//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//
package site

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AresConnectionStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AresConnectionStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AresConnectionStatus) DeepCopy() *AresConnectionStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AresConnectionStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AresConnectionStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AresConnectionStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AresConnectionStatusValidator().Validate(ctx, m, opts...)
}

type ValidateAresConnectionStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAresConnectionStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AresConnectionStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AresConnectionStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["url"]; exists {

		vOpts := append(opts, db.WithValidateField("url"))
		if err := fv(ctx, m.GetUrl(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAresConnectionStatusValidator = func() *ValidateAresConnectionStatus {
	v := &ValidateAresConnectionStatus{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func AresConnectionStatusValidator() db.Validator {
	return DefaultAresConnectionStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *Bios) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Bios) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Bios) DeepCopy() *Bios {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Bios{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Bios) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Bios) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BiosValidator().Validate(ctx, m, opts...)
}

type ValidateBios struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBios) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Bios)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Bios got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["date"]; exists {

		vOpts := append(opts, db.WithValidateField("date"))
		if err := fv(ctx, m.GetDate(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vendor"]; exists {

		vOpts := append(opts, db.WithValidateField("vendor"))
		if err := fv(ctx, m.GetVendor(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBiosValidator = func() *ValidateBios {
	v := &ValidateBios{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func BiosValidator() db.Validator {
	return DefaultBiosValidator
}

// augmented methods on protoc/std generated struct

func (m *Board) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Board) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Board) DeepCopy() *Board {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Board{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Board) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Board) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BoardValidator().Validate(ctx, m, opts...)
}

type ValidateBoard struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBoard) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Board)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Board got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["asset_tag"]; exists {

		vOpts := append(opts, db.WithValidateField("asset_tag"))
		if err := fv(ctx, m.GetAssetTag(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["serial"]; exists {

		vOpts := append(opts, db.WithValidateField("serial"))
		if err := fv(ctx, m.GetSerial(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vendor"]; exists {

		vOpts := append(opts, db.WithValidateField("vendor"))
		if err := fv(ctx, m.GetVendor(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBoardValidator = func() *ValidateBoard {
	v := &ValidateBoard{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func BoardValidator() db.Validator {
	return DefaultBoardValidator
}

// augmented methods on protoc/std generated struct

func (m *BondMembersType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BondMembersType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BondMembersType) DeepCopy() *BondMembersType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BondMembersType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BondMembersType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BondMembersType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BondMembersTypeValidator().Validate(ctx, m, opts...)
}

type ValidateBondMembersType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBondMembersType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BondMembersType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BondMembersType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["link_speed"]; exists {

		vOpts := append(opts, db.WithValidateField("link_speed"))
		if err := fv(ctx, m.GetLinkSpeed(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["link_state"]; exists {

		vOpts := append(opts, db.WithValidateField("link_state"))
		if err := fv(ctx, m.GetLinkState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBondMembersTypeValidator = func() *ValidateBondMembersType {
	v := &ValidateBondMembersType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func BondMembersTypeValidator() db.Validator {
	return DefaultBondMembersTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *Chassis) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Chassis) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Chassis) DeepCopy() *Chassis {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Chassis{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Chassis) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Chassis) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ChassisValidator().Validate(ctx, m, opts...)
}

type ValidateChassis struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateChassis) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Chassis)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Chassis got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["asset_tag"]; exists {

		vOpts := append(opts, db.WithValidateField("asset_tag"))
		if err := fv(ctx, m.GetAssetTag(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["serial"]; exists {

		vOpts := append(opts, db.WithValidateField("serial"))
		if err := fv(ctx, m.GetSerial(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vendor"]; exists {

		vOpts := append(opts, db.WithValidateField("vendor"))
		if err := fv(ctx, m.GetVendor(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultChassisValidator = func() *ValidateChassis {
	v := &ValidateChassis{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ChassisValidator() db.Validator {
	return DefaultChassisValidator
}

// augmented methods on protoc/std generated struct

func (m *Coordinates) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Coordinates) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Coordinates) DeepCopy() *Coordinates {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Coordinates{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Coordinates) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Coordinates) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CoordinatesValidator().Validate(ctx, m, opts...)
}

type ValidateCoordinates struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCoordinates) LatitudeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewFloatValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for latitude")
	}

	return validatorFn, nil
}

func (v *ValidateCoordinates) LongitudeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewFloatValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for longitude")
	}

	return validatorFn, nil
}

func (v *ValidateCoordinates) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Coordinates)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Coordinates got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["latitude"]; exists {

		vOpts := append(opts, db.WithValidateField("latitude"))
		if err := fv(ctx, m.GetLatitude(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["longitude"]; exists {

		vOpts := append(opts, db.WithValidateField("longitude"))
		if err := fv(ctx, m.GetLongitude(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCoordinatesValidator = func() *ValidateCoordinates {
	v := &ValidateCoordinates{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhLatitude := v.LatitudeValidationRuleHandler
	rulesLatitude := map[string]string{
		"ves.io.schema.rules.float.gte": "-90.0",
		"ves.io.schema.rules.float.lte": "90.0",
	}
	vFn, err = vrhLatitude(rulesLatitude)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Coordinates.latitude: %s", err)
		panic(errMsg)
	}
	v.FldValidators["latitude"] = vFn

	vrhLongitude := v.LongitudeValidationRuleHandler
	rulesLongitude := map[string]string{
		"ves.io.schema.rules.float.gte": "-180.0",
		"ves.io.schema.rules.float.lte": "180.0",
	}
	vFn, err = vrhLongitude(rulesLongitude)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Coordinates.longitude: %s", err)
		panic(errMsg)
	}
	v.FldValidators["longitude"] = vFn

	return v
}()

func CoordinatesValidator() db.Validator {
	return DefaultCoordinatesValidator
}

// augmented methods on protoc/std generated struct

func (m *Cpu) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Cpu) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Cpu) DeepCopy() *Cpu {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Cpu{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Cpu) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Cpu) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CpuValidator().Validate(ctx, m, opts...)
}

type ValidateCpu struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCpu) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Cpu)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Cpu got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache"]; exists {

		vOpts := append(opts, db.WithValidateField("cache"))
		if err := fv(ctx, m.GetCache(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cores"]; exists {

		vOpts := append(opts, db.WithValidateField("cores"))
		if err := fv(ctx, m.GetCores(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cpus"]; exists {

		vOpts := append(opts, db.WithValidateField("cpus"))
		if err := fv(ctx, m.GetCpus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["model"]; exists {

		vOpts := append(opts, db.WithValidateField("model"))
		if err := fv(ctx, m.GetModel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["speed"]; exists {

		vOpts := append(opts, db.WithValidateField("speed"))
		if err := fv(ctx, m.GetSpeed(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["threads"]; exists {

		vOpts := append(opts, db.WithValidateField("threads"))
		if err := fv(ctx, m.GetThreads(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vendor"]; exists {

		vOpts := append(opts, db.WithValidateField("vendor"))
		if err := fv(ctx, m.GetVendor(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCpuValidator = func() *ValidateCpu {
	v := &ValidateCpu{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func CpuValidator() db.Validator {
	return DefaultCpuValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateGlobalKubeConfigReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateGlobalKubeConfigReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateGlobalKubeConfigReq) DeepCopy() *CreateGlobalKubeConfigReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateGlobalKubeConfigReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateGlobalKubeConfigReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateGlobalKubeConfigReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateGlobalKubeConfigReqValidator().Validate(ctx, m, opts...)
}

type ValidateCreateGlobalKubeConfigReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateGlobalKubeConfigReq) SiteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site")
	}

	return validatorFn, nil
}

func (v *ValidateCreateGlobalKubeConfigReq) ExpirationTimestampValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var (
		reqdValidatorFn db.ValidatorFunc
		err             error
	)

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if reqdValidatorFn != nil {
			if err = reqdValidatorFn(ctx, val, opts...); err != nil {
				return err
			}
		}
		// TODO: lookup configured third-party type validators
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateGlobalKubeConfigReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateGlobalKubeConfigReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateGlobalKubeConfigReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["expiration_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("expiration_timestamp"))
		if err := fv(ctx, m.GetExpirationTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateGlobalKubeConfigReqValidator = func() *ValidateCreateGlobalKubeConfigReq {
	v := &ValidateCreateGlobalKubeConfigReq{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSite := v.SiteValidationRuleHandler
	rulesSite := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhSite(rulesSite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateGlobalKubeConfigReq.site: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site"] = vFn

	vrhExpirationTimestamp := v.ExpirationTimestampValidationRuleHandler
	rulesExpirationTimestamp := map[string]string{
		"ves.io.schema.rules.timestamp.gt_now":         "true",
		"ves.io.schema.rules.timestamp.within.seconds": "31536000",
	}
	vFn, err = vrhExpirationTimestamp(rulesExpirationTimestamp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateGlobalKubeConfigReq.expiration_timestamp: %s", err)
		panic(errMsg)
	}
	v.FldValidators["expiration_timestamp"] = vFn

	return v
}()

func CreateGlobalKubeConfigReqValidator() db.Validator {
	return DefaultCreateGlobalKubeConfigReqValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateKubeConfigReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateKubeConfigReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateKubeConfigReq) DeepCopy() *CreateKubeConfigReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateKubeConfigReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateKubeConfigReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateKubeConfigReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateKubeConfigReqValidator().Validate(ctx, m, opts...)
}

type ValidateCreateKubeConfigReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateKubeConfigReq) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateCreateKubeConfigReq) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateCreateKubeConfigReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateKubeConfigReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateKubeConfigReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateKubeConfigReqValidator = func() *ValidateCreateKubeConfigReq {
	v := &ValidateCreateKubeConfigReq{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateKubeConfigReq.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateKubeConfigReq.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func CreateKubeConfigReqValidator() db.Validator {
	return DefaultCreateKubeConfigReqValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) SiteTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(SiteType)
		return int32(i)
	}
	// SiteType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, SiteType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_type")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) AddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) InsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_vip")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) SiteToSiteTunnelIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_to_site_tunnel_ip")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) BgpRouterIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bgp_router_id")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) BgpPeerAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bgp_peer_address")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) OutsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_vip")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) InsideNameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) OutsideNameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) DesiredPoolCountValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewInt32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for desired_pool_count")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) TunnelTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.SiteToSiteTunnelType)
		return int32(i)
	}
	// ves_io_schema.SiteToSiteTunnelType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.SiteToSiteTunnelType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_type")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) TunnelDeadTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_dead_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address"]; exists {

		vOpts := append(opts, db.WithValidateField("address"))
		if err := fv(ctx, m.GetAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bgp_peer_address"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_peer_address"))
		if err := fv(ctx, m.GetBgpPeerAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bgp_router_id"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_router_id"))
		if err := fv(ctx, m.GetBgpRouterId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ce_site_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("ce_site_mode"))
		if err := fv(ctx, m.GetCeSiteMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["coordinates"]; exists {

		vOpts := append(opts, db.WithValidateField("coordinates"))
		if err := fv(ctx, m.GetCoordinates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_underlay_network"]; exists {

		vOpts := append(opts, db.WithValidateField("default_underlay_network"))
		if err := fv(ctx, m.GetDefaultUnderlayNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["desired_pool_count"]; exists {

		vOpts := append(opts, db.WithValidateField("desired_pool_count"))
		if err := fv(ctx, m.GetDesiredPoolCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_nameserver"))
		if err := fv(ctx, m.GetInsideNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_vip"))
		if err := fv(ctx, m.GetInsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operating_system_version"]; exists {

		vOpts := append(opts, db.WithValidateField("operating_system_version"))
		if err := fv(ctx, m.GetOperatingSystemVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_nameserver"))
		if err := fv(ctx, m.GetOutsideNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_vip"))
		if err := fv(ctx, m.GetOutsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["region"]; exists {

		vOpts := append(opts, db.WithValidateField("region"))
		if err := fv(ctx, m.GetRegion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_network_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_to_site_network_type"))
		if err := fv(ctx, m.GetSiteToSiteNetworkType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_tunnel_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("site_to_site_tunnel_ip"))
		if err := fv(ctx, m.GetSiteToSiteTunnelIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_type"))
		if err := fv(ctx, m.GetSiteType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_dead_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_dead_timeout"))
		if err := fv(ctx, m.GetTunnelDeadTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_type"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_type"))
		if err := fv(ctx, m.GetTunnelType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vip_vrrp_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("vip_vrrp_mode"))
		if err := fv(ctx, m.GetVipVrrpMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_overide"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_overide"))
		if err := fv(ctx, m.GetVolterraSoftwareOveride(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSiteType := v.SiteTypeValidationRuleHandler
	rulesSiteType := map[string]string{
		"ves.io.schema.rules.enum.not_in": "0",
	}
	vFn, err = vrhSiteType(rulesSiteType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.site_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_type"] = vFn

	vrhAddress := v.AddressValidationRuleHandler
	rulesAddress := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhAddress(rulesAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address"] = vFn

	vrhInsideVip := v.InsideVipValidationRuleHandler
	rulesInsideVip := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhInsideVip(rulesInsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.inside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_vip"] = vFn

	vrhSiteToSiteTunnelIp := v.SiteToSiteTunnelIpValidationRuleHandler
	rulesSiteToSiteTunnelIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhSiteToSiteTunnelIp(rulesSiteToSiteTunnelIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.site_to_site_tunnel_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_to_site_tunnel_ip"] = vFn

	vrhBgpRouterId := v.BgpRouterIdValidationRuleHandler
	rulesBgpRouterId := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhBgpRouterId(rulesBgpRouterId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.bgp_router_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bgp_router_id"] = vFn

	vrhBgpPeerAddress := v.BgpPeerAddressValidationRuleHandler
	rulesBgpPeerAddress := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhBgpPeerAddress(rulesBgpPeerAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.bgp_peer_address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bgp_peer_address"] = vFn

	vrhOutsideVip := v.OutsideVipValidationRuleHandler
	rulesOutsideVip := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhOutsideVip(rulesOutsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.outside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_vip"] = vFn

	vrhInsideNameserver := v.InsideNameserverValidationRuleHandler
	rulesInsideNameserver := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhInsideNameserver(rulesInsideNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.inside_nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_nameserver"] = vFn

	vrhOutsideNameserver := v.OutsideNameserverValidationRuleHandler
	rulesOutsideNameserver := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhOutsideNameserver(rulesOutsideNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.outside_nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_nameserver"] = vFn

	vrhDesiredPoolCount := v.DesiredPoolCountValidationRuleHandler
	rulesDesiredPoolCount := map[string]string{
		"ves.io.schema.rules.int32.gte": "-1",
		"ves.io.schema.rules.int32.lte": "64",
	}
	vFn, err = vrhDesiredPoolCount(rulesDesiredPoolCount)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.desired_pool_count: %s", err)
		panic(errMsg)
	}
	v.FldValidators["desired_pool_count"] = vFn

	vrhTunnelType := v.TunnelTypeValidationRuleHandler
	rulesTunnelType := map[string]string{
		"ves.io.schema.rules.enum.in": "[0,1,2]",
	}
	vFn, err = vrhTunnelType(rulesTunnelType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.tunnel_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_type"] = vFn

	vrhTunnelDeadTimeout := v.TunnelDeadTimeoutValidationRuleHandler
	rulesTunnelDeadTimeout := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "180000",
	}
	vFn, err = vrhTunnelDeadTimeout(rulesTunnelDeadTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.tunnel_dead_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_dead_timeout"] = vFn

	v.FldValidators["coordinates"] = CoordinatesValidator().Validate

	v.FldValidators["default_underlay_network"] = DefaultUnderlayNetworkTypeValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DefaultUnderlayNetworkType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DefaultUnderlayNetworkType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DefaultUnderlayNetworkType) DeepCopy() *DefaultUnderlayNetworkType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DefaultUnderlayNetworkType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DefaultUnderlayNetworkType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DefaultUnderlayNetworkType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DefaultUnderlayNetworkTypeValidator().Validate(ctx, m, opts...)
}

type ValidateDefaultUnderlayNetworkType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDefaultUnderlayNetworkType) PrivateAccessChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for private_access_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDefaultUnderlayNetworkType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DefaultUnderlayNetworkType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DefaultUnderlayNetworkType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["private_access_choice"]; exists {
		val := m.GetPrivateAccessChoice()
		vOpts := append(opts,
			db.WithValidateField("private_access_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPrivateAccessChoice().(type) {
	case *DefaultUnderlayNetworkType_SiteLocalOutside:
		if fv, exists := v.FldValidators["private_access_choice.site_local_outside"]; exists {
			val := m.GetPrivateAccessChoice().(*DefaultUnderlayNetworkType_SiteLocalOutside).SiteLocalOutside
			vOpts := append(opts,
				db.WithValidateField("private_access_choice"),
				db.WithValidateField("site_local_outside"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DefaultUnderlayNetworkType_SiteLocalInside:
		if fv, exists := v.FldValidators["private_access_choice.site_local_inside"]; exists {
			val := m.GetPrivateAccessChoice().(*DefaultUnderlayNetworkType_SiteLocalInside).SiteLocalInside
			vOpts := append(opts,
				db.WithValidateField("private_access_choice"),
				db.WithValidateField("site_local_inside"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDefaultUnderlayNetworkTypeValidator = func() *ValidateDefaultUnderlayNetworkType {
	v := &ValidateDefaultUnderlayNetworkType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPrivateAccessChoice := v.PrivateAccessChoiceValidationRuleHandler
	rulesPrivateAccessChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPrivateAccessChoice(rulesPrivateAccessChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DefaultUnderlayNetworkType.private_access_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["private_access_choice"] = vFn

	return v
}()

func DefaultUnderlayNetworkTypeValidator() db.Validator {
	return DefaultDefaultUnderlayNetworkTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DeploymentState) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DeploymentState) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DeploymentState) DeepCopy() *DeploymentState {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DeploymentState{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DeploymentState) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DeploymentState) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DeploymentStateValidator().Validate(ctx, m, opts...)
}

type ValidateDeploymentState struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDeploymentState) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DeploymentState)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DeploymentState got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["message"]; exists {

		vOpts := append(opts, db.WithValidateField("message"))
		if err := fv(ctx, m.GetMessage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["modification_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("modification_timestamp"))
		if err := fv(ctx, m.GetModificationTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["phase"]; exists {

		vOpts := append(opts, db.WithValidateField("phase"))
		if err := fv(ctx, m.GetPhase(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["result"]; exists {

		vOpts := append(opts, db.WithValidateField("result"))
		if err := fv(ctx, m.GetResult(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDeploymentStateValidator = func() *ValidateDeploymentState {
	v := &ValidateDeploymentState{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DeploymentStateValidator() db.Validator {
	return DefaultDeploymentStateValidator
}

// augmented methods on protoc/std generated struct

func (m *FleetCondition) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FleetCondition) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FleetCondition) DeepCopy() *FleetCondition {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FleetCondition{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FleetCondition) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FleetCondition) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FleetConditionValidator().Validate(ctx, m, opts...)
}

type ValidateFleetCondition struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFleetCondition) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FleetCondition)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FleetCondition got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["message"]; exists {

		vOpts := append(opts, db.WithValidateField("message"))
		if err := fv(ctx, m.GetMessage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["module_name"]; exists {

		vOpts := append(opts, db.WithValidateField("module_name"))
		if err := fv(ctx, m.GetModuleName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["result"]; exists {

		vOpts := append(opts, db.WithValidateField("result"))
		if err := fv(ctx, m.GetResult(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFleetConditionValidator = func() *ValidateFleetCondition {
	v := &ValidateFleetCondition{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FleetConditionValidator() db.Validator {
	return DefaultFleetConditionValidator
}

// augmented methods on protoc/std generated struct

func (m *FleetDeploymentState) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FleetDeploymentState) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FleetDeploymentState) DeepCopy() *FleetDeploymentState {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FleetDeploymentState{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FleetDeploymentState) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FleetDeploymentState) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FleetDeploymentStateValidator().Validate(ctx, m, opts...)
}

type ValidateFleetDeploymentState struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFleetDeploymentState) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FleetDeploymentState)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FleetDeploymentState got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["condition"]; exists {

		vOpts := append(opts, db.WithValidateField("condition"))
		for idx, item := range m.GetCondition() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["hash"]; exists {

		vOpts := append(opts, db.WithValidateField("hash"))
		if err := fv(ctx, m.GetHash(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["modification_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("modification_timestamp"))
		if err := fv(ctx, m.GetModificationTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["result"]; exists {

		vOpts := append(opts, db.WithValidateField("result"))
		if err := fv(ctx, m.GetResult(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFleetDeploymentStateValidator = func() *ValidateFleetDeploymentState {
	v := &ValidateFleetDeploymentState{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FleetDeploymentStateValidator() db.Validator {
	return DefaultFleetDeploymentStateValidator
}

// augmented methods on protoc/std generated struct

func (m *FleetStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FleetStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FleetStatus) DeepCopy() *FleetStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FleetStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FleetStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FleetStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FleetStatusValidator().Validate(ctx, m, opts...)
}

type ValidateFleetStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFleetStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FleetStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FleetStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["deployment_state"]; exists {

		vOpts := append(opts, db.WithValidateField("deployment_state"))
		if err := fv(ctx, m.GetDeploymentState(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFleetStatusValidator = func() *ValidateFleetStatus {
	v := &ValidateFleetStatus{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FleetStatusValidator() db.Validator {
	return DefaultFleetStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *GPU) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GPU) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GPU) DeepCopy() *GPU {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GPU{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GPU) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GPU) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GPUValidator().Validate(ctx, m, opts...)
}

type ValidateGPU struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGPU) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GPU)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GPU got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cuda_version"]; exists {

		vOpts := append(opts, db.WithValidateField("cuda_version"))
		if err := fv(ctx, m.GetCudaVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["driver_version"]; exists {

		vOpts := append(opts, db.WithValidateField("driver_version"))
		if err := fv(ctx, m.GetDriverVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gpu_device"]; exists {

		vOpts := append(opts, db.WithValidateField("gpu_device"))
		for idx, item := range m.GetGpuDevice() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGPUValidator = func() *ValidateGPU {
	v := &ValidateGPU{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GPUValidator() db.Validator {
	return DefaultGPUValidator
}

// augmented methods on protoc/std generated struct

func (m *GPUDevice) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GPUDevice) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GPUDevice) DeepCopy() *GPUDevice {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GPUDevice{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GPUDevice) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GPUDevice) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GPUDeviceValidator().Validate(ctx, m, opts...)
}

type ValidateGPUDevice struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGPUDevice) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GPUDevice)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GPUDevice got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["processes"]; exists {

		vOpts := append(opts, db.WithValidateField("processes"))
		if err := fv(ctx, m.GetProcesses(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["product_name"]; exists {

		vOpts := append(opts, db.WithValidateField("product_name"))
		if err := fv(ctx, m.GetProductName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGPUDeviceValidator = func() *ValidateGPUDevice {
	v := &ValidateGPUDevice{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GPUDeviceValidator() db.Validator {
	return DefaultGPUDeviceValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GetSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetConnectedReDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetConnectedReForConfigDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *GetSpecType) GetConnectedReDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetConnectedRe() {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.connected_re[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "site.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "connected_re",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetConnectedReDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetConnectedReDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: site")
	}
	for _, ref := range m.GetConnectedRe() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GetSpecType) GetConnectedReForConfigDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetConnectedReForConfig() {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.connected_re_for_config[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "site.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "connected_re_for_config",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetConnectedReForConfigDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetConnectedReForConfigDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: site")
	}
	for _, ref := range m.GetConnectedReForConfig() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) SiteTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(SiteType)
		return int32(i)
	}
	// SiteType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, SiteType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_type")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) AddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) ConnectedReValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for connected_re")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated connected_re")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items connected_re")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) ConnectedReForConfigValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for connected_re_for_config")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated connected_re_for_config")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items connected_re_for_config")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) InsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_vip")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) SiteToSiteTunnelIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_to_site_tunnel_ip")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) BgpRouterIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bgp_router_id")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) BgpPeerAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bgp_peer_address")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) OutsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_vip")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) InsideNameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) OutsideNameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) DesiredPoolCountValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewInt32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for desired_pool_count")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) TunnelTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.SiteToSiteTunnelType)
		return int32(i)
	}
	// ves_io_schema.SiteToSiteTunnelType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.SiteToSiteTunnelType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_type")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) TunnelDeadTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_dead_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) VipParamsPerAzValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*PublishVIPParamsPerAz, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := PublishVIPParamsPerAzValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for vip_params_per_az")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*PublishVIPParamsPerAz)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*PublishVIPParamsPerAz, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated vip_params_per_az")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items vip_params_per_az")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address"]; exists {

		vOpts := append(opts, db.WithValidateField("address"))
		if err := fv(ctx, m.GetAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bgp_peer_address"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_peer_address"))
		if err := fv(ctx, m.GetBgpPeerAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bgp_router_id"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_router_id"))
		if err := fv(ctx, m.GetBgpRouterId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ce_site_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("ce_site_mode"))
		if err := fv(ctx, m.GetCeSiteMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["connected_re"]; exists {
		vOpts := append(opts, db.WithValidateField("connected_re"))
		if err := fv(ctx, m.GetConnectedRe(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["connected_re_for_config"]; exists {
		vOpts := append(opts, db.WithValidateField("connected_re_for_config"))
		if err := fv(ctx, m.GetConnectedReForConfig(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["coordinates"]; exists {

		vOpts := append(opts, db.WithValidateField("coordinates"))
		if err := fv(ctx, m.GetCoordinates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_underlay_network"]; exists {

		vOpts := append(opts, db.WithValidateField("default_underlay_network"))
		if err := fv(ctx, m.GetDefaultUnderlayNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["desired_pool_count"]; exists {

		vOpts := append(opts, db.WithValidateField("desired_pool_count"))
		if err := fv(ctx, m.GetDesiredPoolCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["global_access_k8s_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("global_access_k8s_enabled"))
		if err := fv(ctx, m.GetGlobalAccessK8SEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_nameserver"))
		if err := fv(ctx, m.GetInsideNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_vip"))
		if err := fv(ctx, m.GetInsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["local_access_k8s_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("local_access_k8s_enabled"))
		if err := fv(ctx, m.GetLocalAccessK8SEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["local_k8s_access_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("local_k8s_access_enabled"))
		if err := fv(ctx, m.GetLocalK8SAccessEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operating_system_version"]; exists {

		vOpts := append(opts, db.WithValidateField("operating_system_version"))
		if err := fv(ctx, m.GetOperatingSystemVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_nameserver"))
		if err := fv(ctx, m.GetOutsideNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_vip"))
		if err := fv(ctx, m.GetOutsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["region"]; exists {

		vOpts := append(opts, db.WithValidateField("region"))
		if err := fv(ctx, m.GetRegion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_state"]; exists {

		vOpts := append(opts, db.WithValidateField("site_state"))
		if err := fv(ctx, m.GetSiteState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_subtype"]; exists {

		vOpts := append(opts, db.WithValidateField("site_subtype"))
		if err := fv(ctx, m.GetSiteSubtype(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_network_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_to_site_network_type"))
		if err := fv(ctx, m.GetSiteToSiteNetworkType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_tunnel_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("site_to_site_tunnel_ip"))
		if err := fv(ctx, m.GetSiteToSiteTunnelIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_type"))
		if err := fv(ctx, m.GetSiteType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_dead_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_dead_timeout"))
		if err := fv(ctx, m.GetTunnelDeadTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_type"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_type"))
		if err := fv(ctx, m.GetTunnelType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vip_params_per_az"]; exists {
		vOpts := append(opts, db.WithValidateField("vip_params_per_az"))
		if err := fv(ctx, m.GetVipParamsPerAz(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vip_vrrp_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("vip_vrrp_mode"))
		if err := fv(ctx, m.GetVipVrrpMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_overide"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_overide"))
		if err := fv(ctx, m.GetVolterraSoftwareOveride(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_version"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_version"))
		if err := fv(ctx, m.GetVolterraSoftwareVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSiteType := v.SiteTypeValidationRuleHandler
	rulesSiteType := map[string]string{
		"ves.io.schema.rules.enum.not_in": "0",
	}
	vFn, err = vrhSiteType(rulesSiteType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.site_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_type"] = vFn

	vrhAddress := v.AddressValidationRuleHandler
	rulesAddress := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhAddress(rulesAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address"] = vFn

	vrhConnectedRe := v.ConnectedReValidationRuleHandler
	rulesConnectedRe := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhConnectedRe(rulesConnectedRe)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.connected_re: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connected_re"] = vFn

	vrhConnectedReForConfig := v.ConnectedReForConfigValidationRuleHandler
	rulesConnectedReForConfig := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhConnectedReForConfig(rulesConnectedReForConfig)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.connected_re_for_config: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connected_re_for_config"] = vFn

	vrhInsideVip := v.InsideVipValidationRuleHandler
	rulesInsideVip := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhInsideVip(rulesInsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.inside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_vip"] = vFn

	vrhSiteToSiteTunnelIp := v.SiteToSiteTunnelIpValidationRuleHandler
	rulesSiteToSiteTunnelIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhSiteToSiteTunnelIp(rulesSiteToSiteTunnelIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.site_to_site_tunnel_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_to_site_tunnel_ip"] = vFn

	vrhBgpRouterId := v.BgpRouterIdValidationRuleHandler
	rulesBgpRouterId := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhBgpRouterId(rulesBgpRouterId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.bgp_router_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bgp_router_id"] = vFn

	vrhBgpPeerAddress := v.BgpPeerAddressValidationRuleHandler
	rulesBgpPeerAddress := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhBgpPeerAddress(rulesBgpPeerAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.bgp_peer_address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bgp_peer_address"] = vFn

	vrhOutsideVip := v.OutsideVipValidationRuleHandler
	rulesOutsideVip := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhOutsideVip(rulesOutsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.outside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_vip"] = vFn

	vrhInsideNameserver := v.InsideNameserverValidationRuleHandler
	rulesInsideNameserver := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhInsideNameserver(rulesInsideNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.inside_nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_nameserver"] = vFn

	vrhOutsideNameserver := v.OutsideNameserverValidationRuleHandler
	rulesOutsideNameserver := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhOutsideNameserver(rulesOutsideNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.outside_nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_nameserver"] = vFn

	vrhDesiredPoolCount := v.DesiredPoolCountValidationRuleHandler
	rulesDesiredPoolCount := map[string]string{
		"ves.io.schema.rules.int32.gte": "-1",
		"ves.io.schema.rules.int32.lte": "64",
	}
	vFn, err = vrhDesiredPoolCount(rulesDesiredPoolCount)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.desired_pool_count: %s", err)
		panic(errMsg)
	}
	v.FldValidators["desired_pool_count"] = vFn

	vrhTunnelType := v.TunnelTypeValidationRuleHandler
	rulesTunnelType := map[string]string{
		"ves.io.schema.rules.enum.in": "[0,1,2]",
	}
	vFn, err = vrhTunnelType(rulesTunnelType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.tunnel_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_type"] = vFn

	vrhTunnelDeadTimeout := v.TunnelDeadTimeoutValidationRuleHandler
	rulesTunnelDeadTimeout := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "180000",
	}
	vFn, err = vrhTunnelDeadTimeout(rulesTunnelDeadTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.tunnel_dead_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_dead_timeout"] = vFn

	vrhVipParamsPerAz := v.VipParamsPerAzValidationRuleHandler
	rulesVipParamsPerAz := map[string]string{
		"ves.io.schema.rules.repeated.num_items": "0,1,3",
	}
	vFn, err = vrhVipParamsPerAz(rulesVipParamsPerAz)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.vip_params_per_az: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vip_params_per_az"] = vFn

	v.FldValidators["coordinates"] = CoordinatesValidator().Validate

	v.FldValidators["default_underlay_network"] = DefaultUnderlayNetworkTypeValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalAccessCheckRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalAccessCheckRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GlobalAccessCheckRequest) DeepCopy() *GlobalAccessCheckRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalAccessCheckRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalAccessCheckRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalAccessCheckRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalAccessCheckRequestValidator().Validate(ctx, m, opts...)
}

type ValidateGlobalAccessCheckRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalAccessCheckRequest) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalAccessCheckRequest) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalAccessCheckRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalAccessCheckRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalAccessCheckRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalAccessCheckRequestValidator = func() *ValidateGlobalAccessCheckRequest {
	v := &ValidateGlobalAccessCheckRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalAccessCheckRequest.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalAccessCheckRequest.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func GlobalAccessCheckRequestValidator() db.Validator {
	return DefaultGlobalAccessCheckRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalAccessCheckResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalAccessCheckResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GlobalAccessCheckResponse) DeepCopy() *GlobalAccessCheckResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalAccessCheckResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalAccessCheckResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalAccessCheckResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalAccessCheckResponseValidator().Validate(ctx, m, opts...)
}

type ValidateGlobalAccessCheckResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalAccessCheckResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalAccessCheckResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalAccessCheckResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("enabled"))
		if err := fv(ctx, m.GetEnabled(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalAccessCheckResponseValidator = func() *ValidateGlobalAccessCheckResponse {
	v := &ValidateGlobalAccessCheckResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GlobalAccessCheckResponseValidator() db.Validator {
	return DefaultGlobalAccessCheckResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetConnectedReDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetConnectedReForConfigDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetK8SClusterApiGwDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *GlobalSpecType) GetConnectedReDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetConnectedRe() {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.connected_re[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "site.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "connected_re",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetConnectedReDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetConnectedReDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: site")
	}
	for _, ref := range m.GetConnectedRe() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetConnectedReForConfigDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetConnectedReForConfig() {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.connected_re_for_config[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "site.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "connected_re_for_config",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetConnectedReForConfigDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetConnectedReForConfigDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: site")
	}
	for _, ref := range m.GetConnectedReForConfig() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetK8SClusterApiGwDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetK8SClusterApiGw() {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.k8s_cluster_api_gw[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_host.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "k8s_cluster_api_gw",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetK8SClusterApiGwDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetK8SClusterApiGwDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_host.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_host")
	}
	for _, ref := range m.GetK8SClusterApiGw() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) SiteTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(SiteType)
		return int32(i)
	}
	// SiteType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, SiteType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_type")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) AddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ConnectedReValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for connected_re")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated connected_re")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items connected_re")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ConnectedReForConfigValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for connected_re_for_config")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated connected_re_for_config")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items connected_re_for_config")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) StaticRoutesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for static_routes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for static_routes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated static_routes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items static_routes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) PublicIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for public_ip")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ClusterIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cluster_ip")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) InsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_vip")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) SiteToSiteTunnelIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_to_site_tunnel_ip")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) BgpRouterIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bgp_router_id")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) BgpPeerAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bgp_peer_address")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) OutsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_vip")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) InsideNameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) OutsideNameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) DesiredPoolCountValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewInt32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for desired_pool_count")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) TunnelTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.SiteToSiteTunnelType)
		return int32(i)
	}
	// ves_io_schema.SiteToSiteTunnelType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.SiteToSiteTunnelType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_type")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) TunnelDeadTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_dead_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) K8SClusterApiGwValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for k8s_cluster_api_gw")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated k8s_cluster_api_gw")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items k8s_cluster_api_gw")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) PrivateIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for private_ip")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) IpsecSslVipFqdnValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ipsec_ssl_vip_fqdn")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) VipParamsPerAzValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*PublishVIPParamsPerAz, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := PublishVIPParamsPerAzValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for vip_params_per_az")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*PublishVIPParamsPerAz)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*PublishVIPParamsPerAz, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated vip_params_per_az")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items vip_params_per_az")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address"]; exists {

		vOpts := append(opts, db.WithValidateField("address"))
		if err := fv(ctx, m.GetAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ares_list"]; exists {

		vOpts := append(opts, db.WithValidateField("ares_list"))
		for idx, item := range m.GetAresList() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["ares_vtrp_list"]; exists {

		vOpts := append(opts, db.WithValidateField("ares_vtrp_list"))
		for idx, item := range m.GetAresVtrpList() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["bgp_peer_address"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_peer_address"))
		if err := fv(ctx, m.GetBgpPeerAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bgp_router_id"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_router_id"))
		if err := fv(ctx, m.GetBgpRouterId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ce_site_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("ce_site_mode"))
		if err := fv(ctx, m.GetCeSiteMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cluster_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("cluster_ip"))
		if err := fv(ctx, m.GetClusterIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["connected_re"]; exists {
		vOpts := append(opts, db.WithValidateField("connected_re"))
		if err := fv(ctx, m.GetConnectedRe(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["connected_re_for_config"]; exists {
		vOpts := append(opts, db.WithValidateField("connected_re_for_config"))
		if err := fv(ctx, m.GetConnectedReForConfig(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["coordinates"]; exists {

		vOpts := append(opts, db.WithValidateField("coordinates"))
		if err := fv(ctx, m.GetCoordinates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_underlay_network"]; exists {

		vOpts := append(opts, db.WithValidateField("default_underlay_network"))
		if err := fv(ctx, m.GetDefaultUnderlayNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["desired_pool_count"]; exists {

		vOpts := append(opts, db.WithValidateField("desired_pool_count"))
		if err := fv(ctx, m.GetDesiredPoolCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_nameserver"))
		if err := fv(ctx, m.GetInsideNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_vip"))
		if err := fv(ctx, m.GetInsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ipsec_ssl_vip_fqdn"]; exists {

		vOpts := append(opts, db.WithValidateField("ipsec_ssl_vip_fqdn"))
		if err := fv(ctx, m.GetIpsecSslVipFqdn(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["k8s_api_servers"]; exists {

		vOpts := append(opts, db.WithValidateField("k8s_api_servers"))
		for key, value := range m.GetK8SApiServers() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["k8s_cluster_api_gw"]; exists {
		vOpts := append(opts, db.WithValidateField("k8s_cluster_api_gw"))
		if err := fv(ctx, m.GetK8SClusterApiGw(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["local_k8s_access_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("local_k8s_access_enabled"))
		if err := fv(ctx, m.GetLocalK8SAccessEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mars_list"]; exists {

		vOpts := append(opts, db.WithValidateField("mars_list"))
		for idx, item := range m.GetMarsList() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["mars_vtrp_list"]; exists {

		vOpts := append(opts, db.WithValidateField("mars_vtrp_list"))
		for idx, item := range m.GetMarsVtrpList() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["no_tenant_in_vk8s_ns"]; exists {

		vOpts := append(opts, db.WithValidateField("no_tenant_in_vk8s_ns"))
		if err := fv(ctx, m.GetNoTenantInVk8SNs(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["opera"]; exists {

		vOpts := append(opts, db.WithValidateField("opera"))
		if err := fv(ctx, m.GetOpera(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operating_system_version"]; exists {

		vOpts := append(opts, db.WithValidateField("operating_system_version"))
		if err := fv(ctx, m.GetOperatingSystemVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_nameserver"))
		if err := fv(ctx, m.GetOutsideNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_vip"))
		if err := fv(ctx, m.GetOutsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["phobos_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("phobos_enabled"))
		if err := fv(ctx, m.GetPhobosEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["piku_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("piku_enabled"))
		if err := fv(ctx, m.GetPikuEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["private_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("private_ip"))
		if err := fv(ctx, m.GetPrivateIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["public_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("public_ip"))
		if err := fv(ctx, m.GetPublicIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rakar"]; exists {

		vOpts := append(opts, db.WithValidateField("rakar"))
		if err := fv(ctx, m.GetRakar(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["region"]; exists {

		vOpts := append(opts, db.WithValidateField("region"))
		if err := fv(ctx, m.GetRegion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_state"]; exists {

		vOpts := append(opts, db.WithValidateField("site_state"))
		if err := fv(ctx, m.GetSiteState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_subtype"]; exists {

		vOpts := append(opts, db.WithValidateField("site_subtype"))
		if err := fv(ctx, m.GetSiteSubtype(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_network_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_to_site_network_type"))
		if err := fv(ctx, m.GetSiteToSiteNetworkType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_tunnel_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("site_to_site_tunnel_ip"))
		if err := fv(ctx, m.GetSiteToSiteTunnelIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_type"))
		if err := fv(ctx, m.GetSiteType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["srv6_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("srv6_enabled"))
		if err := fv(ctx, m.GetSrv6Enabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["static_routes"]; exists {
		vOpts := append(opts, db.WithValidateField("static_routes"))
		if err := fv(ctx, m.GetStaticRoutes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["template_parameters"]; exists {

		vOpts := append(opts, db.WithValidateField("template_parameters"))
		for key, value := range m.GetTemplateParameters() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tenant_index"]; exists {

		vOpts := append(opts, db.WithValidateField("tenant_index"))
		if err := fv(ctx, m.GetTenantIndex(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_dead_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_dead_timeout"))
		if err := fv(ctx, m.GetTunnelDeadTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_type"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_type"))
		if err := fv(ctx, m.GetTunnelType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["use_private_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("use_private_ip"))
		if err := fv(ctx, m.GetUsePrivateIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vega"]; exists {

		vOpts := append(opts, db.WithValidateField("vega"))
		if err := fv(ctx, m.GetVega(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vip_params_per_az"]; exists {
		vOpts := append(opts, db.WithValidateField("vip_params_per_az"))
		if err := fv(ctx, m.GetVipParamsPerAz(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vip_vrrp_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("vip_vrrp_mode"))
		if err := fv(ctx, m.GetVipVrrpMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_overide"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_overide"))
		if err := fv(ctx, m.GetVolterraSoftwareOveride(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_version"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_version"))
		if err := fv(ctx, m.GetVolterraSoftwareVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSiteType := v.SiteTypeValidationRuleHandler
	rulesSiteType := map[string]string{
		"ves.io.schema.rules.enum.not_in": "0",
	}
	vFn, err = vrhSiteType(rulesSiteType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.site_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_type"] = vFn

	vrhAddress := v.AddressValidationRuleHandler
	rulesAddress := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhAddress(rulesAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address"] = vFn

	vrhConnectedRe := v.ConnectedReValidationRuleHandler
	rulesConnectedRe := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhConnectedRe(rulesConnectedRe)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.connected_re: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connected_re"] = vFn

	vrhConnectedReForConfig := v.ConnectedReForConfigValidationRuleHandler
	rulesConnectedReForConfig := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhConnectedReForConfig(rulesConnectedReForConfig)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.connected_re_for_config: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connected_re_for_config"] = vFn

	vrhStaticRoutes := v.StaticRoutesValidationRuleHandler
	rulesStaticRoutes := map[string]string{
		"ves.io.schema.rules.message.required":                  "true",
		"ves.io.schema.rules.repeated.items.string.ipv4_prefix": "true",
	}
	vFn, err = vrhStaticRoutes(rulesStaticRoutes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.static_routes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["static_routes"] = vFn

	vrhPublicIp := v.PublicIpValidationRuleHandler
	rulesPublicIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhPublicIp(rulesPublicIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.public_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["public_ip"] = vFn

	vrhClusterIp := v.ClusterIpValidationRuleHandler
	rulesClusterIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhClusterIp(rulesClusterIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.cluster_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cluster_ip"] = vFn

	vrhInsideVip := v.InsideVipValidationRuleHandler
	rulesInsideVip := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhInsideVip(rulesInsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.inside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_vip"] = vFn

	vrhSiteToSiteTunnelIp := v.SiteToSiteTunnelIpValidationRuleHandler
	rulesSiteToSiteTunnelIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhSiteToSiteTunnelIp(rulesSiteToSiteTunnelIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.site_to_site_tunnel_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_to_site_tunnel_ip"] = vFn

	vrhBgpRouterId := v.BgpRouterIdValidationRuleHandler
	rulesBgpRouterId := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhBgpRouterId(rulesBgpRouterId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.bgp_router_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bgp_router_id"] = vFn

	vrhBgpPeerAddress := v.BgpPeerAddressValidationRuleHandler
	rulesBgpPeerAddress := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhBgpPeerAddress(rulesBgpPeerAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.bgp_peer_address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bgp_peer_address"] = vFn

	vrhOutsideVip := v.OutsideVipValidationRuleHandler
	rulesOutsideVip := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhOutsideVip(rulesOutsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.outside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_vip"] = vFn

	vrhInsideNameserver := v.InsideNameserverValidationRuleHandler
	rulesInsideNameserver := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhInsideNameserver(rulesInsideNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.inside_nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_nameserver"] = vFn

	vrhOutsideNameserver := v.OutsideNameserverValidationRuleHandler
	rulesOutsideNameserver := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhOutsideNameserver(rulesOutsideNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.outside_nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_nameserver"] = vFn

	vrhDesiredPoolCount := v.DesiredPoolCountValidationRuleHandler
	rulesDesiredPoolCount := map[string]string{
		"ves.io.schema.rules.int32.gte": "-1",
		"ves.io.schema.rules.int32.lte": "64",
	}
	vFn, err = vrhDesiredPoolCount(rulesDesiredPoolCount)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.desired_pool_count: %s", err)
		panic(errMsg)
	}
	v.FldValidators["desired_pool_count"] = vFn

	vrhTunnelType := v.TunnelTypeValidationRuleHandler
	rulesTunnelType := map[string]string{
		"ves.io.schema.rules.enum.in": "[0,1,2]",
	}
	vFn, err = vrhTunnelType(rulesTunnelType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.tunnel_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_type"] = vFn

	vrhTunnelDeadTimeout := v.TunnelDeadTimeoutValidationRuleHandler
	rulesTunnelDeadTimeout := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "180000",
	}
	vFn, err = vrhTunnelDeadTimeout(rulesTunnelDeadTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.tunnel_dead_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_dead_timeout"] = vFn

	vrhK8SClusterApiGw := v.K8SClusterApiGwValidationRuleHandler
	rulesK8SClusterApiGw := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhK8SClusterApiGw(rulesK8SClusterApiGw)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.k8s_cluster_api_gw: %s", err)
		panic(errMsg)
	}
	v.FldValidators["k8s_cluster_api_gw"] = vFn

	vrhPrivateIp := v.PrivateIpValidationRuleHandler
	rulesPrivateIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhPrivateIp(rulesPrivateIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.private_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["private_ip"] = vFn

	vrhIpsecSslVipFqdn := v.IpsecSslVipFqdnValidationRuleHandler
	rulesIpsecSslVipFqdn := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
	}
	vFn, err = vrhIpsecSslVipFqdn(rulesIpsecSslVipFqdn)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.ipsec_ssl_vip_fqdn: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ipsec_ssl_vip_fqdn"] = vFn

	vrhVipParamsPerAz := v.VipParamsPerAzValidationRuleHandler
	rulesVipParamsPerAz := map[string]string{
		"ves.io.schema.rules.repeated.num_items": "0,1,3",
	}
	vFn, err = vrhVipParamsPerAz(rulesVipParamsPerAz)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.vip_params_per_az: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vip_params_per_az"] = vFn

	v.FldValidators["coordinates"] = CoordinatesValidator().Validate

	v.FldValidators["default_underlay_network"] = DefaultUnderlayNetworkTypeValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *InterfaceStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *InterfaceStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *InterfaceStatus) DeepCopy() *InterfaceStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &InterfaceStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *InterfaceStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *InterfaceStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return InterfaceStatusValidator().Validate(ctx, m, opts...)
}

type ValidateInterfaceStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInterfaceStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*InterfaceStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *InterfaceStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["active_state"]; exists {

		vOpts := append(opts, db.WithValidateField("active_state"))
		if err := fv(ctx, m.GetActiveState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bond_members"]; exists {

		vOpts := append(opts, db.WithValidateField("bond_members"))
		for idx, item := range m.GetBondMembers() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["dhcp_server"]; exists {

		vOpts := append(opts, db.WithValidateField("dhcp_server"))
		if err := fv(ctx, m.GetDhcpServer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip"]; exists {

		vOpts := append(opts, db.WithValidateField("ip"))
		if err := fv(ctx, m.GetIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("ip_mode"))
		if err := fv(ctx, m.GetIpMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ipv6"]; exists {

		vOpts := append(opts, db.WithValidateField("ipv6"))
		if err := fv(ctx, m.GetIpv6(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["link_quality"]; exists {

		vOpts := append(opts, db.WithValidateField("link_quality"))
		if err := fv(ctx, m.GetLinkQuality(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["link_state"]; exists {

		vOpts := append(opts, db.WithValidateField("link_state"))
		if err := fv(ctx, m.GetLinkState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["link_type"]; exists {

		vOpts := append(opts, db.WithValidateField("link_type"))
		if err := fv(ctx, m.GetLinkType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mac"]; exists {

		vOpts := append(opts, db.WithValidateField("mac"))
		if err := fv(ctx, m.GetMac(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network_name"]; exists {

		vOpts := append(opts, db.WithValidateField("network_name"))
		if err := fv(ctx, m.GetNetworkName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network_type"]; exists {

		vOpts := append(opts, db.WithValidateField("network_type"))
		if err := fv(ctx, m.GetNetworkType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInterfaceStatusValidator = func() *ValidateInterfaceStatus {
	v := &ValidateInterfaceStatus{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["ip"] = ves_io_schema.IpSubnetTypeValidator().Validate

	v.FldValidators["ipv6"] = ves_io_schema.IpSubnetTypeValidator().Validate

	return v
}()

func InterfaceStatusValidator() db.Validator {
	return DefaultInterfaceStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *IpsecConnectionStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IpsecConnectionStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IpsecConnectionStatus) DeepCopy() *IpsecConnectionStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IpsecConnectionStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IpsecConnectionStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IpsecConnectionStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IpsecConnectionStatusValidator().Validate(ctx, m, opts...)
}

type ValidateIpsecConnectionStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIpsecConnectionStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IpsecConnectionStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IpsecConnectionStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["isLocal"]; exists {

		vOpts := append(opts, db.WithValidateField("isLocal"))
		if err := fv(ctx, m.GetIsLocal(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["remoteAddress"]; exists {

		vOpts := append(opts, db.WithValidateField("remoteAddress"))
		if err := fv(ctx, m.GetRemoteAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["role"]; exists {

		vOpts := append(opts, db.WithValidateField("role"))
		if err := fv(ctx, m.GetRole(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["url"]; exists {

		vOpts := append(opts, db.WithValidateField("url"))
		if err := fv(ctx, m.GetUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["verNodeName"]; exists {

		vOpts := append(opts, db.WithValidateField("verNodeName"))
		if err := fv(ctx, m.GetVerNodeName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIpsecConnectionStatusValidator = func() *ValidateIpsecConnectionStatus {
	v := &ValidateIpsecConnectionStatus{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func IpsecConnectionStatusValidator() db.Validator {
	return DefaultIpsecConnectionStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *K8SApiServerParameters) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *K8SApiServerParameters) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *K8SApiServerParameters) DeepCopy() *K8SApiServerParameters {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &K8SApiServerParameters{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *K8SApiServerParameters) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *K8SApiServerParameters) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return K8SApiServerParametersValidator().Validate(ctx, m, opts...)
}

type ValidateK8SApiServerParameters struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateK8SApiServerParameters) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*K8SApiServerParameters)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *K8SApiServerParameters got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultK8SApiServerParametersValidator = func() *ValidateK8SApiServerParameters {
	v := &ValidateK8SApiServerParameters{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func K8SApiServerParametersValidator() db.Validator {
	return DefaultK8SApiServerParametersValidator
}

// augmented methods on protoc/std generated struct

func (m *Kernel) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Kernel) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Kernel) DeepCopy() *Kernel {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Kernel{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Kernel) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Kernel) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return KernelValidator().Validate(ctx, m, opts...)
}

type ValidateKernel struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateKernel) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Kernel)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Kernel got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["architecture"]; exists {

		vOpts := append(opts, db.WithValidateField("architecture"))
		if err := fv(ctx, m.GetArchitecture(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["release"]; exists {

		vOpts := append(opts, db.WithValidateField("release"))
		if err := fv(ctx, m.GetRelease(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultKernelValidator = func() *ValidateKernel {
	v := &ValidateKernel{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func KernelValidator() db.Validator {
	return DefaultKernelValidator
}

// augmented methods on protoc/std generated struct

func (m *KubeConfigStatusRsp) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *KubeConfigStatusRsp) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *KubeConfigStatusRsp) DeepCopy() *KubeConfigStatusRsp {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &KubeConfigStatusRsp{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *KubeConfigStatusRsp) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *KubeConfigStatusRsp) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return KubeConfigStatusRspValidator().Validate(ctx, m, opts...)
}

type ValidateKubeConfigStatusRsp struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateKubeConfigStatusRsp) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*KubeConfigStatusRsp)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *KubeConfigStatusRsp got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultKubeConfigStatusRspValidator = func() *ValidateKubeConfigStatusRsp {
	v := &ValidateKubeConfigStatusRsp{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func KubeConfigStatusRspValidator() db.Validator {
	return DefaultKubeConfigStatusRspValidator
}

// augmented methods on protoc/std generated struct

func (m *ListGlobalKubeConfigReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListGlobalKubeConfigReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListGlobalKubeConfigReq) DeepCopy() *ListGlobalKubeConfigReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListGlobalKubeConfigReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListGlobalKubeConfigReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListGlobalKubeConfigReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListGlobalKubeConfigReqValidator().Validate(ctx, m, opts...)
}

type ValidateListGlobalKubeConfigReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListGlobalKubeConfigReq) SiteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site")
	}

	return validatorFn, nil
}

func (v *ValidateListGlobalKubeConfigReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListGlobalKubeConfigReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListGlobalKubeConfigReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListGlobalKubeConfigReqValidator = func() *ValidateListGlobalKubeConfigReq {
	v := &ValidateListGlobalKubeConfigReq{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSite := v.SiteValidationRuleHandler
	rulesSite := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhSite(rulesSite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListGlobalKubeConfigReq.site: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site"] = vFn

	return v
}()

func ListGlobalKubeConfigReqValidator() db.Validator {
	return DefaultListGlobalKubeConfigReqValidator
}

// augmented methods on protoc/std generated struct

func (m *ListKubeConfigReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListKubeConfigReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListKubeConfigReq) DeepCopy() *ListKubeConfigReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListKubeConfigReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListKubeConfigReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListKubeConfigReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListKubeConfigReqValidator().Validate(ctx, m, opts...)
}

type ValidateListKubeConfigReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListKubeConfigReq) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateListKubeConfigReq) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateListKubeConfigReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListKubeConfigReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListKubeConfigReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListKubeConfigReqValidator = func() *ValidateListKubeConfigReq {
	v := &ValidateListKubeConfigReq{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListKubeConfigReq.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListKubeConfigReq.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func ListKubeConfigReqValidator() db.Validator {
	return DefaultListKubeConfigReqValidator
}

// augmented methods on protoc/std generated struct

func (m *ListKubeConfigRsp) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListKubeConfigRsp) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListKubeConfigRsp) DeepCopy() *ListKubeConfigRsp {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListKubeConfigRsp{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListKubeConfigRsp) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListKubeConfigRsp) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListKubeConfigRspValidator().Validate(ctx, m, opts...)
}

type ValidateListKubeConfigRsp struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListKubeConfigRsp) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListKubeConfigRsp)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListKubeConfigRsp got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["items"]; exists {

		vOpts := append(opts, db.WithValidateField("items"))
		for idx, item := range m.GetItems() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListKubeConfigRspValidator = func() *ValidateListKubeConfigRsp {
	v := &ValidateListKubeConfigRsp{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["items"] = ListKubeConfigRspItemValidator().Validate

	return v
}()

func ListKubeConfigRspValidator() db.Validator {
	return DefaultListKubeConfigRspValidator
}

// augmented methods on protoc/std generated struct

func (m *ListKubeConfigRspItem) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListKubeConfigRspItem) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListKubeConfigRspItem) DeepCopy() *ListKubeConfigRspItem {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListKubeConfigRspItem{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListKubeConfigRspItem) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListKubeConfigRspItem) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListKubeConfigRspItemValidator().Validate(ctx, m, opts...)
}

type ValidateListKubeConfigRspItem struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListKubeConfigRspItem) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateListKubeConfigRspItem) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListKubeConfigRspItem)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListKubeConfigRspItem got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["create_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("create_timestamp"))
		if err := fv(ctx, m.GetCreateTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["expiry_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("expiry_timestamp"))
		if err := fv(ctx, m.GetExpiryTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["uid"]; exists {

		vOpts := append(opts, db.WithValidateField("uid"))
		if err := fv(ctx, m.GetUid(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user_email"]; exists {

		vOpts := append(opts, db.WithValidateField("user_email"))
		if err := fv(ctx, m.GetUserEmail(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListKubeConfigRspItemValidator = func() *ValidateListKubeConfigRspItem {
	v := &ValidateListKubeConfigRspItem{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListKubeConfigRspItem.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func ListKubeConfigRspItemValidator() db.Validator {
	return DefaultListKubeConfigRspItemValidator
}

// augmented methods on protoc/std generated struct

func (m *Memory) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Memory) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Memory) DeepCopy() *Memory {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Memory{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Memory) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Memory) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MemoryValidator().Validate(ctx, m, opts...)
}

type ValidateMemory struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMemory) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Memory)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Memory got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["size_mb"]; exists {

		vOpts := append(opts, db.WithValidateField("size_mb"))
		if err := fv(ctx, m.GetSizeMb(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["speed"]; exists {

		vOpts := append(opts, db.WithValidateField("speed"))
		if err := fv(ctx, m.GetSpeed(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMemoryValidator = func() *ValidateMemory {
	v := &ValidateMemory{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func MemoryValidator() db.Validator {
	return DefaultMemoryValidator
}

// augmented methods on protoc/std generated struct

func (m *NetworkDevice) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NetworkDevice) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NetworkDevice) DeepCopy() *NetworkDevice {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NetworkDevice{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NetworkDevice) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NetworkDevice) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NetworkDeviceValidator().Validate(ctx, m, opts...)
}

type ValidateNetworkDevice struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNetworkDevice) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NetworkDevice)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NetworkDevice got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["driver"]; exists {

		vOpts := append(opts, db.WithValidateField("driver"))
		if err := fv(ctx, m.GetDriver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip_address"]; exists {

		vOpts := append(opts, db.WithValidateField("ip_address"))
		for idx, item := range m.GetIpAddress() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["link_quality"]; exists {

		vOpts := append(opts, db.WithValidateField("link_quality"))
		if err := fv(ctx, m.GetLinkQuality(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["link_type"]; exists {

		vOpts := append(opts, db.WithValidateField("link_type"))
		if err := fv(ctx, m.GetLinkType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mac_address"]; exists {

		vOpts := append(opts, db.WithValidateField("mac_address"))
		if err := fv(ctx, m.GetMacAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["port"]; exists {

		vOpts := append(opts, db.WithValidateField("port"))
		if err := fv(ctx, m.GetPort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["speed"]; exists {

		vOpts := append(opts, db.WithValidateField("speed"))
		if err := fv(ctx, m.GetSpeed(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNetworkDeviceValidator = func() *ValidateNetworkDevice {
	v := &ValidateNetworkDevice{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func NetworkDeviceValidator() db.Validator {
	return DefaultNetworkDeviceValidator
}

// augmented methods on protoc/std generated struct

func (m *NodeInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NodeInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NodeInfo) DeepCopy() *NodeInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NodeInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NodeInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NodeInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NodeInfoValidator().Validate(ctx, m, opts...)
}

type ValidateNodeInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNodeInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NodeInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NodeInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["hostname"]; exists {

		vOpts := append(opts, db.WithValidateField("hostname"))
		if err := fv(ctx, m.GetHostname(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["role"]; exists {

		vOpts := append(opts, db.WithValidateField("role"))
		for idx, item := range m.GetRole() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNodeInfoValidator = func() *ValidateNodeInfo {
	v := &ValidateNodeInfo{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func NodeInfoValidator() db.Validator {
	return DefaultNodeInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *OS) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OS) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OS) DeepCopy() *OS {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OS{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OS) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OS) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OSValidator().Validate(ctx, m, opts...)
}

type ValidateOS struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOS) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OS)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OS got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["architecture"]; exists {

		vOpts := append(opts, db.WithValidateField("architecture"))
		if err := fv(ctx, m.GetArchitecture(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["release"]; exists {

		vOpts := append(opts, db.WithValidateField("release"))
		if err := fv(ctx, m.GetRelease(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vendor"]; exists {

		vOpts := append(opts, db.WithValidateField("vendor"))
		if err := fv(ctx, m.GetVendor(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOSValidator = func() *ValidateOS {
	v := &ValidateOS{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func OSValidator() db.Validator {
	return DefaultOSValidator
}

// augmented methods on protoc/std generated struct

func (m *OperatingSystemStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OperatingSystemStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OperatingSystemStatus) DeepCopy() *OperatingSystemStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OperatingSystemStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OperatingSystemStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OperatingSystemStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OperatingSystemStatusValidator().Validate(ctx, m, opts...)
}

type ValidateOperatingSystemStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOperatingSystemStatus) NonconformingStateValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for nonconforming_state")
	}

	return validatorFn, nil
}

func (v *ValidateOperatingSystemStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OperatingSystemStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OperatingSystemStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["available_version"]; exists {

		vOpts := append(opts, db.WithValidateField("available_version"))
		if err := fv(ctx, m.GetAvailableVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["deployment_state"]; exists {

		vOpts := append(opts, db.WithValidateField("deployment_state"))
		if err := fv(ctx, m.GetDeploymentState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["nonconforming_state"]; exists {

		vOpts := append(opts, db.WithValidateField("nonconforming_state"))
		if err := fv(ctx, m.GetNonconformingState(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOperatingSystemStatusValidator = func() *ValidateOperatingSystemStatus {
	v := &ValidateOperatingSystemStatus{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNonconformingState := v.NonconformingStateValidationRuleHandler
	rulesNonconformingState := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhNonconformingState(rulesNonconformingState)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OperatingSystemStatus.nonconforming_state: %s", err)
		panic(errMsg)
	}
	v.FldValidators["nonconforming_state"] = vFn

	return v
}()

func OperatingSystemStatusValidator() db.Validator {
	return DefaultOperatingSystemStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *OsInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OsInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OsInfo) DeepCopy() *OsInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OsInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OsInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OsInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OsInfoValidator().Validate(ctx, m, opts...)
}

type ValidateOsInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOsInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OsInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OsInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["bios"]; exists {

		vOpts := append(opts, db.WithValidateField("bios"))
		if err := fv(ctx, m.GetBios(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["board"]; exists {

		vOpts := append(opts, db.WithValidateField("board"))
		if err := fv(ctx, m.GetBoard(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["chassis"]; exists {

		vOpts := append(opts, db.WithValidateField("chassis"))
		if err := fv(ctx, m.GetChassis(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cpu"]; exists {

		vOpts := append(opts, db.WithValidateField("cpu"))
		if err := fv(ctx, m.GetCpu(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gpu"]; exists {

		vOpts := append(opts, db.WithValidateField("gpu"))
		if err := fv(ctx, m.GetGpu(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["kernel"]; exists {

		vOpts := append(opts, db.WithValidateField("kernel"))
		if err := fv(ctx, m.GetKernel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["memory"]; exists {

		vOpts := append(opts, db.WithValidateField("memory"))
		if err := fv(ctx, m.GetMemory(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network"]; exists {

		vOpts := append(opts, db.WithValidateField("network"))
		for idx, item := range m.GetNetwork() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["os"]; exists {

		vOpts := append(opts, db.WithValidateField("os"))
		if err := fv(ctx, m.GetOs(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["product"]; exists {

		vOpts := append(opts, db.WithValidateField("product"))
		if err := fv(ctx, m.GetProduct(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["storage"]; exists {

		vOpts := append(opts, db.WithValidateField("storage"))
		for idx, item := range m.GetStorage() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["usb"]; exists {

		vOpts := append(opts, db.WithValidateField("usb"))
		for idx, item := range m.GetUsb() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOsInfoValidator = func() *ValidateOsInfo {
	v := &ValidateOsInfo{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func OsInfoValidator() db.Validator {
	return DefaultOsInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *Product) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Product) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Product) DeepCopy() *Product {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Product{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Product) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Product) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ProductValidator().Validate(ctx, m, opts...)
}

type ValidateProduct struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateProduct) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Product)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Product got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["serial"]; exists {

		vOpts := append(opts, db.WithValidateField("serial"))
		if err := fv(ctx, m.GetSerial(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vendor"]; exists {

		vOpts := append(opts, db.WithValidateField("vendor"))
		if err := fv(ctx, m.GetVendor(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultProductValidator = func() *ValidateProduct {
	v := &ValidateProduct{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ProductValidator() db.Validator {
	return DefaultProductValidator
}

// augmented methods on protoc/std generated struct

func (m *PublishVIPParamsPerAz) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PublishVIPParamsPerAz) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PublishVIPParamsPerAz) DeepCopy() *PublishVIPParamsPerAz {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PublishVIPParamsPerAz{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PublishVIPParamsPerAz) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PublishVIPParamsPerAz) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PublishVIPParamsPerAzValidator().Validate(ctx, m, opts...)
}

type ValidatePublishVIPParamsPerAz struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePublishVIPParamsPerAz) InsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for inside_vip")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for inside_vip")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated inside_vip")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items inside_vip")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePublishVIPParamsPerAz) OutsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for outside_vip")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for outside_vip")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated outside_vip")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items outside_vip")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePublishVIPParamsPerAz) OutsideVipCnameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_vip_cname")
	}

	return validatorFn, nil
}

func (v *ValidatePublishVIPParamsPerAz) InsideVipCnameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_vip_cname")
	}

	return validatorFn, nil
}

func (v *ValidatePublishVIPParamsPerAz) AzNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for az_name")
	}

	return validatorFn, nil
}

func (v *ValidatePublishVIPParamsPerAz) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PublishVIPParamsPerAz)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PublishVIPParamsPerAz got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["az_name"]; exists {

		vOpts := append(opts, db.WithValidateField("az_name"))
		if err := fv(ctx, m.GetAzName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_vip"]; exists {
		vOpts := append(opts, db.WithValidateField("inside_vip"))
		if err := fv(ctx, m.GetInsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_vip_cname"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_vip_cname"))
		if err := fv(ctx, m.GetInsideVipCname(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_vip"]; exists {
		vOpts := append(opts, db.WithValidateField("outside_vip"))
		if err := fv(ctx, m.GetOutsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_vip_cname"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_vip_cname"))
		if err := fv(ctx, m.GetOutsideVipCname(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPublishVIPParamsPerAzValidator = func() *ValidatePublishVIPParamsPerAz {
	v := &ValidatePublishVIPParamsPerAz{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInsideVip := v.InsideVipValidationRuleHandler
	rulesInsideVip := map[string]string{
		"ves.io.schema.rules.repeated.items.string.ipv4": "true",
		"ves.io.schema.rules.repeated.max_items":         "3",
		"ves.io.schema.rules.repeated.unique":            "true",
	}
	vFn, err = vrhInsideVip(rulesInsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PublishVIPParamsPerAz.inside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_vip"] = vFn

	vrhOutsideVip := v.OutsideVipValidationRuleHandler
	rulesOutsideVip := map[string]string{
		"ves.io.schema.rules.message.required":           "true",
		"ves.io.schema.rules.repeated.items.string.ipv4": "true",
		"ves.io.schema.rules.repeated.max_items":         "3",
		"ves.io.schema.rules.repeated.min_items":         "1",
		"ves.io.schema.rules.repeated.unique":            "true",
	}
	vFn, err = vrhOutsideVip(rulesOutsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PublishVIPParamsPerAz.outside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_vip"] = vFn

	vrhOutsideVipCname := v.OutsideVipCnameValidationRuleHandler
	rulesOutsideVipCname := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhOutsideVipCname(rulesOutsideVipCname)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PublishVIPParamsPerAz.outside_vip_cname: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_vip_cname"] = vFn

	vrhInsideVipCname := v.InsideVipCnameValidationRuleHandler
	rulesInsideVipCname := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhInsideVipCname(rulesInsideVipCname)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PublishVIPParamsPerAz.inside_vip_cname: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_vip_cname"] = vFn

	vrhAzName := v.AzNameValidationRuleHandler
	rulesAzName := map[string]string{
		"ves.io.schema.rules.string.in": "[\"ap-northeast-1a\",\"ap-northeast-1c\",\"ap-northeast-1d\",\"ap-southeast-1a\",\"ap-southeast-1b\",\"ap-southeast-1c\",\"eu-central-1a\",\"eu-central-1b\",\"eu-central-1c\",\"eu-west-1a\",\"eu-west-1b\",\"eu-west-1c\",\"eu-west-3a\",\"eu-west-3b\",\"eu-west-3c\",\"sa-east-1a\",\"sa-east-1b\",\"sa-east-1c\",\"us-east-1a\",\"us-east-1b\",\"us-east-1c\",\"us-east-1d\",\"us-east-1e\",\"us-east-1f\",\"us-east-2a\",\"us-east-2b\",\"us-east-2c\",\"us-west-2a\",\"us-west-2b\",\"us-west-2c\",\"us-west-2d\",\"ca-central-1a\",\"ca-central-1b\",\"ca-central-1d\",\"af-south-1a\",\"af-south-1b\",\"af-south-1c\",\"ap-east-1a\",\"ap-east-1b\",\"ap-east-1c\",\"ap-south-1a\",\"ap-south-1b\",\"ap-south-1c\",\"ap-northeast-2a\",\"ap-northeast-2b\",\"ap-northeast-2c\",\"ap-northeast-2d\",\"ap-southeast-2a\",\"ap-southeast-2b\",\"ap-southeast-2c\",\"eu-south-1a\",\"eu-south-1b\",\"eu-south-1c\",\"eu-north-1a\",\"eu-north-1b\",\"eu-north-1c\",\"eu-west-2a\",\"eu-west-2b\",\"eu-west-2c\",\"me-south-1a\",\"me-south-1b\",\"me-south-1c\",\"us-west-1a\",\"us-west-1c\",\"1\",\"2\",\"3\",\"asia-east1-a\",\"asia-east1-b\",\"asia-east1-c\",\"asia-east2-a\",\"asia-east2-b\",\"asia-east2-c\",\"asia-northeast1-a\",\"asia-northeast1-b\",\"asia-northeast1-c\",\"asia-northeast2-a\",\"asia-northeast2-b\",\"asia-northeast2-c\",\"asia-northeast3-a\",\"asia-northeast3-b\",\"asia-northeast3-c\",\"asia-south1-a\",\"asia-south1-b\",\"asia-south1-c\",\"asia-southeast1-a\",\"asia-southeast1-b\",\"asia-southeast1-c\",\"asia-southeast2-a\",\"asia-southeast2-b\",\"asia-southeast2-c\",\"australia-southeast1-a\",\"australia-southeast1-b\",\"australia-southeast1-c\",\"europe-north1-a\",\"europe-north1-b\",\"europe-north1-c\",\"europe-west1-b\",\"europe-west1-c\",\"europe-west1-d\",\"europe-west2-a\",\"europe-west2-b\",\"europe-west2-c\",\"europe-west3-a\",\"europe-west3-b\",\"europe-west3-c\",\"europe-west4-a\",\"europe-west4-b\",\"europe-west4-c\",\"europe-west6-a\",\"europe-west6-b\",\"europe-west6-c\",\"northamerica-northeast1-a\",\"northamerica-northeast1-b\",\"northamerica-northeast1-c\",\"southamerica-east1-a\",\"southamerica-east1-b\",\"southamerica-east1-c\",\"us-central1-a\",\"us-central1-b\",\"us-central1-c\",\"us-central1-f\",\"us-east1-b\",\"us-east1-c\",\"us-east1-d\",\"us-east4-a\",\"us-east4-b\",\"us-east4-c\",\"us-west1-a\",\"us-west1-b\",\"us-west1-c\",\"us-west2-a\",\"us-west2-b\",\"us-west2-c\",\"us-west3-a\",\"us-west3-b\",\"us-west3-c\",\"us-west4-a\",\"us-west4-b\",\"us-west4-c\"]",
	}
	vFn, err = vrhAzName(rulesAzName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PublishVIPParamsPerAz.az_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["az_name"] = vFn

	return v
}()

func PublishVIPParamsPerAzValidator() db.Validator {
	return DefaultPublishVIPParamsPerAzValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) AddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) InsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_vip")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) SiteToSiteTunnelIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_to_site_tunnel_ip")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) BgpRouterIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bgp_router_id")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) BgpPeerAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bgp_peer_address")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) OutsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_vip")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) InsideNameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) OutsideNameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) DesiredPoolCountValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewInt32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for desired_pool_count")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) TunnelTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.SiteToSiteTunnelType)
		return int32(i)
	}
	// ves_io_schema.SiteToSiteTunnelType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.SiteToSiteTunnelType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_type")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) TunnelDeadTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_dead_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address"]; exists {

		vOpts := append(opts, db.WithValidateField("address"))
		if err := fv(ctx, m.GetAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bgp_peer_address"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_peer_address"))
		if err := fv(ctx, m.GetBgpPeerAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bgp_router_id"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_router_id"))
		if err := fv(ctx, m.GetBgpRouterId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["coordinates"]; exists {

		vOpts := append(opts, db.WithValidateField("coordinates"))
		if err := fv(ctx, m.GetCoordinates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_underlay_network"]; exists {

		vOpts := append(opts, db.WithValidateField("default_underlay_network"))
		if err := fv(ctx, m.GetDefaultUnderlayNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["desired_pool_count"]; exists {

		vOpts := append(opts, db.WithValidateField("desired_pool_count"))
		if err := fv(ctx, m.GetDesiredPoolCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_nameserver"))
		if err := fv(ctx, m.GetInsideNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_vip"))
		if err := fv(ctx, m.GetInsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operating_system_version"]; exists {

		vOpts := append(opts, db.WithValidateField("operating_system_version"))
		if err := fv(ctx, m.GetOperatingSystemVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_nameserver"))
		if err := fv(ctx, m.GetOutsideNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_vip"))
		if err := fv(ctx, m.GetOutsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["region"]; exists {

		vOpts := append(opts, db.WithValidateField("region"))
		if err := fv(ctx, m.GetRegion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_network_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_to_site_network_type"))
		if err := fv(ctx, m.GetSiteToSiteNetworkType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_tunnel_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("site_to_site_tunnel_ip"))
		if err := fv(ctx, m.GetSiteToSiteTunnelIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_dead_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_dead_timeout"))
		if err := fv(ctx, m.GetTunnelDeadTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_type"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_type"))
		if err := fv(ctx, m.GetTunnelType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vip_vrrp_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("vip_vrrp_mode"))
		if err := fv(ctx, m.GetVipVrrpMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_overide"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_overide"))
		if err := fv(ctx, m.GetVolterraSoftwareOveride(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_version"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_version"))
		if err := fv(ctx, m.GetVolterraSoftwareVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAddress := v.AddressValidationRuleHandler
	rulesAddress := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhAddress(rulesAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address"] = vFn

	vrhInsideVip := v.InsideVipValidationRuleHandler
	rulesInsideVip := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhInsideVip(rulesInsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.inside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_vip"] = vFn

	vrhSiteToSiteTunnelIp := v.SiteToSiteTunnelIpValidationRuleHandler
	rulesSiteToSiteTunnelIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhSiteToSiteTunnelIp(rulesSiteToSiteTunnelIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.site_to_site_tunnel_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_to_site_tunnel_ip"] = vFn

	vrhBgpRouterId := v.BgpRouterIdValidationRuleHandler
	rulesBgpRouterId := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhBgpRouterId(rulesBgpRouterId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.bgp_router_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bgp_router_id"] = vFn

	vrhBgpPeerAddress := v.BgpPeerAddressValidationRuleHandler
	rulesBgpPeerAddress := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhBgpPeerAddress(rulesBgpPeerAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.bgp_peer_address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bgp_peer_address"] = vFn

	vrhOutsideVip := v.OutsideVipValidationRuleHandler
	rulesOutsideVip := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhOutsideVip(rulesOutsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.outside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_vip"] = vFn

	vrhInsideNameserver := v.InsideNameserverValidationRuleHandler
	rulesInsideNameserver := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhInsideNameserver(rulesInsideNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.inside_nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_nameserver"] = vFn

	vrhOutsideNameserver := v.OutsideNameserverValidationRuleHandler
	rulesOutsideNameserver := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhOutsideNameserver(rulesOutsideNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.outside_nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_nameserver"] = vFn

	vrhDesiredPoolCount := v.DesiredPoolCountValidationRuleHandler
	rulesDesiredPoolCount := map[string]string{
		"ves.io.schema.rules.int32.gte": "-1",
		"ves.io.schema.rules.int32.lte": "64",
	}
	vFn, err = vrhDesiredPoolCount(rulesDesiredPoolCount)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.desired_pool_count: %s", err)
		panic(errMsg)
	}
	v.FldValidators["desired_pool_count"] = vFn

	vrhTunnelType := v.TunnelTypeValidationRuleHandler
	rulesTunnelType := map[string]string{
		"ves.io.schema.rules.enum.in": "[0,1,2]",
	}
	vFn, err = vrhTunnelType(rulesTunnelType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.tunnel_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_type"] = vFn

	vrhTunnelDeadTimeout := v.TunnelDeadTimeoutValidationRuleHandler
	rulesTunnelDeadTimeout := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "180000",
	}
	vFn, err = vrhTunnelDeadTimeout(rulesTunnelDeadTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.tunnel_dead_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_dead_timeout"] = vFn

	v.FldValidators["coordinates"] = CoordinatesValidator().Validate

	v.FldValidators["default_underlay_network"] = DefaultUnderlayNetworkTypeValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *RevokeKubeConfigReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RevokeKubeConfigReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RevokeKubeConfigReq) DeepCopy() *RevokeKubeConfigReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RevokeKubeConfigReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RevokeKubeConfigReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RevokeKubeConfigReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RevokeKubeConfigReqValidator().Validate(ctx, m, opts...)
}

type ValidateRevokeKubeConfigReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRevokeKubeConfigReq) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateRevokeKubeConfigReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RevokeKubeConfigReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RevokeKubeConfigReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRevokeKubeConfigReqValidator = func() *ValidateRevokeKubeConfigReq {
	v := &ValidateRevokeKubeConfigReq{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RevokeKubeConfigReq.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func RevokeKubeConfigReqValidator() db.Validator {
	return DefaultRevokeKubeConfigReqValidator
}

// augmented methods on protoc/std generated struct

func (m *ScalingStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ScalingStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ScalingStatus) DeepCopy() *ScalingStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ScalingStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ScalingStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ScalingStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ScalingStatusValidator().Validate(ctx, m, opts...)
}

type ValidateScalingStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateScalingStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ScalingStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ScalingStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["message"]; exists {

		vOpts := append(opts, db.WithValidateField("message"))
		if err := fv(ctx, m.GetMessage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["phase"]; exists {

		vOpts := append(opts, db.WithValidateField("phase"))
		if err := fv(ctx, m.GetPhase(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["pool_node_count_current"]; exists {

		vOpts := append(opts, db.WithValidateField("pool_node_count_current"))
		if err := fv(ctx, m.GetPoolNodeCountCurrent(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["pool_node_count_target"]; exists {

		vOpts := append(opts, db.WithValidateField("pool_node_count_target"))
		if err := fv(ctx, m.GetPoolNodeCountTarget(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultScalingStatusValidator = func() *ValidateScalingStatus {
	v := &ValidateScalingStatus{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ScalingStatusValidator() db.Validator {
	return DefaultScalingStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteStatusMetricsData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteStatusMetricsData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteStatusMetricsData) DeepCopy() *SiteStatusMetricsData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteStatusMetricsData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteStatusMetricsData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteStatusMetricsData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteStatusMetricsDataValidator().Validate(ctx, m, opts...)
}

type ValidateSiteStatusMetricsData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteStatusMetricsData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteStatusMetricsData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteStatusMetricsData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["data"]; exists {

		vOpts := append(opts, db.WithValidateField("data"))
		for idx, item := range m.GetData() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["field"]; exists {

		vOpts := append(opts, db.WithValidateField("field"))
		if err := fv(ctx, m.GetField(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteStatusMetricsDataValidator = func() *ValidateSiteStatusMetricsData {
	v := &ValidateSiteStatusMetricsData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SiteStatusMetricsDataValidator() db.Validator {
	return DefaultSiteStatusMetricsDataValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteStatusMetricsFieldData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteStatusMetricsFieldData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteStatusMetricsFieldData) DeepCopy() *SiteStatusMetricsFieldData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteStatusMetricsFieldData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteStatusMetricsFieldData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteStatusMetricsFieldData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteStatusMetricsFieldDataValidator().Validate(ctx, m, opts...)
}

type ValidateSiteStatusMetricsFieldData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteStatusMetricsFieldData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteStatusMetricsFieldData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteStatusMetricsFieldData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["key"]; exists {

		vOpts := append(opts, db.WithValidateField("key"))
		for key, value := range m.GetKey() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		for idx, item := range m.GetValue() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteStatusMetricsFieldDataValidator = func() *ValidateSiteStatusMetricsFieldData {
	v := &ValidateSiteStatusMetricsFieldData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SiteStatusMetricsFieldDataValidator() db.Validator {
	return DefaultSiteStatusMetricsFieldDataValidator
}

// augmented methods on protoc/std generated struct

func (m *StorageDevice) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StorageDevice) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StorageDevice) DeepCopy() *StorageDevice {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StorageDevice{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StorageDevice) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StorageDevice) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StorageDeviceValidator().Validate(ctx, m, opts...)
}

type ValidateStorageDevice struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStorageDevice) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StorageDevice)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StorageDevice got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["driver"]; exists {

		vOpts := append(opts, db.WithValidateField("driver"))
		if err := fv(ctx, m.GetDriver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["model"]; exists {

		vOpts := append(opts, db.WithValidateField("model"))
		if err := fv(ctx, m.GetModel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["serial"]; exists {

		vOpts := append(opts, db.WithValidateField("serial"))
		if err := fv(ctx, m.GetSerial(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["size_gb"]; exists {

		vOpts := append(opts, db.WithValidateField("size_gb"))
		if err := fv(ctx, m.GetSizeGb(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vendor"]; exists {

		vOpts := append(opts, db.WithValidateField("vendor"))
		if err := fv(ctx, m.GetVendor(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStorageDeviceValidator = func() *ValidateStorageDevice {
	v := &ValidateStorageDevice{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func StorageDeviceValidator() db.Validator {
	return DefaultStorageDeviceValidator
}

// augmented methods on protoc/std generated struct

func (m *TunnelConnectionStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TunnelConnectionStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TunnelConnectionStatus) DeepCopy() *TunnelConnectionStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TunnelConnectionStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TunnelConnectionStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TunnelConnectionStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TunnelConnectionStatusValidator().Validate(ctx, m, opts...)
}

type ValidateTunnelConnectionStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTunnelConnectionStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TunnelConnectionStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TunnelConnectionStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["encap"]; exists {

		vOpts := append(opts, db.WithValidateField("encap"))
		if err := fv(ctx, m.GetEncap(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["isLocal"]; exists {

		vOpts := append(opts, db.WithValidateField("isLocal"))
		if err := fv(ctx, m.GetIsLocal(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["remoteAddress"]; exists {

		vOpts := append(opts, db.WithValidateField("remoteAddress"))
		if err := fv(ctx, m.GetRemoteAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["role"]; exists {

		vOpts := append(opts, db.WithValidateField("role"))
		if err := fv(ctx, m.GetRole(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnelName"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnelName"))
		if err := fv(ctx, m.GetTunnelName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["url"]; exists {

		vOpts := append(opts, db.WithValidateField("url"))
		if err := fv(ctx, m.GetUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["verNodeName"]; exists {

		vOpts := append(opts, db.WithValidateField("verNodeName"))
		if err := fv(ctx, m.GetVerNodeName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTunnelConnectionStatusValidator = func() *ValidateTunnelConnectionStatus {
	v := &ValidateTunnelConnectionStatus{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func TunnelConnectionStatusValidator() db.Validator {
	return DefaultTunnelConnectionStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *USBDevice) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *USBDevice) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *USBDevice) DeepCopy() *USBDevice {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &USBDevice{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *USBDevice) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *USBDevice) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return USBDeviceValidator().Validate(ctx, m, opts...)
}

type ValidateUSBDevice struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUSBDevice) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*USBDevice)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *USBDevice got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address"]; exists {

		vOpts := append(opts, db.WithValidateField("address"))
		if err := fv(ctx, m.GetAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["b_device_class"]; exists {

		vOpts := append(opts, db.WithValidateField("b_device_class"))
		if err := fv(ctx, m.GetBDeviceClass(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["b_device_protocol"]; exists {

		vOpts := append(opts, db.WithValidateField("b_device_protocol"))
		if err := fv(ctx, m.GetBDeviceProtocol(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["b_device_sub_class"]; exists {

		vOpts := append(opts, db.WithValidateField("b_device_sub_class"))
		if err := fv(ctx, m.GetBDeviceSubClass(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["b_max_packet_size"]; exists {

		vOpts := append(opts, db.WithValidateField("b_max_packet_size"))
		if err := fv(ctx, m.GetBMaxPacketSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bcd_device"]; exists {

		vOpts := append(opts, db.WithValidateField("bcd_device"))
		if err := fv(ctx, m.GetBcdDevice(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bcd_usb"]; exists {

		vOpts := append(opts, db.WithValidateField("bcd_usb"))
		if err := fv(ctx, m.GetBcdUsb(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bus"]; exists {

		vOpts := append(opts, db.WithValidateField("bus"))
		if err := fv(ctx, m.GetBus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["i_manufacturer"]; exists {

		vOpts := append(opts, db.WithValidateField("i_manufacturer"))
		if err := fv(ctx, m.GetIManufacturer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["i_product"]; exists {

		vOpts := append(opts, db.WithValidateField("i_product"))
		if err := fv(ctx, m.GetIProduct(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["i_serial"]; exists {

		vOpts := append(opts, db.WithValidateField("i_serial"))
		if err := fv(ctx, m.GetISerial(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["id_product"]; exists {

		vOpts := append(opts, db.WithValidateField("id_product"))
		if err := fv(ctx, m.GetIdProduct(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["id_vendor"]; exists {

		vOpts := append(opts, db.WithValidateField("id_vendor"))
		if err := fv(ctx, m.GetIdVendor(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["port"]; exists {

		vOpts := append(opts, db.WithValidateField("port"))
		if err := fv(ctx, m.GetPort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["product_name"]; exists {

		vOpts := append(opts, db.WithValidateField("product_name"))
		if err := fv(ctx, m.GetProductName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["speed"]; exists {

		vOpts := append(opts, db.WithValidateField("speed"))
		if err := fv(ctx, m.GetSpeed(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["usb_type"]; exists {

		vOpts := append(opts, db.WithValidateField("usb_type"))
		if err := fv(ctx, m.GetUsbType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vendor_name"]; exists {

		vOpts := append(opts, db.WithValidateField("vendor_name"))
		if err := fv(ctx, m.GetVendorName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUSBDeviceValidator = func() *ValidateUSBDevice {
	v := &ValidateUSBDevice{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func USBDeviceValidator() db.Validator {
	return DefaultUSBDeviceValidator
}

// augmented methods on protoc/std generated struct

func (m *VerMasterStatusType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VerMasterStatusType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VerMasterStatusType) DeepCopy() *VerMasterStatusType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VerMasterStatusType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VerMasterStatusType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VerMasterStatusType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VerMasterStatusTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVerMasterStatusType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVerMasterStatusType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VerMasterStatusType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VerMasterStatusType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["transition_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("transition_timestamp"))
		if err := fv(ctx, m.GetTransitionTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ver_UID"]; exists {

		vOpts := append(opts, db.WithValidateField("ver_UID"))
		if err := fv(ctx, m.GetVer_UID(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ver_name"]; exists {

		vOpts := append(opts, db.WithValidateField("ver_name"))
		if err := fv(ctx, m.GetVerName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVerMasterStatusTypeValidator = func() *ValidateVerMasterStatusType {
	v := &ValidateVerMasterStatusType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func VerMasterStatusTypeValidator() db.Validator {
	return DefaultVerMasterStatusTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VerStatusType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VerStatusType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VerStatusType) DeepCopy() *VerStatusType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VerStatusType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VerStatusType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VerStatusType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VerStatusTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVerStatusType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVerStatusType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VerStatusType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VerStatusType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ares_status"]; exists {

		vOpts := append(opts, db.WithValidateField("ares_status"))
		for idx, item := range m.GetAresStatus() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["configured_tunnel_status"]; exists {

		vOpts := append(opts, db.WithValidateField("configured_tunnel_status"))
		for idx, item := range m.GetConfiguredTunnelStatus() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["intf_status"]; exists {

		vOpts := append(opts, db.WithValidateField("intf_status"))
		for idx, item := range m.GetIntfStatus() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["ipsec_status"]; exists {

		vOpts := append(opts, db.WithValidateField("ipsec_status"))
		for idx, item := range m.GetIpsecStatus() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["site_tunnel_status"]; exists {

		vOpts := append(opts, db.WithValidateField("site_tunnel_status"))
		for idx, item := range m.GetSiteTunnelStatus() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["ver_instance_name"]; exists {

		vOpts := append(opts, db.WithValidateField("ver_instance_name"))
		if err := fv(ctx, m.GetVerInstanceName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVerStatusTypeValidator = func() *ValidateVerStatusType {
	v := &ValidateVerStatusType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["intf_status"] = InterfaceStatusValidator().Validate

	return v
}()

func VerStatusTypeValidator() db.Validator {
	return DefaultVerStatusTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VolterraSoftwareStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VolterraSoftwareStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VolterraSoftwareStatus) DeepCopy() *VolterraSoftwareStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VolterraSoftwareStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VolterraSoftwareStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VolterraSoftwareStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VolterraSoftwareStatusValidator().Validate(ctx, m, opts...)
}

type ValidateVolterraSoftwareStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVolterraSoftwareStatus) NonconformingStateValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for nonconforming_state")
	}

	return validatorFn, nil
}

func (v *ValidateVolterraSoftwareStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VolterraSoftwareStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VolterraSoftwareStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["available_version"]; exists {

		vOpts := append(opts, db.WithValidateField("available_version"))
		if err := fv(ctx, m.GetAvailableVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["deployment_state"]; exists {

		vOpts := append(opts, db.WithValidateField("deployment_state"))
		if err := fv(ctx, m.GetDeploymentState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["nonconforming_state"]; exists {

		vOpts := append(opts, db.WithValidateField("nonconforming_state"))
		if err := fv(ctx, m.GetNonconformingState(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVolterraSoftwareStatusValidator = func() *ValidateVolterraSoftwareStatus {
	v := &ValidateVolterraSoftwareStatus{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNonconformingState := v.NonconformingStateValidationRuleHandler
	rulesNonconformingState := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhNonconformingState(rulesNonconformingState)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VolterraSoftwareStatus.nonconforming_state: %s", err)
		panic(errMsg)
	}
	v.FldValidators["nonconforming_state"] = vFn

	return v
}()

func VolterraSoftwareStatusValidator() db.Validator {
	return DefaultVolterraSoftwareStatusValidator
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.Address = f.GetAddress()
	m.BgpPeerAddress = f.GetBgpPeerAddress()
	m.BgpRouterId = f.GetBgpRouterId()
	m.CeSiteMode = f.GetCeSiteMode()
	m.Coordinates = f.GetCoordinates()
	m.DefaultUnderlayNetwork = f.GetDefaultUnderlayNetwork()
	m.DesiredPoolCount = f.GetDesiredPoolCount()
	m.InsideNameserver = f.GetInsideNameserver()
	m.InsideVip = f.GetInsideVip()
	m.OperatingSystemVersion = f.GetOperatingSystemVersion()
	m.OutsideNameserver = f.GetOutsideNameserver()
	m.OutsideVip = f.GetOutsideVip()
	m.Region = f.GetRegion()
	m.SiteToSiteNetworkType = f.GetSiteToSiteNetworkType()
	m.SiteToSiteTunnelIp = f.GetSiteToSiteTunnelIp()
	m.SiteType = f.GetSiteType()
	m.TunnelDeadTimeout = f.GetTunnelDeadTimeout()
	m.TunnelType = f.GetTunnelType()
	m.VipVrrpMode = f.GetVipVrrpMode()
	m.VolterraSoftwareOveride = f.GetVolterraSoftwareOveride()
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	f.Address = m1.Address
	f.BgpPeerAddress = m1.BgpPeerAddress
	f.BgpRouterId = m1.BgpRouterId
	f.CeSiteMode = m1.CeSiteMode
	f.Coordinates = m1.Coordinates
	f.DefaultUnderlayNetwork = m1.DefaultUnderlayNetwork
	f.DesiredPoolCount = m1.DesiredPoolCount
	f.InsideNameserver = m1.InsideNameserver
	f.InsideVip = m1.InsideVip
	f.OperatingSystemVersion = m1.OperatingSystemVersion
	f.OutsideNameserver = m1.OutsideNameserver
	f.OutsideVip = m1.OutsideVip
	f.Region = m1.Region
	f.SiteToSiteNetworkType = m1.SiteToSiteNetworkType
	f.SiteToSiteTunnelIp = m1.SiteToSiteTunnelIp
	f.SiteType = m1.SiteType
	f.TunnelDeadTimeout = m1.TunnelDeadTimeout
	f.TunnelType = m1.TunnelType
	f.VipVrrpMode = m1.VipVrrpMode
	f.VolterraSoftwareOveride = m1.VolterraSoftwareOveride
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.Address = f.GetAddress()
	m.BgpPeerAddress = f.GetBgpPeerAddress()
	m.BgpRouterId = f.GetBgpRouterId()
	m.CeSiteMode = f.GetCeSiteMode()
	m.ConnectedRe = f.GetConnectedRe()
	m.ConnectedReForConfig = f.GetConnectedReForConfig()
	m.Coordinates = f.GetCoordinates()
	m.DefaultUnderlayNetwork = f.GetDefaultUnderlayNetwork()
	m.DesiredPoolCount = f.GetDesiredPoolCount()

	m.InsideNameserver = f.GetInsideNameserver()
	m.InsideVip = f.GetInsideVip()

	m.LocalK8SAccessEnabled = f.GetLocalK8SAccessEnabled()
	m.OperatingSystemVersion = f.GetOperatingSystemVersion()
	m.OutsideNameserver = f.GetOutsideNameserver()
	m.OutsideVip = f.GetOutsideVip()
	m.Region = f.GetRegion()
	m.SiteState = f.GetSiteState()
	m.SiteSubtype = f.GetSiteSubtype()
	m.SiteToSiteNetworkType = f.GetSiteToSiteNetworkType()
	m.SiteToSiteTunnelIp = f.GetSiteToSiteTunnelIp()
	m.SiteType = f.GetSiteType()
	m.TunnelDeadTimeout = f.GetTunnelDeadTimeout()
	m.TunnelType = f.GetTunnelType()
	m.VipParamsPerAz = f.GetVipParamsPerAz()
	m.VipVrrpMode = f.GetVipVrrpMode()
	m.VolterraSoftwareOveride = f.GetVolterraSoftwareOveride()
	m.VolterraSoftwareVersion = f.GetVolterraSoftwareVersion()
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	f.Address = m1.Address
	f.BgpPeerAddress = m1.BgpPeerAddress
	f.BgpRouterId = m1.BgpRouterId
	f.CeSiteMode = m1.CeSiteMode
	f.ConnectedRe = m1.ConnectedRe
	f.ConnectedReForConfig = m1.ConnectedReForConfig
	f.Coordinates = m1.Coordinates
	f.DefaultUnderlayNetwork = m1.DefaultUnderlayNetwork
	f.DesiredPoolCount = m1.DesiredPoolCount

	f.InsideNameserver = m1.InsideNameserver
	f.InsideVip = m1.InsideVip

	f.LocalK8SAccessEnabled = m1.LocalK8SAccessEnabled
	f.OperatingSystemVersion = m1.OperatingSystemVersion
	f.OutsideNameserver = m1.OutsideNameserver
	f.OutsideVip = m1.OutsideVip
	f.Region = m1.Region
	f.SiteState = m1.SiteState
	f.SiteSubtype = m1.SiteSubtype
	f.SiteToSiteNetworkType = m1.SiteToSiteNetworkType
	f.SiteToSiteTunnelIp = m1.SiteToSiteTunnelIp
	f.SiteType = m1.SiteType
	f.TunnelDeadTimeout = m1.TunnelDeadTimeout
	f.TunnelType = m1.TunnelType
	f.VipParamsPerAz = m1.VipParamsPerAz
	f.VipVrrpMode = m1.VipVrrpMode
	f.VolterraSoftwareOveride = m1.VolterraSoftwareOveride
	f.VolterraSoftwareVersion = m1.VolterraSoftwareVersion
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.Address = f.GetAddress()
	m.BgpPeerAddress = f.GetBgpPeerAddress()
	m.BgpRouterId = f.GetBgpRouterId()
	m.Coordinates = f.GetCoordinates()
	m.DefaultUnderlayNetwork = f.GetDefaultUnderlayNetwork()
	m.DesiredPoolCount = f.GetDesiredPoolCount()
	m.InsideNameserver = f.GetInsideNameserver()
	m.InsideVip = f.GetInsideVip()
	m.OperatingSystemVersion = f.GetOperatingSystemVersion()
	m.OutsideNameserver = f.GetOutsideNameserver()
	m.OutsideVip = f.GetOutsideVip()
	m.Region = f.GetRegion()
	m.SiteToSiteNetworkType = f.GetSiteToSiteNetworkType()
	m.SiteToSiteTunnelIp = f.GetSiteToSiteTunnelIp()
	m.TunnelDeadTimeout = f.GetTunnelDeadTimeout()
	m.TunnelType = f.GetTunnelType()
	m.VipVrrpMode = f.GetVipVrrpMode()
	m.VolterraSoftwareOveride = f.GetVolterraSoftwareOveride()
	m.VolterraSoftwareVersion = f.GetVolterraSoftwareVersion()
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	f.Address = m1.Address
	f.BgpPeerAddress = m1.BgpPeerAddress
	f.BgpRouterId = m1.BgpRouterId
	f.Coordinates = m1.Coordinates
	f.DefaultUnderlayNetwork = m1.DefaultUnderlayNetwork
	f.DesiredPoolCount = m1.DesiredPoolCount
	f.InsideNameserver = m1.InsideNameserver
	f.InsideVip = m1.InsideVip
	f.OperatingSystemVersion = m1.OperatingSystemVersion
	f.OutsideNameserver = m1.OutsideNameserver
	f.OutsideVip = m1.OutsideVip
	f.Region = m1.Region
	f.SiteToSiteNetworkType = m1.SiteToSiteNetworkType
	f.SiteToSiteTunnelIp = m1.SiteToSiteTunnelIp
	f.TunnelDeadTimeout = m1.TunnelDeadTimeout
	f.TunnelType = m1.TunnelType
	f.VipVrrpMode = m1.VipVrrpMode
	f.VolterraSoftwareOveride = m1.VolterraSoftwareOveride
	f.VolterraSoftwareVersion = m1.VolterraSoftwareVersion
}
