// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package secret_management

import (
	"bytes"
	"context"
	"fmt"
	io "io"
	"net/http"
	"strings"

	"github.com/gogo/protobuf/proto"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"google.golang.org/grpc"

	"gopkg.volterra.us/stdlib/client"
	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/errors"
	"gopkg.volterra.us/stdlib/server"
	"gopkg.volterra.us/stdlib/svcfw"
)

var (
	_ = fmt.Sprintf("dummy for fmt import use")
)

// Create CustomAPI GRPC Client satisfying server.CustomClient
type CustomAPIGrpcClient struct {
	conn       *grpc.ClientConn
	grpcClient CustomAPIClient
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error)
}

func (c *CustomAPIGrpcClient) doRPCGetPolicyDocument(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetPolicyDocumentRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.secret_management.GetPolicyDocumentRequest", yamlReq)
	}
	rsp, err := c.grpcClient.GetPolicyDocument(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCGetPublicKey(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetPublicKeyRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.secret_management.GetPublicKeyRequest", yamlReq)
	}
	rsp, err := c.grpcClient.GetPublicKey(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	if cco.YAMLReq == "" {
		return nil, fmt.Errorf("Error, empty request body")
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := rpcFn(ctx, cco.YAMLReq, cco.GrpcCallOpts...)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using GRPC")
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func NewCustomAPIGrpcClient(cc *grpc.ClientConn) server.CustomClient {
	ccl := &CustomAPIGrpcClient{
		conn:       cc,
		grpcClient: NewCustomAPIClient(cc),
	}
	rpcFns := make(map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error))
	rpcFns["GetPolicyDocument"] = ccl.doRPCGetPolicyDocument

	rpcFns["GetPublicKey"] = ccl.doRPCGetPublicKey

	ccl.rpcFns = rpcFns

	return ccl
}

// Create CustomAPI REST Client satisfying server.CustomClient
type CustomAPIRestClient struct {
	baseURL string
	client  http.Client
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error)
}

func (c *CustomAPIRestClient) doRPCGetPolicyDocument(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetPolicyDocumentRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.secret_management.GetPolicyDocumentRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("name", fmt.Sprintf("%v", req.Name))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &GetPolicyDocumentResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.secret_management.GetPolicyDocumentResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCGetPublicKey(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetPublicKeyRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.secret_management.GetPublicKeyRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("key_version", fmt.Sprintf("%v", req.KeyVersion))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &GetPublicKeyResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.secret_management.GetPublicKeyResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	rsp, err := rpcFn(ctx, cco)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using Rest")
	}
	return rsp, nil
}

func NewCustomAPIRestClient(baseURL string, hc http.Client) server.CustomClient {
	ccl := &CustomAPIRestClient{
		baseURL: baseURL,
		client:  hc,
	}

	rpcFns := make(map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error))
	rpcFns["GetPolicyDocument"] = ccl.doRPCGetPolicyDocument

	rpcFns["GetPublicKey"] = ccl.doRPCGetPublicKey

	ccl.rpcFns = rpcFns

	return ccl
}

// Create customAPIInprocClient

// INPROC Client (satisfying CustomAPIClient interface)
type customAPIInprocClient struct {
	CustomAPIServer
}

func (c *customAPIInprocClient) GetPolicyDocument(ctx context.Context, in *GetPolicyDocumentRequest, opts ...grpc.CallOption) (*GetPolicyDocumentResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.secret_management.CustomAPI.GetPolicyDocument")
	return c.CustomAPIServer.GetPolicyDocument(ctx, in)
}
func (c *customAPIInprocClient) GetPublicKey(ctx context.Context, in *GetPublicKeyRequest, opts ...grpc.CallOption) (*GetPublicKeyResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.secret_management.CustomAPI.GetPublicKey")
	return c.CustomAPIServer.GetPublicKey(ctx, in)
}

func NewCustomAPIInprocClient(svc svcfw.Service) CustomAPIClient {
	return &customAPIInprocClient{CustomAPIServer: NewCustomAPIServer(svc)}
}

// RegisterGwCustomAPIHandler registers with grpc-gw with an inproc-client backing so that
// rest to grpc happens without a grpc.Dial (thus avoiding additional certs for mTLS)
func RegisterGwCustomAPIHandler(ctx context.Context, mux *runtime.ServeMux, svc interface{}) error {
	s, ok := svc.(svcfw.Service)
	if !ok {
		return fmt.Errorf("svc is not svcfw.Service")
	}
	return RegisterCustomAPIHandlerClient(ctx, mux, NewCustomAPIInprocClient(s))
}

// Create customAPISrv

// SERVER (satisfying CustomAPIServer interface)
type customAPISrv struct {
	svc svcfw.Service
}

func (s *customAPISrv) GetPolicyDocument(ctx context.Context, in *GetPolicyDocumentRequest) (*GetPolicyDocumentResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.secret_management.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *GetPolicyDocumentResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.secret_management.GetPolicyDocumentRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.GetPolicyDocument' operation on 'secret_management'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.secret_management.CustomAPI.GetPolicyDocument"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetPolicyDocument(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.secret_management.GetPolicyDocumentResponse", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) GetPublicKey(ctx context.Context, in *GetPublicKeyRequest) (*GetPublicKeyResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.secret_management.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *GetPublicKeyResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.secret_management.GetPublicKeyRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.GetPublicKey' operation on 'secret_management'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.secret_management.CustomAPI.GetPublicKey"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetPublicKey(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.secret_management.GetPublicKeyResponse", rsp)...)

	return rsp, nil
}

func NewCustomAPIServer(svc svcfw.Service) CustomAPIServer {
	return &customAPISrv{svc: svc}
}

var CustomAPISwaggerJSON string = `{
    "swagger": "2.0",
    "info": {
        "title": "F5XC Secret Management",
        "description": "F5XC Secret Management service serves APIs for information required for offline secret encryption such as getting the public key and getting the secret policy document.",
        "version": "version not set"
    },
    "schemes": [
        "http",
        "https"
    ],
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ],
    "tags": [],
    "paths": {
        "/public/get_public_key": {
            "get": {
                "summary": "Public Key",
                "description": "GetPublicKey API returns public part of the volterra secret management key that needs to be given to volterra secret management tool to do secret encryption.",
                "operationId": "ves.io.schema.secret_management.CustomAPI.GetPublicKey",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/secret_managementGetPublicKeyResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "key_version",
                        "description": "x-example: \"0\"\nThe version of public key",
                        "in": "query",
                        "required": false,
                        "type": "integer",
                        "format": "int64",
                        "x-displayname": "Key Version"
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-secret_management-customapi-getpublickey"
                },
                "x-ves-proto-rpc": "ves.io.schema.secret_management.CustomAPI.GetPublicKey"
            },
            "x-displayname": "F5XC Secret Management",
            "x-ves-proto-service": "ves.io.schema.secret_management.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/secret_policys/{name}/get_policy_document": {
            "get": {
                "summary": "Policy Document",
                "description": "GetPolicyDocument API returns secret policy document for the given policy that contains information about all the rules in the policy and policy_id.\nThis document can be given to volterra secret management tool to do secret encryption.",
                "operationId": "ves.io.schema.secret_management.CustomAPI.GetPolicyDocument",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/secret_managementGetPolicyDocumentResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-required\nx-example: \"system\"\nNamespace of the secret policy",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "name",
                        "description": "name\n\nx-required\nx-example: \"site-secret-policy\"\nName of the secret policy",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Name"
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-secret_management-customapi-getpolicydocument"
                },
                "x-ves-proto-rpc": "ves.io.schema.secret_management.CustomAPI.GetPolicyDocument"
            },
            "x-displayname": "F5XC Secret Management",
            "x-ves-proto-service": "ves.io.schema.secret_management.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        }
    },
    "definitions": {
        "policyMatcherType": {
            "type": "object",
            "description": "A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set\nof supported match criteria includes a list of exact values and a list of regular expressions.",
            "title": "MatcherType",
            "x-displayname": "Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.MatcherType",
            "properties": {
                "exact_values": {
                    "type": "array",
                    "description": " A list of exact values to match the input against.\n\nExample: - \"['new york', 'london', 'sydney', 'tokyo', 'cairo']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.max_bytes: 256\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "exact values",
                    "maxItems": 64,
                    "items": {
                        "type": "string",
                        "maxLength": 256
                    },
                    "x-displayname": "Exact Values",
                    "x-ves-example": "['new york', 'london', 'sydney', 'tokyo', 'cairo']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.max_bytes": "256",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "regex_values": {
                    "type": "array",
                    "description": " A list of regular expressions to match the input against.\n\nExample: - \"['^new .*$', 'san f.*', '.* del .*']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.max_bytes: 256\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.items.string.regex: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "regex values",
                    "maxItems": 16,
                    "items": {
                        "type": "string",
                        "maxLength": 256
                    },
                    "x-displayname": "Regex Values",
                    "x-ves-example": "['^new .*$', 'san f.*', '.* del .*']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.max_bytes": "256",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.items.string.regex": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "transformers": {
                    "type": "array",
                    "description": " An ordered list of transformers (starting from index 0) to be applied to the path before matching.\n\nExample: - \"[BASE64_DECODE, LOWER_CASE]-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 9\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "transformers",
                    "maxItems": 9,
                    "items": {
                        "$ref": "#/definitions/policyTransformer"
                    },
                    "x-displayname": "Transformers",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "9",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "policyRuleAction": {
            "type": "string",
            "description": "The rule action determines the disposition of the input request API. If a policy matches a rule with an ALLOW action, the processing of the request proceeds\nforward. If it matches a rule with a DENY action, the processing of the request is terminated and an appropriate message/code returned to the originator. If\nit matches a rule with a NEXT_POLICY_SET action, evaluation of the current policy set terminates and evaluation of the next policy set in the chain begins.\n\n - DENY: DENY\n\nDeny the request.\n - ALLOW: ALLOW\n\nAllow the request to proceed.\n - NEXT_POLICY_SET: NEXT_POLICY_SET\n\nTerminate evaluation of the current policy set and begin evaluating the next policy set in the chain. Note that the evaluation of any remaining policies\nin the current policy set is skipped.\n - NEXT_POLICY: NEXT_POLICY\n\nTerminate evaluation of the current policy and begin evaluating the next policy in the policy set. Note that the evaluation of any remaining rules in the\ncurrent policy is skipped.\n - LAST_POLICY: LAST_POLICY\n\nTerminate evaluation of the current policy and begin evaluating the last policy in the policy set. Note that the evaluation of any remaining rules in the\ncurrent policy is skipped.\n - GOTO_POLICY: GOTO_POLICY\n\nTerminate evaluation of the current policy and begin evaluating a specific policy in the policy set. The policy is specified using the goto_policy field in\nthe rule and must be after the current policy in the policy set.",
            "title": "Rule Action",
            "enum": [
                "DENY",
                "ALLOW",
                "NEXT_POLICY"
            ],
            "default": "DENY",
            "x-displayname": "Rule Action",
            "x-ves-proto-enum": "ves.io.schema.policy.RuleAction"
        },
        "policyRuleCombiningAlgorithm": {
            "type": "string",
            "description": "The rule combining algorithm for a policy determines how the list of rules in the policy is evaluated.\nIf any of the rules is configured with a App Firewall action, the rule combining algorithm must be configured to be FIRST_MATCH.\n\n- FIRST_MATCH Rules are evaluated sequentially till a matching rule is identified\n- ALLOW_OVERRIDES Rules with an ALLOW action are evaluated prior to rules with a DENY action\n- DENY_OVERRIDES Rules with a DENY action are evaluated prior to rules with an ALLOW action\n\n - FIRST_MATCH: First Match\n\nRules are evaluated sequentially till a matching rule is identified\n - DENY_OVERRIDES: Deny Overrides\n\nRules with a DENY action are evaluated prior to rules with an ALLOW action\n - ALLOW_OVERRIDES: Allow Overrides\n\nRules with an ALLOW action are evaluated prior to rules with a DENY action",
            "title": "RuleCombiningAlgorithm",
            "enum": [
                "FIRST_MATCH",
                "DENY_OVERRIDES",
                "ALLOW_OVERRIDES"
            ],
            "default": "FIRST_MATCH",
            "x-displayname": "Rule Combining Algorithm",
            "x-ves-proto-enum": "ves.io.schema.policy.RuleCombiningAlgorithm"
        },
        "policyTransformer": {
            "type": "string",
            "description": "Transformers to be applied on the part of the request before matching.\n\n - TRANSFORMER_NONE: transformer none\n\nNo transformers enabled\n - LOWER_CASE: lower case\n\nConvert string to lower case\n - UPPER_CASE: upper case\n\nConvert string to upper case\n - BASE64_DECODE: base64 decode\n\nDecode string assuming base64 encoding\n - NORMALIZE_PATH: normalize path\n\nNormalize URL path so that /a/b/../c will be transformed to /a/c\n - REMOVE_WHITESPACE: remove whitespace\n\nRemove whitespaces\n - URL_DECODE: URL decode\n\nDecode string assuming URL encoding as per rfc1738\n - TRIM_LEFT: trim left\n\nRemove whitespace from the left side of the input string\n - TRIM_RIGHT: trim right\n\nRemove whitespace from the right side of the input string\n - TRIM: trim\n\nRemove whitespace from the both sides of the input string",
            "title": "Transformer",
            "enum": [
                "LOWER_CASE",
                "UPPER_CASE",
                "BASE64_DECODE",
                "NORMALIZE_PATH",
                "REMOVE_WHITESPACE",
                "URL_DECODE",
                "TRIM_LEFT",
                "TRIM_RIGHT",
                "TRIM"
            ],
            "default": "TRANSFORMER_NONE",
            "x-displayname": "Transformer",
            "x-ves-proto-enum": "ves.io.schema.policy.Transformer"
        },
        "schemaLabelMatcherType": {
            "type": "object",
            "description": "x-displayName: \"Label Matcher\"\nA label matcher specifies a list of label keys whose values need to match for\nsource/client and destination/server. Note that the actual label values are not\nspecified and do not matter. This allows an ability to scope grouping by the\nlabel key name.",
            "title": "LabelMatcherType",
            "properties": {
                "keys": {
                    "type": "array",
                    "description": "x-displayName: \"Keys\"\nx-example: \"['environment', 'location', 'deployment']\"\nThe list of label key names that have to match",
                    "title": "keys",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "schemaLabelSelectorType": {
            "type": "object",
            "description": "This type can be used to establish a 'selector reference' from one object(called selector) to\na set of other objects(called selectees) based on the value of expresssions.\nA label selector is a label query over a set of resources. An empty label selector matches all objects.\nA null label selector matches no objects. Label selector is immutable.\nexpressions is a list of strings of label selection expression.\nEach string has \",\" separated values which are \"AND\" and all strings are logically \"OR\".\nBNF for expression string\n\u003cselector-syntax\u003e         ::= \u003crequirement\u003e | \u003crequirement\u003e \",\" \u003cselector-syntax\u003e\n\u003crequirement\u003e             ::= [!] KEY [ \u003cset-based-restriction\u003e | \u003cexact-match-restriction\u003e ]\n\u003cset-based-restriction\u003e   ::= \"\" | \u003cinclusion-exclusion\u003e \u003cvalue-set\u003e\n\u003cinclusion-exclusion\u003e     ::= \u003cinclusion\u003e | \u003cexclusion\u003e\n\u003cexclusion\u003e               ::= \"notin\"\n\u003cinclusion\u003e               ::= \"in\"\n\u003cvalue-set\u003e               ::= \"(\" \u003cvalues\u003e \")\"\n\u003cvalues\u003e                  ::= VALUE | VALUE \",\" \u003cvalues\u003e\n\u003cexact-match-restriction\u003e ::= [\"=\"|\"==\"|\"!=\"] VALUE",
            "title": "LabelSelectorType",
            "x-displayname": "Label Selector",
            "x-ves-proto-message": "ves.io.schema.LabelSelectorType",
            "properties": {
                "expressions": {
                    "type": "array",
                    "description": " expressions contains the kubernetes style label expression for selections.\n\nExample: - \"region in (us-west1, us-west2),tier in (staging)\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.string.k8s_label_selector: true\n  ves.io.schema.rules.repeated.items.string.max_len: 4096\n  ves.io.schema.rules.repeated.items.string.min_len: 1\n  ves.io.schema.rules.repeated.max_items: 1\n",
                    "title": "expressions",
                    "maxItems": 1,
                    "items": {
                        "type": "string",
                        "minLength": 1,
                        "maxLength": 4096
                    },
                    "x-displayname": "Selector Expression",
                    "x-ves-example": "region in (us-west1, us-west2),tier in (staging)",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.string.k8s_label_selector": "true",
                        "ves.io.schema.rules.repeated.items.string.max_len": "4096",
                        "ves.io.schema.rules.repeated.items.string.min_len": "1",
                        "ves.io.schema.rules.repeated.max_items": "1"
                    }
                }
            }
        },
        "schemasecret_policy_ruleGlobalSpecType": {
            "type": "object",
            "description": "A secret_policy_rule object consists of an unordered list of predicates and an action.\nThe predicates are evaluated against a set of input fields that are extracted from client certificate.\nA rule is considered to match if all predicates in the rule evaluate to true for that request.\nAny predicates that are not specified in a rule are implicitly considered to be true.\nIf a rule is matched, the action specified for the rule is enforced for that request.\n\nA secret_policy_rule can be part of exactly one secret_policy and must belong to the same namespace as the secret policy.",
            "title": "Secret Policy Rule Specifications",
            "x-displayname": "Global Specifications",
            "x-ves-oneof-field-client_choice": "[\"client_name\",\"client_name_matcher\",\"client_selector\"]",
            "x-ves-proto-message": "ves.io.schema.secret_policy_rule.GlobalSpecType",
            "properties": {
                "action": {
                    "description": " Action to be enforced if all the predicates evaluates to true.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.enum.in: [0,1]\n  ves.io.schema.rules.message.required: true\n",
                    "title": "action",
                    "$ref": "#/definitions/policyRuleAction",
                    "x-displayname": "Action",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.enum.in": "[0,1]",
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "client_name": {
                    "type": "string",
                    "description": "Exclusive with [client_name_matcher client_selector]\n The name of the client trying to access the secret. Name of the client will be extracted from client TLS certificate.\n This predicate evaluates to true if client name matches the configured name\n\nExample: - \"ver.re01.int.ves.io\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 256\n",
                    "title": "client name",
                    "maxLength": 256,
                    "x-displayname": "Client Name",
                    "x-ves-example": "ver.re01.int.ves.io",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "256"
                    }
                },
                "client_name_matcher": {
                    "description": "Exclusive with [client_name client_selector]\n A list of exact values and/or regular expressions for the expected name of the client. The actual names of the client are extracted from its TLS certificate.\n This is a generalized version of the client name predicate that allows the same rule to be applicable to a set of clients rather than a single client.\n The predicate evaluates to true if any of the client's actual names match any of the exact values or regular expressions in the client name matcher.",
                    "title": "client name matcher",
                    "$ref": "#/definitions/policyMatcherType",
                    "x-displayname": "Group of Clients by Name"
                },
                "client_selector": {
                    "description": "Exclusive with [client_name client_name_matcher]\n A label selector that describes the expected set of clients. The labels associated with the client trying to access the secret are used to evaluate the label\n expressions in the selector. These labels are derived from the client TLS certificate.\n This is a more flexible and powerful version of the client name matcher predicate that allows a given rule to be applicable to a set of clients based on the\n client labels rather than being limited to relying on patterns in the client name.\n The predicate evaluates to true if the expressions in the label selector are true for the client labels.",
                    "title": "client selector",
                    "$ref": "#/definitions/schemaLabelSelectorType",
                    "x-displayname": "Group of Clients by Label Selector"
                }
            }
        },
        "secret_managementGetPolicyDocumentResponse": {
            "type": "object",
            "description": "Policy Document contains the information about the secret policy and all the secret policy rules for the policy.\nThis document can be given to volterra secret management tool to do secret encryption.",
            "title": "GetPolicyDocumentResponse",
            "x-displayname": "Policy Document",
            "x-ves-proto-message": "ves.io.schema.secret_management.GetPolicyDocumentResponse",
            "properties": {
                "data": {
                    "description": " data contains the information about the secret policy and all the secret policy rules for the policy.",
                    "$ref": "#/definitions/secret_managementPolicyData",
                    "x-displayname": "Policy Data"
                }
            }
        },
        "secret_managementGetPublicKeyResponse": {
            "type": "object",
            "description": "F5XC Secret Management uses asymmetric cryptography for securing secrets.\nEach tenant will be assigned a \u003cpublic,private\u003e keypair for secret management at registration time.\nWhile private part of the key never leaves volterra secret management, public part of this asymmetric key is used for secret encryption.\nget_public_key_response is the response to the get_public_key API and holds the public key for secret encryption.",
            "title": "GetPublicKeyResponse",
            "x-displayname": "Public Key",
            "x-ves-proto-message": "ves.io.schema.secret_management.GetPublicKeyResponse",
            "properties": {
                "data": {
                    "description": " data holds the public key for secret encryption",
                    "title": "data",
                    "$ref": "#/definitions/secret_managementKeyData",
                    "x-displayname": "Data"
                }
            }
        },
        "secret_managementKeyData": {
            "type": "object",
            "description": "F5XC Secret Management uses asymmetric cryptography for securing secrets.\nEach tenant will be assigned a \u003cpublic,private\u003e keypair for secret management at registration time.\nWhile private part of the key never leaves volterra secret management, public part of this asymmetric key is used for secret encryption.\nkey_data holds the public key for secret encryption.",
            "title": "KeyData",
            "x-displayname": "Public Key",
            "x-ves-proto-message": "ves.io.schema.secret_management.KeyData",
            "properties": {
                "key_version": {
                    "type": "integer",
                    "description": "\n\nExample: - \"1\"-",
                    "title": "key_version",
                    "format": "int64",
                    "x-displayname": "Version of the key",
                    "x-ves-example": "1"
                },
                "modulus_base64": {
                    "type": "string",
                    "description": " Modulus as Base64 encoded string\n\nExample: - \"value\"-",
                    "title": "modulus_base64",
                    "x-displayname": "Modulus",
                    "x-ves-example": "value"
                },
                "public_exponent_base64": {
                    "type": "string",
                    "description": " Public Exponent as Base64 encoded string\n\nExample: - \"value\"-",
                    "title": "public_exponent_base64",
                    "x-displayname": "Public Exponent",
                    "x-ves-example": "value"
                },
                "tenant": {
                    "type": "string",
                    "description": " Tenant of the public key\n\nExample: - \"ves-io\"-",
                    "title": "tenant",
                    "x-displayname": "Tenant",
                    "x-ves-example": "ves-io"
                }
            }
        },
        "secret_managementPolicyData": {
            "type": "object",
            "description": "policy_data contains the information about the secret policy and all the secret policy rules for the policy.",
            "title": "PolicyData",
            "x-displayname": "Policy Data",
            "x-ves-proto-message": "ves.io.schema.secret_management.PolicyData",
            "properties": {
                "name": {
                    "type": "string",
                    "description": " Name of the policy\n\nExample: - \"volterra-secret-policy\"-",
                    "title": "name",
                    "x-displayname": "Name",
                    "x-ves-example": "volterra-secret-policy"
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace of the policy\n\nExample: - \"system\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "system"
                },
                "policy_id": {
                    "type": "string",
                    "description": " PolicyID for the policy. PolicyID is an integer ID which uniquely identifies the policy in given tenant.\n\nExample: - \"101\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint64.gte: 0\n  ves.io.schema.rules.uint64.lte: 2147483647\n",
                    "title": "policy_id",
                    "format": "uint64",
                    "x-displayname": "PolicyID",
                    "x-ves-example": "101",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint64.gte": "0",
                        "ves.io.schema.rules.uint64.lte": "2147483647"
                    }
                },
                "policy_info": {
                    "description": " policy_info contains the specifications of the policy.",
                    "title": "policy_info",
                    "$ref": "#/definitions/secret_managementPolicyInfoType",
                    "x-displayname": "Policy Information"
                },
                "tenant": {
                    "type": "string",
                    "description": " Tenant for the policy\n\nExample: - \"ves-io\"-",
                    "title": "tenant",
                    "x-displayname": "Tenant",
                    "x-ves-example": "ves-io"
                }
            }
        },
        "secret_managementPolicyInfoType": {
            "type": "object",
            "description": "policy_information contains the shape and specifications of the secret policy.",
            "title": "PolicyInfoType",
            "x-displayname": "Policy Information",
            "x-ves-proto-message": "ves.io.schema.secret_management.PolicyInfoType",
            "properties": {
                "algo": {
                    "description": " This will define the rule combining algorithm. It can take one of the following values -\n\n - FIRST_MATCH Rules are evaluated sequentially till a matching rule is identified\n - ALLOW_OVERRIDES Rules with an ALLOW action are evaluated prior to rules with a DENY action\n - DENY_OVERRIDES Rules with a DENY action are evaluated prior to rules with an ALLOW action",
                    "title": "algo",
                    "$ref": "#/definitions/policyRuleCombiningAlgorithm",
                    "x-displayname": "Rule Combining Algorithm"
                },
                "rules": {
                    "type": "array",
                    "description": " A list of references to secret_policy_rule objects.\n The order of evaluation of the rules depends on the rule combining algorithm.",
                    "title": "Rules",
                    "items": {
                        "$ref": "#/definitions/schemasecret_policy_ruleGlobalSpecType"
                    },
                    "x-displayname": "Secret Policy Rules"
                }
            }
        }
    },
    "x-displayname": "F5XC Secret Management",
    "x-ves-proto-file": "ves.io/schema/secret_management/public_customapi.proto"
}`
