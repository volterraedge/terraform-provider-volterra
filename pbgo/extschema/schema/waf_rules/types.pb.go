// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/waf_rules/types.proto

package waf_rules

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	waf_rule_list "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/waf_rule_list"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SeverityType
//
// x-displayName: "Severity"
// Rule severity as defined in the rule
type SeverityType int32

const (
	// x-displayName: "Emergency"
	// Emergency Level
	EMERGENCY SeverityType = 0
	// x-displayName: "Alert"
	// Alert Level
	ALERT SeverityType = 1
	// x-displayName: "Critical"
	// Critical Level
	CRITICAL SeverityType = 2
	// x-displayName: "Error"
	// Error Level
	ERROR SeverityType = 3
	// x-displayName: "Warning"
	// Warning Level
	WARNING SeverityType = 4
	// x-displayName: "Notice"
	// Notice Level
	NOTICE SeverityType = 5
	// x-displayName: "Info"
	// Info Level
	INFO SeverityType = 6
	// x-displayName: "Debug"
	// Debug Level
	DEBUG SeverityType = 7
)

var SeverityType_name = map[int32]string{
	0: "EMERGENCY",
	1: "ALERT",
	2: "CRITICAL",
	3: "ERROR",
	4: "WARNING",
	5: "NOTICE",
	6: "INFO",
	7: "DEBUG",
}

var SeverityType_value = map[string]int32{
	"EMERGENCY": 0,
	"ALERT":     1,
	"CRITICAL":  2,
	"ERROR":     3,
	"WARNING":   4,
	"NOTICE":    5,
	"INFO":      6,
	"DEBUG":     7,
}

func (SeverityType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00ad238a682aa65c, []int{0}
}

// RuleModeType
//
// x-displayName: "Rule Mode"
// Specify whether rule is to be included or excluded.
type RuleModeType int32

const (
	// x-displayName: "Exclude"
	// Exclude
	EXCLUDE RuleModeType = 0
	// x-displayName: "Include"
	// Include
	INCLUDE RuleModeType = 1
)

var RuleModeType_name = map[int32]string{
	0: "EXCLUDE",
	1: "INCLUDE",
}

var RuleModeType_value = map[string]int32{
	"EXCLUDE": 0,
	"INCLUDE": 1,
}

func (RuleModeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00ad238a682aa65c, []int{1}
}

// Rule
//
// x-displayName: "Rule"
// Every WAF rule will have these properties associated
type Rules struct {
	// mode
	//
	// x-displayName: "Mode"
	// Whether the Rule is excluded or included
	Mode RuleModeType `protobuf:"varint,1,opt,name=mode,proto3,enum=ves.io.schema.waf_rules.RuleModeType" json:"mode,omitempty"`
	// id
	//
	// x-displayName: "ID"
	// x-example: "941210"
	// WAF rule ID which is a unique ID with in waf_rules object.
	// Generated alerts will have the id displayed in alert.
	Id uint32 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	// description
	//
	// x-displayName: "Description"
	// x-example: "IE XSS Filters - Attack Detected."
	// This is the brief description of the rule.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// tags
	//
	// x-displayName: "Tags"
	// x-example: "["attack-sqli", "attack-protocol"]"
	//Tags are a set of string labels associated with a rule. For eg a particular rule may be under
	//"attack-sqli" and "attack-protocol" tags. This is used by user to find out Tags associated with a
	//Rule.
	Tags []string `protobuf:"bytes,4,rep,name=tags,proto3" json:"tags,omitempty"`
	// severity
	//
	// x-displayName: "Severity"
	// Severity of the rule.
	Severity SeverityType `protobuf:"varint,5,opt,name=severity,proto3,enum=ves.io.schema.waf_rules.SeverityType" json:"severity,omitempty"`
}

func (m *Rules) Reset()      { *m = Rules{} }
func (*Rules) ProtoMessage() {}
func (*Rules) Descriptor() ([]byte, []int) {
	return fileDescriptor_00ad238a682aa65c, []int{0}
}
func (m *Rules) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rules) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Rules) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rules.Merge(m, src)
}
func (m *Rules) XXX_Size() int {
	return m.Size()
}
func (m *Rules) XXX_DiscardUnknown() {
	xxx_messageInfo_Rules.DiscardUnknown(m)
}

var xxx_messageInfo_Rules proto.InternalMessageInfo

func (m *Rules) GetMode() RuleModeType {
	if m != nil {
		return m.Mode
	}
	return EXCLUDE
}

func (m *Rules) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Rules) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Rules) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Rules) GetSeverity() SeverityType {
	if m != nil {
		return m.Severity
	}
	return EMERGENCY
}

// GlobalSpecType
//
// x-displayName: "Specification"
type GlobalSpecType struct {
	// mode
	//
	// x-displayName: "Mode"
	// x-required
	// WAF Mode is blocking or Alert
	Mode schema.WafModeType `protobuf:"varint,1,opt,name=mode,proto3,enum=ves.io.schema.WafModeType" json:"mode,omitempty"`
	// anomaly_score_threshold
	//
	// x-displayName: "Anomaly Score Threshold"
	// x-example: "4"
	// x-required
	// If anomaly score is same or above threshold , the req/resp will be blocked/alerted (depending
	// on non_blocking_mode configuration)
	AnomalyScoreThreshold uint32 `protobuf:"varint,2,opt,name=anomaly_score_threshold,json=anomalyScoreThreshold,proto3" json:"anomaly_score_threshold,omitempty"`
	// paranoia_level
	//
	// x-displayName: "Paranoia Level"
	// x-required
	// x-example: "2"
	// Paranoia level
	ParanoiaLevel uint32 `protobuf:"varint,3,opt,name=paranoia_level,json=paranoiaLevel,proto3" json:"paranoia_level,omitempty"`
	// rule_ids
	//
	// x-displayName: "Rule IDs"
	// x-example: "[941210, 941310]"
	// rule IDs to be included or excluded in this WAF instance
	RuleIds []waf_rule_list.WafRuleID `protobuf:"varint,4,rep,packed,name=rule_ids,json=ruleIds,proto3,enum=ves.io.schema.waf_rule_list.WafRuleID" json:"rule_ids,omitempty"`
	// rule_list_type
	//
	// x-displayName: "Rule List Type"
	// x-required
	// Specify whether the defined rule_ids list is to be included or excluded from associated WAF instance
	RuleListType RuleModeType `protobuf:"varint,5,opt,name=rule_list_type,json=ruleListType,proto3,enum=ves.io.schema.waf_rules.RuleModeType" json:"rule_list_type,omitempty"`
	// waf
	//
	// x-displayName: "WAF"
	// A reference to WAF object
	Waf []*schema.ObjectRefType `protobuf:"bytes,6,rep,name=waf,proto3" json:"waf,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_00ad238a682aa65c, []int{1}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

func (m *GlobalSpecType) GetMode() schema.WafModeType {
	if m != nil {
		return m.Mode
	}
	return schema.BLOCK
}

func (m *GlobalSpecType) GetAnomalyScoreThreshold() uint32 {
	if m != nil {
		return m.AnomalyScoreThreshold
	}
	return 0
}

func (m *GlobalSpecType) GetParanoiaLevel() uint32 {
	if m != nil {
		return m.ParanoiaLevel
	}
	return 0
}

func (m *GlobalSpecType) GetRuleIds() []waf_rule_list.WafRuleID {
	if m != nil {
		return m.RuleIds
	}
	return nil
}

func (m *GlobalSpecType) GetRuleListType() RuleModeType {
	if m != nil {
		return m.RuleListType
	}
	return EXCLUDE
}

func (m *GlobalSpecType) GetWaf() []*schema.ObjectRefType {
	if m != nil {
		return m.Waf
	}
	return nil
}

// Create WAF Rules
//
// x-displayName: "Create WAF Rules"
// Create App type will create the configuration in namespace metadata.namespace
type CreateSpecType struct {
	Mode                  schema.WafModeType        `protobuf:"varint,1,opt,name=mode,proto3,enum=ves.io.schema.WafModeType" json:"mode,omitempty"`
	AnomalyScoreThreshold uint32                    `protobuf:"varint,2,opt,name=anomaly_score_threshold,json=anomalyScoreThreshold,proto3" json:"anomaly_score_threshold,omitempty"`
	ParanoiaLevel         uint32                    `protobuf:"varint,3,opt,name=paranoia_level,json=paranoiaLevel,proto3" json:"paranoia_level,omitempty"`
	RuleIds               []waf_rule_list.WafRuleID `protobuf:"varint,4,rep,packed,name=rule_ids,json=ruleIds,proto3,enum=ves.io.schema.waf_rule_list.WafRuleID" json:"rule_ids,omitempty"`
	RuleListType          RuleModeType              `protobuf:"varint,5,opt,name=rule_list_type,json=ruleListType,proto3,enum=ves.io.schema.waf_rules.RuleModeType" json:"rule_list_type,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_00ad238a682aa65c, []int{2}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

func (m *CreateSpecType) GetMode() schema.WafModeType {
	if m != nil {
		return m.Mode
	}
	return schema.BLOCK
}

func (m *CreateSpecType) GetAnomalyScoreThreshold() uint32 {
	if m != nil {
		return m.AnomalyScoreThreshold
	}
	return 0
}

func (m *CreateSpecType) GetParanoiaLevel() uint32 {
	if m != nil {
		return m.ParanoiaLevel
	}
	return 0
}

func (m *CreateSpecType) GetRuleIds() []waf_rule_list.WafRuleID {
	if m != nil {
		return m.RuleIds
	}
	return nil
}

func (m *CreateSpecType) GetRuleListType() RuleModeType {
	if m != nil {
		return m.RuleListType
	}
	return EXCLUDE
}

// Replace WAF Rules
//
// x-displayName: "Replace WAF Rules"
// Update the configuration by replacing the existing spec with the provided one.
// For read-then-write operations a resourceVersion mismatch will occur if the object was modified between the read and write.
type ReplaceSpecType struct {
	Mode                  schema.WafModeType        `protobuf:"varint,1,opt,name=mode,proto3,enum=ves.io.schema.WafModeType" json:"mode,omitempty"`
	AnomalyScoreThreshold uint32                    `protobuf:"varint,2,opt,name=anomaly_score_threshold,json=anomalyScoreThreshold,proto3" json:"anomaly_score_threshold,omitempty"`
	ParanoiaLevel         uint32                    `protobuf:"varint,3,opt,name=paranoia_level,json=paranoiaLevel,proto3" json:"paranoia_level,omitempty"`
	RuleIds               []waf_rule_list.WafRuleID `protobuf:"varint,4,rep,packed,name=rule_ids,json=ruleIds,proto3,enum=ves.io.schema.waf_rule_list.WafRuleID" json:"rule_ids,omitempty"`
	RuleListType          RuleModeType              `protobuf:"varint,5,opt,name=rule_list_type,json=ruleListType,proto3,enum=ves.io.schema.waf_rules.RuleModeType" json:"rule_list_type,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_00ad238a682aa65c, []int{3}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

func (m *ReplaceSpecType) GetMode() schema.WafModeType {
	if m != nil {
		return m.Mode
	}
	return schema.BLOCK
}

func (m *ReplaceSpecType) GetAnomalyScoreThreshold() uint32 {
	if m != nil {
		return m.AnomalyScoreThreshold
	}
	return 0
}

func (m *ReplaceSpecType) GetParanoiaLevel() uint32 {
	if m != nil {
		return m.ParanoiaLevel
	}
	return 0
}

func (m *ReplaceSpecType) GetRuleIds() []waf_rule_list.WafRuleID {
	if m != nil {
		return m.RuleIds
	}
	return nil
}

func (m *ReplaceSpecType) GetRuleListType() RuleModeType {
	if m != nil {
		return m.RuleListType
	}
	return EXCLUDE
}

// Get WAF Rules
//
// x-displayName: "Get WAF Rules"
// Get App type will read the configuration from namespace metadata.namespace
type GetSpecType struct {
	Mode                  schema.WafModeType        `protobuf:"varint,1,opt,name=mode,proto3,enum=ves.io.schema.WafModeType" json:"mode,omitempty"`
	AnomalyScoreThreshold uint32                    `protobuf:"varint,2,opt,name=anomaly_score_threshold,json=anomalyScoreThreshold,proto3" json:"anomaly_score_threshold,omitempty"`
	ParanoiaLevel         uint32                    `protobuf:"varint,3,opt,name=paranoia_level,json=paranoiaLevel,proto3" json:"paranoia_level,omitempty"`
	RuleIds               []waf_rule_list.WafRuleID `protobuf:"varint,4,rep,packed,name=rule_ids,json=ruleIds,proto3,enum=ves.io.schema.waf_rule_list.WafRuleID" json:"rule_ids,omitempty"`
	RuleListType          RuleModeType              `protobuf:"varint,5,opt,name=rule_list_type,json=ruleListType,proto3,enum=ves.io.schema.waf_rules.RuleModeType" json:"rule_list_type,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_00ad238a682aa65c, []int{4}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

func (m *GetSpecType) GetMode() schema.WafModeType {
	if m != nil {
		return m.Mode
	}
	return schema.BLOCK
}

func (m *GetSpecType) GetAnomalyScoreThreshold() uint32 {
	if m != nil {
		return m.AnomalyScoreThreshold
	}
	return 0
}

func (m *GetSpecType) GetParanoiaLevel() uint32 {
	if m != nil {
		return m.ParanoiaLevel
	}
	return 0
}

func (m *GetSpecType) GetRuleIds() []waf_rule_list.WafRuleID {
	if m != nil {
		return m.RuleIds
	}
	return nil
}

func (m *GetSpecType) GetRuleListType() RuleModeType {
	if m != nil {
		return m.RuleListType
	}
	return EXCLUDE
}

func init() {
	proto.RegisterEnum("ves.io.schema.waf_rules.SeverityType", SeverityType_name, SeverityType_value)
	proto.RegisterEnum("ves.io.schema.waf_rules.RuleModeType", RuleModeType_name, RuleModeType_value)
	proto.RegisterType((*Rules)(nil), "ves.io.schema.waf_rules.Rules")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.waf_rules.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.waf_rules.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.waf_rules.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.waf_rules.GetSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/waf_rules/types.proto", fileDescriptor_00ad238a682aa65c)
}

var fileDescriptor_00ad238a682aa65c = []byte{
	// 761 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x56, 0xcd, 0x6a, 0xeb, 0x46,
	0x18, 0xd5, 0x48, 0xfe, 0x1d, 0xff, 0x54, 0x1d, 0x08, 0x51, 0xdd, 0x20, 0x8c, 0x4b, 0x5b, 0x63,
	0x88, 0x54, 0x52, 0x08, 0xb4, 0x8b, 0x16, 0xdb, 0x51, 0x8d, 0xa8, 0x63, 0xc3, 0xc4, 0x21, 0x69,
	0x37, 0x66, 0x6c, 0x8d, 0x6d, 0xb5, 0x72, 0x46, 0x48, 0xb2, 0x53, 0x2f, 0x0a, 0xd9, 0x75, 0x5b,
	0xf2, 0x14, 0xa5, 0x8f, 0xd0, 0x55, 0x97, 0x25, 0xa5, 0x25, 0xcb, 0x2c, 0x6f, 0x94, 0xcd, 0xbd,
	0xbb, 0x3c, 0xc2, 0x65, 0x64, 0x27, 0xd8, 0xe6, 0x86, 0x40, 0xc8, 0xdd, 0x65, 0x63, 0xbe, 0x4f,
	0xe7, 0x7c, 0x7f, 0xe7, 0x18, 0xcb, 0xf0, 0x93, 0x29, 0xf5, 0x35, 0x9b, 0xe9, 0x7e, 0x7f, 0x44,
	0xc7, 0x44, 0x3f, 0x25, 0x83, 0xae, 0x37, 0x71, 0xa8, 0xaf, 0x07, 0x33, 0x97, 0xfa, 0x9a, 0xeb,
	0xb1, 0x80, 0xa1, 0xcd, 0x39, 0x49, 0x9b, 0x93, 0xb4, 0x7b, 0x52, 0x61, 0x7b, 0x68, 0x07, 0xa3,
	0x49, 0x4f, 0xeb, 0xb3, 0xb1, 0x3e, 0x64, 0x43, 0xa6, 0x47, 0xfc, 0xde, 0x64, 0x10, 0x65, 0x51,
	0x12, 0x45, 0xf3, 0x3e, 0x85, 0x8f, 0x57, 0x87, 0x31, 0x37, 0xb0, 0xd9, 0xc9, 0x62, 0x48, 0xe1,
	0xa3, 0x55, 0x70, 0x69, 0x7e, 0x61, 0x6b, 0x15, 0x9a, 0x12, 0xc7, 0xb6, 0x48, 0x40, 0x17, 0x68,
	0x71, 0x0d, 0xb5, 0xe9, 0x69, 0x77, 0xb5, 0xf5, 0xe7, 0xef, 0x3e, 0xb2, 0xeb, 0xd8, 0x7e, 0xb0,
	0x3c, 0xa8, 0xf4, 0x2f, 0x80, 0x71, 0xcc, 0x2f, 0x43, 0x5f, 0xc1, 0xd8, 0x98, 0x59, 0x54, 0x01,
	0x45, 0x50, 0xce, 0xef, 0x7c, 0xaa, 0x3d, 0xa0, 0x80, 0xc6, 0xd9, 0xfb, 0xcc, 0xa2, 0x9d, 0x99,
	0x4b, 0x71, 0x54, 0x82, 0xf2, 0x50, 0xb4, 0x2d, 0x45, 0x2c, 0x82, 0x72, 0x0e, 0x8b, 0xb6, 0x85,
	0x8a, 0x30, 0x63, 0x51, 0xbf, 0xef, 0xd9, 0xd1, 0x4e, 0x8a, 0x54, 0x04, 0xe5, 0x34, 0x5e, 0x7e,
	0x84, 0x10, 0x8c, 0x05, 0x64, 0xe8, 0x2b, 0xb1, 0xa2, 0x54, 0x4e, 0xe3, 0x28, 0x46, 0x55, 0x98,
	0xf2, 0xe9, 0x94, 0x7a, 0x76, 0x30, 0x53, 0xe2, 0x8f, 0x2c, 0x71, 0xb0, 0x20, 0x46, 0x4b, 0xdc,
	0x97, 0x95, 0xce, 0x25, 0x98, 0x6f, 0x38, 0xac, 0x47, 0x9c, 0x03, 0x97, 0xf6, 0x39, 0x88, 0xb4,
	0x95, 0xb3, 0x0a, 0x6b, 0x1d, 0x8f, 0xc8, 0x60, 0xed, 0x96, 0x6f, 0xe1, 0x26, 0x39, 0x61, 0x63,
	0xe2, 0xcc, 0xba, 0x7e, 0x9f, 0x79, 0xb4, 0x1b, 0x8c, 0x3c, 0xea, 0x8f, 0x98, 0xb3, 0x38, 0xb0,
	0x96, 0xfc, 0xeb, 0xcd, 0xdf, 0x92, 0x58, 0x11, 0xf0, 0xc6, 0x82, 0x77, 0xc0, 0x69, 0x9d, 0x3b,
	0x16, 0xfa, 0x02, 0xe6, 0x5d, 0xe2, 0x91, 0x13, 0x66, 0x93, 0xae, 0x43, 0xa7, 0xd4, 0x89, 0xee,
	0xcf, 0xd5, 0xd2, 0xbc, 0x2e, 0x56, 0x11, 0x95, 0x18, 0xce, 0xdd, 0x11, 0x9a, 0x1c, 0x47, 0xc7,
	0x30, 0x15, 0x99, 0x63, 0x5b, 0x73, 0x41, 0xf2, 0x3b, 0x9f, 0x3d, 0x70, 0x78, 0xe4, 0x1f, 0x5f,
	0x9a, 0x9b, 0x60, 0xee, 0xd5, 0x36, 0x78, 0xcf, 0xc4, 0x39, 0x90, 0xe4, 0x33, 0x91, 0x87, 0xf1,
	0x73, 0x20, 0x2a, 0x00, 0x27, 0x39, 0xd7, 0xb4, 0x7c, 0xf4, 0x3d, 0xcc, 0xdf, 0x97, 0x75, 0xb9,
	0xed, 0x8f, 0x0a, 0xbb, 0xe2, 0x6e, 0x96, 0x3f, 0x6b, 0xda, 0x7e, 0x10, 0x29, 0xb9, 0x0b, 0xa5,
	0x53, 0x32, 0x50, 0x12, 0x45, 0xa9, 0x9c, 0xd9, 0xd9, 0x5a, 0xeb, 0xd0, 0xee, 0xfd, 0x44, 0xfb,
	0x01, 0xa6, 0x03, 0x4e, 0xad, 0x25, 0xfe, 0xfc, 0x95, 0x73, 0x31, 0xff, 0x28, 0xfd, 0x27, 0xc2,
	0x7c, 0xdd, 0xa3, 0x24, 0xa0, 0x4f, 0x36, 0x65, 0xf7, 0x11, 0x53, 0x9e, 0xcf, 0x8b, 0xea, 0x53,
	0xbd, 0x78, 0x3f, 0xa2, 0x7f, 0xfd, 0xe1, 0xc5, 0x37, 0x6b, 0xdf, 0xe8, 0xd2, 0xff, 0x22, 0xfc,
	0x00, 0x53, 0xd7, 0x21, 0xfd, 0x17, 0x41, 0x9f, 0x45, 0xd0, 0x0b, 0x11, 0x66, 0x1a, 0x34, 0x78,
	0x11, 0xf3, 0x19, 0xc4, 0xac, 0x30, 0x98, 0x5d, 0xfe, 0x71, 0x46, 0x39, 0x98, 0x36, 0xf6, 0x0d,
	0xdc, 0x30, 0x5a, 0xf5, 0x1f, 0x64, 0x01, 0xa5, 0x61, 0xbc, 0xda, 0x34, 0x70, 0x47, 0x06, 0x28,
	0x0b, 0x53, 0x75, 0x6c, 0x76, 0xcc, 0x7a, 0xb5, 0x29, 0x8b, 0x1c, 0x30, 0x30, 0x6e, 0x63, 0x59,
	0x42, 0x19, 0x98, 0x3c, 0xaa, 0xe2, 0x96, 0xd9, 0x6a, 0xc8, 0x31, 0x04, 0x61, 0xa2, 0xd5, 0xee,
	0x98, 0x75, 0x43, 0x8e, 0xa3, 0x14, 0x8c, 0x99, 0xad, 0xef, 0xda, 0x72, 0x82, 0xb3, 0xf7, 0x8c,
	0xda, 0x61, 0x43, 0x4e, 0x56, 0xca, 0x30, 0xbb, 0xbc, 0x21, 0xaf, 0x36, 0x8e, 0xeb, 0xcd, 0xc3,
	0x3d, 0x43, 0x16, 0x78, 0x62, 0xb6, 0xe6, 0x09, 0xa8, 0xfd, 0x06, 0x2e, 0xaf, 0x55, 0xe1, 0xea,
	0x5a, 0x15, 0x6e, 0xaf, 0x55, 0x70, 0x16, 0xaa, 0xe0, 0x8f, 0x50, 0x05, 0xff, 0x84, 0x2a, 0xb8,
	0x0c, 0x55, 0x70, 0x15, 0xaa, 0xe0, 0x55, 0xa8, 0x82, 0xd7, 0xa1, 0x2a, 0xdc, 0x86, 0x2a, 0xf8,
	0xfd, 0x46, 0x15, 0x2e, 0x6f, 0x54, 0xe1, 0xea, 0x46, 0x15, 0x7e, 0xdc, 0x1f, 0x32, 0xf7, 0xe7,
	0xa1, 0x36, 0x65, 0x4e, 0x40, 0x3d, 0x8f, 0x68, 0x13, 0x5f, 0x8f, 0x82, 0x01, 0xf3, 0xc6, 0xdb,
	0xae, 0xc7, 0xa6, 0xb6, 0x45, 0xbd, 0xed, 0x3b, 0x58, 0x77, 0x7b, 0x43, 0xa6, 0xd3, 0x5f, 0x82,
	0xc5, 0xeb, 0x77, 0xfd, 0xaf, 0x46, 0x2f, 0x11, 0xbd, 0x7c, 0xbf, 0x7c, 0x1b, 0x00, 0x00, 0xff,
	0xff, 0x40, 0xc5, 0xb3, 0x4b, 0x8c, 0x08, 0x00, 0x00,
}

func (x SeverityType) String() string {
	s, ok := SeverityType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RuleModeType) String() string {
	s, ok := RuleModeType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Rules) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Rules)
	if !ok {
		that2, ok := that.(Rules)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if this.Severity != that1.Severity {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if this.AnomalyScoreThreshold != that1.AnomalyScoreThreshold {
		return false
	}
	if this.ParanoiaLevel != that1.ParanoiaLevel {
		return false
	}
	if len(this.RuleIds) != len(that1.RuleIds) {
		return false
	}
	for i := range this.RuleIds {
		if this.RuleIds[i] != that1.RuleIds[i] {
			return false
		}
	}
	if this.RuleListType != that1.RuleListType {
		return false
	}
	if len(this.Waf) != len(that1.Waf) {
		return false
	}
	for i := range this.Waf {
		if !this.Waf[i].Equal(that1.Waf[i]) {
			return false
		}
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if this.AnomalyScoreThreshold != that1.AnomalyScoreThreshold {
		return false
	}
	if this.ParanoiaLevel != that1.ParanoiaLevel {
		return false
	}
	if len(this.RuleIds) != len(that1.RuleIds) {
		return false
	}
	for i := range this.RuleIds {
		if this.RuleIds[i] != that1.RuleIds[i] {
			return false
		}
	}
	if this.RuleListType != that1.RuleListType {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if this.AnomalyScoreThreshold != that1.AnomalyScoreThreshold {
		return false
	}
	if this.ParanoiaLevel != that1.ParanoiaLevel {
		return false
	}
	if len(this.RuleIds) != len(that1.RuleIds) {
		return false
	}
	for i := range this.RuleIds {
		if this.RuleIds[i] != that1.RuleIds[i] {
			return false
		}
	}
	if this.RuleListType != that1.RuleListType {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if this.AnomalyScoreThreshold != that1.AnomalyScoreThreshold {
		return false
	}
	if this.ParanoiaLevel != that1.ParanoiaLevel {
		return false
	}
	if len(this.RuleIds) != len(that1.RuleIds) {
		return false
	}
	for i := range this.RuleIds {
		if this.RuleIds[i] != that1.RuleIds[i] {
			return false
		}
	}
	if this.RuleListType != that1.RuleListType {
		return false
	}
	return true
}
func (this *Rules) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&waf_rules.Rules{")
	s = append(s, "Mode: "+fmt.Sprintf("%#v", this.Mode)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Tags: "+fmt.Sprintf("%#v", this.Tags)+",\n")
	s = append(s, "Severity: "+fmt.Sprintf("%#v", this.Severity)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&waf_rules.GlobalSpecType{")
	s = append(s, "Mode: "+fmt.Sprintf("%#v", this.Mode)+",\n")
	s = append(s, "AnomalyScoreThreshold: "+fmt.Sprintf("%#v", this.AnomalyScoreThreshold)+",\n")
	s = append(s, "ParanoiaLevel: "+fmt.Sprintf("%#v", this.ParanoiaLevel)+",\n")
	s = append(s, "RuleIds: "+fmt.Sprintf("%#v", this.RuleIds)+",\n")
	s = append(s, "RuleListType: "+fmt.Sprintf("%#v", this.RuleListType)+",\n")
	if this.Waf != nil {
		s = append(s, "Waf: "+fmt.Sprintf("%#v", this.Waf)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&waf_rules.CreateSpecType{")
	s = append(s, "Mode: "+fmt.Sprintf("%#v", this.Mode)+",\n")
	s = append(s, "AnomalyScoreThreshold: "+fmt.Sprintf("%#v", this.AnomalyScoreThreshold)+",\n")
	s = append(s, "ParanoiaLevel: "+fmt.Sprintf("%#v", this.ParanoiaLevel)+",\n")
	s = append(s, "RuleIds: "+fmt.Sprintf("%#v", this.RuleIds)+",\n")
	s = append(s, "RuleListType: "+fmt.Sprintf("%#v", this.RuleListType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&waf_rules.ReplaceSpecType{")
	s = append(s, "Mode: "+fmt.Sprintf("%#v", this.Mode)+",\n")
	s = append(s, "AnomalyScoreThreshold: "+fmt.Sprintf("%#v", this.AnomalyScoreThreshold)+",\n")
	s = append(s, "ParanoiaLevel: "+fmt.Sprintf("%#v", this.ParanoiaLevel)+",\n")
	s = append(s, "RuleIds: "+fmt.Sprintf("%#v", this.RuleIds)+",\n")
	s = append(s, "RuleListType: "+fmt.Sprintf("%#v", this.RuleListType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&waf_rules.GetSpecType{")
	s = append(s, "Mode: "+fmt.Sprintf("%#v", this.Mode)+",\n")
	s = append(s, "AnomalyScoreThreshold: "+fmt.Sprintf("%#v", this.AnomalyScoreThreshold)+",\n")
	s = append(s, "ParanoiaLevel: "+fmt.Sprintf("%#v", this.ParanoiaLevel)+",\n")
	s = append(s, "RuleIds: "+fmt.Sprintf("%#v", this.RuleIds)+",\n")
	s = append(s, "RuleListType: "+fmt.Sprintf("%#v", this.RuleListType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Rules) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rules) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rules) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Severity != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Severity))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Id != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if m.Mode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Waf) > 0 {
		for iNdEx := len(m.Waf) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Waf[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.RuleListType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RuleListType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.RuleIds) > 0 {
		dAtA2 := make([]byte, len(m.RuleIds)*10)
		var j1 int
		for _, num := range m.RuleIds {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintTypes(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x22
	}
	if m.ParanoiaLevel != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ParanoiaLevel))
		i--
		dAtA[i] = 0x18
	}
	if m.AnomalyScoreThreshold != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AnomalyScoreThreshold))
		i--
		dAtA[i] = 0x10
	}
	if m.Mode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RuleListType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RuleListType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.RuleIds) > 0 {
		dAtA4 := make([]byte, len(m.RuleIds)*10)
		var j3 int
		for _, num := range m.RuleIds {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintTypes(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x22
	}
	if m.ParanoiaLevel != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ParanoiaLevel))
		i--
		dAtA[i] = 0x18
	}
	if m.AnomalyScoreThreshold != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AnomalyScoreThreshold))
		i--
		dAtA[i] = 0x10
	}
	if m.Mode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RuleListType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RuleListType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.RuleIds) > 0 {
		dAtA6 := make([]byte, len(m.RuleIds)*10)
		var j5 int
		for _, num := range m.RuleIds {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintTypes(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x22
	}
	if m.ParanoiaLevel != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ParanoiaLevel))
		i--
		dAtA[i] = 0x18
	}
	if m.AnomalyScoreThreshold != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AnomalyScoreThreshold))
		i--
		dAtA[i] = 0x10
	}
	if m.Mode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RuleListType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RuleListType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.RuleIds) > 0 {
		dAtA8 := make([]byte, len(m.RuleIds)*10)
		var j7 int
		for _, num := range m.RuleIds {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintTypes(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x22
	}
	if m.ParanoiaLevel != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ParanoiaLevel))
		i--
		dAtA[i] = 0x18
	}
	if m.AnomalyScoreThreshold != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AnomalyScoreThreshold))
		i--
		dAtA[i] = 0x10
	}
	if m.Mode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Rules) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovTypes(uint64(m.Mode))
	}
	if m.Id != 0 {
		n += 1 + sovTypes(uint64(m.Id))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Severity != 0 {
		n += 1 + sovTypes(uint64(m.Severity))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovTypes(uint64(m.Mode))
	}
	if m.AnomalyScoreThreshold != 0 {
		n += 1 + sovTypes(uint64(m.AnomalyScoreThreshold))
	}
	if m.ParanoiaLevel != 0 {
		n += 1 + sovTypes(uint64(m.ParanoiaLevel))
	}
	if len(m.RuleIds) > 0 {
		l = 0
		for _, e := range m.RuleIds {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.RuleListType != 0 {
		n += 1 + sovTypes(uint64(m.RuleListType))
	}
	if len(m.Waf) > 0 {
		for _, e := range m.Waf {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovTypes(uint64(m.Mode))
	}
	if m.AnomalyScoreThreshold != 0 {
		n += 1 + sovTypes(uint64(m.AnomalyScoreThreshold))
	}
	if m.ParanoiaLevel != 0 {
		n += 1 + sovTypes(uint64(m.ParanoiaLevel))
	}
	if len(m.RuleIds) > 0 {
		l = 0
		for _, e := range m.RuleIds {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.RuleListType != 0 {
		n += 1 + sovTypes(uint64(m.RuleListType))
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovTypes(uint64(m.Mode))
	}
	if m.AnomalyScoreThreshold != 0 {
		n += 1 + sovTypes(uint64(m.AnomalyScoreThreshold))
	}
	if m.ParanoiaLevel != 0 {
		n += 1 + sovTypes(uint64(m.ParanoiaLevel))
	}
	if len(m.RuleIds) > 0 {
		l = 0
		for _, e := range m.RuleIds {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.RuleListType != 0 {
		n += 1 + sovTypes(uint64(m.RuleListType))
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovTypes(uint64(m.Mode))
	}
	if m.AnomalyScoreThreshold != 0 {
		n += 1 + sovTypes(uint64(m.AnomalyScoreThreshold))
	}
	if m.ParanoiaLevel != 0 {
		n += 1 + sovTypes(uint64(m.ParanoiaLevel))
	}
	if len(m.RuleIds) > 0 {
		l = 0
		for _, e := range m.RuleIds {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.RuleListType != 0 {
		n += 1 + sovTypes(uint64(m.RuleListType))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Rules) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Rules{`,
		`Mode:` + fmt.Sprintf("%v", this.Mode) + `,`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Tags:` + fmt.Sprintf("%v", this.Tags) + `,`,
		`Severity:` + fmt.Sprintf("%v", this.Severity) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForWaf := "[]*ObjectRefType{"
	for _, f := range this.Waf {
		repeatedStringForWaf += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForWaf += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Mode:` + fmt.Sprintf("%v", this.Mode) + `,`,
		`AnomalyScoreThreshold:` + fmt.Sprintf("%v", this.AnomalyScoreThreshold) + `,`,
		`ParanoiaLevel:` + fmt.Sprintf("%v", this.ParanoiaLevel) + `,`,
		`RuleIds:` + fmt.Sprintf("%v", this.RuleIds) + `,`,
		`RuleListType:` + fmt.Sprintf("%v", this.RuleListType) + `,`,
		`Waf:` + repeatedStringForWaf + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Mode:` + fmt.Sprintf("%v", this.Mode) + `,`,
		`AnomalyScoreThreshold:` + fmt.Sprintf("%v", this.AnomalyScoreThreshold) + `,`,
		`ParanoiaLevel:` + fmt.Sprintf("%v", this.ParanoiaLevel) + `,`,
		`RuleIds:` + fmt.Sprintf("%v", this.RuleIds) + `,`,
		`RuleListType:` + fmt.Sprintf("%v", this.RuleListType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Mode:` + fmt.Sprintf("%v", this.Mode) + `,`,
		`AnomalyScoreThreshold:` + fmt.Sprintf("%v", this.AnomalyScoreThreshold) + `,`,
		`ParanoiaLevel:` + fmt.Sprintf("%v", this.ParanoiaLevel) + `,`,
		`RuleIds:` + fmt.Sprintf("%v", this.RuleIds) + `,`,
		`RuleListType:` + fmt.Sprintf("%v", this.RuleListType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`Mode:` + fmt.Sprintf("%v", this.Mode) + `,`,
		`AnomalyScoreThreshold:` + fmt.Sprintf("%v", this.AnomalyScoreThreshold) + `,`,
		`ParanoiaLevel:` + fmt.Sprintf("%v", this.ParanoiaLevel) + `,`,
		`RuleIds:` + fmt.Sprintf("%v", this.RuleIds) + `,`,
		`RuleListType:` + fmt.Sprintf("%v", this.RuleListType) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Rules) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= RuleModeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			m.Severity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Severity |= SeverityType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= schema.WafModeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnomalyScoreThreshold", wireType)
			}
			m.AnomalyScoreThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnomalyScoreThreshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParanoiaLevel", wireType)
			}
			m.ParanoiaLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParanoiaLevel |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v waf_rule_list.WafRuleID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= waf_rule_list.WafRuleID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RuleIds = append(m.RuleIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.RuleIds) == 0 {
					m.RuleIds = make([]waf_rule_list.WafRuleID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v waf_rule_list.WafRuleID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= waf_rule_list.WafRuleID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RuleIds = append(m.RuleIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleIds", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleListType", wireType)
			}
			m.RuleListType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuleListType |= RuleModeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Waf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Waf = append(m.Waf, &schema.ObjectRefType{})
			if err := m.Waf[len(m.Waf)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= schema.WafModeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnomalyScoreThreshold", wireType)
			}
			m.AnomalyScoreThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnomalyScoreThreshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParanoiaLevel", wireType)
			}
			m.ParanoiaLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParanoiaLevel |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v waf_rule_list.WafRuleID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= waf_rule_list.WafRuleID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RuleIds = append(m.RuleIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.RuleIds) == 0 {
					m.RuleIds = make([]waf_rule_list.WafRuleID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v waf_rule_list.WafRuleID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= waf_rule_list.WafRuleID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RuleIds = append(m.RuleIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleIds", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleListType", wireType)
			}
			m.RuleListType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuleListType |= RuleModeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= schema.WafModeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnomalyScoreThreshold", wireType)
			}
			m.AnomalyScoreThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnomalyScoreThreshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParanoiaLevel", wireType)
			}
			m.ParanoiaLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParanoiaLevel |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v waf_rule_list.WafRuleID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= waf_rule_list.WafRuleID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RuleIds = append(m.RuleIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.RuleIds) == 0 {
					m.RuleIds = make([]waf_rule_list.WafRuleID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v waf_rule_list.WafRuleID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= waf_rule_list.WafRuleID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RuleIds = append(m.RuleIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleIds", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleListType", wireType)
			}
			m.RuleListType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuleListType |= RuleModeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= schema.WafModeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnomalyScoreThreshold", wireType)
			}
			m.AnomalyScoreThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnomalyScoreThreshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParanoiaLevel", wireType)
			}
			m.ParanoiaLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParanoiaLevel |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v waf_rule_list.WafRuleID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= waf_rule_list.WafRuleID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RuleIds = append(m.RuleIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.RuleIds) == 0 {
					m.RuleIds = make([]waf_rule_list.WafRuleID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v waf_rule_list.WafRuleID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= waf_rule_list.WafRuleID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RuleIds = append(m.RuleIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleIds", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleListType", wireType)
			}
			m.RuleListType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuleListType |= RuleModeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
