// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package customer_support

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *CloseRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CloseRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CloseRequest) DeepCopy() *CloseRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CloseRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CloseRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CloseRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CloseRequestValidator().Validate(ctx, m, opts...)
}

type ValidateCloseRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCloseRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CloseRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CloseRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCloseRequestValidator = func() *ValidateCloseRequest {
	v := &ValidateCloseRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func CloseRequestValidator() db.Validator {
	return DefaultCloseRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *CloseResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CloseResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CloseResponse) DeepCopy() *CloseResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CloseResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CloseResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CloseResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CloseResponseValidator().Validate(ctx, m, opts...)
}

type ValidateCloseResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCloseResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CloseResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CloseResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["err"]; exists {

		vOpts := append(opts, db.WithValidateField("err"))
		if err := fv(ctx, m.GetErr(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCloseResponseValidator = func() *ValidateCloseResponse {
	v := &ValidateCloseResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func CloseResponseValidator() db.Validator {
	return DefaultCloseResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *CommentRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CommentRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CommentRequest) DeepCopy() *CommentRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CommentRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CommentRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CommentRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CommentRequestValidator().Validate(ctx, m, opts...)
}

type ValidateCommentRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCommentRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CommentRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CommentRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["attachments"]; exists {

		vOpts := append(opts, db.WithValidateField("attachments"))
		for idx, item := range m.GetAttachments() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["comment"]; exists {

		vOpts := append(opts, db.WithValidateField("comment"))
		if err := fv(ctx, m.GetComment(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCommentRequestValidator = func() *ValidateCommentRequest {
	v := &ValidateCommentRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func CommentRequestValidator() db.Validator {
	return DefaultCommentRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *CommentResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CommentResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CommentResponse) DeepCopy() *CommentResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CommentResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CommentResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CommentResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CommentResponseValidator().Validate(ctx, m, opts...)
}

type ValidateCommentResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCommentResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CommentResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CommentResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["err"]; exists {

		vOpts := append(opts, db.WithValidateField("err"))
		if err := fv(ctx, m.GetErr(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCommentResponseValidator = func() *ValidateCommentResponse {
	v := &ValidateCommentResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func CommentResponseValidator() db.Validator {
	return DefaultCommentResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *EscalationRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *EscalationRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *EscalationRequest) DeepCopy() *EscalationRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &EscalationRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *EscalationRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *EscalationRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EscalationRequestValidator().Validate(ctx, m, opts...)
}

type ValidateEscalationRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEscalationRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*EscalationRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *EscalationRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEscalationRequestValidator = func() *ValidateEscalationRequest {
	v := &ValidateEscalationRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func EscalationRequestValidator() db.Validator {
	return DefaultEscalationRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *EscalationResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *EscalationResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *EscalationResponse) DeepCopy() *EscalationResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &EscalationResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *EscalationResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *EscalationResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EscalationResponseValidator().Validate(ctx, m, opts...)
}

type ValidateEscalationResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEscalationResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*EscalationResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *EscalationResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["err"]; exists {

		vOpts := append(opts, db.WithValidateField("err"))
		if err := fv(ctx, m.GetErr(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEscalationResponseValidator = func() *ValidateEscalationResponse {
	v := &ValidateEscalationResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func EscalationResponseValidator() db.Validator {
	return DefaultEscalationResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *GetAttachmentRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetAttachmentRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetAttachmentRequest) DeepCopy() *GetAttachmentRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetAttachmentRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetAttachmentRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetAttachmentRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetAttachmentRequestValidator().Validate(ctx, m, opts...)
}

type ValidateGetAttachmentRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetAttachmentRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetAttachmentRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetAttachmentRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["attachment_id"]; exists {

		vOpts := append(opts, db.WithValidateField("attachment_id"))
		if err := fv(ctx, m.GetAttachmentId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["comment_id"]; exists {

		vOpts := append(opts, db.WithValidateField("comment_id"))
		if err := fv(ctx, m.GetCommentId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetAttachmentRequestValidator = func() *ValidateGetAttachmentRequest {
	v := &ValidateGetAttachmentRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetAttachmentRequestValidator() db.Validator {
	return DefaultGetAttachmentRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ListSupportRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListSupportRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListSupportRequest) DeepCopy() *ListSupportRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListSupportRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListSupportRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListSupportRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListSupportRequestValidator().Validate(ctx, m, opts...)
}

type ValidateListSupportRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListSupportRequest) PriorityValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(SupportTicketPriority)
		return int32(i)
	}
	// SupportTicketPriority_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, SupportTicketPriority_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for priority")
	}
	itemsValidatorFn := func(ctx context.Context, elems []SupportTicketPriority, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for priority")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]SupportTicketPriority)
		if !ok {
			return fmt.Errorf("Repeated validation expected []SupportTicketPriority, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated priority")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items priority")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateListSupportRequest) StatusValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(SupportTicketStatus)
		return int32(i)
	}
	// SupportTicketStatus_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, SupportTicketStatus_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for status")
	}
	itemsValidatorFn := func(ctx context.Context, elems []SupportTicketStatus, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for status")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]SupportTicketStatus)
		if !ok {
			return fmt.Errorf("Repeated validation expected []SupportTicketStatus, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated status")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items status")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateListSupportRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListSupportRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListSupportRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["priority"]; exists {
		vOpts := append(opts, db.WithValidateField("priority"))
		if err := fv(ctx, m.GetPriority(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {
		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListSupportRequestValidator = func() *ValidateListSupportRequest {
	v := &ValidateListSupportRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPriority := v.PriorityValidationRuleHandler
	rulesPriority := map[string]string{
		"ves.io.schema.rules.message.required":                 "true",
		"ves.io.schema.rules.repeated.items.enum.defined_only": "true",
		"ves.io.schema.rules.repeated.items.enum.not_in":       "0",
		"ves.io.schema.rules.repeated.min_items":               "1",
		"ves.io.schema.rules.repeated.unique":                  "true",
	}
	vFn, err = vrhPriority(rulesPriority)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListSupportRequest.priority: %s", err)
		panic(errMsg)
	}
	v.FldValidators["priority"] = vFn

	vrhStatus := v.StatusValidationRuleHandler
	rulesStatus := map[string]string{
		"ves.io.schema.rules.message.required":                 "true",
		"ves.io.schema.rules.repeated.items.enum.defined_only": "true",
		"ves.io.schema.rules.repeated.items.enum.not_in":       "0",
		"ves.io.schema.rules.repeated.min_items":               "1",
		"ves.io.schema.rules.repeated.unique":                  "true",
	}
	vFn, err = vrhStatus(rulesStatus)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListSupportRequest.status: %s", err)
		panic(errMsg)
	}
	v.FldValidators["status"] = vFn

	return v
}()

func ListSupportRequestValidator() db.Validator {
	return DefaultListSupportRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ListSupportResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListSupportResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListSupportResponse) DeepCopy() *ListSupportResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListSupportResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListSupportResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListSupportResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListSupportResponseValidator().Validate(ctx, m, opts...)
}

func (m *ListSupportResponse) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetItemsDRefInfo()

}

// GetDRefInfo for the field's type
func (m *ListSupportResponse) GetItemsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetItems() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetItems() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetItems() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("items[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateListSupportResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListSupportResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListSupportResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListSupportResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["errors"]; exists {

		vOpts := append(opts, db.WithValidateField("errors"))
		for idx, item := range m.GetErrors() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["items"]; exists {

		vOpts := append(opts, db.WithValidateField("items"))
		for idx, item := range m.GetItems() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListSupportResponseValidator = func() *ValidateListSupportResponse {
	v := &ValidateListSupportResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["items"] = ListResponseItemValidator().Validate

	return v
}()

func ListSupportResponseValidator() db.Validator {
	return DefaultListSupportResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *PriorityRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PriorityRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PriorityRequest) DeepCopy() *PriorityRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PriorityRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PriorityRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PriorityRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PriorityRequestValidator().Validate(ctx, m, opts...)
}

type ValidatePriorityRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePriorityRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PriorityRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PriorityRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["priority"]; exists {

		vOpts := append(opts, db.WithValidateField("priority"))
		if err := fv(ctx, m.GetPriority(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPriorityRequestValidator = func() *ValidatePriorityRequest {
	v := &ValidatePriorityRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func PriorityRequestValidator() db.Validator {
	return DefaultPriorityRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *PriorityResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PriorityResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PriorityResponse) DeepCopy() *PriorityResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PriorityResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PriorityResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PriorityResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PriorityResponseValidator().Validate(ctx, m, opts...)
}

type ValidatePriorityResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePriorityResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PriorityResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PriorityResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["err"]; exists {

		vOpts := append(opts, db.WithValidateField("err"))
		if err := fv(ctx, m.GetErr(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPriorityResponseValidator = func() *ValidatePriorityResponse {
	v := &ValidatePriorityResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func PriorityResponseValidator() db.Validator {
	return DefaultPriorityResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *RaiseTaxExemptVerificationSupportTicketRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RaiseTaxExemptVerificationSupportTicketRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RaiseTaxExemptVerificationSupportTicketRequest) DeepCopy() *RaiseTaxExemptVerificationSupportTicketRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RaiseTaxExemptVerificationSupportTicketRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RaiseTaxExemptVerificationSupportTicketRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RaiseTaxExemptVerificationSupportTicketRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RaiseTaxExemptVerificationSupportTicketRequestValidator().Validate(ctx, m, opts...)
}

type ValidateRaiseTaxExemptVerificationSupportTicketRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRaiseTaxExemptVerificationSupportTicketRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RaiseTaxExemptVerificationSupportTicketRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RaiseTaxExemptVerificationSupportTicketRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["attachments"]; exists {

		vOpts := append(opts, db.WithValidateField("attachments"))
		for idx, item := range m.GetAttachments() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["request_description"]; exists {

		vOpts := append(opts, db.WithValidateField("request_description"))
		if err := fv(ctx, m.GetRequestDescription(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRaiseTaxExemptVerificationSupportTicketRequestValidator = func() *ValidateRaiseTaxExemptVerificationSupportTicketRequest {
	v := &ValidateRaiseTaxExemptVerificationSupportTicketRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func RaiseTaxExemptVerificationSupportTicketRequestValidator() db.Validator {
	return DefaultRaiseTaxExemptVerificationSupportTicketRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *RaiseTaxExemptVerificationSupportTicketResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RaiseTaxExemptVerificationSupportTicketResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RaiseTaxExemptVerificationSupportTicketResponse) DeepCopy() *RaiseTaxExemptVerificationSupportTicketResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RaiseTaxExemptVerificationSupportTicketResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RaiseTaxExemptVerificationSupportTicketResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RaiseTaxExemptVerificationSupportTicketResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RaiseTaxExemptVerificationSupportTicketResponseValidator().Validate(ctx, m, opts...)
}

type ValidateRaiseTaxExemptVerificationSupportTicketResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRaiseTaxExemptVerificationSupportTicketResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RaiseTaxExemptVerificationSupportTicketResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RaiseTaxExemptVerificationSupportTicketResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["err"]; exists {

		vOpts := append(opts, db.WithValidateField("err"))
		if err := fv(ctx, m.GetErr(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRaiseTaxExemptVerificationSupportTicketResponseValidator = func() *ValidateRaiseTaxExemptVerificationSupportTicketResponse {
	v := &ValidateRaiseTaxExemptVerificationSupportTicketResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func RaiseTaxExemptVerificationSupportTicketResponseValidator() db.Validator {
	return DefaultRaiseTaxExemptVerificationSupportTicketResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *ReopenRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReopenRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ReopenRequest) DeepCopy() *ReopenRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReopenRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReopenRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReopenRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReopenRequestValidator().Validate(ctx, m, opts...)
}

type ValidateReopenRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReopenRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReopenRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReopenRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReopenRequestValidator = func() *ValidateReopenRequest {
	v := &ValidateReopenRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ReopenRequestValidator() db.Validator {
	return DefaultReopenRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ReopenResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReopenResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ReopenResponse) DeepCopy() *ReopenResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReopenResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReopenResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReopenResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReopenResponseValidator().Validate(ctx, m, opts...)
}

type ValidateReopenResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReopenResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReopenResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReopenResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["err"]; exists {

		vOpts := append(opts, db.WithValidateField("err"))
		if err := fv(ctx, m.GetErr(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReopenResponseValidator = func() *ValidateReopenResponse {
	v := &ValidateReopenResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ReopenResponseValidator() db.Validator {
	return DefaultReopenResponseValidator
}
