// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/customer_support/types.proto

package customer_support

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SupportService
//
// x-displayName: "Support Service"
// Indicates the list of support service
type SupportService int32

const (
	// x-displayName: "Unknown"
	// Unknown Support Service
	SS_UNKNOWN SupportService = 0
	// x-displayName: "Account Protection"
	// Account Protection Support Service
	SS_ACCOUNT_PROTECTION SupportService = 1
	// x-displayName: "Administration"
	// Administration Support Service
	SS_ADMINISTRATION SupportService = 2
	// x-displayName: "Application Traffic Insight"
	// Application Traffic Insight Support Service
	SS_APPLICATION_TRAFFIC_INSIGHT SupportService = 3
	// x-displayName: "Audit Logs & Alerts"
	// Audit Logs & Alerts Support Service
	SS_AUDIT_LOGS_AND_ALERTS SupportService = 4
	// x-displayName: "Authentication Intelligence"
	// Authentication Intelligence Support Service
	SS_AUTHENTICATION_INTELLIGENCE SupportService = 5
	// x-displayName: "Billing"
	// Billing Support Service
	SS_BILLING SupportService = 6
	// x-displayName: "Client Side Defense"
	// Client Side Defense Support Service
	SS_CLIENT_SIDE_DEFENSE SupportService = 7
	// x-displayName: "Cloud & Edge Sites"
	// Cloud & Edge Sites Support Service
	// deprecated: use SS_MULTI_CLOUD_NETWORK_CONNECT instead
	SS_CLOUD_AND_EDGE_SITES SupportService = 8
	// x-displayName: "DDOS & Transit Services"
	// DDOS & Transit Support Service
	// Deprecated: use SS_ROUTED_DDOS instead
	SS_DDOS_AND_TRANSIT_SERVICES SupportService = 9
	// x-displayName: "Distributed Apps"
	// Distributed Apps Support Service
	SS_DISTRIBUTED_APPS SupportService = 10
	// x-displayName: "DNS Management"
	// DNS Management Support Service
	SS_DNS_MANAGEMENT SupportService = 11
	// x-displayName: "LoadBalancers"
	// LoadBalancers Support Service
	// deprecated: use SS_MULTI_CLOUD_APP_CONNECT instead
	SS_LOAD_BALANCERS SupportService = 12
	// x-displayName: "Shared Configuration"
	// Shared Configuration Support Service
	SS_SHARED_CONFIGURATION SupportService = 13
	// x-displayName: "Web App & API Protection"
	// Web App & API Protection Support Service
	SS_WEB_APP_AND_API_PROTECTION SupportService = 15
	// x-displayName: "Other"
	// Other Support Service
	SS_OTHER SupportService = 16
	// x-displayName: "Bot Defense"
	// Bot Defense Support Service
	SS_BOT_DEFENSE SupportService = 17
	// x-displayName: "CDN"
	// Content delivery network Support Service
	SS_CDN SupportService = 18
	// x-displayName: "Observability"
	// Observability Support Service
	SS_OBSERVABILITY SupportService = 20
	// x-displayName: "Delegated Access"
	// Delegated Access Support Service
	SS_DELEGATED_ACCESS SupportService = 22
	// x-displayName: "Multi Cloud Network Connect"
	// Networking & security across clouds, edge and on-premises
	SS_MULTI_CLOUD_NETWORK_CONNECT SupportService = 24
	// x-displayName: "Multi Cloud App Connect"
	// Connect apps across clouds, edge and on-premises using Load Balancers
	SS_MULTI_CLOUD_APP_CONNECT SupportService = 25
	// x-displayName: "BIG-IP APM"
	// BIG-IP Access Policy Manager (APM)
	SS_BIG_IP_APM SupportService = 27
	// x-displayName: "Data Intelligence"
	// Data Intelligence Support Service
	SS_DATA_INTELLIGENCE SupportService = 28
	// x-displayName: "NGINX One"
	// NGINX One Support Service
	SS_NGINX_ONE SupportService = 29
	// x-displayName: "Web App Scanning"
	// Web App Scanning Support Service
	SS_WEB_APP_SCANNING SupportService = 30
	// x-displayName: "Routed DDoS"
	// Routed DDoS Support Service
	SS_ROUTED_DDOS SupportService = 31
	// x-displayName: "Mobile App Shield"
	// Mobile App Shield protects mobile apps from reverse engineering, tampering and malware
	SS_MOBILE_APP_SHIELD SupportService = 32
)

var SupportService_name = map[int32]string{
	0:  "SS_UNKNOWN",
	1:  "SS_ACCOUNT_PROTECTION",
	2:  "SS_ADMINISTRATION",
	3:  "SS_APPLICATION_TRAFFIC_INSIGHT",
	4:  "SS_AUDIT_LOGS_AND_ALERTS",
	5:  "SS_AUTHENTICATION_INTELLIGENCE",
	6:  "SS_BILLING",
	7:  "SS_CLIENT_SIDE_DEFENSE",
	8:  "SS_CLOUD_AND_EDGE_SITES",
	9:  "SS_DDOS_AND_TRANSIT_SERVICES",
	10: "SS_DISTRIBUTED_APPS",
	11: "SS_DNS_MANAGEMENT",
	12: "SS_LOAD_BALANCERS",
	13: "SS_SHARED_CONFIGURATION",
	15: "SS_WEB_APP_AND_API_PROTECTION",
	16: "SS_OTHER",
	17: "SS_BOT_DEFENSE",
	18: "SS_CDN",
	20: "SS_OBSERVABILITY",
	22: "SS_DELEGATED_ACCESS",
	24: "SS_MULTI_CLOUD_NETWORK_CONNECT",
	25: "SS_MULTI_CLOUD_APP_CONNECT",
	27: "SS_BIG_IP_APM",
	28: "SS_DATA_INTELLIGENCE",
	29: "SS_NGINX_ONE",
	30: "SS_WEB_APP_SCANNING",
	31: "SS_ROUTED_DDOS",
	32: "SS_MOBILE_APP_SHIELD",
}

var SupportService_value = map[string]int32{
	"SS_UNKNOWN":                     0,
	"SS_ACCOUNT_PROTECTION":          1,
	"SS_ADMINISTRATION":              2,
	"SS_APPLICATION_TRAFFIC_INSIGHT": 3,
	"SS_AUDIT_LOGS_AND_ALERTS":       4,
	"SS_AUTHENTICATION_INTELLIGENCE": 5,
	"SS_BILLING":                     6,
	"SS_CLIENT_SIDE_DEFENSE":         7,
	"SS_CLOUD_AND_EDGE_SITES":        8,
	"SS_DDOS_AND_TRANSIT_SERVICES":   9,
	"SS_DISTRIBUTED_APPS":            10,
	"SS_DNS_MANAGEMENT":              11,
	"SS_LOAD_BALANCERS":              12,
	"SS_SHARED_CONFIGURATION":        13,
	"SS_WEB_APP_AND_API_PROTECTION":  15,
	"SS_OTHER":                       16,
	"SS_BOT_DEFENSE":                 17,
	"SS_CDN":                         18,
	"SS_OBSERVABILITY":               20,
	"SS_DELEGATED_ACCESS":            22,
	"SS_MULTI_CLOUD_NETWORK_CONNECT": 24,
	"SS_MULTI_CLOUD_APP_CONNECT":     25,
	"SS_BIG_IP_APM":                  27,
	"SS_DATA_INTELLIGENCE":           28,
	"SS_NGINX_ONE":                   29,
	"SS_WEB_APP_SCANNING":            30,
	"SS_ROUTED_DDOS":                 31,
	"SS_MOBILE_APP_SHIELD":           32,
}

func (SupportService) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e6b5b8084babe616, []int{0}
}

// SupportTopic
//
// x-displayName: "Support Topic"
// Support Topic indicates the list of topics for service tickets
type SupportTopic int32

const (
	// x-displayName: "Unknown"
	// Unknown/empty priority
	TOPIC_UNKNOWN SupportTopic = 0
	// x-displayName: "Access Request"
	// ACCOUNT_SUPPORT_TOPIC_ACCESS_REQUEST
	ACCOUNT_SUPPORT_TOPIC_ACCESS_REQUEST SupportTopic = 1
	// x-displayName: "Account"
	// ACCOUNT_SUPPORT_TOPIC_ACCOUNT
	ACCOUNT_SUPPORT_TOPIC_ACCOUNT SupportTopic = 2
	// x-displayName: "Billing"
	// ACCOUNT_SUPPORT_TOPIC_BILLING
	ACCOUNT_SUPPORT_TOPIC_BILLING SupportTopic = 3
	// x-displayName: "Billing Plan Change"
	// ACCOUNT_SUPPORT_TOPIC_BILLING_PLAN_CHANGE
	ACCOUNT_SUPPORT_TOPIC_BILLING_PLAN_CHANGE SupportTopic = 4
	// x-displayName: "Public IP"
	// ACCOUNT_SUPPORT_TOPIC_PUBLIC_IP
	ACCOUNT_SUPPORT_TOPIC_PUBLIC_IP SupportTopic = 5
	// x-displayName: "Quota Increase"
	// ACCOUNT_SUPPORT_TOPIC_QUOTA_INCREASE
	ACCOUNT_SUPPORT_TOPIC_QUOTA_INCREASE SupportTopic = 6
	// x-displayName: "RMA"
	// ACCOUNT_SUPPORT_TOPIC_RMA
	ACCOUNT_SUPPORT_TOPIC_RMA SupportTopic = 7
	// x-displayName: "Tax Exempt Verification"
	// ACCOUNT_SUPPORT_TOPIC_TAX_EXEMPT_VERIFICATION
	ACCOUNT_SUPPORT_TOPIC_TAX_EXEMPT_VERIFICATION SupportTopic = 8
	// x-displayName: "Other topics"
	// ACCOUNT_SUPPORT_TOPIC_OTHERS
	ACCOUNT_SUPPORT_TOPIC_OTHERS SupportTopic = 9
	// x-displayName: "Configuration Changes"
	// TECHNICAL_SUPPORT_TOPIC_CONFIGURATION_CHANGES
	TECHNICAL_SUPPORT_TOPIC_CONFIGURATION_CHANGES SupportTopic = 10
	// x-displayName: "Error Message"
	// TECHNICAL_SUPPORT_TOPIC_ERROR_MESSAGE
	TECHNICAL_SUPPORT_TOPIC_ERROR_MESSAGE SupportTopic = 11
	// x-displayName: "New Configuration"
	// TECHNICAL_SUPPORT_TOPIC_NEW_CONFIGURATION
	TECHNICAL_SUPPORT_TOPIC_NEW_CONFIGURATION SupportTopic = 12
	// x-displayName: "Product Questions"
	// TECHNICAL_SUPPORT_TOPIC_PRODUCT_QUESTION
	TECHNICAL_SUPPORT_TOPIC_PRODUCT_QUESTION SupportTopic = 13
	// x-displayName: "Troubleshooting"
	// TECHNICAL_SUPPORT_TOPIC_TROUBLESHOOTING
	TECHNICAL_SUPPORT_TOPIC_TROUBLESHOOTING SupportTopic = 14
	// x-displayName: "Other Topics"
	// TECHNICAL_SUPPORT_TOPIC_OTHERS
	TECHNICAL_SUPPORT_TOPIC_OTHERS SupportTopic = 15
	// x-displayName: "Latency"
	// INCIDENT_SUPPORT_TOPIC_LATENCY
	INCIDENT_SUPPORT_TOPIC_LATENCY SupportTopic = 16
	// x-displayName: "Performance Degradation"
	// INCIDENT_SUPPORT_TOPIC_PERFORMANCE_DEGRADATION
	INCIDENT_SUPPORT_TOPIC_PERFORMANCE_DEGRADATION SupportTopic = 17
	// x-displayName: "Partial Outage"
	// INCIDENT_SUPPORT_TOPIC_PARTIAL_OUTAGE
	INCIDENT_SUPPORT_TOPIC_PARTIAL_OUTAGE SupportTopic = 18
	// x-displayName: "Complete Outage"
	// INCIDENT_SUPPORT_TOPIC_COMPLETE_OUTAGE
	INCIDENT_SUPPORT_TOPIC_COMPLETE_OUTAGE SupportTopic = 19
	// x-displayName: "Other Topics"
	// INCIDENT_SUPPORT_TOPIC_OTHERS
	INCIDENT_SUPPORT_TOPIC_OTHERS SupportTopic = 20
	// x-displayName: "Plan Transition"
	// TASK_TOPIC_PLAN_TRANSITION
	TASK_TOPIC_PLAN_TRANSITION SupportTopic = 21
	// x-displayName: "Support Alert"
	// PROBLEM_TOPIC_SUPPORT_ALERT
	PROBLEM_TOPIC_SUPPORT_ALERT SupportTopic = 22
	// x-displayName: "Infrastructure"
	// QUESTION_TOPIC_INFRASTRUCTURE
	QUESTION_TOPIC_INFRASTRUCTURE SupportTopic = 23
	// x-displayName: "Delegated Domain migration"
	// TECHNICAL_SUPPORT_TOPIC_DELEGATED_DOMAIN_MIGRATION
	TECHNICAL_SUPPORT_TOPIC_DELEGATED_DOMAIN_MIGRATION SupportTopic = 24
)

var SupportTopic_name = map[int32]string{
	0:  "TOPIC_UNKNOWN",
	1:  "ACCOUNT_SUPPORT_TOPIC_ACCESS_REQUEST",
	2:  "ACCOUNT_SUPPORT_TOPIC_ACCOUNT",
	3:  "ACCOUNT_SUPPORT_TOPIC_BILLING",
	4:  "ACCOUNT_SUPPORT_TOPIC_BILLING_PLAN_CHANGE",
	5:  "ACCOUNT_SUPPORT_TOPIC_PUBLIC_IP",
	6:  "ACCOUNT_SUPPORT_TOPIC_QUOTA_INCREASE",
	7:  "ACCOUNT_SUPPORT_TOPIC_RMA",
	8:  "ACCOUNT_SUPPORT_TOPIC_TAX_EXEMPT_VERIFICATION",
	9:  "ACCOUNT_SUPPORT_TOPIC_OTHERS",
	10: "TECHNICAL_SUPPORT_TOPIC_CONFIGURATION_CHANGES",
	11: "TECHNICAL_SUPPORT_TOPIC_ERROR_MESSAGE",
	12: "TECHNICAL_SUPPORT_TOPIC_NEW_CONFIGURATION",
	13: "TECHNICAL_SUPPORT_TOPIC_PRODUCT_QUESTION",
	14: "TECHNICAL_SUPPORT_TOPIC_TROUBLESHOOTING",
	15: "TECHNICAL_SUPPORT_TOPIC_OTHERS",
	16: "INCIDENT_SUPPORT_TOPIC_LATENCY",
	17: "INCIDENT_SUPPORT_TOPIC_PERFORMANCE_DEGRADATION",
	18: "INCIDENT_SUPPORT_TOPIC_PARTIAL_OUTAGE",
	19: "INCIDENT_SUPPORT_TOPIC_COMPLETE_OUTAGE",
	20: "INCIDENT_SUPPORT_TOPIC_OTHERS",
	21: "TASK_TOPIC_PLAN_TRANSITION",
	22: "PROBLEM_TOPIC_SUPPORT_ALERT",
	23: "QUESTION_TOPIC_INFRASTRUCTURE",
	24: "TECHNICAL_SUPPORT_TOPIC_DELEGATED_DOMAIN_MIGRATION",
}

var SupportTopic_value = map[string]int32{
	"TOPIC_UNKNOWN":                                      0,
	"ACCOUNT_SUPPORT_TOPIC_ACCESS_REQUEST":               1,
	"ACCOUNT_SUPPORT_TOPIC_ACCOUNT":                      2,
	"ACCOUNT_SUPPORT_TOPIC_BILLING":                      3,
	"ACCOUNT_SUPPORT_TOPIC_BILLING_PLAN_CHANGE":          4,
	"ACCOUNT_SUPPORT_TOPIC_PUBLIC_IP":                    5,
	"ACCOUNT_SUPPORT_TOPIC_QUOTA_INCREASE":               6,
	"ACCOUNT_SUPPORT_TOPIC_RMA":                          7,
	"ACCOUNT_SUPPORT_TOPIC_TAX_EXEMPT_VERIFICATION":      8,
	"ACCOUNT_SUPPORT_TOPIC_OTHERS":                       9,
	"TECHNICAL_SUPPORT_TOPIC_CONFIGURATION_CHANGES":      10,
	"TECHNICAL_SUPPORT_TOPIC_ERROR_MESSAGE":              11,
	"TECHNICAL_SUPPORT_TOPIC_NEW_CONFIGURATION":          12,
	"TECHNICAL_SUPPORT_TOPIC_PRODUCT_QUESTION":           13,
	"TECHNICAL_SUPPORT_TOPIC_TROUBLESHOOTING":            14,
	"TECHNICAL_SUPPORT_TOPIC_OTHERS":                     15,
	"INCIDENT_SUPPORT_TOPIC_LATENCY":                     16,
	"INCIDENT_SUPPORT_TOPIC_PERFORMANCE_DEGRADATION":     17,
	"INCIDENT_SUPPORT_TOPIC_PARTIAL_OUTAGE":              18,
	"INCIDENT_SUPPORT_TOPIC_COMPLETE_OUTAGE":             19,
	"INCIDENT_SUPPORT_TOPIC_OTHERS":                      20,
	"TASK_TOPIC_PLAN_TRANSITION":                         21,
	"PROBLEM_TOPIC_SUPPORT_ALERT":                        22,
	"QUESTION_TOPIC_INFRASTRUCTURE":                      23,
	"TECHNICAL_SUPPORT_TOPIC_DELEGATED_DOMAIN_MIGRATION": 24,
}

func (SupportTopic) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e6b5b8084babe616, []int{1}
}

// SupportTicketPriority
//
// x-displayName: "Priority"
// Support ticket priority helps understand importance of the ticket and focus
// more on more critical issues.
type SupportTicketPriority int32

const (
	// x-displayName: "Unknown"
	// Unknown/empty priority
	PRIORITY_UNKNOWN SupportTicketPriority = 0
	// x-displayName: "Normal"
	// Normal priority issue
	PRIORITY_NORMAL SupportTicketPriority = 1
	// x-displayName: "High"
	// High priority issue
	PRIORITY_HIGH SupportTicketPriority = 2
	// x-displayName: "Urgent"
	// Urgent priority issue
	PRIORITY_URGENT SupportTicketPriority = 3
)

var SupportTicketPriority_name = map[int32]string{
	0: "PRIORITY_UNKNOWN",
	1: "PRIORITY_NORMAL",
	2: "PRIORITY_HIGH",
	3: "PRIORITY_URGENT",
}

var SupportTicketPriority_value = map[string]int32{
	"PRIORITY_UNKNOWN": 0,
	"PRIORITY_NORMAL":  1,
	"PRIORITY_HIGH":    2,
	"PRIORITY_URGENT":  3,
}

func (SupportTicketPriority) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e6b5b8084babe616, []int{2}
}

// SupportTicketType
//
// x-displayName: "Support Ticket"
// Several types of issues are supported, such as problems, questions.
type SupportTicketType int32

const (
	// x-displayName: "Unknown"
	// Unknown or empty ticket type
	TYPE_UNKNOWN SupportTicketType = 0
	// x-displayName: "Problem"
	// Indicates a problem (e.g. misconfiguration)
	TYPE_PROBLEM SupportTicketType = 1
	// x-displayName: "Task"
	// Indicates a task (a request to do something)
	TYPE_TASK SupportTicketType = 2
	// x-displayName: "Question"
	// Indicates a question (billing, services related)
	TYPE_QUESTION SupportTicketType = 3
	// x-displayName: "Incident"
	// Indicates an incident (something is not working)
	TYPE_INCIDENT SupportTicketType = 4
	// x-displayName: "Technical support"
	// Indicates a technical support ticket
	TYPE_TECHNICAL_SUPPORT SupportTicketType = 5
	// x-displayName: "Account support"
	// Indicates an account support ticket
	TYPE_ACCOUNT_SUPPORT SupportTicketType = 6
	// x-displayName: "Incident support"
	// Indicates an Incident support ticket
	TYPE_INCIDENT_SUPPORT SupportTicketType = 7
)

var SupportTicketType_name = map[int32]string{
	0: "TYPE_UNKNOWN",
	1: "TYPE_PROBLEM",
	2: "TYPE_TASK",
	3: "TYPE_QUESTION",
	4: "TYPE_INCIDENT",
	5: "TYPE_TECHNICAL_SUPPORT",
	6: "TYPE_ACCOUNT_SUPPORT",
	7: "TYPE_INCIDENT_SUPPORT",
}

var SupportTicketType_value = map[string]int32{
	"TYPE_UNKNOWN":           0,
	"TYPE_PROBLEM":           1,
	"TYPE_TASK":              2,
	"TYPE_QUESTION":          3,
	"TYPE_INCIDENT":          4,
	"TYPE_TECHNICAL_SUPPORT": 5,
	"TYPE_ACCOUNT_SUPPORT":   6,
	"TYPE_INCIDENT_SUPPORT":  7,
}

func (SupportTicketType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e6b5b8084babe616, []int{3}
}

// SupportTicketStatus
//
// x-displayName: "Support Ticket Status"
// State of the ticket so the customers know if the problem is being looked into
type SupportTicketStatus int32

const (
	// x-displayName: "Unknown"
	// Unknown or empty support ticket status
	STATUS_UNKNOWN SupportTicketStatus = 0
	// x-displayName: "New"
	// Indicates a new ticket, waiting to be assigned to an agent
	STATUS_NEW SupportTicketStatus = 1
	// x-displayName: "Open"
	// Indicates an open issues, actively being looked into
	STATUS_OPEN SupportTicketStatus = 2
	// x-displayName: "Pending"
	// Indicates a pending issue, an open issue not actively being looked into
	STATUS_PENDING SupportTicketStatus = 3
	// x-displayName: "On-hold"
	// Indicates on issue that on-hold, waiting for more information
	STATUS_ONHOLD SupportTicketStatus = 4
	// x-displayName: "Solved"
	// Indicates a solved issue, waiting for customer's confirmation
	STATUS_SOLVED SupportTicketStatus = 5
	// x-displayName: "Closed"
	// Indicates a closed issue, resolved and customer approved
	STATUS_CLOSED SupportTicketStatus = 6
	// x-displayName: "Failed"
	// Indicates a failed ticket, a failed ticket didn't make it into Zendesk and a customer should create new one instead
	STATUS_FAILED SupportTicketStatus = 7
)

var SupportTicketStatus_name = map[int32]string{
	0: "STATUS_UNKNOWN",
	1: "STATUS_NEW",
	2: "STATUS_OPEN",
	3: "STATUS_PENDING",
	4: "STATUS_ONHOLD",
	5: "STATUS_SOLVED",
	6: "STATUS_CLOSED",
	7: "STATUS_FAILED",
}

var SupportTicketStatus_value = map[string]int32{
	"STATUS_UNKNOWN": 0,
	"STATUS_NEW":     1,
	"STATUS_OPEN":    2,
	"STATUS_PENDING": 3,
	"STATUS_ONHOLD":  4,
	"STATUS_SOLVED":  5,
	"STATUS_CLOSED":  6,
	"STATUS_FAILED":  7,
}

func (SupportTicketStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e6b5b8084babe616, []int{4}
}

// Attachment
//
// x-displayName: "Attachment"
// Attachment represents a single support ticket comment attachment. Attachment are normally not store with the ticket itself,
// they represent a handle in the third party, so the contact can be retrieved omn demand.
type AttachmentType struct {
	// Binary attachment
	//
	// x-displayName: "Attachment data"
	// x-example: "dGVzdCBhdHRhY2htZW50"
	// Any binary attachment (such as screenshots, plain text files, PDFs) encoded as base64 if used over HTTP.
	Attachment []byte `protobuf:"bytes,1,opt,name=attachment,proto3" json:"attachment,omitempty"`
	// Filename of the attachment
	//
	// x-displayName: "Filename"
	// x-example: "attachment.pdf"
	// Filename of the attachment as provided by the caller.
	Filename string `protobuf:"bytes,2,opt,name=filename,proto3" json:"filename,omitempty"`
	// Content type
	//
	// x-displayName: "Content type"
	// x-example: "application/pdf"
	// Mime content type of the attachment. Helps the UI to properly display the data.
	ContentType string `protobuf:"bytes,3,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	// 3rd party ID
	//
	// x-displayName: "3rd party ID"
	// x-example: "1234"
	// Optional ID as assigned by the 3rd party actually storing the data.
	TpId string `protobuf:"bytes,4,opt,name=tp_id,json=tpId,proto3" json:"tp_id,omitempty"`
}

func (m *AttachmentType) Reset()      { *m = AttachmentType{} }
func (*AttachmentType) ProtoMessage() {}
func (*AttachmentType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b5b8084babe616, []int{0}
}
func (m *AttachmentType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttachmentType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AttachmentType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachmentType.Merge(m, src)
}
func (m *AttachmentType) XXX_Size() int {
	return m.Size()
}
func (m *AttachmentType) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachmentType.DiscardUnknown(m)
}

var xxx_messageInfo_AttachmentType proto.InternalMessageInfo

func (m *AttachmentType) GetAttachment() []byte {
	if m != nil {
		return m.Attachment
	}
	return nil
}

func (m *AttachmentType) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *AttachmentType) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *AttachmentType) GetTpId() string {
	if m != nil {
		return m.TpId
	}
	return ""
}

// Comment
//
// x-displayName: "Comment"
// Comment represents a single comment on an issue. It contains information like name of the person commenting, timestamp and the comment itself.
// Customers usually download all comments on an issue which resembles a conversation on an issue.
type CommentType struct {
	// Author
	//
	// x-displayName: "Author"
	// x-example: "John Smith"
	// Author of the comment (as a name)
	AuthorName string `protobuf:"bytes,1,opt,name=author_name,json=authorName,proto3" json:"author_name,omitempty"`
	// Email
	//
	// x-displayName: "Email"
	// x-example: "john.smith@volterra.io"
	// Email of the author of the comment
	AuthorEmail string `protobuf:"bytes,2,opt,name=author_email,json=authorEmail,proto3" json:"author_email,omitempty"`
	// Creation timestamp
	//
	// x-displayName: "At"
	// x-example: "01-01-1970T00:00:00Z"
	// Comment creation time
	CreatedAt *types.Timestamp `protobuf:"bytes,3,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// Plain text
	//
	// x-displayName: "Comment"
	// x-example: "Looking good"
	// Comment body as plain text
	PlainText string `protobuf:"bytes,4,opt,name=plain_text,json=plainText,proto3" json:"plain_text,omitempty"`
	// HTML text
	//
	// x-displayName: "Comment"
	// x-example: "<p>Looking good</p>"
	// Comment body as HTML
	Html string `protobuf:"bytes,5,opt,name=html,proto3" json:"html,omitempty"`
	// Attachments information
	//
	// x-displayName: "Attachments details"
	// Information about any attachments (such as screenshots, plain text files) the comment can have.
	AttachmentsInfo []*AttachmentType `protobuf:"bytes,8,rep,name=attachments_info,json=attachmentsInfo,proto3" json:"attachments_info,omitempty"`
	// Third party attachment ID
	//
	// x-displayName: "Attachment IDs"
	// x-example: "12345"
	// Third party id of any attachment related to this ticket comment
	AttachmentIds []string `protobuf:"bytes,7,rep,name=attachment_ids,json=attachmentIds,proto3" json:"attachment_ids,omitempty"`
	// Comment ID
	//
	// x-displayName: "Comment ID"
	// x-example: "02s3S000000vvYSQAY"
	// ID assigned to this comment by support provider.
	CommentId string `protobuf:"bytes,9,opt,name=comment_id,json=commentId,proto3" json:"comment_id,omitempty"`
}

func (m *CommentType) Reset()      { *m = CommentType{} }
func (*CommentType) ProtoMessage() {}
func (*CommentType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b5b8084babe616, []int{1}
}
func (m *CommentType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommentType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CommentType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommentType.Merge(m, src)
}
func (m *CommentType) XXX_Size() int {
	return m.Size()
}
func (m *CommentType) XXX_DiscardUnknown() {
	xxx_messageInfo_CommentType.DiscardUnknown(m)
}

var xxx_messageInfo_CommentType proto.InternalMessageInfo

func (m *CommentType) GetAuthorName() string {
	if m != nil {
		return m.AuthorName
	}
	return ""
}

func (m *CommentType) GetAuthorEmail() string {
	if m != nil {
		return m.AuthorEmail
	}
	return ""
}

func (m *CommentType) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *CommentType) GetPlainText() string {
	if m != nil {
		return m.PlainText
	}
	return ""
}

func (m *CommentType) GetHtml() string {
	if m != nil {
		return m.Html
	}
	return ""
}

func (m *CommentType) GetAttachmentsInfo() []*AttachmentType {
	if m != nil {
		return m.AttachmentsInfo
	}
	return nil
}

func (m *CommentType) GetAttachmentIds() []string {
	if m != nil {
		return m.AttachmentIds
	}
	return nil
}

func (m *CommentType) GetCommentId() string {
	if m != nil {
		return m.CommentId
	}
	return ""
}

// Customer support
//
// x-displayName: "Customer Support"
// Represents a single incident created by a customer. Once submitted it is assign to a specialist to resolve.
// Customers can track the progress by list issues or off-the-system (email, instant messaging).
// Customer support is only available to paying customers. Not paying customer our welcome to read the documentation and seek help
// in communal forums.
type GlobalSpecType struct {
	// Type
	//
	// x-displayName: "Type"
	// ticket type is the category of the ticket - technical question, technical
	// issue, billing question for the start.
	Type SupportTicketType `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.customer_support.SupportTicketType" json:"type,omitempty"`
	// Category
	//
	// x-displayName: "Category"
	// x-example: "infrastructure"
	// ticket area further narrows down the ticket - infrastructure, application,
	// dashboards can be examples.
	//
	Category string `protobuf:"bytes,2,opt,name=category,proto3" json:"category,omitempty"`
	// Priority
	//
	// x-displayName: "Priority"
	// priority of the ticket (from low to critical)
	Priority SupportTicketPriority `protobuf:"varint,3,opt,name=priority,proto3,enum=ves.io.schema.customer_support.SupportTicketPriority" json:"priority,omitempty"`
	// Status
	//
	// x-displayName: "Status"
	// ticket status
	Status SupportTicketStatus `protobuf:"varint,4,opt,name=status,proto3,enum=ves.io.schema.customer_support.SupportTicketStatus" json:"status,omitempty"`
	// Description
	//
	// x-displayName: "Description"
	// x-example: "Hello support,  I cannot login to my account. Can you please look into it. Thank you, John"
	// customer's description of the issue (free text)
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	// Subject
	//
	// x-displayName: "Subject"
	// x-example: "Problem logging into account"
	// subject of the ticket
	Subject string `protobuf:"bytes,7,opt,name=subject,proto3" json:"subject,omitempty"`
	// Tags
	//
	// x-displayName: "Tags"
	// x-example: "UAM,UI"
	// tags help to further categorize issues (read-only field)
	Tags []string `protobuf:"bytes,8,rep,name=tags,proto3" json:"tags,omitempty"`
	// Custom fields
	//
	// x-displayName: "Custom Fields"
	// x-example: "custom-field-id:custom-field-value"
	// any custom fields (read only). custom fields have to be defined first before they're used.
	// custom fields have no direct impact on the issue but help to better categorize issues.
	CustomFields []string `protobuf:"bytes,9,rep,name=custom_fields,json=customFields,proto3" json:"custom_fields,omitempty"`
	// Via
	//
	// x-displayName: "Via"
	// x-example: "['channel':'web', 'source': '{}']"
	// via describes the way of a ticket reaching us (read-only)
	Via map[string]string `protobuf:"bytes,10,rep,name=via,proto3" json:"via,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// User
	//
	// x-displayName: "User"
	// x-example: "user@email.com"
	// logged in user (read-only)
	User []*schema.ObjectRefType `protobuf:"bytes,11,rep,name=user,proto3" json:"user,omitempty"`
	// Comments
	//
	// x-displayName: "Comments"
	// x-example: ["I'm looking into it", "Thanks", "Fixed, can you please retry?", "It works!", "Thanks, closing the issue"]
	// Comments are all public comments on an issue. They're usually conversation between the support personnel and the customer.
	Comments []*CommentType `protobuf:"bytes,12,rep,name=comments,proto3" json:"comments,omitempty"`
	// Creation timestamp
	//
	// x-displayName: "Created at"
	// x-example: "01-01-1970T00:00:00Z"
	// Created at timestamp
	CreatedAt *types.Timestamp `protobuf:"bytes,13,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// Updated timestamp
	//
	// x-displayName: "Updated at"
	// x-example: "01-01-1970T00:00:00Z"
	// Date of the last modification
	UpdateAt *types.Timestamp `protobuf:"bytes,14,opt,name=update_at,json=updateAt,proto3" json:"update_at,omitempty"`
	// Third party ID
	//
	// x-displayName: "Third Party ID"
	// x-example: "123"
	// ID assigned to this ticket by our support provider.
	TpId string `protobuf:"bytes,15,opt,name=tp_id,json=tpId,proto3" json:"tp_id,omitempty"`
	// Followup tickets
	//
	// x-displayName: "Followup tickets"
	// Optional reference to followup tickets. It only applies to closed tickets and points to any ticket that is open as a followup to this closed ticket.
	// Used in situations when the original ticket has been closed but the issue occurred again or a new problem occurred in relation to this closed ticket.
	Followups []*schema.ObjectRefType `protobuf:"bytes,16,rep,name=followups,proto3" json:"followups,omitempty"`
	// Relates to ticket
	//
	// x-displayName: "Ticket which this one relates to"
	// Optional reference to any original ticket in case the ticket being created is a followup.
	RelatesTo []*schema.ObjectRefType `protobuf:"bytes,17,rep,name=relates_to,json=relatesTo,proto3" json:"relates_to,omitempty"`
	// Escalated flag
	//
	// x-displayName: "Escalated"
	// Indicates escalated ticket - i.e. a ticket its priority has been increased to PRIORITY_URGENT and L1 support has been notified of it.
	// only existing enterprise customer tickets with priority other then PRIORITY_URGENT can be escalated
	Escalated bool `protobuf:"varint,18,opt,name=escalated,proto3" json:"escalated,omitempty"`
	// Author
	//
	// x-displayName: "Author"
	// x-example: "John Smith"
	// Author of the comment (as a name)
	AuthorName string `protobuf:"bytes,19,opt,name=author_name,json=authorName,proto3" json:"author_name,omitempty"`
	// Private flag
	//
	// x-displayName: "Private"
	// Indicates a private ticket - i.e. a ticket that would be hidden for the user / from the UI
	Private bool `protobuf:"varint,20,opt,name=private,proto3" json:"private,omitempty"`
	// Service
	//
	// x-displayName: "Service"
	// x-example: "ddos"
	// Indicates the support service the ticket is related to (ddos, voltstack, bot)
	Service SupportService `protobuf:"varint,22,opt,name=service,proto3,enum=ves.io.schema.customer_support.SupportService" json:"service,omitempty"`
	// Topic
	//
	// x-displayName: "Topic"
	// Support topic for the ticket. This field supersedes the category field.
	Topic SupportTopic `protobuf:"varint,23,opt,name=topic,proto3,enum=ves.io.schema.customer_support.SupportTopic" json:"topic,omitempty"`
	// Product data
	//
	// x-displayName: "Product Data"
	// x-example: "Happening in the loreimpsum namespace and impacts most of our sites"
	// Product data is a free text field that can be used to describe the issue in more detail.
	ProductData string `protobuf:"bytes,24,opt,name=product_data,json=productData,proto3" json:"product_data,omitempty"`
	// Timeline
	//
	// x-displayName: "Timeline"
	// x-example: "Both LBs have been down since noon on Jan 5, 2022."
	// Timeline is a free text field that can be used to describe the issue in more detail.
	Timeline string `protobuf:"bytes,25,opt,name=timeline,proto3" json:"timeline,omitempty"`
	// Ongoing
	//
	// x-displayName: "Ongoing"
	// Ongoing is a flag that indicates whether the issue is ongoing or not.
	Ongoing bool `protobuf:"varint,26,opt,name=ongoing,proto3" json:"ongoing,omitempty"`
	// Case Id
	//
	// x-displayName: "Case ID"
	// x-example: "500dn000001oj4eAAA"
	// ID assigned to this ticket by our support provider (not customer friendly).
	CaseId string `protobuf:"bytes,27,opt,name=case_id,json=caseId,proto3" json:"case_id,omitempty"`
	// Provider Id
	//
	// x-displayName: "Provider ID"
	// ProviderId represents a unique UID of the external support provider configuration.
	ProviderId string `protobuf:"bytes,28,opt,name=provider_id,json=providerId,proto3" json:"provider_id,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b5b8084babe616, []int{2}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

func (m *GlobalSpecType) GetType() SupportTicketType {
	if m != nil {
		return m.Type
	}
	return TYPE_UNKNOWN
}

func (m *GlobalSpecType) GetCategory() string {
	if m != nil {
		return m.Category
	}
	return ""
}

func (m *GlobalSpecType) GetPriority() SupportTicketPriority {
	if m != nil {
		return m.Priority
	}
	return PRIORITY_UNKNOWN
}

func (m *GlobalSpecType) GetStatus() SupportTicketStatus {
	if m != nil {
		return m.Status
	}
	return STATUS_UNKNOWN
}

func (m *GlobalSpecType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *GlobalSpecType) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *GlobalSpecType) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *GlobalSpecType) GetCustomFields() []string {
	if m != nil {
		return m.CustomFields
	}
	return nil
}

func (m *GlobalSpecType) GetVia() map[string]string {
	if m != nil {
		return m.Via
	}
	return nil
}

func (m *GlobalSpecType) GetUser() []*schema.ObjectRefType {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *GlobalSpecType) GetComments() []*CommentType {
	if m != nil {
		return m.Comments
	}
	return nil
}

func (m *GlobalSpecType) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *GlobalSpecType) GetUpdateAt() *types.Timestamp {
	if m != nil {
		return m.UpdateAt
	}
	return nil
}

func (m *GlobalSpecType) GetTpId() string {
	if m != nil {
		return m.TpId
	}
	return ""
}

func (m *GlobalSpecType) GetFollowups() []*schema.ObjectRefType {
	if m != nil {
		return m.Followups
	}
	return nil
}

func (m *GlobalSpecType) GetRelatesTo() []*schema.ObjectRefType {
	if m != nil {
		return m.RelatesTo
	}
	return nil
}

func (m *GlobalSpecType) GetEscalated() bool {
	if m != nil {
		return m.Escalated
	}
	return false
}

func (m *GlobalSpecType) GetAuthorName() string {
	if m != nil {
		return m.AuthorName
	}
	return ""
}

func (m *GlobalSpecType) GetPrivate() bool {
	if m != nil {
		return m.Private
	}
	return false
}

func (m *GlobalSpecType) GetService() SupportService {
	if m != nil {
		return m.Service
	}
	return SS_UNKNOWN
}

func (m *GlobalSpecType) GetTopic() SupportTopic {
	if m != nil {
		return m.Topic
	}
	return TOPIC_UNKNOWN
}

func (m *GlobalSpecType) GetProductData() string {
	if m != nil {
		return m.ProductData
	}
	return ""
}

func (m *GlobalSpecType) GetTimeline() string {
	if m != nil {
		return m.Timeline
	}
	return ""
}

func (m *GlobalSpecType) GetOngoing() bool {
	if m != nil {
		return m.Ongoing
	}
	return false
}

func (m *GlobalSpecType) GetCaseId() string {
	if m != nil {
		return m.CaseId
	}
	return ""
}

func (m *GlobalSpecType) GetProviderId() string {
	if m != nil {
		return m.ProviderId
	}
	return ""
}

// Create issue specification
//
// x-displayName: "Create Customer Support"
// Creates a new customer support ticket in our customer support provider system.
type CreateSpecType struct {
	Type SupportTicketType `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.customer_support.SupportTicketType" json:"type,omitempty"`
	// Deprecated
	Category    string                  `protobuf:"bytes,2,opt,name=category,proto3" json:"category,omitempty"`
	Priority    SupportTicketPriority   `protobuf:"varint,3,opt,name=priority,proto3,enum=ves.io.schema.customer_support.SupportTicketPriority" json:"priority,omitempty"`
	Status      SupportTicketStatus     `protobuf:"varint,4,opt,name=status,proto3,enum=ves.io.schema.customer_support.SupportTicketStatus" json:"status,omitempty"`
	Description string                  `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	Subject     string                  `protobuf:"bytes,7,opt,name=subject,proto3" json:"subject,omitempty"`
	Comments    []*CommentType          `protobuf:"bytes,12,rep,name=comments,proto3" json:"comments,omitempty"`
	TpId        string                  `protobuf:"bytes,15,opt,name=tp_id,json=tpId,proto3" json:"tp_id,omitempty"`
	RelatesTo   []*schema.ObjectRefType `protobuf:"bytes,17,rep,name=relates_to,json=relatesTo,proto3" json:"relates_to,omitempty"`
	Service     SupportService          `protobuf:"varint,22,opt,name=service,proto3,enum=ves.io.schema.customer_support.SupportService" json:"service,omitempty"`
	// Topic
	//
	// x-displayName: "Topic"
	// support topic for the ticket. This is to be used instead of category field
	Topic       SupportTopic `protobuf:"varint,23,opt,name=topic,proto3,enum=ves.io.schema.customer_support.SupportTopic" json:"topic,omitempty"`
	ProductData string       `protobuf:"bytes,24,opt,name=product_data,json=productData,proto3" json:"product_data,omitempty"`
	Timeline    string       `protobuf:"bytes,25,opt,name=timeline,proto3" json:"timeline,omitempty"`
	Ongoing     bool         `protobuf:"varint,26,opt,name=ongoing,proto3" json:"ongoing,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b5b8084babe616, []int{3}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

func (m *CreateSpecType) GetType() SupportTicketType {
	if m != nil {
		return m.Type
	}
	return TYPE_UNKNOWN
}

func (m *CreateSpecType) GetCategory() string {
	if m != nil {
		return m.Category
	}
	return ""
}

func (m *CreateSpecType) GetPriority() SupportTicketPriority {
	if m != nil {
		return m.Priority
	}
	return PRIORITY_UNKNOWN
}

func (m *CreateSpecType) GetStatus() SupportTicketStatus {
	if m != nil {
		return m.Status
	}
	return STATUS_UNKNOWN
}

func (m *CreateSpecType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CreateSpecType) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *CreateSpecType) GetComments() []*CommentType {
	if m != nil {
		return m.Comments
	}
	return nil
}

func (m *CreateSpecType) GetTpId() string {
	if m != nil {
		return m.TpId
	}
	return ""
}

func (m *CreateSpecType) GetRelatesTo() []*schema.ObjectRefType {
	if m != nil {
		return m.RelatesTo
	}
	return nil
}

func (m *CreateSpecType) GetService() SupportService {
	if m != nil {
		return m.Service
	}
	return SS_UNKNOWN
}

func (m *CreateSpecType) GetTopic() SupportTopic {
	if m != nil {
		return m.Topic
	}
	return TOPIC_UNKNOWN
}

func (m *CreateSpecType) GetProductData() string {
	if m != nil {
		return m.ProductData
	}
	return ""
}

func (m *CreateSpecType) GetTimeline() string {
	if m != nil {
		return m.Timeline
	}
	return ""
}

func (m *CreateSpecType) GetOngoing() bool {
	if m != nil {
		return m.Ongoing
	}
	return false
}

// Get issue specification
//
// x-displayName: "Get Customer Support"
// Support ticket representation we display to customers. There's much more information associated with a ticker but this maybe sensitive/irrelevant.
type GetSpecType struct {
	Type SupportTicketType `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.customer_support.SupportTicketType" json:"type,omitempty"`
	// Deprecated
	Category     string                  `protobuf:"bytes,2,opt,name=category,proto3" json:"category,omitempty"`
	Priority     SupportTicketPriority   `protobuf:"varint,3,opt,name=priority,proto3,enum=ves.io.schema.customer_support.SupportTicketPriority" json:"priority,omitempty"`
	Status       SupportTicketStatus     `protobuf:"varint,4,opt,name=status,proto3,enum=ves.io.schema.customer_support.SupportTicketStatus" json:"status,omitempty"`
	Description  string                  `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	Subject      string                  `protobuf:"bytes,7,opt,name=subject,proto3" json:"subject,omitempty"`
	Tags         []string                `protobuf:"bytes,8,rep,name=tags,proto3" json:"tags,omitempty"`
	CustomFields []string                `protobuf:"bytes,9,rep,name=custom_fields,json=customFields,proto3" json:"custom_fields,omitempty"`
	Via          map[string]string       `protobuf:"bytes,10,rep,name=via,proto3" json:"via,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	User         []*schema.ObjectRefType `protobuf:"bytes,11,rep,name=user,proto3" json:"user,omitempty"`
	Comments     []*CommentType          `protobuf:"bytes,12,rep,name=comments,proto3" json:"comments,omitempty"`
	CreatedAt    *types.Timestamp        `protobuf:"bytes,13,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	UpdateAt     *types.Timestamp        `protobuf:"bytes,14,opt,name=update_at,json=updateAt,proto3" json:"update_at,omitempty"`
	TpId         string                  `protobuf:"bytes,15,opt,name=tp_id,json=tpId,proto3" json:"tp_id,omitempty"`
	Followups    []*schema.ObjectRefType `protobuf:"bytes,16,rep,name=followups,proto3" json:"followups,omitempty"`
	RelatesTo    []*schema.ObjectRefType `protobuf:"bytes,17,rep,name=relates_to,json=relatesTo,proto3" json:"relates_to,omitempty"`
	Escalated    bool                    `protobuf:"varint,18,opt,name=escalated,proto3" json:"escalated,omitempty"`
	AuthorName   string                  `protobuf:"bytes,19,opt,name=author_name,json=authorName,proto3" json:"author_name,omitempty"`
	Service      SupportService          `protobuf:"varint,22,opt,name=service,proto3,enum=ves.io.schema.customer_support.SupportService" json:"service,omitempty"`
	// Topic
	//
	// x-displayName: "Topic"
	// support topic for the ticket. This is to be used instead of category field
	Topic       SupportTopic `protobuf:"varint,23,opt,name=topic,proto3,enum=ves.io.schema.customer_support.SupportTopic" json:"topic,omitempty"`
	ProductData string       `protobuf:"bytes,24,opt,name=product_data,json=productData,proto3" json:"product_data,omitempty"`
	Timeline    string       `protobuf:"bytes,25,opt,name=timeline,proto3" json:"timeline,omitempty"`
	Ongoing     bool         `protobuf:"varint,26,opt,name=ongoing,proto3" json:"ongoing,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b5b8084babe616, []int{4}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

func (m *GetSpecType) GetType() SupportTicketType {
	if m != nil {
		return m.Type
	}
	return TYPE_UNKNOWN
}

func (m *GetSpecType) GetCategory() string {
	if m != nil {
		return m.Category
	}
	return ""
}

func (m *GetSpecType) GetPriority() SupportTicketPriority {
	if m != nil {
		return m.Priority
	}
	return PRIORITY_UNKNOWN
}

func (m *GetSpecType) GetStatus() SupportTicketStatus {
	if m != nil {
		return m.Status
	}
	return STATUS_UNKNOWN
}

func (m *GetSpecType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *GetSpecType) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *GetSpecType) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *GetSpecType) GetCustomFields() []string {
	if m != nil {
		return m.CustomFields
	}
	return nil
}

func (m *GetSpecType) GetVia() map[string]string {
	if m != nil {
		return m.Via
	}
	return nil
}

func (m *GetSpecType) GetUser() []*schema.ObjectRefType {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *GetSpecType) GetComments() []*CommentType {
	if m != nil {
		return m.Comments
	}
	return nil
}

func (m *GetSpecType) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *GetSpecType) GetUpdateAt() *types.Timestamp {
	if m != nil {
		return m.UpdateAt
	}
	return nil
}

func (m *GetSpecType) GetTpId() string {
	if m != nil {
		return m.TpId
	}
	return ""
}

func (m *GetSpecType) GetFollowups() []*schema.ObjectRefType {
	if m != nil {
		return m.Followups
	}
	return nil
}

func (m *GetSpecType) GetRelatesTo() []*schema.ObjectRefType {
	if m != nil {
		return m.RelatesTo
	}
	return nil
}

func (m *GetSpecType) GetEscalated() bool {
	if m != nil {
		return m.Escalated
	}
	return false
}

func (m *GetSpecType) GetAuthorName() string {
	if m != nil {
		return m.AuthorName
	}
	return ""
}

func (m *GetSpecType) GetService() SupportService {
	if m != nil {
		return m.Service
	}
	return SS_UNKNOWN
}

func (m *GetSpecType) GetTopic() SupportTopic {
	if m != nil {
		return m.Topic
	}
	return TOPIC_UNKNOWN
}

func (m *GetSpecType) GetProductData() string {
	if m != nil {
		return m.ProductData
	}
	return ""
}

func (m *GetSpecType) GetTimeline() string {
	if m != nil {
		return m.Timeline
	}
	return ""
}

func (m *GetSpecType) GetOngoing() bool {
	if m != nil {
		return m.Ongoing
	}
	return false
}

func init() {
	proto.RegisterEnum("ves.io.schema.customer_support.SupportService", SupportService_name, SupportService_value)
	golang_proto.RegisterEnum("ves.io.schema.customer_support.SupportService", SupportService_name, SupportService_value)
	proto.RegisterEnum("ves.io.schema.customer_support.SupportTopic", SupportTopic_name, SupportTopic_value)
	golang_proto.RegisterEnum("ves.io.schema.customer_support.SupportTopic", SupportTopic_name, SupportTopic_value)
	proto.RegisterEnum("ves.io.schema.customer_support.SupportTicketPriority", SupportTicketPriority_name, SupportTicketPriority_value)
	golang_proto.RegisterEnum("ves.io.schema.customer_support.SupportTicketPriority", SupportTicketPriority_name, SupportTicketPriority_value)
	proto.RegisterEnum("ves.io.schema.customer_support.SupportTicketType", SupportTicketType_name, SupportTicketType_value)
	golang_proto.RegisterEnum("ves.io.schema.customer_support.SupportTicketType", SupportTicketType_name, SupportTicketType_value)
	proto.RegisterEnum("ves.io.schema.customer_support.SupportTicketStatus", SupportTicketStatus_name, SupportTicketStatus_value)
	golang_proto.RegisterEnum("ves.io.schema.customer_support.SupportTicketStatus", SupportTicketStatus_name, SupportTicketStatus_value)
	proto.RegisterType((*AttachmentType)(nil), "ves.io.schema.customer_support.AttachmentType")
	golang_proto.RegisterType((*AttachmentType)(nil), "ves.io.schema.customer_support.AttachmentType")
	proto.RegisterType((*CommentType)(nil), "ves.io.schema.customer_support.CommentType")
	golang_proto.RegisterType((*CommentType)(nil), "ves.io.schema.customer_support.CommentType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.customer_support.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.customer_support.GlobalSpecType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.customer_support.GlobalSpecType.ViaEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.customer_support.GlobalSpecType.ViaEntry")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.customer_support.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.customer_support.CreateSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.customer_support.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.customer_support.GetSpecType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.customer_support.GetSpecType.ViaEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.customer_support.GetSpecType.ViaEntry")
}

func init() {
	proto.RegisterFile("ves.io/schema/customer_support/types.proto", fileDescriptor_e6b5b8084babe616)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/customer_support/types.proto", fileDescriptor_e6b5b8084babe616)
}

var fileDescriptor_e6b5b8084babe616 = []byte{
	// 2189 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x59, 0x4f, 0x6f, 0x1b, 0xc7,
	0x15, 0xd7, 0x4a, 0x94, 0x48, 0x8e, 0x24, 0x6a, 0x34, 0xfa, 0xb7, 0xa6, 0x65, 0x5a, 0x51, 0x9a,
	0x46, 0x51, 0x22, 0x0a, 0x51, 0xda, 0xa4, 0xc9, 0xa1, 0xc0, 0x72, 0x77, 0x44, 0x6e, 0xbc, 0xdc,
	0x65, 0x66, 0x87, 0x76, 0xdc, 0xcb, 0x60, 0x45, 0xae, 0xe8, 0x8d, 0x29, 0x2e, 0xc1, 0x5d, 0x2a,
	0xd6, 0xc1, 0x40, 0x2f, 0xbd, 0xf5, 0x50, 0xf4, 0x53, 0x14, 0xfe, 0x0a, 0x45, 0x81, 0x1e, 0x8b,
	0x9c, 0x7c, 0x74, 0x6f, 0xb5, 0x7c, 0xe9, 0xa9, 0xcd, 0xb9, 0x40, 0x81, 0x62, 0x66, 0x77, 0xf9,
	0xcf, 0x62, 0x64, 0x07, 0x06, 0x7a, 0x70, 0x2e, 0xf6, 0xce, 0x7b, 0xbf, 0xf7, 0xe6, 0xbd, 0xdf,
	0x9b, 0xf7, 0x66, 0x24, 0x81, 0xfd, 0x73, 0x37, 0x28, 0x7a, 0xfe, 0x61, 0xd0, 0x78, 0xe0, 0x9e,
	0x39, 0x87, 0x8d, 0x7e, 0x10, 0xfa, 0x67, 0x6e, 0x8f, 0x05, 0xfd, 0x6e, 0xd7, 0xef, 0x85, 0x87,
	0xe1, 0x45, 0xd7, 0x0d, 0x8a, 0xdd, 0x9e, 0x1f, 0xfa, 0xa8, 0x10, 0x61, 0x8b, 0x11, 0xb6, 0x38,
	0x89, 0xcd, 0x1f, 0xb4, 0xbc, 0xf0, 0x41, 0xff, 0xa4, 0xd8, 0xf0, 0xcf, 0x0e, 0x5b, 0x7e, 0xcb,
	0x3f, 0x14, 0x66, 0x27, 0xfd, 0x53, 0xb1, 0x12, 0x0b, 0xf1, 0x15, 0xb9, 0xcb, 0xdf, 0x68, 0xf9,
	0x7e, 0xab, 0xed, 0x0e, 0x51, 0x4e, 0xe7, 0x22, 0x56, 0xdd, 0x9e, 0x54, 0x85, 0xde, 0x99, 0x1b,
	0x84, 0xce, 0x59, 0x37, 0x06, 0xdc, 0x1c, 0x0f, 0xdb, 0xef, 0x86, 0x9e, 0xdf, 0x09, 0x12, 0xc7,
	0xe3, 0xca, 0x91, 0x14, 0xf2, 0x3b, 0xe3, 0xaa, 0x73, 0xcf, 0xfd, 0x96, 0x8d, 0x19, 0xef, 0xfe,
	0x5e, 0x02, 0x39, 0x25, 0x0c, 0x9d, 0xc6, 0x83, 0x33, 0xb7, 0x13, 0xd2, 0x8b, 0xae, 0x8b, 0x0a,
	0x00, 0x38, 0x03, 0x89, 0x2c, 0xed, 0x48, 0x7b, 0x4b, 0x64, 0x44, 0x82, 0xf2, 0x20, 0x73, 0xea,
	0xb5, 0xdd, 0x8e, 0x73, 0xe6, 0xca, 0xb3, 0x3b, 0xd2, 0x5e, 0x96, 0x0c, 0xd6, 0xe8, 0x1d, 0xb0,
	0xd4, 0xf0, 0x3b, 0xa1, 0xdb, 0x09, 0x19, 0x8f, 0x43, 0x9e, 0x13, 0xfa, 0xc5, 0x58, 0x26, 0xdc,
	0xaf, 0x81, 0xf9, 0xb0, 0xcb, 0xbc, 0xa6, 0x9c, 0x12, 0xba, 0x54, 0xd8, 0xd5, 0x9b, 0x5f, 0x2c,
	0x7c, 0xf7, 0x67, 0x69, 0x16, 0x4a, 0xbb, 0xff, 0x9a, 0x05, 0x8b, 0xaa, 0x7f, 0x36, 0x88, 0xe5,
	0x36, 0x58, 0x74, 0xfa, 0xe1, 0x03, 0xbf, 0xc7, 0xc4, 0x76, 0x92, 0x30, 0x01, 0x91, 0xc8, 0x8c,
	0x37, 0x8c, 0x01, 0xee, 0x99, 0xe3, 0xb5, 0xe3, 0x80, 0x62, 0x23, 0xcc, 0x45, 0xe8, 0x73, 0x00,
	0x1a, 0x3d, 0xd7, 0x09, 0xdd, 0x26, 0x73, 0x42, 0x11, 0xd1, 0xe2, 0x51, 0xbe, 0x18, 0x51, 0x5e,
	0x4c, 0x28, 0x2f, 0xd2, 0x84, 0x72, 0x92, 0x8d, 0xd1, 0x4a, 0x88, 0x6e, 0x01, 0xd0, 0x6d, 0x3b,
	0x5e, 0x87, 0x85, 0xee, 0xa3, 0x30, 0x0e, 0x38, 0x2b, 0x24, 0xd4, 0x7d, 0x14, 0x22, 0x04, 0x52,
	0x0f, 0xc2, 0xb3, 0xb6, 0x3c, 0x1f, 0x65, 0xc2, 0xbf, 0xd1, 0x7d, 0x00, 0x87, 0x5c, 0x05, 0xcc,
	0xeb, 0x9c, 0xfa, 0x72, 0x66, 0x67, 0x6e, 0x6f, 0xf1, 0xa8, 0x58, 0xfc, 0xe1, 0x03, 0x55, 0x1c,
	0xaf, 0x03, 0x59, 0x19, 0xf1, 0xa3, 0x77, 0x4e, 0x7d, 0xf4, 0x1e, 0xc8, 0x0d, 0x45, 0xcc, 0x6b,
	0x06, 0x72, 0x7a, 0x67, 0x6e, 0x2f, 0x4b, 0x96, 0x87, 0x52, 0xbd, 0x19, 0xf0, 0xa0, 0x1b, 0x11,
	0x85, 0x9c, 0xe5, 0x6c, 0x14, 0x74, 0x2c, 0x19, 0x52, 0xfd, 0x65, 0x2a, 0xb3, 0x00, 0xd3, 0xbb,
	0x7f, 0x07, 0x20, 0x57, 0x6e, 0xfb, 0x27, 0x4e, 0xdb, 0xee, 0xba, 0x0d, 0xc1, 0x39, 0x06, 0x29,
	0x51, 0x3b, 0x4e, 0x76, 0xee, 0xe8, 0xe3, 0xeb, 0xa2, 0xb6, 0xa3, 0xff, 0xa9, 0xd7, 0x78, 0xe8,
	0x46, 0x81, 0x0b, 0x73, 0x74, 0x04, 0x32, 0x0d, 0x27, 0x74, 0x5b, 0x7e, 0xef, 0x22, 0xaa, 0x4a,
	0x69, 0xf3, 0xf2, 0xf1, 0x1a, 0x71, 0xbb, 0x6d, 0xa7, 0xe1, 0x36, 0x77, 0x4e, 0x2e, 0x76, 0xde,
	0x0f, 0xfd, 0xae, 0xd7, 0x78, 0x9f, 0x0c, 0x70, 0xe8, 0x2b, 0x90, 0xe9, 0xf6, 0x3c, 0xbf, 0xe7,
	0x85, 0x17, 0xa2, 0x50, 0xb9, 0xa3, 0x5f, 0xbe, 0xd6, 0xf6, 0xb5, 0xd8, 0x98, 0x0c, 0xdc, 0xa0,
	0x3b, 0x60, 0x21, 0x08, 0x9d, 0xb0, 0x1f, 0x88, 0xf2, 0xe5, 0x8e, 0x3e, 0x79, 0x2d, 0x87, 0xb6,
	0x30, 0x25, 0xb1, 0x0b, 0xb4, 0x03, 0x16, 0x9b, 0x6e, 0xd0, 0xe8, 0x79, 0xa2, 0x87, 0xe2, 0xba,
	0x8f, 0x8a, 0x90, 0x0c, 0xd2, 0x41, 0xff, 0xe4, 0x1b, 0xb7, 0x11, 0xca, 0x69, 0xa1, 0x4d, 0x96,
	0xfc, 0xb0, 0x84, 0x4e, 0x2b, 0x10, 0x87, 0x81, 0x1f, 0x7b, 0xa7, 0x15, 0xa0, 0x77, 0xc1, 0x72,
	0xb4, 0x3f, 0x3b, 0xf5, 0xdc, 0x76, 0x33, 0x90, 0xb3, 0x42, 0xb9, 0x14, 0x09, 0x8f, 0x85, 0x0c,
	0xe9, 0x60, 0xee, 0xdc, 0x73, 0x64, 0x20, 0x0e, 0xd1, 0x67, 0xd7, 0x85, 0x3f, 0x5e, 0xcc, 0xe2,
	0x5d, 0xcf, 0xc1, 0x9d, 0xb0, 0x77, 0x41, 0xb8, 0x0f, 0xf4, 0x39, 0x48, 0xf5, 0x03, 0xb7, 0x27,
	0x2f, 0x0a, 0x5f, 0xdb, 0x13, 0xbe, 0x2c, 0x11, 0x28, 0x71, 0x4f, 0xb9, 0x65, 0x29, 0xfd, 0xe4,
	0xb1, 0x00, 0x13, 0xf1, 0x2f, 0x2a, 0x83, 0x4c, 0x7c, 0x86, 0x02, 0x79, 0x49, 0x98, 0x7f, 0x78,
	0x5d, 0x28, 0x23, 0x8d, 0x4c, 0x06, 0xc6, 0x13, 0xed, 0xb8, 0xfc, 0x3a, 0xed, 0xf8, 0x19, 0xc8,
	0xf6, 0xbb, 0x4d, 0x27, 0x74, 0xb9, 0x65, 0xee, 0x5a, 0xcb, 0x4c, 0x04, 0x56, 0xc2, 0xe1, 0xcc,
	0x59, 0x19, 0xce, 0x1c, 0x64, 0x81, 0xec, 0xa9, 0xdf, 0x6e, 0xfb, 0xdf, 0xf6, 0xbb, 0x81, 0x0c,
	0x5f, 0x81, 0x91, 0xb5, 0x27, 0x8f, 0xe1, 0x64, 0x92, 0x64, 0xe8, 0x03, 0xd5, 0x00, 0xe8, 0xb9,
	0x6d, 0x27, 0x74, 0x03, 0x16, 0xfa, 0xf2, 0xea, 0x8f, 0xf6, 0x18, 0x3b, 0xa1, 0x3e, 0xda, 0x06,
	0x59, 0x37, 0x68, 0x38, 0x7c, 0xd9, 0x94, 0xd1, 0x8e, 0xb4, 0x97, 0x21, 0x43, 0xc1, 0xe4, 0x70,
	0x5c, 0x7b, 0x69, 0x38, 0xca, 0x20, 0xdd, 0xed, 0x79, 0xe7, 0x4e, 0xe8, 0xca, 0xeb, 0xc2, 0x38,
	0x59, 0xa2, 0x0a, 0x48, 0x07, 0x6e, 0xef, 0xdc, 0x6b, 0xb8, 0xf2, 0xa6, 0x68, 0x8b, 0xe2, 0x2b,
	0xb6, 0x85, 0x1d, 0x59, 0x91, 0xc4, 0x1c, 0x95, 0xc0, 0xbc, 0x68, 0x63, 0x79, 0x4b, 0xf8, 0xf9,
	0xe8, 0x55, 0xdb, 0x8b, 0xdb, 0x90, 0xc8, 0x94, 0x0f, 0xf1, 0x6e, 0xcf, 0x6f, 0xf6, 0x1b, 0x21,
	0x6b, 0x3a, 0xa1, 0x23, 0xcb, 0x51, 0x5f, 0xc5, 0x32, 0xcd, 0x09, 0x1d, 0x7e, 0xe9, 0xf0, 0x4b,
	0xb1, 0xed, 0x75, 0x5c, 0xf9, 0x46, 0x74, 0xe9, 0x24, 0x6b, 0x9e, 0xa6, 0xdf, 0x69, 0xf9, 0x5e,
	0xa7, 0x25, 0xe7, 0xa3, 0x34, 0xe3, 0x25, 0xda, 0x02, 0xe9, 0x86, 0x13, 0xb8, 0xbc, 0xf2, 0x37,
	0x85, 0xd1, 0x02, 0x5f, 0xea, 0x82, 0xba, 0x6e, 0xcf, 0x3f, 0xf7, 0x9a, 0x6e, 0x8f, 0x2b, 0xb7,
	0x23, 0xea, 0x12, 0x91, 0xde, 0xcc, 0x7f, 0x0a, 0x32, 0x49, 0xeb, 0x20, 0x08, 0xe6, 0x1e, 0xba,
	0x17, 0xf1, 0xe5, 0xc3, 0x3f, 0xd1, 0x3a, 0x98, 0x3f, 0x77, 0xda, 0xfd, 0xe4, 0xfe, 0x8b, 0x16,
	0x5f, 0xcc, 0xfe, 0x2a, 0x9e, 0xaa, 0x5f, 0xa6, 0x32, 0x1b, 0x70, 0x73, 0xf7, 0x77, 0x0b, 0x20,
	0xa7, 0x8a, 0xc3, 0xfb, 0xa6, 0x67, 0x6b, 0x7e, 0x72, 0xb6, 0xbe, 0x25, 0x33, 0xf4, 0x8d, 0x0d,
	0xa1, 0x2b, 0x07, 0xc2, 0x9b, 0xef, 0xdf, 0xb7, 0xa3, 0xcd, 0xbe, 0x58, 0xfd, 0xee, 0xd7, 0x13,
	0x8f, 0x88, 0xb1, 0x3e, 0xf8, 0x4f, 0x16, 0x2c, 0x96, 0xdd, 0xf0, 0xa7, 0x26, 0xf8, 0x3f, 0x3f,
	0x24, 0x8e, 0x47, 0x1f, 0x12, 0xbf, 0xb8, 0xf6, 0x21, 0x31, 0xac, 0xd8, 0x4f, 0xaf, 0x88, 0xb7,
	0xf9, 0x15, 0xf1, 0x76, 0x0c, 0xb1, 0x1f, 0x7b, 0xe3, 0x5f, 0x33, 0xfc, 0xf6, 0xff, 0x3d, 0x0f,
	0x72, 0xe3, 0x7c, 0xa0, 0x1c, 0x00, 0xb6, 0xcd, 0xea, 0xe6, 0x1d, 0xd3, 0xba, 0x67, 0xc2, 0x19,
	0x74, 0x03, 0x6c, 0xd8, 0x36, 0x53, 0x54, 0xd5, 0xaa, 0x9b, 0x94, 0xd5, 0x88, 0x45, 0xb1, 0x4a,
	0x75, 0xcb, 0x84, 0x12, 0xda, 0x00, 0xab, 0x5c, 0xa5, 0x55, 0x75, 0x53, 0xb7, 0x29, 0x51, 0x84,
	0x78, 0x16, 0xed, 0x82, 0x02, 0x17, 0xd7, 0x6a, 0x86, 0xae, 0x0a, 0x19, 0xa3, 0x44, 0x39, 0x3e,
	0xd6, 0x55, 0xa6, 0x9b, 0xb6, 0x5e, 0xae, 0x50, 0x38, 0x87, 0xb6, 0x81, 0xcc, 0x31, 0x75, 0x4d,
	0xa7, 0xcc, 0xb0, 0xca, 0x36, 0x53, 0x4c, 0x8d, 0x29, 0x06, 0x26, 0xd4, 0x86, 0xa9, 0xc4, 0x43,
	0x9d, 0x56, 0xb0, 0x49, 0x13, 0x27, 0xba, 0x49, 0xb1, 0x61, 0xe8, 0x65, 0x6c, 0xaa, 0x18, 0xce,
	0xc7, 0x71, 0x96, 0x74, 0xc3, 0xd0, 0xcd, 0x32, 0x5c, 0x40, 0x79, 0xb0, 0x69, 0xdb, 0x4c, 0x35,
	0x74, 0x6c, 0x52, 0x66, 0xeb, 0x1a, 0x66, 0x1a, 0x3e, 0xc6, 0xa6, 0x8d, 0x61, 0x1a, 0xdd, 0x04,
	0x5b, 0x42, 0x67, 0xd5, 0x35, 0xb1, 0x11, 0xd6, 0xca, 0x98, 0xd9, 0x3a, 0xc5, 0x36, 0xcc, 0xa0,
	0x1d, 0xb0, 0x6d, 0xdb, 0x4c, 0xd3, 0xac, 0x28, 0x08, 0x4a, 0x14, 0xd3, 0xd6, 0x29, 0xb3, 0x31,
	0xb9, 0xab, 0xab, 0xd8, 0x86, 0x59, 0xb4, 0x05, 0xd6, 0x38, 0x82, 0xe7, 0xa8, 0x97, 0xea, 0x14,
	0x6b, 0x3c, 0x39, 0x1b, 0x82, 0x98, 0x00, 0xcd, 0xb4, 0x59, 0x55, 0x31, 0x95, 0x32, 0xae, 0x62,
	0x93, 0xc2, 0xc5, 0x58, 0x6c, 0x58, 0x8a, 0xc6, 0x4a, 0x8a, 0xa1, 0x98, 0x2a, 0x26, 0x36, 0x5c,
	0x8a, 0xa3, 0xb0, 0x2b, 0x0a, 0xc1, 0x1a, 0x53, 0x2d, 0xf3, 0x58, 0x2f, 0xd7, 0x63, 0xd2, 0x96,
	0xd1, 0x3b, 0xe0, 0x96, 0x6d, 0xb3, 0x7b, 0xb8, 0xc4, 0x7d, 0x47, 0x6c, 0xd4, 0xf4, 0x51, 0xba,
	0x57, 0xd0, 0x12, 0xc8, 0xd8, 0x36, 0xb3, 0x68, 0x05, 0x13, 0x08, 0x11, 0x02, 0x39, 0x9e, 0xbf,
	0x45, 0x07, 0x79, 0xae, 0x22, 0x00, 0x16, 0x78, 0x9e, 0x9a, 0x09, 0x11, 0x5a, 0x07, 0x90, 0xa3,
	0x4b, 0x3c, 0x0f, 0xa5, 0xa4, 0x1b, 0x3a, 0xbd, 0x0f, 0xd7, 0x93, 0x54, 0xb0, 0x81, 0xcb, 0x8a,
	0x48, 0x44, 0x55, 0xb1, 0x6d, 0xc3, 0xcd, 0x98, 0xf2, 0x6a, 0xdd, 0xa0, 0x7a, 0x4c, 0x94, 0x89,
	0xe9, 0x3d, 0x8b, 0xdc, 0xe1, 0x91, 0x9a, 0x58, 0xa5, 0x50, 0x46, 0x05, 0x90, 0x9f, 0xc0, 0xf0,
	0x58, 0x13, 0xfd, 0x0d, 0xb4, 0x0a, 0x96, 0x45, 0x49, 0xca, 0x4c, 0xaf, 0x31, 0xa5, 0x56, 0x85,
	0x37, 0x91, 0x0c, 0xd6, 0xf9, 0x7e, 0x0a, 0x55, 0xc6, 0xeb, 0xb7, 0x8d, 0x20, 0x58, 0xb2, 0x6d,
	0x66, 0x96, 0x75, 0xf3, 0x6b, 0x66, 0x99, 0x18, 0xde, 0x8a, 0x63, 0x4b, 0x28, 0xb0, 0x55, 0xc5,
	0x34, 0x79, 0x69, 0x0b, 0x71, 0xaa, 0xc4, 0x12, 0xd4, 0xf3, 0x42, 0xc1, 0xdb, 0xb1, 0xe3, 0xaa,
	0x55, 0xd2, 0x0d, 0x1c, 0xe1, 0x2b, 0x3a, 0x36, 0x34, 0xb8, 0xb3, 0x9b, 0xca, 0xe4, 0x60, 0x6e,
	0x37, 0x95, 0x59, 0x83, 0x6b, 0xbb, 0xfc, 0x94, 0x6f, 0xec, 0xa6, 0x32, 0x5b, 0x70, 0x6b, 0x37,
	0x95, 0xc9, 0xc3, 0xfc, 0xfe, 0x7f, 0xd3, 0x60, 0x69, 0xb4, 0x73, 0x79, 0xd0, 0xd4, 0xaa, 0xe9,
	0xea, 0xc8, 0x91, 0xdf, 0x03, 0x3f, 0x4b, 0xce, 0xbb, 0x5d, 0xaf, 0xd5, 0x2c, 0x42, 0x59, 0x04,
	0x89, 0xd8, 0x62, 0x04, 0x7f, 0x55, 0xc7, 0x36, 0x85, 0x12, 0xaf, 0xda, 0x54, 0x24, 0x97, 0xc2,
	0xd9, 0xe9, 0x90, 0xe4, 0xe8, 0xce, 0xa1, 0x03, 0xf0, 0xc1, 0x0f, 0x42, 0x58, 0xcd, 0x50, 0x4c,
	0xa6, 0x56, 0x14, 0xb3, 0x8c, 0x61, 0x0a, 0xbd, 0x0b, 0x6e, 0x5f, 0x0d, 0xaf, 0xd5, 0x4b, 0x06,
	0xef, 0xb2, 0x1a, 0x9c, 0x9f, 0x9e, 0xc3, 0x57, 0x75, 0x4b, 0x14, 0x43, 0x25, 0x58, 0xb1, 0x31,
	0x5c, 0x40, 0xb7, 0xc0, 0x8d, 0xab, 0x91, 0xa4, 0xaa, 0xc0, 0x34, 0xfa, 0x18, 0x1c, 0x5c, 0xad,
	0xa6, 0xca, 0xd7, 0x0c, 0x7f, 0x8d, 0xab, 0x35, 0xca, 0xee, 0x62, 0xa2, 0x1f, 0xc7, 0x7d, 0x1a,
	0x75, 0xd4, 0xd5, 0x26, 0xe2, 0xec, 0xf2, 0x8e, 0xfa, 0x18, 0x1c, 0x50, 0xac, 0x56, 0x4c, 0x5d,
	0x55, 0x8c, 0x09, 0xcc, 0x58, 0x63, 0xc4, 0x49, 0xf3, 0x5e, 0xfb, 0x00, 0xbc, 0x37, 0xcd, 0x04,
	0x13, 0x62, 0x11, 0x56, 0xc5, 0xb6, 0xad, 0x94, 0x31, 0x5c, 0xe4, 0x7c, 0x4e, 0x83, 0x9a, 0xf8,
	0xde, 0x44, 0xeb, 0x2d, 0xa1, 0x8f, 0xc0, 0xde, 0x34, 0x78, 0x8d, 0x58, 0x5a, 0x5d, 0xa5, 0x4c,
	0xd4, 0x3b, 0x6a, 0xd4, 0x0f, 0xc1, 0xfb, 0xd3, 0xd0, 0x94, 0x58, 0xf5, 0x92, 0x81, 0xed, 0x8a,
	0x65, 0x51, 0x5e, 0xd9, 0x1c, 0xef, 0xaa, 0x69, 0xe0, 0x98, 0x8b, 0x15, 0x8e, 0xd1, 0x4d, 0x55,
	0xd7, 0xf0, 0x4b, 0x74, 0x19, 0x0a, 0xc5, 0xa6, 0x7a, 0x1f, 0x42, 0x74, 0x04, 0x8a, 0x53, 0x30,
	0x35, 0x4c, 0x8e, 0x2d, 0x52, 0xe5, 0x43, 0x86, 0x69, 0xb8, 0x4c, 0x14, 0x2d, 0x4a, 0x6b, 0x95,
	0x13, 0x36, 0xcd, 0x46, 0x21, 0x54, 0x57, 0x0c, 0x66, 0xd5, 0x29, 0x27, 0x0c, 0xa1, 0x7d, 0xf0,
	0xf3, 0x29, 0x50, 0xd5, 0xaa, 0xd6, 0x0c, 0x4c, 0x71, 0x82, 0x5d, 0xe3, 0xe7, 0x79, 0x0a, 0x36,
	0xce, 0x68, 0x9d, 0xcf, 0x09, 0xaa, 0xd8, 0x77, 0x92, 0xdd, 0xf8, 0xe1, 0x8d, 0xa7, 0x2a, 0x8f,
	0x6c, 0x03, 0xdd, 0x06, 0x37, 0x6b, 0xc4, 0x2a, 0x19, 0xb8, 0x1a, 0x43, 0x12, 0x3f, 0xe2, 0x02,
	0x80, 0x9b, 0x7c, 0x8f, 0x84, 0xf1, 0x18, 0xa1, 0x9b, 0xc7, 0x44, 0xb1, 0x29, 0xa9, 0xab, 0xb4,
	0x4e, 0x30, 0xdc, 0x42, 0x9f, 0x82, 0xa3, 0x69, 0xcc, 0x0e, 0xa7, 0x9b, 0x66, 0x55, 0x15, 0xdd,
	0x64, 0x55, 0xbd, 0x1c, 0x17, 0x5b, 0xde, 0xff, 0x06, 0x6c, 0x5c, 0xf9, 0x96, 0xe6, 0xf3, 0xb2,
	0x46, 0x74, 0x8b, 0xe8, 0xf4, 0xfe, 0xc8, 0x28, 0x58, 0x03, 0x2b, 0x03, 0xa9, 0xc9, 0x79, 0x36,
	0xa0, 0xc4, 0x47, 0xc6, 0x40, 0x58, 0xd1, 0xcb, 0x15, 0x38, 0x3b, 0x86, 0xab, 0x93, 0x32, 0xbf,
	0x07, 0xe6, 0xf6, 0xff, 0x22, 0x81, 0xd5, 0x97, 0x7e, 0x3e, 0xe0, 0x83, 0x8f, 0xde, 0xaf, 0xe1,
	0x91, 0x4d, 0x12, 0x49, 0x4c, 0x0a, 0x94, 0xd0, 0x32, 0xc8, 0x0a, 0x09, 0xa7, 0x11, 0xce, 0x8a,
	0x19, 0xc5, 0x97, 0x83, 0x63, 0x38, 0x37, 0x10, 0x25, 0xb5, 0x80, 0x29, 0x7e, 0x03, 0x46, 0x46,
	0x93, 0xbc, 0xc0, 0x79, 0x3e, 0x2e, 0x85, 0x6e, 0xa2, 0x2f, 0xe1, 0x02, 0xbf, 0xdf, 0xc7, 0x1c,
	0x0d, 0x54, 0xe9, 0xfd, 0x27, 0x12, 0x58, 0xbb, 0xe2, 0xe7, 0x04, 0x31, 0x8f, 0xa9, 0x42, 0xeb,
	0xa3, 0xcf, 0x04, 0x7e, 0x1d, 0x47, 0x32, 0x13, 0xdf, 0x83, 0x12, 0x5a, 0x01, 0x8b, 0xf1, 0xda,
	0xaa, 0x61, 0xfe, 0x2a, 0x18, 0x1a, 0xd5, 0xb0, 0xa9, 0x45, 0x83, 0x8f, 0x5f, 0x18, 0x31, 0xc8,
	0xac, 0x58, 0x86, 0x06, 0x53, 0x23, 0x22, 0xdb, 0x32, 0xee, 0x62, 0x0d, 0xce, 0x8f, 0x88, 0x54,
	0xc3, 0xb2, 0xb1, 0x06, 0x17, 0x46, 0x44, 0xc7, 0x8a, 0x6e, 0x60, 0x0d, 0xa6, 0x4b, 0x7f, 0x94,
	0x9e, 0x3e, 0x2f, 0xcc, 0x3c, 0x7b, 0x5e, 0x98, 0xf9, 0xfe, 0x79, 0x41, 0xfa, 0xed, 0x65, 0x41,
	0xfa, 0xd3, 0x65, 0x41, 0xfa, 0xdb, 0x65, 0x41, 0x7a, 0x7a, 0x59, 0x90, 0x9e, 0x5d, 0x16, 0xa4,
	0x7f, 0x5c, 0x16, 0xa4, 0x7f, 0x5e, 0x16, 0x66, 0xbe, 0xbf, 0x2c, 0x48, 0x7f, 0x78, 0x51, 0x98,
	0xf9, 0xeb, 0x8b, 0x82, 0xf4, 0xf4, 0x45, 0x61, 0xe6, 0xd9, 0x8b, 0xc2, 0xcc, 0x6f, 0x68, 0xcb,
	0xef, 0x3e, 0x6c, 0x15, 0xcf, 0xfd, 0x76, 0xe8, 0xf6, 0x7a, 0x4e, 0xb1, 0x1f, 0x1c, 0x8a, 0x8f,
	0x53, 0xbf, 0x77, 0x76, 0x90, 0xfc, 0xea, 0xe5, 0x20, 0x51, 0x1f, 0x76, 0x4f, 0x5a, 0xfe, 0xa1,
	0xfb, 0x28, 0x8c, 0xff, 0x76, 0x31, 0xe5, 0x2f, 0x36, 0x27, 0x0b, 0xe2, 0xc9, 0xfe, 0xc9, 0xff,
	0x02, 0x00, 0x00, 0xff, 0xff, 0x1c, 0xdb, 0xfa, 0xa5, 0xda, 0x19, 0x00, 0x00,
}

func (x SupportService) String() string {
	s, ok := SupportService_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SupportTopic) String() string {
	s, ok := SupportTopic_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SupportTicketPriority) String() string {
	s, ok := SupportTicketPriority_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SupportTicketType) String() string {
	s, ok := SupportTicketType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SupportTicketStatus) String() string {
	s, ok := SupportTicketStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *AttachmentType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AttachmentType)
	if !ok {
		that2, ok := that.(AttachmentType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Attachment, that1.Attachment) {
		return false
	}
	if this.Filename != that1.Filename {
		return false
	}
	if this.ContentType != that1.ContentType {
		return false
	}
	if this.TpId != that1.TpId {
		return false
	}
	return true
}
func (this *CommentType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CommentType)
	if !ok {
		that2, ok := that.(CommentType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AuthorName != that1.AuthorName {
		return false
	}
	if this.AuthorEmail != that1.AuthorEmail {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if this.PlainText != that1.PlainText {
		return false
	}
	if this.Html != that1.Html {
		return false
	}
	if len(this.AttachmentsInfo) != len(that1.AttachmentsInfo) {
		return false
	}
	for i := range this.AttachmentsInfo {
		if !this.AttachmentsInfo[i].Equal(that1.AttachmentsInfo[i]) {
			return false
		}
	}
	if len(this.AttachmentIds) != len(that1.AttachmentIds) {
		return false
	}
	for i := range this.AttachmentIds {
		if this.AttachmentIds[i] != that1.AttachmentIds[i] {
			return false
		}
	}
	if this.CommentId != that1.CommentId {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Category != that1.Category {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Subject != that1.Subject {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if len(this.CustomFields) != len(that1.CustomFields) {
		return false
	}
	for i := range this.CustomFields {
		if this.CustomFields[i] != that1.CustomFields[i] {
			return false
		}
	}
	if len(this.Via) != len(that1.Via) {
		return false
	}
	for i := range this.Via {
		if this.Via[i] != that1.Via[i] {
			return false
		}
	}
	if len(this.User) != len(that1.User) {
		return false
	}
	for i := range this.User {
		if !this.User[i].Equal(that1.User[i]) {
			return false
		}
	}
	if len(this.Comments) != len(that1.Comments) {
		return false
	}
	for i := range this.Comments {
		if !this.Comments[i].Equal(that1.Comments[i]) {
			return false
		}
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if !this.UpdateAt.Equal(that1.UpdateAt) {
		return false
	}
	if this.TpId != that1.TpId {
		return false
	}
	if len(this.Followups) != len(that1.Followups) {
		return false
	}
	for i := range this.Followups {
		if !this.Followups[i].Equal(that1.Followups[i]) {
			return false
		}
	}
	if len(this.RelatesTo) != len(that1.RelatesTo) {
		return false
	}
	for i := range this.RelatesTo {
		if !this.RelatesTo[i].Equal(that1.RelatesTo[i]) {
			return false
		}
	}
	if this.Escalated != that1.Escalated {
		return false
	}
	if this.AuthorName != that1.AuthorName {
		return false
	}
	if this.Private != that1.Private {
		return false
	}
	if this.Service != that1.Service {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.ProductData != that1.ProductData {
		return false
	}
	if this.Timeline != that1.Timeline {
		return false
	}
	if this.Ongoing != that1.Ongoing {
		return false
	}
	if this.CaseId != that1.CaseId {
		return false
	}
	if this.ProviderId != that1.ProviderId {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Category != that1.Category {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Subject != that1.Subject {
		return false
	}
	if len(this.Comments) != len(that1.Comments) {
		return false
	}
	for i := range this.Comments {
		if !this.Comments[i].Equal(that1.Comments[i]) {
			return false
		}
	}
	if this.TpId != that1.TpId {
		return false
	}
	if len(this.RelatesTo) != len(that1.RelatesTo) {
		return false
	}
	for i := range this.RelatesTo {
		if !this.RelatesTo[i].Equal(that1.RelatesTo[i]) {
			return false
		}
	}
	if this.Service != that1.Service {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.ProductData != that1.ProductData {
		return false
	}
	if this.Timeline != that1.Timeline {
		return false
	}
	if this.Ongoing != that1.Ongoing {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Category != that1.Category {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Subject != that1.Subject {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if len(this.CustomFields) != len(that1.CustomFields) {
		return false
	}
	for i := range this.CustomFields {
		if this.CustomFields[i] != that1.CustomFields[i] {
			return false
		}
	}
	if len(this.Via) != len(that1.Via) {
		return false
	}
	for i := range this.Via {
		if this.Via[i] != that1.Via[i] {
			return false
		}
	}
	if len(this.User) != len(that1.User) {
		return false
	}
	for i := range this.User {
		if !this.User[i].Equal(that1.User[i]) {
			return false
		}
	}
	if len(this.Comments) != len(that1.Comments) {
		return false
	}
	for i := range this.Comments {
		if !this.Comments[i].Equal(that1.Comments[i]) {
			return false
		}
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if !this.UpdateAt.Equal(that1.UpdateAt) {
		return false
	}
	if this.TpId != that1.TpId {
		return false
	}
	if len(this.Followups) != len(that1.Followups) {
		return false
	}
	for i := range this.Followups {
		if !this.Followups[i].Equal(that1.Followups[i]) {
			return false
		}
	}
	if len(this.RelatesTo) != len(that1.RelatesTo) {
		return false
	}
	for i := range this.RelatesTo {
		if !this.RelatesTo[i].Equal(that1.RelatesTo[i]) {
			return false
		}
	}
	if this.Escalated != that1.Escalated {
		return false
	}
	if this.AuthorName != that1.AuthorName {
		return false
	}
	if this.Service != that1.Service {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.ProductData != that1.ProductData {
		return false
	}
	if this.Timeline != that1.Timeline {
		return false
	}
	if this.Ongoing != that1.Ongoing {
		return false
	}
	return true
}
func (this *AttachmentType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&customer_support.AttachmentType{")
	s = append(s, "Attachment: "+fmt.Sprintf("%#v", this.Attachment)+",\n")
	s = append(s, "Filename: "+fmt.Sprintf("%#v", this.Filename)+",\n")
	s = append(s, "ContentType: "+fmt.Sprintf("%#v", this.ContentType)+",\n")
	s = append(s, "TpId: "+fmt.Sprintf("%#v", this.TpId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CommentType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&customer_support.CommentType{")
	s = append(s, "AuthorName: "+fmt.Sprintf("%#v", this.AuthorName)+",\n")
	s = append(s, "AuthorEmail: "+fmt.Sprintf("%#v", this.AuthorEmail)+",\n")
	if this.CreatedAt != nil {
		s = append(s, "CreatedAt: "+fmt.Sprintf("%#v", this.CreatedAt)+",\n")
	}
	s = append(s, "PlainText: "+fmt.Sprintf("%#v", this.PlainText)+",\n")
	s = append(s, "Html: "+fmt.Sprintf("%#v", this.Html)+",\n")
	if this.AttachmentsInfo != nil {
		s = append(s, "AttachmentsInfo: "+fmt.Sprintf("%#v", this.AttachmentsInfo)+",\n")
	}
	s = append(s, "AttachmentIds: "+fmt.Sprintf("%#v", this.AttachmentIds)+",\n")
	s = append(s, "CommentId: "+fmt.Sprintf("%#v", this.CommentId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 30)
	s = append(s, "&customer_support.GlobalSpecType{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Category: "+fmt.Sprintf("%#v", this.Category)+",\n")
	s = append(s, "Priority: "+fmt.Sprintf("%#v", this.Priority)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Subject: "+fmt.Sprintf("%#v", this.Subject)+",\n")
	s = append(s, "Tags: "+fmt.Sprintf("%#v", this.Tags)+",\n")
	s = append(s, "CustomFields: "+fmt.Sprintf("%#v", this.CustomFields)+",\n")
	keysForVia := make([]string, 0, len(this.Via))
	for k, _ := range this.Via {
		keysForVia = append(keysForVia, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForVia)
	mapStringForVia := "map[string]string{"
	for _, k := range keysForVia {
		mapStringForVia += fmt.Sprintf("%#v: %#v,", k, this.Via[k])
	}
	mapStringForVia += "}"
	if this.Via != nil {
		s = append(s, "Via: "+mapStringForVia+",\n")
	}
	if this.User != nil {
		s = append(s, "User: "+fmt.Sprintf("%#v", this.User)+",\n")
	}
	if this.Comments != nil {
		s = append(s, "Comments: "+fmt.Sprintf("%#v", this.Comments)+",\n")
	}
	if this.CreatedAt != nil {
		s = append(s, "CreatedAt: "+fmt.Sprintf("%#v", this.CreatedAt)+",\n")
	}
	if this.UpdateAt != nil {
		s = append(s, "UpdateAt: "+fmt.Sprintf("%#v", this.UpdateAt)+",\n")
	}
	s = append(s, "TpId: "+fmt.Sprintf("%#v", this.TpId)+",\n")
	if this.Followups != nil {
		s = append(s, "Followups: "+fmt.Sprintf("%#v", this.Followups)+",\n")
	}
	if this.RelatesTo != nil {
		s = append(s, "RelatesTo: "+fmt.Sprintf("%#v", this.RelatesTo)+",\n")
	}
	s = append(s, "Escalated: "+fmt.Sprintf("%#v", this.Escalated)+",\n")
	s = append(s, "AuthorName: "+fmt.Sprintf("%#v", this.AuthorName)+",\n")
	s = append(s, "Private: "+fmt.Sprintf("%#v", this.Private)+",\n")
	s = append(s, "Service: "+fmt.Sprintf("%#v", this.Service)+",\n")
	s = append(s, "Topic: "+fmt.Sprintf("%#v", this.Topic)+",\n")
	s = append(s, "ProductData: "+fmt.Sprintf("%#v", this.ProductData)+",\n")
	s = append(s, "Timeline: "+fmt.Sprintf("%#v", this.Timeline)+",\n")
	s = append(s, "Ongoing: "+fmt.Sprintf("%#v", this.Ongoing)+",\n")
	s = append(s, "CaseId: "+fmt.Sprintf("%#v", this.CaseId)+",\n")
	s = append(s, "ProviderId: "+fmt.Sprintf("%#v", this.ProviderId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&customer_support.CreateSpecType{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Category: "+fmt.Sprintf("%#v", this.Category)+",\n")
	s = append(s, "Priority: "+fmt.Sprintf("%#v", this.Priority)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Subject: "+fmt.Sprintf("%#v", this.Subject)+",\n")
	if this.Comments != nil {
		s = append(s, "Comments: "+fmt.Sprintf("%#v", this.Comments)+",\n")
	}
	s = append(s, "TpId: "+fmt.Sprintf("%#v", this.TpId)+",\n")
	if this.RelatesTo != nil {
		s = append(s, "RelatesTo: "+fmt.Sprintf("%#v", this.RelatesTo)+",\n")
	}
	s = append(s, "Service: "+fmt.Sprintf("%#v", this.Service)+",\n")
	s = append(s, "Topic: "+fmt.Sprintf("%#v", this.Topic)+",\n")
	s = append(s, "ProductData: "+fmt.Sprintf("%#v", this.ProductData)+",\n")
	s = append(s, "Timeline: "+fmt.Sprintf("%#v", this.Timeline)+",\n")
	s = append(s, "Ongoing: "+fmt.Sprintf("%#v", this.Ongoing)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 27)
	s = append(s, "&customer_support.GetSpecType{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Category: "+fmt.Sprintf("%#v", this.Category)+",\n")
	s = append(s, "Priority: "+fmt.Sprintf("%#v", this.Priority)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Subject: "+fmt.Sprintf("%#v", this.Subject)+",\n")
	s = append(s, "Tags: "+fmt.Sprintf("%#v", this.Tags)+",\n")
	s = append(s, "CustomFields: "+fmt.Sprintf("%#v", this.CustomFields)+",\n")
	keysForVia := make([]string, 0, len(this.Via))
	for k, _ := range this.Via {
		keysForVia = append(keysForVia, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForVia)
	mapStringForVia := "map[string]string{"
	for _, k := range keysForVia {
		mapStringForVia += fmt.Sprintf("%#v: %#v,", k, this.Via[k])
	}
	mapStringForVia += "}"
	if this.Via != nil {
		s = append(s, "Via: "+mapStringForVia+",\n")
	}
	if this.User != nil {
		s = append(s, "User: "+fmt.Sprintf("%#v", this.User)+",\n")
	}
	if this.Comments != nil {
		s = append(s, "Comments: "+fmt.Sprintf("%#v", this.Comments)+",\n")
	}
	if this.CreatedAt != nil {
		s = append(s, "CreatedAt: "+fmt.Sprintf("%#v", this.CreatedAt)+",\n")
	}
	if this.UpdateAt != nil {
		s = append(s, "UpdateAt: "+fmt.Sprintf("%#v", this.UpdateAt)+",\n")
	}
	s = append(s, "TpId: "+fmt.Sprintf("%#v", this.TpId)+",\n")
	if this.Followups != nil {
		s = append(s, "Followups: "+fmt.Sprintf("%#v", this.Followups)+",\n")
	}
	if this.RelatesTo != nil {
		s = append(s, "RelatesTo: "+fmt.Sprintf("%#v", this.RelatesTo)+",\n")
	}
	s = append(s, "Escalated: "+fmt.Sprintf("%#v", this.Escalated)+",\n")
	s = append(s, "AuthorName: "+fmt.Sprintf("%#v", this.AuthorName)+",\n")
	s = append(s, "Service: "+fmt.Sprintf("%#v", this.Service)+",\n")
	s = append(s, "Topic: "+fmt.Sprintf("%#v", this.Topic)+",\n")
	s = append(s, "ProductData: "+fmt.Sprintf("%#v", this.ProductData)+",\n")
	s = append(s, "Timeline: "+fmt.Sprintf("%#v", this.Timeline)+",\n")
	s = append(s, "Ongoing: "+fmt.Sprintf("%#v", this.Ongoing)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *AttachmentType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttachmentType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttachmentType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TpId) > 0 {
		i -= len(m.TpId)
		copy(dAtA[i:], m.TpId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TpId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ContentType) > 0 {
		i -= len(m.ContentType)
		copy(dAtA[i:], m.ContentType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ContentType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Filename) > 0 {
		i -= len(m.Filename)
		copy(dAtA[i:], m.Filename)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Filename)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Attachment) > 0 {
		i -= len(m.Attachment)
		copy(dAtA[i:], m.Attachment)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Attachment)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommentType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommentType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommentType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CommentId) > 0 {
		i -= len(m.CommentId)
		copy(dAtA[i:], m.CommentId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CommentId)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.AttachmentsInfo) > 0 {
		for iNdEx := len(m.AttachmentsInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AttachmentsInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.AttachmentIds) > 0 {
		for iNdEx := len(m.AttachmentIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AttachmentIds[iNdEx])
			copy(dAtA[i:], m.AttachmentIds[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AttachmentIds[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Html) > 0 {
		i -= len(m.Html)
		copy(dAtA[i:], m.Html)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Html)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PlainText) > 0 {
		i -= len(m.PlainText)
		copy(dAtA[i:], m.PlainText)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PlainText)))
		i--
		dAtA[i] = 0x22
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AuthorEmail) > 0 {
		i -= len(m.AuthorEmail)
		copy(dAtA[i:], m.AuthorEmail)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AuthorEmail)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AuthorName) > 0 {
		i -= len(m.AuthorName)
		copy(dAtA[i:], m.AuthorName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AuthorName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProviderId) > 0 {
		i -= len(m.ProviderId)
		copy(dAtA[i:], m.ProviderId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProviderId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.CaseId) > 0 {
		i -= len(m.CaseId)
		copy(dAtA[i:], m.CaseId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CaseId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.Ongoing {
		i--
		if m.Ongoing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if len(m.Timeline) > 0 {
		i -= len(m.Timeline)
		copy(dAtA[i:], m.Timeline)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Timeline)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.ProductData) > 0 {
		i -= len(m.ProductData)
		copy(dAtA[i:], m.ProductData)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProductData)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.Topic != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Topic))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.Service != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Service))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.Private {
		i--
		if m.Private {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.AuthorName) > 0 {
		i -= len(m.AuthorName)
		copy(dAtA[i:], m.AuthorName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AuthorName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.Escalated {
		i--
		if m.Escalated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.RelatesTo) > 0 {
		for iNdEx := len(m.RelatesTo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RelatesTo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.Followups) > 0 {
		for iNdEx := len(m.Followups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Followups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.TpId) > 0 {
		i -= len(m.TpId)
		copy(dAtA[i:], m.TpId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TpId)))
		i--
		dAtA[i] = 0x7a
	}
	if m.UpdateAt != nil {
		{
			size, err := m.UpdateAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Comments) > 0 {
		for iNdEx := len(m.Comments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Comments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.User) > 0 {
		for iNdEx := len(m.User) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.User[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.Via) > 0 {
		keysForVia := make([]string, 0, len(m.Via))
		for k := range m.Via {
			keysForVia = append(keysForVia, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForVia)
		for iNdEx := len(keysForVia) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Via[string(keysForVia[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForVia[iNdEx])
			copy(dAtA[i:], keysForVia[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForVia[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.CustomFields) > 0 {
		for iNdEx := len(m.CustomFields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CustomFields[iNdEx])
			copy(dAtA[i:], m.CustomFields[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.CustomFields[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Subject) > 0 {
		i -= len(m.Subject)
		copy(dAtA[i:], m.Subject)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Subject)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if m.Priority != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Category) > 0 {
		i -= len(m.Category)
		copy(dAtA[i:], m.Category)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Category)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ongoing {
		i--
		if m.Ongoing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if len(m.Timeline) > 0 {
		i -= len(m.Timeline)
		copy(dAtA[i:], m.Timeline)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Timeline)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.ProductData) > 0 {
		i -= len(m.ProductData)
		copy(dAtA[i:], m.ProductData)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProductData)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.Topic != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Topic))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.Service != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Service))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if len(m.RelatesTo) > 0 {
		for iNdEx := len(m.RelatesTo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RelatesTo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.TpId) > 0 {
		i -= len(m.TpId)
		copy(dAtA[i:], m.TpId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TpId)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.Comments) > 0 {
		for iNdEx := len(m.Comments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Comments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.Subject) > 0 {
		i -= len(m.Subject)
		copy(dAtA[i:], m.Subject)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Subject)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if m.Priority != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Category) > 0 {
		i -= len(m.Category)
		copy(dAtA[i:], m.Category)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Category)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ongoing {
		i--
		if m.Ongoing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if len(m.Timeline) > 0 {
		i -= len(m.Timeline)
		copy(dAtA[i:], m.Timeline)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Timeline)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.ProductData) > 0 {
		i -= len(m.ProductData)
		copy(dAtA[i:], m.ProductData)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProductData)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.Topic != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Topic))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.Service != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Service))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if len(m.AuthorName) > 0 {
		i -= len(m.AuthorName)
		copy(dAtA[i:], m.AuthorName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AuthorName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.Escalated {
		i--
		if m.Escalated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.RelatesTo) > 0 {
		for iNdEx := len(m.RelatesTo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RelatesTo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.Followups) > 0 {
		for iNdEx := len(m.Followups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Followups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.TpId) > 0 {
		i -= len(m.TpId)
		copy(dAtA[i:], m.TpId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TpId)))
		i--
		dAtA[i] = 0x7a
	}
	if m.UpdateAt != nil {
		{
			size, err := m.UpdateAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Comments) > 0 {
		for iNdEx := len(m.Comments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Comments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.User) > 0 {
		for iNdEx := len(m.User) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.User[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.Via) > 0 {
		keysForVia := make([]string, 0, len(m.Via))
		for k := range m.Via {
			keysForVia = append(keysForVia, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForVia)
		for iNdEx := len(keysForVia) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Via[string(keysForVia[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForVia[iNdEx])
			copy(dAtA[i:], keysForVia[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForVia[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.CustomFields) > 0 {
		for iNdEx := len(m.CustomFields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CustomFields[iNdEx])
			copy(dAtA[i:], m.CustomFields[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.CustomFields[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Subject) > 0 {
		i -= len(m.Subject)
		copy(dAtA[i:], m.Subject)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Subject)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if m.Priority != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Category) > 0 {
		i -= len(m.Category)
		copy(dAtA[i:], m.Category)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Category)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AttachmentType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Attachment)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TpId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CommentType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AuthorName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AuthorEmail)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PlainText)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Html)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AttachmentIds) > 0 {
		for _, s := range m.AttachmentIds {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.AttachmentsInfo) > 0 {
		for _, e := range m.AttachmentsInfo {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.CommentId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	l = len(m.Category)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovTypes(uint64(m.Priority))
	}
	if m.Status != 0 {
		n += 1 + sovTypes(uint64(m.Status))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.CustomFields) > 0 {
		for _, s := range m.CustomFields {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Via) > 0 {
		for k, v := range m.Via {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.User) > 0 {
		for _, e := range m.User {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Comments) > 0 {
		for _, e := range m.Comments {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.UpdateAt != nil {
		l = m.UpdateAt.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TpId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Followups) > 0 {
		for _, e := range m.Followups {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RelatesTo) > 0 {
		for _, e := range m.RelatesTo {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.Escalated {
		n += 3
	}
	l = len(m.AuthorName)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.Private {
		n += 3
	}
	if m.Service != 0 {
		n += 2 + sovTypes(uint64(m.Service))
	}
	if m.Topic != 0 {
		n += 2 + sovTypes(uint64(m.Topic))
	}
	l = len(m.ProductData)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.Timeline)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.Ongoing {
		n += 3
	}
	l = len(m.CaseId)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.ProviderId)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	l = len(m.Category)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovTypes(uint64(m.Priority))
	}
	if m.Status != 0 {
		n += 1 + sovTypes(uint64(m.Status))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Comments) > 0 {
		for _, e := range m.Comments {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.TpId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.RelatesTo) > 0 {
		for _, e := range m.RelatesTo {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.Service != 0 {
		n += 2 + sovTypes(uint64(m.Service))
	}
	if m.Topic != 0 {
		n += 2 + sovTypes(uint64(m.Topic))
	}
	l = len(m.ProductData)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.Timeline)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.Ongoing {
		n += 3
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	l = len(m.Category)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovTypes(uint64(m.Priority))
	}
	if m.Status != 0 {
		n += 1 + sovTypes(uint64(m.Status))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.CustomFields) > 0 {
		for _, s := range m.CustomFields {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Via) > 0 {
		for k, v := range m.Via {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.User) > 0 {
		for _, e := range m.User {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Comments) > 0 {
		for _, e := range m.Comments {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.UpdateAt != nil {
		l = m.UpdateAt.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TpId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Followups) > 0 {
		for _, e := range m.Followups {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RelatesTo) > 0 {
		for _, e := range m.RelatesTo {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.Escalated {
		n += 3
	}
	l = len(m.AuthorName)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.Service != 0 {
		n += 2 + sovTypes(uint64(m.Service))
	}
	if m.Topic != 0 {
		n += 2 + sovTypes(uint64(m.Topic))
	}
	l = len(m.ProductData)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.Timeline)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.Ongoing {
		n += 3
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AttachmentType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AttachmentType{`,
		`Attachment:` + fmt.Sprintf("%v", this.Attachment) + `,`,
		`Filename:` + fmt.Sprintf("%v", this.Filename) + `,`,
		`ContentType:` + fmt.Sprintf("%v", this.ContentType) + `,`,
		`TpId:` + fmt.Sprintf("%v", this.TpId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CommentType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAttachmentsInfo := "[]*AttachmentType{"
	for _, f := range this.AttachmentsInfo {
		repeatedStringForAttachmentsInfo += strings.Replace(f.String(), "AttachmentType", "AttachmentType", 1) + ","
	}
	repeatedStringForAttachmentsInfo += "}"
	s := strings.Join([]string{`&CommentType{`,
		`AuthorName:` + fmt.Sprintf("%v", this.AuthorName) + `,`,
		`AuthorEmail:` + fmt.Sprintf("%v", this.AuthorEmail) + `,`,
		`CreatedAt:` + strings.Replace(fmt.Sprintf("%v", this.CreatedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`PlainText:` + fmt.Sprintf("%v", this.PlainText) + `,`,
		`Html:` + fmt.Sprintf("%v", this.Html) + `,`,
		`AttachmentIds:` + fmt.Sprintf("%v", this.AttachmentIds) + `,`,
		`AttachmentsInfo:` + repeatedStringForAttachmentsInfo + `,`,
		`CommentId:` + fmt.Sprintf("%v", this.CommentId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForUser := "[]*ObjectRefType{"
	for _, f := range this.User {
		repeatedStringForUser += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForUser += "}"
	repeatedStringForComments := "[]*CommentType{"
	for _, f := range this.Comments {
		repeatedStringForComments += strings.Replace(f.String(), "CommentType", "CommentType", 1) + ","
	}
	repeatedStringForComments += "}"
	repeatedStringForFollowups := "[]*ObjectRefType{"
	for _, f := range this.Followups {
		repeatedStringForFollowups += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForFollowups += "}"
	repeatedStringForRelatesTo := "[]*ObjectRefType{"
	for _, f := range this.RelatesTo {
		repeatedStringForRelatesTo += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRelatesTo += "}"
	keysForVia := make([]string, 0, len(this.Via))
	for k, _ := range this.Via {
		keysForVia = append(keysForVia, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForVia)
	mapStringForVia := "map[string]string{"
	for _, k := range keysForVia {
		mapStringForVia += fmt.Sprintf("%v: %v,", k, this.Via[k])
	}
	mapStringForVia += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Category:` + fmt.Sprintf("%v", this.Category) + `,`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Subject:` + fmt.Sprintf("%v", this.Subject) + `,`,
		`Tags:` + fmt.Sprintf("%v", this.Tags) + `,`,
		`CustomFields:` + fmt.Sprintf("%v", this.CustomFields) + `,`,
		`Via:` + mapStringForVia + `,`,
		`User:` + repeatedStringForUser + `,`,
		`Comments:` + repeatedStringForComments + `,`,
		`CreatedAt:` + strings.Replace(fmt.Sprintf("%v", this.CreatedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`UpdateAt:` + strings.Replace(fmt.Sprintf("%v", this.UpdateAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`TpId:` + fmt.Sprintf("%v", this.TpId) + `,`,
		`Followups:` + repeatedStringForFollowups + `,`,
		`RelatesTo:` + repeatedStringForRelatesTo + `,`,
		`Escalated:` + fmt.Sprintf("%v", this.Escalated) + `,`,
		`AuthorName:` + fmt.Sprintf("%v", this.AuthorName) + `,`,
		`Private:` + fmt.Sprintf("%v", this.Private) + `,`,
		`Service:` + fmt.Sprintf("%v", this.Service) + `,`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`ProductData:` + fmt.Sprintf("%v", this.ProductData) + `,`,
		`Timeline:` + fmt.Sprintf("%v", this.Timeline) + `,`,
		`Ongoing:` + fmt.Sprintf("%v", this.Ongoing) + `,`,
		`CaseId:` + fmt.Sprintf("%v", this.CaseId) + `,`,
		`ProviderId:` + fmt.Sprintf("%v", this.ProviderId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForComments := "[]*CommentType{"
	for _, f := range this.Comments {
		repeatedStringForComments += strings.Replace(f.String(), "CommentType", "CommentType", 1) + ","
	}
	repeatedStringForComments += "}"
	repeatedStringForRelatesTo := "[]*ObjectRefType{"
	for _, f := range this.RelatesTo {
		repeatedStringForRelatesTo += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRelatesTo += "}"
	s := strings.Join([]string{`&CreateSpecType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Category:` + fmt.Sprintf("%v", this.Category) + `,`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Subject:` + fmt.Sprintf("%v", this.Subject) + `,`,
		`Comments:` + repeatedStringForComments + `,`,
		`TpId:` + fmt.Sprintf("%v", this.TpId) + `,`,
		`RelatesTo:` + repeatedStringForRelatesTo + `,`,
		`Service:` + fmt.Sprintf("%v", this.Service) + `,`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`ProductData:` + fmt.Sprintf("%v", this.ProductData) + `,`,
		`Timeline:` + fmt.Sprintf("%v", this.Timeline) + `,`,
		`Ongoing:` + fmt.Sprintf("%v", this.Ongoing) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForUser := "[]*ObjectRefType{"
	for _, f := range this.User {
		repeatedStringForUser += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForUser += "}"
	repeatedStringForComments := "[]*CommentType{"
	for _, f := range this.Comments {
		repeatedStringForComments += strings.Replace(f.String(), "CommentType", "CommentType", 1) + ","
	}
	repeatedStringForComments += "}"
	repeatedStringForFollowups := "[]*ObjectRefType{"
	for _, f := range this.Followups {
		repeatedStringForFollowups += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForFollowups += "}"
	repeatedStringForRelatesTo := "[]*ObjectRefType{"
	for _, f := range this.RelatesTo {
		repeatedStringForRelatesTo += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRelatesTo += "}"
	keysForVia := make([]string, 0, len(this.Via))
	for k, _ := range this.Via {
		keysForVia = append(keysForVia, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForVia)
	mapStringForVia := "map[string]string{"
	for _, k := range keysForVia {
		mapStringForVia += fmt.Sprintf("%v: %v,", k, this.Via[k])
	}
	mapStringForVia += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Category:` + fmt.Sprintf("%v", this.Category) + `,`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Subject:` + fmt.Sprintf("%v", this.Subject) + `,`,
		`Tags:` + fmt.Sprintf("%v", this.Tags) + `,`,
		`CustomFields:` + fmt.Sprintf("%v", this.CustomFields) + `,`,
		`Via:` + mapStringForVia + `,`,
		`User:` + repeatedStringForUser + `,`,
		`Comments:` + repeatedStringForComments + `,`,
		`CreatedAt:` + strings.Replace(fmt.Sprintf("%v", this.CreatedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`UpdateAt:` + strings.Replace(fmt.Sprintf("%v", this.UpdateAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`TpId:` + fmt.Sprintf("%v", this.TpId) + `,`,
		`Followups:` + repeatedStringForFollowups + `,`,
		`RelatesTo:` + repeatedStringForRelatesTo + `,`,
		`Escalated:` + fmt.Sprintf("%v", this.Escalated) + `,`,
		`AuthorName:` + fmt.Sprintf("%v", this.AuthorName) + `,`,
		`Service:` + fmt.Sprintf("%v", this.Service) + `,`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`ProductData:` + fmt.Sprintf("%v", this.ProductData) + `,`,
		`Timeline:` + fmt.Sprintf("%v", this.Timeline) + `,`,
		`Ongoing:` + fmt.Sprintf("%v", this.Ongoing) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AttachmentType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttachmentType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttachmentType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attachment", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attachment = append(m.Attachment[:0], dAtA[iNdEx:postIndex]...)
			if m.Attachment == nil {
				m.Attachment = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TpId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TpId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommentType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommentType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommentType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorEmail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorEmail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlainText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlainText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Html", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Html = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachmentIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttachmentIds = append(m.AttachmentIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachmentsInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttachmentsInfo = append(m.AttachmentsInfo, &AttachmentType{})
			if err := m.AttachmentsInfo[len(m.AttachmentsInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= SupportTicketType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Category = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= SupportTicketPriority(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= SupportTicketStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomFields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomFields = append(m.CustomFields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Via", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Via == nil {
				m.Via = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Via[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = append(m.User, &schema.ObjectRefType{})
			if err := m.User[len(m.User)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comments = append(m.Comments, &CommentType{})
			if err := m.Comments[len(m.Comments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateAt == nil {
				m.UpdateAt = &types.Timestamp{}
			}
			if err := m.UpdateAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TpId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TpId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Followups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Followups = append(m.Followups, &schema.ObjectRefType{})
			if err := m.Followups[len(m.Followups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelatesTo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelatesTo = append(m.RelatesTo, &schema.ObjectRefType{})
			if err := m.RelatesTo[len(m.RelatesTo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Escalated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Escalated = bool(v != 0)
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Private", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Private = bool(v != 0)
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			m.Service = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Service |= SupportService(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			m.Topic = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Topic |= SupportTopic(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeline", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timeline = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ongoing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ongoing = bool(v != 0)
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= SupportTicketType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Category = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= SupportTicketPriority(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= SupportTicketStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comments = append(m.Comments, &CommentType{})
			if err := m.Comments[len(m.Comments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TpId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TpId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelatesTo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelatesTo = append(m.RelatesTo, &schema.ObjectRefType{})
			if err := m.RelatesTo[len(m.RelatesTo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			m.Service = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Service |= SupportService(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			m.Topic = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Topic |= SupportTopic(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeline", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timeline = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ongoing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ongoing = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= SupportTicketType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Category = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= SupportTicketPriority(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= SupportTicketStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomFields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomFields = append(m.CustomFields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Via", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Via == nil {
				m.Via = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Via[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = append(m.User, &schema.ObjectRefType{})
			if err := m.User[len(m.User)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comments = append(m.Comments, &CommentType{})
			if err := m.Comments[len(m.Comments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateAt == nil {
				m.UpdateAt = &types.Timestamp{}
			}
			if err := m.UpdateAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TpId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TpId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Followups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Followups = append(m.Followups, &schema.ObjectRefType{})
			if err := m.Followups[len(m.Followups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelatesTo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelatesTo = append(m.RelatesTo, &schema.ObjectRefType{})
			if err := m.RelatesTo[len(m.RelatesTo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Escalated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Escalated = bool(v != 0)
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			m.Service = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Service |= SupportService(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			m.Topic = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Topic |= SupportTopic(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeline", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timeline = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ongoing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ongoing = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
