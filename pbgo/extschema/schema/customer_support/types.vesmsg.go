// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package customer_support

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AttachmentType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AttachmentType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AttachmentType) DeepCopy() *AttachmentType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AttachmentType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AttachmentType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AttachmentType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AttachmentTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAttachmentType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAttachmentType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AttachmentType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AttachmentType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["attachment"]; exists {

		vOpts := append(opts, db.WithValidateField("attachment"))
		if err := fv(ctx, m.GetAttachment(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["content_type"]; exists {

		vOpts := append(opts, db.WithValidateField("content_type"))
		if err := fv(ctx, m.GetContentType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["filename"]; exists {

		vOpts := append(opts, db.WithValidateField("filename"))
		if err := fv(ctx, m.GetFilename(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tp_id"]; exists {

		vOpts := append(opts, db.WithValidateField("tp_id"))
		if err := fv(ctx, m.GetTpId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAttachmentTypeValidator = func() *ValidateAttachmentType {
	v := &ValidateAttachmentType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func AttachmentTypeValidator() db.Validator {
	return DefaultAttachmentTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CommentType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CommentType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CommentType) DeepCopy() *CommentType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CommentType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CommentType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CommentType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CommentTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCommentType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCommentType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CommentType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CommentType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["attachment_ids"]; exists {

		vOpts := append(opts, db.WithValidateField("attachment_ids"))
		for idx, item := range m.GetAttachmentIds() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["attachments_info"]; exists {

		vOpts := append(opts, db.WithValidateField("attachments_info"))
		for idx, item := range m.GetAttachmentsInfo() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["author_email"]; exists {

		vOpts := append(opts, db.WithValidateField("author_email"))
		if err := fv(ctx, m.GetAuthorEmail(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["author_name"]; exists {

		vOpts := append(opts, db.WithValidateField("author_name"))
		if err := fv(ctx, m.GetAuthorName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["comment_id"]; exists {

		vOpts := append(opts, db.WithValidateField("comment_id"))
		if err := fv(ctx, m.GetCommentId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["created_at"]; exists {

		vOpts := append(opts, db.WithValidateField("created_at"))
		if err := fv(ctx, m.GetCreatedAt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["html"]; exists {

		vOpts := append(opts, db.WithValidateField("html"))
		if err := fv(ctx, m.GetHtml(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["plain_text"]; exists {

		vOpts := append(opts, db.WithValidateField("plain_text"))
		if err := fv(ctx, m.GetPlainText(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCommentTypeValidator = func() *ValidateCommentType {
	v := &ValidateCommentType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func CommentTypeValidator() db.Validator {
	return DefaultCommentTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *CreateSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetRelatesToDRefInfo()

}

func (m *CreateSpecType) GetRelatesToDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRelatesTo()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("CreateSpecType.relates_to[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "customer_support.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "relates_to",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRelatesToDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetRelatesToDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "customer_support.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: customer_support")
	}
	for _, ref := range m.GetRelatesTo() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["category"]; exists {

		vOpts := append(opts, db.WithValidateField("category"))
		if err := fv(ctx, m.GetCategory(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["comments"]; exists {

		vOpts := append(opts, db.WithValidateField("comments"))
		for idx, item := range m.GetComments() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ongoing"]; exists {

		vOpts := append(opts, db.WithValidateField("ongoing"))
		if err := fv(ctx, m.GetOngoing(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["priority"]; exists {

		vOpts := append(opts, db.WithValidateField("priority"))
		if err := fv(ctx, m.GetPriority(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["product_data"]; exists {

		vOpts := append(opts, db.WithValidateField("product_data"))
		if err := fv(ctx, m.GetProductData(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["relates_to"]; exists {

		vOpts := append(opts, db.WithValidateField("relates_to"))
		for idx, item := range m.GetRelatesTo() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["service"]; exists {

		vOpts := append(opts, db.WithValidateField("service"))
		if err := fv(ctx, m.GetService(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["subject"]; exists {

		vOpts := append(opts, db.WithValidateField("subject"))
		if err := fv(ctx, m.GetSubject(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["timeline"]; exists {

		vOpts := append(opts, db.WithValidateField("timeline"))
		if err := fv(ctx, m.GetTimeline(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["topic"]; exists {

		vOpts := append(opts, db.WithValidateField("topic"))
		if err := fv(ctx, m.GetTopic(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tp_id"]; exists {

		vOpts := append(opts, db.WithValidateField("tp_id"))
		if err := fv(ctx, m.GetTpId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GetSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetFollowupsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetFollowupsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRelatesToDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRelatesToDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetUserDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetUserDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *GetSpecType) GetFollowupsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetFollowups()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.followups[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "customer_support.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "followups",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetFollowupsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetFollowupsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "customer_support.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: customer_support")
	}
	for _, ref := range m.GetFollowups() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GetSpecType) GetRelatesToDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRelatesTo()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.relates_to[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "customer_support.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "relates_to",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRelatesToDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetRelatesToDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "customer_support.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: customer_support")
	}
	for _, ref := range m.GetRelatesTo() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GetSpecType) GetUserDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetUser()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.user[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "user.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "user",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetUserDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetUserDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "user.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: user")
	}
	for _, ref := range m.GetUser() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["author_name"]; exists {

		vOpts := append(opts, db.WithValidateField("author_name"))
		if err := fv(ctx, m.GetAuthorName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["category"]; exists {

		vOpts := append(opts, db.WithValidateField("category"))
		if err := fv(ctx, m.GetCategory(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["comments"]; exists {

		vOpts := append(opts, db.WithValidateField("comments"))
		for idx, item := range m.GetComments() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["created_at"]; exists {

		vOpts := append(opts, db.WithValidateField("created_at"))
		if err := fv(ctx, m.GetCreatedAt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["custom_fields"]; exists {

		vOpts := append(opts, db.WithValidateField("custom_fields"))
		for idx, item := range m.GetCustomFields() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["escalated"]; exists {

		vOpts := append(opts, db.WithValidateField("escalated"))
		if err := fv(ctx, m.GetEscalated(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["followups"]; exists {

		vOpts := append(opts, db.WithValidateField("followups"))
		for idx, item := range m.GetFollowups() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["ongoing"]; exists {

		vOpts := append(opts, db.WithValidateField("ongoing"))
		if err := fv(ctx, m.GetOngoing(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["priority"]; exists {

		vOpts := append(opts, db.WithValidateField("priority"))
		if err := fv(ctx, m.GetPriority(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["product_data"]; exists {

		vOpts := append(opts, db.WithValidateField("product_data"))
		if err := fv(ctx, m.GetProductData(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["relates_to"]; exists {

		vOpts := append(opts, db.WithValidateField("relates_to"))
		for idx, item := range m.GetRelatesTo() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["service"]; exists {

		vOpts := append(opts, db.WithValidateField("service"))
		if err := fv(ctx, m.GetService(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["subject"]; exists {

		vOpts := append(opts, db.WithValidateField("subject"))
		if err := fv(ctx, m.GetSubject(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tags"]; exists {

		vOpts := append(opts, db.WithValidateField("tags"))
		for idx, item := range m.GetTags() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["timeline"]; exists {

		vOpts := append(opts, db.WithValidateField("timeline"))
		if err := fv(ctx, m.GetTimeline(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["topic"]; exists {

		vOpts := append(opts, db.WithValidateField("topic"))
		if err := fv(ctx, m.GetTopic(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tp_id"]; exists {

		vOpts := append(opts, db.WithValidateField("tp_id"))
		if err := fv(ctx, m.GetTpId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["update_at"]; exists {

		vOpts := append(opts, db.WithValidateField("update_at"))
		if err := fv(ctx, m.GetUpdateAt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user"]; exists {

		vOpts := append(opts, db.WithValidateField("user"))
		for idx, item := range m.GetUser() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["via"]; exists {

		vOpts := append(opts, db.WithValidateField("via"))
		for key, value := range m.GetVia() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetFollowupsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetFollowupsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRelatesToDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRelatesToDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetUserDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetUserDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *GlobalSpecType) GetFollowupsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetFollowups()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.followups[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "customer_support.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "followups",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetFollowupsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetFollowupsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "customer_support.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: customer_support")
	}
	for _, ref := range m.GetFollowups() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetRelatesToDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRelatesTo()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.relates_to[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "customer_support.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "relates_to",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRelatesToDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetRelatesToDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "customer_support.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: customer_support")
	}
	for _, ref := range m.GetRelatesTo() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetUserDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetUser()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.user[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "user.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "user",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetUserDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetUserDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "user.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: user")
	}
	for _, ref := range m.GetUser() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["author_name"]; exists {

		vOpts := append(opts, db.WithValidateField("author_name"))
		if err := fv(ctx, m.GetAuthorName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["case_id"]; exists {

		vOpts := append(opts, db.WithValidateField("case_id"))
		if err := fv(ctx, m.GetCaseId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["category"]; exists {

		vOpts := append(opts, db.WithValidateField("category"))
		if err := fv(ctx, m.GetCategory(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["comments"]; exists {

		vOpts := append(opts, db.WithValidateField("comments"))
		for idx, item := range m.GetComments() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["created_at"]; exists {

		vOpts := append(opts, db.WithValidateField("created_at"))
		if err := fv(ctx, m.GetCreatedAt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["custom_fields"]; exists {

		vOpts := append(opts, db.WithValidateField("custom_fields"))
		for idx, item := range m.GetCustomFields() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["escalated"]; exists {

		vOpts := append(opts, db.WithValidateField("escalated"))
		if err := fv(ctx, m.GetEscalated(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["followups"]; exists {

		vOpts := append(opts, db.WithValidateField("followups"))
		for idx, item := range m.GetFollowups() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["ongoing"]; exists {

		vOpts := append(opts, db.WithValidateField("ongoing"))
		if err := fv(ctx, m.GetOngoing(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["priority"]; exists {

		vOpts := append(opts, db.WithValidateField("priority"))
		if err := fv(ctx, m.GetPriority(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["private"]; exists {

		vOpts := append(opts, db.WithValidateField("private"))
		if err := fv(ctx, m.GetPrivate(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["product_data"]; exists {

		vOpts := append(opts, db.WithValidateField("product_data"))
		if err := fv(ctx, m.GetProductData(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["provider_id"]; exists {

		vOpts := append(opts, db.WithValidateField("provider_id"))
		if err := fv(ctx, m.GetProviderId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["relates_to"]; exists {

		vOpts := append(opts, db.WithValidateField("relates_to"))
		for idx, item := range m.GetRelatesTo() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["service"]; exists {

		vOpts := append(opts, db.WithValidateField("service"))
		if err := fv(ctx, m.GetService(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["subject"]; exists {

		vOpts := append(opts, db.WithValidateField("subject"))
		if err := fv(ctx, m.GetSubject(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tags"]; exists {

		vOpts := append(opts, db.WithValidateField("tags"))
		for idx, item := range m.GetTags() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["timeline"]; exists {

		vOpts := append(opts, db.WithValidateField("timeline"))
		if err := fv(ctx, m.GetTimeline(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["topic"]; exists {

		vOpts := append(opts, db.WithValidateField("topic"))
		if err := fv(ctx, m.GetTopic(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tp_id"]; exists {

		vOpts := append(opts, db.WithValidateField("tp_id"))
		if err := fv(ctx, m.GetTpId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["update_at"]; exists {

		vOpts := append(opts, db.WithValidateField("update_at"))
		if err := fv(ctx, m.GetUpdateAt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user"]; exists {

		vOpts := append(opts, db.WithValidateField("user"))
		for idx, item := range m.GetUser() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["via"]; exists {

		vOpts := append(opts, db.WithValidateField("via"))
		for key, value := range m.GetVia() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

func (m *CreateSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.Category = f.GetCategory()
	m.Comments = f.GetComments()
	m.Description = f.GetDescription()
	m.Ongoing = f.GetOngoing()
	m.Priority = f.GetPriority()
	m.ProductData = f.GetProductData()
	m.RelatesTo = f.GetRelatesTo()
	m.Service = f.GetService()
	m.Status = f.GetStatus()
	m.Subject = f.GetSubject()
	m.Timeline = f.GetTimeline()
	m.Topic = f.GetTopic()
	m.TpId = f.GetTpId()
	m.Type = f.GetType()
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *CreateSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *CreateSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.Category = m1.Category
	f.Comments = m1.Comments
	f.Description = m1.Description
	f.Ongoing = m1.Ongoing
	f.Priority = m1.Priority
	f.ProductData = m1.ProductData
	f.RelatesTo = m1.RelatesTo
	f.Service = m1.Service
	f.Status = m1.Status
	f.Subject = m1.Subject
	f.Timeline = m1.Timeline
	f.Topic = m1.Topic
	f.TpId = m1.TpId
	f.Type = m1.Type
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *CreateSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

func (m *GetSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.AuthorName = f.GetAuthorName()
	m.Category = f.GetCategory()
	m.Comments = f.GetComments()
	m.CreatedAt = f.GetCreatedAt()
	m.CustomFields = f.GetCustomFields()
	m.Description = f.GetDescription()
	m.Escalated = f.GetEscalated()
	m.Followups = f.GetFollowups()
	m.Ongoing = f.GetOngoing()
	m.Priority = f.GetPriority()
	m.ProductData = f.GetProductData()
	m.RelatesTo = f.GetRelatesTo()
	m.Service = f.GetService()
	m.Status = f.GetStatus()
	m.Subject = f.GetSubject()
	m.Tags = f.GetTags()
	m.Timeline = f.GetTimeline()
	m.Topic = f.GetTopic()
	m.TpId = f.GetTpId()
	m.Type = f.GetType()
	m.UpdateAt = f.GetUpdateAt()
	m.User = f.GetUser()
	m.Via = f.GetVia()
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *GetSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *GetSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.AuthorName = m1.AuthorName
	f.Category = m1.Category
	f.Comments = m1.Comments
	f.CreatedAt = m1.CreatedAt
	f.CustomFields = m1.CustomFields
	f.Description = m1.Description
	f.Escalated = m1.Escalated
	f.Followups = m1.Followups
	f.Ongoing = m1.Ongoing
	f.Priority = m1.Priority
	f.ProductData = m1.ProductData
	f.RelatesTo = m1.RelatesTo
	f.Service = m1.Service
	f.Status = m1.Status
	f.Subject = m1.Subject
	f.Tags = m1.Tags
	f.Timeline = m1.Timeline
	f.Topic = m1.Topic
	f.TpId = m1.TpId
	f.Type = m1.Type
	f.UpdateAt = m1.UpdateAt
	f.User = m1.User
	f.Via = m1.Via
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *GetSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}
