// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package schema

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *ChoiceItem) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ChoiceItem) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ChoiceItem) DeepCopy() *ChoiceItem {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ChoiceItem{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ChoiceItem) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ChoiceItem) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ChoiceItemValidator().Validate(ctx, m, opts...)
}

type ValidateChoiceItem struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateChoiceItem) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ChoiceItem)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ChoiceItem got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultChoiceItemValidator = func() *ValidateChoiceItem {
	v := &ValidateChoiceItem{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ChoiceItemValidator() db.Validator {
	return DefaultChoiceItemValidator
}

// augmented methods on protoc/std generated struct

func (m *ChoiceItemList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ChoiceItemList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ChoiceItemList) DeepCopy() *ChoiceItemList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ChoiceItemList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ChoiceItemList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ChoiceItemList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ChoiceItemListValidator().Validate(ctx, m, opts...)
}

type ValidateChoiceItemList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateChoiceItemList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ChoiceItemList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ChoiceItemList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice_items"]; exists {

		vOpts := append(opts, db.WithValidateField("choice_items"))
		for idx, item := range m.GetChoiceItems() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultChoiceItemListValidator = func() *ValidateChoiceItemList {
	v := &ValidateChoiceItemList{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ChoiceItemListValidator() db.Validator {
	return DefaultChoiceItemListValidator
}

// augmented methods on protoc/std generated struct

func (m *Choices) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Choices) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Choices) DeepCopy() *Choices {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Choices{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Choices) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Choices) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ChoicesValidator().Validate(ctx, m, opts...)
}

type ValidateChoices struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateChoices) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Choices)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Choices got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {

		vOpts := append(opts, db.WithValidateField("choice"))
		for idx, item := range m.GetChoice() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultChoicesValidator = func() *ValidateChoices {
	v := &ValidateChoices{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ChoicesValidator() db.Validator {
	return DefaultChoicesValidator
}

// augmented methods on protoc/std generated struct

func (m *Column) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Column) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Column) DeepCopy() *Column {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Column{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Column) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Column) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ColumnValidator().Validate(ctx, m, opts...)
}

type ValidateColumn struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateColumn) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Column)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Column got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetFieldChoice().(type) {
	case *Column_FieldValue:
		if fv, exists := v.FldValidators["field_choice.field_value"]; exists {
			val := m.GetFieldChoice().(*Column_FieldValue).FieldValue
			vOpts := append(opts,
				db.WithValidateField("field_choice"),
				db.WithValidateField("field_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Column_FieldExistsNotExists:
		if fv, exists := v.FldValidators["field_choice.field_exists_not_exists"]; exists {
			val := m.GetFieldChoice().(*Column_FieldExistsNotExists).FieldExistsNotExists
			vOpts := append(opts,
				db.WithValidateField("field_choice"),
				db.WithValidateField("field_exists_not_exists"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Column_FieldOneof:
		if fv, exists := v.FldValidators["field_choice.field_oneof"]; exists {
			val := m.GetFieldChoice().(*Column_FieldOneof).FieldOneof
			vOpts := append(opts,
				db.WithValidateField("field_choice"),
				db.WithValidateField("field_oneof"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Column_FieldOneValue:
		if fv, exists := v.FldValidators["field_choice.field_one_value"]; exists {
			val := m.GetFieldChoice().(*Column_FieldOneValue).FieldOneValue
			vOpts := append(opts,
				db.WithValidateField("field_choice"),
				db.WithValidateField("field_one_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Column_FieldLength:
		if fv, exists := v.FldValidators["field_choice.field_length"]; exists {
			val := m.GetFieldChoice().(*Column_FieldLength).FieldLength
			vOpts := append(opts,
				db.WithValidateField("field_choice"),
				db.WithValidateField("field_length"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Column_FieldElements:
		if fv, exists := v.FldValidators["field_choice.field_elements"]; exists {
			val := m.GetFieldChoice().(*Column_FieldElements).FieldElements
			vOpts := append(opts,
				db.WithValidateField("field_choice"),
				db.WithValidateField("field_elements"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Column_FieldMapElements:
		if fv, exists := v.FldValidators["field_choice.field_map_elements"]; exists {
			val := m.GetFieldChoice().(*Column_FieldMapElements).FieldMapElements
			vOpts := append(opts,
				db.WithValidateField("field_choice"),
				db.WithValidateField("field_map_elements"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Column_FieldKvPairs:
		if fv, exists := v.FldValidators["field_choice.field_kv_pairs"]; exists {
			val := m.GetFieldChoice().(*Column_FieldKvPairs).FieldKvPairs
			vOpts := append(opts,
				db.WithValidateField("field_choice"),
				db.WithValidateField("field_kv_pairs"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["optional"]; exists {

		vOpts := append(opts, db.WithValidateField("optional"))
		if err := fv(ctx, m.GetOptional(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["show_copy_button"]; exists {

		vOpts := append(opts, db.WithValidateField("show_copy_button"))
		if err := fv(ctx, m.GetShowCopyButton(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["title"]; exists {

		vOpts := append(opts, db.WithValidateField("title"))
		if err := fv(ctx, m.GetTitle(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultColumnValidator = func() *ValidateColumn {
	v := &ValidateColumn{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ColumnValidator() db.Validator {
	return DefaultColumnValidator
}

// augmented methods on protoc/std generated struct

func (m *Columns) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Columns) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Columns) DeepCopy() *Columns {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Columns{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Columns) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Columns) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ColumnsValidator().Validate(ctx, m, opts...)
}

type ValidateColumns struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateColumns) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Columns)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Columns got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["column_list"]; exists {

		vOpts := append(opts, db.WithValidateField("column_list"))
		for idx, item := range m.GetColumnList() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["not_required"]; exists {

		vOpts := append(opts, db.WithValidateField("not_required"))
		if err := fv(ctx, m.GetNotRequired(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultColumnsValidator = func() *ValidateColumns {
	v := &ValidateColumns{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ColumnsValidator() db.Validator {
	return DefaultColumnsValidator
}

// augmented methods on protoc/std generated struct

func (m *ConstraintLength) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ConstraintLength) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ConstraintLength) DeepCopy() *ConstraintLength {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ConstraintLength{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ConstraintLength) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ConstraintLength) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ConstraintLengthValidator().Validate(ctx, m, opts...)
}

type ValidateConstraintLength struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateConstraintLength) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ConstraintLength)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ConstraintLength got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetLengthChoice().(type) {
	case *ConstraintLength_Equals:
		if fv, exists := v.FldValidators["length_choice.equals"]; exists {
			val := m.GetLengthChoice().(*ConstraintLength_Equals).Equals
			vOpts := append(opts,
				db.WithValidateField("length_choice"),
				db.WithValidateField("equals"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ConstraintLength_NotEquals:
		if fv, exists := v.FldValidators["length_choice.not_equals"]; exists {
			val := m.GetLengthChoice().(*ConstraintLength_NotEquals).NotEquals
			vOpts := append(opts,
				db.WithValidateField("length_choice"),
				db.WithValidateField("not_equals"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultConstraintLengthValidator = func() *ValidateConstraintLength {
	v := &ValidateConstraintLength{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ConstraintLengthValidator() db.Validator {
	return DefaultConstraintLengthValidator
}

// augmented methods on protoc/std generated struct

func (m *DateRangeOptions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DateRangeOptions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DateRangeOptions) DeepCopy() *DateRangeOptions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DateRangeOptions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DateRangeOptions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DateRangeOptions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DateRangeOptionsValidator().Validate(ctx, m, opts...)
}

type ValidateDateRangeOptions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDateRangeOptions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DateRangeOptions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DateRangeOptions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["max_days"]; exists {

		vOpts := append(opts, db.WithValidateField("max_days"))
		if err := fv(ctx, m.GetMaxDays(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["min_days"]; exists {

		vOpts := append(opts, db.WithValidateField("min_days"))
		if err := fv(ctx, m.GetMinDays(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDateRangeOptionsValidator = func() *ValidateDateRangeOptions {
	v := &ValidateDateRangeOptions{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DateRangeOptionsValidator() db.Validator {
	return DefaultDateRangeOptionsValidator
}

// augmented methods on protoc/std generated struct

func (m *DisplayElements) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DisplayElements) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DisplayElements) DeepCopy() *DisplayElements {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DisplayElements{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DisplayElements) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DisplayElements) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DisplayElementsValidator().Validate(ctx, m, opts...)
}

type ValidateDisplayElements struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDisplayElements) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DisplayElements)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DisplayElements got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["default_value"]; exists {

		vOpts := append(opts, db.WithValidateField("default_value"))
		if err := fv(ctx, m.GetDefaultValue(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["is_enum"]; exists {

		vOpts := append(opts, db.WithValidateField("is_enum"))
		if err := fv(ctx, m.GetIsEnum(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["limit"]; exists {

		vOpts := append(opts, db.WithValidateField("limit"))
		if err := fv(ctx, m.GetLimit(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["prefix"]; exists {

		vOpts := append(opts, db.WithValidateField("prefix"))
		if err := fv(ctx, m.GetPrefix(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sub_path"]; exists {

		vOpts := append(opts, db.WithValidateField("sub_path"))
		if err := fv(ctx, m.GetSubPath(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDisplayElementsValidator = func() *ValidateDisplayElements {
	v := &ValidateDisplayElements{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DisplayElementsValidator() db.Validator {
	return DefaultDisplayElementsValidator
}

// augmented methods on protoc/std generated struct

func (m *DisplayExistsNotExists) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DisplayExistsNotExists) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DisplayExistsNotExists) DeepCopy() *DisplayExistsNotExists {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DisplayExistsNotExists{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DisplayExistsNotExists) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DisplayExistsNotExists) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DisplayExistsNotExistsValidator().Validate(ctx, m, opts...)
}

type ValidateDisplayExistsNotExists struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDisplayExistsNotExists) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DisplayExistsNotExists)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DisplayExistsNotExists got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["exists_value"]; exists {

		vOpts := append(opts, db.WithValidateField("exists_value"))
		if err := fv(ctx, m.GetExistsValue(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["no_exists_value"]; exists {

		vOpts := append(opts, db.WithValidateField("no_exists_value"))
		if err := fv(ctx, m.GetNoExistsValue(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDisplayExistsNotExistsValidator = func() *ValidateDisplayExistsNotExists {
	v := &ValidateDisplayExistsNotExists{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DisplayExistsNotExistsValidator() db.Validator {
	return DefaultDisplayExistsNotExistsValidator
}

// augmented methods on protoc/std generated struct

func (m *DisplayKVItem) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DisplayKVItem) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DisplayKVItem) DeepCopy() *DisplayKVItem {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DisplayKVItem{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DisplayKVItem) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DisplayKVItem) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DisplayKVItemValidator().Validate(ctx, m, opts...)
}

type ValidateDisplayKVItem struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDisplayKVItem) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DisplayKVItem)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DisplayKVItem got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["key"]; exists {

		vOpts := append(opts, db.WithValidateField("key"))
		if err := fv(ctx, m.GetKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["length_of"]; exists {

		vOpts := append(opts, db.WithValidateField("length_of"))
		if err := fv(ctx, m.GetLengthOf(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetValueChoice().(type) {
	case *DisplayKVItem_FieldLength:
		if fv, exists := v.FldValidators["value_choice.field_length"]; exists {
			val := m.GetValueChoice().(*DisplayKVItem_FieldLength).FieldLength
			vOpts := append(opts,
				db.WithValidateField("value_choice"),
				db.WithValidateField("field_length"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DisplayKVItem_FieldElements:
		if fv, exists := v.FldValidators["value_choice.field_elements"]; exists {
			val := m.GetValueChoice().(*DisplayKVItem_FieldElements).FieldElements
			vOpts := append(opts,
				db.WithValidateField("value_choice"),
				db.WithValidateField("field_elements"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DisplayKVItem_FieldValue:
		if fv, exists := v.FldValidators["value_choice.field_value"]; exists {
			val := m.GetValueChoice().(*DisplayKVItem_FieldValue).FieldValue
			vOpts := append(opts,
				db.WithValidateField("value_choice"),
				db.WithValidateField("field_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DisplayKVItem_Value:
		if fv, exists := v.FldValidators["value_choice.value"]; exists {
			val := m.GetValueChoice().(*DisplayKVItem_Value).Value
			vOpts := append(opts,
				db.WithValidateField("value_choice"),
				db.WithValidateField("value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDisplayKVItemValidator = func() *ValidateDisplayKVItem {
	v := &ValidateDisplayKVItem{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DisplayKVItemValidator() db.Validator {
	return DefaultDisplayKVItemValidator
}

// augmented methods on protoc/std generated struct

func (m *DisplayKVItemList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DisplayKVItemList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DisplayKVItemList) DeepCopy() *DisplayKVItemList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DisplayKVItemList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DisplayKVItemList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DisplayKVItemList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DisplayKVItemListValidator().Validate(ctx, m, opts...)
}

type ValidateDisplayKVItemList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDisplayKVItemList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DisplayKVItemList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DisplayKVItemList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["items"]; exists {

		vOpts := append(opts, db.WithValidateField("items"))
		for idx, item := range m.GetItems() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDisplayKVItemListValidator = func() *ValidateDisplayKVItemList {
	v := &ValidateDisplayKVItemList{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DisplayKVItemListValidator() db.Validator {
	return DefaultDisplayKVItemListValidator
}

// augmented methods on protoc/std generated struct

func (m *DisplayLength) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DisplayLength) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DisplayLength) DeepCopy() *DisplayLength {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DisplayLength{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DisplayLength) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DisplayLength) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DisplayLengthValidator().Validate(ctx, m, opts...)
}

type ValidateDisplayLength struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDisplayLength) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DisplayLength)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DisplayLength got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["placeholder"]; exists {

		vOpts := append(opts, db.WithValidateField("placeholder"))
		if err := fv(ctx, m.GetPlaceholder(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["suffix"]; exists {

		vOpts := append(opts, db.WithValidateField("suffix"))
		if err := fv(ctx, m.GetSuffix(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDisplayLengthValidator = func() *ValidateDisplayLength {
	v := &ValidateDisplayLength{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DisplayLengthValidator() db.Validator {
	return DefaultDisplayLengthValidator
}

// augmented methods on protoc/std generated struct

func (m *DisplayMapElements) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DisplayMapElements) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DisplayMapElements) DeepCopy() *DisplayMapElements {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DisplayMapElements{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DisplayMapElements) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DisplayMapElements) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DisplayMapElementsValidator().Validate(ctx, m, opts...)
}

type ValidateDisplayMapElements struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDisplayMapElements) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DisplayMapElements)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DisplayMapElements got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["default_value"]; exists {

		vOpts := append(opts, db.WithValidateField("default_value"))
		if err := fv(ctx, m.GetDefaultValue(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["key_is_enum"]; exists {

		vOpts := append(opts, db.WithValidateField("key_is_enum"))
		if err := fv(ctx, m.GetKeyIsEnum(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["limit"]; exists {

		vOpts := append(opts, db.WithValidateField("limit"))
		if err := fv(ctx, m.GetLimit(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value_is_enum"]; exists {

		vOpts := append(opts, db.WithValidateField("value_is_enum"))
		if err := fv(ctx, m.GetValueIsEnum(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDisplayMapElementsValidator = func() *ValidateDisplayMapElements {
	v := &ValidateDisplayMapElements{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DisplayMapElementsValidator() db.Validator {
	return DefaultDisplayMapElementsValidator
}

// augmented methods on protoc/std generated struct

func (m *DisplayOneValue) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DisplayOneValue) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DisplayOneValue) DeepCopy() *DisplayOneValue {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DisplayOneValue{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DisplayOneValue) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DisplayOneValue) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DisplayOneValueValidator().Validate(ctx, m, opts...)
}

type ValidateDisplayOneValue struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDisplayOneValue) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DisplayOneValue)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DisplayOneValue got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["default_value"]; exists {

		vOpts := append(opts, db.WithValidateField("default_value"))
		if err := fv(ctx, m.GetDefaultValue(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path_list"]; exists {

		vOpts := append(opts, db.WithValidateField("path_list"))
		for idx, item := range m.GetPathList() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDisplayOneValueValidator = func() *ValidateDisplayOneValue {
	v := &ValidateDisplayOneValue{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DisplayOneValueValidator() db.Validator {
	return DefaultDisplayOneValueValidator
}

// augmented methods on protoc/std generated struct

func (m *DisplayOneof) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DisplayOneof) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DisplayOneof) DeepCopy() *DisplayOneof {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DisplayOneof{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DisplayOneof) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DisplayOneof) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DisplayOneofValidator().Validate(ctx, m, opts...)
}

type ValidateDisplayOneof struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDisplayOneof) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DisplayOneof)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DisplayOneof got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["default_value"]; exists {

		vOpts := append(opts, db.WithValidateField("default_value"))
		if err := fv(ctx, m.GetDefaultValue(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["oneof_list"]; exists {

		vOpts := append(opts, db.WithValidateField("oneof_list"))
		if err := fv(ctx, m.GetOneofList(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDisplayOneofValidator = func() *ValidateDisplayOneof {
	v := &ValidateDisplayOneof{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DisplayOneofValidator() db.Validator {
	return DefaultDisplayOneofValidator
}

// augmented methods on protoc/std generated struct

func (m *DisplayOneofItem) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DisplayOneofItem) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DisplayOneofItem) DeepCopy() *DisplayOneofItem {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DisplayOneofItem{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DisplayOneofItem) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DisplayOneofItem) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DisplayOneofItemValidator().Validate(ctx, m, opts...)
}

type ValidateDisplayOneofItem struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDisplayOneofItem) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DisplayOneofItem)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DisplayOneofItem got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["length_of"]; exists {

		vOpts := append(opts, db.WithValidateField("length_of"))
		if err := fv(ctx, m.GetLengthOf(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetValueChoice().(type) {
	case *DisplayOneofItem_FieldValue:
		if fv, exists := v.FldValidators["value_choice.field_value"]; exists {
			val := m.GetValueChoice().(*DisplayOneofItem_FieldValue).FieldValue
			vOpts := append(opts,
				db.WithValidateField("value_choice"),
				db.WithValidateField("field_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DisplayOneofItem_FieldLength:
		if fv, exists := v.FldValidators["value_choice.field_length"]; exists {
			val := m.GetValueChoice().(*DisplayOneofItem_FieldLength).FieldLength
			vOpts := append(opts,
				db.WithValidateField("value_choice"),
				db.WithValidateField("field_length"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DisplayOneofItem_FieldElements:
		if fv, exists := v.FldValidators["value_choice.field_elements"]; exists {
			val := m.GetValueChoice().(*DisplayOneofItem_FieldElements).FieldElements
			vOpts := append(opts,
				db.WithValidateField("value_choice"),
				db.WithValidateField("field_elements"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DisplayOneofItem_FieldMapElements:
		if fv, exists := v.FldValidators["value_choice.field_map_elements"]; exists {
			val := m.GetValueChoice().(*DisplayOneofItem_FieldMapElements).FieldMapElements
			vOpts := append(opts,
				db.WithValidateField("value_choice"),
				db.WithValidateField("field_map_elements"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DisplayOneofItem_Value:
		if fv, exists := v.FldValidators["value_choice.value"]; exists {
			val := m.GetValueChoice().(*DisplayOneofItem_Value).Value
			vOpts := append(opts,
				db.WithValidateField("value_choice"),
				db.WithValidateField("value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDisplayOneofItemValidator = func() *ValidateDisplayOneofItem {
	v := &ValidateDisplayOneofItem{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DisplayOneofItemValidator() db.Validator {
	return DefaultDisplayOneofItemValidator
}

// augmented methods on protoc/std generated struct

func (m *DisplayOneofItemList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DisplayOneofItemList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DisplayOneofItemList) DeepCopy() *DisplayOneofItemList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DisplayOneofItemList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DisplayOneofItemList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DisplayOneofItemList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DisplayOneofItemListValidator().Validate(ctx, m, opts...)
}

type ValidateDisplayOneofItemList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDisplayOneofItemList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DisplayOneofItemList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DisplayOneofItemList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["items"]; exists {

		vOpts := append(opts, db.WithValidateField("items"))
		for idx, item := range m.GetItems() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDisplayOneofItemListValidator = func() *ValidateDisplayOneofItemList {
	v := &ValidateDisplayOneofItemList{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DisplayOneofItemListValidator() db.Validator {
	return DefaultDisplayOneofItemListValidator
}

// augmented methods on protoc/std generated struct

func (m *DisplayValue) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DisplayValue) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DisplayValue) DeepCopy() *DisplayValue {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DisplayValue{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DisplayValue) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DisplayValue) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DisplayValueValidator().Validate(ctx, m, opts...)
}

type ValidateDisplayValue struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDisplayValue) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DisplayValue)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DisplayValue got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["default_value"]; exists {

		vOpts := append(opts, db.WithValidateField("default_value"))
		if err := fv(ctx, m.GetDefaultValue(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["is_enum"]; exists {

		vOpts := append(opts, db.WithValidateField("is_enum"))
		if err := fv(ctx, m.GetIsEnum(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["prefix"]; exists {

		vOpts := append(opts, db.WithValidateField("prefix"))
		if err := fv(ctx, m.GetPrefix(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDisplayValueValidator = func() *ValidateDisplayValue {
	v := &ValidateDisplayValue{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DisplayValueValidator() db.Validator {
	return DefaultDisplayValueValidator
}

// augmented methods on protoc/std generated struct

func (m *FieldViewOptions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FieldViewOptions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FieldViewOptions) DeepCopy() *FieldViewOptions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FieldViewOptions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FieldViewOptions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FieldViewOptions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FieldViewOptionsValidator().Validate(ctx, m, opts...)
}

type ValidateFieldViewOptions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFieldViewOptions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FieldViewOptions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FieldViewOptions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["common_choices"]; exists {

		vOpts := append(opts, db.WithValidateField("common_choices"))
		if err := fv(ctx, m.GetCommonChoices(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_value"]; exists {

		vOpts := append(opts, db.WithValidateField("default_value"))
		if err := fv(ctx, m.GetDefaultValue(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["display_name"]; exists {

		vOpts := append(opts, db.WithValidateField("display_name"))
		if err := fv(ctx, m.GetDisplayName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["in_namespace_types"]; exists {

		vOpts := append(opts, db.WithValidateField("in_namespace_types"))
		if err := fv(ctx, m.GetInNamespaceTypes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["input_box_format"]; exists {

		vOpts := append(opts, db.WithValidateField("input_box_format"))
		if err := fv(ctx, m.GetInputBoxFormat(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["input_box_size"]; exists {

		vOpts := append(opts, db.WithValidateField("input_box_size"))
		if err := fv(ctx, m.GetInputBoxSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["map"]; exists {

		vOpts := append(opts, db.WithValidateField("map"))
		if err := fv(ctx, m.GetMap(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["new_form"]; exists {

		vOpts := append(opts, db.WithValidateField("new_form"))
		if err := fv(ctx, m.GetNewForm(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["repeated"]; exists {

		vOpts := append(opts, db.WithValidateField("repeated"))
		if err := fv(ctx, m.GetRepeated(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFieldViewOptionsValidator = func() *ValidateFieldViewOptions {
	v := &ValidateFieldViewOptions{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FieldViewOptionsValidator() db.Validator {
	return DefaultFieldViewOptionsValidator
}

// augmented methods on protoc/std generated struct

func (m *HiddenConditions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HiddenConditions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HiddenConditions) DeepCopy() *HiddenConditions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HiddenConditions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HiddenConditions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HiddenConditions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HiddenConditionsValidator().Validate(ctx, m, opts...)
}

type ValidateHiddenConditions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHiddenConditions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HiddenConditions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HiddenConditions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ancestor_message_in"]; exists {

		vOpts := append(opts, db.WithValidateField("ancestor_message_in"))
		for idx, item := range m.GetAncestorMessageIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["environment_in"]; exists {

		vOpts := append(opts, db.WithValidateField("environment_in"))
		for idx, item := range m.GetEnvironmentIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["invert_match"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_match"))
		if err := fv(ctx, m.GetInvertMatch(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path_suffix_in"]; exists {

		vOpts := append(opts, db.WithValidateField("path_suffix_in"))
		for idx, item := range m.GetPathSuffixIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["root_object_in"]; exists {

		vOpts := append(opts, db.WithValidateField("root_object_in"))
		for idx, item := range m.GetRootObjectIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["workspaces_in"]; exists {

		vOpts := append(opts, db.WithValidateField("workspaces_in"))
		for idx, item := range m.GetWorkspacesIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHiddenConditionsValidator = func() *ValidateHiddenConditions {
	v := &ValidateHiddenConditions{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func HiddenConditionsValidator() db.Validator {
	return DefaultHiddenConditionsValidator
}

// augmented methods on protoc/std generated struct

func (m *HintWithAction) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HintWithAction) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HintWithAction) DeepCopy() *HintWithAction {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HintWithAction{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HintWithAction) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HintWithAction) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HintWithActionValidator().Validate(ctx, m, opts...)
}

type ValidateHintWithAction struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHintWithAction) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HintWithAction)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HintWithAction got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["action_label"]; exists {

		vOpts := append(opts, db.WithValidateField("action_label"))
		if err := fv(ctx, m.GetActionLabel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["action_type"]; exists {

		vOpts := append(opts, db.WithValidateField("action_type"))
		if err := fv(ctx, m.GetActionType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHintWithActionValidator = func() *ValidateHintWithAction {
	v := &ValidateHintWithAction{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func HintWithActionValidator() db.Validator {
	return DefaultHintWithActionValidator
}

// augmented methods on protoc/std generated struct

func (m *HintWithLink) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HintWithLink) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HintWithLink) DeepCopy() *HintWithLink {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HintWithLink{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HintWithLink) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HintWithLink) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HintWithLinkValidator().Validate(ctx, m, opts...)
}

type ValidateHintWithLink struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHintWithLink) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HintWithLink)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HintWithLink got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["link_text"]; exists {

		vOpts := append(opts, db.WithValidateField("link_text"))
		if err := fv(ctx, m.GetLinkText(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["link_url"]; exists {

		vOpts := append(opts, db.WithValidateField("link_url"))
		if err := fv(ctx, m.GetLinkUrl(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHintWithLinkValidator = func() *ValidateHintWithLink {
	v := &ValidateHintWithLink{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func HintWithLinkValidator() db.Validator {
	return DefaultHintWithLinkValidator
}

// augmented methods on protoc/std generated struct

func (m *LabelKeyClassList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LabelKeyClassList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LabelKeyClassList) DeepCopy() *LabelKeyClassList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LabelKeyClassList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LabelKeyClassList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LabelKeyClassList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LabelKeyClassListValidator().Validate(ctx, m, opts...)
}

type ValidateLabelKeyClassList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLabelKeyClassList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LabelKeyClassList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LabelKeyClassList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["key_classes"]; exists {

		vOpts := append(opts, db.WithValidateField("key_classes"))
		for idx, item := range m.GetKeyClasses() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLabelKeyClassListValidator = func() *ValidateLabelKeyClassList {
	v := &ValidateLabelKeyClassList{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LabelKeyClassListValidator() db.Validator {
	return DefaultLabelKeyClassListValidator
}

// augmented methods on protoc/std generated struct

func (m *LabelSelectorOperatorList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LabelSelectorOperatorList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LabelSelectorOperatorList) DeepCopy() *LabelSelectorOperatorList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LabelSelectorOperatorList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LabelSelectorOperatorList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LabelSelectorOperatorList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LabelSelectorOperatorListValidator().Validate(ctx, m, opts...)
}

type ValidateLabelSelectorOperatorList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLabelSelectorOperatorList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LabelSelectorOperatorList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LabelSelectorOperatorList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["operators"]; exists {

		vOpts := append(opts, db.WithValidateField("operators"))
		for idx, item := range m.GetOperators() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLabelSelectorOperatorListValidator = func() *ValidateLabelSelectorOperatorList {
	v := &ValidateLabelSelectorOperatorList{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LabelSelectorOperatorListValidator() db.Validator {
	return DefaultLabelSelectorOperatorListValidator
}

// augmented methods on protoc/std generated struct

func (m *MapOptions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MapOptions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MapOptions) DeepCopy() *MapOptions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MapOptions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MapOptions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MapOptions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MapOptionsValidator().Validate(ctx, m, opts...)
}

type ValidateMapOptions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMapOptions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MapOptions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MapOptions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["keys"]; exists {

		vOpts := append(opts, db.WithValidateField("keys"))
		if err := fv(ctx, m.GetKeys(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["style"]; exists {

		vOpts := append(opts, db.WithValidateField("style"))
		if err := fv(ctx, m.GetStyle(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["values"]; exists {

		vOpts := append(opts, db.WithValidateField("values"))
		if err := fv(ctx, m.GetValues(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMapOptionsValidator = func() *ValidateMapOptions {
	v := &ValidateMapOptions{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func MapOptionsValidator() db.Validator {
	return DefaultMapOptionsValidator
}

// augmented methods on protoc/std generated struct

func (m *RepeatedOptions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RepeatedOptions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RepeatedOptions) DeepCopy() *RepeatedOptions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RepeatedOptions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RepeatedOptions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RepeatedOptions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RepeatedOptionsValidator().Validate(ctx, m, opts...)
}

type ValidateRepeatedOptions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRepeatedOptions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RepeatedOptions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RepeatedOptions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["custom_empty_table_text"]; exists {

		vOpts := append(opts, db.WithValidateField("custom_empty_table_text"))
		if err := fv(ctx, m.GetCustomEmptyTableText(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_create_on_table"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_create_on_table"))
		if err := fv(ctx, m.GetDisableCreateOnTable(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ordered_list"]; exists {

		vOpts := append(opts, db.WithValidateField("ordered_list"))
		if err := fv(ctx, m.GetOrderedList(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["style"]; exists {

		vOpts := append(opts, db.WithValidateField("style"))
		if err := fv(ctx, m.GetStyle(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRepeatedOptionsValidator = func() *ValidateRepeatedOptions {
	v := &ValidateRepeatedOptions{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func RepeatedOptionsValidator() db.Validator {
	return DefaultRepeatedOptionsValidator
}

// augmented methods on protoc/std generated struct

func (m *StoredObjectURL) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StoredObjectURL) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StoredObjectURL) DeepCopy() *StoredObjectURL {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StoredObjectURL{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StoredObjectURL) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StoredObjectURL) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StoredObjectURLValidator().Validate(ctx, m, opts...)
}

type ValidateStoredObjectURL struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStoredObjectURL) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StoredObjectURL)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StoredObjectURL got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["disable_create"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_create"))
		if err := fv(ctx, m.GetDisableCreate(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["object_type"]; exists {

		vOpts := append(opts, db.WithValidateField("object_type"))
		if err := fv(ctx, m.GetObjectType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStoredObjectURLValidator = func() *ValidateStoredObjectURL {
	v := &ValidateStoredObjectURL{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func StoredObjectURLValidator() db.Validator {
	return DefaultStoredObjectURLValidator
}

// augmented methods on protoc/std generated struct

func (m *SuffixText) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SuffixText) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SuffixText) DeepCopy() *SuffixText {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SuffixText{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SuffixText) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SuffixText) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SuffixTextValidator().Validate(ctx, m, opts...)
}

type ValidateSuffixText struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSuffixText) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SuffixText)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SuffixText got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["field_path_value"]; exists {

		vOpts := append(opts, db.WithValidateField("field_path_value"))
		if err := fv(ctx, m.GetFieldPathValue(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSuffixTextValidator = func() *ValidateSuffixText {
	v := &ValidateSuffixText{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SuffixTextValidator() db.Validator {
	return DefaultSuffixTextValidator
}

// augmented methods on protoc/std generated struct

func (m *SuggestedValues) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SuggestedValues) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SuggestedValues) DeepCopy() *SuggestedValues {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SuggestedValues{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SuggestedValues) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SuggestedValues) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SuggestedValuesValidator().Validate(ctx, m, opts...)
}

type ValidateSuggestedValues struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSuggestedValues) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SuggestedValues)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SuggestedValues got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ancestor_message_in"]; exists {

		vOpts := append(opts, db.WithValidateField("ancestor_message_in"))
		for idx, item := range m.GetAncestorMessageIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["exclusive"]; exists {

		vOpts := append(opts, db.WithValidateField("exclusive"))
		if err := fv(ctx, m.GetExclusive(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["expected_count"]; exists {

		vOpts := append(opts, db.WithValidateField("expected_count"))
		if err := fv(ctx, m.GetExpectedCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path_suffix_in"]; exists {

		vOpts := append(opts, db.WithValidateField("path_suffix_in"))
		for idx, item := range m.GetPathSuffixIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["prefetch"]; exists {

		vOpts := append(opts, db.WithValidateField("prefetch"))
		if err := fv(ctx, m.GetPrefetch(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["root_object_in"]; exists {

		vOpts := append(opts, db.WithValidateField("root_object_in"))
		for idx, item := range m.GetRootObjectIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["service_slug"]; exists {

		vOpts := append(opts, db.WithValidateField("service_slug"))
		if err := fv(ctx, m.GetServiceSlug(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSuggestedValuesValidator = func() *ValidateSuggestedValues {
	v := &ValidateSuggestedValues{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SuggestedValuesValidator() db.Validator {
	return DefaultSuggestedValuesValidator
}

// augmented methods on protoc/std generated struct

func (m *Tile) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Tile) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Tile) DeepCopy() *Tile {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Tile{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Tile) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Tile) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TileValidator().Validate(ctx, m, opts...)
}

type ValidateTile struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTile) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Tile)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Tile got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["anonymous"]; exists {

		vOpts := append(opts, db.WithValidateField("anonymous"))
		if err := fv(ctx, m.GetAnonymous(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["collapse"]; exists {

		vOpts := append(opts, db.WithValidateField("collapse"))
		if err := fv(ctx, m.GetCollapse(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["fields"]; exists {

		vOpts := append(opts, db.WithValidateField("fields"))
		if err := fv(ctx, m.GetFields(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["help"]; exists {

		vOpts := append(opts, db.WithValidateField("help"))
		if err := fv(ctx, m.GetHelp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inherit_description"]; exists {

		vOpts := append(opts, db.WithValidateField("inherit_description"))
		if err := fv(ctx, m.GetInheritDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["title"]; exists {

		vOpts := append(opts, db.WithValidateField("title"))
		if err := fv(ctx, m.GetTitle(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTileValidator = func() *ValidateTile {
	v := &ValidateTile{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func TileValidator() db.Validator {
	return DefaultTileValidator
}

// augmented methods on protoc/std generated struct

func (m *Tiles) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Tiles) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Tiles) DeepCopy() *Tiles {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Tiles{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Tiles) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Tiles) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TilesValidator().Validate(ctx, m, opts...)
}

type ValidateTiles struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTiles) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Tiles)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Tiles got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["tile_list"]; exists {

		vOpts := append(opts, db.WithValidateField("tile_list"))
		for idx, item := range m.GetTileList() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTilesValidator = func() *ValidateTiles {
	v := &ValidateTiles{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func TilesValidator() db.Validator {
	return DefaultTilesValidator
}
