//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//
package schema

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *ChoiceItem) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ChoiceItem) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ChoiceItem) DeepCopy() *ChoiceItem {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ChoiceItem{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ChoiceItem) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ChoiceItem) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ChoiceItemValidator().Validate(ctx, m, opts...)
}

type ValidateChoiceItem struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateChoiceItem) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ChoiceItem)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ChoiceItem got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultChoiceItemValidator = func() *ValidateChoiceItem {
	v := &ValidateChoiceItem{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ChoiceItemValidator() db.Validator {
	return DefaultChoiceItemValidator
}

// augmented methods on protoc/std generated struct

func (m *ChoiceItemList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ChoiceItemList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ChoiceItemList) DeepCopy() *ChoiceItemList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ChoiceItemList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ChoiceItemList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ChoiceItemList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ChoiceItemListValidator().Validate(ctx, m, opts...)
}

type ValidateChoiceItemList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateChoiceItemList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ChoiceItemList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ChoiceItemList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice_items"]; exists {

		vOpts := append(opts, db.WithValidateField("choice_items"))
		for idx, item := range m.GetChoiceItems() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultChoiceItemListValidator = func() *ValidateChoiceItemList {
	v := &ValidateChoiceItemList{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ChoiceItemListValidator() db.Validator {
	return DefaultChoiceItemListValidator
}

// augmented methods on protoc/std generated struct

func (m *Choices) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Choices) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Choices) DeepCopy() *Choices {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Choices{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Choices) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Choices) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ChoicesValidator().Validate(ctx, m, opts...)
}

type ValidateChoices struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateChoices) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Choices)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Choices got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {

		vOpts := append(opts, db.WithValidateField("choice"))
		for idx, item := range m.GetChoice() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultChoicesValidator = func() *ValidateChoices {
	v := &ValidateChoices{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ChoicesValidator() db.Validator {
	return DefaultChoicesValidator
}

// augmented methods on protoc/std generated struct

func (m *FieldViewOptions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FieldViewOptions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FieldViewOptions) DeepCopy() *FieldViewOptions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FieldViewOptions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FieldViewOptions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FieldViewOptions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FieldViewOptionsValidator().Validate(ctx, m, opts...)
}

type ValidateFieldViewOptions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFieldViewOptions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FieldViewOptions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FieldViewOptions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetType().(type) {
	case *FieldViewOptions_NewForm:
		if fv, exists := v.FldValidators["type.new_form"]; exists {
			val := m.GetType().(*FieldViewOptions_NewForm).NewForm
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("new_form"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldViewOptions_InputBoxSize:
		if fv, exists := v.FldValidators["type.input_box_size"]; exists {
			val := m.GetType().(*FieldViewOptions_InputBoxSize).InputBoxSize
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("input_box_size"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldViewOptions_DefaultValue:
		if fv, exists := v.FldValidators["type.default_value"]; exists {
			val := m.GetType().(*FieldViewOptions_DefaultValue).DefaultValue
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("default_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldViewOptions_CommonChoices:
		if fv, exists := v.FldValidators["type.common_choices"]; exists {
			val := m.GetType().(*FieldViewOptions_CommonChoices).CommonChoices
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("common_choices"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldViewOptions_DisplayName:
		if fv, exists := v.FldValidators["type.display_name"]; exists {
			val := m.GetType().(*FieldViewOptions_DisplayName).DisplayName
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("display_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldViewOptions_Description:
		if fv, exists := v.FldValidators["type.description"]; exists {
			val := m.GetType().(*FieldViewOptions_Description).Description
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("description"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldViewOptions_Map:
		if fv, exists := v.FldValidators["type.map"]; exists {
			val := m.GetType().(*FieldViewOptions_Map).Map
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("map"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldViewOptions_Repeated:
		if fv, exists := v.FldValidators["type.repeated"]; exists {
			val := m.GetType().(*FieldViewOptions_Repeated).Repeated
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("repeated"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldViewOptions_InNamespaceTypes:
		if fv, exists := v.FldValidators["type.in_namespace_types"]; exists {
			val := m.GetType().(*FieldViewOptions_InNamespaceTypes).InNamespaceTypes
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("in_namespace_types"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldViewOptions_InputBoxFormat:
		if fv, exists := v.FldValidators["type.input_box_format"]; exists {
			val := m.GetType().(*FieldViewOptions_InputBoxFormat).InputBoxFormat
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("input_box_format"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFieldViewOptionsValidator = func() *ValidateFieldViewOptions {
	v := &ValidateFieldViewOptions{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FieldViewOptionsValidator() db.Validator {
	return DefaultFieldViewOptionsValidator
}

// augmented methods on protoc/std generated struct

func (m *HiddenConditions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HiddenConditions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HiddenConditions) DeepCopy() *HiddenConditions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HiddenConditions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HiddenConditions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HiddenConditions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HiddenConditionsValidator().Validate(ctx, m, opts...)
}

type ValidateHiddenConditions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHiddenConditions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HiddenConditions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HiddenConditions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ancestor_message_in"]; exists {

		vOpts := append(opts, db.WithValidateField("ancestor_message_in"))
		for idx, item := range m.GetAncestorMessageIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["invert_match"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_match"))
		if err := fv(ctx, m.GetInvertMatch(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path_suffix_in"]; exists {

		vOpts := append(opts, db.WithValidateField("path_suffix_in"))
		for idx, item := range m.GetPathSuffixIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["root_object_in"]; exists {

		vOpts := append(opts, db.WithValidateField("root_object_in"))
		for idx, item := range m.GetRootObjectIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHiddenConditionsValidator = func() *ValidateHiddenConditions {
	v := &ValidateHiddenConditions{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func HiddenConditionsValidator() db.Validator {
	return DefaultHiddenConditionsValidator
}

// augmented methods on protoc/std generated struct

func (m *LabelKeyClassList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LabelKeyClassList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LabelKeyClassList) DeepCopy() *LabelKeyClassList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LabelKeyClassList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LabelKeyClassList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LabelKeyClassList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LabelKeyClassListValidator().Validate(ctx, m, opts...)
}

type ValidateLabelKeyClassList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLabelKeyClassList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LabelKeyClassList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LabelKeyClassList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["key_classes"]; exists {

		vOpts := append(opts, db.WithValidateField("key_classes"))
		for idx, item := range m.GetKeyClasses() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLabelKeyClassListValidator = func() *ValidateLabelKeyClassList {
	v := &ValidateLabelKeyClassList{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LabelKeyClassListValidator() db.Validator {
	return DefaultLabelKeyClassListValidator
}

// augmented methods on protoc/std generated struct

func (m *MapOptions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MapOptions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MapOptions) DeepCopy() *MapOptions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MapOptions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MapOptions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MapOptions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MapOptionsValidator().Validate(ctx, m, opts...)
}

type ValidateMapOptions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMapOptions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MapOptions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MapOptions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["keys"]; exists {

		vOpts := append(opts, db.WithValidateField("keys"))
		if err := fv(ctx, m.GetKeys(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["style"]; exists {

		vOpts := append(opts, db.WithValidateField("style"))
		if err := fv(ctx, m.GetStyle(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["values"]; exists {

		vOpts := append(opts, db.WithValidateField("values"))
		if err := fv(ctx, m.GetValues(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMapOptionsValidator = func() *ValidateMapOptions {
	v := &ValidateMapOptions{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func MapOptionsValidator() db.Validator {
	return DefaultMapOptionsValidator
}

// augmented methods on protoc/std generated struct

func (m *RepeatedOptions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RepeatedOptions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RepeatedOptions) DeepCopy() *RepeatedOptions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RepeatedOptions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RepeatedOptions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RepeatedOptions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RepeatedOptionsValidator().Validate(ctx, m, opts...)
}

type ValidateRepeatedOptions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRepeatedOptions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RepeatedOptions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RepeatedOptions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ordered_list"]; exists {

		vOpts := append(opts, db.WithValidateField("ordered_list"))
		if err := fv(ctx, m.GetOrderedList(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["style"]; exists {

		vOpts := append(opts, db.WithValidateField("style"))
		if err := fv(ctx, m.GetStyle(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRepeatedOptionsValidator = func() *ValidateRepeatedOptions {
	v := &ValidateRepeatedOptions{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func RepeatedOptionsValidator() db.Validator {
	return DefaultRepeatedOptionsValidator
}

// augmented methods on protoc/std generated struct

func (m *Tile) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Tile) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Tile) DeepCopy() *Tile {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Tile{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Tile) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Tile) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TileValidator().Validate(ctx, m, opts...)
}

type ValidateTile struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTile) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Tile)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Tile got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["fields"]; exists {

		vOpts := append(opts, db.WithValidateField("fields"))
		if err := fv(ctx, m.GetFields(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["help"]; exists {

		vOpts := append(opts, db.WithValidateField("help"))
		if err := fv(ctx, m.GetHelp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inherit_description"]; exists {

		vOpts := append(opts, db.WithValidateField("inherit_description"))
		if err := fv(ctx, m.GetInheritDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["title"]; exists {

		vOpts := append(opts, db.WithValidateField("title"))
		if err := fv(ctx, m.GetTitle(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTileValidator = func() *ValidateTile {
	v := &ValidateTile{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func TileValidator() db.Validator {
	return DefaultTileValidator
}

// augmented methods on protoc/std generated struct

func (m *Tiles) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Tiles) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Tiles) DeepCopy() *Tiles {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Tiles{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Tiles) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Tiles) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TilesValidator().Validate(ctx, m, opts...)
}

type ValidateTiles struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTiles) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Tiles)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Tiles got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["tile_list"]; exists {

		vOpts := append(opts, db.WithValidateField("tile_list"))
		for idx, item := range m.GetTileList() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTilesValidator = func() *ValidateTiles {
	v := &ValidateTiles{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func TilesValidator() db.Validator {
	return DefaultTilesValidator
}
