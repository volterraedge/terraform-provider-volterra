//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//

package namespace

import (
	"bytes"
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"

	"github.com/gogo/protobuf/proto"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"google.golang.org/grpc"

	"gopkg.volterra.us/stdlib/client"
	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/errors"
	"gopkg.volterra.us/stdlib/server"
	"gopkg.volterra.us/stdlib/svcfw"
)

var (
	_ = fmt.Sprintf("dummy for fmt import use")
)

// Create NamespaceCustomAPI GRPC Client satisfying server.CustomClient
type NamespaceCustomAPIGrpcClient struct {
	conn       *grpc.ClientConn
	grpcClient NamespaceCustomAPIClient
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error)
}

func (c *NamespaceCustomAPIGrpcClient) doRPCGetActiveNetworkPolicies(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetActiveNetworkPoliciesRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.namespace.GetActiveNetworkPoliciesRequest", yamlReq)
	}
	rsp, err := c.grpcClient.GetActiveNetworkPolicies(ctx, req, opts...)
	return rsp, err
}

func (c *NamespaceCustomAPIGrpcClient) doRPCGetActiveServicePolicies(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetActiveServicePoliciesRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.namespace.GetActiveServicePoliciesRequest", yamlReq)
	}
	rsp, err := c.grpcClient.GetActiveServicePolicies(ctx, req, opts...)
	return rsp, err
}

func (c *NamespaceCustomAPIGrpcClient) doRPCGetFastACLsForInternetVIPs(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetFastACLsForInternetVIPsRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.namespace.GetFastACLsForInternetVIPsRequest", yamlReq)
	}
	rsp, err := c.grpcClient.GetFastACLsForInternetVIPs(ctx, req, opts...)
	return rsp, err
}

func (c *NamespaceCustomAPIGrpcClient) doRPCSetActiveNetworkPolicies(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SetActiveNetworkPoliciesRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.namespace.SetActiveNetworkPoliciesRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SetActiveNetworkPolicies(ctx, req, opts...)
	return rsp, err
}

func (c *NamespaceCustomAPIGrpcClient) doRPCSetActiveServicePolicies(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SetActiveServicePoliciesRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.namespace.SetActiveServicePoliciesRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SetActiveServicePolicies(ctx, req, opts...)
	return rsp, err
}

func (c *NamespaceCustomAPIGrpcClient) doRPCSetFastACLsForInternetVIPs(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SetFastACLsForInternetVIPsRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.namespace.SetFastACLsForInternetVIPsRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SetFastACLsForInternetVIPs(ctx, req, opts...)
	return rsp, err
}

func (c *NamespaceCustomAPIGrpcClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	if cco.YAMLReq == "" {
		return nil, fmt.Errorf("Error, empty request body")
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := rpcFn(ctx, cco.YAMLReq, cco.GrpcCallOpts...)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using GRPC")
	}
	return rsp, nil
}

func NewNamespaceCustomAPIGrpcClient(cc *grpc.ClientConn) server.CustomClient {
	ccl := &NamespaceCustomAPIGrpcClient{
		conn:       cc,
		grpcClient: NewNamespaceCustomAPIClient(cc),
	}
	rpcFns := make(map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error))
	rpcFns["GetActiveNetworkPolicies"] = ccl.doRPCGetActiveNetworkPolicies

	rpcFns["GetActiveServicePolicies"] = ccl.doRPCGetActiveServicePolicies

	rpcFns["GetFastACLsForInternetVIPs"] = ccl.doRPCGetFastACLsForInternetVIPs

	rpcFns["SetActiveNetworkPolicies"] = ccl.doRPCSetActiveNetworkPolicies

	rpcFns["SetActiveServicePolicies"] = ccl.doRPCSetActiveServicePolicies

	rpcFns["SetFastACLsForInternetVIPs"] = ccl.doRPCSetFastACLsForInternetVIPs

	ccl.rpcFns = rpcFns

	return ccl
}

// Create NamespaceCustomAPI REST Client satisfying server.CustomClient
type NamespaceCustomAPIRestClient struct {
	baseURL string
	client  http.Client
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error)
}

func (c *NamespaceCustomAPIRestClient) doRPCGetActiveNetworkPolicies(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetActiveNetworkPoliciesRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.namespace.GetActiveNetworkPoliciesRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		newReq, err := http.NewRequest(http.MethodPost, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP POST request for custom API")
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &GetActiveNetworkPoliciesResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.namespace.GetActiveNetworkPoliciesResponse", body)
	}
	return pbRsp, nil
}

func (c *NamespaceCustomAPIRestClient) doRPCGetActiveServicePolicies(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetActiveServicePoliciesRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.namespace.GetActiveServicePoliciesRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		newReq, err := http.NewRequest(http.MethodPost, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP POST request for custom API")
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &GetActiveServicePoliciesResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.namespace.GetActiveServicePoliciesResponse", body)
	}
	return pbRsp, nil
}

func (c *NamespaceCustomAPIRestClient) doRPCGetFastACLsForInternetVIPs(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetFastACLsForInternetVIPsRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.namespace.GetFastACLsForInternetVIPsRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		newReq, err := http.NewRequest(http.MethodPost, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP POST request for custom API")
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &GetFastACLsForInternetVIPsResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.namespace.GetFastACLsForInternetVIPsResponse", body)
	}
	return pbRsp, nil
}

func (c *NamespaceCustomAPIRestClient) doRPCSetActiveNetworkPolicies(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SetActiveNetworkPoliciesRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.namespace.SetActiveNetworkPoliciesRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		newReq, err := http.NewRequest(http.MethodPost, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP POST request for custom API")
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("network_policies", fmt.Sprintf("%v", req.NetworkPolicies))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &SetActiveNetworkPoliciesResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.namespace.SetActiveNetworkPoliciesResponse", body)
	}
	return pbRsp, nil
}

func (c *NamespaceCustomAPIRestClient) doRPCSetActiveServicePolicies(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SetActiveServicePoliciesRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.namespace.SetActiveServicePoliciesRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		newReq, err := http.NewRequest(http.MethodPost, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP POST request for custom API")
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("service_policies", fmt.Sprintf("%v", req.ServicePolicies))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &SetActiveServicePoliciesResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.namespace.SetActiveServicePoliciesResponse", body)
	}
	return pbRsp, nil
}

func (c *NamespaceCustomAPIRestClient) doRPCSetFastACLsForInternetVIPs(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SetFastACLsForInternetVIPsRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.namespace.SetFastACLsForInternetVIPsRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		newReq, err := http.NewRequest(http.MethodPost, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP POST request for custom API")
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("fast_acls", fmt.Sprintf("%v", req.FastAcls))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &SetFastACLsForInternetVIPsResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.namespace.SetFastACLsForInternetVIPsResponse", body)
	}
	return pbRsp, nil
}

func (c *NamespaceCustomAPIRestClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	rsp, err := rpcFn(ctx, cco)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using Rest")
	}
	return rsp, nil
}

func NewNamespaceCustomAPIRestClient(baseURL string, hc http.Client) server.CustomClient {
	ccl := &NamespaceCustomAPIRestClient{
		baseURL: baseURL,
		client:  hc,
	}

	rpcFns := make(map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error))
	rpcFns["GetActiveNetworkPolicies"] = ccl.doRPCGetActiveNetworkPolicies

	rpcFns["GetActiveServicePolicies"] = ccl.doRPCGetActiveServicePolicies

	rpcFns["GetFastACLsForInternetVIPs"] = ccl.doRPCGetFastACLsForInternetVIPs

	rpcFns["SetActiveNetworkPolicies"] = ccl.doRPCSetActiveNetworkPolicies

	rpcFns["SetActiveServicePolicies"] = ccl.doRPCSetActiveServicePolicies

	rpcFns["SetFastACLsForInternetVIPs"] = ccl.doRPCSetFastACLsForInternetVIPs

	ccl.rpcFns = rpcFns

	return ccl
}

// Create NamespaceCustomAPIInprocClient

// INPROC Client (satisfying NamespaceCustomAPIClient interface)
type NamespaceCustomAPIInprocClient struct {
	svc svcfw.Service
}

func (c *NamespaceCustomAPIInprocClient) GetActiveNetworkPolicies(ctx context.Context, in *GetActiveNetworkPoliciesRequest, opts ...grpc.CallOption) (*GetActiveNetworkPoliciesResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.namespace.NamespaceCustomAPI")
	cah, ok := ah.(NamespaceCustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *NamespaceCustomAPISrv", ah)
	}

	var (
		rsp *GetActiveNetworkPoliciesResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.namespace.GetActiveNetworkPoliciesRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'NamespaceCustomAPI.GetActiveNetworkPolicies' operation on 'namespace'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.namespace.NamespaceCustomAPI.GetActiveNetworkPolicies"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetActiveNetworkPolicies(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.namespace.GetActiveNetworkPoliciesResponse", rsp)...)

	return rsp, nil
}
func (c *NamespaceCustomAPIInprocClient) GetActiveServicePolicies(ctx context.Context, in *GetActiveServicePoliciesRequest, opts ...grpc.CallOption) (*GetActiveServicePoliciesResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.namespace.NamespaceCustomAPI")
	cah, ok := ah.(NamespaceCustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *NamespaceCustomAPISrv", ah)
	}

	var (
		rsp *GetActiveServicePoliciesResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.namespace.GetActiveServicePoliciesRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'NamespaceCustomAPI.GetActiveServicePolicies' operation on 'namespace'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.namespace.NamespaceCustomAPI.GetActiveServicePolicies"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetActiveServicePolicies(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.namespace.GetActiveServicePoliciesResponse", rsp)...)

	return rsp, nil
}
func (c *NamespaceCustomAPIInprocClient) GetFastACLsForInternetVIPs(ctx context.Context, in *GetFastACLsForInternetVIPsRequest, opts ...grpc.CallOption) (*GetFastACLsForInternetVIPsResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.namespace.NamespaceCustomAPI")
	cah, ok := ah.(NamespaceCustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *NamespaceCustomAPISrv", ah)
	}

	var (
		rsp *GetFastACLsForInternetVIPsResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.namespace.GetFastACLsForInternetVIPsRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'NamespaceCustomAPI.GetFastACLsForInternetVIPs' operation on 'namespace'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.namespace.NamespaceCustomAPI.GetFastACLsForInternetVIPs"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetFastACLsForInternetVIPs(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.namespace.GetFastACLsForInternetVIPsResponse", rsp)...)

	return rsp, nil
}
func (c *NamespaceCustomAPIInprocClient) SetActiveNetworkPolicies(ctx context.Context, in *SetActiveNetworkPoliciesRequest, opts ...grpc.CallOption) (*SetActiveNetworkPoliciesResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.namespace.NamespaceCustomAPI")
	cah, ok := ah.(NamespaceCustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *NamespaceCustomAPISrv", ah)
	}

	var (
		rsp *SetActiveNetworkPoliciesResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.namespace.SetActiveNetworkPoliciesRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'NamespaceCustomAPI.SetActiveNetworkPolicies' operation on 'namespace'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.namespace.NamespaceCustomAPI.SetActiveNetworkPolicies"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SetActiveNetworkPolicies(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.namespace.SetActiveNetworkPoliciesResponse", rsp)...)

	return rsp, nil
}
func (c *NamespaceCustomAPIInprocClient) SetActiveServicePolicies(ctx context.Context, in *SetActiveServicePoliciesRequest, opts ...grpc.CallOption) (*SetActiveServicePoliciesResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.namespace.NamespaceCustomAPI")
	cah, ok := ah.(NamespaceCustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *NamespaceCustomAPISrv", ah)
	}

	var (
		rsp *SetActiveServicePoliciesResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.namespace.SetActiveServicePoliciesRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'NamespaceCustomAPI.SetActiveServicePolicies' operation on 'namespace'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.namespace.NamespaceCustomAPI.SetActiveServicePolicies"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SetActiveServicePolicies(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.namespace.SetActiveServicePoliciesResponse", rsp)...)

	return rsp, nil
}
func (c *NamespaceCustomAPIInprocClient) SetFastACLsForInternetVIPs(ctx context.Context, in *SetFastACLsForInternetVIPsRequest, opts ...grpc.CallOption) (*SetFastACLsForInternetVIPsResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.namespace.NamespaceCustomAPI")
	cah, ok := ah.(NamespaceCustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *NamespaceCustomAPISrv", ah)
	}

	var (
		rsp *SetFastACLsForInternetVIPsResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.namespace.SetFastACLsForInternetVIPsRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'NamespaceCustomAPI.SetFastACLsForInternetVIPs' operation on 'namespace'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.namespace.NamespaceCustomAPI.SetFastACLsForInternetVIPs"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SetFastACLsForInternetVIPs(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.namespace.SetFastACLsForInternetVIPsResponse", rsp)...)

	return rsp, nil
}

func NewNamespaceCustomAPIInprocClient(svc svcfw.Service) NamespaceCustomAPIClient {
	return &NamespaceCustomAPIInprocClient{svc: svc}
}

// RegisterGwNamespaceCustomAPIHandler registers with grpc-gw with an inproc-client backing so that
// rest to grpc happens without a grpc.Dial (thus avoiding additional certs for mTLS)
func RegisterGwNamespaceCustomAPIHandler(ctx context.Context, mux *runtime.ServeMux, svc interface{}) error {
	s, ok := svc.(svcfw.Service)
	if !ok {
		return fmt.Errorf("svc is not svcfw.Service")
	}
	return RegisterNamespaceCustomAPIHandlerClient(ctx, mux, NewNamespaceCustomAPIInprocClient(s))
}

var NamespaceCustomAPISwaggerJSON string = `{
    "swagger": "2.0",
    "info": {
        "title": "Namespace API",
        "description": "APIs in this file are custom APIs on namespace object served by akar",
        "version": "version not set"
    },
    "schemes": [
        "http",
        "https"
    ],
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ],
    "tags": null,
    "paths": {
        "/public/namespaces/{namespace}/active_network_policies": {
            "get": {
                "summary": "GetActiveNetworkPolicies",
                "description": "GetActiveNetworkPolicies resturn the list of active network policies for the namespace",
                "operationId": "ves.io.schema.namespace.NamespaceCustomAPI.GetActiveNetworkPolicies",
                "responses": {
                    "200": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/namespaceGetActiveNetworkPoliciesResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    }
                ],
                "tags": [
                    "NamespaceCustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-namespace-NamespaceCustomAPI-GetActiveNetworkPolicies"
                },
                "x-ves-proto-rpc": "ves.io.schema.namespace.NamespaceCustomAPI.GetActiveNetworkPolicies"
            },
            "post": {
                "summary": "SetActiveNetworkPolicies",
                "description": "SetActiveNetworkPolicies sets the active network policies for the namespace\nAn emtpy list in the request will clear the active network policies for the namespace",
                "operationId": "ves.io.schema.namespace.NamespaceCustomAPI.SetActiveNetworkPolicies",
                "responses": {
                    "200": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/namespaceSetActiveNetworkPoliciesResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/namespaceSetActiveNetworkPoliciesRequest"
                        }
                    }
                ],
                "tags": [
                    "NamespaceCustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-namespace-NamespaceCustomAPI-SetActiveNetworkPolicies"
                },
                "x-ves-proto-rpc": "ves.io.schema.namespace.NamespaceCustomAPI.SetActiveNetworkPolicies"
            },
            "x-displayname": "NamespaceCustomAPI",
            "x-ves-proto-service": "ves.io.schema.namespace.NamespaceCustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/active_service_policies": {
            "get": {
                "summary": "GetActiveServicePolicies",
                "description": "GetActiveServicePolicies resturn the list of active service policies for the namespace",
                "operationId": "ves.io.schema.namespace.NamespaceCustomAPI.GetActiveServicePolicies",
                "responses": {
                    "200": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/namespaceGetActiveServicePoliciesResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    }
                ],
                "tags": [
                    "NamespaceCustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-namespace-NamespaceCustomAPI-GetActiveServicePolicies"
                },
                "x-ves-proto-rpc": "ves.io.schema.namespace.NamespaceCustomAPI.GetActiveServicePolicies"
            },
            "post": {
                "summary": "SetActiveServicePolicies",
                "description": "SetActiveServicePolicies sets the active service policies for the namespace\nAn emtpy list in the request will clear the active service policies for the namespace",
                "operationId": "ves.io.schema.namespace.NamespaceCustomAPI.SetActiveServicePolicies",
                "responses": {
                    "200": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/namespaceSetActiveServicePoliciesResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/namespaceSetActiveServicePoliciesRequest"
                        }
                    }
                ],
                "tags": [
                    "NamespaceCustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-namespace-NamespaceCustomAPI-SetActiveServicePolicies"
                },
                "x-ves-proto-rpc": "ves.io.schema.namespace.NamespaceCustomAPI.SetActiveServicePolicies"
            },
            "x-displayname": "NamespaceCustomAPI",
            "x-ves-proto-service": "ves.io.schema.namespace.NamespaceCustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/fast_acls_for_internet_vips": {
            "get": {
                "summary": "GetFastACLsForInternetVIPs",
                "description": "GetFastACLsForInternetVIPs Returns the list of Active FastACLs for Internet VIPs.",
                "operationId": "ves.io.schema.namespace.NamespaceCustomAPI.GetFastACLsForInternetVIPs",
                "responses": {
                    "200": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/namespaceGetFastACLsForInternetVIPsResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    }
                ],
                "tags": [
                    "NamespaceCustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-namespace-NamespaceCustomAPI-GetFastACLsForInternetVIPs"
                },
                "x-ves-proto-rpc": "ves.io.schema.namespace.NamespaceCustomAPI.GetFastACLsForInternetVIPs"
            },
            "post": {
                "summary": "SetFastACLsForInternetVIPs",
                "description": "SetFastACLsForInternetVIPs activates the passed list of FastACLs for Internet VIPs.\nAn emtpy list in the request will clear FastACLs for Internet VIPs.",
                "operationId": "ves.io.schema.namespace.NamespaceCustomAPI.SetFastACLsForInternetVIPs",
                "responses": {
                    "200": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/namespaceSetFastACLsForInternetVIPsResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/namespaceSetFastACLsForInternetVIPsRequest"
                        }
                    }
                ],
                "tags": [
                    "NamespaceCustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-namespace-NamespaceCustomAPI-SetFastACLsForInternetVIPs"
                },
                "x-ves-proto-rpc": "ves.io.schema.namespace.NamespaceCustomAPI.SetFastACLsForInternetVIPs"
            },
            "x-displayname": "NamespaceCustomAPI",
            "x-ves-proto-service": "ves.io.schema.namespace.NamespaceCustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        }
    },
    "definitions": {
        "namespaceGetActiveNetworkPoliciesResponse": {
            "type": "object",
            "description": "GetActiveNetworkPoliciesResponse is the shape of the response for GetActiveNetworkPolicies.",
            "title": "GetActiveNetworkPoliciesResponse",
            "x-displayname": "Response for GetActiveNetworkPolicies",
            "x-ves-proto-message": "ves.io.schema.namespace.GetActiveNetworkPoliciesResponse",
            "properties": {
                "network_policies": {
                    "type": "array",
                    "description": " A list of references to network_policy objects.",
                    "title": "network_policies",
                    "items": {
                        "$ref": "#/definitions/schemaviewsObjectRefType"
                    },
                    "x-displayname": "Network Policies"
                }
            }
        },
        "namespaceGetActiveServicePoliciesResponse": {
            "type": "object",
            "description": "GetActiveServicePoliciesResponse is the shape of the response for GetActiveServicePolicies.",
            "title": "GetActiveServicePoliciesResponse",
            "x-displayname": "Response for GetActiveServicePolicies",
            "x-ves-proto-message": "ves.io.schema.namespace.GetActiveServicePoliciesResponse",
            "properties": {
                "service_policies": {
                    "type": "array",
                    "description": " A list of references to service_policy objects.",
                    "title": "service_policies",
                    "items": {
                        "$ref": "#/definitions/schemaviewsObjectRefType"
                    },
                    "x-displayname": "Service Policies"
                }
            }
        },
        "namespaceGetFastACLsForInternetVIPsResponse": {
            "type": "object",
            "description": "GetFastACLsForInternetVIPsResponse contains list of FastACLs refs that\nare applied to the Internet VIPs",
            "title": "GetFastACLsForInternetVIPsResponse",
            "x-displayname": "Response for GetFastACLsForInternetVIPs",
            "x-ves-proto-message": "ves.io.schema.namespace.GetFastACLsForInternetVIPsResponse",
            "properties": {
                "fast_acls": {
                    "type": "array",
                    "description": " The list of refs of FastACLs\n\nExample: - \"list of refs\"-",
                    "title": "fast_acls",
                    "items": {
                        "$ref": "#/definitions/schemaviewsObjectRefType"
                    },
                    "x-displayname": "FastACLs",
                    "x-ves-example": "list of refs"
                }
            }
        },
        "namespaceSetActiveNetworkPoliciesRequest": {
            "type": "object",
            "description": "SetActiveNetworkPoliciesRequest is the shape of the request for SetActiveNetworkPolicies.",
            "title": "SetActiveNetworkPoliciesRequest",
            "x-displayname": "Request for SetActiveNetworkPolicies",
            "x-ves-proto-message": "ves.io.schema.namespace.SetActiveNetworkPoliciesRequest",
            "properties": {
                "namespace": {
                    "type": "string",
                    "description": " The name of the namespace\n\nExample: - \"ns1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1"
                },
                "network_policies": {
                    "type": "array",
                    "description": " A list of references to network_policy objects.",
                    "title": "network_policies",
                    "items": {
                        "$ref": "#/definitions/schemaviewsObjectRefType"
                    },
                    "x-displayname": "Network Policies"
                }
            }
        },
        "namespaceSetActiveNetworkPoliciesResponse": {
            "type": "object",
            "description": "SetActiveNetworkPoliciesResponse is the shape of the response for SetActiveNetworkPolicies.",
            "title": "SetActiveNetworkPoliciesResponse",
            "x-displayname": "Response for SetActiveNetworkPolicies",
            "x-ves-proto-message": "ves.io.schema.namespace.SetActiveNetworkPoliciesResponse"
        },
        "namespaceSetActiveServicePoliciesRequest": {
            "type": "object",
            "description": "SetActiveServicePoliciesRequest is the shape of the request for SetActiveServicePolicies.",
            "title": "SetActiveServicePoliciesRequest",
            "x-displayname": "Request for SetActiveServicePolicies",
            "x-ves-proto-message": "ves.io.schema.namespace.SetActiveServicePoliciesRequest",
            "properties": {
                "namespace": {
                    "type": "string",
                    "description": " The name of the namespace\n\nExample: - \"ns1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1"
                },
                "service_policies": {
                    "type": "array",
                    "description": " A list of references to service_policy objects.",
                    "title": "service_policies",
                    "items": {
                        "$ref": "#/definitions/schemaviewsObjectRefType"
                    },
                    "x-displayname": "Service Policies"
                }
            }
        },
        "namespaceSetActiveServicePoliciesResponse": {
            "type": "object",
            "description": "SetActiveServicePoliciesResponse is the shape of the response for SetActiveServicePolicies.",
            "title": "SetActiveServicePoliciesResponse",
            "x-displayname": "Response for SetActiveServicePolicies",
            "x-ves-proto-message": "ves.io.schema.namespace.SetActiveServicePoliciesResponse"
        },
        "namespaceSetFastACLsForInternetVIPsRequest": {
            "type": "object",
            "description": "SetFastACLsForInternetVIPsRequest contains list of FastACLs refs that\nshould be applied to the Internet VIPs",
            "title": "SetFastACLsForInternetVIPsRequest",
            "x-displayname": "Request for SetFastACLsForInternetVIP",
            "x-ves-proto-message": "ves.io.schema.namespace.SetFastACLsForInternetVIPsRequest",
            "properties": {
                "fast_acls": {
                    "type": "array",
                    "description": " The list of refs of FastACLs\n\nExample: - \"list of refs\"-",
                    "title": "fast_acls",
                    "items": {
                        "$ref": "#/definitions/schemaviewsObjectRefType"
                    },
                    "x-displayname": "FastACLs",
                    "x-ves-example": "list of refs"
                },
                "namespace": {
                    "type": "string",
                    "description": " The name of the namespace\n\nExample: - \"ns1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1"
                }
            }
        },
        "namespaceSetFastACLsForInternetVIPsResponse": {
            "type": "object",
            "description": "SetFastACLsForInternetVIPsResponse is empty",
            "title": "SetFastACLsForInternetVIPsResponse",
            "x-displayname": "Response for SetFastACLsForInternetVIPs",
            "x-ves-proto-message": "ves.io.schema.namespace.SetFastACLsForInternetVIPsResponse"
        },
        "schemaviewsObjectRefType": {
            "type": "object",
            "description": "This type establishes a direct reference from one object(the referrer) to another(the referred). \nSuch a reference is in form of tenant/namespace/name",
            "title": "ObjectRefType",
            "x-displayname": "Object reference",
            "x-ves-proto-message": "ves.io.schema.views.ObjectRefType",
            "properties": {
                "name": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then name will hold the referred object's(e.g. route's) name.\n\nExample: - \"contacts-route\"-\nRequired: YES",
                    "title": "name",
                    "x-displayname": "Name",
                    "x-ves-example": "contacts-route",
                    "x-ves-required": "true"
                },
                "namespace": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then namespace will hold the referred object's(e.g. route's) namespace.\n\nExample: - \"ns1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1"
                },
                "tenant": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then tenant will hold the referred object's(e.g. route's) tenant.\n\nExample: - \"acmecorp\"-",
                    "title": "tenant",
                    "x-displayname": "Tenant",
                    "x-ves-example": "acmecorp"
                }
            }
        }
    },
    "x-displayname": "Namespace",
    "x-ves-proto-file": "ves.io/schema/namespace/public_customapi_akar.proto"
}`
