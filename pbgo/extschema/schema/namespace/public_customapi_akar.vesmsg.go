// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package namespace

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_alert_policy_set "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/alert_policy_set"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *ApplicationInventoryRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ApplicationInventoryRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ApplicationInventoryRequest) DeepCopy() *ApplicationInventoryRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ApplicationInventoryRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ApplicationInventoryRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ApplicationInventoryRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ApplicationInventoryRequestValidator().Validate(ctx, m, opts...)
}

type ValidateApplicationInventoryRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateApplicationInventoryRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ApplicationInventoryRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ApplicationInventoryRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["http_load_balancer_filter"]; exists {

		vOpts := append(opts, db.WithValidateField("http_load_balancer_filter"))
		if err := fv(ctx, m.GetHttpLoadBalancerFilter(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tcp_load_balancer_filter"]; exists {

		vOpts := append(opts, db.WithValidateField("tcp_load_balancer_filter"))
		if err := fv(ctx, m.GetTcpLoadBalancerFilter(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultApplicationInventoryRequestValidator = func() *ValidateApplicationInventoryRequest {
	v := &ValidateApplicationInventoryRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ApplicationInventoryRequestValidator() db.Validator {
	return DefaultApplicationInventoryRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ApplicationInventoryResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ApplicationInventoryResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ApplicationInventoryResponse) DeepCopy() *ApplicationInventoryResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ApplicationInventoryResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ApplicationInventoryResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ApplicationInventoryResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ApplicationInventoryResponseValidator().Validate(ctx, m, opts...)
}

type ValidateApplicationInventoryResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateApplicationInventoryResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ApplicationInventoryResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ApplicationInventoryResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["http_loadbalancers"]; exists {

		vOpts := append(opts, db.WithValidateField("http_loadbalancers"))
		if err := fv(ctx, m.GetHttpLoadbalancers(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["loadbalancers"]; exists {

		vOpts := append(opts, db.WithValidateField("loadbalancers"))
		if err := fv(ctx, m.GetLoadbalancers(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["origin_pools"]; exists {

		vOpts := append(opts, db.WithValidateField("origin_pools"))
		if err := fv(ctx, m.GetOriginPools(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["services_discovered"]; exists {

		vOpts := append(opts, db.WithValidateField("services_discovered"))
		if err := fv(ctx, m.GetServicesDiscovered(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tcp_loadbalancers"]; exists {

		vOpts := append(opts, db.WithValidateField("tcp_loadbalancers"))
		if err := fv(ctx, m.GetTcpLoadbalancers(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultApplicationInventoryResponseValidator = func() *ValidateApplicationInventoryResponse {
	v := &ValidateApplicationInventoryResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ApplicationInventoryResponseValidator() db.Validator {
	return DefaultApplicationInventoryResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *GetActiveAlertPoliciesRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetActiveAlertPoliciesRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetActiveAlertPoliciesRequest) DeepCopy() *GetActiveAlertPoliciesRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetActiveAlertPoliciesRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetActiveAlertPoliciesRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetActiveAlertPoliciesRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetActiveAlertPoliciesRequestValidator().Validate(ctx, m, opts...)
}

type ValidateGetActiveAlertPoliciesRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetActiveAlertPoliciesRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetActiveAlertPoliciesRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetActiveAlertPoliciesRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetActiveAlertPoliciesRequestValidator = func() *ValidateGetActiveAlertPoliciesRequest {
	v := &ValidateGetActiveAlertPoliciesRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetActiveAlertPoliciesRequestValidator() db.Validator {
	return DefaultGetActiveAlertPoliciesRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *GetActiveAlertPoliciesResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetActiveAlertPoliciesResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetActiveAlertPoliciesResponse) DeepCopy() *GetActiveAlertPoliciesResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetActiveAlertPoliciesResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetActiveAlertPoliciesResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetActiveAlertPoliciesResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetActiveAlertPoliciesResponseValidator().Validate(ctx, m, opts...)
}

func (m *GetActiveAlertPoliciesResponse) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAlertPoliciesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAlertPoliciesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetAlertPoliciesStatusDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAlertPoliciesStatusDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *GetActiveAlertPoliciesResponse) GetAlertPoliciesDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetAlertPolicies()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("GetActiveAlertPoliciesResponse.alert_policies[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("alert_policy.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "alert_policy.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "alert_policies",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetAlertPoliciesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetActiveAlertPoliciesResponse) GetAlertPoliciesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "alert_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: alert_policy")
	}
	for i, vref := range m.GetAlertPolicies() {
		if vref == nil {
			return nil, fmt.Errorf("GetActiveAlertPoliciesResponse.alert_policies[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "alert_policy.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GetActiveAlertPoliciesResponse) GetAlertPoliciesStatusDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAlertPoliciesStatus() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetAlertPoliciesStatus() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAlertPoliciesStatus() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("alert_policies_status[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateGetActiveAlertPoliciesResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetActiveAlertPoliciesResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetActiveAlertPoliciesResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetActiveAlertPoliciesResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["alert_policies"]; exists {

		vOpts := append(opts, db.WithValidateField("alert_policies"))
		for idx, item := range m.GetAlertPolicies() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["alert_policies_status"]; exists {

		vOpts := append(opts, db.WithValidateField("alert_policies_status"))
		for idx, item := range m.GetAlertPoliciesStatus() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetActiveAlertPoliciesResponseValidator = func() *ValidateGetActiveAlertPoliciesResponse {
	v := &ValidateGetActiveAlertPoliciesResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["alert_policies"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["alert_policies_status"] = ves_io_schema_alert_policy_set.AlertPolicyStatusValidator().Validate

	return v
}()

func GetActiveAlertPoliciesResponseValidator() db.Validator {
	return DefaultGetActiveAlertPoliciesResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *GetActiveNetworkPoliciesRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetActiveNetworkPoliciesRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetActiveNetworkPoliciesRequest) DeepCopy() *GetActiveNetworkPoliciesRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetActiveNetworkPoliciesRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetActiveNetworkPoliciesRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetActiveNetworkPoliciesRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetActiveNetworkPoliciesRequestValidator().Validate(ctx, m, opts...)
}

type ValidateGetActiveNetworkPoliciesRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetActiveNetworkPoliciesRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetActiveNetworkPoliciesRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetActiveNetworkPoliciesRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetActiveNetworkPoliciesRequestValidator = func() *ValidateGetActiveNetworkPoliciesRequest {
	v := &ValidateGetActiveNetworkPoliciesRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetActiveNetworkPoliciesRequestValidator() db.Validator {
	return DefaultGetActiveNetworkPoliciesRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *GetActiveNetworkPoliciesResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetActiveNetworkPoliciesResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetActiveNetworkPoliciesResponse) DeepCopy() *GetActiveNetworkPoliciesResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetActiveNetworkPoliciesResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetActiveNetworkPoliciesResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetActiveNetworkPoliciesResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetActiveNetworkPoliciesResponseValidator().Validate(ctx, m, opts...)
}

func (m *GetActiveNetworkPoliciesResponse) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetNetworkPoliciesDRefInfo()

}

func (m *GetActiveNetworkPoliciesResponse) GetNetworkPoliciesDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetNetworkPolicies()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("GetActiveNetworkPoliciesResponse.network_policies[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("network_policy.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "network_policy.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "network_policies",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetNetworkPoliciesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetActiveNetworkPoliciesResponse) GetNetworkPoliciesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "network_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: network_policy")
	}
	for i, vref := range m.GetNetworkPolicies() {
		if vref == nil {
			return nil, fmt.Errorf("GetActiveNetworkPoliciesResponse.network_policies[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "network_policy.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateGetActiveNetworkPoliciesResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetActiveNetworkPoliciesResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetActiveNetworkPoliciesResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetActiveNetworkPoliciesResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["network_policies"]; exists {

		vOpts := append(opts, db.WithValidateField("network_policies"))
		for idx, item := range m.GetNetworkPolicies() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetActiveNetworkPoliciesResponseValidator = func() *ValidateGetActiveNetworkPoliciesResponse {
	v := &ValidateGetActiveNetworkPoliciesResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["network_policies"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func GetActiveNetworkPoliciesResponseValidator() db.Validator {
	return DefaultGetActiveNetworkPoliciesResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *GetActiveServicePoliciesRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetActiveServicePoliciesRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetActiveServicePoliciesRequest) DeepCopy() *GetActiveServicePoliciesRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetActiveServicePoliciesRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetActiveServicePoliciesRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetActiveServicePoliciesRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetActiveServicePoliciesRequestValidator().Validate(ctx, m, opts...)
}

type ValidateGetActiveServicePoliciesRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetActiveServicePoliciesRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetActiveServicePoliciesRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetActiveServicePoliciesRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetActiveServicePoliciesRequestValidator = func() *ValidateGetActiveServicePoliciesRequest {
	v := &ValidateGetActiveServicePoliciesRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetActiveServicePoliciesRequestValidator() db.Validator {
	return DefaultGetActiveServicePoliciesRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *GetActiveServicePoliciesResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetActiveServicePoliciesResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetActiveServicePoliciesResponse) DeepCopy() *GetActiveServicePoliciesResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetActiveServicePoliciesResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetActiveServicePoliciesResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetActiveServicePoliciesResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetActiveServicePoliciesResponseValidator().Validate(ctx, m, opts...)
}

func (m *GetActiveServicePoliciesResponse) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetServicePoliciesDRefInfo()

}

func (m *GetActiveServicePoliciesResponse) GetServicePoliciesDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetServicePolicies()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("GetActiveServicePoliciesResponse.service_policies[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("service_policy.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "service_policy.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "service_policies",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetServicePoliciesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetActiveServicePoliciesResponse) GetServicePoliciesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "service_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: service_policy")
	}
	for i, vref := range m.GetServicePolicies() {
		if vref == nil {
			return nil, fmt.Errorf("GetActiveServicePoliciesResponse.service_policies[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "service_policy.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateGetActiveServicePoliciesResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetActiveServicePoliciesResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetActiveServicePoliciesResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetActiveServicePoliciesResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["service_policies"]; exists {

		vOpts := append(opts, db.WithValidateField("service_policies"))
		for idx, item := range m.GetServicePolicies() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetActiveServicePoliciesResponseValidator = func() *ValidateGetActiveServicePoliciesResponse {
	v := &ValidateGetActiveServicePoliciesResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["service_policies"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func GetActiveServicePoliciesResponseValidator() db.Validator {
	return DefaultGetActiveServicePoliciesResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *GetFastACLsForInternetVIPsRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetFastACLsForInternetVIPsRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetFastACLsForInternetVIPsRequest) DeepCopy() *GetFastACLsForInternetVIPsRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetFastACLsForInternetVIPsRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetFastACLsForInternetVIPsRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetFastACLsForInternetVIPsRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetFastACLsForInternetVIPsRequestValidator().Validate(ctx, m, opts...)
}

type ValidateGetFastACLsForInternetVIPsRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetFastACLsForInternetVIPsRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetFastACLsForInternetVIPsRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetFastACLsForInternetVIPsRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetFastACLsForInternetVIPsRequestValidator = func() *ValidateGetFastACLsForInternetVIPsRequest {
	v := &ValidateGetFastACLsForInternetVIPsRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetFastACLsForInternetVIPsRequestValidator() db.Validator {
	return DefaultGetFastACLsForInternetVIPsRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *GetFastACLsForInternetVIPsResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetFastACLsForInternetVIPsResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetFastACLsForInternetVIPsResponse) DeepCopy() *GetFastACLsForInternetVIPsResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetFastACLsForInternetVIPsResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetFastACLsForInternetVIPsResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetFastACLsForInternetVIPsResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetFastACLsForInternetVIPsResponseValidator().Validate(ctx, m, opts...)
}

func (m *GetFastACLsForInternetVIPsResponse) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetFastAclsDRefInfo()

}

func (m *GetFastACLsForInternetVIPsResponse) GetFastAclsDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetFastAcls()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("GetFastACLsForInternetVIPsResponse.fast_acls[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("fast_acl.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "fast_acl.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "fast_acls",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetFastAclsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetFastACLsForInternetVIPsResponse) GetFastAclsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "fast_acl.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: fast_acl")
	}
	for i, vref := range m.GetFastAcls() {
		if vref == nil {
			return nil, fmt.Errorf("GetFastACLsForInternetVIPsResponse.fast_acls[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "fast_acl.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateGetFastACLsForInternetVIPsResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetFastACLsForInternetVIPsResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetFastACLsForInternetVIPsResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetFastACLsForInternetVIPsResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["fast_acls"]; exists {

		vOpts := append(opts, db.WithValidateField("fast_acls"))
		for idx, item := range m.GetFastAcls() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetFastACLsForInternetVIPsResponseValidator = func() *ValidateGetFastACLsForInternetVIPsResponse {
	v := &ValidateGetFastACLsForInternetVIPsResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["fast_acls"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func GetFastACLsForInternetVIPsResponseValidator() db.Validator {
	return DefaultGetFastACLsForInternetVIPsResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *HTTPLoadbalancerInventoryFilterType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HTTPLoadbalancerInventoryFilterType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HTTPLoadbalancerInventoryFilterType) DeepCopy() *HTTPLoadbalancerInventoryFilterType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HTTPLoadbalancerInventoryFilterType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HTTPLoadbalancerInventoryFilterType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HTTPLoadbalancerInventoryFilterType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HTTPLoadbalancerInventoryFilterTypeValidator().Validate(ctx, m, opts...)
}

type ValidateHTTPLoadbalancerInventoryFilterType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHTTPLoadbalancerInventoryFilterType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HTTPLoadbalancerInventoryFilterType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HTTPLoadbalancerInventoryFilterType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_protection"]; exists {

		vOpts := append(opts, db.WithValidateField("api_protection"))
		if err := fv(ctx, m.GetApiProtection(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bot_protection"]; exists {

		vOpts := append(opts, db.WithValidateField("bot_protection"))
		if err := fv(ctx, m.GetBotProtection(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["client_side_defense"]; exists {

		vOpts := append(opts, db.WithValidateField("client_side_defense"))
		if err := fv(ctx, m.GetClientSideDefense(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ddos_protection"]; exists {

		vOpts := append(opts, db.WithValidateField("ddos_protection"))
		if err := fv(ctx, m.GetDdosProtection(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["http_only"]; exists {

		vOpts := append(opts, db.WithValidateField("http_only"))
		if err := fv(ctx, m.GetHttpOnly(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip_reputation"]; exists {

		vOpts := append(opts, db.WithValidateField("ip_reputation"))
		if err := fv(ctx, m.GetIpReputation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["malicious_user_detection"]; exists {

		vOpts := append(opts, db.WithValidateField("malicious_user_detection"))
		if err := fv(ctx, m.GetMaliciousUserDetection(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace_service_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace_service_policy"))
		if err := fv(ctx, m.GetNamespaceServicePolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["private_advertisement"]; exists {

		vOpts := append(opts, db.WithValidateField("private_advertisement"))
		if err := fv(ctx, m.GetPrivateAdvertisement(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["public_advertisment"]; exists {

		vOpts := append(opts, db.WithValidateField("public_advertisment"))
		if err := fv(ctx, m.GetPublicAdvertisment(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("service_policy"))
		if err := fv(ctx, m.GetServicePolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["waf"]; exists {

		vOpts := append(opts, db.WithValidateField("waf"))
		if err := fv(ctx, m.GetWaf(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHTTPLoadbalancerInventoryFilterTypeValidator = func() *ValidateHTTPLoadbalancerInventoryFilterType {
	v := &ValidateHTTPLoadbalancerInventoryFilterType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func HTTPLoadbalancerInventoryFilterTypeValidator() db.Validator {
	return DefaultHTTPLoadbalancerInventoryFilterTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *HTTPLoadbalancerInventoryType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HTTPLoadbalancerInventoryType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HTTPLoadbalancerInventoryType) DeepCopy() *HTTPLoadbalancerInventoryType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HTTPLoadbalancerInventoryType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HTTPLoadbalancerInventoryType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HTTPLoadbalancerInventoryType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HTTPLoadbalancerInventoryTypeValidator().Validate(ctx, m, opts...)
}

type ValidateHTTPLoadbalancerInventoryType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHTTPLoadbalancerInventoryType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HTTPLoadbalancerInventoryType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HTTPLoadbalancerInventoryType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_protection"]; exists {

		vOpts := append(opts, db.WithValidateField("api_protection"))
		if err := fv(ctx, m.GetApiProtection(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bot_protection"]; exists {

		vOpts := append(opts, db.WithValidateField("bot_protection"))
		if err := fv(ctx, m.GetBotProtection(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["client_side_defense"]; exists {

		vOpts := append(opts, db.WithValidateField("client_side_defense"))
		if err := fv(ctx, m.GetClientSideDefense(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ddos_protection"]; exists {

		vOpts := append(opts, db.WithValidateField("ddos_protection"))
		if err := fv(ctx, m.GetDdosProtection(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["http_only"]; exists {

		vOpts := append(opts, db.WithValidateField("http_only"))
		if err := fv(ctx, m.GetHttpOnly(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["httplb_results"]; exists {

		vOpts := append(opts, db.WithValidateField("httplb_results"))
		for idx, item := range m.GetHttplbResults() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["ip_reputation"]; exists {

		vOpts := append(opts, db.WithValidateField("ip_reputation"))
		if err := fv(ctx, m.GetIpReputation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["malicious_user_detection"]; exists {

		vOpts := append(opts, db.WithValidateField("malicious_user_detection"))
		if err := fv(ctx, m.GetMaliciousUserDetection(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace_service_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace_service_policy"))
		if err := fv(ctx, m.GetNamespaceServicePolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["private_advertisement"]; exists {

		vOpts := append(opts, db.WithValidateField("private_advertisement"))
		if err := fv(ctx, m.GetPrivateAdvertisement(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["public_advertisment"]; exists {

		vOpts := append(opts, db.WithValidateField("public_advertisment"))
		if err := fv(ctx, m.GetPublicAdvertisment(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("service_policy"))
		if err := fv(ctx, m.GetServicePolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["waf"]; exists {

		vOpts := append(opts, db.WithValidateField("waf"))
		if err := fv(ctx, m.GetWaf(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHTTPLoadbalancerInventoryTypeValidator = func() *ValidateHTTPLoadbalancerInventoryType {
	v := &ValidateHTTPLoadbalancerInventoryType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func HTTPLoadbalancerInventoryTypeValidator() db.Validator {
	return DefaultHTTPLoadbalancerInventoryTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *HTTPLoadbalancerResultType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HTTPLoadbalancerResultType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HTTPLoadbalancerResultType) DeepCopy() *HTTPLoadbalancerResultType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HTTPLoadbalancerResultType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HTTPLoadbalancerResultType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HTTPLoadbalancerResultType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HTTPLoadbalancerResultTypeValidator().Validate(ctx, m, opts...)
}

type ValidateHTTPLoadbalancerResultType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHTTPLoadbalancerResultType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HTTPLoadbalancerResultType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HTTPLoadbalancerResultType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_protection_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("api_protection_enabled"))
		if err := fv(ctx, m.GetApiProtectionEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bot_protection_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("bot_protection_enabled"))
		if err := fv(ctx, m.GetBotProtectionEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["client_side_defense_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("client_side_defense_enabled"))
		if err := fv(ctx, m.GetClientSideDefenseEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ddos_protection_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("ddos_protection_enabled"))
		if err := fv(ctx, m.GetDdosProtectionEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["http_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("http_enabled"))
		if err := fv(ctx, m.GetHttpEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip_reputation_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("ip_reputation_enabled"))
		if err := fv(ctx, m.GetIpReputationEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["malicious_user_detection_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("malicious_user_detection_enabled"))
		if err := fv(ctx, m.GetMaliciousUserDetectionEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace_service_policy_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace_service_policy_enabled"))
		if err := fv(ctx, m.GetNamespaceServicePolicyEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["private_advertisement_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("private_advertisement_enabled"))
		if err := fv(ctx, m.GetPrivateAdvertisementEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["public_advertisment_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("public_advertisment_enabled"))
		if err := fv(ctx, m.GetPublicAdvertismentEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rate_limit"]; exists {

		vOpts := append(opts, db.WithValidateField("rate_limit"))
		if err := fv(ctx, m.GetRateLimit(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_policy_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("service_policy_enabled"))
		if err := fv(ctx, m.GetServicePolicyEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["waf_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("waf_enabled"))
		if err := fv(ctx, m.GetWafEnabled(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHTTPLoadbalancerResultTypeValidator = func() *ValidateHTTPLoadbalancerResultType {
	v := &ValidateHTTPLoadbalancerResultType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func HTTPLoadbalancerResultTypeValidator() db.Validator {
	return DefaultHTTPLoadbalancerResultTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *NetworkingInventoryRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NetworkingInventoryRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NetworkingInventoryRequest) DeepCopy() *NetworkingInventoryRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NetworkingInventoryRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NetworkingInventoryRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NetworkingInventoryRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NetworkingInventoryRequestValidator().Validate(ctx, m, opts...)
}

type ValidateNetworkingInventoryRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNetworkingInventoryRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NetworkingInventoryRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NetworkingInventoryRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNetworkingInventoryRequestValidator = func() *ValidateNetworkingInventoryRequest {
	v := &ValidateNetworkingInventoryRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func NetworkingInventoryRequestValidator() db.Validator {
	return DefaultNetworkingInventoryRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *NetworkingInventoryResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NetworkingInventoryResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NetworkingInventoryResponse) DeepCopy() *NetworkingInventoryResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NetworkingInventoryResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NetworkingInventoryResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NetworkingInventoryResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NetworkingInventoryResponseValidator().Validate(ctx, m, opts...)
}

type ValidateNetworkingInventoryResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNetworkingInventoryResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NetworkingInventoryResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NetworkingInventoryResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["dc_cluster_groups"]; exists {

		vOpts := append(opts, db.WithValidateField("dc_cluster_groups"))
		if err := fv(ctx, m.GetDcClusterGroups(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["global_networks"]; exists {

		vOpts := append(opts, db.WithValidateField("global_networks"))
		if err := fv(ctx, m.GetGlobalNetworks(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_mesh_groups"]; exists {

		vOpts := append(opts, db.WithValidateField("site_mesh_groups"))
		if err := fv(ctx, m.GetSiteMeshGroups(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sites"]; exists {

		vOpts := append(opts, db.WithValidateField("sites"))
		if err := fv(ctx, m.GetSites(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNetworkingInventoryResponseValidator = func() *ValidateNetworkingInventoryResponse {
	v := &ValidateNetworkingInventoryResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func NetworkingInventoryResponseValidator() db.Validator {
	return DefaultNetworkingInventoryResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *SetActiveAlertPoliciesRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SetActiveAlertPoliciesRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SetActiveAlertPoliciesRequest) DeepCopy() *SetActiveAlertPoliciesRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SetActiveAlertPoliciesRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SetActiveAlertPoliciesRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SetActiveAlertPoliciesRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SetActiveAlertPoliciesRequestValidator().Validate(ctx, m, opts...)
}

func (m *SetActiveAlertPoliciesRequest) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetAlertPoliciesDRefInfo()

}

func (m *SetActiveAlertPoliciesRequest) GetAlertPoliciesDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetAlertPolicies()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("SetActiveAlertPoliciesRequest.alert_policies[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("alert_policy.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "alert_policy.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "alert_policies",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetAlertPoliciesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *SetActiveAlertPoliciesRequest) GetAlertPoliciesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "alert_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: alert_policy")
	}
	for i, vref := range m.GetAlertPolicies() {
		if vref == nil {
			return nil, fmt.Errorf("SetActiveAlertPoliciesRequest.alert_policies[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "alert_policy.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateSetActiveAlertPoliciesRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSetActiveAlertPoliciesRequest) AlertPoliciesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for alert_policies")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for alert_policies")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated alert_policies")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items alert_policies")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSetActiveAlertPoliciesRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SetActiveAlertPoliciesRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SetActiveAlertPoliciesRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["alert_policies"]; exists {
		vOpts := append(opts, db.WithValidateField("alert_policies"))
		if err := fv(ctx, m.GetAlertPolicies(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSetActiveAlertPoliciesRequestValidator = func() *ValidateSetActiveAlertPoliciesRequest {
	v := &ValidateSetActiveAlertPoliciesRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAlertPolicies := v.AlertPoliciesValidationRuleHandler
	rulesAlertPolicies := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
	}
	vFn, err = vrhAlertPolicies(rulesAlertPolicies)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SetActiveAlertPoliciesRequest.alert_policies: %s", err)
		panic(errMsg)
	}
	v.FldValidators["alert_policies"] = vFn

	return v
}()

func SetActiveAlertPoliciesRequestValidator() db.Validator {
	return DefaultSetActiveAlertPoliciesRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *SetActiveAlertPoliciesResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SetActiveAlertPoliciesResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SetActiveAlertPoliciesResponse) DeepCopy() *SetActiveAlertPoliciesResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SetActiveAlertPoliciesResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SetActiveAlertPoliciesResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SetActiveAlertPoliciesResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SetActiveAlertPoliciesResponseValidator().Validate(ctx, m, opts...)
}

type ValidateSetActiveAlertPoliciesResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSetActiveAlertPoliciesResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SetActiveAlertPoliciesResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SetActiveAlertPoliciesResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSetActiveAlertPoliciesResponseValidator = func() *ValidateSetActiveAlertPoliciesResponse {
	v := &ValidateSetActiveAlertPoliciesResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SetActiveAlertPoliciesResponseValidator() db.Validator {
	return DefaultSetActiveAlertPoliciesResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *SetActiveNetworkPoliciesRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SetActiveNetworkPoliciesRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SetActiveNetworkPoliciesRequest) DeepCopy() *SetActiveNetworkPoliciesRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SetActiveNetworkPoliciesRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SetActiveNetworkPoliciesRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SetActiveNetworkPoliciesRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SetActiveNetworkPoliciesRequestValidator().Validate(ctx, m, opts...)
}

func (m *SetActiveNetworkPoliciesRequest) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetNetworkPoliciesDRefInfo()

}

func (m *SetActiveNetworkPoliciesRequest) GetNetworkPoliciesDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetNetworkPolicies()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("SetActiveNetworkPoliciesRequest.network_policies[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("network_policy.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "network_policy.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "network_policies",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetNetworkPoliciesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *SetActiveNetworkPoliciesRequest) GetNetworkPoliciesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "network_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: network_policy")
	}
	for i, vref := range m.GetNetworkPolicies() {
		if vref == nil {
			return nil, fmt.Errorf("SetActiveNetworkPoliciesRequest.network_policies[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "network_policy.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateSetActiveNetworkPoliciesRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSetActiveNetworkPoliciesRequest) NetworkPoliciesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for network_policies")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for network_policies")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated network_policies")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items network_policies")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSetActiveNetworkPoliciesRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SetActiveNetworkPoliciesRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SetActiveNetworkPoliciesRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network_policies"]; exists {
		vOpts := append(opts, db.WithValidateField("network_policies"))
		if err := fv(ctx, m.GetNetworkPolicies(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSetActiveNetworkPoliciesRequestValidator = func() *ValidateSetActiveNetworkPoliciesRequest {
	v := &ValidateSetActiveNetworkPoliciesRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNetworkPolicies := v.NetworkPoliciesValidationRuleHandler
	rulesNetworkPolicies := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
	}
	vFn, err = vrhNetworkPolicies(rulesNetworkPolicies)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SetActiveNetworkPoliciesRequest.network_policies: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_policies"] = vFn

	return v
}()

func SetActiveNetworkPoliciesRequestValidator() db.Validator {
	return DefaultSetActiveNetworkPoliciesRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *SetActiveNetworkPoliciesResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SetActiveNetworkPoliciesResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SetActiveNetworkPoliciesResponse) DeepCopy() *SetActiveNetworkPoliciesResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SetActiveNetworkPoliciesResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SetActiveNetworkPoliciesResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SetActiveNetworkPoliciesResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SetActiveNetworkPoliciesResponseValidator().Validate(ctx, m, opts...)
}

type ValidateSetActiveNetworkPoliciesResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSetActiveNetworkPoliciesResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SetActiveNetworkPoliciesResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SetActiveNetworkPoliciesResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSetActiveNetworkPoliciesResponseValidator = func() *ValidateSetActiveNetworkPoliciesResponse {
	v := &ValidateSetActiveNetworkPoliciesResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SetActiveNetworkPoliciesResponseValidator() db.Validator {
	return DefaultSetActiveNetworkPoliciesResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *SetActiveServicePoliciesRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SetActiveServicePoliciesRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SetActiveServicePoliciesRequest) DeepCopy() *SetActiveServicePoliciesRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SetActiveServicePoliciesRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SetActiveServicePoliciesRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SetActiveServicePoliciesRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SetActiveServicePoliciesRequestValidator().Validate(ctx, m, opts...)
}

func (m *SetActiveServicePoliciesRequest) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetServicePoliciesDRefInfo()

}

func (m *SetActiveServicePoliciesRequest) GetServicePoliciesDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetServicePolicies()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("SetActiveServicePoliciesRequest.service_policies[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("service_policy.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "service_policy.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "service_policies",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetServicePoliciesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *SetActiveServicePoliciesRequest) GetServicePoliciesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "service_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: service_policy")
	}
	for i, vref := range m.GetServicePolicies() {
		if vref == nil {
			return nil, fmt.Errorf("SetActiveServicePoliciesRequest.service_policies[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "service_policy.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateSetActiveServicePoliciesRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSetActiveServicePoliciesRequest) ServicePoliciesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for service_policies")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for service_policies")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated service_policies")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items service_policies")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSetActiveServicePoliciesRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SetActiveServicePoliciesRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SetActiveServicePoliciesRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_policies"]; exists {
		vOpts := append(opts, db.WithValidateField("service_policies"))
		if err := fv(ctx, m.GetServicePolicies(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSetActiveServicePoliciesRequestValidator = func() *ValidateSetActiveServicePoliciesRequest {
	v := &ValidateSetActiveServicePoliciesRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhServicePolicies := v.ServicePoliciesValidationRuleHandler
	rulesServicePolicies := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
	}
	vFn, err = vrhServicePolicies(rulesServicePolicies)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SetActiveServicePoliciesRequest.service_policies: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_policies"] = vFn

	return v
}()

func SetActiveServicePoliciesRequestValidator() db.Validator {
	return DefaultSetActiveServicePoliciesRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *SetActiveServicePoliciesResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SetActiveServicePoliciesResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SetActiveServicePoliciesResponse) DeepCopy() *SetActiveServicePoliciesResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SetActiveServicePoliciesResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SetActiveServicePoliciesResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SetActiveServicePoliciesResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SetActiveServicePoliciesResponseValidator().Validate(ctx, m, opts...)
}

type ValidateSetActiveServicePoliciesResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSetActiveServicePoliciesResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SetActiveServicePoliciesResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SetActiveServicePoliciesResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSetActiveServicePoliciesResponseValidator = func() *ValidateSetActiveServicePoliciesResponse {
	v := &ValidateSetActiveServicePoliciesResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SetActiveServicePoliciesResponseValidator() db.Validator {
	return DefaultSetActiveServicePoliciesResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *SetFastACLsForInternetVIPsRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SetFastACLsForInternetVIPsRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SetFastACLsForInternetVIPsRequest) DeepCopy() *SetFastACLsForInternetVIPsRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SetFastACLsForInternetVIPsRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SetFastACLsForInternetVIPsRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SetFastACLsForInternetVIPsRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SetFastACLsForInternetVIPsRequestValidator().Validate(ctx, m, opts...)
}

func (m *SetFastACLsForInternetVIPsRequest) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetFastAclsDRefInfo()

}

func (m *SetFastACLsForInternetVIPsRequest) GetFastAclsDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetFastAcls()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("SetFastACLsForInternetVIPsRequest.fast_acls[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("fast_acl.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "fast_acl.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "fast_acls",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetFastAclsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *SetFastACLsForInternetVIPsRequest) GetFastAclsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "fast_acl.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: fast_acl")
	}
	for i, vref := range m.GetFastAcls() {
		if vref == nil {
			return nil, fmt.Errorf("SetFastACLsForInternetVIPsRequest.fast_acls[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "fast_acl.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateSetFastACLsForInternetVIPsRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSetFastACLsForInternetVIPsRequest) FastAclsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for fast_acls")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for fast_acls")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated fast_acls")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items fast_acls")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSetFastACLsForInternetVIPsRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SetFastACLsForInternetVIPsRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SetFastACLsForInternetVIPsRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["fast_acls"]; exists {
		vOpts := append(opts, db.WithValidateField("fast_acls"))
		if err := fv(ctx, m.GetFastAcls(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSetFastACLsForInternetVIPsRequestValidator = func() *ValidateSetFastACLsForInternetVIPsRequest {
	v := &ValidateSetFastACLsForInternetVIPsRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhFastAcls := v.FastAclsValidationRuleHandler
	rulesFastAcls := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "128",
	}
	vFn, err = vrhFastAcls(rulesFastAcls)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SetFastACLsForInternetVIPsRequest.fast_acls: %s", err)
		panic(errMsg)
	}
	v.FldValidators["fast_acls"] = vFn

	return v
}()

func SetFastACLsForInternetVIPsRequestValidator() db.Validator {
	return DefaultSetFastACLsForInternetVIPsRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *SetFastACLsForInternetVIPsResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SetFastACLsForInternetVIPsResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SetFastACLsForInternetVIPsResponse) DeepCopy() *SetFastACLsForInternetVIPsResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SetFastACLsForInternetVIPsResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SetFastACLsForInternetVIPsResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SetFastACLsForInternetVIPsResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SetFastACLsForInternetVIPsResponseValidator().Validate(ctx, m, opts...)
}

type ValidateSetFastACLsForInternetVIPsResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSetFastACLsForInternetVIPsResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SetFastACLsForInternetVIPsResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SetFastACLsForInternetVIPsResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSetFastACLsForInternetVIPsResponseValidator = func() *ValidateSetFastACLsForInternetVIPsResponse {
	v := &ValidateSetFastACLsForInternetVIPsResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SetFastACLsForInternetVIPsResponseValidator() db.Validator {
	return DefaultSetFastACLsForInternetVIPsResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *TCPLoadbalancerInventoryFilterType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TCPLoadbalancerInventoryFilterType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TCPLoadbalancerInventoryFilterType) DeepCopy() *TCPLoadbalancerInventoryFilterType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TCPLoadbalancerInventoryFilterType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TCPLoadbalancerInventoryFilterType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TCPLoadbalancerInventoryFilterType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TCPLoadbalancerInventoryFilterTypeValidator().Validate(ctx, m, opts...)
}

type ValidateTCPLoadbalancerInventoryFilterType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTCPLoadbalancerInventoryFilterType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TCPLoadbalancerInventoryFilterType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TCPLoadbalancerInventoryFilterType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace_service_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace_service_policy"))
		if err := fv(ctx, m.GetNamespaceServicePolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["private_advertisement"]; exists {

		vOpts := append(opts, db.WithValidateField("private_advertisement"))
		if err := fv(ctx, m.GetPrivateAdvertisement(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["public_advertisment"]; exists {

		vOpts := append(opts, db.WithValidateField("public_advertisment"))
		if err := fv(ctx, m.GetPublicAdvertisment(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("service_policy"))
		if err := fv(ctx, m.GetServicePolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tls_encryption"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_encryption"))
		if err := fv(ctx, m.GetTlsEncryption(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTCPLoadbalancerInventoryFilterTypeValidator = func() *ValidateTCPLoadbalancerInventoryFilterType {
	v := &ValidateTCPLoadbalancerInventoryFilterType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func TCPLoadbalancerInventoryFilterTypeValidator() db.Validator {
	return DefaultTCPLoadbalancerInventoryFilterTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TCPLoadbalancerInventoryType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TCPLoadbalancerInventoryType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TCPLoadbalancerInventoryType) DeepCopy() *TCPLoadbalancerInventoryType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TCPLoadbalancerInventoryType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TCPLoadbalancerInventoryType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TCPLoadbalancerInventoryType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TCPLoadbalancerInventoryTypeValidator().Validate(ctx, m, opts...)
}

type ValidateTCPLoadbalancerInventoryType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTCPLoadbalancerInventoryType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TCPLoadbalancerInventoryType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TCPLoadbalancerInventoryType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace_service_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace_service_policy"))
		if err := fv(ctx, m.GetNamespaceServicePolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["private_advertisement"]; exists {

		vOpts := append(opts, db.WithValidateField("private_advertisement"))
		if err := fv(ctx, m.GetPrivateAdvertisement(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["public_advertisment"]; exists {

		vOpts := append(opts, db.WithValidateField("public_advertisment"))
		if err := fv(ctx, m.GetPublicAdvertisment(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("service_policy"))
		if err := fv(ctx, m.GetServicePolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tcplb_results"]; exists {

		vOpts := append(opts, db.WithValidateField("tcplb_results"))
		for idx, item := range m.GetTcplbResults() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tls_encryption"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_encryption"))
		if err := fv(ctx, m.GetTlsEncryption(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTCPLoadbalancerInventoryTypeValidator = func() *ValidateTCPLoadbalancerInventoryType {
	v := &ValidateTCPLoadbalancerInventoryType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func TCPLoadbalancerInventoryTypeValidator() db.Validator {
	return DefaultTCPLoadbalancerInventoryTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TCPLoadbalancerResultType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TCPLoadbalancerResultType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TCPLoadbalancerResultType) DeepCopy() *TCPLoadbalancerResultType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TCPLoadbalancerResultType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TCPLoadbalancerResultType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TCPLoadbalancerResultType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TCPLoadbalancerResultTypeValidator().Validate(ctx, m, opts...)
}

type ValidateTCPLoadbalancerResultType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTCPLoadbalancerResultType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TCPLoadbalancerResultType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TCPLoadbalancerResultType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace_service_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace_service_policy"))
		if err := fv(ctx, m.GetNamespaceServicePolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["private_advertisement"]; exists {

		vOpts := append(opts, db.WithValidateField("private_advertisement"))
		if err := fv(ctx, m.GetPrivateAdvertisement(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["public_advertisment"]; exists {

		vOpts := append(opts, db.WithValidateField("public_advertisment"))
		if err := fv(ctx, m.GetPublicAdvertisment(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rate_limit"]; exists {

		vOpts := append(opts, db.WithValidateField("rate_limit"))
		if err := fv(ctx, m.GetRateLimit(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("service_policy"))
		if err := fv(ctx, m.GetServicePolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tls_encryption"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_encryption"))
		if err := fv(ctx, m.GetTlsEncryption(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTCPLoadbalancerResultTypeValidator = func() *ValidateTCPLoadbalancerResultType {
	v := &ValidateTCPLoadbalancerResultType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func TCPLoadbalancerResultTypeValidator() db.Validator {
	return DefaultTCPLoadbalancerResultTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *UpdateAllowAdvertiseOnPublicReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UpdateAllowAdvertiseOnPublicReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UpdateAllowAdvertiseOnPublicReq) DeepCopy() *UpdateAllowAdvertiseOnPublicReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UpdateAllowAdvertiseOnPublicReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UpdateAllowAdvertiseOnPublicReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UpdateAllowAdvertiseOnPublicReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UpdateAllowAdvertiseOnPublicReqValidator().Validate(ctx, m, opts...)
}

type ValidateUpdateAllowAdvertiseOnPublicReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUpdateAllowAdvertiseOnPublicReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UpdateAllowAdvertiseOnPublicReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UpdateAllowAdvertiseOnPublicReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["allow_advertise_on_public"]; exists {

		vOpts := append(opts, db.WithValidateField("allow_advertise_on_public"))
		if err := fv(ctx, m.GetAllowAdvertiseOnPublic(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUpdateAllowAdvertiseOnPublicReqValidator = func() *ValidateUpdateAllowAdvertiseOnPublicReq {
	v := &ValidateUpdateAllowAdvertiseOnPublicReq{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UpdateAllowAdvertiseOnPublicReqValidator() db.Validator {
	return DefaultUpdateAllowAdvertiseOnPublicReqValidator
}

// augmented methods on protoc/std generated struct

func (m *UpdateAllowAdvertiseOnPublicResp) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UpdateAllowAdvertiseOnPublicResp) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UpdateAllowAdvertiseOnPublicResp) DeepCopy() *UpdateAllowAdvertiseOnPublicResp {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UpdateAllowAdvertiseOnPublicResp{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UpdateAllowAdvertiseOnPublicResp) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UpdateAllowAdvertiseOnPublicResp) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UpdateAllowAdvertiseOnPublicRespValidator().Validate(ctx, m, opts...)
}

type ValidateUpdateAllowAdvertiseOnPublicResp struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUpdateAllowAdvertiseOnPublicResp) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UpdateAllowAdvertiseOnPublicResp)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UpdateAllowAdvertiseOnPublicResp got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["result"]; exists {

		vOpts := append(opts, db.WithValidateField("result"))
		if err := fv(ctx, m.GetResult(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUpdateAllowAdvertiseOnPublicRespValidator = func() *ValidateUpdateAllowAdvertiseOnPublicResp {
	v := &ValidateUpdateAllowAdvertiseOnPublicResp{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UpdateAllowAdvertiseOnPublicRespValidator() db.Validator {
	return DefaultUpdateAllowAdvertiseOnPublicRespValidator
}

// augmented methods on protoc/std generated struct

func (m *ValidateRulesReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ValidateRulesReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ValidateRulesReq) DeepCopy() *ValidateRulesReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ValidateRulesReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ValidateRulesReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ValidateRulesReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ValidateRulesReqValidator().Validate(ctx, m, opts...)
}

type ValidateValidateRulesReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateValidateRulesReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ValidateRulesReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ValidateRulesReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["validator_evaluation"]; exists {

		vOpts := append(opts, db.WithValidateField("validator_evaluation"))
		for key, value := range m.GetValidatorEvaluation() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultValidateRulesReqValidator = func() *ValidateValidateRulesReq {
	v := &ValidateValidateRulesReq{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ValidateRulesReqValidator() db.Validator {
	return DefaultValidateRulesReqValidator
}

// augmented methods on protoc/std generated struct

func (m *ValidateRulesResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ValidateRulesResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ValidateRulesResponse) DeepCopy() *ValidateRulesResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ValidateRulesResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ValidateRulesResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ValidateRulesResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ValidateRulesResponseValidator().Validate(ctx, m, opts...)
}

type ValidateValidateRulesResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateValidateRulesResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ValidateRulesResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ValidateRulesResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["error"]; exists {

		vOpts := append(opts, db.WithValidateField("error"))
		if err := fv(ctx, m.GetError(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["success"]; exists {

		vOpts := append(opts, db.WithValidateField("success"))
		if err := fv(ctx, m.GetSuccess(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultValidateRulesResponseValidator = func() *ValidateValidateRulesResponse {
	v := &ValidateValidateRulesResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ValidateRulesResponseValidator() db.Validator {
	return DefaultValidateRulesResponseValidator
}
