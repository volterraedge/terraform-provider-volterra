// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package registration

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *ApprovalReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ApprovalReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ApprovalReq) DeepCopy() *ApprovalReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ApprovalReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ApprovalReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ApprovalReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ApprovalReqValidator().Validate(ctx, m, opts...)
}

type ValidateApprovalReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateApprovalReq) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateApprovalReq) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateApprovalReq) StateValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ObjectState)
		return int32(i)
	}
	// ObjectState_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ObjectState_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for state")
	}

	return validatorFn, nil
}

func (v *ValidateApprovalReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ApprovalReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ApprovalReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["annotations"]; exists {

		vOpts := append(opts, db.WithValidateField("annotations"))
		for key, value := range m.GetAnnotations() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["connected_region"]; exists {

		vOpts := append(opts, db.WithValidateField("connected_region"))
		if err := fv(ctx, m.GetConnectedRegion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["labels"]; exists {

		vOpts := append(opts, db.WithValidateField("labels"))
		for key, value := range m.GetLabels() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["passport"]; exists {

		vOpts := append(opts, db.WithValidateField("passport"))
		if err := fv(ctx, m.GetPassport(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["preferred_active_re"]; exists {

		vOpts := append(opts, db.WithValidateField("preferred_active_re"))
		if err := fv(ctx, m.GetPreferredActiveRe(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_type"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_type"))
		if err := fv(ctx, m.GetTunnelType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultApprovalReqValidator = func() *ValidateApprovalReq {
	v := &ValidateApprovalReq{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ApprovalReq.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ApprovalReq.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhState := v.StateValidationRuleHandler
	rulesState := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhState(rulesState)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ApprovalReq.state: %s", err)
		panic(errMsg)
	}
	v.FldValidators["state"] = vFn

	v.FldValidators["passport"] = PassportValidator().Validate

	return v
}()

func ApprovalReqValidator() db.Validator {
	return DefaultApprovalReqValidator
}

// augmented methods on protoc/std generated struct

func (m *ConfigReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ConfigReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ConfigReq) DeepCopy() *ConfigReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ConfigReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ConfigReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ConfigReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ConfigReqValidator().Validate(ctx, m, opts...)
}

type ValidateConfigReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateConfigReq) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateConfigReq) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateConfigReq) TokenValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for token")
	}

	return validatorFn, nil
}

func (v *ValidateConfigReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ConfigReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ConfigReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["token"]; exists {

		vOpts := append(opts, db.WithValidateField("token"))
		if err := fv(ctx, m.GetToken(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultConfigReqValidator = func() *ValidateConfigReq {
	v := &ValidateConfigReq{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ConfigReq.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ConfigReq.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhToken := v.TokenValidationRuleHandler
	rulesToken := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhToken(rulesToken)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ConfigReq.token: %s", err)
		panic(errMsg)
	}
	v.FldValidators["token"] = vFn

	return v
}()

func ConfigReqValidator() db.Validator {
	return DefaultConfigReqValidator
}

// augmented methods on protoc/std generated struct

func (m *ConfigResp) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ConfigResp) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ConfigResp) DeepCopy() *ConfigResp {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ConfigResp{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ConfigResp) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ConfigResp) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ConfigRespValidator().Validate(ctx, m, opts...)
}

type ValidateConfigResp struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateConfigResp) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ConfigResp)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ConfigResp got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["hash"]; exists {

		vOpts := append(opts, db.WithValidateField("hash"))
		if err := fv(ctx, m.GetHash(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["workload"]; exists {

		vOpts := append(opts, db.WithValidateField("workload"))
		for key, value := range m.GetWorkload() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultConfigRespValidator = func() *ValidateConfigResp {
	v := &ValidateConfigResp{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ConfigRespValidator() db.Validator {
	return DefaultConfigRespValidator
}

// augmented methods on protoc/std generated struct

func (m *DeleteRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DeleteRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DeleteRequest) DeepCopy() *DeleteRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DeleteRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DeleteRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DeleteRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DeleteRequestValidator().Validate(ctx, m, opts...)
}

type ValidateDeleteRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDeleteRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DeleteRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DeleteRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["fail_if_referred"]; exists {

		vOpts := append(opts, db.WithValidateField("fail_if_referred"))
		if err := fv(ctx, m.GetFailIfReferred(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDeleteRequestValidator = func() *ValidateDeleteRequest {
	v := &ValidateDeleteRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DeleteRequestValidator() db.Validator {
	return DefaultDeleteRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *GetImageDownloadUrlReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetImageDownloadUrlReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetImageDownloadUrlReq) DeepCopy() *GetImageDownloadUrlReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetImageDownloadUrlReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetImageDownloadUrlReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetImageDownloadUrlReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetImageDownloadUrlReqValidator().Validate(ctx, m, opts...)
}

type ValidateGetImageDownloadUrlReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetImageDownloadUrlReq) ProviderValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for provider")
	}

	return validatorFn, nil
}

func (v *ValidateGetImageDownloadUrlReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetImageDownloadUrlReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetImageDownloadUrlReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["provider"]; exists {

		vOpts := append(opts, db.WithValidateField("provider"))
		if err := fv(ctx, m.GetProvider(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetImageDownloadUrlReqValidator = func() *ValidateGetImageDownloadUrlReq {
	v := &ValidateGetImageDownloadUrlReq{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhProvider := v.ProviderValidationRuleHandler
	rulesProvider := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhProvider(rulesProvider)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetImageDownloadUrlReq.provider: %s", err)
		panic(errMsg)
	}
	v.FldValidators["provider"] = vFn

	return v
}()

func GetImageDownloadUrlReqValidator() db.Validator {
	return DefaultGetImageDownloadUrlReqValidator
}

// augmented methods on protoc/std generated struct

func (m *GetImageDownloadUrlResp) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetImageDownloadUrlResp) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetImageDownloadUrlResp) DeepCopy() *GetImageDownloadUrlResp {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetImageDownloadUrlResp{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetImageDownloadUrlResp) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetImageDownloadUrlResp) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetImageDownloadUrlRespValidator().Validate(ctx, m, opts...)
}

type ValidateGetImageDownloadUrlResp struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetImageDownloadUrlResp) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetImageDownloadUrlResp)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetImageDownloadUrlResp got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["image_download_url"]; exists {

		vOpts := append(opts, db.WithValidateField("image_download_url"))
		if err := fv(ctx, m.GetImageDownloadUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["image_md5_download_url"]; exists {

		vOpts := append(opts, db.WithValidateField("image_md5_download_url"))
		if err := fv(ctx, m.GetImageMd5DownloadUrl(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetImageDownloadUrlRespValidator = func() *ValidateGetImageDownloadUrlResp {
	v := &ValidateGetImageDownloadUrlResp{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetImageDownloadUrlRespValidator() db.Validator {
	return DefaultGetImageDownloadUrlRespValidator
}

// augmented methods on protoc/std generated struct

func (m *GetRegistrationsBySiteTokenReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetRegistrationsBySiteTokenReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetRegistrationsBySiteTokenReq) DeepCopy() *GetRegistrationsBySiteTokenReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetRegistrationsBySiteTokenReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetRegistrationsBySiteTokenReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetRegistrationsBySiteTokenReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetRegistrationsBySiteTokenReqValidator().Validate(ctx, m, opts...)
}

type ValidateGetRegistrationsBySiteTokenReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetRegistrationsBySiteTokenReq) SiteTokenValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_token")
	}

	return validatorFn, nil
}

func (v *ValidateGetRegistrationsBySiteTokenReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetRegistrationsBySiteTokenReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetRegistrationsBySiteTokenReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["site_token"]; exists {

		vOpts := append(opts, db.WithValidateField("site_token"))
		if err := fv(ctx, m.GetSiteToken(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetRegistrationsBySiteTokenReqValidator = func() *ValidateGetRegistrationsBySiteTokenReq {
	v := &ValidateGetRegistrationsBySiteTokenReq{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSiteToken := v.SiteTokenValidationRuleHandler
	rulesSiteToken := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSiteToken(rulesSiteToken)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetRegistrationsBySiteTokenReq.site_token: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_token"] = vFn

	return v
}()

func GetRegistrationsBySiteTokenReqValidator() db.Validator {
	return DefaultGetRegistrationsBySiteTokenReqValidator
}

// augmented methods on protoc/std generated struct

func (m *GetRegistrationsBySiteTokenResp) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetRegistrationsBySiteTokenResp) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetRegistrationsBySiteTokenResp) DeepCopy() *GetRegistrationsBySiteTokenResp {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetRegistrationsBySiteTokenResp{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetRegistrationsBySiteTokenResp) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetRegistrationsBySiteTokenResp) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetRegistrationsBySiteTokenRespValidator().Validate(ctx, m, opts...)
}

type ValidateGetRegistrationsBySiteTokenResp struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetRegistrationsBySiteTokenResp) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetRegistrationsBySiteTokenResp)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetRegistrationsBySiteTokenResp got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["registration_uuids"]; exists {

		vOpts := append(opts, db.WithValidateField("registration_uuids"))
		for idx, item := range m.GetRegistrationUuids() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetRegistrationsBySiteTokenRespValidator = func() *ValidateGetRegistrationsBySiteTokenResp {
	v := &ValidateGetRegistrationsBySiteTokenResp{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetRegistrationsBySiteTokenRespValidator() db.Validator {
	return DefaultGetRegistrationsBySiteTokenRespValidator
}

// augmented methods on protoc/std generated struct

func (m *GetRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetRequest) DeepCopy() *GetRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetRequestValidator().Validate(ctx, m, opts...)
}

type ValidateGetRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_format"]; exists {

		vOpts := append(opts, db.WithValidateField("response_format"))
		if err := fv(ctx, m.GetResponseFormat(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetRequestValidator = func() *ValidateGetRequest {
	v := &ValidateGetRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetRequestValidator() db.Validator {
	return DefaultGetRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *GetResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetResponse) DeepCopy() *GetResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetResponseValidator().Validate(ctx, m, opts...)
}

func (m *GetResponse) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return nil, nil

}

type ValidateGetResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["create_form"]; exists {

		vOpts := append(opts, db.WithValidateField("create_form"))
		if err := fv(ctx, m.GetCreateForm(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["deleted_referred_objects"]; exists {

		vOpts := append(opts, db.WithValidateField("deleted_referred_objects"))
		for idx, item := range m.GetDeletedReferredObjects() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["disabled_referred_objects"]; exists {

		vOpts := append(opts, db.WithValidateField("disabled_referred_objects"))
		for idx, item := range m.GetDisabledReferredObjects() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["object"]; exists {

		vOpts := append(opts, db.WithValidateField("object"))
		if err := fv(ctx, m.GetObject(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["referring_objects"]; exists {

		vOpts := append(opts, db.WithValidateField("referring_objects"))
		for idx, item := range m.GetReferringObjects() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["replace_form"]; exists {

		vOpts := append(opts, db.WithValidateField("replace_form"))
		if err := fv(ctx, m.GetReplaceForm(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["resource_version"]; exists {

		vOpts := append(opts, db.WithValidateField("resource_version"))
		if err := fv(ctx, m.GetResourceVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["spec"]; exists {

		vOpts := append(opts, db.WithValidateField("spec"))
		if err := fv(ctx, m.GetSpec(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["system_metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("system_metadata"))
		if err := fv(ctx, m.GetSystemMetadata(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetResponseValidator = func() *ValidateGetResponse {
	v := &ValidateGetResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["object"] = ObjectValidator().Validate

	v.FldValidators["create_form"] = CreateRequestValidator().Validate

	v.FldValidators["replace_form"] = ReplaceRequestValidator().Validate

	v.FldValidators["metadata"] = ves_io_schema.ObjectGetMetaTypeValidator().Validate

	v.FldValidators["spec"] = GetSpecTypeValidator().Validate

	return v
}()

func GetResponseValidator() db.Validator {
	return DefaultGetResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *ListBySiteReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListBySiteReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListBySiteReq) DeepCopy() *ListBySiteReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListBySiteReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListBySiteReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListBySiteReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListBySiteReqValidator().Validate(ctx, m, opts...)
}

type ValidateListBySiteReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListBySiteReq) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateListBySiteReq) SiteNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_name")
	}

	return validatorFn, nil
}

func (v *ValidateListBySiteReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListBySiteReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListBySiteReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_name"]; exists {

		vOpts := append(opts, db.WithValidateField("site_name"))
		if err := fv(ctx, m.GetSiteName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListBySiteReqValidator = func() *ValidateListBySiteReq {
	v := &ValidateListBySiteReq{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListBySiteReq.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhSiteName := v.SiteNameValidationRuleHandler
	rulesSiteName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSiteName(rulesSiteName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListBySiteReq.site_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_name"] = vFn

	return v
}()

func ListBySiteReqValidator() db.Validator {
	return DefaultListBySiteReqValidator
}

// augmented methods on protoc/std generated struct

func (m *ListRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListRequest) DeepCopy() *ListRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListRequestValidator().Validate(ctx, m, opts...)
}

type ValidateListRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["label_filter"]; exists {

		vOpts := append(opts, db.WithValidateField("label_filter"))
		if err := fv(ctx, m.GetLabelFilter(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["report_fields"]; exists {

		vOpts := append(opts, db.WithValidateField("report_fields"))
		for idx, item := range m.GetReportFields() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["report_status_fields"]; exists {

		vOpts := append(opts, db.WithValidateField("report_status_fields"))
		for idx, item := range m.GetReportStatusFields() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListRequestValidator = func() *ValidateListRequest {
	v := &ValidateListRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ListRequestValidator() db.Validator {
	return DefaultListRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ListResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListResponse) DeepCopy() *ListResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListResponseValidator().Validate(ctx, m, opts...)
}

func (m *ListResponse) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetItemsDRefInfo()

}

// GetDRefInfo for the field's type
func (m *ListResponse) GetItemsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetItems() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetItems() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetItems() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("items[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateListResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["errors"]; exists {

		vOpts := append(opts, db.WithValidateField("errors"))
		for idx, item := range m.GetErrors() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["items"]; exists {

		vOpts := append(opts, db.WithValidateField("items"))
		for idx, item := range m.GetItems() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListResponseValidator = func() *ValidateListResponse {
	v := &ValidateListResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["items"] = ListResponseItemValidator().Validate

	return v
}()

func ListResponseValidator() db.Validator {
	return DefaultListResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *ListResponseItem) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListResponseItem) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListResponseItem) DeepCopy() *ListResponseItem {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListResponseItem{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListResponseItem) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListResponseItem) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListResponseItemValidator().Validate(ctx, m, opts...)
}

func (m *ListResponseItem) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return nil, nil

}

type ValidateListResponseItem struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListResponseItem) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListResponseItem)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListResponseItem got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["annotations"]; exists {

		vOpts := append(opts, db.WithValidateField("annotations"))
		for key, value := range m.GetAnnotations() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disabled"]; exists {

		vOpts := append(opts, db.WithValidateField("disabled"))
		if err := fv(ctx, m.GetDisabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["get_spec"]; exists {

		vOpts := append(opts, db.WithValidateField("get_spec"))
		if err := fv(ctx, m.GetGetSpec(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["labels"]; exists {

		vOpts := append(opts, db.WithValidateField("labels"))
		for key, value := range m.GetLabels() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["object"]; exists {

		vOpts := append(opts, db.WithValidateField("object"))
		if err := fv(ctx, m.GetObject(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["owner_view"]; exists {

		vOpts := append(opts, db.WithValidateField("owner_view"))
		if err := fv(ctx, m.GetOwnerView(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["system_metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("system_metadata"))
		if err := fv(ctx, m.GetSystemMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tenant"]; exists {

		vOpts := append(opts, db.WithValidateField("tenant"))
		if err := fv(ctx, m.GetTenant(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["uid"]; exists {

		vOpts := append(opts, db.WithValidateField("uid"))
		if err := fv(ctx, m.GetUid(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListResponseItemValidator = func() *ValidateListResponseItem {
	v := &ValidateListResponseItem{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["object"] = ObjectValidator().Validate

	v.FldValidators["get_spec"] = GetSpecTypeValidator().Validate

	v.FldValidators["metadata"] = ves_io_schema.ObjectGetMetaTypeValidator().Validate

	return v
}()

func ListResponseItemValidator() db.Validator {
	return DefaultListResponseItemValidator
}

// augmented methods on protoc/std generated struct

func (m *ListStateReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListStateReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListStateReq) DeepCopy() *ListStateReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListStateReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListStateReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListStateReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListStateReqValidator().Validate(ctx, m, opts...)
}

type ValidateListStateReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListStateReq) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateListStateReq) StateValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ObjectState)
		return int32(i)
	}
	// ObjectState_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ObjectState_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for state")
	}

	return validatorFn, nil
}

func (v *ValidateListStateReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListStateReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListStateReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListStateReqValidator = func() *ValidateListStateReq {
	v := &ValidateListStateReq{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListStateReq.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhState := v.StateValidationRuleHandler
	rulesState := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhState(rulesState)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListStateReq.state: %s", err)
		panic(errMsg)
	}
	v.FldValidators["state"] = vFn

	return v
}()

func ListStateReqValidator() db.Validator {
	return DefaultListStateReqValidator
}

// augmented methods on protoc/std generated struct

func (m *ObjectChangeResp) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ObjectChangeResp) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ObjectChangeResp) DeepCopy() *ObjectChangeResp {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ObjectChangeResp{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ObjectChangeResp) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ObjectChangeResp) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ObjectChangeRespValidator().Validate(ctx, m, opts...)
}

func (m *ObjectChangeResp) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return nil, nil

}

type ValidateObjectChangeResp struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateObjectChangeResp) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ObjectChangeResp)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ObjectChangeResp got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["obj"]; exists {

		vOpts := append(opts, db.WithValidateField("obj"))
		if err := fv(ctx, m.GetObj(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultObjectChangeRespValidator = func() *ValidateObjectChangeResp {
	v := &ValidateObjectChangeResp{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["obj"] = ObjectValidator().Validate

	return v
}()

func ObjectChangeRespValidator() db.Validator {
	return DefaultObjectChangeRespValidator
}

// augmented methods on protoc/std generated struct

func (m *RegistrationCreateRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RegistrationCreateRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RegistrationCreateRequest) DeepCopy() *RegistrationCreateRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RegistrationCreateRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RegistrationCreateRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RegistrationCreateRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RegistrationCreateRequestValidator().Validate(ctx, m, opts...)
}

type ValidateRegistrationCreateRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRegistrationCreateRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RegistrationCreateRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RegistrationCreateRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["spec"]; exists {

		vOpts := append(opts, db.WithValidateField("spec"))
		if err := fv(ctx, m.GetSpec(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRegistrationCreateRequestValidator = func() *ValidateRegistrationCreateRequest {
	v := &ValidateRegistrationCreateRequest{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["metadata"] = ves_io_schema.ObjectCreateMetaTypeValidator().Validate

	v.FldValidators["spec"] = CreateSpecTypeValidator().Validate

	return v
}()

func RegistrationCreateRequestValidator() db.Validator {
	return DefaultRegistrationCreateRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *SuggestValuesReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SuggestValuesReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SuggestValuesReq) DeepCopy() *SuggestValuesReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SuggestValuesReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SuggestValuesReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SuggestValuesReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SuggestValuesReqValidator().Validate(ctx, m, opts...)
}

type ValidateSuggestValuesReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSuggestValuesReq) FieldPathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for field_path")
	}

	return validatorFn, nil
}

func (v *ValidateSuggestValuesReq) MatchValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for match_value")
	}

	return validatorFn, nil
}

func (v *ValidateSuggestValuesReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SuggestValuesReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SuggestValuesReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["field_path"]; exists {

		vOpts := append(opts, db.WithValidateField("field_path"))
		if err := fv(ctx, m.GetFieldPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["match_value"]; exists {

		vOpts := append(opts, db.WithValidateField("match_value"))
		if err := fv(ctx, m.GetMatchValue(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_body"]; exists {

		vOpts := append(opts, db.WithValidateField("request_body"))
		if err := fv(ctx, m.GetRequestBody(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSuggestValuesReqValidator = func() *ValidateSuggestValuesReq {
	v := &ValidateSuggestValuesReq{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhFieldPath := v.FieldPathValidationRuleHandler
	rulesFieldPath := map[string]string{
		"ves.io.schema.rules.string.max_len": "1024",
	}
	vFn, err = vrhFieldPath(rulesFieldPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SuggestValuesReq.field_path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["field_path"] = vFn

	vrhMatchValue := v.MatchValueValidationRuleHandler
	rulesMatchValue := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhMatchValue(rulesMatchValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SuggestValuesReq.match_value: %s", err)
		panic(errMsg)
	}
	v.FldValidators["match_value"] = vFn

	return v
}()

func SuggestValuesReqValidator() db.Validator {
	return DefaultSuggestValuesReqValidator
}

// augmented methods on protoc/std generated struct

func (m *SuggestValuesResp) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SuggestValuesResp) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SuggestValuesResp) DeepCopy() *SuggestValuesResp {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SuggestValuesResp{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SuggestValuesResp) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SuggestValuesResp) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SuggestValuesRespValidator().Validate(ctx, m, opts...)
}

type ValidateSuggestValuesResp struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSuggestValuesResp) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SuggestValuesResp)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SuggestValuesResp got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["items"]; exists {

		vOpts := append(opts, db.WithValidateField("items"))
		for idx, item := range m.GetItems() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSuggestValuesRespValidator = func() *ValidateSuggestValuesResp {
	v := &ValidateSuggestValuesResp{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["items"] = SuggestedItemValidator().Validate

	return v
}()

func SuggestValuesRespValidator() db.Validator {
	return DefaultSuggestValuesRespValidator
}

// augmented methods on protoc/std generated struct

func (m *SuggestedItem) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SuggestedItem) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SuggestedItem) DeepCopy() *SuggestedItem {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SuggestedItem{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SuggestedItem) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SuggestedItem) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SuggestedItemValidator().Validate(ctx, m, opts...)
}

type ValidateSuggestedItem struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSuggestedItem) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SuggestedItem)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SuggestedItem got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetValueChoice().(type) {
	case *SuggestedItem_StrValue:
		if fv, exists := v.FldValidators["value_choice.str_value"]; exists {
			val := m.GetValueChoice().(*SuggestedItem_StrValue).StrValue
			vOpts := append(opts,
				db.WithValidateField("value_choice"),
				db.WithValidateField("str_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SuggestedItem_RefValue:
		if fv, exists := v.FldValidators["value_choice.ref_value"]; exists {
			val := m.GetValueChoice().(*SuggestedItem_RefValue).RefValue
			vOpts := append(opts,
				db.WithValidateField("value_choice"),
				db.WithValidateField("ref_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSuggestedItemValidator = func() *ValidateSuggestedItem {
	v := &ValidateSuggestedItem{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["value_choice.ref_value"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func SuggestedItemValidator() db.Validator {
	return DefaultSuggestedItemValidator
}

func (m *GetResponse) fromObject(e db.Entry, withDeepCopy bool) {
	f := e.(*DBObject)
	if withDeepCopy {
		f = e.DeepCopy().(*DBObject)
	}
	_ = f

	if m.Metadata == nil {
		m.Metadata = &ves_io_schema.ObjectGetMetaType{}
	}
	m.Metadata.FromObjectMetaTypeWithoutDeepCopy(f.GetMetadata())

	if m.Spec == nil {
		m.Spec = &GetSpecType{}
	}
	m.Spec.FromGlobalSpecTypeWithoutDeepCopy(f.GetSpec().GetGcSpec())

	if m.SystemMetadata == nil {
		m.SystemMetadata = &ves_io_schema.SystemObjectGetMetaType{}
	}
	m.SystemMetadata.FromSystemObjectMetaTypeWithoutDeepCopy(f.GetSystemMetadata())

}

func (m *GetResponse) FromObject(e db.Entry) {
	m.fromObject(e, true)
}

func (m *GetResponse) FromObjectWithoutDeepCopy(e db.Entry) {
	m.fromObject(e, false)
}

func (m *GetResponse) toObject(e db.Entry, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1
	f := e.(*DBObject)
	_ = f

	if m1.Metadata != nil {
		if f.Metadata == nil {
			f.Metadata = &ves_io_schema.ObjectMetaType{}
		}
	} else if f.Metadata != nil {
		f.Metadata = nil
	}

	if m1.Metadata != nil {
		m1.Metadata.ToObjectMetaTypeWithoutDeepCopy(f.Metadata)
	}

	if m1.Spec != nil {
		if f.Spec == nil {
			f.Spec = &SpecType{}
		}
	} else if f.Spec != nil {
		f.Spec = nil
	}

	if m1.Spec != nil {
		if f.Spec.GcSpec == nil {
			f.Spec.GcSpec = &GlobalSpecType{}
		}
	} else if f.Spec != nil {
		f.Spec.GcSpec = nil
	}

	if m1.Spec != nil {
		m1.Spec.ToGlobalSpecTypeWithoutDeepCopy(f.Spec.GcSpec)
	}

	if m1.SystemMetadata != nil {
		if f.SystemMetadata == nil {
			f.SystemMetadata = &ves_io_schema.SystemObjectMetaType{}
		}
	} else if f.SystemMetadata != nil {
		f.SystemMetadata = nil
	}

	if m1.SystemMetadata != nil {
		m1.SystemMetadata.ToSystemObjectMetaTypeWithoutDeepCopy(f.SystemMetadata)
	}

}

func (m *GetResponse) ToObject(e db.Entry) {
	m.toObject(e, true)
}

func (m *GetResponse) ToObjectWithoutDeepCopy(e db.Entry) {
	m.toObject(e, false)
}

func (m *RegistrationCreateRequest) fromObject(e db.Entry, withDeepCopy bool) {
	f := e.(*DBObject)
	if withDeepCopy {
		f = e.DeepCopy().(*DBObject)
	}
	_ = f

	if m.Metadata == nil {
		m.Metadata = &ves_io_schema.ObjectCreateMetaType{}
	}
	m.Metadata.FromObjectMetaTypeWithoutDeepCopy(f.GetMetadata())

	if m.Spec == nil {
		m.Spec = &CreateSpecType{}
	}
	m.Spec.FromGlobalSpecTypeWithoutDeepCopy(f.GetSpec().GetGcSpec())

}

func (m *RegistrationCreateRequest) FromObject(e db.Entry) {
	m.fromObject(e, true)
}

func (m *RegistrationCreateRequest) FromObjectWithoutDeepCopy(e db.Entry) {
	m.fromObject(e, false)
}

func (m *RegistrationCreateRequest) toObject(e db.Entry, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1
	f := e.(*DBObject)
	_ = f

	if m1.Metadata != nil {
		if f.Metadata == nil {
			f.Metadata = &ves_io_schema.ObjectMetaType{}
		}
	} else if f.Metadata != nil {
		f.Metadata = nil
	}

	if m1.Metadata != nil {
		m1.Metadata.ToObjectMetaTypeWithoutDeepCopy(f.Metadata)
	}

	if m1.Spec != nil {
		if f.Spec == nil {
			f.Spec = &SpecType{}
		}
	} else if f.Spec != nil {
		f.Spec = nil
	}

	if m1.Spec != nil {
		if f.Spec.GcSpec == nil {
			f.Spec.GcSpec = &GlobalSpecType{}
		}
	} else if f.Spec != nil {
		f.Spec.GcSpec = nil
	}

	if m1.Spec != nil {
		m1.Spec.ToGlobalSpecTypeWithoutDeepCopy(f.Spec.GcSpec)
	}

}

func (m *RegistrationCreateRequest) ToObject(e db.Entry) {
	m.toObject(e, true)
}

func (m *RegistrationCreateRequest) ToObjectWithoutDeepCopy(e db.Entry) {
	m.toObject(e, false)
}
