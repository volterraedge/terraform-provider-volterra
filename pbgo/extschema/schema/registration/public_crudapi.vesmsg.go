// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package registration

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *CreateRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateRequest) DeepCopy() *CreateRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateRequestValidator().Validate(ctx, m, opts...)
}

type ValidateCreateRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["spec"]; exists {

		vOpts := append(opts, db.WithValidateField("spec"))
		if err := fv(ctx, m.GetSpec(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateRequestValidator = func() *ValidateCreateRequest {
	v := &ValidateCreateRequest{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["metadata"] = ves_io_schema.ObjectCreateMetaTypeValidator().Validate

	v.FldValidators["spec"] = CreateSpecTypeValidator().Validate

	return v
}()

func CreateRequestValidator() db.Validator {
	return DefaultCreateRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateResponse) DeepCopy() *CreateResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateResponseValidator().Validate(ctx, m, opts...)
}

type ValidateCreateResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["spec"]; exists {

		vOpts := append(opts, db.WithValidateField("spec"))
		if err := fv(ctx, m.GetSpec(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["system_metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("system_metadata"))
		if err := fv(ctx, m.GetSystemMetadata(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateResponseValidator = func() *ValidateCreateResponse {
	v := &ValidateCreateResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["metadata"] = ves_io_schema.ObjectGetMetaTypeValidator().Validate

	v.FldValidators["spec"] = GetSpecTypeValidator().Validate

	return v
}()

func CreateResponseValidator() db.Validator {
	return DefaultCreateResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ReplaceRequest) DeepCopy() *ReplaceRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceRequestValidator().Validate(ctx, m, opts...)
}

type ValidateReplaceRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["resource_version"]; exists {

		vOpts := append(opts, db.WithValidateField("resource_version"))
		if err := fv(ctx, m.GetResourceVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["spec"]; exists {

		vOpts := append(opts, db.WithValidateField("spec"))
		if err := fv(ctx, m.GetSpec(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceRequestValidator = func() *ValidateReplaceRequest {
	v := &ValidateReplaceRequest{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["metadata"] = ves_io_schema.ObjectReplaceMetaTypeValidator().Validate

	v.FldValidators["spec"] = ReplaceSpecTypeValidator().Validate

	return v
}()

func ReplaceRequestValidator() db.Validator {
	return DefaultReplaceRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ReplaceResponse) DeepCopy() *ReplaceResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceResponseValidator().Validate(ctx, m, opts...)
}

type ValidateReplaceResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceResponseValidator = func() *ValidateReplaceResponse {
	v := &ValidateReplaceResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ReplaceResponseValidator() db.Validator {
	return DefaultReplaceResponseValidator
}

func (m *CreateRequest) fromObject(e db.Entry, withDeepCopy bool) {
	f := e.(*DBObject)
	if withDeepCopy {
		f = e.DeepCopy().(*DBObject)
	}
	_ = f

	if m.Metadata == nil {
		m.Metadata = &ves_io_schema.ObjectCreateMetaType{}
	}
	m.Metadata.FromObjectMetaTypeWithoutDeepCopy(f.GetMetadata())

	if m.Spec == nil {
		m.Spec = &CreateSpecType{}
	}
	m.Spec.FromGlobalSpecTypeWithoutDeepCopy(f.GetSpec().GetGcSpec())

}

func (m *CreateRequest) FromObject(e db.Entry) {
	m.fromObject(e, true)
}

func (m *CreateRequest) FromObjectWithoutDeepCopy(e db.Entry) {
	m.fromObject(e, false)
}

func (m *CreateRequest) toObject(e db.Entry, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1
	f := e.(*DBObject)
	_ = f

	if m1.Metadata != nil {
		if f.Metadata == nil {
			f.Metadata = &ves_io_schema.ObjectMetaType{}
		}
	} else if f.Metadata != nil {
		f.Metadata = nil
	}

	if m1.Metadata != nil {
		m1.Metadata.ToObjectMetaTypeWithoutDeepCopy(f.Metadata)
	}

	if m1.Spec != nil {
		if f.Spec == nil {
			f.Spec = &SpecType{}
		}
	} else if f.Spec != nil {
		f.Spec = nil
	}

	if m1.Spec != nil {
		if f.Spec.GcSpec == nil {
			f.Spec.GcSpec = &GlobalSpecType{}
		}
	} else if f.Spec != nil {
		f.Spec.GcSpec = nil
	}

	if m1.Spec != nil {
		m1.Spec.ToGlobalSpecTypeWithoutDeepCopy(f.Spec.GcSpec)
	}

}

func (m *CreateRequest) ToObject(e db.Entry) {
	m.toObject(e, true)
}

func (m *CreateRequest) ToObjectWithoutDeepCopy(e db.Entry) {
	m.toObject(e, false)
}

func (m *CreateResponse) fromObject(e db.Entry, withDeepCopy bool) {
	f := e.(*DBObject)
	if withDeepCopy {
		f = e.DeepCopy().(*DBObject)
	}
	_ = f

	if m.Metadata == nil {
		m.Metadata = &ves_io_schema.ObjectGetMetaType{}
	}
	m.Metadata.FromObjectMetaTypeWithoutDeepCopy(f.GetMetadata())

	if m.Spec == nil {
		m.Spec = &GetSpecType{}
	}
	m.Spec.FromGlobalSpecTypeWithoutDeepCopy(f.GetSpec().GetGcSpec())

	if m.SystemMetadata == nil {
		m.SystemMetadata = &ves_io_schema.SystemObjectGetMetaType{}
	}
	m.SystemMetadata.FromSystemObjectMetaTypeWithoutDeepCopy(f.GetSystemMetadata())

}

func (m *CreateResponse) FromObject(e db.Entry) {
	m.fromObject(e, true)
}

func (m *CreateResponse) FromObjectWithoutDeepCopy(e db.Entry) {
	m.fromObject(e, false)
}

func (m *CreateResponse) toObject(e db.Entry, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1
	f := e.(*DBObject)
	_ = f

	if m1.Metadata != nil {
		if f.Metadata == nil {
			f.Metadata = &ves_io_schema.ObjectMetaType{}
		}
	} else if f.Metadata != nil {
		f.Metadata = nil
	}

	if m1.Metadata != nil {
		m1.Metadata.ToObjectMetaTypeWithoutDeepCopy(f.Metadata)
	}

	if m1.Spec != nil {
		if f.Spec == nil {
			f.Spec = &SpecType{}
		}
	} else if f.Spec != nil {
		f.Spec = nil
	}

	if m1.Spec != nil {
		if f.Spec.GcSpec == nil {
			f.Spec.GcSpec = &GlobalSpecType{}
		}
	} else if f.Spec != nil {
		f.Spec.GcSpec = nil
	}

	if m1.Spec != nil {
		m1.Spec.ToGlobalSpecTypeWithoutDeepCopy(f.Spec.GcSpec)
	}

	if m1.SystemMetadata != nil {
		if f.SystemMetadata == nil {
			f.SystemMetadata = &ves_io_schema.SystemObjectMetaType{}
		}
	} else if f.SystemMetadata != nil {
		f.SystemMetadata = nil
	}

	if m1.SystemMetadata != nil {
		m1.SystemMetadata.ToSystemObjectMetaTypeWithoutDeepCopy(f.SystemMetadata)
	}

}

func (m *CreateResponse) ToObject(e db.Entry) {
	m.toObject(e, true)
}

func (m *CreateResponse) ToObjectWithoutDeepCopy(e db.Entry) {
	m.toObject(e, false)
}

func (m *ReplaceRequest) fromObject(e db.Entry, withDeepCopy bool) {
	f := e.(*DBObject)
	if withDeepCopy {
		f = e.DeepCopy().(*DBObject)
	}
	_ = f

	if m.Metadata == nil {
		m.Metadata = &ves_io_schema.ObjectReplaceMetaType{}
	}
	m.Metadata.FromObjectMetaTypeWithoutDeepCopy(f.GetMetadata())

	if m.Spec == nil {
		m.Spec = &ReplaceSpecType{}
	}
	m.Spec.FromGlobalSpecTypeWithoutDeepCopy(f.GetSpec().GetGcSpec())

}

func (m *ReplaceRequest) FromObject(e db.Entry) {
	m.fromObject(e, true)
}

func (m *ReplaceRequest) FromObjectWithoutDeepCopy(e db.Entry) {
	m.fromObject(e, false)
}

func (m *ReplaceRequest) toObject(e db.Entry, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1
	f := e.(*DBObject)
	_ = f

	if m1.Metadata != nil {
		if f.Metadata == nil {
			f.Metadata = &ves_io_schema.ObjectMetaType{}
		}
	} else if f.Metadata != nil {
		f.Metadata = nil
	}

	if m1.Metadata != nil {
		m1.Metadata.ToObjectMetaTypeWithoutDeepCopy(f.Metadata)
	}

	if m1.Spec != nil {
		if f.Spec == nil {
			f.Spec = &SpecType{}
		}
	} else if f.Spec != nil {
		f.Spec = nil
	}

	if m1.Spec != nil {
		if f.Spec.GcSpec == nil {
			f.Spec.GcSpec = &GlobalSpecType{}
		}
	} else if f.Spec != nil {
		f.Spec.GcSpec = nil
	}

	if m1.Spec != nil {
		m1.Spec.ToGlobalSpecTypeWithoutDeepCopy(f.Spec.GcSpec)
	}

}

func (m *ReplaceRequest) ToObject(e db.Entry) {
	m.toObject(e, true)
}

func (m *ReplaceRequest) ToObjectWithoutDeepCopy(e db.Entry) {
	m.toObject(e, false)
}
