// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/registration/types.proto

package registration

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	site "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/site"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Infrastructure provider
//
// x-displayName: "Infrastructure Provider"
// Infrastructure provider enum for registration. It describes where is instance running.
type Provider int32

const (
	// x-displayName: "Unknown"
	// Provider was not detected
	UNKNOWN Provider = 0
	// x-displayName: "AWS"
	// AWS cloud instance
	AWS Provider = 1
	// x-displayName: "GCP"
	// Google cloud instance
	GOOGLE Provider = 2
	// x-displayName: "Azure"
	// Azure cloud instance
	AZURE Provider = 3
	// x-displayName: "VMware"
	// VMWare VM
	VMWARE Provider = 4
	// x-displayName: "KVM"
	// KVM VM
	KVM Provider = 5
	// x-displayName: "Other"
	// Other provider, which was not identified by system.
	OTHER Provider = 6
	// x-displayName: "Volterra"
	// F5XC HW device.
	VOLTERRA Provider = 7
	// x-displayName: "IBM Cloud"
	// IBM Cloud instance.
	IBMCLOUD Provider = 8
	// x-displayName: "Uknown-K8S"
	UNKNOWN_K8S Provider = 9
	// x-displayName: "AWS-K8S"
	// Kubernetes cluster in AWS
	AWS_K8S Provider = 10
	// x-displayName: "GCP-K8S"
	// Kubernetes cluster in GCP
	GCP_K8S Provider = 11
	// x-displayName: "Azure-K8S"
	// Kubernetes cluster in Azure
	AZURE_K8S Provider = 12
	// x-displayName: "VMware-K8S"
	// Kubernetes cluster in Vmware
	VMWARE_K8S Provider = 13
	// x-displayName: "KVM-K8S"
	// Kubernetes cluster in VMware
	KVM_K8S Provider = 14
	// x-displayName: "OTHER-K8S"
	// Kubernetes cluster in Other provider
	OTHER_K8S Provider = 15
	// x-displayName: "Volterra-K8S"
	// Kubernetes cluster in Volterra
	VOLTERRA_K8S Provider = 16
	// x-displayName: "IBM Cloud-K8S"
	// Kubernetes cluster in IBM Cloud
	IBMCLOUD_K8S Provider = 17
	// x-displayName: "F5OS"
	// F5OS HW device.
	F5OS Provider = 18
	// x-displayName: "RSeries"
	// RSeries Device
	RSERIES Provider = 19
	// x-displayName: "OCI"
	// OCI Cloud Instance
	OCI Provider = 20
	// x-displayName: "Nutanix"
	// Nutanix instance
	NUTANIX Provider = 21
	// x-displayName: "Openstack"
	// Openstack Instance
	OPENSTACK Provider = 22
)

var Provider_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "AWS",
	2:  "GOOGLE",
	3:  "AZURE",
	4:  "VMWARE",
	5:  "KVM",
	6:  "OTHER",
	7:  "VOLTERRA",
	8:  "IBMCLOUD",
	9:  "UNKNOWN_K8S",
	10: "AWS_K8S",
	11: "GCP_K8S",
	12: "AZURE_K8S",
	13: "VMWARE_K8S",
	14: "KVM_K8S",
	15: "OTHER_K8S",
	16: "VOLTERRA_K8S",
	17: "IBMCLOUD_K8S",
	18: "F5OS",
	19: "RSERIES",
	20: "OCI",
	21: "NUTANIX",
	22: "OPENSTACK",
}

var Provider_value = map[string]int32{
	"UNKNOWN":      0,
	"AWS":          1,
	"GOOGLE":       2,
	"AZURE":        3,
	"VMWARE":       4,
	"KVM":          5,
	"OTHER":        6,
	"VOLTERRA":     7,
	"IBMCLOUD":     8,
	"UNKNOWN_K8S":  9,
	"AWS_K8S":      10,
	"GCP_K8S":      11,
	"AZURE_K8S":    12,
	"VMWARE_K8S":   13,
	"KVM_K8S":      14,
	"OTHER_K8S":    15,
	"VOLTERRA_K8S": 16,
	"IBMCLOUD_K8S": 17,
	"F5OS":         18,
	"RSERIES":      19,
	"OCI":          20,
	"NUTANIX":      21,
	"OPENSTACK":    22,
}

func (Provider) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77378b39a994305d, []int{0}
}

// ObjectState
//
// x-displayName: "Object State"
// Defines states for registration object
type ObjectState int32

const (
	// x-displayName: "Not Set"
	// State isn't set
	NOTSET ObjectState = 0
	// x-displayName: "New"
	// Object was created (registration request was received and object created)
	NEW ObjectState = 1
	// x-displayName: "Approved"
	// Registration was approved and waiting for configuration
	// This state can be set by user only if current state is NEW
	APPROVED ObjectState = 2
	// x-displayName: "Admitted"
	// Registration is approved and prepared for  to connect
	// It can't be set manually.
	ADMITTED ObjectState = 3
	// x-displayName: "Retired"
	// Registration isn't valid anymore and it will be deleted in near future
	// This state can be set by user anytime.
	RETIRED ObjectState = 4
	// x-displayName: "Failed"
	// Registration is failed (vpm reported or timeout)
	FAILED ObjectState = 5
	// x-displayName: "Done"
	// DEPRECATED. Registration is reported as finished (workload was deployed)
	DONE ObjectState = 6
	// x-displayName: "Pending"
	// User action is required
	PENDING ObjectState = 7
	// x-displayName: "Online"
	// Registration is online
	ONLINE ObjectState = 8
	// x-displayName: "Upgrading"
	// Operating system upgrade is in progress
	UPGRADING ObjectState = 9
	// x-displayName: "Maintenance"
	// Maintenance is in progress
	MAINTENANCE ObjectState = 10
)

var ObjectState_name = map[int32]string{
	0:  "NOTSET",
	1:  "NEW",
	2:  "APPROVED",
	3:  "ADMITTED",
	4:  "RETIRED",
	5:  "FAILED",
	6:  "DONE",
	7:  "PENDING",
	8:  "ONLINE",
	9:  "UPGRADING",
	10: "MAINTENANCE",
}

var ObjectState_value = map[string]int32{
	"NOTSET":      0,
	"NEW":         1,
	"APPROVED":    2,
	"ADMITTED":    3,
	"RETIRED":     4,
	"FAILED":      5,
	"DONE":        6,
	"PENDING":     7,
	"ONLINE":      8,
	"UPGRADING":   9,
	"MAINTENANCE": 10,
}

func (ObjectState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77378b39a994305d, []int{1}
}

// Infrastructure information
//
// x-displayName: "Infra Information"
// InfraMetadata stores information about instance infrastructure
type Infra struct {
	// Provider
	//
	// x-displayName: "Provider"
	// Infrastructure provider detected by system
	Provider Provider `protobuf:"varint,1,opt,name=provider,proto3,enum=ves.io.schema.registration.Provider" json:"provider,omitempty"`
	// Instance ID
	//
	// x-displayName: "Instance ID"
	// x-example: "value"
	// Instance id (assigned by infrastructure provider)
	InstanceId string `protobuf:"bytes,2,opt,name=instance_id,json=instanceId,proto3" json:"instance_id,omitempty"`
	// Zone
	//
	// x-displayName: "Region"
	// x-example: "value"
	// Instance zone (or region), depends on provider
	Zone string `protobuf:"bytes,3,opt,name=zone,proto3" json:"zone,omitempty"`
	// availability_zone
	//
	// x-displayName: "Availability Zone"
	// x-example: "value"
	// An Availability Zone is a high-availability offering that protects your applications and data from datacenter failures.
	AvailabilityZone string `protobuf:"bytes,11,opt,name=availability_zone,json=availabilityZone,proto3" json:"availability_zone,omitempty"`
	// Instance hostname
	//
	// x-displayName: "Hostname"
	// x-example: "value"
	// x-required
	// Must be unique in entire cluster and same as OS settings.
	// '.' (dots) are not allowed in hostname
	Hostname string `protobuf:"bytes,4,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// Instance domain
	//
	// x-displayName: "Instance Domain"
	// x-example: "value"
	// Machine domain. It's used for Kubernetes cloud provider when domain must be
	// different than Volterra
	Domain string `protobuf:"bytes,7,opt,name=domain,proto3" json:"domain,omitempty"`
	// Machine ID
	//
	// x-displayName: "Machine ID"
	// x-example: "value"
	// Machine id - generated by operating system
	MachineId string `protobuf:"bytes,5,opt,name=machine_id,json=machineId,proto3" json:"machine_id,omitempty"`
	// Interfaces
	//
	// x-displayName: "Interfaces"
	// x-required
	// Machine interfaces present during registration time
	Interfaces map[string]*Interface `protobuf:"bytes,6,rep,name=interfaces,proto3" json:"interfaces,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Hardware information
	//
	// x-displayName: "Hardware Information"
	// HW information about node in the site
	HwInfo *site.OsInfo `protobuf:"bytes,8,opt,name=hw_info,json=hwInfo,proto3" json:"hw_info,omitempty"`
	// Certified hardware name
	//
	// x-displayName: "Certified Hardware"
	// x-example: "value"
	// certified HW name used to map with F5XC certified_hardware definition
	CertifiedHw string `protobuf:"bytes,9,opt,name=certified_hw,json=certifiedHw,proto3" json:"certified_hw,omitempty"`
	// Internet Proxy Configuration
	//
	// x-displayName: "Local HTTP/HTTPS proxy configuration"
	// It will be used as the proxy URL for HTTP requests and HTTPS requests to F5XC public domains.
	InternetProxy *InternetProxy `protobuf:"bytes,10,opt,name=internet_proxy,json=internetProxy,proto3" json:"internet_proxy,omitempty"`
	// Timestamp
	//
	// x-displayName: "Current (machine) time"
	// It's used to verify machine have acceptable time difference from server
	Timestamp *types.Timestamp `protobuf:"bytes,12,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *Infra) Reset()      { *m = Infra{} }
func (*Infra) ProtoMessage() {}
func (*Infra) Descriptor() ([]byte, []int) {
	return fileDescriptor_77378b39a994305d, []int{0}
}
func (m *Infra) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Infra) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Infra) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Infra.Merge(m, src)
}
func (m *Infra) XXX_Size() int {
	return m.Size()
}
func (m *Infra) XXX_DiscardUnknown() {
	xxx_messageInfo_Infra.DiscardUnknown(m)
}

var xxx_messageInfo_Infra proto.InternalMessageInfo

func (m *Infra) GetProvider() Provider {
	if m != nil {
		return m.Provider
	}
	return UNKNOWN
}

func (m *Infra) GetInstanceId() string {
	if m != nil {
		return m.InstanceId
	}
	return ""
}

func (m *Infra) GetZone() string {
	if m != nil {
		return m.Zone
	}
	return ""
}

func (m *Infra) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}

func (m *Infra) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Infra) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *Infra) GetMachineId() string {
	if m != nil {
		return m.MachineId
	}
	return ""
}

func (m *Infra) GetInterfaces() map[string]*Interface {
	if m != nil {
		return m.Interfaces
	}
	return nil
}

func (m *Infra) GetHwInfo() *site.OsInfo {
	if m != nil {
		return m.HwInfo
	}
	return nil
}

func (m *Infra) GetCertifiedHw() string {
	if m != nil {
		return m.CertifiedHw
	}
	return ""
}

func (m *Infra) GetInternetProxy() *InternetProxy {
	if m != nil {
		return m.InternetProxy
	}
	return nil
}

func (m *Infra) GetTimestamp() *types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

// Internet Proxy configuration
//
// x-displayName: "Internet Proxy Configuration"
// Proxy describes options for HTTP or HTTPS proxy configurations
type InternetProxy struct {
	// Http Proxy
	//
	// x-displayName: "HTTP PROXY"
	// It will be used as the proxy URL for HTTP requests and HTTPS requests unless overridden by HTTPSProxy or NoProxy.
	// x-example: "http://USERNAME:PASSWORD@10.0.1.1:8080/"
	HttpProxy string `protobuf:"bytes,1,opt,name=http_proxy,json=httpProxy,proto3" json:"http_proxy,omitempty"`
	// Https Proxy
	//
	// x-displayName: "HTTPS PROXY"
	// It will be used as the proxy URL for HTTPS requests unless overridden by NoProxy.
	// x-example: "https://USERNAME:PASSWORD@10.0.0.1:8080/"
	HttpsProxy string `protobuf:"bytes,2,opt,name=https_proxy,json=httpsProxy,proto3" json:"https_proxy,omitempty"`
	// No Proxy
	//
	// x-displayName: "NO PROXY"
	// It specifies a string that contains comma-separated values
	// specifying hosts that should be excluded from proxying. Each value is
	// represented by an IP address prefix (1.2.3.4), an IP address prefix in
	// CIDR notation (1.2.3.4/8), a domain name, or a special DNS label (*).
	// An IP address prefix and domain name can also include a literal port
	// number (1.2.3.4:80).
	// A domain name matches that name and all subdomains. A domain name with
	// a leading "." matches subdomains only. For example "foo.com" matches
	// "foo.com" and "bar.foo.com"; ".y.com" matches "x.y.com" but not "y.com".
	// A single asterisk (*) indicates that no proxying should be done.
	// x-example: "master.hostname.example.com,10.1.0.0/16,172.30.0.0/16"
	NoProxy string `protobuf:"bytes,3,opt,name=no_proxy,json=noProxy,proto3" json:"no_proxy,omitempty"`
	// Proxy CA certificate URL
	//
	// x-displayName: "Proxy CA certificate URL"
	// Allow optional different trust-store for proxy in HTTP CONNECT step
	// by picking proxy ca certificate value.
	// x-example: "string:///LS0tLS1CRUdJTiBDRxxxx"
	ProxyCacertUrl string `protobuf:"bytes,4,opt,name=proxy_cacert_url,json=proxyCacertUrl,proto3" json:"proxy_cacert_url,omitempty"`
}

func (m *InternetProxy) Reset()      { *m = InternetProxy{} }
func (*InternetProxy) ProtoMessage() {}
func (*InternetProxy) Descriptor() ([]byte, []int) {
	return fileDescriptor_77378b39a994305d, []int{1}
}
func (m *InternetProxy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InternetProxy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InternetProxy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InternetProxy.Merge(m, src)
}
func (m *InternetProxy) XXX_Size() int {
	return m.Size()
}
func (m *InternetProxy) XXX_DiscardUnknown() {
	xxx_messageInfo_InternetProxy.DiscardUnknown(m)
}

var xxx_messageInfo_InternetProxy proto.InternalMessageInfo

func (m *InternetProxy) GetHttpProxy() string {
	if m != nil {
		return m.HttpProxy
	}
	return ""
}

func (m *InternetProxy) GetHttpsProxy() string {
	if m != nil {
		return m.HttpsProxy
	}
	return ""
}

func (m *InternetProxy) GetNoProxy() string {
	if m != nil {
		return m.NoProxy
	}
	return ""
}

func (m *InternetProxy) GetProxyCacertUrl() string {
	if m != nil {
		return m.ProxyCacertUrl
	}
	return ""
}

// Machine interface
//
// x-displayName: "Machine Interface"
// Interface describe network interface
type Interface struct {
	// IP Address
	//
	// x-displayName: "IP Address"
	// x-example: "192.168.100.1"
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	// Prefix length
	//
	// x-displayName: "IP Prefix"
	// x-example: "24"
	Plen int32 `protobuf:"varint,2,opt,name=plen,proto3" json:"plen,omitempty"`
	// Interface name
	//
	// x-displayName: "Interface Name"
	// x-example: "eth0"
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Interface) Reset()      { *m = Interface{} }
func (*Interface) ProtoMessage() {}
func (*Interface) Descriptor() ([]byte, []int) {
	return fileDescriptor_77378b39a994305d, []int{2}
}
func (m *Interface) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Interface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Interface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Interface.Merge(m, src)
}
func (m *Interface) XXX_Size() int {
	return m.Size()
}
func (m *Interface) XXX_DiscardUnknown() {
	xxx_messageInfo_Interface.DiscardUnknown(m)
}

var xxx_messageInfo_Interface proto.InternalMessageInfo

func (m *Interface) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *Interface) GetPlen() int32 {
	if m != nil {
		return m.Plen
	}
	return 0
}

func (m *Interface) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Shape of the registration specification
//
// x-displayName: "Global Specification"
type GlobalSpecType struct {
	// Infra
	//
	// x-displayName: "Infrastructure"
	// x-required
	// Infrastructure metadata section
	Infra *Infra `protobuf:"bytes,1,opt,name=infra,proto3" json:"infra,omitempty"`
	// Token
	//
	// x-displayName: "Token"
	// x-example: "value"
	// x-required
	// Token is used for machine and tenant identification
	Token string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	// Passport
	//
	// x-displayName: "Passport"
	// x-required
	// Passport is storing identification for instance as site name, latitude, longitude, etc.
	Passport *Passport `protobuf:"bytes,3,opt,name=passport,proto3" json:"passport,omitempty"`
	// Site
	//
	// x-displayName: "Site"
	// Site for this registration, assigned after registration is assigned to site.
	Site []*schema.ObjectRefType `protobuf:"bytes,4,rep,name=site,proto3" json:"site,omitempty"`
	// Instance role
	//
	// x-displayName: "Role"
	// x-example: "k8s-master, etcd"
	// Role of registered node. Used by system to determine what roles should be enforced.
	Role []string `protobuf:"bytes,5,rep,name=role,proto3" json:"role,omitempty"`
	// Site to site tunnel type
	//
	// x-displayName: "Site to Site Tunnel Type"
	// Tunnel type specifies the type of tunnel to be used for traffic between the sites.
	TunnelType schema.SiteToSiteTunnelType `protobuf:"varint,6,opt,name=tunnel_type,json=tunnelType,proto3,enum=ves.io.schema.SiteToSiteTunnelType" json:"tunnel_type,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_77378b39a994305d, []int{3}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

func (m *GlobalSpecType) GetInfra() *Infra {
	if m != nil {
		return m.Infra
	}
	return nil
}

func (m *GlobalSpecType) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *GlobalSpecType) GetPassport() *Passport {
	if m != nil {
		return m.Passport
	}
	return nil
}

func (m *GlobalSpecType) GetSite() []*schema.ObjectRefType {
	if m != nil {
		return m.Site
	}
	return nil
}

func (m *GlobalSpecType) GetRole() []string {
	if m != nil {
		return m.Role
	}
	return nil
}

func (m *GlobalSpecType) GetTunnelType() schema.SiteToSiteTunnelType {
	if m != nil {
		return m.TunnelType
	}
	return schema.SITE_TO_SITE_TUNNEL_IPSEC_OR_SSL
}

// Passport
//
// x-displayName: "Passport"
// Passport stores information about identification and node configuration provided by CE during registration. It can be manually updated by user during approval.
type Passport struct {
	// cluster_name
	//
	// x-displayName: "Cluster Name"
	// x-example: "acme-ce01"
	// x-required
	ClusterName string `protobuf:"bytes,1,opt,name=cluster_name,json=clusterName,proto3" json:"cluster_name,omitempty"`
	// cluster_type
	//
	// x-displayName: "Cluster Type"
	// x-example: "ce"
	// x-required
	ClusterType string `protobuf:"bytes,2,opt,name=cluster_type,json=clusterType,proto3" json:"cluster_type,omitempty"`
	// Latitude
	//
	// x-displayName: "Latitude"
	// x-example: "49.3156733"
	// x-required
	// Geographic location of this site
	Latitude float32 `protobuf:"fixed32,7,opt,name=latitude,proto3" json:"latitude,omitempty"`
	// Longitude
	//
	// x-displayName: "Longitude"
	// x-example: "14.2484333"
	// x-required
	// Geographic location of this site
	Longitude float32 `protobuf:"fixed32,8,opt,name=longitude,proto3" json:"longitude,omitempty"`
	// Cluster size
	//
	// x-displayName: "Cluster Size"
	// x-example: "3"
	// Defines how many master nodes is in the cluster, only 1 or 3 is allowed
	// 1 - cluster have single master, without HA
	// 3 - cluster have 3 masters, with HA, all nodes should be allowed at same time, cluster won't start until ALL nodes are ADMITTED
	// 0 - same as 1
	// This value can't be changed after installation.
	// It does not interact with auto-scaling as only pool nodes are scaled.
	ClusterSize int32 `protobuf:"varint,9,opt,name=cluster_size,json=clusterSize,proto3" json:"cluster_size,omitempty"`
	// VPM version
	//
	// x-displayName: "VPM Version"
	// x-example: "value"
	// vpm version used for registration
	// it'll be used to refuse registration from old vpms
	// Local control plane to manage volterra software appliance
	VpmVersion string `protobuf:"bytes,10,opt,name=vpm_version,json=vpmVersion,proto3" json:"vpm_version,omitempty"`
	// Private Network Name
	//
	// x-displayName: "Private Network Name"
	// x-example: "private-ntw"
	// Private Network name for private access connectivity to F5XC ADN.
	// It is used for PrivateLink, CloudLink and L3VPN.
	PrivateNetworkName string `protobuf:"bytes,11,opt,name=private_network_name,json=privateNetworkName,proto3" json:"private_network_name,omitempty"`
	// Select F5XC Software Version
	//
	// x-displayName: "Select F5XC Software Version"
	// F5XC Software Version is optional parameter, which allows to specify target SW version for particular site e.g. crt-20210329-1002.
	// If not specified, latest available version is used. If existing site/fleet already has version, this value is ignored.
	//
	// Types that are valid to be assigned to VolterraSwVersionChoice:
	//	*Passport_DefaultSwVersion
	//	*Passport_VolterraSoftwareVersion
	VolterraSwVersionChoice isPassport_VolterraSwVersionChoice `protobuf_oneof:"volterra_sw_version_choice"`
	// Select Operating System Version
	//
	// x-displayName: "Select Operating System Version"
	// Operating System Version is optional parameter, which allows to specify target SW version for particular site e.g. 7.2009.10.
	// If not specified, latest available version is used. If existing site/fleet already has version, this value is ignored.
	//
	// Types that are valid to be assigned to OperatingSystemVersionChoice:
	//	*Passport_DefaultOsVersion
	//	*Passport_OperatingSystemVersion
	OperatingSystemVersionChoice isPassport_OperatingSystemVersionChoice `protobuf_oneof:"operating_system_version_choice"`
}

func (m *Passport) Reset()      { *m = Passport{} }
func (*Passport) ProtoMessage() {}
func (*Passport) Descriptor() ([]byte, []int) {
	return fileDescriptor_77378b39a994305d, []int{4}
}
func (m *Passport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Passport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Passport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Passport.Merge(m, src)
}
func (m *Passport) XXX_Size() int {
	return m.Size()
}
func (m *Passport) XXX_DiscardUnknown() {
	xxx_messageInfo_Passport.DiscardUnknown(m)
}

var xxx_messageInfo_Passport proto.InternalMessageInfo

type isPassport_VolterraSwVersionChoice interface {
	isPassport_VolterraSwVersionChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isPassport_OperatingSystemVersionChoice interface {
	isPassport_OperatingSystemVersionChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Passport_DefaultSwVersion struct {
	DefaultSwVersion *schema.Empty `protobuf:"bytes,13,opt,name=default_sw_version,json=defaultSwVersion,proto3,oneof" json:"default_sw_version,omitempty"`
}
type Passport_VolterraSoftwareVersion struct {
	VolterraSoftwareVersion string `protobuf:"bytes,14,opt,name=volterra_software_version,json=volterraSoftwareVersion,proto3,oneof" json:"volterra_software_version,omitempty"`
}
type Passport_DefaultOsVersion struct {
	DefaultOsVersion *schema.Empty `protobuf:"bytes,16,opt,name=default_os_version,json=defaultOsVersion,proto3,oneof" json:"default_os_version,omitempty"`
}
type Passport_OperatingSystemVersion struct {
	OperatingSystemVersion string `protobuf:"bytes,17,opt,name=operating_system_version,json=operatingSystemVersion,proto3,oneof" json:"operating_system_version,omitempty"`
}

func (*Passport_DefaultSwVersion) isPassport_VolterraSwVersionChoice()            {}
func (*Passport_VolterraSoftwareVersion) isPassport_VolterraSwVersionChoice()     {}
func (*Passport_DefaultOsVersion) isPassport_OperatingSystemVersionChoice()       {}
func (*Passport_OperatingSystemVersion) isPassport_OperatingSystemVersionChoice() {}

func (m *Passport) GetVolterraSwVersionChoice() isPassport_VolterraSwVersionChoice {
	if m != nil {
		return m.VolterraSwVersionChoice
	}
	return nil
}
func (m *Passport) GetOperatingSystemVersionChoice() isPassport_OperatingSystemVersionChoice {
	if m != nil {
		return m.OperatingSystemVersionChoice
	}
	return nil
}

func (m *Passport) GetClusterName() string {
	if m != nil {
		return m.ClusterName
	}
	return ""
}

func (m *Passport) GetClusterType() string {
	if m != nil {
		return m.ClusterType
	}
	return ""
}

func (m *Passport) GetLatitude() float32 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *Passport) GetLongitude() float32 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *Passport) GetClusterSize() int32 {
	if m != nil {
		return m.ClusterSize
	}
	return 0
}

func (m *Passport) GetVpmVersion() string {
	if m != nil {
		return m.VpmVersion
	}
	return ""
}

func (m *Passport) GetPrivateNetworkName() string {
	if m != nil {
		return m.PrivateNetworkName
	}
	return ""
}

func (m *Passport) GetDefaultSwVersion() *schema.Empty {
	if x, ok := m.GetVolterraSwVersionChoice().(*Passport_DefaultSwVersion); ok {
		return x.DefaultSwVersion
	}
	return nil
}

func (m *Passport) GetVolterraSoftwareVersion() string {
	if x, ok := m.GetVolterraSwVersionChoice().(*Passport_VolterraSoftwareVersion); ok {
		return x.VolterraSoftwareVersion
	}
	return ""
}

func (m *Passport) GetDefaultOsVersion() *schema.Empty {
	if x, ok := m.GetOperatingSystemVersionChoice().(*Passport_DefaultOsVersion); ok {
		return x.DefaultOsVersion
	}
	return nil
}

func (m *Passport) GetOperatingSystemVersion() string {
	if x, ok := m.GetOperatingSystemVersionChoice().(*Passport_OperatingSystemVersion); ok {
		return x.OperatingSystemVersion
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Passport) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Passport_DefaultSwVersion)(nil),
		(*Passport_VolterraSoftwareVersion)(nil),
		(*Passport_DefaultOsVersion)(nil),
		(*Passport_OperatingSystemVersion)(nil),
	}
}

// Workload context
//
// x-displayName: "Workload Context"
// WorkloadContext defines context for workload templates and infrastructure configuration
// used in vpm
type WorkloadContext struct {
	// Params
	//
	// x-displayName: "Params"
	// x-example: "value"
	// map of workload params
	Params map[string]string `protobuf:"bytes,1,rep,name=params,proto3" json:"params,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// AppName
	//
	// x-displayName: "App Name"
	// x-example: "phobos"
	// application type name
	AppName string `protobuf:"bytes,2,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
}

func (m *WorkloadContext) Reset()      { *m = WorkloadContext{} }
func (*WorkloadContext) ProtoMessage() {}
func (*WorkloadContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_77378b39a994305d, []int{5}
}
func (m *WorkloadContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkloadContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WorkloadContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkloadContext.Merge(m, src)
}
func (m *WorkloadContext) XXX_Size() int {
	return m.Size()
}
func (m *WorkloadContext) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkloadContext.DiscardUnknown(m)
}

var xxx_messageInfo_WorkloadContext proto.InternalMessageInfo

func (m *WorkloadContext) GetParams() map[string]string {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *WorkloadContext) GetAppName() string {
	if m != nil {
		return m.AppName
	}
	return ""
}

// Create registration
//
// x-displayName: "Create Registration"
// VPM creates registration using this message, never used by users.
type CreateSpecType struct {
	Infra    *Infra    `protobuf:"bytes,1,opt,name=infra,proto3" json:"infra,omitempty"`
	Token    string    `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	Passport *Passport `protobuf:"bytes,3,opt,name=passport,proto3" json:"passport,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_77378b39a994305d, []int{6}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

func (m *CreateSpecType) GetInfra() *Infra {
	if m != nil {
		return m.Infra
	}
	return nil
}

func (m *CreateSpecType) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *CreateSpecType) GetPassport() *Passport {
	if m != nil {
		return m.Passport
	}
	return nil
}

// Replace registration
//
// x-displayName: "Replace Registration"
// NO fields are allowed to be replaced
type ReplaceSpecType struct {
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_77378b39a994305d, []int{7}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

// Get registration
//
// x-displayName: "Get Registration"
// Get registration specification
type GetSpecType struct {
	Infra    *Infra    `protobuf:"bytes,1,opt,name=infra,proto3" json:"infra,omitempty"`
	Token    string    `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	Passport *Passport `protobuf:"bytes,3,opt,name=passport,proto3" json:"passport,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_77378b39a994305d, []int{8}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

func (m *GetSpecType) GetInfra() *Infra {
	if m != nil {
		return m.Infra
	}
	return nil
}

func (m *GetSpecType) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *GetSpecType) GetPassport() *Passport {
	if m != nil {
		return m.Passport
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.registration.Provider", Provider_name, Provider_value)
	golang_proto.RegisterEnum("ves.io.schema.registration.Provider", Provider_name, Provider_value)
	proto.RegisterEnum("ves.io.schema.registration.ObjectState", ObjectState_name, ObjectState_value)
	golang_proto.RegisterEnum("ves.io.schema.registration.ObjectState", ObjectState_name, ObjectState_value)
	proto.RegisterType((*Infra)(nil), "ves.io.schema.registration.Infra")
	golang_proto.RegisterType((*Infra)(nil), "ves.io.schema.registration.Infra")
	proto.RegisterMapType((map[string]*Interface)(nil), "ves.io.schema.registration.Infra.InterfacesEntry")
	golang_proto.RegisterMapType((map[string]*Interface)(nil), "ves.io.schema.registration.Infra.InterfacesEntry")
	proto.RegisterType((*InternetProxy)(nil), "ves.io.schema.registration.InternetProxy")
	golang_proto.RegisterType((*InternetProxy)(nil), "ves.io.schema.registration.InternetProxy")
	proto.RegisterType((*Interface)(nil), "ves.io.schema.registration.Interface")
	golang_proto.RegisterType((*Interface)(nil), "ves.io.schema.registration.Interface")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.registration.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.registration.GlobalSpecType")
	proto.RegisterType((*Passport)(nil), "ves.io.schema.registration.Passport")
	golang_proto.RegisterType((*Passport)(nil), "ves.io.schema.registration.Passport")
	proto.RegisterType((*WorkloadContext)(nil), "ves.io.schema.registration.WorkloadContext")
	golang_proto.RegisterType((*WorkloadContext)(nil), "ves.io.schema.registration.WorkloadContext")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.registration.WorkloadContext.ParamsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.registration.WorkloadContext.ParamsEntry")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.registration.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.registration.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.registration.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.registration.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.registration.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.registration.GetSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/registration/types.proto", fileDescriptor_77378b39a994305d)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/registration/types.proto", fileDescriptor_77378b39a994305d)
}

var fileDescriptor_77378b39a994305d = []byte{
	// 1780 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x57, 0x4b, 0x6f, 0x1b, 0xc9,
	0x11, 0x66, 0xf3, 0x39, 0x6c, 0xea, 0xd1, 0xea, 0x28, 0x0e, 0xcd, 0xac, 0x69, 0xad, 0xb2, 0x1b,
	0x68, 0x37, 0x14, 0x19, 0x4a, 0xf2, 0xfa, 0xb1, 0x80, 0xb1, 0x24, 0x35, 0x2b, 0x53, 0x8f, 0x19,
	0x66, 0x86, 0x92, 0x02, 0x5f, 0x06, 0x23, 0xb2, 0x49, 0x4d, 0x34, 0x9c, 0x1e, 0xcc, 0xb4, 0x48,
	0xcb, 0x80, 0x81, 0x20, 0x3f, 0x20, 0xc8, 0x21, 0xc8, 0xc1, 0xf9, 0x03, 0x41, 0xce, 0x7b, 0x48,
	0xa2, 0x8b, 0x91, 0x5c, 0x82, 0x9c, 0x74, 0x34, 0x0c, 0x04, 0x88, 0xe5, 0xcb, 0xee, 0x6d, 0xb1,
	0xbf, 0x20, 0xe8, 0x9e, 0xe1, 0x88, 0xe2, 0x66, 0x6d, 0x24, 0xc7, 0x5c, 0xc8, 0xae, 0xaa, 0xaf,
	0xaa, 0xbe, 0xae, 0xae, 0xae, 0x26, 0xe1, 0x8f, 0x87, 0xc4, 0x2f, 0x5b, 0xb4, 0xe2, 0x77, 0x8e,
	0xc9, 0xc0, 0xac, 0x78, 0xa4, 0x6f, 0xf9, 0xcc, 0x33, 0x99, 0x45, 0x9d, 0x0a, 0x3b, 0x73, 0x89,
	0x5f, 0x76, 0x3d, 0xca, 0x28, 0x2e, 0x04, 0xb8, 0x72, 0x80, 0x2b, 0x4f, 0xe2, 0x0a, 0xab, 0x7d,
	0x8b, 0x1d, 0x9f, 0x1e, 0x95, 0x3b, 0x74, 0x50, 0xe9, 0xd3, 0x3e, 0xad, 0x08, 0x97, 0xa3, 0xd3,
	0x9e, 0x90, 0x84, 0x20, 0x56, 0x41, 0xa8, 0xc2, 0xed, 0x3e, 0xa5, 0x7d, 0x9b, 0x5c, 0xa1, 0x98,
	0x35, 0x20, 0x3e, 0x33, 0x07, 0x6e, 0x08, 0xf8, 0xe1, 0x75, 0x4e, 0xd4, 0xe5, 0x59, 0x42, 0x22,
	0x85, 0xe2, 0x75, 0xa3, 0x6f, 0x31, 0x32, 0x49, 0xb4, 0x70, 0xf3, 0xba, 0x7d, 0xd2, 0xf4, 0xde,
	0x75, 0xd3, 0xd0, 0xb4, 0xad, 0xae, 0xc9, 0x48, 0x68, 0x5d, 0x9a, 0xb2, 0x5a, 0x64, 0x64, 0x5c,
	0x4b, 0xbd, 0xfc, 0xfb, 0x14, 0x4c, 0x35, 0x9d, 0x9e, 0x67, 0xe2, 0xcf, 0xa0, 0xe4, 0x7a, 0x74,
	0x68, 0x75, 0x89, 0x97, 0x07, 0x4b, 0x60, 0x65, 0x6e, 0xed, 0x83, 0xf2, 0x77, 0x17, 0xa8, 0xdc,
	0x0a, 0xb1, 0x5a, 0xe4, 0x85, 0x6f, 0xc3, 0x9c, 0xe5, 0xf8, 0xcc, 0x74, 0x3a, 0xc4, 0xb0, 0xba,
	0xf9, 0xf8, 0x12, 0x58, 0xc9, 0x6a, 0x70, 0xac, 0x6a, 0x76, 0x31, 0x86, 0xc9, 0xa7, 0xd4, 0x21,
	0xf9, 0x84, 0xb0, 0x88, 0x35, 0xfe, 0x09, 0x5c, 0x30, 0x87, 0xa6, 0x65, 0x9b, 0x47, 0x96, 0x6d,
	0xb1, 0x33, 0x43, 0x00, 0x72, 0x02, 0x80, 0x26, 0x0d, 0x8f, 0x39, 0xb8, 0x00, 0xa5, 0x63, 0xea,
	0x33, 0xc7, 0x1c, 0x90, 0x7c, 0x52, 0x60, 0x22, 0x19, 0xdf, 0x80, 0xe9, 0x2e, 0x1d, 0x98, 0x96,
	0x93, 0xcf, 0x08, 0x4b, 0x28, 0xe1, 0x5b, 0x10, 0x0e, 0xcc, 0xce, 0xb1, 0xe5, 0x08, 0x52, 0x29,
	0x61, 0xcb, 0x86, 0x9a, 0x66, 0x17, 0xff, 0x0c, 0x42, 0xcb, 0x61, 0xc4, 0xeb, 0x99, 0x1d, 0xe2,
	0xe7, 0xd3, 0x4b, 0x89, 0x95, 0xdc, 0x5a, 0xf5, 0x6d, 0x1b, 0x17, 0xd5, 0x2a, 0x37, 0x23, 0x1f,
	0xd9, 0x61, 0xde, 0x99, 0x36, 0x11, 0x04, 0xaf, 0xc3, 0xcc, 0xf1, 0xc8, 0xb0, 0x9c, 0x1e, 0xcd,
	0x4b, 0x4b, 0x60, 0x25, 0xb7, 0x56, 0x98, 0x8a, 0xc7, 0x0f, 0xb8, 0xac, 0xfa, 0x4d, 0xa7, 0x47,
	0xb5, 0xf4, 0xf1, 0x88, 0x7f, 0xe3, 0xf7, 0xe1, 0x4c, 0x87, 0x78, 0xcc, 0xea, 0x59, 0xa4, 0x6b,
	0x1c, 0x8f, 0xf2, 0x59, 0x41, 0x34, 0x17, 0xe9, 0x1e, 0x8d, 0x70, 0x0b, 0xce, 0x89, 0x2c, 0x0e,
	0x61, 0x86, 0xeb, 0xd1, 0x27, 0x67, 0x79, 0x28, 0xc2, 0x7f, 0xf4, 0x76, 0xba, 0x81, 0x47, 0x8b,
	0x3b, 0x68, 0xb3, 0xd6, 0xa4, 0x88, 0xef, 0xc1, 0x6c, 0xd4, 0xa8, 0xf9, 0x99, 0x90, 0x6b, 0xd0,
	0xca, 0xe5, 0x71, 0x2b, 0x97, 0xdb, 0x63, 0x84, 0x76, 0x05, 0x2e, 0x74, 0xe1, 0xfc, 0x54, 0x09,
	0x30, 0x82, 0x89, 0x13, 0x72, 0x26, 0x7a, 0x27, 0xab, 0xf1, 0x25, 0xfe, 0x14, 0xa6, 0x86, 0xa6,
	0x7d, 0x4a, 0x44, 0x2b, 0xe4, 0xd6, 0x3e, 0x7c, 0x27, 0x4f, 0x1e, 0x4d, 0x0b, 0x7c, 0x1e, 0xc4,
	0xef, 0x81, 0xe5, 0xdf, 0x02, 0x38, 0x7b, 0x6d, 0x03, 0xfc, 0x34, 0x8f, 0x19, 0x73, 0xc3, 0xfd,
	0x07, 0xb9, 0xb2, 0x5c, 0x13, 0x98, 0x6f, 0xc3, 0x1c, 0x17, 0xfc, 0xd0, 0x1e, 0xb6, 0xa0, 0x50,
	0x05, 0x80, 0x9b, 0x50, 0x72, 0x68, 0x68, 0x0d, 0xda, 0x30, 0xe3, 0xd0, 0xc0, 0xb4, 0x02, 0x91,
	0xd0, 0x1b, 0x1d, 0x93, 0x57, 0xdd, 0x38, 0xf5, 0xec, 0xb0, 0xc9, 0xe6, 0x84, 0xbe, 0x21, 0xd4,
	0xfb, 0x9e, 0xbd, 0xbc, 0x05, 0xb3, 0x11, 0x5d, 0xde, 0xd4, 0x66, 0xb7, 0xeb, 0x85, 0x5c, 0xc4,
	0x9a, 0xeb, 0x5c, 0x9b, 0x38, 0x22, 0x7f, 0x4a, 0x13, 0x6b, 0xae, 0x13, 0x7d, 0x1b, 0x36, 0x3f,
	0x5f, 0x2f, 0x7f, 0x15, 0x87, 0x73, 0x5b, 0x36, 0x3d, 0x32, 0x6d, 0xdd, 0x25, 0x9d, 0xf6, 0x99,
	0x4b, 0xf0, 0x5d, 0x98, 0xb2, 0x78, 0x87, 0x89, 0x78, 0xb9, 0xb5, 0xf7, 0xdf, 0xd9, 0x8a, 0x5a,
	0x80, 0xc7, 0x8b, 0x30, 0xc5, 0xe8, 0x49, 0x98, 0x34, 0xab, 0x05, 0x82, 0xb8, 0xd5, 0xa6, 0xef,
	0xbb, 0xd4, 0x63, 0x22, 0x73, 0xee, 0x1d, 0xb7, 0x3a, 0xc4, 0x6a, 0x91, 0x17, 0xbe, 0x0f, 0x93,
	0xbc, 0x5f, 0xf3, 0x49, 0x71, 0x35, 0xde, 0x9b, 0xf2, 0x56, 0x8f, 0x7e, 0x41, 0x3a, 0x4c, 0x23,
	0x3d, 0x4e, 0xbe, 0x9e, 0xf9, 0xe3, 0x33, 0x01, 0xd6, 0xc4, 0x27, 0xdf, 0xb2, 0x47, 0x6d, 0x92,
	0x4f, 0x2d, 0x25, 0xf8, 0x96, 0xf9, 0x1a, 0x8f, 0x60, 0x8e, 0x9d, 0x3a, 0x0e, 0xb1, 0x0d, 0x3e,
	0xc6, 0xf2, 0x69, 0x31, 0x69, 0x7e, 0x34, 0x15, 0x55, 0xb7, 0x18, 0x69, 0x53, 0xf1, 0x29, 0xb0,
	0x22, 0x78, 0xf5, 0xd5, 0x39, 0x58, 0xd2, 0x9b, 0x6d, 0xd9, 0x68, 0xab, 0x46, 0xf0, 0xbd, 0xaf,
	0x28, 0xf2, 0xae, 0xd1, 0x6c, 0xe9, 0x72, 0xc3, 0x50, 0x35, 0x43, 0xd7, 0x77, 0xff, 0xf2, 0xd5,
	0x8b, 0x84, 0xf4, 0x2b, 0x90, 0x2a, 0x24, 0x62, 0x20, 0xae, 0x41, 0x16, 0xb9, 0x2f, 0xff, 0x2e,
	0x0d, 0xa5, 0xf1, 0xf6, 0xc4, 0x6d, 0xb3, 0x4f, 0x7d, 0x46, 0x3c, 0x43, 0x1c, 0x0a, 0x08, 0x6f,
	0x5b, 0xa0, 0x53, 0xf8, 0x3c, 0xf9, 0xe8, 0x0a, 0x22, 0x98, 0x8a, 0xb2, 0xd6, 0xd3, 0xaf, 0xce,
	0x41, 0xbc, 0x43, 0x22, 0xa8, 0x38, 0xb3, 0x55, 0x28, 0xd9, 0x26, 0xb3, 0xd8, 0x69, 0x97, 0x88,
	0xe1, 0x13, 0xaf, 0x2f, 0x70, 0x1e, 0x33, 0x10, 0xde, 0x8a, 0xc5, 0xbe, 0xa8, 0xaf, 0xc6, 0x62,
	0x5f, 0xfc, 0x55, 0x8b, 0x20, 0xb8, 0x02, 0xb3, 0x36, 0x75, 0xfa, 0x01, 0x5e, 0x9a, 0xc6, 0x6f,
	0x34, 0x56, 0x63, 0xb1, 0x8d, 0xbf, 0x69, 0x57, 0x18, 0x5c, 0xb9, 0xa2, 0xe2, 0x5b, 0x4f, 0x89,
	0x98, 0x0d, 0xa9, 0xfa, 0x0c, 0xf7, 0xc9, 0x14, 0x52, 0x6b, 0x89, 0x18, 0x48, 0x44, 0x84, 0x74,
	0xeb, 0x29, 0xc1, 0x1f, 0xc2, 0xdc, 0xd0, 0x1d, 0x18, 0x43, 0xe2, 0xf9, 0x16, 0x75, 0xc4, 0x98,
	0xc8, 0xd6, 0x93, 0x5f, 0x9e, 0x03, 0xa0, 0xc1, 0xa1, 0x3b, 0x38, 0x08, 0xf4, 0xf8, 0x53, 0xb8,
	0xe8, 0x7a, 0xd6, 0xd0, 0x64, 0xc4, 0x70, 0x08, 0x1b, 0x51, 0xef, 0x24, 0xa8, 0x86, 0x18, 0xbf,
	0xf5, 0x2c, 0x8f, 0x9f, 0xf4, 0xe2, 0x2b, 0x9f, 0x69, 0x38, 0x84, 0x29, 0x01, 0x4a, 0xd4, 0x67,
	0x13, 0xe2, 0x2e, 0xe9, 0x99, 0xa7, 0x36, 0x33, 0xfc, 0x51, 0x94, 0x6a, 0x56, 0xf4, 0xd8, 0xe2,
	0xd4, 0x79, 0xca, 0x03, 0x97, 0x9d, 0x3d, 0x8a, 0x69, 0x28, 0xf4, 0xd0, 0x47, 0x63, 0x0a, 0x5b,
	0xf0, 0xe6, 0x90, 0xda, 0x8c, 0x78, 0x9e, 0x69, 0xf8, 0xb4, 0xc7, 0x46, 0xa6, 0x47, 0xa2, 0x60,
	0x73, 0xd7, 0x78, 0xe4, 0x17, 0x1f, 0xc5, 0xb4, 0x1f, 0x8c, 0xd1, 0x7a, 0x08, 0x1e, 0x07, 0x9a,
	0xa0, 0x43, 0xfd, 0x28, 0x02, 0x7a, 0x0b, 0x1d, 0x10, 0xd1, 0x51, 0xfd, 0x71, 0x14, 0x19, 0xe6,
	0xa9, 0x4b, 0xf8, 0x65, 0x70, 0xfa, 0x86, 0x7f, 0xe6, 0x33, 0x72, 0x55, 0xc5, 0x85, 0x69, 0x36,
	0x40, 0xbb, 0x11, 0x81, 0x75, 0x81, 0x0d, 0xc3, 0x3c, 0x58, 0xfa, 0xe6, 0xe1, 0xad, 0x6a, 0x69,
	0xad, 0x74, 0xbf, 0x74, 0xb7, 0x74, 0xaf, 0xb4, 0x51, 0xba, 0x53, 0xfa, 0xa4, 0x54, 0xfd, 0x69,
	0x69, 0xbd, 0x54, 0xad, 0x96, 0xaa, 0x6b, 0xa5, 0xea, 0x9d, 0x7a, 0x05, 0x16, 0xae, 0xf6, 0x1d,
	0x95, 0xcf, 0xe8, 0x1c, 0x53, 0xab, 0x43, 0xf0, 0xc2, 0x8b, 0x73, 0x30, 0x7b, 0x71, 0x0e, 0x66,
	0x2e, 0xcf, 0x41, 0xaa, 0xba, 0x5e, 0xaa, 0x6e, 0xd4, 0x37, 0xe0, 0xed, 0xef, 0x62, 0x36, 0xe9,
	0x85, 0x2e, 0xce, 0xc1, 0xbc, 0xf0, 0xfa, 0xa4, 0x54, 0xbd, 0xbb, 0x9d, 0x94, 0x12, 0x28, 0xb9,
	0x9d, 0x94, 0x92, 0x28, 0xb5, 0x9d, 0x94, 0x52, 0x28, 0xbd, 0x9d, 0x94, 0xd2, 0x28, 0xb3, 0x9d,
	0x94, 0x66, 0xd0, 0xec, 0x76, 0x52, 0x9a, 0x47, 0x68, 0xf9, 0x4f, 0x00, 0xce, 0x1f, 0x52, 0xef,
	0xc4, 0xa6, 0x66, 0xb7, 0x41, 0x1d, 0x46, 0x9e, 0x30, 0xac, 0xc2, 0xb4, 0x6b, 0x7a, 0xe6, 0xc0,
	0xcf, 0x03, 0x71, 0xed, 0xef, 0xbe, 0x6d, 0x68, 0x4c, 0x39, 0x97, 0x5b, 0xc2, 0x33, 0x78, 0x17,
	0xc3, 0x30, 0x7c, 0xee, 0x9a, 0xae, 0x1b, 0xb4, 0x57, 0x30, 0xa0, 0x32, 0xa6, 0xeb, 0xf2, 0x46,
	0x2a, 0xdc, 0x87, 0xb9, 0x09, 0x8f, 0xff, 0xf0, 0x8c, 0x2c, 0x4e, 0x3e, 0x23, 0xd9, 0xc9, 0xf7,
	0xe1, 0x9f, 0x00, 0xce, 0x35, 0x3c, 0x62, 0x32, 0x12, 0xcd, 0xcf, 0xda, 0x7f, 0x3b, 0x3f, 0xeb,
	0xd2, 0xf3, 0x67, 0x81, 0xcb, 0x78, 0x92, 0x16, 0xaf, 0x4d, 0x52, 0x61, 0x17, 0xf2, 0x78, 0xa6,
	0xee, 0xfd, 0x6f, 0x33, 0xb5, 0x9e, 0x7b, 0xfe, 0x2c, 0x72, 0xbc, 0x1a, 0xb0, 0x0f, 0x6e, 0xfe,
	0xe3, 0xe1, 0xd4, 0x23, 0xf0, 0xcd, 0xc3, 0x14, 0xef, 0x9e, 0xf5, 0xe5, 0x0f, 0xe0, 0xbc, 0x46,
	0x5c, 0xdb, 0xec, 0x44, 0xfb, 0x7b, 0xb0, 0xf0, 0x2d, 0xf4, 0xf2, 0x2b, 0x00, 0x73, 0x5b, 0x84,
	0xfd, 0x5f, 0x96, 0xe0, 0xe3, 0x3f, 0xc7, 0xa1, 0x34, 0xfe, 0xad, 0x89, 0x73, 0x30, 0xb3, 0xaf,
	0xec, 0x28, 0xea, 0xa1, 0x82, 0x62, 0x38, 0x03, 0x13, 0xb5, 0x43, 0x1d, 0x01, 0x0c, 0x61, 0x7a,
	0x4b, 0x55, 0xb7, 0x76, 0x65, 0x14, 0xc7, 0x59, 0x98, 0xaa, 0x3d, 0xde, 0xd7, 0x64, 0x94, 0xe0,
	0xea, 0x83, 0xbd, 0xc3, 0x9a, 0x26, 0xa3, 0x24, 0xc7, 0xee, 0x1c, 0xec, 0xa1, 0x14, 0xb7, 0xab,
	0xed, 0x47, 0xb2, 0x86, 0xd2, 0x78, 0x06, 0x4a, 0x07, 0xea, 0x6e, 0x5b, 0xd6, 0xb4, 0x1a, 0xca,
	0x70, 0xa9, 0x59, 0xdf, 0x6b, 0xec, 0xaa, 0xfb, 0x9b, 0x48, 0xc2, 0xf3, 0x30, 0x17, 0x26, 0x32,
	0x76, 0xee, 0xe9, 0x28, 0xcb, 0x33, 0xd7, 0x0e, 0x75, 0x21, 0x40, 0x2e, 0x6c, 0x35, 0x5a, 0x42,
	0xc8, 0xe1, 0x59, 0x98, 0x15, 0x19, 0x85, 0x38, 0x83, 0xe7, 0x20, 0x0c, 0xb2, 0x0a, 0x79, 0x96,
	0x63, 0x77, 0x0e, 0xf6, 0x84, 0x30, 0xc7, 0xb1, 0x22, 0xbb, 0x10, 0xe7, 0x31, 0x82, 0x33, 0x63,
	0x06, 0x42, 0x83, 0xb8, 0x66, 0xcc, 0x42, 0x68, 0x16, 0xb0, 0x04, 0x93, 0x9f, 0xdf, 0x51, 0x75,
	0x84, 0x79, 0x24, 0x4d, 0x97, 0xb5, 0xa6, 0xac, 0xa3, 0xef, 0xf1, 0x0d, 0xa9, 0x8d, 0x26, 0x5a,
	0xe4, 0x5a, 0x65, 0xbf, 0x5d, 0x53, 0x9a, 0x3f, 0x47, 0xdf, 0x17, 0xf1, 0x5b, 0xb2, 0xa2, 0xb7,
	0x6b, 0x8d, 0x1d, 0x74, 0xe3, 0xe3, 0xe7, 0x00, 0xe6, 0x82, 0x07, 0x5a, 0x67, 0x26, 0x23, 0xbc,
	0x22, 0x8a, 0xda, 0xd6, 0xe5, 0x76, 0x50, 0x3d, 0x45, 0x3e, 0x44, 0x80, 0x6f, 0xbc, 0xd6, 0x6a,
	0x69, 0xea, 0x81, 0xbc, 0x89, 0xe2, 0x42, 0xda, 0xdc, 0x6b, 0xb6, 0xdb, 0xf2, 0x26, 0x4a, 0x88,
	0x94, 0x72, 0xbb, 0xa9, 0xc9, 0x9b, 0x28, 0xc9, 0xbd, 0x3f, 0xaf, 0x35, 0x77, 0xe5, 0x4d, 0x94,
	0xe2, 0xac, 0x36, 0x55, 0x45, 0x46, 0x69, 0x0e, 0x69, 0xc9, 0xca, 0x66, 0x53, 0xd9, 0x42, 0x19,
	0x0e, 0x51, 0x95, 0xdd, 0xa6, 0x22, 0x23, 0x89, 0x73, 0xd9, 0x6f, 0x6d, 0x69, 0x35, 0x61, 0xca,
	0xf2, 0x8a, 0xee, 0xd5, 0x9a, 0x4a, 0x5b, 0x56, 0x6a, 0x4a, 0x43, 0x46, 0xb0, 0xfe, 0x6b, 0x70,
	0xf1, 0xba, 0x18, 0x7b, 0xf9, 0xba, 0x18, 0xfb, 0xfa, 0x75, 0x11, 0xfc, 0xf2, 0xb2, 0x08, 0xfe,
	0x70, 0x59, 0x04, 0x7f, 0xbf, 0x2c, 0x82, 0x8b, 0xcb, 0x22, 0x78, 0x79, 0x59, 0x04, 0xff, 0xba,
	0x2c, 0x82, 0x2f, 0x2f, 0x8b, 0xb1, 0xaf, 0x2f, 0x8b, 0xe0, 0x37, 0x6f, 0x8a, 0xb1, 0x17, 0x6f,
	0x8a, 0xe0, 0xe2, 0x4d, 0x31, 0xf6, 0xf2, 0x4d, 0x31, 0xf6, 0xb8, 0xd5, 0xa7, 0xee, 0x49, 0xbf,
	0x3c, 0x1e, 0xa2, 0xe5, 0x53, 0xbf, 0x22, 0x16, 0x3d, 0xea, 0x0d, 0x56, 0xc7, 0x7f, 0x49, 0x56,
	0xc7, 0xe6, 0x8a, 0x7b, 0xd4, 0xa7, 0x15, 0xf2, 0x84, 0x8d, 0xff, 0x62, 0x7d, 0xfb, 0xaf, 0xe1,
	0x51, 0x5a, 0xfc, 0xe2, 0x5d, 0xff, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x8f, 0x5c, 0x09, 0x85,
	0x3f, 0x0e, 0x00, 0x00,
}

func (x Provider) String() string {
	s, ok := Provider_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ObjectState) String() string {
	s, ok := ObjectState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Infra) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Infra)
	if !ok {
		that2, ok := that.(Infra)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Provider != that1.Provider {
		return false
	}
	if this.InstanceId != that1.InstanceId {
		return false
	}
	if this.Zone != that1.Zone {
		return false
	}
	if this.AvailabilityZone != that1.AvailabilityZone {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if this.Domain != that1.Domain {
		return false
	}
	if this.MachineId != that1.MachineId {
		return false
	}
	if len(this.Interfaces) != len(that1.Interfaces) {
		return false
	}
	for i := range this.Interfaces {
		if !this.Interfaces[i].Equal(that1.Interfaces[i]) {
			return false
		}
	}
	if !this.HwInfo.Equal(that1.HwInfo) {
		return false
	}
	if this.CertifiedHw != that1.CertifiedHw {
		return false
	}
	if !this.InternetProxy.Equal(that1.InternetProxy) {
		return false
	}
	if !this.Timestamp.Equal(that1.Timestamp) {
		return false
	}
	return true
}
func (this *InternetProxy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InternetProxy)
	if !ok {
		that2, ok := that.(InternetProxy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HttpProxy != that1.HttpProxy {
		return false
	}
	if this.HttpsProxy != that1.HttpsProxy {
		return false
	}
	if this.NoProxy != that1.NoProxy {
		return false
	}
	if this.ProxyCacertUrl != that1.ProxyCacertUrl {
		return false
	}
	return true
}
func (this *Interface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Interface)
	if !ok {
		that2, ok := that.(Interface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Addr != that1.Addr {
		return false
	}
	if this.Plen != that1.Plen {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Infra.Equal(that1.Infra) {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	if !this.Passport.Equal(that1.Passport) {
		return false
	}
	if len(this.Site) != len(that1.Site) {
		return false
	}
	for i := range this.Site {
		if !this.Site[i].Equal(that1.Site[i]) {
			return false
		}
	}
	if len(this.Role) != len(that1.Role) {
		return false
	}
	for i := range this.Role {
		if this.Role[i] != that1.Role[i] {
			return false
		}
	}
	if this.TunnelType != that1.TunnelType {
		return false
	}
	return true
}
func (this *Passport) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Passport)
	if !ok {
		that2, ok := that.(Passport)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClusterName != that1.ClusterName {
		return false
	}
	if this.ClusterType != that1.ClusterType {
		return false
	}
	if this.Latitude != that1.Latitude {
		return false
	}
	if this.Longitude != that1.Longitude {
		return false
	}
	if this.ClusterSize != that1.ClusterSize {
		return false
	}
	if this.VpmVersion != that1.VpmVersion {
		return false
	}
	if this.PrivateNetworkName != that1.PrivateNetworkName {
		return false
	}
	if that1.VolterraSwVersionChoice == nil {
		if this.VolterraSwVersionChoice != nil {
			return false
		}
	} else if this.VolterraSwVersionChoice == nil {
		return false
	} else if !this.VolterraSwVersionChoice.Equal(that1.VolterraSwVersionChoice) {
		return false
	}
	if that1.OperatingSystemVersionChoice == nil {
		if this.OperatingSystemVersionChoice != nil {
			return false
		}
	} else if this.OperatingSystemVersionChoice == nil {
		return false
	} else if !this.OperatingSystemVersionChoice.Equal(that1.OperatingSystemVersionChoice) {
		return false
	}
	return true
}
func (this *Passport_DefaultSwVersion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Passport_DefaultSwVersion)
	if !ok {
		that2, ok := that.(Passport_DefaultSwVersion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultSwVersion.Equal(that1.DefaultSwVersion) {
		return false
	}
	return true
}
func (this *Passport_VolterraSoftwareVersion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Passport_VolterraSoftwareVersion)
	if !ok {
		that2, ok := that.(Passport_VolterraSoftwareVersion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VolterraSoftwareVersion != that1.VolterraSoftwareVersion {
		return false
	}
	return true
}
func (this *Passport_DefaultOsVersion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Passport_DefaultOsVersion)
	if !ok {
		that2, ok := that.(Passport_DefaultOsVersion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultOsVersion.Equal(that1.DefaultOsVersion) {
		return false
	}
	return true
}
func (this *Passport_OperatingSystemVersion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Passport_OperatingSystemVersion)
	if !ok {
		that2, ok := that.(Passport_OperatingSystemVersion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OperatingSystemVersion != that1.OperatingSystemVersion {
		return false
	}
	return true
}
func (this *WorkloadContext) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WorkloadContext)
	if !ok {
		that2, ok := that.(WorkloadContext)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Params) != len(that1.Params) {
		return false
	}
	for i := range this.Params {
		if this.Params[i] != that1.Params[i] {
			return false
		}
	}
	if this.AppName != that1.AppName {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Infra.Equal(that1.Infra) {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	if !this.Passport.Equal(that1.Passport) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Infra.Equal(that1.Infra) {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	if !this.Passport.Equal(that1.Passport) {
		return false
	}
	return true
}
func (this *Infra) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&registration.Infra{")
	s = append(s, "Provider: "+fmt.Sprintf("%#v", this.Provider)+",\n")
	s = append(s, "InstanceId: "+fmt.Sprintf("%#v", this.InstanceId)+",\n")
	s = append(s, "Zone: "+fmt.Sprintf("%#v", this.Zone)+",\n")
	s = append(s, "AvailabilityZone: "+fmt.Sprintf("%#v", this.AvailabilityZone)+",\n")
	s = append(s, "Hostname: "+fmt.Sprintf("%#v", this.Hostname)+",\n")
	s = append(s, "Domain: "+fmt.Sprintf("%#v", this.Domain)+",\n")
	s = append(s, "MachineId: "+fmt.Sprintf("%#v", this.MachineId)+",\n")
	keysForInterfaces := make([]string, 0, len(this.Interfaces))
	for k, _ := range this.Interfaces {
		keysForInterfaces = append(keysForInterfaces, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForInterfaces)
	mapStringForInterfaces := "map[string]*Interface{"
	for _, k := range keysForInterfaces {
		mapStringForInterfaces += fmt.Sprintf("%#v: %#v,", k, this.Interfaces[k])
	}
	mapStringForInterfaces += "}"
	if this.Interfaces != nil {
		s = append(s, "Interfaces: "+mapStringForInterfaces+",\n")
	}
	if this.HwInfo != nil {
		s = append(s, "HwInfo: "+fmt.Sprintf("%#v", this.HwInfo)+",\n")
	}
	s = append(s, "CertifiedHw: "+fmt.Sprintf("%#v", this.CertifiedHw)+",\n")
	if this.InternetProxy != nil {
		s = append(s, "InternetProxy: "+fmt.Sprintf("%#v", this.InternetProxy)+",\n")
	}
	if this.Timestamp != nil {
		s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InternetProxy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&registration.InternetProxy{")
	s = append(s, "HttpProxy: "+fmt.Sprintf("%#v", this.HttpProxy)+",\n")
	s = append(s, "HttpsProxy: "+fmt.Sprintf("%#v", this.HttpsProxy)+",\n")
	s = append(s, "NoProxy: "+fmt.Sprintf("%#v", this.NoProxy)+",\n")
	s = append(s, "ProxyCacertUrl: "+fmt.Sprintf("%#v", this.ProxyCacertUrl)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Interface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&registration.Interface{")
	s = append(s, "Addr: "+fmt.Sprintf("%#v", this.Addr)+",\n")
	s = append(s, "Plen: "+fmt.Sprintf("%#v", this.Plen)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&registration.GlobalSpecType{")
	if this.Infra != nil {
		s = append(s, "Infra: "+fmt.Sprintf("%#v", this.Infra)+",\n")
	}
	s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	if this.Passport != nil {
		s = append(s, "Passport: "+fmt.Sprintf("%#v", this.Passport)+",\n")
	}
	if this.Site != nil {
		s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	}
	s = append(s, "Role: "+fmt.Sprintf("%#v", this.Role)+",\n")
	s = append(s, "TunnelType: "+fmt.Sprintf("%#v", this.TunnelType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Passport) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&registration.Passport{")
	s = append(s, "ClusterName: "+fmt.Sprintf("%#v", this.ClusterName)+",\n")
	s = append(s, "ClusterType: "+fmt.Sprintf("%#v", this.ClusterType)+",\n")
	s = append(s, "Latitude: "+fmt.Sprintf("%#v", this.Latitude)+",\n")
	s = append(s, "Longitude: "+fmt.Sprintf("%#v", this.Longitude)+",\n")
	s = append(s, "ClusterSize: "+fmt.Sprintf("%#v", this.ClusterSize)+",\n")
	s = append(s, "VpmVersion: "+fmt.Sprintf("%#v", this.VpmVersion)+",\n")
	s = append(s, "PrivateNetworkName: "+fmt.Sprintf("%#v", this.PrivateNetworkName)+",\n")
	if this.VolterraSwVersionChoice != nil {
		s = append(s, "VolterraSwVersionChoice: "+fmt.Sprintf("%#v", this.VolterraSwVersionChoice)+",\n")
	}
	if this.OperatingSystemVersionChoice != nil {
		s = append(s, "OperatingSystemVersionChoice: "+fmt.Sprintf("%#v", this.OperatingSystemVersionChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Passport_DefaultSwVersion) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&registration.Passport_DefaultSwVersion{` +
		`DefaultSwVersion:` + fmt.Sprintf("%#v", this.DefaultSwVersion) + `}`}, ", ")
	return s
}
func (this *Passport_VolterraSoftwareVersion) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&registration.Passport_VolterraSoftwareVersion{` +
		`VolterraSoftwareVersion:` + fmt.Sprintf("%#v", this.VolterraSoftwareVersion) + `}`}, ", ")
	return s
}
func (this *Passport_DefaultOsVersion) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&registration.Passport_DefaultOsVersion{` +
		`DefaultOsVersion:` + fmt.Sprintf("%#v", this.DefaultOsVersion) + `}`}, ", ")
	return s
}
func (this *Passport_OperatingSystemVersion) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&registration.Passport_OperatingSystemVersion{` +
		`OperatingSystemVersion:` + fmt.Sprintf("%#v", this.OperatingSystemVersion) + `}`}, ", ")
	return s
}
func (this *WorkloadContext) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&registration.WorkloadContext{")
	keysForParams := make([]string, 0, len(this.Params))
	for k, _ := range this.Params {
		keysForParams = append(keysForParams, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForParams)
	mapStringForParams := "map[string]string{"
	for _, k := range keysForParams {
		mapStringForParams += fmt.Sprintf("%#v: %#v,", k, this.Params[k])
	}
	mapStringForParams += "}"
	if this.Params != nil {
		s = append(s, "Params: "+mapStringForParams+",\n")
	}
	s = append(s, "AppName: "+fmt.Sprintf("%#v", this.AppName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&registration.CreateSpecType{")
	if this.Infra != nil {
		s = append(s, "Infra: "+fmt.Sprintf("%#v", this.Infra)+",\n")
	}
	s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	if this.Passport != nil {
		s = append(s, "Passport: "+fmt.Sprintf("%#v", this.Passport)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&registration.ReplaceSpecType{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&registration.GetSpecType{")
	if this.Infra != nil {
		s = append(s, "Infra: "+fmt.Sprintf("%#v", this.Infra)+",\n")
	}
	s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	if this.Passport != nil {
		s = append(s, "Passport: "+fmt.Sprintf("%#v", this.Passport)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Infra) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Infra) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Infra) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.AvailabilityZone) > 0 {
		i -= len(m.AvailabilityZone)
		copy(dAtA[i:], m.AvailabilityZone)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AvailabilityZone)))
		i--
		dAtA[i] = 0x5a
	}
	if m.InternetProxy != nil {
		{
			size, err := m.InternetProxy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.CertifiedHw) > 0 {
		i -= len(m.CertifiedHw)
		copy(dAtA[i:], m.CertifiedHw)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CertifiedHw)))
		i--
		dAtA[i] = 0x4a
	}
	if m.HwInfo != nil {
		{
			size, err := m.HwInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Interfaces) > 0 {
		keysForInterfaces := make([]string, 0, len(m.Interfaces))
		for k := range m.Interfaces {
			keysForInterfaces = append(keysForInterfaces, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForInterfaces)
		for iNdEx := len(keysForInterfaces) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Interfaces[string(keysForInterfaces[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTypes(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForInterfaces[iNdEx])
			copy(dAtA[i:], keysForInterfaces[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForInterfaces[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.MachineId) > 0 {
		i -= len(m.MachineId)
		copy(dAtA[i:], m.MachineId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MachineId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Zone) > 0 {
		i -= len(m.Zone)
		copy(dAtA[i:], m.Zone)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Zone)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.InstanceId) > 0 {
		i -= len(m.InstanceId)
		copy(dAtA[i:], m.InstanceId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InstanceId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Provider != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Provider))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InternetProxy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InternetProxy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InternetProxy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProxyCacertUrl) > 0 {
		i -= len(m.ProxyCacertUrl)
		copy(dAtA[i:], m.ProxyCacertUrl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProxyCacertUrl)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.NoProxy) > 0 {
		i -= len(m.NoProxy)
		copy(dAtA[i:], m.NoProxy)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NoProxy)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.HttpsProxy) > 0 {
		i -= len(m.HttpsProxy)
		copy(dAtA[i:], m.HttpsProxy)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HttpsProxy)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.HttpProxy) > 0 {
		i -= len(m.HttpProxy)
		copy(dAtA[i:], m.HttpProxy)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HttpProxy)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Interface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Interface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Interface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Plen != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Plen))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TunnelType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Role) > 0 {
		for iNdEx := len(m.Role) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Role[iNdEx])
			copy(dAtA[i:], m.Role[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Role[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Site) > 0 {
		for iNdEx := len(m.Site) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Site[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Passport != nil {
		{
			size, err := m.Passport.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Infra != nil {
		{
			size, err := m.Infra.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Passport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Passport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Passport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OperatingSystemVersionChoice != nil {
		{
			size := m.OperatingSystemVersionChoice.Size()
			i -= size
			if _, err := m.OperatingSystemVersionChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.VolterraSwVersionChoice != nil {
		{
			size := m.VolterraSwVersionChoice.Size()
			i -= size
			if _, err := m.VolterraSwVersionChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.PrivateNetworkName) > 0 {
		i -= len(m.PrivateNetworkName)
		copy(dAtA[i:], m.PrivateNetworkName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PrivateNetworkName)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.VpmVersion) > 0 {
		i -= len(m.VpmVersion)
		copy(dAtA[i:], m.VpmVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VpmVersion)))
		i--
		dAtA[i] = 0x52
	}
	if m.ClusterSize != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ClusterSize))
		i--
		dAtA[i] = 0x48
	}
	if m.Longitude != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Longitude))))
		i--
		dAtA[i] = 0x45
	}
	if m.Latitude != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Latitude))))
		i--
		dAtA[i] = 0x3d
	}
	if len(m.ClusterType) > 0 {
		i -= len(m.ClusterType)
		copy(dAtA[i:], m.ClusterType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterName) > 0 {
		i -= len(m.ClusterName)
		copy(dAtA[i:], m.ClusterName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Passport_DefaultSwVersion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Passport_DefaultSwVersion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultSwVersion != nil {
		{
			size, err := m.DefaultSwVersion.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *Passport_VolterraSoftwareVersion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Passport_VolterraSoftwareVersion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.VolterraSoftwareVersion)
	copy(dAtA[i:], m.VolterraSoftwareVersion)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.VolterraSoftwareVersion)))
	i--
	dAtA[i] = 0x72
	return len(dAtA) - i, nil
}
func (m *Passport_DefaultOsVersion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Passport_DefaultOsVersion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultOsVersion != nil {
		{
			size, err := m.DefaultOsVersion.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *Passport_OperatingSystemVersion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Passport_OperatingSystemVersion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.OperatingSystemVersion)
	copy(dAtA[i:], m.OperatingSystemVersion)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.OperatingSystemVersion)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	return len(dAtA) - i, nil
}
func (m *WorkloadContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkloadContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkloadContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AppName) > 0 {
		i -= len(m.AppName)
		copy(dAtA[i:], m.AppName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AppName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Params) > 0 {
		keysForParams := make([]string, 0, len(m.Params))
		for k := range m.Params {
			keysForParams = append(keysForParams, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForParams)
		for iNdEx := len(keysForParams) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Params[string(keysForParams[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForParams[iNdEx])
			copy(dAtA[i:], keysForParams[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForParams[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Passport != nil {
		{
			size, err := m.Passport.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Infra != nil {
		{
			size, err := m.Infra.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Passport != nil {
		{
			size, err := m.Passport.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Infra != nil {
		{
			size, err := m.Infra.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Infra) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Provider != 0 {
		n += 1 + sovTypes(uint64(m.Provider))
	}
	l = len(m.InstanceId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Zone)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.MachineId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Interfaces) > 0 {
		for k, v := range m.Interfaces {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.HwInfo != nil {
		l = m.HwInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CertifiedHw)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.InternetProxy != nil {
		l = m.InternetProxy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AvailabilityZone)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *InternetProxy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HttpProxy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.HttpsProxy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.NoProxy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProxyCacertUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Interface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Plen != 0 {
		n += 1 + sovTypes(uint64(m.Plen))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Infra != nil {
		l = m.Infra.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Passport != nil {
		l = m.Passport.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Site) > 0 {
		for _, e := range m.Site {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Role) > 0 {
		for _, s := range m.Role {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.TunnelType != 0 {
		n += 1 + sovTypes(uint64(m.TunnelType))
	}
	return n
}

func (m *Passport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClusterType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Latitude != 0 {
		n += 5
	}
	if m.Longitude != 0 {
		n += 5
	}
	if m.ClusterSize != 0 {
		n += 1 + sovTypes(uint64(m.ClusterSize))
	}
	l = len(m.VpmVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PrivateNetworkName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VolterraSwVersionChoice != nil {
		n += m.VolterraSwVersionChoice.Size()
	}
	if m.OperatingSystemVersionChoice != nil {
		n += m.OperatingSystemVersionChoice.Size()
	}
	return n
}

func (m *Passport_DefaultSwVersion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultSwVersion != nil {
		l = m.DefaultSwVersion.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Passport_VolterraSoftwareVersion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VolterraSoftwareVersion)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *Passport_DefaultOsVersion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultOsVersion != nil {
		l = m.DefaultOsVersion.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Passport_OperatingSystemVersion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OperatingSystemVersion)
	n += 2 + l + sovTypes(uint64(l))
	return n
}
func (m *WorkloadContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Params) > 0 {
		for k, v := range m.Params {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Infra != nil {
		l = m.Infra.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Passport != nil {
		l = m.Passport.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Infra != nil {
		l = m.Infra.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Passport != nil {
		l = m.Passport.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Infra) String() string {
	if this == nil {
		return "nil"
	}
	keysForInterfaces := make([]string, 0, len(this.Interfaces))
	for k, _ := range this.Interfaces {
		keysForInterfaces = append(keysForInterfaces, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForInterfaces)
	mapStringForInterfaces := "map[string]*Interface{"
	for _, k := range keysForInterfaces {
		mapStringForInterfaces += fmt.Sprintf("%v: %v,", k, this.Interfaces[k])
	}
	mapStringForInterfaces += "}"
	s := strings.Join([]string{`&Infra{`,
		`Provider:` + fmt.Sprintf("%v", this.Provider) + `,`,
		`InstanceId:` + fmt.Sprintf("%v", this.InstanceId) + `,`,
		`Zone:` + fmt.Sprintf("%v", this.Zone) + `,`,
		`Hostname:` + fmt.Sprintf("%v", this.Hostname) + `,`,
		`MachineId:` + fmt.Sprintf("%v", this.MachineId) + `,`,
		`Interfaces:` + mapStringForInterfaces + `,`,
		`Domain:` + fmt.Sprintf("%v", this.Domain) + `,`,
		`HwInfo:` + strings.Replace(fmt.Sprintf("%v", this.HwInfo), "OsInfo", "site.OsInfo", 1) + `,`,
		`CertifiedHw:` + fmt.Sprintf("%v", this.CertifiedHw) + `,`,
		`InternetProxy:` + strings.Replace(this.InternetProxy.String(), "InternetProxy", "InternetProxy", 1) + `,`,
		`AvailabilityZone:` + fmt.Sprintf("%v", this.AvailabilityZone) + `,`,
		`Timestamp:` + strings.Replace(fmt.Sprintf("%v", this.Timestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InternetProxy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InternetProxy{`,
		`HttpProxy:` + fmt.Sprintf("%v", this.HttpProxy) + `,`,
		`HttpsProxy:` + fmt.Sprintf("%v", this.HttpsProxy) + `,`,
		`NoProxy:` + fmt.Sprintf("%v", this.NoProxy) + `,`,
		`ProxyCacertUrl:` + fmt.Sprintf("%v", this.ProxyCacertUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Interface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Interface{`,
		`Addr:` + fmt.Sprintf("%v", this.Addr) + `,`,
		`Plen:` + fmt.Sprintf("%v", this.Plen) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSite := "[]*ObjectRefType{"
	for _, f := range this.Site {
		repeatedStringForSite += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForSite += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Infra:` + strings.Replace(this.Infra.String(), "Infra", "Infra", 1) + `,`,
		`Token:` + fmt.Sprintf("%v", this.Token) + `,`,
		`Passport:` + strings.Replace(this.Passport.String(), "Passport", "Passport", 1) + `,`,
		`Site:` + repeatedStringForSite + `,`,
		`Role:` + fmt.Sprintf("%v", this.Role) + `,`,
		`TunnelType:` + fmt.Sprintf("%v", this.TunnelType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Passport) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Passport{`,
		`ClusterName:` + fmt.Sprintf("%v", this.ClusterName) + `,`,
		`ClusterType:` + fmt.Sprintf("%v", this.ClusterType) + `,`,
		`Latitude:` + fmt.Sprintf("%v", this.Latitude) + `,`,
		`Longitude:` + fmt.Sprintf("%v", this.Longitude) + `,`,
		`ClusterSize:` + fmt.Sprintf("%v", this.ClusterSize) + `,`,
		`VpmVersion:` + fmt.Sprintf("%v", this.VpmVersion) + `,`,
		`PrivateNetworkName:` + fmt.Sprintf("%v", this.PrivateNetworkName) + `,`,
		`VolterraSwVersionChoice:` + fmt.Sprintf("%v", this.VolterraSwVersionChoice) + `,`,
		`OperatingSystemVersionChoice:` + fmt.Sprintf("%v", this.OperatingSystemVersionChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Passport_DefaultSwVersion) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Passport_DefaultSwVersion{`,
		`DefaultSwVersion:` + strings.Replace(fmt.Sprintf("%v", this.DefaultSwVersion), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Passport_VolterraSoftwareVersion) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Passport_VolterraSoftwareVersion{`,
		`VolterraSoftwareVersion:` + fmt.Sprintf("%v", this.VolterraSoftwareVersion) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Passport_DefaultOsVersion) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Passport_DefaultOsVersion{`,
		`DefaultOsVersion:` + strings.Replace(fmt.Sprintf("%v", this.DefaultOsVersion), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Passport_OperatingSystemVersion) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Passport_OperatingSystemVersion{`,
		`OperatingSystemVersion:` + fmt.Sprintf("%v", this.OperatingSystemVersion) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WorkloadContext) String() string {
	if this == nil {
		return "nil"
	}
	keysForParams := make([]string, 0, len(this.Params))
	for k, _ := range this.Params {
		keysForParams = append(keysForParams, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForParams)
	mapStringForParams := "map[string]string{"
	for _, k := range keysForParams {
		mapStringForParams += fmt.Sprintf("%v: %v,", k, this.Params[k])
	}
	mapStringForParams += "}"
	s := strings.Join([]string{`&WorkloadContext{`,
		`Params:` + mapStringForParams + `,`,
		`AppName:` + fmt.Sprintf("%v", this.AppName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Infra:` + strings.Replace(this.Infra.String(), "Infra", "Infra", 1) + `,`,
		`Token:` + fmt.Sprintf("%v", this.Token) + `,`,
		`Passport:` + strings.Replace(this.Passport.String(), "Passport", "Passport", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`Infra:` + strings.Replace(this.Infra.String(), "Infra", "Infra", 1) + `,`,
		`Token:` + fmt.Sprintf("%v", this.Token) + `,`,
		`Passport:` + strings.Replace(this.Passport.String(), "Passport", "Passport", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Infra) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Infra: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Infra: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			m.Provider = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Provider |= Provider(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MachineId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MachineId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interfaces == nil {
				m.Interfaces = make(map[string]*Interface)
			}
			var mapkey string
			var mapvalue *Interface
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Interface{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Interfaces[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HwInfo == nil {
				m.HwInfo = &site.OsInfo{}
			}
			if err := m.HwInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertifiedHw", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertifiedHw = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternetProxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternetProxy == nil {
				m.InternetProxy = &InternetProxy{}
			}
			if err := m.InternetProxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailabilityZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailabilityZone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InternetProxy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternetProxy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternetProxy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpProxy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpProxy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpsProxy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpsProxy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoProxy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NoProxy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyCacertUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyCacertUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Interface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Interface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Interface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plen", wireType)
			}
			m.Plen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Plen |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infra", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Infra == nil {
				m.Infra = &Infra{}
			}
			if err := m.Infra.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Passport == nil {
				m.Passport = &Passport{}
			}
			if err := m.Passport.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = append(m.Site, &schema.ObjectRefType{})
			if err := m.Site[len(m.Site)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = append(m.Role, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelType", wireType)
			}
			m.TunnelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelType |= schema.SiteToSiteTunnelType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Passport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Passport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Passport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Latitude = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Longitude = float32(math.Float32frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterSize", wireType)
			}
			m.ClusterSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpmVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpmVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateNetworkName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateNetworkName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultSwVersion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VolterraSwVersionChoice = &Passport_DefaultSwVersion{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSoftwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolterraSwVersionChoice = &Passport_VolterraSoftwareVersion{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultOsVersion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OperatingSystemVersionChoice = &Passport_DefaultOsVersion{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingSystemVersionChoice = &Passport_OperatingSystemVersion{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkloadContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkloadContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkloadContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Params[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infra", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Infra == nil {
				m.Infra = &Infra{}
			}
			if err := m.Infra.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Passport == nil {
				m.Passport = &Passport{}
			}
			if err := m.Passport.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infra", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Infra == nil {
				m.Infra = &Infra{}
			}
			if err := m.Infra.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Passport == nil {
				m.Passport = &Passport{}
			}
			if err := m.Passport.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
