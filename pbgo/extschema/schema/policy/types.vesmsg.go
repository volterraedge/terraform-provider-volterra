//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//
package policy

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_waf_rule_list "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/waf_rule_list"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *ArgMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ArgMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ArgMatcherType) DeepCopy() *ArgMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ArgMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ArgMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ArgMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ArgMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateArgMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateArgMatcherType) MatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for match")
	}
	return validatorFn, nil
}

func (v *ValidateArgMatcherType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateArgMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ArgMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ArgMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["match"]; exists {
		val := m.GetMatch()
		vOpts := append(opts,
			db.WithValidateField("match"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMatch().(type) {
	case *ArgMatcherType_Presence:
		if fv, exists := v.FldValidators["match.presence"]; exists {
			val := m.GetMatch().(*ArgMatcherType_Presence).Presence
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("presence"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ArgMatcherType_Item:
		if fv, exists := v.FldValidators["match.item"]; exists {
			val := m.GetMatch().(*ArgMatcherType_Item).Item
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("item"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ArgMatcherType_CheckPresent:
		if fv, exists := v.FldValidators["match.check_present"]; exists {
			val := m.GetMatch().(*ArgMatcherType_CheckPresent).CheckPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ArgMatcherType_CheckNotPresent:
		if fv, exists := v.FldValidators["match.check_not_present"]; exists {
			val := m.GetMatch().(*ArgMatcherType_CheckNotPresent).CheckNotPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_not_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultArgMatcherTypeValidator = func() *ValidateArgMatcherType {
	v := &ValidateArgMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMatch := v.MatchValidationRuleHandler
	rulesMatch := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMatch(rulesMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ArgMatcherType.match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["match"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.json_path": "true",
		"ves.io.schema.rules.string.max_bytes": "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ArgMatcherType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	v.FldValidators["match.item"] = MatcherTypeValidator().Validate

	return v
}()

func ArgMatcherTypeValidator() db.Validator {
	return DefaultArgMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AsnMatchList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AsnMatchList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AsnMatchList) DeepCopy() *AsnMatchList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AsnMatchList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AsnMatchList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AsnMatchList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AsnMatchListValidator().Validate(ctx, m, opts...)
}

type ValidateAsnMatchList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAsnMatchList) AsNumbersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepUint32ItemRules(rules)
	itemValFn, err := db.NewUint32ValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for as_numbers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []uint32, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for as_numbers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]uint32)
		if !ok {
			return fmt.Errorf("Repeated validation expected []uint32, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated as_numbers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items as_numbers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAsnMatchList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AsnMatchList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AsnMatchList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["as_numbers"]; exists {
		vOpts := append(opts, db.WithValidateField("as_numbers"))
		if err := fv(ctx, m.GetAsNumbers(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAsnMatchListValidator = func() *ValidateAsnMatchList {
	v := &ValidateAsnMatchList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAsNumbers := v.AsNumbersValidationRuleHandler
	rulesAsNumbers := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhAsNumbers(rulesAsNumbers)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AsnMatchList.as_numbers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["as_numbers"] = vFn

	return v
}()

func AsnMatchListValidator() db.Validator {
	return DefaultAsnMatchListValidator
}

// augmented methods on protoc/std generated struct

func (m *AsnMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AsnMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AsnMatcherType) DeepCopy() *AsnMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AsnMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AsnMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AsnMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AsnMatcherTypeValidator().Validate(ctx, m, opts...)
}

func (m *AsnMatcherType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAsnSetsDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *AsnMatcherType) GetAsnSetsDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetAsnSets() {
		if ref == nil {
			return nil, fmt.Errorf("AsnMatcherType.asn_sets[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "bgp_asn_set.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "asn_sets",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetAsnSetsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *AsnMatcherType) GetAsnSetsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "bgp_asn_set.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: bgp_asn_set")
	}
	for _, ref := range m.GetAsnSets() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateAsnMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAsnMatcherType) AsnSetsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for asn_sets")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated asn_sets")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items asn_sets")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAsnMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AsnMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AsnMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["asn_sets"]; exists {
		vOpts := append(opts, db.WithValidateField("asn_sets"))
		if err := fv(ctx, m.GetAsnSets(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAsnMatcherTypeValidator = func() *ValidateAsnMatcherType {
	v := &ValidateAsnMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAsnSets := v.AsnSetsValidationRuleHandler
	rulesAsnSets := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhAsnSets(rulesAsnSets)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AsnMatcherType.asn_sets: %s", err)
		panic(errMsg)
	}
	v.FldValidators["asn_sets"] = vFn

	return v
}()

func AsnMatcherTypeValidator() db.Validator {
	return DefaultAsnMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CookieMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CookieMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CookieMatcherType) DeepCopy() *CookieMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CookieMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CookieMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CookieMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CookieMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCookieMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCookieMatcherType) MatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for match")
	}
	return validatorFn, nil
}

func (v *ValidateCookieMatcherType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateCookieMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CookieMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CookieMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["match"]; exists {
		val := m.GetMatch()
		vOpts := append(opts,
			db.WithValidateField("match"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMatch().(type) {
	case *CookieMatcherType_Presence:
		if fv, exists := v.FldValidators["match.presence"]; exists {
			val := m.GetMatch().(*CookieMatcherType_Presence).Presence
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("presence"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CookieMatcherType_Item:
		if fv, exists := v.FldValidators["match.item"]; exists {
			val := m.GetMatch().(*CookieMatcherType_Item).Item
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("item"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CookieMatcherType_CheckPresent:
		if fv, exists := v.FldValidators["match.check_present"]; exists {
			val := m.GetMatch().(*CookieMatcherType_CheckPresent).CheckPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CookieMatcherType_CheckNotPresent:
		if fv, exists := v.FldValidators["match.check_not_present"]; exists {
			val := m.GetMatch().(*CookieMatcherType_CheckNotPresent).CheckNotPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_not_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCookieMatcherTypeValidator = func() *ValidateCookieMatcherType {
	v := &ValidateCookieMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMatch := v.MatchValidationRuleHandler
	rulesMatch := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMatch(rulesMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CookieMatcherType.match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["match"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CookieMatcherType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	v.FldValidators["match.item"] = MatcherTypeValidator().Validate

	return v
}()

func CookieMatcherTypeValidator() db.Validator {
	return DefaultCookieMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DenyInformation) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DenyInformation) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DenyInformation) DeepCopy() *DenyInformation {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DenyInformation{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DenyInformation) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DenyInformation) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DenyInformationValidator().Validate(ctx, m, opts...)
}

type ValidateDenyInformation struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDenyInformation) ResponseCodeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for response_code")
	}

	return validatorFn, nil
}

func (v *ValidateDenyInformation) ErrorMessageValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for error_message")
	}

	return validatorFn, nil
}

func (v *ValidateDenyInformation) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DenyInformation)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DenyInformation got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["error_message"]; exists {

		vOpts := append(opts, db.WithValidateField("error_message"))
		if err := fv(ctx, m.GetErrorMessage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_code"]; exists {

		vOpts := append(opts, db.WithValidateField("response_code"))
		if err := fv(ctx, m.GetResponseCode(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDenyInformationValidator = func() *ValidateDenyInformation {
	v := &ValidateDenyInformation{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhResponseCode := v.ResponseCodeValidationRuleHandler
	rulesResponseCode := map[string]string{
		"ves.io.schema.rules.uint32.lte": "599",
	}
	vFn, err = vrhResponseCode(rulesResponseCode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DenyInformation.response_code: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_code"] = vFn

	vrhErrorMessage := v.ErrorMessageValidationRuleHandler
	rulesErrorMessage := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "512",
	}
	vFn, err = vrhErrorMessage(rulesErrorMessage)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DenyInformation.error_message: %s", err)
		panic(errMsg)
	}
	v.FldValidators["error_message"] = vFn

	return v
}()

func DenyInformationValidator() db.Validator {
	return DefaultDenyInformationValidator
}

// augmented methods on protoc/std generated struct

func (m *HeaderMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HeaderMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HeaderMatcherType) DeepCopy() *HeaderMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HeaderMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HeaderMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HeaderMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HeaderMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateHeaderMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHeaderMatcherType) MatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for match")
	}
	return validatorFn, nil
}

func (v *ValidateHeaderMatcherType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateHeaderMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HeaderMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HeaderMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["match"]; exists {
		val := m.GetMatch()
		vOpts := append(opts,
			db.WithValidateField("match"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMatch().(type) {
	case *HeaderMatcherType_Presence:
		if fv, exists := v.FldValidators["match.presence"]; exists {
			val := m.GetMatch().(*HeaderMatcherType_Presence).Presence
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("presence"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HeaderMatcherType_Item:
		if fv, exists := v.FldValidators["match.item"]; exists {
			val := m.GetMatch().(*HeaderMatcherType_Item).Item
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("item"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HeaderMatcherType_CheckPresent:
		if fv, exists := v.FldValidators["match.check_present"]; exists {
			val := m.GetMatch().(*HeaderMatcherType_CheckPresent).CheckPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HeaderMatcherType_CheckNotPresent:
		if fv, exists := v.FldValidators["match.check_not_present"]; exists {
			val := m.GetMatch().(*HeaderMatcherType_CheckNotPresent).CheckNotPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_not_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHeaderMatcherTypeValidator = func() *ValidateHeaderMatcherType {
	v := &ValidateHeaderMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMatch := v.MatchValidationRuleHandler
	rulesMatch := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMatch(rulesMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderMatcherType.match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["match"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required":         "true",
		"ves.io.schema.rules.string.http_header_field": "true",
		"ves.io.schema.rules.string.max_bytes":         "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderMatcherType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	v.FldValidators["match.item"] = MatcherTypeValidator().Validate

	return v
}()

func HeaderMatcherTypeValidator() db.Validator {
	return DefaultHeaderMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *HttpMethodMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HttpMethodMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HttpMethodMatcherType) DeepCopy() *HttpMethodMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HttpMethodMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HttpMethodMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HttpMethodMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HttpMethodMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateHttpMethodMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHttpMethodMatcherType) MethodsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.HttpMethod)
		return int32(i)
	}
	// ves_io_schema.HttpMethod_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, ves_io_schema.HttpMethod_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for methods")
	}
	itemsValidatorFn := func(ctx context.Context, elems []ves_io_schema.HttpMethod, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for methods")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]ves_io_schema.HttpMethod)
		if !ok {
			return fmt.Errorf("Repeated validation expected []ves_io_schema.HttpMethod, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated methods")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items methods")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateHttpMethodMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HttpMethodMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HttpMethodMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["methods"]; exists {
		vOpts := append(opts, db.WithValidateField("methods"))
		if err := fv(ctx, m.GetMethods(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHttpMethodMatcherTypeValidator = func() *ValidateHttpMethodMatcherType {
	v := &ValidateHttpMethodMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMethods := v.MethodsValidationRuleHandler
	rulesMethods := map[string]string{
		"ves.io.schema.rules.enum.defined_only": "true",
		"ves.io.schema.rules.repeated.unique":   "true",
	}
	vFn, err = vrhMethods(rulesMethods)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HttpMethodMatcherType.methods: %s", err)
		panic(errMsg)
	}
	v.FldValidators["methods"] = vFn

	return v
}()

func HttpMethodMatcherTypeValidator() db.Validator {
	return DefaultHttpMethodMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *IpMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IpMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IpMatcherType) DeepCopy() *IpMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IpMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IpMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IpMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IpMatcherTypeValidator().Validate(ctx, m, opts...)
}

func (m *IpMatcherType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetPrefixSetsDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *IpMatcherType) GetPrefixSetsDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetPrefixSets() {
		if ref == nil {
			return nil, fmt.Errorf("IpMatcherType.prefix_sets[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "ip_prefix_set.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "prefix_sets",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetPrefixSetsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *IpMatcherType) GetPrefixSetsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "ip_prefix_set.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: ip_prefix_set")
	}
	for _, ref := range m.GetPrefixSets() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateIpMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIpMatcherType) PrefixSetsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for prefix_sets")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated prefix_sets")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items prefix_sets")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateIpMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IpMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IpMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["prefix_sets"]; exists {
		vOpts := append(opts, db.WithValidateField("prefix_sets"))
		if err := fv(ctx, m.GetPrefixSets(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIpMatcherTypeValidator = func() *ValidateIpMatcherType {
	v := &ValidateIpMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPrefixSets := v.PrefixSetsValidationRuleHandler
	rulesPrefixSets := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhPrefixSets(rulesPrefixSets)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IpMatcherType.prefix_sets: %s", err)
		panic(errMsg)
	}
	v.FldValidators["prefix_sets"] = vFn

	return v
}()

func IpMatcherTypeValidator() db.Validator {
	return DefaultIpMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *L4DestMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *L4DestMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *L4DestMatcherType) DeepCopy() *L4DestMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &L4DestMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *L4DestMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *L4DestMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return L4DestMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateL4DestMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateL4DestMatcherType) L4DestsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.L4DestType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.L4DestTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for l4_dests")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.L4DestType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.L4DestType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated l4_dests")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items l4_dests")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateL4DestMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*L4DestMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *L4DestMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["l4_dests"]; exists {
		vOpts := append(opts, db.WithValidateField("l4_dests"))
		if err := fv(ctx, m.GetL4Dests(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultL4DestMatcherTypeValidator = func() *ValidateL4DestMatcherType {
	v := &ValidateL4DestMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhL4Dests := v.L4DestsValidationRuleHandler
	rulesL4Dests := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhL4Dests(rulesL4Dests)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for L4DestMatcherType.l4_dests: %s", err)
		panic(errMsg)
	}
	v.FldValidators["l4_dests"] = vFn

	return v
}()

func L4DestMatcherTypeValidator() db.Validator {
	return DefaultL4DestMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *MatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MatcherType) DeepCopy() *MatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMatcherType) ExactValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for exact_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exact_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exact_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exact_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateMatcherType) RegexValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for regex_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for regex_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated regex_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items regex_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateMatcherType) TransformersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(Transformer)
		return int32(i)
	}
	// Transformer_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, Transformer_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for transformers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []Transformer, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for transformers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]Transformer)
		if !ok {
			return fmt.Errorf("Repeated validation expected []Transformer, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated transformers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items transformers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["exact_values"]; exists {
		vOpts := append(opts, db.WithValidateField("exact_values"))
		if err := fv(ctx, m.GetExactValues(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["regex_values"]; exists {
		vOpts := append(opts, db.WithValidateField("regex_values"))
		if err := fv(ctx, m.GetRegexValues(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["transformers"]; exists {
		vOpts := append(opts, db.WithValidateField("transformers"))
		if err := fv(ctx, m.GetTransformers(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMatcherTypeValidator = func() *ValidateMatcherType {
	v := &ValidateMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhExactValues := v.ExactValuesValidationRuleHandler
	rulesExactValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhExactValues(rulesExactValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MatcherType.exact_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exact_values"] = vFn

	vrhRegexValues := v.RegexValuesValidationRuleHandler
	rulesRegexValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.regex":     "true",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhRegexValues(rulesRegexValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MatcherType.regex_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["regex_values"] = vFn

	vrhTransformers := v.TransformersValidationRuleHandler
	rulesTransformers := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "9",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhTransformers(rulesTransformers)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MatcherType.transformers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["transformers"] = vFn

	return v
}()

func MatcherTypeValidator() db.Validator {
	return DefaultMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *MatcherTypeBasic) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MatcherTypeBasic) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MatcherTypeBasic) DeepCopy() *MatcherTypeBasic {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MatcherTypeBasic{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MatcherTypeBasic) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MatcherTypeBasic) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MatcherTypeBasicValidator().Validate(ctx, m, opts...)
}

type ValidateMatcherTypeBasic struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMatcherTypeBasic) ExactValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for exact_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exact_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exact_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exact_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateMatcherTypeBasic) RegexValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for regex_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for regex_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated regex_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items regex_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateMatcherTypeBasic) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MatcherTypeBasic)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MatcherTypeBasic got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["exact_values"]; exists {
		vOpts := append(opts, db.WithValidateField("exact_values"))
		if err := fv(ctx, m.GetExactValues(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["regex_values"]; exists {
		vOpts := append(opts, db.WithValidateField("regex_values"))
		if err := fv(ctx, m.GetRegexValues(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMatcherTypeBasicValidator = func() *ValidateMatcherTypeBasic {
	v := &ValidateMatcherTypeBasic{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhExactValues := v.ExactValuesValidationRuleHandler
	rulesExactValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhExactValues(rulesExactValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MatcherTypeBasic.exact_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exact_values"] = vFn

	vrhRegexValues := v.RegexValuesValidationRuleHandler
	rulesRegexValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.regex":     "true",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhRegexValues(rulesRegexValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MatcherTypeBasic.regex_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["regex_values"] = vFn

	return v
}()

func MatcherTypeBasicValidator() db.Validator {
	return DefaultMatcherTypeBasicValidator
}

// augmented methods on protoc/std generated struct

func (m *PathMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PathMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PathMatcherType) DeepCopy() *PathMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PathMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PathMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PathMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PathMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePathMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePathMatcherType) PrefixValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for prefix_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for prefix_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated prefix_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items prefix_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePathMatcherType) ExactValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for exact_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exact_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exact_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exact_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePathMatcherType) RegexValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for regex_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for regex_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated regex_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items regex_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePathMatcherType) TransformersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(Transformer)
		return int32(i)
	}
	// Transformer_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, Transformer_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for transformers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []Transformer, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for transformers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]Transformer)
		if !ok {
			return fmt.Errorf("Repeated validation expected []Transformer, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated transformers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items transformers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePathMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PathMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PathMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["exact_values"]; exists {
		vOpts := append(opts, db.WithValidateField("exact_values"))
		if err := fv(ctx, m.GetExactValues(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["prefix_values"]; exists {
		vOpts := append(opts, db.WithValidateField("prefix_values"))
		if err := fv(ctx, m.GetPrefixValues(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["regex_values"]; exists {
		vOpts := append(opts, db.WithValidateField("regex_values"))
		if err := fv(ctx, m.GetRegexValues(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["transformers"]; exists {
		vOpts := append(opts, db.WithValidateField("transformers"))
		if err := fv(ctx, m.GetTransformers(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPathMatcherTypeValidator = func() *ValidatePathMatcherType {
	v := &ValidatePathMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPrefixValues := v.PrefixValuesValidationRuleHandler
	rulesPrefixValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhPrefixValues(rulesPrefixValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PathMatcherType.prefix_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["prefix_values"] = vFn

	vrhExactValues := v.ExactValuesValidationRuleHandler
	rulesExactValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhExactValues(rulesExactValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PathMatcherType.exact_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exact_values"] = vFn

	vrhRegexValues := v.RegexValuesValidationRuleHandler
	rulesRegexValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.regex":     "true",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhRegexValues(rulesRegexValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PathMatcherType.regex_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["regex_values"] = vFn

	vrhTransformers := v.TransformersValidationRuleHandler
	rulesTransformers := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "9",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhTransformers(rulesTransformers)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PathMatcherType.transformers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["transformers"] = vFn

	return v
}()

func PathMatcherTypeValidator() db.Validator {
	return DefaultPathMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PortMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PortMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PortMatcherType) DeepCopy() *PortMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PortMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PortMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PortMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PortMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePortMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePortMatcherType) PortsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for ports")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ports")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ports")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ports")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePortMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PortMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PortMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ports"]; exists {
		vOpts := append(opts, db.WithValidateField("ports"))
		if err := fv(ctx, m.GetPorts(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPortMatcherTypeValidator = func() *ValidatePortMatcherType {
	v := &ValidatePortMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPorts := v.PortsValidationRuleHandler
	rulesPorts := map[string]string{
		"ves.io.schema.rules.message.required":                 "true",
		"ves.io.schema.rules.repeated.items.string.port_range": "true",
		"ves.io.schema.rules.repeated.max_items":               "16",
		"ves.io.schema.rules.repeated.unique":                  "true",
	}
	vFn, err = vrhPorts(rulesPorts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PortMatcherType.ports: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ports"] = vFn

	return v
}()

func PortMatcherTypeValidator() db.Validator {
	return DefaultPortMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PrefixMatchList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PrefixMatchList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PrefixMatchList) DeepCopy() *PrefixMatchList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PrefixMatchList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PrefixMatchList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PrefixMatchList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PrefixMatchListValidator().Validate(ctx, m, opts...)
}

type ValidatePrefixMatchList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePrefixMatchList) IpPrefixesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for ip_prefixes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ip_prefixes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ip_prefixes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ip_prefixes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePrefixMatchList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PrefixMatchList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PrefixMatchList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_match"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_match"))
		if err := fv(ctx, m.GetInvertMatch(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip_prefixes"]; exists {
		vOpts := append(opts, db.WithValidateField("ip_prefixes"))
		if err := fv(ctx, m.GetIpPrefixes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPrefixMatchListValidator = func() *ValidatePrefixMatchList {
	v := &ValidatePrefixMatchList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhIpPrefixes := v.IpPrefixesValidationRuleHandler
	rulesIpPrefixes := map[string]string{
		"ves.io.schema.rules.message.required":                  "true",
		"ves.io.schema.rules.repeated.items.string.ipv4_prefix": "true",
		"ves.io.schema.rules.repeated.max_items":                "16",
		"ves.io.schema.rules.repeated.min_items":                "1",
		"ves.io.schema.rules.repeated.unique":                   "true",
	}
	vFn, err = vrhIpPrefixes(rulesIpPrefixes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PrefixMatchList.ip_prefixes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip_prefixes"] = vFn

	return v
}()

func PrefixMatchListValidator() db.Validator {
	return DefaultPrefixMatchListValidator
}

// augmented methods on protoc/std generated struct

func (m *QueryParameterMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *QueryParameterMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *QueryParameterMatcherType) DeepCopy() *QueryParameterMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &QueryParameterMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *QueryParameterMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *QueryParameterMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return QueryParameterMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateQueryParameterMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateQueryParameterMatcherType) MatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for match")
	}
	return validatorFn, nil
}

func (v *ValidateQueryParameterMatcherType) KeyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for key")
	}

	return validatorFn, nil
}

func (v *ValidateQueryParameterMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*QueryParameterMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *QueryParameterMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["key"]; exists {

		vOpts := append(opts, db.WithValidateField("key"))
		if err := fv(ctx, m.GetKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["match"]; exists {
		val := m.GetMatch()
		vOpts := append(opts,
			db.WithValidateField("match"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMatch().(type) {
	case *QueryParameterMatcherType_Presence:
		if fv, exists := v.FldValidators["match.presence"]; exists {
			val := m.GetMatch().(*QueryParameterMatcherType_Presence).Presence
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("presence"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *QueryParameterMatcherType_Item:
		if fv, exists := v.FldValidators["match.item"]; exists {
			val := m.GetMatch().(*QueryParameterMatcherType_Item).Item
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("item"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *QueryParameterMatcherType_CheckPresent:
		if fv, exists := v.FldValidators["match.check_present"]; exists {
			val := m.GetMatch().(*QueryParameterMatcherType_CheckPresent).CheckPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *QueryParameterMatcherType_CheckNotPresent:
		if fv, exists := v.FldValidators["match.check_not_present"]; exists {
			val := m.GetMatch().(*QueryParameterMatcherType_CheckNotPresent).CheckNotPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_not_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultQueryParameterMatcherTypeValidator = func() *ValidateQueryParameterMatcherType {
	v := &ValidateQueryParameterMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMatch := v.MatchValidationRuleHandler
	rulesMatch := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMatch(rulesMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for QueryParameterMatcherType.match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["match"] = vFn

	vrhKey := v.KeyValidationRuleHandler
	rulesKey := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "256",
	}
	vFn, err = vrhKey(rulesKey)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for QueryParameterMatcherType.key: %s", err)
		panic(errMsg)
	}
	v.FldValidators["key"] = vFn

	v.FldValidators["match.item"] = MatcherTypeValidator().Validate

	return v
}()

func QueryParameterMatcherTypeValidator() db.Validator {
	return DefaultQueryParameterMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *RoleMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RoleMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RoleMatcherType) DeepCopy() *RoleMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RoleMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RoleMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RoleMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RoleMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateRoleMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRoleMatcherType) MatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for match")
	}

	return validatorFn, nil
}

func (v *ValidateRoleMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RoleMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RoleMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["match"]; exists {

		vOpts := append(opts, db.WithValidateField("match"))
		if err := fv(ctx, m.GetMatch(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRoleMatcherTypeValidator = func() *ValidateRoleMatcherType {
	v := &ValidateRoleMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMatch := v.MatchValidationRuleHandler
	rulesMatch := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "63",
	}
	vFn, err = vrhMatch(rulesMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RoleMatcherType.match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["match"] = vFn

	return v
}()

func RoleMatcherTypeValidator() db.Validator {
	return DefaultRoleMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SimpleWafExclusionRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SimpleWafExclusionRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SimpleWafExclusionRule) DeepCopy() *SimpleWafExclusionRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SimpleWafExclusionRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SimpleWafExclusionRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SimpleWafExclusionRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SimpleWafExclusionRuleValidator().Validate(ctx, m, opts...)
}

type ValidateSimpleWafExclusionRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSimpleWafExclusionRule) DomainChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_choice")
	}
	return validatorFn, nil
}

func (v *ValidateSimpleWafExclusionRule) DomainChoiceDomainRegexValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_DomainRegex, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_regex")
	}
	return oValidatorFn_DomainRegex, nil
}

func (v *ValidateSimpleWafExclusionRule) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateSimpleWafExclusionRule) DescriptionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for description")
	}

	return validatorFn, nil
}

func (v *ValidateSimpleWafExclusionRule) PathRegexValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for path_regex")
	}

	return validatorFn, nil
}

func (v *ValidateSimpleWafExclusionRule) MethodsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.HttpMethod)
		return int32(i)
	}
	// ves_io_schema.HttpMethod_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, ves_io_schema.HttpMethod_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for methods")
	}
	itemsValidatorFn := func(ctx context.Context, elems []ves_io_schema.HttpMethod, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for methods")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]ves_io_schema.HttpMethod)
		if !ok {
			return fmt.Errorf("Repeated validation expected []ves_io_schema.HttpMethod, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated methods")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items methods")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSimpleWafExclusionRule) ExcludeRuleIdsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema_waf_rule_list.WafRuleID)
		return int32(i)
	}
	// ves_io_schema_waf_rule_list.WafRuleID_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, ves_io_schema_waf_rule_list.WafRuleID_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for exclude_rule_ids")
	}
	itemsValidatorFn := func(ctx context.Context, elems []ves_io_schema_waf_rule_list.WafRuleID, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exclude_rule_ids")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]ves_io_schema_waf_rule_list.WafRuleID)
		if !ok {
			return fmt.Errorf("Repeated validation expected []ves_io_schema_waf_rule_list.WafRuleID, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exclude_rule_ids")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exclude_rule_ids")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSimpleWafExclusionRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SimpleWafExclusionRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SimpleWafExclusionRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["domain_choice"]; exists {
		val := m.GetDomainChoice()
		vOpts := append(opts,
			db.WithValidateField("domain_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDomainChoice().(type) {
	case *SimpleWafExclusionRule_AnyDomain:
		if fv, exists := v.FldValidators["domain_choice.any_domain"]; exists {
			val := m.GetDomainChoice().(*SimpleWafExclusionRule_AnyDomain).AnyDomain
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("any_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SimpleWafExclusionRule_DomainRegex:
		if fv, exists := v.FldValidators["domain_choice.domain_regex"]; exists {
			val := m.GetDomainChoice().(*SimpleWafExclusionRule_DomainRegex).DomainRegex
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("domain_regex"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["exclude_rule_ids"]; exists {
		vOpts := append(opts, db.WithValidateField("exclude_rule_ids"))
		if err := fv(ctx, m.GetExcludeRuleIds(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["expiration_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("expiration_timestamp"))
		if err := fv(ctx, m.GetExpirationTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["methods"]; exists {
		vOpts := append(opts, db.WithValidateField("methods"))
		if err := fv(ctx, m.GetMethods(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path_regex"]; exists {

		vOpts := append(opts, db.WithValidateField("path_regex"))
		if err := fv(ctx, m.GetPathRegex(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSimpleWafExclusionRuleValidator = func() *ValidateSimpleWafExclusionRule {
	v := &ValidateSimpleWafExclusionRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomainChoice := v.DomainChoiceValidationRuleHandler
	rulesDomainChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDomainChoice(rulesDomainChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleWafExclusionRule.domain_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_choice"] = vFn

	vrhDomainChoiceDomainRegex := v.DomainChoiceDomainRegexValidationRuleHandler
	rulesDomainChoiceDomainRegex := map[string]string{
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.vh_domain": "true",
	}
	vFnMap["domain_choice.domain_regex"], err = vrhDomainChoiceDomainRegex(rulesDomainChoiceDomainRegex)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field SimpleWafExclusionRule.domain_choice_domain_regex: %s", err)
		panic(errMsg)
	}

	v.FldValidators["domain_choice.domain_regex"] = vFnMap["domain_choice.domain_regex"]

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleWafExclusionRule.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhDescription := v.DescriptionValidationRuleHandler
	rulesDescription := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhDescription(rulesDescription)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleWafExclusionRule.description: %s", err)
		panic(errMsg)
	}
	v.FldValidators["description"] = vFn

	vrhPathRegex := v.PathRegexValidationRuleHandler
	rulesPathRegex := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "256",
		"ves.io.schema.rules.string.regex":     "true",
	}
	vFn, err = vrhPathRegex(rulesPathRegex)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleWafExclusionRule.path_regex: %s", err)
		panic(errMsg)
	}
	v.FldValidators["path_regex"] = vFn

	vrhMethods := v.MethodsValidationRuleHandler
	rulesMethods := map[string]string{
		"ves.io.schema.rules.enum.defined_only": "true",
		"ves.io.schema.rules.repeated.unique":   "true",
	}
	vFn, err = vrhMethods(rulesMethods)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleWafExclusionRule.methods: %s", err)
		panic(errMsg)
	}
	v.FldValidators["methods"] = vFn

	vrhExcludeRuleIds := v.ExcludeRuleIdsValidationRuleHandler
	rulesExcludeRuleIds := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhExcludeRuleIds(rulesExcludeRuleIds)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleWafExclusionRule.exclude_rule_ids: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exclude_rule_ids"] = vFn

	return v
}()

func SimpleWafExclusionRuleValidator() db.Validator {
	return DefaultSimpleWafExclusionRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *StringMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StringMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StringMatcherType) DeepCopy() *StringMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StringMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StringMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StringMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StringMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateStringMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStringMatcherType) MatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for match")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for match")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated match")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items match")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateStringMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StringMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StringMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["match"]; exists {
		vOpts := append(opts, db.WithValidateField("match"))
		if err := fv(ctx, m.GetMatch(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStringMatcherTypeValidator = func() *ValidateStringMatcherType {
	v := &ValidateStringMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMatch := v.MatchValidationRuleHandler
	rulesMatch := map[string]string{
		"ves.io.schema.rules.message.required":                "true",
		"ves.io.schema.rules.repeated.items.string.max_bytes": "63",
		"ves.io.schema.rules.repeated.max_items":              "64",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhMatch(rulesMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StringMatcherType.match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["match"] = vFn

	return v
}()

func StringMatcherTypeValidator() db.Validator {
	return DefaultStringMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TlsFingerprintMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TlsFingerprintMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TlsFingerprintMatcherType) DeepCopy() *TlsFingerprintMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TlsFingerprintMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TlsFingerprintMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TlsFingerprintMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TlsFingerprintMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateTlsFingerprintMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTlsFingerprintMatcherType) ClassesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(KnownTlsFingerprintClass)
		return int32(i)
	}
	// KnownTlsFingerprintClass_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, KnownTlsFingerprintClass_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for classes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []KnownTlsFingerprintClass, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for classes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]KnownTlsFingerprintClass)
		if !ok {
			return fmt.Errorf("Repeated validation expected []KnownTlsFingerprintClass, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated classes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items classes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateTlsFingerprintMatcherType) ExactValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for exact_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exact_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exact_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exact_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateTlsFingerprintMatcherType) ExcludedValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for excluded_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for excluded_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated excluded_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items excluded_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateTlsFingerprintMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TlsFingerprintMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TlsFingerprintMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["classes"]; exists {
		vOpts := append(opts, db.WithValidateField("classes"))
		if err := fv(ctx, m.GetClasses(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["exact_values"]; exists {
		vOpts := append(opts, db.WithValidateField("exact_values"))
		if err := fv(ctx, m.GetExactValues(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["excluded_values"]; exists {
		vOpts := append(opts, db.WithValidateField("excluded_values"))
		if err := fv(ctx, m.GetExcludedValues(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTlsFingerprintMatcherTypeValidator = func() *ValidateTlsFingerprintMatcherType {
	v := &ValidateTlsFingerprintMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhClasses := v.ClassesValidationRuleHandler
	rulesClasses := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhClasses(rulesClasses)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TlsFingerprintMatcherType.classes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["classes"] = vFn

	vrhExactValues := v.ExactValuesValidationRuleHandler
	rulesExactValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.len": "32",
		"ves.io.schema.rules.repeated.max_items":        "16",
		"ves.io.schema.rules.repeated.unique":           "true",
	}
	vFn, err = vrhExactValues(rulesExactValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TlsFingerprintMatcherType.exact_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exact_values"] = vFn

	vrhExcludedValues := v.ExcludedValuesValidationRuleHandler
	rulesExcludedValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.len": "32",
		"ves.io.schema.rules.repeated.max_items":        "32",
		"ves.io.schema.rules.repeated.unique":           "true",
	}
	vFn, err = vrhExcludedValues(rulesExcludedValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TlsFingerprintMatcherType.excluded_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["excluded_values"] = vFn

	return v
}()

func TlsFingerprintMatcherTypeValidator() db.Validator {
	return DefaultTlsFingerprintMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *URLItem) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *URLItem) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *URLItem) DeepCopy() *URLItem {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &URLItem{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *URLItem) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *URLItem) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return URLItemValidator().Validate(ctx, m, opts...)
}

type ValidateURLItem struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateURLItem) DomainChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_choice")
	}
	return validatorFn, nil
}

func (v *ValidateURLItem) DomainChoiceDomainValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_DomainValue, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_value")
	}
	return oValidatorFn_DomainValue, nil
}
func (v *ValidateURLItem) DomainChoiceDomainRegexValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_DomainRegex, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_regex")
	}
	return oValidatorFn_DomainRegex, nil
}

func (v *ValidateURLItem) PathChoicePathValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_PathValue, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for path_value")
	}
	return oValidatorFn_PathValue, nil
}
func (v *ValidateURLItem) PathChoicePathRegexValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_PathRegex, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for path_regex")
	}
	return oValidatorFn_PathRegex, nil
}
func (v *ValidateURLItem) PathChoicePathPrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_PathPrefix, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for path_prefix")
	}
	return oValidatorFn_PathPrefix, nil
}

func (v *ValidateURLItem) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*URLItem)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *URLItem got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domain_choice"]; exists {
		val := m.GetDomainChoice()
		vOpts := append(opts,
			db.WithValidateField("domain_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDomainChoice().(type) {
	case *URLItem_DomainValue:
		if fv, exists := v.FldValidators["domain_choice.domain_value"]; exists {
			val := m.GetDomainChoice().(*URLItem_DomainValue).DomainValue
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("domain_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *URLItem_DomainRegex:
		if fv, exists := v.FldValidators["domain_choice.domain_regex"]; exists {
			val := m.GetDomainChoice().(*URLItem_DomainRegex).DomainRegex
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("domain_regex"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetPathChoice().(type) {
	case *URLItem_PathValue:
		if fv, exists := v.FldValidators["path_choice.path_value"]; exists {
			val := m.GetPathChoice().(*URLItem_PathValue).PathValue
			vOpts := append(opts,
				db.WithValidateField("path_choice"),
				db.WithValidateField("path_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *URLItem_PathRegex:
		if fv, exists := v.FldValidators["path_choice.path_regex"]; exists {
			val := m.GetPathChoice().(*URLItem_PathRegex).PathRegex
			vOpts := append(opts,
				db.WithValidateField("path_choice"),
				db.WithValidateField("path_regex"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *URLItem_PathPrefix:
		if fv, exists := v.FldValidators["path_choice.path_prefix"]; exists {
			val := m.GetPathChoice().(*URLItem_PathPrefix).PathPrefix
			vOpts := append(opts,
				db.WithValidateField("path_choice"),
				db.WithValidateField("path_prefix"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultURLItemValidator = func() *ValidateURLItem {
	v := &ValidateURLItem{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomainChoice := v.DomainChoiceValidationRuleHandler
	rulesDomainChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDomainChoice(rulesDomainChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for URLItem.domain_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_choice"] = vFn

	vrhDomainChoiceDomainValue := v.DomainChoiceDomainValueValidationRuleHandler
	rulesDomainChoiceDomainValue := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
	}
	vFnMap["domain_choice.domain_value"], err = vrhDomainChoiceDomainValue(rulesDomainChoiceDomainValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field URLItem.domain_choice_domain_value: %s", err)
		panic(errMsg)
	}
	vrhDomainChoiceDomainRegex := v.DomainChoiceDomainRegexValidationRuleHandler
	rulesDomainChoiceDomainRegex := map[string]string{
		"ves.io.schema.rules.string.regex": "true",
	}
	vFnMap["domain_choice.domain_regex"], err = vrhDomainChoiceDomainRegex(rulesDomainChoiceDomainRegex)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field URLItem.domain_choice_domain_regex: %s", err)
		panic(errMsg)
	}

	v.FldValidators["domain_choice.domain_value"] = vFnMap["domain_choice.domain_value"]
	v.FldValidators["domain_choice.domain_regex"] = vFnMap["domain_choice.domain_regex"]

	vrhPathChoicePathValue := v.PathChoicePathValueValidationRuleHandler
	rulesPathChoicePathValue := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFnMap["path_choice.path_value"], err = vrhPathChoicePathValue(rulesPathChoicePathValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field URLItem.path_choice_path_value: %s", err)
		panic(errMsg)
	}
	vrhPathChoicePathRegex := v.PathChoicePathRegexValidationRuleHandler
	rulesPathChoicePathRegex := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.regex":   "true",
	}
	vFnMap["path_choice.path_regex"], err = vrhPathChoicePathRegex(rulesPathChoicePathRegex)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field URLItem.path_choice_path_regex: %s", err)
		panic(errMsg)
	}
	vrhPathChoicePathPrefix := v.PathChoicePathPrefixValidationRuleHandler
	rulesPathChoicePathPrefix := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFnMap["path_choice.path_prefix"], err = vrhPathChoicePathPrefix(rulesPathChoicePathPrefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field URLItem.path_choice_path_prefix: %s", err)
		panic(errMsg)
	}

	v.FldValidators["path_choice.path_value"] = vFnMap["path_choice.path_value"]
	v.FldValidators["path_choice.path_regex"] = vFnMap["path_choice.path_regex"]
	v.FldValidators["path_choice.path_prefix"] = vFnMap["path_choice.path_prefix"]

	return v
}()

func URLItemValidator() db.Validator {
	return DefaultURLItemValidator
}

// augmented methods on protoc/std generated struct

func (m *URLMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *URLMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *URLMatcherType) DeepCopy() *URLMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &URLMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *URLMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *URLMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return URLMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateURLMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateURLMatcherType) UrlItemsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*URLItem, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := URLItemValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for url_items")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*URLItem)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*URLItem, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated url_items")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items url_items")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateURLMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*URLMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *URLMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["url_items"]; exists {
		vOpts := append(opts, db.WithValidateField("url_items"))
		if err := fv(ctx, m.GetUrlItems(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultURLMatcherTypeValidator = func() *ValidateURLMatcherType {
	v := &ValidateURLMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhUrlItems := v.UrlItemsValidationRuleHandler
	rulesUrlItems := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhUrlItems(rulesUrlItems)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for URLMatcherType.url_items: %s", err)
		panic(errMsg)
	}
	v.FldValidators["url_items"] = vFn

	return v
}()

func URLMatcherTypeValidator() db.Validator {
	return DefaultURLMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *WafAction) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WafAction) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WafAction) DeepCopy() *WafAction {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WafAction{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WafAction) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WafAction) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WafActionValidator().Validate(ctx, m, opts...)
}

func (m *WafAction) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetActionTypeDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *WafAction) GetActionTypeDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.ActionType == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetActionType().(type) {
	case *WafAction_WafSkipProcessing:

	case *WafAction_WafRuleControl:
		odrInfos, err = m.GetWafRuleControl().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "waf_rule_control." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	case *WafAction_None:

	case *WafAction_WafInlineRuleControl:

	}

	return drInfos, err
}

type ValidateWafAction struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWafAction) ActionTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for action_type")
	}
	return validatorFn, nil
}

func (v *ValidateWafAction) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WafAction)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WafAction got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["action_type"]; exists {
		val := m.GetActionType()
		vOpts := append(opts,
			db.WithValidateField("action_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetActionType().(type) {
	case *WafAction_WafSkipProcessing:
		if fv, exists := v.FldValidators["action_type.waf_skip_processing"]; exists {
			val := m.GetActionType().(*WafAction_WafSkipProcessing).WafSkipProcessing
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("waf_skip_processing"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WafAction_WafRuleControl:
		if fv, exists := v.FldValidators["action_type.waf_rule_control"]; exists {
			val := m.GetActionType().(*WafAction_WafRuleControl).WafRuleControl
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("waf_rule_control"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WafAction_None:
		if fv, exists := v.FldValidators["action_type.none"]; exists {
			val := m.GetActionType().(*WafAction_None).None
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WafAction_WafInlineRuleControl:
		if fv, exists := v.FldValidators["action_type.waf_inline_rule_control"]; exists {
			val := m.GetActionType().(*WafAction_WafInlineRuleControl).WafInlineRuleControl
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("waf_inline_rule_control"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWafActionValidator = func() *ValidateWafAction {
	v := &ValidateWafAction{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhActionType := v.ActionTypeValidationRuleHandler
	rulesActionType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhActionType(rulesActionType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WafAction.action_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["action_type"] = vFn

	v.FldValidators["action_type.waf_rule_control"] = WafRuleControlValidator().Validate
	v.FldValidators["action_type.waf_inline_rule_control"] = WafInlineRuleControlValidator().Validate

	return v
}()

func WafActionValidator() db.Validator {
	return DefaultWafActionValidator
}

// augmented methods on protoc/std generated struct

func (m *WafInlineRuleControl) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WafInlineRuleControl) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WafInlineRuleControl) DeepCopy() *WafInlineRuleControl {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WafInlineRuleControl{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WafInlineRuleControl) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WafInlineRuleControl) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WafInlineRuleControlValidator().Validate(ctx, m, opts...)
}

type ValidateWafInlineRuleControl struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWafInlineRuleControl) ExcludeRuleIdsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema_waf_rule_list.WafRuleID)
		return int32(i)
	}
	// ves_io_schema_waf_rule_list.WafRuleID_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, ves_io_schema_waf_rule_list.WafRuleID_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for exclude_rule_ids")
	}
	itemsValidatorFn := func(ctx context.Context, elems []ves_io_schema_waf_rule_list.WafRuleID, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exclude_rule_ids")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]ves_io_schema_waf_rule_list.WafRuleID)
		if !ok {
			return fmt.Errorf("Repeated validation expected []ves_io_schema_waf_rule_list.WafRuleID, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exclude_rule_ids")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exclude_rule_ids")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateWafInlineRuleControl) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WafInlineRuleControl)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WafInlineRuleControl got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["exclude_rule_ids"]; exists {
		vOpts := append(opts, db.WithValidateField("exclude_rule_ids"))
		if err := fv(ctx, m.GetExcludeRuleIds(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWafInlineRuleControlValidator = func() *ValidateWafInlineRuleControl {
	v := &ValidateWafInlineRuleControl{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhExcludeRuleIds := v.ExcludeRuleIdsValidationRuleHandler
	rulesExcludeRuleIds := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhExcludeRuleIds(rulesExcludeRuleIds)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WafInlineRuleControl.exclude_rule_ids: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exclude_rule_ids"] = vFn

	return v
}()

func WafInlineRuleControlValidator() db.Validator {
	return DefaultWafInlineRuleControlValidator
}

// augmented methods on protoc/std generated struct

func (m *WafRuleControl) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WafRuleControl) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WafRuleControl) DeepCopy() *WafRuleControl {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WafRuleControl{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WafRuleControl) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WafRuleControl) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WafRuleControlValidator().Validate(ctx, m, opts...)
}

func (m *WafRuleControl) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetExcludeRuleIdsDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *WafRuleControl) GetExcludeRuleIdsDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetExcludeRuleIds() {
		if ref == nil {
			return nil, fmt.Errorf("WafRuleControl.exclude_rule_ids[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "waf_rule_list.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "exclude_rule_ids",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetExcludeRuleIdsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *WafRuleControl) GetExcludeRuleIdsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "waf_rule_list.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: waf_rule_list")
	}
	for _, ref := range m.GetExcludeRuleIds() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateWafRuleControl struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWafRuleControl) ExcludeRuleIdsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exclude_rule_ids")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exclude_rule_ids")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exclude_rule_ids")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateWafRuleControl) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WafRuleControl)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WafRuleControl got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["exclude_rule_ids"]; exists {
		vOpts := append(opts, db.WithValidateField("exclude_rule_ids"))
		if err := fv(ctx, m.GetExcludeRuleIds(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWafRuleControlValidator = func() *ValidateWafRuleControl {
	v := &ValidateWafRuleControl{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhExcludeRuleIds := v.ExcludeRuleIdsValidationRuleHandler
	rulesExcludeRuleIds := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhExcludeRuleIds(rulesExcludeRuleIds)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WafRuleControl.exclude_rule_ids: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exclude_rule_ids"] = vFn

	return v
}()

func WafRuleControlValidator() db.Validator {
	return DefaultWafRuleControlValidator
}

func (m *MatcherTypeBasic) FromMatcherType(f *MatcherType) {
	if f == nil {
		return
	}
	m.ExactValues = f.GetExactValues()
	m.RegexValues = f.GetRegexValues()
}

func (m *MatcherTypeBasic) ToMatcherType(f *MatcherType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	f.ExactValues = m1.ExactValues
	f.RegexValues = m1.RegexValues
}
