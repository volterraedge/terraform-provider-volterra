// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package policy

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_app_firewall "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/app_firewall"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *ActiveEnhancedFirewallPoliciesType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ActiveEnhancedFirewallPoliciesType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ActiveEnhancedFirewallPoliciesType) DeepCopy() *ActiveEnhancedFirewallPoliciesType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ActiveEnhancedFirewallPoliciesType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ActiveEnhancedFirewallPoliciesType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ActiveEnhancedFirewallPoliciesType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ActiveEnhancedFirewallPoliciesTypeValidator().Validate(ctx, m, opts...)
}

func (m *ActiveEnhancedFirewallPoliciesType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetEnhancedFirewallPoliciesDRefInfo()

}

func (m *ActiveEnhancedFirewallPoliciesType) GetEnhancedFirewallPoliciesDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetEnhancedFirewallPolicies()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("ActiveEnhancedFirewallPoliciesType.enhanced_firewall_policies[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("enhanced_firewall_policy.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "enhanced_firewall_policy.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "enhanced_firewall_policies",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetEnhancedFirewallPoliciesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ActiveEnhancedFirewallPoliciesType) GetEnhancedFirewallPoliciesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "enhanced_firewall_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: enhanced_firewall_policy")
	}
	for i, vref := range m.GetEnhancedFirewallPolicies() {
		if vref == nil {
			return nil, fmt.Errorf("ActiveEnhancedFirewallPoliciesType.enhanced_firewall_policies[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "enhanced_firewall_policy.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateActiveEnhancedFirewallPoliciesType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateActiveEnhancedFirewallPoliciesType) EnhancedFirewallPoliciesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for enhanced_firewall_policies")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for enhanced_firewall_policies")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated enhanced_firewall_policies")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items enhanced_firewall_policies")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateActiveEnhancedFirewallPoliciesType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ActiveEnhancedFirewallPoliciesType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ActiveEnhancedFirewallPoliciesType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["enhanced_firewall_policies"]; exists {
		vOpts := append(opts, db.WithValidateField("enhanced_firewall_policies"))
		if err := fv(ctx, m.GetEnhancedFirewallPolicies(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultActiveEnhancedFirewallPoliciesTypeValidator = func() *ValidateActiveEnhancedFirewallPoliciesType {
	v := &ValidateActiveEnhancedFirewallPoliciesType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhEnhancedFirewallPolicies := v.EnhancedFirewallPoliciesValidationRuleHandler
	rulesEnhancedFirewallPolicies := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "128",
		"ves.io.schema.rules.repeated.min_items": "1",
	}
	vFn, err = vrhEnhancedFirewallPolicies(rulesEnhancedFirewallPolicies)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ActiveEnhancedFirewallPoliciesType.enhanced_firewall_policies: %s", err)
		panic(errMsg)
	}
	v.FldValidators["enhanced_firewall_policies"] = vFn

	return v
}()

func ActiveEnhancedFirewallPoliciesTypeValidator() db.Validator {
	return DefaultActiveEnhancedFirewallPoliciesTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ActiveForwardProxyPoliciesType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ActiveForwardProxyPoliciesType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ActiveForwardProxyPoliciesType) DeepCopy() *ActiveForwardProxyPoliciesType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ActiveForwardProxyPoliciesType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ActiveForwardProxyPoliciesType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ActiveForwardProxyPoliciesType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ActiveForwardProxyPoliciesTypeValidator().Validate(ctx, m, opts...)
}

func (m *ActiveForwardProxyPoliciesType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetForwardProxyPoliciesDRefInfo()

}

func (m *ActiveForwardProxyPoliciesType) GetForwardProxyPoliciesDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetForwardProxyPolicies()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("ActiveForwardProxyPoliciesType.forward_proxy_policies[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("forward_proxy_policy.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "forward_proxy_policy.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "forward_proxy_policies",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetForwardProxyPoliciesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ActiveForwardProxyPoliciesType) GetForwardProxyPoliciesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "forward_proxy_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: forward_proxy_policy")
	}
	for i, vref := range m.GetForwardProxyPolicies() {
		if vref == nil {
			return nil, fmt.Errorf("ActiveForwardProxyPoliciesType.forward_proxy_policies[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "forward_proxy_policy.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateActiveForwardProxyPoliciesType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateActiveForwardProxyPoliciesType) ForwardProxyPoliciesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for forward_proxy_policies")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for forward_proxy_policies")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated forward_proxy_policies")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items forward_proxy_policies")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateActiveForwardProxyPoliciesType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ActiveForwardProxyPoliciesType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ActiveForwardProxyPoliciesType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["forward_proxy_policies"]; exists {
		vOpts := append(opts, db.WithValidateField("forward_proxy_policies"))
		if err := fv(ctx, m.GetForwardProxyPolicies(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultActiveForwardProxyPoliciesTypeValidator = func() *ValidateActiveForwardProxyPoliciesType {
	v := &ValidateActiveForwardProxyPoliciesType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhForwardProxyPolicies := v.ForwardProxyPoliciesValidationRuleHandler
	rulesForwardProxyPolicies := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "128",
		"ves.io.schema.rules.repeated.min_items": "1",
	}
	vFn, err = vrhForwardProxyPolicies(rulesForwardProxyPolicies)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ActiveForwardProxyPoliciesType.forward_proxy_policies: %s", err)
		panic(errMsg)
	}
	v.FldValidators["forward_proxy_policies"] = vFn

	return v
}()

func ActiveForwardProxyPoliciesTypeValidator() db.Validator {
	return DefaultActiveForwardProxyPoliciesTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ActiveServicePoliciesType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ActiveServicePoliciesType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ActiveServicePoliciesType) DeepCopy() *ActiveServicePoliciesType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ActiveServicePoliciesType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ActiveServicePoliciesType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ActiveServicePoliciesType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ActiveServicePoliciesTypeValidator().Validate(ctx, m, opts...)
}

func (m *ActiveServicePoliciesType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetServicePoliciesDRefInfo()

}

func (m *ActiveServicePoliciesType) GetServicePoliciesDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetServicePolicies()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("ActiveServicePoliciesType.service_policies[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("service_policy.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "service_policy.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "service_policies",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetServicePoliciesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ActiveServicePoliciesType) GetServicePoliciesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "service_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: service_policy")
	}
	for i, vref := range m.GetServicePolicies() {
		if vref == nil {
			return nil, fmt.Errorf("ActiveServicePoliciesType.service_policies[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "service_policy.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateActiveServicePoliciesType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateActiveServicePoliciesType) ServicePoliciesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for service_policies")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for service_policies")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated service_policies")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items service_policies")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateActiveServicePoliciesType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ActiveServicePoliciesType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ActiveServicePoliciesType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["service_policies"]; exists {
		vOpts := append(opts, db.WithValidateField("service_policies"))
		if err := fv(ctx, m.GetServicePolicies(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultActiveServicePoliciesTypeValidator = func() *ValidateActiveServicePoliciesType {
	v := &ValidateActiveServicePoliciesType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhServicePolicies := v.ServicePoliciesValidationRuleHandler
	rulesServicePolicies := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhServicePolicies(rulesServicePolicies)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ActiveServicePoliciesType.service_policies: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_policies"] = vFn

	return v
}()

func ActiveServicePoliciesTypeValidator() db.Validator {
	return DefaultActiveServicePoliciesTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AppFirewallAttackTypeContext) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AppFirewallAttackTypeContext) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AppFirewallAttackTypeContext) DeepCopy() *AppFirewallAttackTypeContext {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AppFirewallAttackTypeContext{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AppFirewallAttackTypeContext) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AppFirewallAttackTypeContext) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AppFirewallAttackTypeContextValidator().Validate(ctx, m, opts...)
}

type ValidateAppFirewallAttackTypeContext struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAppFirewallAttackTypeContext) ExcludeAttackTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema_app_firewall.AttackType)
		return int32(i)
	}
	// ves_io_schema_app_firewall.AttackType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema_app_firewall.AttackType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for exclude_attack_type")
	}

	return validatorFn, nil
}

func (v *ValidateAppFirewallAttackTypeContext) ContextValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(DetectionContext)
		return int32(i)
	}
	// DetectionContext_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, DetectionContext_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for context")
	}

	return validatorFn, nil
}

func (v *ValidateAppFirewallAttackTypeContext) ContextNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for context_name")
	}

	return validatorFn, nil
}

func (v *ValidateAppFirewallAttackTypeContext) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AppFirewallAttackTypeContext)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AppFirewallAttackTypeContext got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["context"]; exists {

		vOpts := append(opts, db.WithValidateField("context"))
		if err := fv(ctx, m.GetContext(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["context_name"]; exists {

		vOpts := append(opts, db.WithValidateField("context_name"))
		if err := fv(ctx, m.GetContextName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["exclude_attack_type"]; exists {

		vOpts := append(opts, db.WithValidateField("exclude_attack_type"))
		if err := fv(ctx, m.GetExcludeAttackType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAppFirewallAttackTypeContextValidator = func() *ValidateAppFirewallAttackTypeContext {
	v := &ValidateAppFirewallAttackTypeContext{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhExcludeAttackType := v.ExcludeAttackTypeValidationRuleHandler
	rulesExcludeAttackType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhExcludeAttackType(rulesExcludeAttackType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppFirewallAttackTypeContext.exclude_attack_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exclude_attack_type"] = vFn

	vrhContext := v.ContextValidationRuleHandler
	rulesContext := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhContext(rulesContext)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppFirewallAttackTypeContext.context: %s", err)
		panic(errMsg)
	}
	v.FldValidators["context"] = vFn

	vrhContextName := v.ContextNameValidationRuleHandler
	rulesContextName := map[string]string{
		"ves.io.schema.rules.string.max_len": "128",
	}
	vFn, err = vrhContextName(rulesContextName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppFirewallAttackTypeContext.context_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["context_name"] = vFn

	return v
}()

func AppFirewallAttackTypeContextValidator() db.Validator {
	return DefaultAppFirewallAttackTypeContextValidator
}

// augmented methods on protoc/std generated struct

func (m *AppFirewallDetectionControl) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AppFirewallDetectionControl) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AppFirewallDetectionControl) DeepCopy() *AppFirewallDetectionControl {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AppFirewallDetectionControl{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AppFirewallDetectionControl) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AppFirewallDetectionControl) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AppFirewallDetectionControlValidator().Validate(ctx, m, opts...)
}

type ValidateAppFirewallDetectionControl struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAppFirewallDetectionControl) ExcludeSignatureContextsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for exclude_signature_contexts")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*AppFirewallSignatureContext, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := AppFirewallSignatureContextValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exclude_signature_contexts")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*AppFirewallSignatureContext)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*AppFirewallSignatureContext, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exclude_signature_contexts")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exclude_signature_contexts")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAppFirewallDetectionControl) ExcludeViolationContextsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for exclude_violation_contexts")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*AppFirewallViolationContext, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := AppFirewallViolationContextValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exclude_violation_contexts")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*AppFirewallViolationContext)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*AppFirewallViolationContext, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exclude_violation_contexts")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exclude_violation_contexts")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAppFirewallDetectionControl) ExcludeAttackTypeContextsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for exclude_attack_type_contexts")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*AppFirewallAttackTypeContext, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := AppFirewallAttackTypeContextValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exclude_attack_type_contexts")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*AppFirewallAttackTypeContext)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*AppFirewallAttackTypeContext, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exclude_attack_type_contexts")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exclude_attack_type_contexts")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAppFirewallDetectionControl) ExcludeBotNameContextsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for exclude_bot_name_contexts")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*BotNameContext, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := BotNameContextValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exclude_bot_name_contexts")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*BotNameContext)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*BotNameContext, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exclude_bot_name_contexts")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exclude_bot_name_contexts")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAppFirewallDetectionControl) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AppFirewallDetectionControl)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AppFirewallDetectionControl got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["exclude_attack_type_contexts"]; exists {
		vOpts := append(opts, db.WithValidateField("exclude_attack_type_contexts"))
		if err := fv(ctx, m.GetExcludeAttackTypeContexts(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["exclude_bot_name_contexts"]; exists {
		vOpts := append(opts, db.WithValidateField("exclude_bot_name_contexts"))
		if err := fv(ctx, m.GetExcludeBotNameContexts(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["exclude_signature_contexts"]; exists {
		vOpts := append(opts, db.WithValidateField("exclude_signature_contexts"))
		if err := fv(ctx, m.GetExcludeSignatureContexts(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["exclude_violation_contexts"]; exists {
		vOpts := append(opts, db.WithValidateField("exclude_violation_contexts"))
		if err := fv(ctx, m.GetExcludeViolationContexts(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAppFirewallDetectionControlValidator = func() *ValidateAppFirewallDetectionControl {
	v := &ValidateAppFirewallDetectionControl{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhExcludeSignatureContexts := v.ExcludeSignatureContextsValidationRuleHandler
	rulesExcludeSignatureContexts := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1024",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhExcludeSignatureContexts(rulesExcludeSignatureContexts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppFirewallDetectionControl.exclude_signature_contexts: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exclude_signature_contexts"] = vFn

	vrhExcludeViolationContexts := v.ExcludeViolationContextsValidationRuleHandler
	rulesExcludeViolationContexts := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhExcludeViolationContexts(rulesExcludeViolationContexts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppFirewallDetectionControl.exclude_violation_contexts: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exclude_violation_contexts"] = vFn

	vrhExcludeAttackTypeContexts := v.ExcludeAttackTypeContextsValidationRuleHandler
	rulesExcludeAttackTypeContexts := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhExcludeAttackTypeContexts(rulesExcludeAttackTypeContexts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppFirewallDetectionControl.exclude_attack_type_contexts: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exclude_attack_type_contexts"] = vFn

	vrhExcludeBotNameContexts := v.ExcludeBotNameContextsValidationRuleHandler
	rulesExcludeBotNameContexts := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhExcludeBotNameContexts(rulesExcludeBotNameContexts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppFirewallDetectionControl.exclude_bot_name_contexts: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exclude_bot_name_contexts"] = vFn

	return v
}()

func AppFirewallDetectionControlValidator() db.Validator {
	return DefaultAppFirewallDetectionControlValidator
}

// augmented methods on protoc/std generated struct

func (m *AppFirewallSignatureContext) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AppFirewallSignatureContext) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AppFirewallSignatureContext) DeepCopy() *AppFirewallSignatureContext {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AppFirewallSignatureContext{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AppFirewallSignatureContext) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AppFirewallSignatureContext) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AppFirewallSignatureContextValidator().Validate(ctx, m, opts...)
}

type ValidateAppFirewallSignatureContext struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAppFirewallSignatureContext) SignatureIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for signature_id")
	}

	return validatorFn, nil
}

func (v *ValidateAppFirewallSignatureContext) ContextValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(DetectionContext)
		return int32(i)
	}
	// DetectionContext_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, DetectionContext_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for context")
	}

	return validatorFn, nil
}

func (v *ValidateAppFirewallSignatureContext) ContextNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for context_name")
	}

	return validatorFn, nil
}

func (v *ValidateAppFirewallSignatureContext) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AppFirewallSignatureContext)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AppFirewallSignatureContext got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["context"]; exists {

		vOpts := append(opts, db.WithValidateField("context"))
		if err := fv(ctx, m.GetContext(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["context_name"]; exists {

		vOpts := append(opts, db.WithValidateField("context_name"))
		if err := fv(ctx, m.GetContextName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["signature_id"]; exists {

		vOpts := append(opts, db.WithValidateField("signature_id"))
		if err := fv(ctx, m.GetSignatureId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAppFirewallSignatureContextValidator = func() *ValidateAppFirewallSignatureContext {
	v := &ValidateAppFirewallSignatureContext{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSignatureId := v.SignatureIdValidationRuleHandler
	rulesSignatureId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "0",
		"ves.io.schema.rules.uint32.lte":       "299999999",
	}
	vFn, err = vrhSignatureId(rulesSignatureId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppFirewallSignatureContext.signature_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["signature_id"] = vFn

	vrhContext := v.ContextValidationRuleHandler
	rulesContext := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhContext(rulesContext)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppFirewallSignatureContext.context: %s", err)
		panic(errMsg)
	}
	v.FldValidators["context"] = vFn

	vrhContextName := v.ContextNameValidationRuleHandler
	rulesContextName := map[string]string{
		"ves.io.schema.rules.string.max_len": "128",
	}
	vFn, err = vrhContextName(rulesContextName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppFirewallSignatureContext.context_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["context_name"] = vFn

	return v
}()

func AppFirewallSignatureContextValidator() db.Validator {
	return DefaultAppFirewallSignatureContextValidator
}

// augmented methods on protoc/std generated struct

func (m *AppFirewallViolationContext) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AppFirewallViolationContext) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AppFirewallViolationContext) DeepCopy() *AppFirewallViolationContext {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AppFirewallViolationContext{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AppFirewallViolationContext) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AppFirewallViolationContext) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AppFirewallViolationContextValidator().Validate(ctx, m, opts...)
}

type ValidateAppFirewallViolationContext struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAppFirewallViolationContext) ExcludeViolationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema_app_firewall.AppFirewallViolationType)
		return int32(i)
	}
	// ves_io_schema_app_firewall.AppFirewallViolationType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema_app_firewall.AppFirewallViolationType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for exclude_violation")
	}

	return validatorFn, nil
}

func (v *ValidateAppFirewallViolationContext) ContextValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(DetectionContext)
		return int32(i)
	}
	// DetectionContext_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, DetectionContext_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for context")
	}

	return validatorFn, nil
}

func (v *ValidateAppFirewallViolationContext) ContextNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for context_name")
	}

	return validatorFn, nil
}

func (v *ValidateAppFirewallViolationContext) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AppFirewallViolationContext)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AppFirewallViolationContext got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["context"]; exists {

		vOpts := append(opts, db.WithValidateField("context"))
		if err := fv(ctx, m.GetContext(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["context_name"]; exists {

		vOpts := append(opts, db.WithValidateField("context_name"))
		if err := fv(ctx, m.GetContextName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["exclude_violation"]; exists {

		vOpts := append(opts, db.WithValidateField("exclude_violation"))
		if err := fv(ctx, m.GetExcludeViolation(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAppFirewallViolationContextValidator = func() *ValidateAppFirewallViolationContext {
	v := &ValidateAppFirewallViolationContext{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhExcludeViolation := v.ExcludeViolationValidationRuleHandler
	rulesExcludeViolation := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhExcludeViolation(rulesExcludeViolation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppFirewallViolationContext.exclude_violation: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exclude_violation"] = vFn

	vrhContext := v.ContextValidationRuleHandler
	rulesContext := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhContext(rulesContext)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppFirewallViolationContext.context: %s", err)
		panic(errMsg)
	}
	v.FldValidators["context"] = vFn

	vrhContextName := v.ContextNameValidationRuleHandler
	rulesContextName := map[string]string{
		"ves.io.schema.rules.string.max_len": "128",
	}
	vFn, err = vrhContextName(rulesContextName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppFirewallViolationContext.context_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["context_name"] = vFn

	return v
}()

func AppFirewallViolationContextValidator() db.Validator {
	return DefaultAppFirewallViolationContextValidator
}

// augmented methods on protoc/std generated struct

func (m *ArgMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ArgMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ArgMatcherType) DeepCopy() *ArgMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ArgMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ArgMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ArgMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ArgMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateArgMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateArgMatcherType) MatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for match")
	}
	return validatorFn, nil
}

func (v *ValidateArgMatcherType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateArgMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ArgMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ArgMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["match"]; exists {
		val := m.GetMatch()
		vOpts := append(opts,
			db.WithValidateField("match"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMatch().(type) {
	case *ArgMatcherType_Presence:
		if fv, exists := v.FldValidators["match.presence"]; exists {
			val := m.GetMatch().(*ArgMatcherType_Presence).Presence
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("presence"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ArgMatcherType_Item:
		if fv, exists := v.FldValidators["match.item"]; exists {
			val := m.GetMatch().(*ArgMatcherType_Item).Item
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("item"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ArgMatcherType_CheckPresent:
		if fv, exists := v.FldValidators["match.check_present"]; exists {
			val := m.GetMatch().(*ArgMatcherType_CheckPresent).CheckPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ArgMatcherType_CheckNotPresent:
		if fv, exists := v.FldValidators["match.check_not_present"]; exists {
			val := m.GetMatch().(*ArgMatcherType_CheckNotPresent).CheckNotPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_not_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultArgMatcherTypeValidator = func() *ValidateArgMatcherType {
	v := &ValidateArgMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMatch := v.MatchValidationRuleHandler
	rulesMatch := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMatch(rulesMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ArgMatcherType.match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["match"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.json_path": "true",
		"ves.io.schema.rules.string.max_bytes": "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ArgMatcherType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	v.FldValidators["match.item"] = MatcherTypeValidator().Validate

	return v
}()

func ArgMatcherTypeValidator() db.Validator {
	return DefaultArgMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AsnMatchList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AsnMatchList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AsnMatchList) DeepCopy() *AsnMatchList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AsnMatchList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AsnMatchList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AsnMatchList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AsnMatchListValidator().Validate(ctx, m, opts...)
}

type ValidateAsnMatchList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAsnMatchList) AsNumbersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepUint32ItemRules(rules)
	itemValFn, err := db.NewUint32ValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for as_numbers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []uint32, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for as_numbers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]uint32)
		if !ok {
			return fmt.Errorf("Repeated validation expected []uint32, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated as_numbers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items as_numbers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAsnMatchList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AsnMatchList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AsnMatchList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["as_numbers"]; exists {
		vOpts := append(opts, db.WithValidateField("as_numbers"))
		if err := fv(ctx, m.GetAsNumbers(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAsnMatchListValidator = func() *ValidateAsnMatchList {
	v := &ValidateAsnMatchList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAsNumbers := v.AsNumbersValidationRuleHandler
	rulesAsNumbers := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhAsNumbers(rulesAsNumbers)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AsnMatchList.as_numbers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["as_numbers"] = vFn

	return v
}()

func AsnMatchListValidator() db.Validator {
	return DefaultAsnMatchListValidator
}

// augmented methods on protoc/std generated struct

func (m *AsnMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AsnMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AsnMatcherType) DeepCopy() *AsnMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AsnMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AsnMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AsnMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AsnMatcherTypeValidator().Validate(ctx, m, opts...)
}

func (m *AsnMatcherType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetAsnSetsDRefInfo()

}

func (m *AsnMatcherType) GetAsnSetsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetAsnSets()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("AsnMatcherType.asn_sets[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "bgp_asn_set.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "asn_sets",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetAsnSetsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *AsnMatcherType) GetAsnSetsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "bgp_asn_set.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: bgp_asn_set")
	}
	for _, ref := range m.GetAsnSets() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateAsnMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAsnMatcherType) AsnSetsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for asn_sets")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for asn_sets")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated asn_sets")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items asn_sets")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAsnMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AsnMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AsnMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["asn_sets"]; exists {
		vOpts := append(opts, db.WithValidateField("asn_sets"))
		if err := fv(ctx, m.GetAsnSets(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAsnMatcherTypeValidator = func() *ValidateAsnMatcherType {
	v := &ValidateAsnMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAsnSets := v.AsnSetsValidationRuleHandler
	rulesAsnSets := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhAsnSets(rulesAsnSets)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AsnMatcherType.asn_sets: %s", err)
		panic(errMsg)
	}
	v.FldValidators["asn_sets"] = vFn

	return v
}()

func AsnMatcherTypeValidator() db.Validator {
	return DefaultAsnMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *BotAction) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BotAction) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BotAction) DeepCopy() *BotAction {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BotAction{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BotAction) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BotAction) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BotActionValidator().Validate(ctx, m, opts...)
}

type ValidateBotAction struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBotAction) ActionTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for action_type")
	}
	return validatorFn, nil
}

func (v *ValidateBotAction) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BotAction)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BotAction got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["action_type"]; exists {
		val := m.GetActionType()
		vOpts := append(opts,
			db.WithValidateField("action_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetActionType().(type) {
	case *BotAction_None:
		if fv, exists := v.FldValidators["action_type.none"]; exists {
			val := m.GetActionType().(*BotAction_None).None
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotAction_BotSkipProcessing:
		if fv, exists := v.FldValidators["action_type.bot_skip_processing"]; exists {
			val := m.GetActionType().(*BotAction_BotSkipProcessing).BotSkipProcessing
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("bot_skip_processing"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBotActionValidator = func() *ValidateBotAction {
	v := &ValidateBotAction{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhActionType := v.ActionTypeValidationRuleHandler
	rulesActionType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhActionType(rulesActionType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BotAction.action_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["action_type"] = vFn

	return v
}()

func BotActionValidator() db.Validator {
	return DefaultBotActionValidator
}

// augmented methods on protoc/std generated struct

func (m *BotNameContext) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BotNameContext) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BotNameContext) DeepCopy() *BotNameContext {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BotNameContext{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BotNameContext) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BotNameContext) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BotNameContextValidator().Validate(ctx, m, opts...)
}

type ValidateBotNameContext struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBotNameContext) BotNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bot_name")
	}

	return validatorFn, nil
}

func (v *ValidateBotNameContext) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BotNameContext)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BotNameContext got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["bot_name"]; exists {

		vOpts := append(opts, db.WithValidateField("bot_name"))
		if err := fv(ctx, m.GetBotName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBotNameContextValidator = func() *ValidateBotNameContext {
	v := &ValidateBotNameContext{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhBotName := v.BotNameValidationRuleHandler
	rulesBotName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhBotName(rulesBotName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BotNameContext.bot_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bot_name"] = vFn

	return v
}()

func BotNameContextValidator() db.Validator {
	return DefaultBotNameContextValidator
}

// augmented methods on protoc/std generated struct

func (m *ClientMatcher) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ClientMatcher) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ClientMatcher) DeepCopy() *ClientMatcher {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ClientMatcher{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ClientMatcher) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ClientMatcher) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ClientMatcherValidator().Validate(ctx, m, opts...)
}

func (m *ClientMatcher) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetIpAsnChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *ClientMatcher) GetIpAsnChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetIpAsnChoice() == nil {
		return nil, nil
	}
	switch m.GetIpAsnChoice().(type) {
	case *ClientMatcher_AnyIp:

		return nil, nil

	case *ClientMatcher_IpPrefixList:

		return nil, nil

	case *ClientMatcher_IpMatcher:

		drInfos, err := m.GetIpMatcher().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetIpMatcher().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "ip_matcher." + dri.DRField
		}
		return drInfos, err

	case *ClientMatcher_AsnList:

		return nil, nil

	case *ClientMatcher_AsnMatcher:

		drInfos, err := m.GetAsnMatcher().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAsnMatcher().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "asn_matcher." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateClientMatcher struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateClientMatcher) ClientChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for client_choice")
	}
	return validatorFn, nil
}

func (v *ValidateClientMatcher) IpAsnChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip_asn_choice")
	}
	return validatorFn, nil
}

func (v *ValidateClientMatcher) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ClientMatcher)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ClientMatcher got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["client_choice"]; exists {
		val := m.GetClientChoice()
		vOpts := append(opts,
			db.WithValidateField("client_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetClientChoice().(type) {
	case *ClientMatcher_AnyClient:
		if fv, exists := v.FldValidators["client_choice.any_client"]; exists {
			val := m.GetClientChoice().(*ClientMatcher_AnyClient).AnyClient
			vOpts := append(opts,
				db.WithValidateField("client_choice"),
				db.WithValidateField("any_client"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ClientMatcher_IpThreatCategoryList:
		if fv, exists := v.FldValidators["client_choice.ip_threat_category_list"]; exists {
			val := m.GetClientChoice().(*ClientMatcher_IpThreatCategoryList).IpThreatCategoryList
			vOpts := append(opts,
				db.WithValidateField("client_choice"),
				db.WithValidateField("ip_threat_category_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ClientMatcher_ClientSelector:
		if fv, exists := v.FldValidators["client_choice.client_selector"]; exists {
			val := m.GetClientChoice().(*ClientMatcher_ClientSelector).ClientSelector
			vOpts := append(opts,
				db.WithValidateField("client_choice"),
				db.WithValidateField("client_selector"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["ip_asn_choice"]; exists {
		val := m.GetIpAsnChoice()
		vOpts := append(opts,
			db.WithValidateField("ip_asn_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetIpAsnChoice().(type) {
	case *ClientMatcher_AnyIp:
		if fv, exists := v.FldValidators["ip_asn_choice.any_ip"]; exists {
			val := m.GetIpAsnChoice().(*ClientMatcher_AnyIp).AnyIp
			vOpts := append(opts,
				db.WithValidateField("ip_asn_choice"),
				db.WithValidateField("any_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ClientMatcher_IpPrefixList:
		if fv, exists := v.FldValidators["ip_asn_choice.ip_prefix_list"]; exists {
			val := m.GetIpAsnChoice().(*ClientMatcher_IpPrefixList).IpPrefixList
			vOpts := append(opts,
				db.WithValidateField("ip_asn_choice"),
				db.WithValidateField("ip_prefix_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ClientMatcher_IpMatcher:
		if fv, exists := v.FldValidators["ip_asn_choice.ip_matcher"]; exists {
			val := m.GetIpAsnChoice().(*ClientMatcher_IpMatcher).IpMatcher
			vOpts := append(opts,
				db.WithValidateField("ip_asn_choice"),
				db.WithValidateField("ip_matcher"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ClientMatcher_AsnList:
		if fv, exists := v.FldValidators["ip_asn_choice.asn_list"]; exists {
			val := m.GetIpAsnChoice().(*ClientMatcher_AsnList).AsnList
			vOpts := append(opts,
				db.WithValidateField("ip_asn_choice"),
				db.WithValidateField("asn_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ClientMatcher_AsnMatcher:
		if fv, exists := v.FldValidators["ip_asn_choice.asn_matcher"]; exists {
			val := m.GetIpAsnChoice().(*ClientMatcher_AsnMatcher).AsnMatcher
			vOpts := append(opts,
				db.WithValidateField("ip_asn_choice"),
				db.WithValidateField("asn_matcher"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tls_fingerprint_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_fingerprint_matcher"))
		if err := fv(ctx, m.GetTlsFingerprintMatcher(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultClientMatcherValidator = func() *ValidateClientMatcher {
	v := &ValidateClientMatcher{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhClientChoice := v.ClientChoiceValidationRuleHandler
	rulesClientChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhClientChoice(rulesClientChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ClientMatcher.client_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["client_choice"] = vFn

	vrhIpAsnChoice := v.IpAsnChoiceValidationRuleHandler
	rulesIpAsnChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhIpAsnChoice(rulesIpAsnChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ClientMatcher.ip_asn_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip_asn_choice"] = vFn

	v.FldValidators["client_choice.ip_threat_category_list"] = IPThreatCategoryListTypeValidator().Validate
	v.FldValidators["client_choice.client_selector"] = ves_io_schema.LabelSelectorTypeValidator().Validate

	v.FldValidators["ip_asn_choice.ip_prefix_list"] = PrefixMatchListValidator().Validate
	v.FldValidators["ip_asn_choice.ip_matcher"] = IpMatcherTypeValidator().Validate
	v.FldValidators["ip_asn_choice.asn_list"] = AsnMatchListValidator().Validate
	v.FldValidators["ip_asn_choice.asn_matcher"] = AsnMatcherTypeValidator().Validate

	v.FldValidators["tls_fingerprint_matcher"] = TlsFingerprintMatcherTypeValidator().Validate

	return v
}()

func ClientMatcherValidator() db.Validator {
	return DefaultClientMatcherValidator
}

// augmented methods on protoc/std generated struct

func (m *ContentRewriteAction) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ContentRewriteAction) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ContentRewriteAction) DeepCopy() *ContentRewriteAction {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ContentRewriteAction{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ContentRewriteAction) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ContentRewriteAction) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ContentRewriteActionValidator().Validate(ctx, m, opts...)
}

type ValidateContentRewriteAction struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateContentRewriteAction) InsertContentValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for insert_content")
	}

	return validatorFn, nil
}

func (v *ValidateContentRewriteAction) ElementSelectorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for element_selector")
	}

	return validatorFn, nil
}

func (v *ValidateContentRewriteAction) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ContentRewriteAction)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ContentRewriteAction got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["element_selector"]; exists {

		vOpts := append(opts, db.WithValidateField("element_selector"))
		if err := fv(ctx, m.GetElementSelector(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["insert_content"]; exists {

		vOpts := append(opts, db.WithValidateField("insert_content"))
		if err := fv(ctx, m.GetInsertContent(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inserted_types"]; exists {

		vOpts := append(opts, db.WithValidateField("inserted_types"))
		for key, value := range m.GetInsertedTypes() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["position"]; exists {

		vOpts := append(opts, db.WithValidateField("position"))
		if err := fv(ctx, m.GetPosition(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultContentRewriteActionValidator = func() *ValidateContentRewriteAction {
	v := &ValidateContentRewriteAction{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInsertContent := v.InsertContentValidationRuleHandler
	rulesInsertContent := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFn, err = vrhInsertContent(rulesInsertContent)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ContentRewriteAction.insert_content: %s", err)
		panic(errMsg)
	}
	v.FldValidators["insert_content"] = vFn

	vrhElementSelector := v.ElementSelectorValidationRuleHandler
	rulesElementSelector := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhElementSelector(rulesElementSelector)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ContentRewriteAction.element_selector: %s", err)
		panic(errMsg)
	}
	v.FldValidators["element_selector"] = vFn

	return v
}()

func ContentRewriteActionValidator() db.Validator {
	return DefaultContentRewriteActionValidator
}

// augmented methods on protoc/std generated struct

func (m *CookieMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CookieMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CookieMatcherType) DeepCopy() *CookieMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CookieMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CookieMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CookieMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CookieMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCookieMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCookieMatcherType) MatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for match")
	}
	return validatorFn, nil
}

func (v *ValidateCookieMatcherType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateCookieMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CookieMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CookieMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["match"]; exists {
		val := m.GetMatch()
		vOpts := append(opts,
			db.WithValidateField("match"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMatch().(type) {
	case *CookieMatcherType_Presence:
		if fv, exists := v.FldValidators["match.presence"]; exists {
			val := m.GetMatch().(*CookieMatcherType_Presence).Presence
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("presence"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CookieMatcherType_Item:
		if fv, exists := v.FldValidators["match.item"]; exists {
			val := m.GetMatch().(*CookieMatcherType_Item).Item
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("item"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CookieMatcherType_CheckPresent:
		if fv, exists := v.FldValidators["match.check_present"]; exists {
			val := m.GetMatch().(*CookieMatcherType_CheckPresent).CheckPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CookieMatcherType_CheckNotPresent:
		if fv, exists := v.FldValidators["match.check_not_present"]; exists {
			val := m.GetMatch().(*CookieMatcherType_CheckNotPresent).CheckNotPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_not_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCookieMatcherTypeValidator = func() *ValidateCookieMatcherType {
	v := &ValidateCookieMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMatch := v.MatchValidationRuleHandler
	rulesMatch := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMatch(rulesMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CookieMatcherType.match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["match"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CookieMatcherType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	v.FldValidators["match.item"] = MatcherTypeValidator().Validate

	return v
}()

func CookieMatcherTypeValidator() db.Validator {
	return DefaultCookieMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CountryCodeList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CountryCodeList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CountryCodeList) DeepCopy() *CountryCodeList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CountryCodeList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CountryCodeList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CountryCodeList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CountryCodeListValidator().Validate(ctx, m, opts...)
}

type ValidateCountryCodeList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCountryCodeList) CountryCodesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(CountryCode)
		return int32(i)
	}
	// CountryCode_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, CountryCode_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for country_codes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []CountryCode, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for country_codes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]CountryCode)
		if !ok {
			return fmt.Errorf("Repeated validation expected []CountryCode, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated country_codes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items country_codes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCountryCodeList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CountryCodeList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CountryCodeList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["country_codes"]; exists {
		vOpts := append(opts, db.WithValidateField("country_codes"))
		if err := fv(ctx, m.GetCountryCodes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["invert_match"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_match"))
		if err := fv(ctx, m.GetInvertMatch(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCountryCodeListValidator = func() *ValidateCountryCodeList {
	v := &ValidateCountryCodeList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCountryCodes := v.CountryCodesValidationRuleHandler
	rulesCountryCodes := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhCountryCodes(rulesCountryCodes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CountryCodeList.country_codes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["country_codes"] = vFn

	return v
}()

func CountryCodeListValidator() db.Validator {
	return DefaultCountryCodeListValidator
}

// augmented methods on protoc/std generated struct

func (m *DataGuardControl) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DataGuardControl) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DataGuardControl) DeepCopy() *DataGuardControl {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DataGuardControl{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DataGuardControl) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DataGuardControl) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DataGuardControlValidator().Validate(ctx, m, opts...)
}

type ValidateDataGuardControl struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDataGuardControl) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DataGuardControl)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DataGuardControl got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["policy_name"]; exists {

		vOpts := append(opts, db.WithValidateField("policy_name"))
		if err := fv(ctx, m.GetPolicyName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDataGuardControlValidator = func() *ValidateDataGuardControl {
	v := &ValidateDataGuardControl{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DataGuardControlValidator() db.Validator {
	return DefaultDataGuardControlValidator
}

// augmented methods on protoc/std generated struct

func (m *DenyInformation) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DenyInformation) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DenyInformation) DeepCopy() *DenyInformation {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DenyInformation{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DenyInformation) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DenyInformation) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DenyInformationValidator().Validate(ctx, m, opts...)
}

type ValidateDenyInformation struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDenyInformation) ResponseCodeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for response_code")
	}

	return validatorFn, nil
}

func (v *ValidateDenyInformation) ErrorMessageValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for error_message")
	}

	return validatorFn, nil
}

func (v *ValidateDenyInformation) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DenyInformation)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DenyInformation got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["error_message"]; exists {

		vOpts := append(opts, db.WithValidateField("error_message"))
		if err := fv(ctx, m.GetErrorMessage(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetEventType().(type) {
	case *DenyInformation_UndefinedSecEvent:
		if fv, exists := v.FldValidators["event_type.undefined_sec_event"]; exists {
			val := m.GetEventType().(*DenyInformation_UndefinedSecEvent).UndefinedSecEvent
			vOpts := append(opts,
				db.WithValidateField("event_type"),
				db.WithValidateField("undefined_sec_event"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DenyInformation_ApiSecEvent:
		if fv, exists := v.FldValidators["event_type.api_sec_event"]; exists {
			val := m.GetEventType().(*DenyInformation_ApiSecEvent).ApiSecEvent
			vOpts := append(opts,
				db.WithValidateField("event_type"),
				db.WithValidateField("api_sec_event"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["response_code"]; exists {

		vOpts := append(opts, db.WithValidateField("response_code"))
		if err := fv(ctx, m.GetResponseCode(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDenyInformationValidator = func() *ValidateDenyInformation {
	v := &ValidateDenyInformation{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhResponseCode := v.ResponseCodeValidationRuleHandler
	rulesResponseCode := map[string]string{
		"ves.io.schema.rules.uint32.lte": "599",
	}
	vFn, err = vrhResponseCode(rulesResponseCode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DenyInformation.response_code: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_code"] = vFn

	vrhErrorMessage := v.ErrorMessageValidationRuleHandler
	rulesErrorMessage := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "512",
	}
	vFn, err = vrhErrorMessage(rulesErrorMessage)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DenyInformation.error_message: %s", err)
		panic(errMsg)
	}
	v.FldValidators["error_message"] = vFn

	return v
}()

func DenyInformationValidator() db.Validator {
	return DefaultDenyInformationValidator
}

// augmented methods on protoc/std generated struct

func (m *GraphQLRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GraphQLRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GraphQLRule) DeepCopy() *GraphQLRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GraphQLRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GraphQLRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GraphQLRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GraphQLRuleValidator().Validate(ctx, m, opts...)
}

type ValidateGraphQLRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGraphQLRule) DomainChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGraphQLRule) DomainChoiceExactValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ExactValue, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for exact_value")
	}
	return oValidatorFn_ExactValue, nil
}
func (v *ValidateGraphQLRule) DomainChoiceSuffixValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SuffixValue, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for suffix_value")
	}
	return oValidatorFn_SuffixValue, nil
}

func (v *ValidateGraphQLRule) MethodChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for method_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGraphQLRule) MetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for metadata")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.MessageMetaTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGraphQLRule) ExactPathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for exact_path")
	}

	return validatorFn, nil
}

func (v *ValidateGraphQLRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GraphQLRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GraphQLRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domain_choice"]; exists {
		val := m.GetDomainChoice()
		vOpts := append(opts,
			db.WithValidateField("domain_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDomainChoice().(type) {
	case *GraphQLRule_AnyDomain:
		if fv, exists := v.FldValidators["domain_choice.any_domain"]; exists {
			val := m.GetDomainChoice().(*GraphQLRule_AnyDomain).AnyDomain
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("any_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GraphQLRule_ExactValue:
		if fv, exists := v.FldValidators["domain_choice.exact_value"]; exists {
			val := m.GetDomainChoice().(*GraphQLRule_ExactValue).ExactValue
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("exact_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GraphQLRule_SuffixValue:
		if fv, exists := v.FldValidators["domain_choice.suffix_value"]; exists {
			val := m.GetDomainChoice().(*GraphQLRule_SuffixValue).SuffixValue
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("suffix_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["exact_path"]; exists {

		vOpts := append(opts, db.WithValidateField("exact_path"))
		if err := fv(ctx, m.GetExactPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["graphql_settings"]; exists {

		vOpts := append(opts, db.WithValidateField("graphql_settings"))
		if err := fv(ctx, m.GetGraphqlSettings(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["method_choice"]; exists {
		val := m.GetMethodChoice()
		vOpts := append(opts,
			db.WithValidateField("method_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMethodChoice().(type) {
	case *GraphQLRule_MethodGet:
		if fv, exists := v.FldValidators["method_choice.method_get"]; exists {
			val := m.GetMethodChoice().(*GraphQLRule_MethodGet).MethodGet
			vOpts := append(opts,
				db.WithValidateField("method_choice"),
				db.WithValidateField("method_get"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GraphQLRule_MethodPost:
		if fv, exists := v.FldValidators["method_choice.method_post"]; exists {
			val := m.GetMethodChoice().(*GraphQLRule_MethodPost).MethodPost
			vOpts := append(opts,
				db.WithValidateField("method_choice"),
				db.WithValidateField("method_post"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGraphQLRuleValidator = func() *ValidateGraphQLRule {
	v := &ValidateGraphQLRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomainChoice := v.DomainChoiceValidationRuleHandler
	rulesDomainChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDomainChoice(rulesDomainChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GraphQLRule.domain_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_choice"] = vFn

	vrhDomainChoiceExactValue := v.DomainChoiceExactValueValidationRuleHandler
	rulesDomainChoiceExactValue := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
		"ves.io.schema.rules.string.max_len":  "256",
		"ves.io.schema.rules.string.min_len":  "1",
	}
	vFnMap["domain_choice.exact_value"], err = vrhDomainChoiceExactValue(rulesDomainChoiceExactValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GraphQLRule.domain_choice_exact_value: %s", err)
		panic(errMsg)
	}
	vrhDomainChoiceSuffixValue := v.DomainChoiceSuffixValueValidationRuleHandler
	rulesDomainChoiceSuffixValue := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
		"ves.io.schema.rules.string.max_len":  "256",
		"ves.io.schema.rules.string.min_len":  "1",
	}
	vFnMap["domain_choice.suffix_value"], err = vrhDomainChoiceSuffixValue(rulesDomainChoiceSuffixValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GraphQLRule.domain_choice_suffix_value: %s", err)
		panic(errMsg)
	}

	v.FldValidators["domain_choice.exact_value"] = vFnMap["domain_choice.exact_value"]
	v.FldValidators["domain_choice.suffix_value"] = vFnMap["domain_choice.suffix_value"]

	vrhMethodChoice := v.MethodChoiceValidationRuleHandler
	rulesMethodChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMethodChoice(rulesMethodChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GraphQLRule.method_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["method_choice"] = vFn

	vrhMetadata := v.MetadataValidationRuleHandler
	rulesMetadata := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMetadata(rulesMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GraphQLRule.metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metadata"] = vFn

	vrhExactPath := v.ExactPathValidationRuleHandler
	rulesExactPath := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.http_path": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFn, err = vrhExactPath(rulesExactPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GraphQLRule.exact_path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exact_path"] = vFn

	v.FldValidators["graphql_settings"] = GraphQLSettingsTypeValidator().Validate

	return v
}()

func GraphQLRuleValidator() db.Validator {
	return DefaultGraphQLRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *GraphQLSettingsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GraphQLSettingsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GraphQLSettingsType) DeepCopy() *GraphQLSettingsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GraphQLSettingsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GraphQLSettingsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GraphQLSettingsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GraphQLSettingsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGraphQLSettingsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGraphQLSettingsType) AllowIntrospectionQueriesChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for allow_introspection_queries_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGraphQLSettingsType) MaxTotalLengthValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_total_length")
	}

	return validatorFn, nil
}

func (v *ValidateGraphQLSettingsType) MaxValueLengthValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_value_length")
	}

	return validatorFn, nil
}

func (v *ValidateGraphQLSettingsType) MaxDepthValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_depth")
	}

	return validatorFn, nil
}

func (v *ValidateGraphQLSettingsType) MaxBatchedQueriesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_batched_queries")
	}

	return validatorFn, nil
}

func (v *ValidateGraphQLSettingsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GraphQLSettingsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GraphQLSettingsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["allow_introspection_queries_choice"]; exists {
		val := m.GetAllowIntrospectionQueriesChoice()
		vOpts := append(opts,
			db.WithValidateField("allow_introspection_queries_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAllowIntrospectionQueriesChoice().(type) {
	case *GraphQLSettingsType_DisableIntrospection:
		if fv, exists := v.FldValidators["allow_introspection_queries_choice.disable_introspection"]; exists {
			val := m.GetAllowIntrospectionQueriesChoice().(*GraphQLSettingsType_DisableIntrospection).DisableIntrospection
			vOpts := append(opts,
				db.WithValidateField("allow_introspection_queries_choice"),
				db.WithValidateField("disable_introspection"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GraphQLSettingsType_EnableIntrospection:
		if fv, exists := v.FldValidators["allow_introspection_queries_choice.enable_introspection"]; exists {
			val := m.GetAllowIntrospectionQueriesChoice().(*GraphQLSettingsType_EnableIntrospection).EnableIntrospection
			vOpts := append(opts,
				db.WithValidateField("allow_introspection_queries_choice"),
				db.WithValidateField("enable_introspection"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["max_batched_queries"]; exists {

		vOpts := append(opts, db.WithValidateField("max_batched_queries"))
		if err := fv(ctx, m.GetMaxBatchedQueries(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_depth"]; exists {

		vOpts := append(opts, db.WithValidateField("max_depth"))
		if err := fv(ctx, m.GetMaxDepth(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_total_length"]; exists {

		vOpts := append(opts, db.WithValidateField("max_total_length"))
		if err := fv(ctx, m.GetMaxTotalLength(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_value_length"]; exists {

		vOpts := append(opts, db.WithValidateField("max_value_length"))
		if err := fv(ctx, m.GetMaxValueLength(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["policy_name"]; exists {

		vOpts := append(opts, db.WithValidateField("policy_name"))
		if err := fv(ctx, m.GetPolicyName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGraphQLSettingsTypeValidator = func() *ValidateGraphQLSettingsType {
	v := &ValidateGraphQLSettingsType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAllowIntrospectionQueriesChoice := v.AllowIntrospectionQueriesChoiceValidationRuleHandler
	rulesAllowIntrospectionQueriesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAllowIntrospectionQueriesChoice(rulesAllowIntrospectionQueriesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GraphQLSettingsType.allow_introspection_queries_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["allow_introspection_queries_choice"] = vFn

	vrhMaxTotalLength := v.MaxTotalLengthValidationRuleHandler
	rulesMaxTotalLength := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "0",
		"ves.io.schema.rules.uint32.lte":       "16386",
	}
	vFn, err = vrhMaxTotalLength(rulesMaxTotalLength)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GraphQLSettingsType.max_total_length: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_total_length"] = vFn

	vrhMaxValueLength := v.MaxValueLengthValidationRuleHandler
	rulesMaxValueLength := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "0",
		"ves.io.schema.rules.uint32.lte":       "4096",
	}
	vFn, err = vrhMaxValueLength(rulesMaxValueLength)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GraphQLSettingsType.max_value_length: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_value_length"] = vFn

	vrhMaxDepth := v.MaxDepthValidationRuleHandler
	rulesMaxDepth := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "0",
		"ves.io.schema.rules.uint32.lte":       "20",
	}
	vFn, err = vrhMaxDepth(rulesMaxDepth)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GraphQLSettingsType.max_depth: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_depth"] = vFn

	vrhMaxBatchedQueries := v.MaxBatchedQueriesValidationRuleHandler
	rulesMaxBatchedQueries := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "0",
		"ves.io.schema.rules.uint32.lte":       "20",
	}
	vFn, err = vrhMaxBatchedQueries(rulesMaxBatchedQueries)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GraphQLSettingsType.max_batched_queries: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_batched_queries"] = vFn

	return v
}()

func GraphQLSettingsTypeValidator() db.Validator {
	return DefaultGraphQLSettingsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *HeaderMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HeaderMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HeaderMatcherType) DeepCopy() *HeaderMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HeaderMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HeaderMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HeaderMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HeaderMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateHeaderMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHeaderMatcherType) MatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for match")
	}
	return validatorFn, nil
}

func (v *ValidateHeaderMatcherType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateHeaderMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HeaderMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HeaderMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["match"]; exists {
		val := m.GetMatch()
		vOpts := append(opts,
			db.WithValidateField("match"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMatch().(type) {
	case *HeaderMatcherType_Presence:
		if fv, exists := v.FldValidators["match.presence"]; exists {
			val := m.GetMatch().(*HeaderMatcherType_Presence).Presence
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("presence"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HeaderMatcherType_Item:
		if fv, exists := v.FldValidators["match.item"]; exists {
			val := m.GetMatch().(*HeaderMatcherType_Item).Item
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("item"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HeaderMatcherType_CheckPresent:
		if fv, exists := v.FldValidators["match.check_present"]; exists {
			val := m.GetMatch().(*HeaderMatcherType_CheckPresent).CheckPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HeaderMatcherType_CheckNotPresent:
		if fv, exists := v.FldValidators["match.check_not_present"]; exists {
			val := m.GetMatch().(*HeaderMatcherType_CheckNotPresent).CheckNotPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_not_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHeaderMatcherTypeValidator = func() *ValidateHeaderMatcherType {
	v := &ValidateHeaderMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMatch := v.MatchValidationRuleHandler
	rulesMatch := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMatch(rulesMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderMatcherType.match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["match"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required":         "true",
		"ves.io.schema.rules.string.http_header_field": "true",
		"ves.io.schema.rules.string.max_bytes":         "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderMatcherType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	v.FldValidators["match.item"] = MatcherTypeValidator().Validate

	return v
}()

func HeaderMatcherTypeValidator() db.Validator {
	return DefaultHeaderMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *HeaderMatcherTypeBasic) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HeaderMatcherTypeBasic) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HeaderMatcherTypeBasic) DeepCopy() *HeaderMatcherTypeBasic {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HeaderMatcherTypeBasic{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HeaderMatcherTypeBasic) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HeaderMatcherTypeBasic) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HeaderMatcherTypeBasicValidator().Validate(ctx, m, opts...)
}

type ValidateHeaderMatcherTypeBasic struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHeaderMatcherTypeBasic) MatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for match")
	}
	return validatorFn, nil
}

func (v *ValidateHeaderMatcherTypeBasic) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateHeaderMatcherTypeBasic) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HeaderMatcherTypeBasic)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HeaderMatcherTypeBasic got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["match"]; exists {
		val := m.GetMatch()
		vOpts := append(opts,
			db.WithValidateField("match"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMatch().(type) {
	case *HeaderMatcherTypeBasic_Item:
		if fv, exists := v.FldValidators["match.item"]; exists {
			val := m.GetMatch().(*HeaderMatcherTypeBasic_Item).Item
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("item"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HeaderMatcherTypeBasic_CheckPresent:
		if fv, exists := v.FldValidators["match.check_present"]; exists {
			val := m.GetMatch().(*HeaderMatcherTypeBasic_CheckPresent).CheckPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HeaderMatcherTypeBasic_CheckNotPresent:
		if fv, exists := v.FldValidators["match.check_not_present"]; exists {
			val := m.GetMatch().(*HeaderMatcherTypeBasic_CheckNotPresent).CheckNotPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_not_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHeaderMatcherTypeBasicValidator = func() *ValidateHeaderMatcherTypeBasic {
	v := &ValidateHeaderMatcherTypeBasic{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMatch := v.MatchValidationRuleHandler
	rulesMatch := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMatch(rulesMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderMatcherTypeBasic.match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["match"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required":         "true",
		"ves.io.schema.rules.string.http_header_field": "true",
		"ves.io.schema.rules.string.max_bytes":         "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderMatcherTypeBasic.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	v.FldValidators["match.item"] = MatcherTypeValidator().Validate

	return v
}()

func HeaderMatcherTypeBasicValidator() db.Validator {
	return DefaultHeaderMatcherTypeBasicValidator
}

// augmented methods on protoc/std generated struct

func (m *HttpCookieName) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HttpCookieName) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HttpCookieName) DeepCopy() *HttpCookieName {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HttpCookieName{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HttpCookieName) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HttpCookieName) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HttpCookieNameValidator().Validate(ctx, m, opts...)
}

type ValidateHttpCookieName struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHttpCookieName) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateHttpCookieName) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HttpCookieName)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HttpCookieName got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHttpCookieNameValidator = func() *ValidateHttpCookieName {
	v := &ValidateHttpCookieName{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HttpCookieName.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func HttpCookieNameValidator() db.Validator {
	return DefaultHttpCookieNameValidator
}

// augmented methods on protoc/std generated struct

func (m *HttpHeaderName) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HttpHeaderName) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HttpHeaderName) DeepCopy() *HttpHeaderName {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HttpHeaderName{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HttpHeaderName) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HttpHeaderName) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HttpHeaderNameValidator().Validate(ctx, m, opts...)
}

type ValidateHttpHeaderName struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHttpHeaderName) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateHttpHeaderName) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HttpHeaderName)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HttpHeaderName got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHttpHeaderNameValidator = func() *ValidateHttpHeaderName {
	v := &ValidateHttpHeaderName{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required":         "true",
		"ves.io.schema.rules.string.http_header_field": "true",
		"ves.io.schema.rules.string.max_bytes":         "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HttpHeaderName.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func HttpHeaderNameValidator() db.Validator {
	return DefaultHttpHeaderNameValidator
}

// augmented methods on protoc/std generated struct

func (m *HttpMethodMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HttpMethodMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HttpMethodMatcherType) DeepCopy() *HttpMethodMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HttpMethodMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HttpMethodMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HttpMethodMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HttpMethodMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateHttpMethodMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHttpMethodMatcherType) MethodsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.HttpMethod)
		return int32(i)
	}
	// ves_io_schema.HttpMethod_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, ves_io_schema.HttpMethod_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for methods")
	}
	itemsValidatorFn := func(ctx context.Context, elems []ves_io_schema.HttpMethod, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for methods")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]ves_io_schema.HttpMethod)
		if !ok {
			return fmt.Errorf("Repeated validation expected []ves_io_schema.HttpMethod, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated methods")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items methods")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateHttpMethodMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HttpMethodMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HttpMethodMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["methods"]; exists {
		vOpts := append(opts, db.WithValidateField("methods"))
		if err := fv(ctx, m.GetMethods(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHttpMethodMatcherTypeValidator = func() *ValidateHttpMethodMatcherType {
	v := &ValidateHttpMethodMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMethods := v.MethodsValidationRuleHandler
	rulesMethods := map[string]string{
		"ves.io.schema.rules.repeated.items.enum.defined_only": "true",
		"ves.io.schema.rules.repeated.max_items":               "16",
		"ves.io.schema.rules.repeated.unique":                  "true",
	}
	vFn, err = vrhMethods(rulesMethods)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HttpMethodMatcherType.methods: %s", err)
		panic(errMsg)
	}
	v.FldValidators["methods"] = vFn

	return v
}()

func HttpMethodMatcherTypeValidator() db.Validator {
	return DefaultHttpMethodMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *HttpQueryParameterName) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HttpQueryParameterName) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HttpQueryParameterName) DeepCopy() *HttpQueryParameterName {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HttpQueryParameterName{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HttpQueryParameterName) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HttpQueryParameterName) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HttpQueryParameterNameValidator().Validate(ctx, m, opts...)
}

type ValidateHttpQueryParameterName struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHttpQueryParameterName) KeyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for key")
	}

	return validatorFn, nil
}

func (v *ValidateHttpQueryParameterName) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HttpQueryParameterName)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HttpQueryParameterName got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["key"]; exists {

		vOpts := append(opts, db.WithValidateField("key"))
		if err := fv(ctx, m.GetKey(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHttpQueryParameterNameValidator = func() *ValidateHttpQueryParameterName {
	v := &ValidateHttpQueryParameterName{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhKey := v.KeyValidationRuleHandler
	rulesKey := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "256",
	}
	vFn, err = vrhKey(rulesKey)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HttpQueryParameterName.key: %s", err)
		panic(errMsg)
	}
	v.FldValidators["key"] = vFn

	return v
}()

func HttpQueryParameterNameValidator() db.Validator {
	return DefaultHttpQueryParameterNameValidator
}

// augmented methods on protoc/std generated struct

func (m *IPThreatCategoryListType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IPThreatCategoryListType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IPThreatCategoryListType) DeepCopy() *IPThreatCategoryListType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IPThreatCategoryListType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IPThreatCategoryListType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IPThreatCategoryListType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IPThreatCategoryListTypeValidator().Validate(ctx, m, opts...)
}

type ValidateIPThreatCategoryListType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIPThreatCategoryListType) IpThreatCategoriesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(IPThreatCategory)
		return int32(i)
	}
	// IPThreatCategory_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, IPThreatCategory_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip_threat_categories")
	}
	itemsValidatorFn := func(ctx context.Context, elems []IPThreatCategory, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ip_threat_categories")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]IPThreatCategory)
		if !ok {
			return fmt.Errorf("Repeated validation expected []IPThreatCategory, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ip_threat_categories")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ip_threat_categories")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateIPThreatCategoryListType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IPThreatCategoryListType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IPThreatCategoryListType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ip_threat_categories"]; exists {
		vOpts := append(opts, db.WithValidateField("ip_threat_categories"))
		if err := fv(ctx, m.GetIpThreatCategories(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIPThreatCategoryListTypeValidator = func() *ValidateIPThreatCategoryListType {
	v := &ValidateIPThreatCategoryListType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhIpThreatCategories := v.IpThreatCategoriesValidationRuleHandler
	rulesIpThreatCategories := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhIpThreatCategories(rulesIpThreatCategories)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IPThreatCategoryListType.ip_threat_categories: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip_threat_categories"] = vFn

	return v
}()

func IPThreatCategoryListTypeValidator() db.Validator {
	return DefaultIPThreatCategoryListTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *IpMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IpMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IpMatcherType) DeepCopy() *IpMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IpMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IpMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IpMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IpMatcherTypeValidator().Validate(ctx, m, opts...)
}

func (m *IpMatcherType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetPrefixSetsDRefInfo()

}

func (m *IpMatcherType) GetPrefixSetsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetPrefixSets()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("IpMatcherType.prefix_sets[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "ip_prefix_set.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "prefix_sets",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetPrefixSetsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *IpMatcherType) GetPrefixSetsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "ip_prefix_set.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: ip_prefix_set")
	}
	for _, ref := range m.GetPrefixSets() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateIpMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIpMatcherType) PrefixSetsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for prefix_sets")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for prefix_sets")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated prefix_sets")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items prefix_sets")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateIpMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IpMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IpMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["prefix_sets"]; exists {
		vOpts := append(opts, db.WithValidateField("prefix_sets"))
		if err := fv(ctx, m.GetPrefixSets(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIpMatcherTypeValidator = func() *ValidateIpMatcherType {
	v := &ValidateIpMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPrefixSets := v.PrefixSetsValidationRuleHandler
	rulesPrefixSets := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhPrefixSets(rulesPrefixSets)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IpMatcherType.prefix_sets: %s", err)
		panic(errMsg)
	}
	v.FldValidators["prefix_sets"] = vFn

	return v
}()

func IpMatcherTypeValidator() db.Validator {
	return DefaultIpMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *JA4TlsFingerprintMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JA4TlsFingerprintMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *JA4TlsFingerprintMatcherType) DeepCopy() *JA4TlsFingerprintMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JA4TlsFingerprintMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JA4TlsFingerprintMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JA4TlsFingerprintMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JA4TlsFingerprintMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateJA4TlsFingerprintMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJA4TlsFingerprintMatcherType) ExactValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for exact_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exact_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exact_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exact_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateJA4TlsFingerprintMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JA4TlsFingerprintMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JA4TlsFingerprintMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["exact_values"]; exists {
		vOpts := append(opts, db.WithValidateField("exact_values"))
		if err := fv(ctx, m.GetExactValues(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJA4TlsFingerprintMatcherTypeValidator = func() *ValidateJA4TlsFingerprintMatcherType {
	v := &ValidateJA4TlsFingerprintMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhExactValues := v.ExactValuesValidationRuleHandler
	rulesExactValues := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhExactValues(rulesExactValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JA4TlsFingerprintMatcherType.exact_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exact_values"] = vFn

	return v
}()

func JA4TlsFingerprintMatcherTypeValidator() db.Validator {
	return DefaultJA4TlsFingerprintMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *JWTClaimMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JWTClaimMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *JWTClaimMatcherType) DeepCopy() *JWTClaimMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JWTClaimMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JWTClaimMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JWTClaimMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JWTClaimMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateJWTClaimMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJWTClaimMatcherType) MatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for match")
	}
	return validatorFn, nil
}

func (v *ValidateJWTClaimMatcherType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateJWTClaimMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JWTClaimMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JWTClaimMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["match"]; exists {
		val := m.GetMatch()
		vOpts := append(opts,
			db.WithValidateField("match"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMatch().(type) {
	case *JWTClaimMatcherType_CheckPresent:
		if fv, exists := v.FldValidators["match.check_present"]; exists {
			val := m.GetMatch().(*JWTClaimMatcherType_CheckPresent).CheckPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *JWTClaimMatcherType_CheckNotPresent:
		if fv, exists := v.FldValidators["match.check_not_present"]; exists {
			val := m.GetMatch().(*JWTClaimMatcherType_CheckNotPresent).CheckNotPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_not_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *JWTClaimMatcherType_Item:
		if fv, exists := v.FldValidators["match.item"]; exists {
			val := m.GetMatch().(*JWTClaimMatcherType_Item).Item
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("item"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJWTClaimMatcherTypeValidator = func() *ValidateJWTClaimMatcherType {
	v := &ValidateJWTClaimMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMatch := v.MatchValidationRuleHandler
	rulesMatch := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMatch(rulesMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JWTClaimMatcherType.match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["match"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JWTClaimMatcherType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	v.FldValidators["match.item"] = MatcherTypeValidator().Validate

	return v
}()

func JWTClaimMatcherTypeValidator() db.Validator {
	return DefaultJWTClaimMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *JwtTokenAuthOptions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JwtTokenAuthOptions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *JwtTokenAuthOptions) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetSecretKey().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting JwtTokenAuthOptions.secret_key")
	}

	if err := m.GetBackupKey().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting JwtTokenAuthOptions.backup_key")
	}

	return nil
}

func (m *JwtTokenAuthOptions) DeepCopy() *JwtTokenAuthOptions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JwtTokenAuthOptions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JwtTokenAuthOptions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JwtTokenAuthOptions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JwtTokenAuthOptionsValidator().Validate(ctx, m, opts...)
}

type ValidateJwtTokenAuthOptions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJwtTokenAuthOptions) SecretKeyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for secret_key")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.SecretTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateJwtTokenAuthOptions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JwtTokenAuthOptions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JwtTokenAuthOptions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["backup_key"]; exists {

		vOpts := append(opts, db.WithValidateField("backup_key"))
		if err := fv(ctx, m.GetBackupKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["secret_key"]; exists {

		vOpts := append(opts, db.WithValidateField("secret_key"))
		if err := fv(ctx, m.GetSecretKey(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetTokenSource().(type) {
	case *JwtTokenAuthOptions_Header:
		if fv, exists := v.FldValidators["token_source.header"]; exists {
			val := m.GetTokenSource().(*JwtTokenAuthOptions_Header).Header
			vOpts := append(opts,
				db.WithValidateField("token_source"),
				db.WithValidateField("header"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *JwtTokenAuthOptions_Cookie:
		if fv, exists := v.FldValidators["token_source.cookie"]; exists {
			val := m.GetTokenSource().(*JwtTokenAuthOptions_Cookie).Cookie
			vOpts := append(opts,
				db.WithValidateField("token_source"),
				db.WithValidateField("cookie"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *JwtTokenAuthOptions_QueryParam:
		if fv, exists := v.FldValidators["token_source.query_param"]; exists {
			val := m.GetTokenSource().(*JwtTokenAuthOptions_QueryParam).QueryParam
			vOpts := append(opts,
				db.WithValidateField("token_source"),
				db.WithValidateField("query_param"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *JwtTokenAuthOptions_BearerToken:
		if fv, exists := v.FldValidators["token_source.bearer_token"]; exists {
			val := m.GetTokenSource().(*JwtTokenAuthOptions_BearerToken).BearerToken
			vOpts := append(opts,
				db.WithValidateField("token_source"),
				db.WithValidateField("bearer_token"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJwtTokenAuthOptionsValidator = func() *ValidateJwtTokenAuthOptions {
	v := &ValidateJwtTokenAuthOptions{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSecretKey := v.SecretKeyValidationRuleHandler
	rulesSecretKey := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSecretKey(rulesSecretKey)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JwtTokenAuthOptions.secret_key: %s", err)
		panic(errMsg)
	}
	v.FldValidators["secret_key"] = vFn

	v.FldValidators["token_source.header"] = HttpHeaderNameValidator().Validate
	v.FldValidators["token_source.cookie"] = HttpCookieNameValidator().Validate
	v.FldValidators["token_source.query_param"] = HttpQueryParameterNameValidator().Validate

	v.FldValidators["backup_key"] = ves_io_schema.SecretTypeValidator().Validate

	return v
}()

func JwtTokenAuthOptionsValidator() db.Validator {
	return DefaultJwtTokenAuthOptionsValidator
}

// augmented methods on protoc/std generated struct

func (m *L4DestMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *L4DestMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *L4DestMatcherType) DeepCopy() *L4DestMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &L4DestMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *L4DestMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *L4DestMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return L4DestMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateL4DestMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateL4DestMatcherType) L4DestsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for l4_dests")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.L4DestType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.L4DestTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for l4_dests")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.L4DestType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.L4DestType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated l4_dests")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items l4_dests")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateL4DestMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*L4DestMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *L4DestMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["l4_dests"]; exists {
		vOpts := append(opts, db.WithValidateField("l4_dests"))
		if err := fv(ctx, m.GetL4Dests(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultL4DestMatcherTypeValidator = func() *ValidateL4DestMatcherType {
	v := &ValidateL4DestMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhL4Dests := v.L4DestsValidationRuleHandler
	rulesL4Dests := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhL4Dests(rulesL4Dests)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for L4DestMatcherType.l4_dests: %s", err)
		panic(errMsg)
	}
	v.FldValidators["l4_dests"] = vFn

	return v
}()

func L4DestMatcherTypeValidator() db.Validator {
	return DefaultL4DestMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *MaskingConfig) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MaskingConfig) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MaskingConfig) DeepCopy() *MaskingConfig {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MaskingConfig{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MaskingConfig) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MaskingConfig) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MaskingConfigValidator().Validate(ctx, m, opts...)
}

type ValidateMaskingConfig struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMaskingConfig) ActionChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for action_choice")
	}
	return validatorFn, nil
}

func (v *ValidateMaskingConfig) FieldsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for fields")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for fields")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated fields")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items fields")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateMaskingConfig) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MaskingConfig)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MaskingConfig got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["action_choice"]; exists {
		val := m.GetActionChoice()
		vOpts := append(opts,
			db.WithValidateField("action_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetActionChoice().(type) {
	case *MaskingConfig_Mask:
		if fv, exists := v.FldValidators["action_choice.mask"]; exists {
			val := m.GetActionChoice().(*MaskingConfig_Mask).Mask
			vOpts := append(opts,
				db.WithValidateField("action_choice"),
				db.WithValidateField("mask"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *MaskingConfig_Report:
		if fv, exists := v.FldValidators["action_choice.report"]; exists {
			val := m.GetActionChoice().(*MaskingConfig_Report).Report
			vOpts := append(opts,
				db.WithValidateField("action_choice"),
				db.WithValidateField("report"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["fields"]; exists {
		vOpts := append(opts, db.WithValidateField("fields"))
		if err := fv(ctx, m.GetFields(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMaskingConfigValidator = func() *ValidateMaskingConfig {
	v := &ValidateMaskingConfig{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhActionChoice := v.ActionChoiceValidationRuleHandler
	rulesActionChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhActionChoice(rulesActionChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MaskingConfig.action_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["action_choice"] = vFn

	vrhFields := v.FieldsValidationRuleHandler
	rulesFields := map[string]string{
		"ves.io.schema.rules.repeated.items.string.json_path": "true",
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.items.string.not_empty": "true",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
		"ves.io.schema.rules.string.json_path":                "true",
	}
	vFn, err = vrhFields(rulesFields)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MaskingConfig.fields: %s", err)
		panic(errMsg)
	}
	v.FldValidators["fields"] = vFn

	return v
}()

func MaskingConfigValidator() db.Validator {
	return DefaultMaskingConfigValidator
}

// augmented methods on protoc/std generated struct

func (m *MatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MatcherType) DeepCopy() *MatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMatcherType) ExactValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for exact_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exact_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exact_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exact_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateMatcherType) RegexValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for regex_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for regex_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated regex_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items regex_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateMatcherType) TransformersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(Transformer)
		return int32(i)
	}
	// Transformer_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, Transformer_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for transformers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []Transformer, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for transformers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]Transformer)
		if !ok {
			return fmt.Errorf("Repeated validation expected []Transformer, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated transformers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items transformers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["exact_values"]; exists {
		vOpts := append(opts, db.WithValidateField("exact_values"))
		if err := fv(ctx, m.GetExactValues(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["regex_values"]; exists {
		vOpts := append(opts, db.WithValidateField("regex_values"))
		if err := fv(ctx, m.GetRegexValues(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["transformers"]; exists {
		vOpts := append(opts, db.WithValidateField("transformers"))
		if err := fv(ctx, m.GetTransformers(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMatcherTypeValidator = func() *ValidateMatcherType {
	v := &ValidateMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhExactValues := v.ExactValuesValidationRuleHandler
	rulesExactValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.not_empty": "true",
		"ves.io.schema.rules.repeated.max_items":              "64",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhExactValues(rulesExactValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MatcherType.exact_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exact_values"] = vFn

	vrhRegexValues := v.RegexValuesValidationRuleHandler
	rulesRegexValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.not_empty": "true",
		"ves.io.schema.rules.repeated.items.string.regex":     "true",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhRegexValues(rulesRegexValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MatcherType.regex_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["regex_values"] = vFn

	vrhTransformers := v.TransformersValidationRuleHandler
	rulesTransformers := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "9",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhTransformers(rulesTransformers)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MatcherType.transformers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["transformers"] = vFn

	return v
}()

func MatcherTypeValidator() db.Validator {
	return DefaultMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *MatcherTypeBasic) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MatcherTypeBasic) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MatcherTypeBasic) DeepCopy() *MatcherTypeBasic {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MatcherTypeBasic{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MatcherTypeBasic) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MatcherTypeBasic) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MatcherTypeBasicValidator().Validate(ctx, m, opts...)
}

type ValidateMatcherTypeBasic struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMatcherTypeBasic) ExactValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for exact_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exact_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exact_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exact_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateMatcherTypeBasic) RegexValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for regex_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for regex_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated regex_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items regex_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateMatcherTypeBasic) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MatcherTypeBasic)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MatcherTypeBasic got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["exact_values"]; exists {
		vOpts := append(opts, db.WithValidateField("exact_values"))
		if err := fv(ctx, m.GetExactValues(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["regex_values"]; exists {
		vOpts := append(opts, db.WithValidateField("regex_values"))
		if err := fv(ctx, m.GetRegexValues(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMatcherTypeBasicValidator = func() *ValidateMatcherTypeBasic {
	v := &ValidateMatcherTypeBasic{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhExactValues := v.ExactValuesValidationRuleHandler
	rulesExactValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.not_empty": "true",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhExactValues(rulesExactValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MatcherTypeBasic.exact_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exact_values"] = vFn

	vrhRegexValues := v.RegexValuesValidationRuleHandler
	rulesRegexValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.not_empty": "true",
		"ves.io.schema.rules.repeated.items.string.regex":     "true",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhRegexValues(rulesRegexValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MatcherTypeBasic.regex_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["regex_values"] = vFn

	return v
}()

func MatcherTypeBasicValidator() db.Validator {
	return DefaultMatcherTypeBasicValidator
}

// augmented methods on protoc/std generated struct

func (m *ModifyAction) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ModifyAction) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ModifyAction) DeepCopy() *ModifyAction {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ModifyAction{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ModifyAction) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ModifyAction) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ModifyActionValidator().Validate(ctx, m, opts...)
}

type ValidateModifyAction struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateModifyAction) ActionTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for action_type")
	}
	return validatorFn, nil
}

func (v *ValidateModifyAction) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ModifyAction)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ModifyAction got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["action_type"]; exists {
		val := m.GetActionType()
		vOpts := append(opts,
			db.WithValidateField("action_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetActionType().(type) {
	case *ModifyAction_Default:
		if fv, exists := v.FldValidators["action_type.default"]; exists {
			val := m.GetActionType().(*ModifyAction_Default).Default
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("default"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ModifyAction_SkipProcessing:
		if fv, exists := v.FldValidators["action_type.skip_processing"]; exists {
			val := m.GetActionType().(*ModifyAction_SkipProcessing).SkipProcessing
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("skip_processing"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultModifyActionValidator = func() *ValidateModifyAction {
	v := &ValidateModifyAction{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhActionType := v.ActionTypeValidationRuleHandler
	rulesActionType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhActionType(rulesActionType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ModifyAction.action_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["action_type"] = vFn

	return v
}()

func ModifyActionValidator() db.Validator {
	return DefaultModifyActionValidator
}

// augmented methods on protoc/std generated struct

func (m *OpenApiValidationAction) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OpenApiValidationAction) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OpenApiValidationAction) DeepCopy() *OpenApiValidationAction {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OpenApiValidationAction{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OpenApiValidationAction) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OpenApiValidationAction) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OpenApiValidationActionValidator().Validate(ctx, m, opts...)
}

type ValidateOpenApiValidationAction struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOpenApiValidationAction) RequestPropertiesSelectionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.OpenApiValidationProperties)
		return int32(i)
	}
	// ves_io_schema.OpenApiValidationProperties_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, ves_io_schema.OpenApiValidationProperties_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for request_properties_selection")
	}
	itemsValidatorFn := func(ctx context.Context, elems []ves_io_schema.OpenApiValidationProperties, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_properties_selection")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]ves_io_schema.OpenApiValidationProperties)
		if !ok {
			return fmt.Errorf("Repeated validation expected []ves_io_schema.OpenApiValidationProperties, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_properties_selection")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_properties_selection")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOpenApiValidationAction) OasValidationActionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(OasValidationActionType)
		return int32(i)
	}
	// OasValidationActionType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, OasValidationActionType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for oas_validation_action")
	}

	return validatorFn, nil
}

func (v *ValidateOpenApiValidationAction) ResponsePropertiesSelectionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.OpenApiValidationProperties)
		return int32(i)
	}
	// ves_io_schema.OpenApiValidationProperties_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, ves_io_schema.OpenApiValidationProperties_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for response_properties_selection")
	}
	itemsValidatorFn := func(ctx context.Context, elems []ves_io_schema.OpenApiValidationProperties, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_properties_selection")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]ves_io_schema.OpenApiValidationProperties)
		if !ok {
			return fmt.Errorf("Repeated validation expected []ves_io_schema.OpenApiValidationProperties, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_properties_selection")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_properties_selection")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOpenApiValidationAction) OasResponseValidationActionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(OasValidationActionType)
		return int32(i)
	}
	// OasValidationActionType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, OasValidationActionType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for oas_response_validation_action")
	}

	return validatorFn, nil
}

func (v *ValidateOpenApiValidationAction) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OpenApiValidationAction)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OpenApiValidationAction got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["oas_response_validation_action"]; exists {

		vOpts := append(opts, db.WithValidateField("oas_response_validation_action"))
		if err := fv(ctx, m.GetOasResponseValidationAction(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["oas_validation_action"]; exists {

		vOpts := append(opts, db.WithValidateField("oas_validation_action"))
		if err := fv(ctx, m.GetOasValidationAction(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_properties_selection"]; exists {
		vOpts := append(opts, db.WithValidateField("request_properties_selection"))
		if err := fv(ctx, m.GetRequestPropertiesSelection(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_properties_selection"]; exists {
		vOpts := append(opts, db.WithValidateField("response_properties_selection"))
		if err := fv(ctx, m.GetResponsePropertiesSelection(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOpenApiValidationActionValidator = func() *ValidateOpenApiValidationAction {
	v := &ValidateOpenApiValidationAction{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRequestPropertiesSelection := v.RequestPropertiesSelectionValidationRuleHandler
	rulesRequestPropertiesSelection := map[string]string{
		"ves.io.schema.rules.repeated.items.enum.defined_only": "true",
		"ves.io.schema.rules.repeated.items.enum.not_in":       "[7]",
		"ves.io.schema.rules.repeated.unique":                  "true",
	}
	vFn, err = vrhRequestPropertiesSelection(rulesRequestPropertiesSelection)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OpenApiValidationAction.request_properties_selection: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_properties_selection"] = vFn

	vrhOasValidationAction := v.OasValidationActionValidationRuleHandler
	rulesOasValidationAction := map[string]string{
		"ves.io.schema.rules.enum.defined_only": "true",
		"ves.io.schema.rules.message.required":  "true",
	}
	vFn, err = vrhOasValidationAction(rulesOasValidationAction)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OpenApiValidationAction.oas_validation_action: %s", err)
		panic(errMsg)
	}
	v.FldValidators["oas_validation_action"] = vFn

	vrhResponsePropertiesSelection := v.ResponsePropertiesSelectionValidationRuleHandler
	rulesResponsePropertiesSelection := map[string]string{
		"ves.io.schema.rules.repeated.items.enum.defined_only": "true",
		"ves.io.schema.rules.repeated.items.enum.in":           "[2,4,5,7]",
		"ves.io.schema.rules.repeated.unique":                  "true",
	}
	vFn, err = vrhResponsePropertiesSelection(rulesResponsePropertiesSelection)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OpenApiValidationAction.response_properties_selection: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_properties_selection"] = vFn

	vrhOasResponseValidationAction := v.OasResponseValidationActionValidationRuleHandler
	rulesOasResponseValidationAction := map[string]string{
		"ves.io.schema.rules.enum.defined_only": "true",
		"ves.io.schema.rules.enum.in":           "[0,1,2]",
		"ves.io.schema.rules.message.required":  "true",
	}
	vFn, err = vrhOasResponseValidationAction(rulesOasResponseValidationAction)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OpenApiValidationAction.oas_response_validation_action: %s", err)
		panic(errMsg)
	}
	v.FldValidators["oas_response_validation_action"] = vFn

	return v
}()

func OpenApiValidationActionValidator() db.Validator {
	return DefaultOpenApiValidationActionValidator
}

// augmented methods on protoc/std generated struct

func (m *OriginServerSubsetRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OriginServerSubsetRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OriginServerSubsetRule) DeepCopy() *OriginServerSubsetRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OriginServerSubsetRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OriginServerSubsetRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OriginServerSubsetRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OriginServerSubsetRuleValidator().Validate(ctx, m, opts...)
}

func (m *OriginServerSubsetRule) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAsnChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAsnChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetIpChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetIpChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *OriginServerSubsetRule) GetAsnChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAsnChoice() == nil {
		return nil, nil
	}
	switch m.GetAsnChoice().(type) {
	case *OriginServerSubsetRule_AsnMatcher:

		drInfos, err := m.GetAsnMatcher().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAsnMatcher().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "asn_matcher." + dri.DRField
		}
		return drInfos, err

	case *OriginServerSubsetRule_AnyAsn:

		return nil, nil

	case *OriginServerSubsetRule_AsnList:

		return nil, nil

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *OriginServerSubsetRule) GetIpChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetIpChoice() == nil {
		return nil, nil
	}
	switch m.GetIpChoice().(type) {
	case *OriginServerSubsetRule_IpMatcher:

		drInfos, err := m.GetIpMatcher().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetIpMatcher().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "ip_matcher." + dri.DRField
		}
		return drInfos, err

	case *OriginServerSubsetRule_AnyIp:

		return nil, nil

	case *OriginServerSubsetRule_IpPrefixList:

		return nil, nil

	default:
		return nil, nil
	}

}

type ValidateOriginServerSubsetRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOriginServerSubsetRule) AsnChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for asn_choice")
	}
	return validatorFn, nil
}

func (v *ValidateOriginServerSubsetRule) IpChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip_choice")
	}
	return validatorFn, nil
}

func (v *ValidateOriginServerSubsetRule) SelectorChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for selector_choice")
	}
	return validatorFn, nil
}

func (v *ValidateOriginServerSubsetRule) MetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for metadata")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.MessageMetaTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOriginServerSubsetRule) ReNameListValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for re_name_list")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for re_name_list")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated re_name_list")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items re_name_list")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOriginServerSubsetRule) CountryCodesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(CountryCode)
		return int32(i)
	}
	// CountryCode_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, CountryCode_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for country_codes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []CountryCode, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for country_codes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]CountryCode)
		if !ok {
			return fmt.Errorf("Repeated validation expected []CountryCode, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated country_codes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items country_codes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOriginServerSubsetRule) OriginServerSubsetsActionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for origin_server_subsets_action")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for origin_server_subsets_action")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for origin_server_subsets_action")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map origin_server_subsets_action")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items origin_server_subsets_action")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOriginServerSubsetRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OriginServerSubsetRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OriginServerSubsetRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["asn_choice"]; exists {
		val := m.GetAsnChoice()
		vOpts := append(opts,
			db.WithValidateField("asn_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAsnChoice().(type) {
	case *OriginServerSubsetRule_AsnMatcher:
		if fv, exists := v.FldValidators["asn_choice.asn_matcher"]; exists {
			val := m.GetAsnChoice().(*OriginServerSubsetRule_AsnMatcher).AsnMatcher
			vOpts := append(opts,
				db.WithValidateField("asn_choice"),
				db.WithValidateField("asn_matcher"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginServerSubsetRule_AnyAsn:
		if fv, exists := v.FldValidators["asn_choice.any_asn"]; exists {
			val := m.GetAsnChoice().(*OriginServerSubsetRule_AnyAsn).AnyAsn
			vOpts := append(opts,
				db.WithValidateField("asn_choice"),
				db.WithValidateField("any_asn"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginServerSubsetRule_AsnList:
		if fv, exists := v.FldValidators["asn_choice.asn_list"]; exists {
			val := m.GetAsnChoice().(*OriginServerSubsetRule_AsnList).AsnList
			vOpts := append(opts,
				db.WithValidateField("asn_choice"),
				db.WithValidateField("asn_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["body_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("body_matcher"))
		if err := fv(ctx, m.GetBodyMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["country_codes"]; exists {
		vOpts := append(opts, db.WithValidateField("country_codes"))
		if err := fv(ctx, m.GetCountryCodes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip_choice"]; exists {
		val := m.GetIpChoice()
		vOpts := append(opts,
			db.WithValidateField("ip_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetIpChoice().(type) {
	case *OriginServerSubsetRule_IpMatcher:
		if fv, exists := v.FldValidators["ip_choice.ip_matcher"]; exists {
			val := m.GetIpChoice().(*OriginServerSubsetRule_IpMatcher).IpMatcher
			vOpts := append(opts,
				db.WithValidateField("ip_choice"),
				db.WithValidateField("ip_matcher"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginServerSubsetRule_AnyIp:
		if fv, exists := v.FldValidators["ip_choice.any_ip"]; exists {
			val := m.GetIpChoice().(*OriginServerSubsetRule_AnyIp).AnyIp
			vOpts := append(opts,
				db.WithValidateField("ip_choice"),
				db.WithValidateField("any_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginServerSubsetRule_IpPrefixList:
		if fv, exists := v.FldValidators["ip_choice.ip_prefix_list"]; exists {
			val := m.GetIpChoice().(*OriginServerSubsetRule_IpPrefixList).IpPrefixList
			vOpts := append(opts,
				db.WithValidateField("ip_choice"),
				db.WithValidateField("ip_prefix_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["origin_server_subsets_action"]; exists {
		vOpts := append(opts, db.WithValidateField("origin_server_subsets_action"))
		if err := fv(ctx, m.GetOriginServerSubsetsAction(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["re_name_list"]; exists {
		vOpts := append(opts, db.WithValidateField("re_name_list"))
		if err := fv(ctx, m.GetReNameList(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["selector_choice"]; exists {
		val := m.GetSelectorChoice()
		vOpts := append(opts,
			db.WithValidateField("selector_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSelectorChoice().(type) {
	case *OriginServerSubsetRule_ClientSelector:
		if fv, exists := v.FldValidators["selector_choice.client_selector"]; exists {
			val := m.GetSelectorChoice().(*OriginServerSubsetRule_ClientSelector).ClientSelector
			vOpts := append(opts,
				db.WithValidateField("selector_choice"),
				db.WithValidateField("client_selector"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginServerSubsetRule_None:
		if fv, exists := v.FldValidators["selector_choice.none"]; exists {
			val := m.GetSelectorChoice().(*OriginServerSubsetRule_None).None
			vOpts := append(opts,
				db.WithValidateField("selector_choice"),
				db.WithValidateField("none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOriginServerSubsetRuleValidator = func() *ValidateOriginServerSubsetRule {
	v := &ValidateOriginServerSubsetRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAsnChoice := v.AsnChoiceValidationRuleHandler
	rulesAsnChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAsnChoice(rulesAsnChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerSubsetRule.asn_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["asn_choice"] = vFn

	vrhIpChoice := v.IpChoiceValidationRuleHandler
	rulesIpChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhIpChoice(rulesIpChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerSubsetRule.ip_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip_choice"] = vFn

	vrhSelectorChoice := v.SelectorChoiceValidationRuleHandler
	rulesSelectorChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSelectorChoice(rulesSelectorChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerSubsetRule.selector_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["selector_choice"] = vFn

	vrhMetadata := v.MetadataValidationRuleHandler
	rulesMetadata := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMetadata(rulesMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerSubsetRule.metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metadata"] = vFn

	vrhReNameList := v.ReNameListValidationRuleHandler
	rulesReNameList := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
		"ves.io.schema.rules.string.max_len":     "64",
	}
	vFn, err = vrhReNameList(rulesReNameList)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerSubsetRule.re_name_list: %s", err)
		panic(errMsg)
	}
	v.FldValidators["re_name_list"] = vFn

	vrhCountryCodes := v.CountryCodesValidationRuleHandler
	rulesCountryCodes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhCountryCodes(rulesCountryCodes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerSubsetRule.country_codes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["country_codes"] = vFn

	vrhOriginServerSubsetsAction := v.OriginServerSubsetsActionValidationRuleHandler
	rulesOriginServerSubsetsAction := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len":   "128",
		"ves.io.schema.rules.map.keys.string.min_len":   "1",
		"ves.io.schema.rules.map.max_pairs":             "16",
		"ves.io.schema.rules.map.values.string.max_len": "128",
		"ves.io.schema.rules.map.values.string.min_len": "1",
		"ves.io.schema.rules.message.required":          "true",
	}
	vFn, err = vrhOriginServerSubsetsAction(rulesOriginServerSubsetsAction)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerSubsetRule.origin_server_subsets_action: %s", err)
		panic(errMsg)
	}
	v.FldValidators["origin_server_subsets_action"] = vFn

	v.FldValidators["asn_choice.asn_matcher"] = AsnMatcherTypeValidator().Validate
	v.FldValidators["asn_choice.asn_list"] = AsnMatchListValidator().Validate

	v.FldValidators["ip_choice.ip_matcher"] = IpMatcherTypeValidator().Validate
	v.FldValidators["ip_choice.ip_prefix_list"] = PrefixMatchListValidator().Validate

	v.FldValidators["selector_choice.client_selector"] = ves_io_schema.LabelSelectorTypeValidator().Validate

	v.FldValidators["body_matcher"] = MatcherTypeValidator().Validate

	return v
}()

func OriginServerSubsetRuleValidator() db.Validator {
	return DefaultOriginServerSubsetRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *PathMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PathMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PathMatcherType) DeepCopy() *PathMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PathMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PathMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PathMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PathMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePathMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePathMatcherType) PrefixValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for prefix_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for prefix_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated prefix_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items prefix_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePathMatcherType) ExactValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for exact_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exact_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exact_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exact_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePathMatcherType) RegexValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for regex_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for regex_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated regex_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items regex_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePathMatcherType) TransformersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(Transformer)
		return int32(i)
	}
	// Transformer_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, Transformer_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for transformers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []Transformer, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for transformers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]Transformer)
		if !ok {
			return fmt.Errorf("Repeated validation expected []Transformer, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated transformers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items transformers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePathMatcherType) SuffixValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for suffix_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for suffix_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated suffix_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items suffix_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePathMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PathMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PathMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["exact_values"]; exists {
		vOpts := append(opts, db.WithValidateField("exact_values"))
		if err := fv(ctx, m.GetExactValues(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["prefix_values"]; exists {
		vOpts := append(opts, db.WithValidateField("prefix_values"))
		if err := fv(ctx, m.GetPrefixValues(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["regex_values"]; exists {
		vOpts := append(opts, db.WithValidateField("regex_values"))
		if err := fv(ctx, m.GetRegexValues(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["suffix_values"]; exists {
		vOpts := append(opts, db.WithValidateField("suffix_values"))
		if err := fv(ctx, m.GetSuffixValues(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["transformers"]; exists {
		vOpts := append(opts, db.WithValidateField("transformers"))
		if err := fv(ctx, m.GetTransformers(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPathMatcherTypeValidator = func() *ValidatePathMatcherType {
	v := &ValidatePathMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPrefixValues := v.PrefixValuesValidationRuleHandler
	rulesPrefixValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.http_path": "true",
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.not_empty": "true",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhPrefixValues(rulesPrefixValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PathMatcherType.prefix_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["prefix_values"] = vFn

	vrhExactValues := v.ExactValuesValidationRuleHandler
	rulesExactValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.http_path": "true",
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.not_empty": "true",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhExactValues(rulesExactValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PathMatcherType.exact_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exact_values"] = vFn

	vrhRegexValues := v.RegexValuesValidationRuleHandler
	rulesRegexValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.not_empty": "true",
		"ves.io.schema.rules.repeated.items.string.regex":     "true",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhRegexValues(rulesRegexValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PathMatcherType.regex_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["regex_values"] = vFn

	vrhTransformers := v.TransformersValidationRuleHandler
	rulesTransformers := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "9",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhTransformers(rulesTransformers)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PathMatcherType.transformers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["transformers"] = vFn

	vrhSuffixValues := v.SuffixValuesValidationRuleHandler
	rulesSuffixValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "64",
		"ves.io.schema.rules.repeated.items.string.not_empty": "true",
		"ves.io.schema.rules.repeated.max_items":              "64",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhSuffixValues(rulesSuffixValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PathMatcherType.suffix_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["suffix_values"] = vFn

	return v
}()

func PathMatcherTypeValidator() db.Validator {
	return DefaultPathMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PortMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PortMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PortMatcherType) DeepCopy() *PortMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PortMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PortMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PortMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PortMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePortMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePortMatcherType) PortsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for ports")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ports")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ports")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ports")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePortMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PortMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PortMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ports"]; exists {
		vOpts := append(opts, db.WithValidateField("ports"))
		if err := fv(ctx, m.GetPorts(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPortMatcherTypeValidator = func() *ValidatePortMatcherType {
	v := &ValidatePortMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPorts := v.PortsValidationRuleHandler
	rulesPorts := map[string]string{
		"ves.io.schema.rules.message.required":                 "true",
		"ves.io.schema.rules.repeated.items.string.port_range": "true",
		"ves.io.schema.rules.repeated.max_items":               "16",
		"ves.io.schema.rules.repeated.unique":                  "true",
	}
	vFn, err = vrhPorts(rulesPorts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PortMatcherType.ports: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ports"] = vFn

	return v
}()

func PortMatcherTypeValidator() db.Validator {
	return DefaultPortMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PrefixMatchList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PrefixMatchList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PrefixMatchList) DeepCopy() *PrefixMatchList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PrefixMatchList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PrefixMatchList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PrefixMatchList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PrefixMatchListValidator().Validate(ctx, m, opts...)
}

type ValidatePrefixMatchList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePrefixMatchList) IpPrefixesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for ip_prefixes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ip_prefixes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ip_prefixes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ip_prefixes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePrefixMatchList) Ipv6PrefixesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for ipv6_prefixes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ipv6_prefixes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ipv6_prefixes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ipv6_prefixes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePrefixMatchList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PrefixMatchList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PrefixMatchList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_match"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_match"))
		if err := fv(ctx, m.GetInvertMatch(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip_prefixes"]; exists {
		vOpts := append(opts, db.WithValidateField("ip_prefixes"))
		if err := fv(ctx, m.GetIpPrefixes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ipv6_prefixes"]; exists {
		vOpts := append(opts, db.WithValidateField("ipv6_prefixes"))
		if err := fv(ctx, m.GetIpv6Prefixes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPrefixMatchListValidator = func() *ValidatePrefixMatchList {
	v := &ValidatePrefixMatchList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhIpPrefixes := v.IpPrefixesValidationRuleHandler
	rulesIpPrefixes := map[string]string{
		"ves.io.schema.rules.repeated.items.string.ipv4_prefix": "true",
		"ves.io.schema.rules.repeated.items.string.not_empty":   "true",
		"ves.io.schema.rules.repeated.max_items":                "128",
		"ves.io.schema.rules.repeated.unique":                   "true",
	}
	vFn, err = vrhIpPrefixes(rulesIpPrefixes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PrefixMatchList.ip_prefixes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip_prefixes"] = vFn

	vrhIpv6Prefixes := v.Ipv6PrefixesValidationRuleHandler
	rulesIpv6Prefixes := map[string]string{
		"ves.io.schema.rules.repeated.items.string.ipv6_prefix": "true",
		"ves.io.schema.rules.repeated.items.string.not_empty":   "true",
		"ves.io.schema.rules.repeated.max_items":                "128",
		"ves.io.schema.rules.repeated.unique":                   "true",
	}
	vFn, err = vrhIpv6Prefixes(rulesIpv6Prefixes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PrefixMatchList.ipv6_prefixes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ipv6_prefixes"] = vFn

	return v
}()

func PrefixMatchListValidator() db.Validator {
	return DefaultPrefixMatchListValidator
}

// augmented methods on protoc/std generated struct

func (m *QueryParameterMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *QueryParameterMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *QueryParameterMatcherType) DeepCopy() *QueryParameterMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &QueryParameterMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *QueryParameterMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *QueryParameterMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return QueryParameterMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateQueryParameterMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateQueryParameterMatcherType) MatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for match")
	}
	return validatorFn, nil
}

func (v *ValidateQueryParameterMatcherType) KeyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for key")
	}

	return validatorFn, nil
}

func (v *ValidateQueryParameterMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*QueryParameterMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *QueryParameterMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["key"]; exists {

		vOpts := append(opts, db.WithValidateField("key"))
		if err := fv(ctx, m.GetKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["match"]; exists {
		val := m.GetMatch()
		vOpts := append(opts,
			db.WithValidateField("match"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMatch().(type) {
	case *QueryParameterMatcherType_Presence:
		if fv, exists := v.FldValidators["match.presence"]; exists {
			val := m.GetMatch().(*QueryParameterMatcherType_Presence).Presence
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("presence"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *QueryParameterMatcherType_Item:
		if fv, exists := v.FldValidators["match.item"]; exists {
			val := m.GetMatch().(*QueryParameterMatcherType_Item).Item
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("item"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *QueryParameterMatcherType_CheckPresent:
		if fv, exists := v.FldValidators["match.check_present"]; exists {
			val := m.GetMatch().(*QueryParameterMatcherType_CheckPresent).CheckPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *QueryParameterMatcherType_CheckNotPresent:
		if fv, exists := v.FldValidators["match.check_not_present"]; exists {
			val := m.GetMatch().(*QueryParameterMatcherType_CheckNotPresent).CheckNotPresent
			vOpts := append(opts,
				db.WithValidateField("match"),
				db.WithValidateField("check_not_present"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultQueryParameterMatcherTypeValidator = func() *ValidateQueryParameterMatcherType {
	v := &ValidateQueryParameterMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMatch := v.MatchValidationRuleHandler
	rulesMatch := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMatch(rulesMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for QueryParameterMatcherType.match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["match"] = vFn

	vrhKey := v.KeyValidationRuleHandler
	rulesKey := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "256",
	}
	vFn, err = vrhKey(rulesKey)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for QueryParameterMatcherType.key: %s", err)
		panic(errMsg)
	}
	v.FldValidators["key"] = vFn

	v.FldValidators["match.item"] = MatcherTypeValidator().Validate

	return v
}()

func QueryParameterMatcherTypeValidator() db.Validator {
	return DefaultQueryParameterMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *RequestConstraintType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RequestConstraintType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RequestConstraintType) DeepCopy() *RequestConstraintType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RequestConstraintType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RequestConstraintType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RequestConstraintType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RequestConstraintTypeValidator().Validate(ctx, m, opts...)
}

type ValidateRequestConstraintType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRequestConstraintType) MaxCookieCountChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_cookie_count_choice")
	}
	return validatorFn, nil
}

func (v *ValidateRequestConstraintType) MaxCookieCountChoiceMaxCookieCountExceedsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_MaxCookieCountExceeds, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_cookie_count_exceeds")
	}
	return oValidatorFn_MaxCookieCountExceeds, nil
}

func (v *ValidateRequestConstraintType) MaxCookieKeySizeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_cookie_key_size_choice")
	}
	return validatorFn, nil
}

func (v *ValidateRequestConstraintType) MaxCookieKeySizeChoiceMaxCookieKeySizeExceedsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_MaxCookieKeySizeExceeds, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_cookie_key_size_exceeds")
	}
	return oValidatorFn_MaxCookieKeySizeExceeds, nil
}

func (v *ValidateRequestConstraintType) MaxCookieValueSizeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_cookie_value_size_choice")
	}
	return validatorFn, nil
}

func (v *ValidateRequestConstraintType) MaxCookieValueSizeChoiceMaxCookieValueSizeExceedsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_MaxCookieValueSizeExceeds, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_cookie_value_size_exceeds")
	}
	return oValidatorFn_MaxCookieValueSizeExceeds, nil
}

func (v *ValidateRequestConstraintType) MaxHeaderCountChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_header_count_choice")
	}
	return validatorFn, nil
}

func (v *ValidateRequestConstraintType) MaxHeaderCountChoiceMaxHeaderCountExceedsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_MaxHeaderCountExceeds, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_header_count_exceeds")
	}
	return oValidatorFn_MaxHeaderCountExceeds, nil
}

func (v *ValidateRequestConstraintType) MaxHeaderKeySizeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_header_key_size_choice")
	}
	return validatorFn, nil
}

func (v *ValidateRequestConstraintType) MaxHeaderKeySizeChoiceMaxHeaderKeySizeExceedsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_MaxHeaderKeySizeExceeds, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_header_key_size_exceeds")
	}
	return oValidatorFn_MaxHeaderKeySizeExceeds, nil
}

func (v *ValidateRequestConstraintType) MaxHeaderValueSizeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_header_value_size_choice")
	}
	return validatorFn, nil
}

func (v *ValidateRequestConstraintType) MaxHeaderValueSizeChoiceMaxHeaderValueSizeExceedsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_MaxHeaderValueSizeExceeds, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_header_value_size_exceeds")
	}
	return oValidatorFn_MaxHeaderValueSizeExceeds, nil
}

func (v *ValidateRequestConstraintType) MaxParameterCountChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_parameter_count_choice")
	}
	return validatorFn, nil
}

func (v *ValidateRequestConstraintType) MaxParameterCountChoiceMaxParameterCountExceedsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_MaxParameterCountExceeds, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_parameter_count_exceeds")
	}
	return oValidatorFn_MaxParameterCountExceeds, nil
}

func (v *ValidateRequestConstraintType) MaxParameterNameSizeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_parameter_name_size_choice")
	}
	return validatorFn, nil
}

func (v *ValidateRequestConstraintType) MaxParameterNameSizeChoiceMaxParameterNameSizeExceedsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_MaxParameterNameSizeExceeds, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_parameter_name_size_exceeds")
	}
	return oValidatorFn_MaxParameterNameSizeExceeds, nil
}

func (v *ValidateRequestConstraintType) MaxParameterValueSizeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_parameter_value_size_choice")
	}
	return validatorFn, nil
}

func (v *ValidateRequestConstraintType) MaxParameterValueSizeChoiceMaxParameterValueSizeExceedsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_MaxParameterValueSizeExceeds, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_parameter_value_size_exceeds")
	}
	return oValidatorFn_MaxParameterValueSizeExceeds, nil
}

func (v *ValidateRequestConstraintType) MaxQuerySizeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_query_size_choice")
	}
	return validatorFn, nil
}

func (v *ValidateRequestConstraintType) MaxQuerySizeChoiceMaxQuerySizeExceedsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_MaxQuerySizeExceeds, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_query_size_exceeds")
	}
	return oValidatorFn_MaxQuerySizeExceeds, nil
}

func (v *ValidateRequestConstraintType) MaxRequestLineSizeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_request_line_size_choice")
	}
	return validatorFn, nil
}

func (v *ValidateRequestConstraintType) MaxRequestLineSizeChoiceMaxRequestLineSizeExceedsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_MaxRequestLineSizeExceeds, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_request_line_size_exceeds")
	}
	return oValidatorFn_MaxRequestLineSizeExceeds, nil
}

func (v *ValidateRequestConstraintType) MaxRequestSizeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_request_size_choice")
	}
	return validatorFn, nil
}

func (v *ValidateRequestConstraintType) MaxRequestSizeChoiceMaxRequestSizeExceedsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_MaxRequestSizeExceeds, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_request_size_exceeds")
	}
	return oValidatorFn_MaxRequestSizeExceeds, nil
}

func (v *ValidateRequestConstraintType) MaxUrlSizeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_url_size_choice")
	}
	return validatorFn, nil
}

func (v *ValidateRequestConstraintType) MaxUrlSizeChoiceMaxUrlSizeExceedsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_MaxUrlSizeExceeds, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_url_size_exceeds")
	}
	return oValidatorFn_MaxUrlSizeExceeds, nil
}

func (v *ValidateRequestConstraintType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RequestConstraintType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RequestConstraintType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["max_cookie_count_choice"]; exists {
		val := m.GetMaxCookieCountChoice()
		vOpts := append(opts,
			db.WithValidateField("max_cookie_count_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMaxCookieCountChoice().(type) {
	case *RequestConstraintType_MaxCookieCountNone:
		if fv, exists := v.FldValidators["max_cookie_count_choice.max_cookie_count_none"]; exists {
			val := m.GetMaxCookieCountChoice().(*RequestConstraintType_MaxCookieCountNone).MaxCookieCountNone
			vOpts := append(opts,
				db.WithValidateField("max_cookie_count_choice"),
				db.WithValidateField("max_cookie_count_none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RequestConstraintType_MaxCookieCountExceeds:
		if fv, exists := v.FldValidators["max_cookie_count_choice.max_cookie_count_exceeds"]; exists {
			val := m.GetMaxCookieCountChoice().(*RequestConstraintType_MaxCookieCountExceeds).MaxCookieCountExceeds
			vOpts := append(opts,
				db.WithValidateField("max_cookie_count_choice"),
				db.WithValidateField("max_cookie_count_exceeds"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["max_cookie_key_size_choice"]; exists {
		val := m.GetMaxCookieKeySizeChoice()
		vOpts := append(opts,
			db.WithValidateField("max_cookie_key_size_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMaxCookieKeySizeChoice().(type) {
	case *RequestConstraintType_MaxCookieKeySizeNone:
		if fv, exists := v.FldValidators["max_cookie_key_size_choice.max_cookie_key_size_none"]; exists {
			val := m.GetMaxCookieKeySizeChoice().(*RequestConstraintType_MaxCookieKeySizeNone).MaxCookieKeySizeNone
			vOpts := append(opts,
				db.WithValidateField("max_cookie_key_size_choice"),
				db.WithValidateField("max_cookie_key_size_none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RequestConstraintType_MaxCookieKeySizeExceeds:
		if fv, exists := v.FldValidators["max_cookie_key_size_choice.max_cookie_key_size_exceeds"]; exists {
			val := m.GetMaxCookieKeySizeChoice().(*RequestConstraintType_MaxCookieKeySizeExceeds).MaxCookieKeySizeExceeds
			vOpts := append(opts,
				db.WithValidateField("max_cookie_key_size_choice"),
				db.WithValidateField("max_cookie_key_size_exceeds"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["max_cookie_value_size_choice"]; exists {
		val := m.GetMaxCookieValueSizeChoice()
		vOpts := append(opts,
			db.WithValidateField("max_cookie_value_size_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMaxCookieValueSizeChoice().(type) {
	case *RequestConstraintType_MaxCookieValueSizeNone:
		if fv, exists := v.FldValidators["max_cookie_value_size_choice.max_cookie_value_size_none"]; exists {
			val := m.GetMaxCookieValueSizeChoice().(*RequestConstraintType_MaxCookieValueSizeNone).MaxCookieValueSizeNone
			vOpts := append(opts,
				db.WithValidateField("max_cookie_value_size_choice"),
				db.WithValidateField("max_cookie_value_size_none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RequestConstraintType_MaxCookieValueSizeExceeds:
		if fv, exists := v.FldValidators["max_cookie_value_size_choice.max_cookie_value_size_exceeds"]; exists {
			val := m.GetMaxCookieValueSizeChoice().(*RequestConstraintType_MaxCookieValueSizeExceeds).MaxCookieValueSizeExceeds
			vOpts := append(opts,
				db.WithValidateField("max_cookie_value_size_choice"),
				db.WithValidateField("max_cookie_value_size_exceeds"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["max_header_count_choice"]; exists {
		val := m.GetMaxHeaderCountChoice()
		vOpts := append(opts,
			db.WithValidateField("max_header_count_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMaxHeaderCountChoice().(type) {
	case *RequestConstraintType_MaxHeaderCountNone:
		if fv, exists := v.FldValidators["max_header_count_choice.max_header_count_none"]; exists {
			val := m.GetMaxHeaderCountChoice().(*RequestConstraintType_MaxHeaderCountNone).MaxHeaderCountNone
			vOpts := append(opts,
				db.WithValidateField("max_header_count_choice"),
				db.WithValidateField("max_header_count_none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RequestConstraintType_MaxHeaderCountExceeds:
		if fv, exists := v.FldValidators["max_header_count_choice.max_header_count_exceeds"]; exists {
			val := m.GetMaxHeaderCountChoice().(*RequestConstraintType_MaxHeaderCountExceeds).MaxHeaderCountExceeds
			vOpts := append(opts,
				db.WithValidateField("max_header_count_choice"),
				db.WithValidateField("max_header_count_exceeds"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["max_header_key_size_choice"]; exists {
		val := m.GetMaxHeaderKeySizeChoice()
		vOpts := append(opts,
			db.WithValidateField("max_header_key_size_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMaxHeaderKeySizeChoice().(type) {
	case *RequestConstraintType_MaxHeaderKeySizeNone:
		if fv, exists := v.FldValidators["max_header_key_size_choice.max_header_key_size_none"]; exists {
			val := m.GetMaxHeaderKeySizeChoice().(*RequestConstraintType_MaxHeaderKeySizeNone).MaxHeaderKeySizeNone
			vOpts := append(opts,
				db.WithValidateField("max_header_key_size_choice"),
				db.WithValidateField("max_header_key_size_none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RequestConstraintType_MaxHeaderKeySizeExceeds:
		if fv, exists := v.FldValidators["max_header_key_size_choice.max_header_key_size_exceeds"]; exists {
			val := m.GetMaxHeaderKeySizeChoice().(*RequestConstraintType_MaxHeaderKeySizeExceeds).MaxHeaderKeySizeExceeds
			vOpts := append(opts,
				db.WithValidateField("max_header_key_size_choice"),
				db.WithValidateField("max_header_key_size_exceeds"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["max_header_value_size_choice"]; exists {
		val := m.GetMaxHeaderValueSizeChoice()
		vOpts := append(opts,
			db.WithValidateField("max_header_value_size_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMaxHeaderValueSizeChoice().(type) {
	case *RequestConstraintType_MaxHeaderValueSizeNone:
		if fv, exists := v.FldValidators["max_header_value_size_choice.max_header_value_size_none"]; exists {
			val := m.GetMaxHeaderValueSizeChoice().(*RequestConstraintType_MaxHeaderValueSizeNone).MaxHeaderValueSizeNone
			vOpts := append(opts,
				db.WithValidateField("max_header_value_size_choice"),
				db.WithValidateField("max_header_value_size_none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RequestConstraintType_MaxHeaderValueSizeExceeds:
		if fv, exists := v.FldValidators["max_header_value_size_choice.max_header_value_size_exceeds"]; exists {
			val := m.GetMaxHeaderValueSizeChoice().(*RequestConstraintType_MaxHeaderValueSizeExceeds).MaxHeaderValueSizeExceeds
			vOpts := append(opts,
				db.WithValidateField("max_header_value_size_choice"),
				db.WithValidateField("max_header_value_size_exceeds"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["max_parameter_count_choice"]; exists {
		val := m.GetMaxParameterCountChoice()
		vOpts := append(opts,
			db.WithValidateField("max_parameter_count_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMaxParameterCountChoice().(type) {
	case *RequestConstraintType_MaxParameterCountNone:
		if fv, exists := v.FldValidators["max_parameter_count_choice.max_parameter_count_none"]; exists {
			val := m.GetMaxParameterCountChoice().(*RequestConstraintType_MaxParameterCountNone).MaxParameterCountNone
			vOpts := append(opts,
				db.WithValidateField("max_parameter_count_choice"),
				db.WithValidateField("max_parameter_count_none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RequestConstraintType_MaxParameterCountExceeds:
		if fv, exists := v.FldValidators["max_parameter_count_choice.max_parameter_count_exceeds"]; exists {
			val := m.GetMaxParameterCountChoice().(*RequestConstraintType_MaxParameterCountExceeds).MaxParameterCountExceeds
			vOpts := append(opts,
				db.WithValidateField("max_parameter_count_choice"),
				db.WithValidateField("max_parameter_count_exceeds"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["max_parameter_name_size_choice"]; exists {
		val := m.GetMaxParameterNameSizeChoice()
		vOpts := append(opts,
			db.WithValidateField("max_parameter_name_size_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMaxParameterNameSizeChoice().(type) {
	case *RequestConstraintType_MaxParameterNameSizeNone:
		if fv, exists := v.FldValidators["max_parameter_name_size_choice.max_parameter_name_size_none"]; exists {
			val := m.GetMaxParameterNameSizeChoice().(*RequestConstraintType_MaxParameterNameSizeNone).MaxParameterNameSizeNone
			vOpts := append(opts,
				db.WithValidateField("max_parameter_name_size_choice"),
				db.WithValidateField("max_parameter_name_size_none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RequestConstraintType_MaxParameterNameSizeExceeds:
		if fv, exists := v.FldValidators["max_parameter_name_size_choice.max_parameter_name_size_exceeds"]; exists {
			val := m.GetMaxParameterNameSizeChoice().(*RequestConstraintType_MaxParameterNameSizeExceeds).MaxParameterNameSizeExceeds
			vOpts := append(opts,
				db.WithValidateField("max_parameter_name_size_choice"),
				db.WithValidateField("max_parameter_name_size_exceeds"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["max_parameter_value_size_choice"]; exists {
		val := m.GetMaxParameterValueSizeChoice()
		vOpts := append(opts,
			db.WithValidateField("max_parameter_value_size_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMaxParameterValueSizeChoice().(type) {
	case *RequestConstraintType_MaxParameterValueSizeNone:
		if fv, exists := v.FldValidators["max_parameter_value_size_choice.max_parameter_value_size_none"]; exists {
			val := m.GetMaxParameterValueSizeChoice().(*RequestConstraintType_MaxParameterValueSizeNone).MaxParameterValueSizeNone
			vOpts := append(opts,
				db.WithValidateField("max_parameter_value_size_choice"),
				db.WithValidateField("max_parameter_value_size_none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RequestConstraintType_MaxParameterValueSizeExceeds:
		if fv, exists := v.FldValidators["max_parameter_value_size_choice.max_parameter_value_size_exceeds"]; exists {
			val := m.GetMaxParameterValueSizeChoice().(*RequestConstraintType_MaxParameterValueSizeExceeds).MaxParameterValueSizeExceeds
			vOpts := append(opts,
				db.WithValidateField("max_parameter_value_size_choice"),
				db.WithValidateField("max_parameter_value_size_exceeds"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["max_query_size_choice"]; exists {
		val := m.GetMaxQuerySizeChoice()
		vOpts := append(opts,
			db.WithValidateField("max_query_size_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMaxQuerySizeChoice().(type) {
	case *RequestConstraintType_MaxQuerySizeNone:
		if fv, exists := v.FldValidators["max_query_size_choice.max_query_size_none"]; exists {
			val := m.GetMaxQuerySizeChoice().(*RequestConstraintType_MaxQuerySizeNone).MaxQuerySizeNone
			vOpts := append(opts,
				db.WithValidateField("max_query_size_choice"),
				db.WithValidateField("max_query_size_none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RequestConstraintType_MaxQuerySizeExceeds:
		if fv, exists := v.FldValidators["max_query_size_choice.max_query_size_exceeds"]; exists {
			val := m.GetMaxQuerySizeChoice().(*RequestConstraintType_MaxQuerySizeExceeds).MaxQuerySizeExceeds
			vOpts := append(opts,
				db.WithValidateField("max_query_size_choice"),
				db.WithValidateField("max_query_size_exceeds"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["max_request_line_size_choice"]; exists {
		val := m.GetMaxRequestLineSizeChoice()
		vOpts := append(opts,
			db.WithValidateField("max_request_line_size_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMaxRequestLineSizeChoice().(type) {
	case *RequestConstraintType_MaxRequestLineSizeNone:
		if fv, exists := v.FldValidators["max_request_line_size_choice.max_request_line_size_none"]; exists {
			val := m.GetMaxRequestLineSizeChoice().(*RequestConstraintType_MaxRequestLineSizeNone).MaxRequestLineSizeNone
			vOpts := append(opts,
				db.WithValidateField("max_request_line_size_choice"),
				db.WithValidateField("max_request_line_size_none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RequestConstraintType_MaxRequestLineSizeExceeds:
		if fv, exists := v.FldValidators["max_request_line_size_choice.max_request_line_size_exceeds"]; exists {
			val := m.GetMaxRequestLineSizeChoice().(*RequestConstraintType_MaxRequestLineSizeExceeds).MaxRequestLineSizeExceeds
			vOpts := append(opts,
				db.WithValidateField("max_request_line_size_choice"),
				db.WithValidateField("max_request_line_size_exceeds"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["max_request_size_choice"]; exists {
		val := m.GetMaxRequestSizeChoice()
		vOpts := append(opts,
			db.WithValidateField("max_request_size_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMaxRequestSizeChoice().(type) {
	case *RequestConstraintType_MaxRequestSizeNone:
		if fv, exists := v.FldValidators["max_request_size_choice.max_request_size_none"]; exists {
			val := m.GetMaxRequestSizeChoice().(*RequestConstraintType_MaxRequestSizeNone).MaxRequestSizeNone
			vOpts := append(opts,
				db.WithValidateField("max_request_size_choice"),
				db.WithValidateField("max_request_size_none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RequestConstraintType_MaxRequestSizeExceeds:
		if fv, exists := v.FldValidators["max_request_size_choice.max_request_size_exceeds"]; exists {
			val := m.GetMaxRequestSizeChoice().(*RequestConstraintType_MaxRequestSizeExceeds).MaxRequestSizeExceeds
			vOpts := append(opts,
				db.WithValidateField("max_request_size_choice"),
				db.WithValidateField("max_request_size_exceeds"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["max_url_size_choice"]; exists {
		val := m.GetMaxUrlSizeChoice()
		vOpts := append(opts,
			db.WithValidateField("max_url_size_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMaxUrlSizeChoice().(type) {
	case *RequestConstraintType_MaxUrlSizeNone:
		if fv, exists := v.FldValidators["max_url_size_choice.max_url_size_none"]; exists {
			val := m.GetMaxUrlSizeChoice().(*RequestConstraintType_MaxUrlSizeNone).MaxUrlSizeNone
			vOpts := append(opts,
				db.WithValidateField("max_url_size_choice"),
				db.WithValidateField("max_url_size_none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RequestConstraintType_MaxUrlSizeExceeds:
		if fv, exists := v.FldValidators["max_url_size_choice.max_url_size_exceeds"]; exists {
			val := m.GetMaxUrlSizeChoice().(*RequestConstraintType_MaxUrlSizeExceeds).MaxUrlSizeExceeds
			vOpts := append(opts,
				db.WithValidateField("max_url_size_choice"),
				db.WithValidateField("max_url_size_exceeds"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRequestConstraintTypeValidator = func() *ValidateRequestConstraintType {
	v := &ValidateRequestConstraintType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMaxCookieCountChoice := v.MaxCookieCountChoiceValidationRuleHandler
	rulesMaxCookieCountChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMaxCookieCountChoice(rulesMaxCookieCountChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RequestConstraintType.max_cookie_count_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_cookie_count_choice"] = vFn

	vrhMaxCookieCountChoiceMaxCookieCountExceeds := v.MaxCookieCountChoiceMaxCookieCountExceedsValidationRuleHandler
	rulesMaxCookieCountChoiceMaxCookieCountExceeds := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "1024",
	}
	vFnMap["max_cookie_count_choice.max_cookie_count_exceeds"], err = vrhMaxCookieCountChoiceMaxCookieCountExceeds(rulesMaxCookieCountChoiceMaxCookieCountExceeds)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field RequestConstraintType.max_cookie_count_choice_max_cookie_count_exceeds: %s", err)
		panic(errMsg)
	}

	v.FldValidators["max_cookie_count_choice.max_cookie_count_exceeds"] = vFnMap["max_cookie_count_choice.max_cookie_count_exceeds"]

	vrhMaxCookieKeySizeChoice := v.MaxCookieKeySizeChoiceValidationRuleHandler
	rulesMaxCookieKeySizeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMaxCookieKeySizeChoice(rulesMaxCookieKeySizeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RequestConstraintType.max_cookie_key_size_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_cookie_key_size_choice"] = vFn

	vrhMaxCookieKeySizeChoiceMaxCookieKeySizeExceeds := v.MaxCookieKeySizeChoiceMaxCookieKeySizeExceedsValidationRuleHandler
	rulesMaxCookieKeySizeChoiceMaxCookieKeySizeExceeds := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "1024",
	}
	vFnMap["max_cookie_key_size_choice.max_cookie_key_size_exceeds"], err = vrhMaxCookieKeySizeChoiceMaxCookieKeySizeExceeds(rulesMaxCookieKeySizeChoiceMaxCookieKeySizeExceeds)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field RequestConstraintType.max_cookie_key_size_choice_max_cookie_key_size_exceeds: %s", err)
		panic(errMsg)
	}

	v.FldValidators["max_cookie_key_size_choice.max_cookie_key_size_exceeds"] = vFnMap["max_cookie_key_size_choice.max_cookie_key_size_exceeds"]

	vrhMaxCookieValueSizeChoice := v.MaxCookieValueSizeChoiceValidationRuleHandler
	rulesMaxCookieValueSizeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMaxCookieValueSizeChoice(rulesMaxCookieValueSizeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RequestConstraintType.max_cookie_value_size_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_cookie_value_size_choice"] = vFn

	vrhMaxCookieValueSizeChoiceMaxCookieValueSizeExceeds := v.MaxCookieValueSizeChoiceMaxCookieValueSizeExceedsValidationRuleHandler
	rulesMaxCookieValueSizeChoiceMaxCookieValueSizeExceeds := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "32768",
	}
	vFnMap["max_cookie_value_size_choice.max_cookie_value_size_exceeds"], err = vrhMaxCookieValueSizeChoiceMaxCookieValueSizeExceeds(rulesMaxCookieValueSizeChoiceMaxCookieValueSizeExceeds)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field RequestConstraintType.max_cookie_value_size_choice_max_cookie_value_size_exceeds: %s", err)
		panic(errMsg)
	}

	v.FldValidators["max_cookie_value_size_choice.max_cookie_value_size_exceeds"] = vFnMap["max_cookie_value_size_choice.max_cookie_value_size_exceeds"]

	vrhMaxHeaderCountChoice := v.MaxHeaderCountChoiceValidationRuleHandler
	rulesMaxHeaderCountChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMaxHeaderCountChoice(rulesMaxHeaderCountChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RequestConstraintType.max_header_count_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_header_count_choice"] = vFn

	vrhMaxHeaderCountChoiceMaxHeaderCountExceeds := v.MaxHeaderCountChoiceMaxHeaderCountExceedsValidationRuleHandler
	rulesMaxHeaderCountChoiceMaxHeaderCountExceeds := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "40",
	}
	vFnMap["max_header_count_choice.max_header_count_exceeds"], err = vrhMaxHeaderCountChoiceMaxHeaderCountExceeds(rulesMaxHeaderCountChoiceMaxHeaderCountExceeds)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field RequestConstraintType.max_header_count_choice_max_header_count_exceeds: %s", err)
		panic(errMsg)
	}

	v.FldValidators["max_header_count_choice.max_header_count_exceeds"] = vFnMap["max_header_count_choice.max_header_count_exceeds"]

	vrhMaxHeaderKeySizeChoice := v.MaxHeaderKeySizeChoiceValidationRuleHandler
	rulesMaxHeaderKeySizeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMaxHeaderKeySizeChoice(rulesMaxHeaderKeySizeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RequestConstraintType.max_header_key_size_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_header_key_size_choice"] = vFn

	vrhMaxHeaderKeySizeChoiceMaxHeaderKeySizeExceeds := v.MaxHeaderKeySizeChoiceMaxHeaderKeySizeExceedsValidationRuleHandler
	rulesMaxHeaderKeySizeChoiceMaxHeaderKeySizeExceeds := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "1024",
	}
	vFnMap["max_header_key_size_choice.max_header_key_size_exceeds"], err = vrhMaxHeaderKeySizeChoiceMaxHeaderKeySizeExceeds(rulesMaxHeaderKeySizeChoiceMaxHeaderKeySizeExceeds)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field RequestConstraintType.max_header_key_size_choice_max_header_key_size_exceeds: %s", err)
		panic(errMsg)
	}

	v.FldValidators["max_header_key_size_choice.max_header_key_size_exceeds"] = vFnMap["max_header_key_size_choice.max_header_key_size_exceeds"]

	vrhMaxHeaderValueSizeChoice := v.MaxHeaderValueSizeChoiceValidationRuleHandler
	rulesMaxHeaderValueSizeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMaxHeaderValueSizeChoice(rulesMaxHeaderValueSizeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RequestConstraintType.max_header_value_size_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_header_value_size_choice"] = vFn

	vrhMaxHeaderValueSizeChoiceMaxHeaderValueSizeExceeds := v.MaxHeaderValueSizeChoiceMaxHeaderValueSizeExceedsValidationRuleHandler
	rulesMaxHeaderValueSizeChoiceMaxHeaderValueSizeExceeds := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "64000",
	}
	vFnMap["max_header_value_size_choice.max_header_value_size_exceeds"], err = vrhMaxHeaderValueSizeChoiceMaxHeaderValueSizeExceeds(rulesMaxHeaderValueSizeChoiceMaxHeaderValueSizeExceeds)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field RequestConstraintType.max_header_value_size_choice_max_header_value_size_exceeds: %s", err)
		panic(errMsg)
	}

	v.FldValidators["max_header_value_size_choice.max_header_value_size_exceeds"] = vFnMap["max_header_value_size_choice.max_header_value_size_exceeds"]

	vrhMaxParameterCountChoice := v.MaxParameterCountChoiceValidationRuleHandler
	rulesMaxParameterCountChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMaxParameterCountChoice(rulesMaxParameterCountChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RequestConstraintType.max_parameter_count_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_parameter_count_choice"] = vFn

	vrhMaxParameterCountChoiceMaxParameterCountExceeds := v.MaxParameterCountChoiceMaxParameterCountExceedsValidationRuleHandler
	rulesMaxParameterCountChoiceMaxParameterCountExceeds := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "1024",
	}
	vFnMap["max_parameter_count_choice.max_parameter_count_exceeds"], err = vrhMaxParameterCountChoiceMaxParameterCountExceeds(rulesMaxParameterCountChoiceMaxParameterCountExceeds)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field RequestConstraintType.max_parameter_count_choice_max_parameter_count_exceeds: %s", err)
		panic(errMsg)
	}

	v.FldValidators["max_parameter_count_choice.max_parameter_count_exceeds"] = vFnMap["max_parameter_count_choice.max_parameter_count_exceeds"]

	vrhMaxParameterNameSizeChoice := v.MaxParameterNameSizeChoiceValidationRuleHandler
	rulesMaxParameterNameSizeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMaxParameterNameSizeChoice(rulesMaxParameterNameSizeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RequestConstraintType.max_parameter_name_size_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_parameter_name_size_choice"] = vFn

	vrhMaxParameterNameSizeChoiceMaxParameterNameSizeExceeds := v.MaxParameterNameSizeChoiceMaxParameterNameSizeExceedsValidationRuleHandler
	rulesMaxParameterNameSizeChoiceMaxParameterNameSizeExceeds := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "1024",
	}
	vFnMap["max_parameter_name_size_choice.max_parameter_name_size_exceeds"], err = vrhMaxParameterNameSizeChoiceMaxParameterNameSizeExceeds(rulesMaxParameterNameSizeChoiceMaxParameterNameSizeExceeds)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field RequestConstraintType.max_parameter_name_size_choice_max_parameter_name_size_exceeds: %s", err)
		panic(errMsg)
	}

	v.FldValidators["max_parameter_name_size_choice.max_parameter_name_size_exceeds"] = vFnMap["max_parameter_name_size_choice.max_parameter_name_size_exceeds"]

	vrhMaxParameterValueSizeChoice := v.MaxParameterValueSizeChoiceValidationRuleHandler
	rulesMaxParameterValueSizeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMaxParameterValueSizeChoice(rulesMaxParameterValueSizeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RequestConstraintType.max_parameter_value_size_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_parameter_value_size_choice"] = vFn

	vrhMaxParameterValueSizeChoiceMaxParameterValueSizeExceeds := v.MaxParameterValueSizeChoiceMaxParameterValueSizeExceedsValidationRuleHandler
	rulesMaxParameterValueSizeChoiceMaxParameterValueSizeExceeds := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "1073741824",
	}
	vFnMap["max_parameter_value_size_choice.max_parameter_value_size_exceeds"], err = vrhMaxParameterValueSizeChoiceMaxParameterValueSizeExceeds(rulesMaxParameterValueSizeChoiceMaxParameterValueSizeExceeds)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field RequestConstraintType.max_parameter_value_size_choice_max_parameter_value_size_exceeds: %s", err)
		panic(errMsg)
	}

	v.FldValidators["max_parameter_value_size_choice.max_parameter_value_size_exceeds"] = vFnMap["max_parameter_value_size_choice.max_parameter_value_size_exceeds"]

	vrhMaxQuerySizeChoice := v.MaxQuerySizeChoiceValidationRuleHandler
	rulesMaxQuerySizeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMaxQuerySizeChoice(rulesMaxQuerySizeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RequestConstraintType.max_query_size_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_query_size_choice"] = vFn

	vrhMaxQuerySizeChoiceMaxQuerySizeExceeds := v.MaxQuerySizeChoiceMaxQuerySizeExceedsValidationRuleHandler
	rulesMaxQuerySizeChoiceMaxQuerySizeExceeds := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "60000",
	}
	vFnMap["max_query_size_choice.max_query_size_exceeds"], err = vrhMaxQuerySizeChoiceMaxQuerySizeExceeds(rulesMaxQuerySizeChoiceMaxQuerySizeExceeds)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field RequestConstraintType.max_query_size_choice_max_query_size_exceeds: %s", err)
		panic(errMsg)
	}

	v.FldValidators["max_query_size_choice.max_query_size_exceeds"] = vFnMap["max_query_size_choice.max_query_size_exceeds"]

	vrhMaxRequestLineSizeChoice := v.MaxRequestLineSizeChoiceValidationRuleHandler
	rulesMaxRequestLineSizeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMaxRequestLineSizeChoice(rulesMaxRequestLineSizeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RequestConstraintType.max_request_line_size_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_request_line_size_choice"] = vFn

	vrhMaxRequestLineSizeChoiceMaxRequestLineSizeExceeds := v.MaxRequestLineSizeChoiceMaxRequestLineSizeExceedsValidationRuleHandler
	rulesMaxRequestLineSizeChoiceMaxRequestLineSizeExceeds := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "65536",
	}
	vFnMap["max_request_line_size_choice.max_request_line_size_exceeds"], err = vrhMaxRequestLineSizeChoiceMaxRequestLineSizeExceeds(rulesMaxRequestLineSizeChoiceMaxRequestLineSizeExceeds)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field RequestConstraintType.max_request_line_size_choice_max_request_line_size_exceeds: %s", err)
		panic(errMsg)
	}

	v.FldValidators["max_request_line_size_choice.max_request_line_size_exceeds"] = vFnMap["max_request_line_size_choice.max_request_line_size_exceeds"]

	vrhMaxRequestSizeChoice := v.MaxRequestSizeChoiceValidationRuleHandler
	rulesMaxRequestSizeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMaxRequestSizeChoice(rulesMaxRequestSizeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RequestConstraintType.max_request_size_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_request_size_choice"] = vFn

	vrhMaxRequestSizeChoiceMaxRequestSizeExceeds := v.MaxRequestSizeChoiceMaxRequestSizeExceedsValidationRuleHandler
	rulesMaxRequestSizeChoiceMaxRequestSizeExceeds := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "65536",
	}
	vFnMap["max_request_size_choice.max_request_size_exceeds"], err = vrhMaxRequestSizeChoiceMaxRequestSizeExceeds(rulesMaxRequestSizeChoiceMaxRequestSizeExceeds)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field RequestConstraintType.max_request_size_choice_max_request_size_exceeds: %s", err)
		panic(errMsg)
	}

	v.FldValidators["max_request_size_choice.max_request_size_exceeds"] = vFnMap["max_request_size_choice.max_request_size_exceeds"]

	vrhMaxUrlSizeChoice := v.MaxUrlSizeChoiceValidationRuleHandler
	rulesMaxUrlSizeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMaxUrlSizeChoice(rulesMaxUrlSizeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RequestConstraintType.max_url_size_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_url_size_choice"] = vFn

	vrhMaxUrlSizeChoiceMaxUrlSizeExceeds := v.MaxUrlSizeChoiceMaxUrlSizeExceedsValidationRuleHandler
	rulesMaxUrlSizeChoiceMaxUrlSizeExceeds := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "128000",
	}
	vFnMap["max_url_size_choice.max_url_size_exceeds"], err = vrhMaxUrlSizeChoiceMaxUrlSizeExceeds(rulesMaxUrlSizeChoiceMaxUrlSizeExceeds)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field RequestConstraintType.max_url_size_choice_max_url_size_exceeds: %s", err)
		panic(errMsg)
	}

	v.FldValidators["max_url_size_choice.max_url_size_exceeds"] = vFnMap["max_url_size_choice.max_url_size_exceeds"]

	return v
}()

func RequestConstraintTypeValidator() db.Validator {
	return DefaultRequestConstraintTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *RequestMatcher) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RequestMatcher) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RequestMatcher) DeepCopy() *RequestMatcher {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RequestMatcher{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RequestMatcher) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RequestMatcher) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RequestMatcherValidator().Validate(ctx, m, opts...)
}

type ValidateRequestMatcher struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRequestMatcher) QueryParamsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for query_params")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*QueryParameterMatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := QueryParameterMatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for query_params")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*QueryParameterMatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*QueryParameterMatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated query_params")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items query_params")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRequestMatcher) HeadersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for headers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*HeaderMatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := HeaderMatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for headers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*HeaderMatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*HeaderMatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated headers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items headers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRequestMatcher) CookieMatchersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for cookie_matchers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*CookieMatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := CookieMatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cookie_matchers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*CookieMatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*CookieMatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cookie_matchers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cookie_matchers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRequestMatcher) JwtClaimsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for jwt_claims")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*JWTClaimMatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := JWTClaimMatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for jwt_claims")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*JWTClaimMatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*JWTClaimMatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated jwt_claims")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items jwt_claims")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRequestMatcher) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RequestMatcher)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RequestMatcher got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cookie_matchers"]; exists {
		vOpts := append(opts, db.WithValidateField("cookie_matchers"))
		if err := fv(ctx, m.GetCookieMatchers(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["headers"]; exists {
		vOpts := append(opts, db.WithValidateField("headers"))
		if err := fv(ctx, m.GetHeaders(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["jwt_claims"]; exists {
		vOpts := append(opts, db.WithValidateField("jwt_claims"))
		if err := fv(ctx, m.GetJwtClaims(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query_params"]; exists {
		vOpts := append(opts, db.WithValidateField("query_params"))
		if err := fv(ctx, m.GetQueryParams(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRequestMatcherValidator = func() *ValidateRequestMatcher {
	v := &ValidateRequestMatcher{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhQueryParams := v.QueryParamsValidationRuleHandler
	rulesQueryParams := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhQueryParams(rulesQueryParams)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RequestMatcher.query_params: %s", err)
		panic(errMsg)
	}
	v.FldValidators["query_params"] = vFn

	vrhHeaders := v.HeadersValidationRuleHandler
	rulesHeaders := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhHeaders(rulesHeaders)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RequestMatcher.headers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["headers"] = vFn

	vrhCookieMatchers := v.CookieMatchersValidationRuleHandler
	rulesCookieMatchers := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhCookieMatchers(rulesCookieMatchers)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RequestMatcher.cookie_matchers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cookie_matchers"] = vFn

	vrhJwtClaims := v.JwtClaimsValidationRuleHandler
	rulesJwtClaims := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhJwtClaims(rulesJwtClaims)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RequestMatcher.jwt_claims: %s", err)
		panic(errMsg)
	}
	v.FldValidators["jwt_claims"] = vFn

	return v
}()

func RequestMatcherValidator() db.Validator {
	return DefaultRequestMatcherValidator
}

// augmented methods on protoc/std generated struct

func (m *RoleMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RoleMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RoleMatcherType) DeepCopy() *RoleMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RoleMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RoleMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RoleMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RoleMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateRoleMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRoleMatcherType) MatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for match")
	}

	return validatorFn, nil
}

func (v *ValidateRoleMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RoleMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RoleMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["match"]; exists {

		vOpts := append(opts, db.WithValidateField("match"))
		if err := fv(ctx, m.GetMatch(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRoleMatcherTypeValidator = func() *ValidateRoleMatcherType {
	v := &ValidateRoleMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMatch := v.MatchValidationRuleHandler
	rulesMatch := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "63",
	}
	vFn, err = vrhMatch(rulesMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RoleMatcherType.match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["match"] = vFn

	return v
}()

func RoleMatcherTypeValidator() db.Validator {
	return DefaultRoleMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SecurityPoliciesType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SecurityPoliciesType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SecurityPoliciesType) DeepCopy() *SecurityPoliciesType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SecurityPoliciesType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SecurityPoliciesType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SecurityPoliciesType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SecurityPoliciesTypeValidator().Validate(ctx, m, opts...)
}

func (m *SecurityPoliciesType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetFirewallPolicyChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetFirewallPolicyChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetForwardProxyChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetForwardProxyChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *SecurityPoliciesType) GetFirewallPolicyChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetFirewallPolicyChoice() == nil {
		return nil, nil
	}
	switch m.GetFirewallPolicyChoice().(type) {
	case *SecurityPoliciesType_NoFirewallPolicy:

		return nil, nil

	case *SecurityPoliciesType_ActiveEnhancedFirewallPolicies:

		drInfos, err := m.GetActiveEnhancedFirewallPolicies().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetActiveEnhancedFirewallPolicies().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "active_enhanced_firewall_policies." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *SecurityPoliciesType) GetForwardProxyChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetForwardProxyChoice() == nil {
		return nil, nil
	}
	switch m.GetForwardProxyChoice().(type) {
	case *SecurityPoliciesType_NoForwardProxy:

		return nil, nil

	case *SecurityPoliciesType_ActiveForwardProxyPolicies:

		drInfos, err := m.GetActiveForwardProxyPolicies().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetActiveForwardProxyPolicies().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "active_forward_proxy_policies." + dri.DRField
		}
		return drInfos, err

	case *SecurityPoliciesType_ActiveServicePolicies:

		drInfos, err := m.GetActiveServicePolicies().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetActiveServicePolicies().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "active_service_policies." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateSecurityPoliciesType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSecurityPoliciesType) FirewallPolicyChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for firewall_policy_choice")
	}
	return validatorFn, nil
}

func (v *ValidateSecurityPoliciesType) ForwardProxyChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for forward_proxy_choice")
	}
	return validatorFn, nil
}

func (v *ValidateSecurityPoliciesType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SecurityPoliciesType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SecurityPoliciesType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["firewall_policy_choice"]; exists {
		val := m.GetFirewallPolicyChoice()
		vOpts := append(opts,
			db.WithValidateField("firewall_policy_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetFirewallPolicyChoice().(type) {
	case *SecurityPoliciesType_NoFirewallPolicy:
		if fv, exists := v.FldValidators["firewall_policy_choice.no_firewall_policy"]; exists {
			val := m.GetFirewallPolicyChoice().(*SecurityPoliciesType_NoFirewallPolicy).NoFirewallPolicy
			vOpts := append(opts,
				db.WithValidateField("firewall_policy_choice"),
				db.WithValidateField("no_firewall_policy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SecurityPoliciesType_ActiveEnhancedFirewallPolicies:
		if fv, exists := v.FldValidators["firewall_policy_choice.active_enhanced_firewall_policies"]; exists {
			val := m.GetFirewallPolicyChoice().(*SecurityPoliciesType_ActiveEnhancedFirewallPolicies).ActiveEnhancedFirewallPolicies
			vOpts := append(opts,
				db.WithValidateField("firewall_policy_choice"),
				db.WithValidateField("active_enhanced_firewall_policies"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["forward_proxy_choice"]; exists {
		val := m.GetForwardProxyChoice()
		vOpts := append(opts,
			db.WithValidateField("forward_proxy_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetForwardProxyChoice().(type) {
	case *SecurityPoliciesType_NoForwardProxy:
		if fv, exists := v.FldValidators["forward_proxy_choice.no_forward_proxy"]; exists {
			val := m.GetForwardProxyChoice().(*SecurityPoliciesType_NoForwardProxy).NoForwardProxy
			vOpts := append(opts,
				db.WithValidateField("forward_proxy_choice"),
				db.WithValidateField("no_forward_proxy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SecurityPoliciesType_ActiveForwardProxyPolicies:
		if fv, exists := v.FldValidators["forward_proxy_choice.active_forward_proxy_policies"]; exists {
			val := m.GetForwardProxyChoice().(*SecurityPoliciesType_ActiveForwardProxyPolicies).ActiveForwardProxyPolicies
			vOpts := append(opts,
				db.WithValidateField("forward_proxy_choice"),
				db.WithValidateField("active_forward_proxy_policies"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SecurityPoliciesType_ActiveServicePolicies:
		if fv, exists := v.FldValidators["forward_proxy_choice.active_service_policies"]; exists {
			val := m.GetForwardProxyChoice().(*SecurityPoliciesType_ActiveServicePolicies).ActiveServicePolicies
			vOpts := append(opts,
				db.WithValidateField("forward_proxy_choice"),
				db.WithValidateField("active_service_policies"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSecurityPoliciesTypeValidator = func() *ValidateSecurityPoliciesType {
	v := &ValidateSecurityPoliciesType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhFirewallPolicyChoice := v.FirewallPolicyChoiceValidationRuleHandler
	rulesFirewallPolicyChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhFirewallPolicyChoice(rulesFirewallPolicyChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SecurityPoliciesType.firewall_policy_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["firewall_policy_choice"] = vFn

	vrhForwardProxyChoice := v.ForwardProxyChoiceValidationRuleHandler
	rulesForwardProxyChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhForwardProxyChoice(rulesForwardProxyChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SecurityPoliciesType.forward_proxy_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["forward_proxy_choice"] = vFn

	v.FldValidators["firewall_policy_choice.active_enhanced_firewall_policies"] = ActiveEnhancedFirewallPoliciesTypeValidator().Validate

	v.FldValidators["forward_proxy_choice.active_forward_proxy_policies"] = ActiveForwardProxyPoliciesTypeValidator().Validate
	v.FldValidators["forward_proxy_choice.active_service_policies"] = ActiveServicePoliciesTypeValidator().Validate

	return v
}()

func SecurityPoliciesTypeValidator() db.Validator {
	return DefaultSecurityPoliciesTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SegmentPolicyType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SegmentPolicyType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SegmentPolicyType) DeepCopy() *SegmentPolicyType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SegmentPolicyType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SegmentPolicyType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SegmentPolicyType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SegmentPolicyTypeValidator().Validate(ctx, m, opts...)
}

func (m *SegmentPolicyType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetDstSegmentChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDstSegmentChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetSrcSegmentChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetSrcSegmentChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *SegmentPolicyType) GetDstSegmentChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDstSegmentChoice() == nil {
		return nil, nil
	}
	switch m.GetDstSegmentChoice().(type) {
	case *SegmentPolicyType_DstAny:

		return nil, nil

	case *SegmentPolicyType_IntraSegment:

		return nil, nil

	case *SegmentPolicyType_DstSegments:

		drInfos, err := m.GetDstSegments().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetDstSegments().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "dst_segments." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *SegmentPolicyType) GetSrcSegmentChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetSrcSegmentChoice() == nil {
		return nil, nil
	}
	switch m.GetSrcSegmentChoice().(type) {
	case *SegmentPolicyType_SrcAny:

		return nil, nil

	case *SegmentPolicyType_SrcSegments:

		drInfos, err := m.GetSrcSegments().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSrcSegments().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "src_segments." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateSegmentPolicyType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSegmentPolicyType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SegmentPolicyType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SegmentPolicyType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetDstSegmentChoice().(type) {
	case *SegmentPolicyType_DstAny:
		if fv, exists := v.FldValidators["dst_segment_choice.dst_any"]; exists {
			val := m.GetDstSegmentChoice().(*SegmentPolicyType_DstAny).DstAny
			vOpts := append(opts,
				db.WithValidateField("dst_segment_choice"),
				db.WithValidateField("dst_any"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SegmentPolicyType_IntraSegment:
		if fv, exists := v.FldValidators["dst_segment_choice.intra_segment"]; exists {
			val := m.GetDstSegmentChoice().(*SegmentPolicyType_IntraSegment).IntraSegment
			vOpts := append(opts,
				db.WithValidateField("dst_segment_choice"),
				db.WithValidateField("intra_segment"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SegmentPolicyType_DstSegments:
		if fv, exists := v.FldValidators["dst_segment_choice.dst_segments"]; exists {
			val := m.GetDstSegmentChoice().(*SegmentPolicyType_DstSegments).DstSegments
			vOpts := append(opts,
				db.WithValidateField("dst_segment_choice"),
				db.WithValidateField("dst_segments"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetSrcSegmentChoice().(type) {
	case *SegmentPolicyType_SrcAny:
		if fv, exists := v.FldValidators["src_segment_choice.src_any"]; exists {
			val := m.GetSrcSegmentChoice().(*SegmentPolicyType_SrcAny).SrcAny
			vOpts := append(opts,
				db.WithValidateField("src_segment_choice"),
				db.WithValidateField("src_any"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SegmentPolicyType_SrcSegments:
		if fv, exists := v.FldValidators["src_segment_choice.src_segments"]; exists {
			val := m.GetSrcSegmentChoice().(*SegmentPolicyType_SrcSegments).SrcSegments
			vOpts := append(opts,
				db.WithValidateField("src_segment_choice"),
				db.WithValidateField("src_segments"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSegmentPolicyTypeValidator = func() *ValidateSegmentPolicyType {
	v := &ValidateSegmentPolicyType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["dst_segment_choice.dst_segments"] = ves_io_schema_views.SegmentRefListValidator().Validate

	v.FldValidators["src_segment_choice.src_segments"] = ves_io_schema_views.SegmentRefListValidator().Validate

	return v
}()

func SegmentPolicyTypeValidator() db.Validator {
	return DefaultSegmentPolicyTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ShapeBotBlockMitigationActionType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ShapeBotBlockMitigationActionType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ShapeBotBlockMitigationActionType) DeepCopy() *ShapeBotBlockMitigationActionType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ShapeBotBlockMitigationActionType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ShapeBotBlockMitigationActionType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ShapeBotBlockMitigationActionType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ShapeBotBlockMitigationActionTypeValidator().Validate(ctx, m, opts...)
}

type ValidateShapeBotBlockMitigationActionType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateShapeBotBlockMitigationActionType) StatusValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.HttpStatusCode)
		return int32(i)
	}
	// ves_io_schema.HttpStatusCode_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.HttpStatusCode_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for status")
	}

	return validatorFn, nil
}

func (v *ValidateShapeBotBlockMitigationActionType) BodyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for body")
	}

	return validatorFn, nil
}

func (v *ValidateShapeBotBlockMitigationActionType) BodyHashValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for body_hash")
	}

	return validatorFn, nil
}

func (v *ValidateShapeBotBlockMitigationActionType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ShapeBotBlockMitigationActionType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ShapeBotBlockMitigationActionType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["body"]; exists {

		vOpts := append(opts, db.WithValidateField("body"))
		if err := fv(ctx, m.GetBody(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["body_hash"]; exists {

		vOpts := append(opts, db.WithValidateField("body_hash"))
		if err := fv(ctx, m.GetBodyHash(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultShapeBotBlockMitigationActionTypeValidator = func() *ValidateShapeBotBlockMitigationActionType {
	v := &ValidateShapeBotBlockMitigationActionType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStatus := v.StatusValidationRuleHandler
	rulesStatus := map[string]string{
		"ves.io.schema.rules.enum.defined_only": "true",
		"ves.io.schema.rules.enum.not_in":       "[0]",
	}
	vFn, err = vrhStatus(rulesStatus)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotBlockMitigationActionType.status: %s", err)
		panic(errMsg)
	}
	v.FldValidators["status"] = vFn

	vrhBody := v.BodyValidationRuleHandler
	rulesBody := map[string]string{
		"ves.io.schema.rules.string.max_len": "4096",
		"ves.io.schema.rules.string.uri_ref": "true",
	}
	vFn, err = vrhBody(rulesBody)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotBlockMitigationActionType.body: %s", err)
		panic(errMsg)
	}
	v.FldValidators["body"] = vFn

	vrhBodyHash := v.BodyHashValidationRuleHandler
	rulesBodyHash := map[string]string{
		"ves.io.schema.rules.string.max_len": "32",
		"ves.io.schema.rules.string.min_len": "32",
	}
	vFn, err = vrhBodyHash(rulesBodyHash)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotBlockMitigationActionType.body_hash: %s", err)
		panic(errMsg)
	}
	v.FldValidators["body_hash"] = vFn

	return v
}()

func ShapeBotBlockMitigationActionTypeValidator() db.Validator {
	return DefaultShapeBotBlockMitigationActionTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ShapeBotFlagMitigationActionChoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ShapeBotFlagMitigationActionChoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ShapeBotFlagMitigationActionChoiceType) DeepCopy() *ShapeBotFlagMitigationActionChoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ShapeBotFlagMitigationActionChoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ShapeBotFlagMitigationActionChoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ShapeBotFlagMitigationActionChoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ShapeBotFlagMitigationActionChoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateShapeBotFlagMitigationActionChoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateShapeBotFlagMitigationActionChoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ShapeBotFlagMitigationActionChoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ShapeBotFlagMitigationActionChoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetSendHeadersChoice().(type) {
	case *ShapeBotFlagMitigationActionChoiceType_NoHeaders:
		if fv, exists := v.FldValidators["send_headers_choice.no_headers"]; exists {
			val := m.GetSendHeadersChoice().(*ShapeBotFlagMitigationActionChoiceType_NoHeaders).NoHeaders
			vOpts := append(opts,
				db.WithValidateField("send_headers_choice"),
				db.WithValidateField("no_headers"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ShapeBotFlagMitigationActionChoiceType_AppendHeaders:
		if fv, exists := v.FldValidators["send_headers_choice.append_headers"]; exists {
			val := m.GetSendHeadersChoice().(*ShapeBotFlagMitigationActionChoiceType_AppendHeaders).AppendHeaders
			vOpts := append(opts,
				db.WithValidateField("send_headers_choice"),
				db.WithValidateField("append_headers"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultShapeBotFlagMitigationActionChoiceTypeValidator = func() *ValidateShapeBotFlagMitigationActionChoiceType {
	v := &ValidateShapeBotFlagMitigationActionChoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["send_headers_choice.append_headers"] = ShapeBotFlagMitigationActionTypeValidator().Validate

	return v
}()

func ShapeBotFlagMitigationActionChoiceTypeValidator() db.Validator {
	return DefaultShapeBotFlagMitigationActionChoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ShapeBotFlagMitigationActionType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ShapeBotFlagMitigationActionType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ShapeBotFlagMitigationActionType) DeepCopy() *ShapeBotFlagMitigationActionType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ShapeBotFlagMitigationActionType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ShapeBotFlagMitigationActionType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ShapeBotFlagMitigationActionType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ShapeBotFlagMitigationActionTypeValidator().Validate(ctx, m, opts...)
}

type ValidateShapeBotFlagMitigationActionType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateShapeBotFlagMitigationActionType) InferenceHeaderNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inference_header_name")
	}

	return validatorFn, nil
}

func (v *ValidateShapeBotFlagMitigationActionType) AutoTypeHeaderNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for auto_type_header_name")
	}

	return validatorFn, nil
}

func (v *ValidateShapeBotFlagMitigationActionType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ShapeBotFlagMitigationActionType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ShapeBotFlagMitigationActionType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["auto_type_header_name"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_type_header_name"))
		if err := fv(ctx, m.GetAutoTypeHeaderName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inference_header_name"]; exists {

		vOpts := append(opts, db.WithValidateField("inference_header_name"))
		if err := fv(ctx, m.GetInferenceHeaderName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultShapeBotFlagMitigationActionTypeValidator = func() *ValidateShapeBotFlagMitigationActionType {
	v := &ValidateShapeBotFlagMitigationActionType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInferenceHeaderName := v.InferenceHeaderNameValidationRuleHandler
	rulesInferenceHeaderName := map[string]string{
		"ves.io.schema.rules.message.required":         "true",
		"ves.io.schema.rules.string.http_header_field": "true",
		"ves.io.schema.rules.string.max_bytes":         "256",
	}
	vFn, err = vrhInferenceHeaderName(rulesInferenceHeaderName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotFlagMitigationActionType.inference_header_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inference_header_name"] = vFn

	vrhAutoTypeHeaderName := v.AutoTypeHeaderNameValidationRuleHandler
	rulesAutoTypeHeaderName := map[string]string{
		"ves.io.schema.rules.message.required":         "true",
		"ves.io.schema.rules.string.http_header_field": "true",
		"ves.io.schema.rules.string.max_bytes":         "256",
	}
	vFn, err = vrhAutoTypeHeaderName(rulesAutoTypeHeaderName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotFlagMitigationActionType.auto_type_header_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["auto_type_header_name"] = vFn

	return v
}()

func ShapeBotFlagMitigationActionTypeValidator() db.Validator {
	return DefaultShapeBotFlagMitigationActionTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ShapeBotMitigationAction) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ShapeBotMitigationAction) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ShapeBotMitigationAction) DeepCopy() *ShapeBotMitigationAction {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ShapeBotMitigationAction{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ShapeBotMitigationAction) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ShapeBotMitigationAction) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ShapeBotMitigationActionValidator().Validate(ctx, m, opts...)
}

type ValidateShapeBotMitigationAction struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateShapeBotMitigationAction) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ShapeBotMitigationAction)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ShapeBotMitigationAction got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetActionType().(type) {
	case *ShapeBotMitigationAction_None:
		if fv, exists := v.FldValidators["action_type.none"]; exists {
			val := m.GetActionType().(*ShapeBotMitigationAction_None).None
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ShapeBotMitigationAction_Block:
		if fv, exists := v.FldValidators["action_type.block"]; exists {
			val := m.GetActionType().(*ShapeBotMitigationAction_Block).Block
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("block"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ShapeBotMitigationAction_Redirect:
		if fv, exists := v.FldValidators["action_type.redirect"]; exists {
			val := m.GetActionType().(*ShapeBotMitigationAction_Redirect).Redirect
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("redirect"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ShapeBotMitigationAction_Flag:
		if fv, exists := v.FldValidators["action_type.flag"]; exists {
			val := m.GetActionType().(*ShapeBotMitigationAction_Flag).Flag
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("flag"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultShapeBotMitigationActionValidator = func() *ValidateShapeBotMitigationAction {
	v := &ValidateShapeBotMitigationAction{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["action_type.block"] = ShapeBotBlockMitigationActionTypeValidator().Validate
	v.FldValidators["action_type.redirect"] = ShapeBotRedirectMitigationActionTypeValidator().Validate
	v.FldValidators["action_type.flag"] = ShapeBotFlagMitigationActionChoiceTypeValidator().Validate

	return v
}()

func ShapeBotMitigationActionValidator() db.Validator {
	return DefaultShapeBotMitigationActionValidator
}

// augmented methods on protoc/std generated struct

func (m *ShapeBotRedirectMitigationActionType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ShapeBotRedirectMitigationActionType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ShapeBotRedirectMitigationActionType) DeepCopy() *ShapeBotRedirectMitigationActionType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ShapeBotRedirectMitigationActionType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ShapeBotRedirectMitigationActionType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ShapeBotRedirectMitigationActionType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ShapeBotRedirectMitigationActionTypeValidator().Validate(ctx, m, opts...)
}

type ValidateShapeBotRedirectMitigationActionType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateShapeBotRedirectMitigationActionType) UriValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for uri")
	}

	return validatorFn, nil
}

func (v *ValidateShapeBotRedirectMitigationActionType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ShapeBotRedirectMitigationActionType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ShapeBotRedirectMitigationActionType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["uri"]; exists {

		vOpts := append(opts, db.WithValidateField("uri"))
		if err := fv(ctx, m.GetUri(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultShapeBotRedirectMitigationActionTypeValidator = func() *ValidateShapeBotRedirectMitigationActionType {
	v := &ValidateShapeBotRedirectMitigationActionType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhUri := v.UriValidationRuleHandler
	rulesUri := map[string]string{
		"ves.io.schema.rules.message.required":      "true",
		"ves.io.schema.rules.string.url_or_uri_ref": "true",
	}
	vFn, err = vrhUri(rulesUri)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotRedirectMitigationActionType.uri: %s", err)
		panic(errMsg)
	}
	v.FldValidators["uri"] = vFn

	return v
}()

func ShapeBotRedirectMitigationActionTypeValidator() db.Validator {
	return DefaultShapeBotRedirectMitigationActionTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ShapeProtectedEndpointAction) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ShapeProtectedEndpointAction) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ShapeProtectedEndpointAction) DeepCopy() *ShapeProtectedEndpointAction {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ShapeProtectedEndpointAction{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ShapeProtectedEndpointAction) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ShapeProtectedEndpointAction) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ShapeProtectedEndpointActionValidator().Validate(ctx, m, opts...)
}

type ValidateShapeProtectedEndpointAction struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateShapeProtectedEndpointAction) AppTrafficTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(AppTrafficType)
		return int32(i)
	}
	// AppTrafficType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, AppTrafficType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for app_traffic_type")
	}

	return validatorFn, nil
}

func (v *ValidateShapeProtectedEndpointAction) MitigationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for mitigation")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateShapeProtectedEndpointAction) WebScrapingValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewBoolValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for web_scraping")
	}

	return validatorFn, nil
}

func (v *ValidateShapeProtectedEndpointAction) FlowLabelValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for flow_label")
	}

	return validatorFn, nil
}

func (v *ValidateShapeProtectedEndpointAction) AllowGoodbotValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewBoolValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for allow_goodbot")
	}

	return validatorFn, nil
}

func (v *ValidateShapeProtectedEndpointAction) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ShapeProtectedEndpointAction)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ShapeProtectedEndpointAction got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["allow_goodbot"]; exists {

		vOpts := append(opts, db.WithValidateField("allow_goodbot"))
		if err := fv(ctx, m.GetAllowGoodbot(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["app_traffic_type"]; exists {

		vOpts := append(opts, db.WithValidateField("app_traffic_type"))
		if err := fv(ctx, m.GetAppTrafficType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["flow_label"]; exists {

		vOpts := append(opts, db.WithValidateField("flow_label"))
		if err := fv(ctx, m.GetFlowLabel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mitigation"]; exists {

		vOpts := append(opts, db.WithValidateField("mitigation"))
		if err := fv(ctx, m.GetMitigation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["transaction_result"]; exists {

		vOpts := append(opts, db.WithValidateField("transaction_result"))
		if err := fv(ctx, m.GetTransactionResult(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["web_scraping"]; exists {

		vOpts := append(opts, db.WithValidateField("web_scraping"))
		if err := fv(ctx, m.GetWebScraping(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultShapeProtectedEndpointActionValidator = func() *ValidateShapeProtectedEndpointAction {
	v := &ValidateShapeProtectedEndpointAction{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAppTrafficType := v.AppTrafficTypeValidationRuleHandler
	rulesAppTrafficType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAppTrafficType(rulesAppTrafficType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeProtectedEndpointAction.app_traffic_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["app_traffic_type"] = vFn

	vrhMitigation := v.MitigationValidationRuleHandler
	rulesMitigation := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMitigation(rulesMitigation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeProtectedEndpointAction.mitigation: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mitigation"] = vFn

	vrhWebScraping := v.WebScrapingValidationRuleHandler
	rulesWebScraping := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhWebScraping(rulesWebScraping)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeProtectedEndpointAction.web_scraping: %s", err)
		panic(errMsg)
	}
	v.FldValidators["web_scraping"] = vFn

	vrhFlowLabel := v.FlowLabelValidationRuleHandler
	rulesFlowLabel := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "128",
	}
	vFn, err = vrhFlowLabel(rulesFlowLabel)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeProtectedEndpointAction.flow_label: %s", err)
		panic(errMsg)
	}
	v.FldValidators["flow_label"] = vFn

	vrhAllowGoodbot := v.AllowGoodbotValidationRuleHandler
	rulesAllowGoodbot := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAllowGoodbot(rulesAllowGoodbot)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeProtectedEndpointAction.allow_goodbot: %s", err)
		panic(errMsg)
	}
	v.FldValidators["allow_goodbot"] = vFn

	v.FldValidators["transaction_result"] = ves_io_schema.BotDefenseTransactionResultTypeValidator().Validate

	return v
}()

func ShapeProtectedEndpointActionValidator() db.Validator {
	return DefaultShapeProtectedEndpointActionValidator
}

// augmented methods on protoc/std generated struct

func (m *SimpleDataGuardRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SimpleDataGuardRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SimpleDataGuardRule) DeepCopy() *SimpleDataGuardRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SimpleDataGuardRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SimpleDataGuardRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SimpleDataGuardRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SimpleDataGuardRuleValidator().Validate(ctx, m, opts...)
}

type ValidateSimpleDataGuardRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSimpleDataGuardRule) ActionChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for action_choice")
	}
	return validatorFn, nil
}

func (v *ValidateSimpleDataGuardRule) DomainChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_choice")
	}
	return validatorFn, nil
}

func (v *ValidateSimpleDataGuardRule) DomainChoiceExactValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ExactValue, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for exact_value")
	}
	return oValidatorFn_ExactValue, nil
}
func (v *ValidateSimpleDataGuardRule) DomainChoiceSuffixValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SuffixValue, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for suffix_value")
	}
	return oValidatorFn_SuffixValue, nil
}

func (v *ValidateSimpleDataGuardRule) PathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for path")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.PathMatcherTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSimpleDataGuardRule) MetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for metadata")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.MessageMetaTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSimpleDataGuardRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SimpleDataGuardRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SimpleDataGuardRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["action_choice"]; exists {
		val := m.GetActionChoice()
		vOpts := append(opts,
			db.WithValidateField("action_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetActionChoice().(type) {
	case *SimpleDataGuardRule_ApplyDataGuard:
		if fv, exists := v.FldValidators["action_choice.apply_data_guard"]; exists {
			val := m.GetActionChoice().(*SimpleDataGuardRule_ApplyDataGuard).ApplyDataGuard
			vOpts := append(opts,
				db.WithValidateField("action_choice"),
				db.WithValidateField("apply_data_guard"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SimpleDataGuardRule_SkipDataGuard:
		if fv, exists := v.FldValidators["action_choice.skip_data_guard"]; exists {
			val := m.GetActionChoice().(*SimpleDataGuardRule_SkipDataGuard).SkipDataGuard
			vOpts := append(opts,
				db.WithValidateField("action_choice"),
				db.WithValidateField("skip_data_guard"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["domain_choice"]; exists {
		val := m.GetDomainChoice()
		vOpts := append(opts,
			db.WithValidateField("domain_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDomainChoice().(type) {
	case *SimpleDataGuardRule_AnyDomain:
		if fv, exists := v.FldValidators["domain_choice.any_domain"]; exists {
			val := m.GetDomainChoice().(*SimpleDataGuardRule_AnyDomain).AnyDomain
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("any_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SimpleDataGuardRule_ExactValue:
		if fv, exists := v.FldValidators["domain_choice.exact_value"]; exists {
			val := m.GetDomainChoice().(*SimpleDataGuardRule_ExactValue).ExactValue
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("exact_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SimpleDataGuardRule_SuffixValue:
		if fv, exists := v.FldValidators["domain_choice.suffix_value"]; exists {
			val := m.GetDomainChoice().(*SimpleDataGuardRule_SuffixValue).SuffixValue
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("suffix_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSimpleDataGuardRuleValidator = func() *ValidateSimpleDataGuardRule {
	v := &ValidateSimpleDataGuardRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhActionChoice := v.ActionChoiceValidationRuleHandler
	rulesActionChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhActionChoice(rulesActionChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleDataGuardRule.action_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["action_choice"] = vFn

	vrhDomainChoice := v.DomainChoiceValidationRuleHandler
	rulesDomainChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDomainChoice(rulesDomainChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleDataGuardRule.domain_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_choice"] = vFn

	vrhDomainChoiceExactValue := v.DomainChoiceExactValueValidationRuleHandler
	rulesDomainChoiceExactValue := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
		"ves.io.schema.rules.string.max_len":  "256",
		"ves.io.schema.rules.string.min_len":  "1",
	}
	vFnMap["domain_choice.exact_value"], err = vrhDomainChoiceExactValue(rulesDomainChoiceExactValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field SimpleDataGuardRule.domain_choice_exact_value: %s", err)
		panic(errMsg)
	}
	vrhDomainChoiceSuffixValue := v.DomainChoiceSuffixValueValidationRuleHandler
	rulesDomainChoiceSuffixValue := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
		"ves.io.schema.rules.string.max_len":  "256",
		"ves.io.schema.rules.string.min_len":  "1",
	}
	vFnMap["domain_choice.suffix_value"], err = vrhDomainChoiceSuffixValue(rulesDomainChoiceSuffixValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field SimpleDataGuardRule.domain_choice_suffix_value: %s", err)
		panic(errMsg)
	}

	v.FldValidators["domain_choice.exact_value"] = vFnMap["domain_choice.exact_value"]
	v.FldValidators["domain_choice.suffix_value"] = vFnMap["domain_choice.suffix_value"]

	vrhPath := v.PathValidationRuleHandler
	rulesPath := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPath(rulesPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleDataGuardRule.path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["path"] = vFn

	vrhMetadata := v.MetadataValidationRuleHandler
	rulesMetadata := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMetadata(rulesMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleDataGuardRule.metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metadata"] = vFn

	return v
}()

func SimpleDataGuardRuleValidator() db.Validator {
	return DefaultSimpleDataGuardRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *SimpleWafExclusionRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SimpleWafExclusionRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SimpleWafExclusionRule) DeepCopy() *SimpleWafExclusionRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SimpleWafExclusionRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SimpleWafExclusionRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SimpleWafExclusionRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SimpleWafExclusionRuleValidator().Validate(ctx, m, opts...)
}

type ValidateSimpleWafExclusionRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSimpleWafExclusionRule) DomainChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_choice")
	}
	return validatorFn, nil
}

func (v *ValidateSimpleWafExclusionRule) DomainChoiceExactValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ExactValue, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for exact_value")
	}
	return oValidatorFn_ExactValue, nil
}
func (v *ValidateSimpleWafExclusionRule) DomainChoiceSuffixValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SuffixValue, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for suffix_value")
	}
	return oValidatorFn_SuffixValue, nil
}

func (v *ValidateSimpleWafExclusionRule) PathChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for path_choice")
	}
	return validatorFn, nil
}

func (v *ValidateSimpleWafExclusionRule) PathChoicePathRegexValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_PathRegex, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for path_regex")
	}
	return oValidatorFn_PathRegex, nil
}
func (v *ValidateSimpleWafExclusionRule) PathChoicePathPrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_PathPrefix, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for path_prefix")
	}
	return oValidatorFn_PathPrefix, nil
}

func (v *ValidateSimpleWafExclusionRule) WafAdvancedConfigurationAppFirewallDetectionControlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	return AppFirewallDetectionControlValidator().Validate, nil
}

func (v *ValidateSimpleWafExclusionRule) MethodsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.HttpMethod)
		return int32(i)
	}
	// ves_io_schema.HttpMethod_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, ves_io_schema.HttpMethod_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for methods")
	}
	itemsValidatorFn := func(ctx context.Context, elems []ves_io_schema.HttpMethod, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for methods")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]ves_io_schema.HttpMethod)
		if !ok {
			return fmt.Errorf("Repeated validation expected []ves_io_schema.HttpMethod, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated methods")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items methods")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSimpleWafExclusionRule) MetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for metadata")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.MessageMetaTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSimpleWafExclusionRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SimpleWafExclusionRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SimpleWafExclusionRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domain_choice"]; exists {
		val := m.GetDomainChoice()
		vOpts := append(opts,
			db.WithValidateField("domain_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDomainChoice().(type) {
	case *SimpleWafExclusionRule_AnyDomain:
		if fv, exists := v.FldValidators["domain_choice.any_domain"]; exists {
			val := m.GetDomainChoice().(*SimpleWafExclusionRule_AnyDomain).AnyDomain
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("any_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SimpleWafExclusionRule_ExactValue:
		if fv, exists := v.FldValidators["domain_choice.exact_value"]; exists {
			val := m.GetDomainChoice().(*SimpleWafExclusionRule_ExactValue).ExactValue
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("exact_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SimpleWafExclusionRule_SuffixValue:
		if fv, exists := v.FldValidators["domain_choice.suffix_value"]; exists {
			val := m.GetDomainChoice().(*SimpleWafExclusionRule_SuffixValue).SuffixValue
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("suffix_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["expiration_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("expiration_timestamp"))
		if err := fv(ctx, m.GetExpirationTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["methods"]; exists {
		vOpts := append(opts, db.WithValidateField("methods"))
		if err := fv(ctx, m.GetMethods(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path_choice"]; exists {
		val := m.GetPathChoice()
		vOpts := append(opts,
			db.WithValidateField("path_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPathChoice().(type) {
	case *SimpleWafExclusionRule_PathRegex:
		if fv, exists := v.FldValidators["path_choice.path_regex"]; exists {
			val := m.GetPathChoice().(*SimpleWafExclusionRule_PathRegex).PathRegex
			vOpts := append(opts,
				db.WithValidateField("path_choice"),
				db.WithValidateField("path_regex"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SimpleWafExclusionRule_AnyPath:
		if fv, exists := v.FldValidators["path_choice.any_path"]; exists {
			val := m.GetPathChoice().(*SimpleWafExclusionRule_AnyPath).AnyPath
			vOpts := append(opts,
				db.WithValidateField("path_choice"),
				db.WithValidateField("any_path"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SimpleWafExclusionRule_PathPrefix:
		if fv, exists := v.FldValidators["path_choice.path_prefix"]; exists {
			val := m.GetPathChoice().(*SimpleWafExclusionRule_PathPrefix).PathPrefix
			vOpts := append(opts,
				db.WithValidateField("path_choice"),
				db.WithValidateField("path_prefix"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetWafAdvancedConfiguration().(type) {
	case *SimpleWafExclusionRule_AppFirewallDetectionControl:
		if fv, exists := v.FldValidators["waf_advanced_configuration.app_firewall_detection_control"]; exists {
			val := m.GetWafAdvancedConfiguration().(*SimpleWafExclusionRule_AppFirewallDetectionControl).AppFirewallDetectionControl
			vOpts := append(opts,
				db.WithValidateField("waf_advanced_configuration"),
				db.WithValidateField("app_firewall_detection_control"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SimpleWafExclusionRule_WafSkipProcessing:
		if fv, exists := v.FldValidators["waf_advanced_configuration.waf_skip_processing"]; exists {
			val := m.GetWafAdvancedConfiguration().(*SimpleWafExclusionRule_WafSkipProcessing).WafSkipProcessing
			vOpts := append(opts,
				db.WithValidateField("waf_advanced_configuration"),
				db.WithValidateField("waf_skip_processing"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSimpleWafExclusionRuleValidator = func() *ValidateSimpleWafExclusionRule {
	v := &ValidateSimpleWafExclusionRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomainChoice := v.DomainChoiceValidationRuleHandler
	rulesDomainChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDomainChoice(rulesDomainChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleWafExclusionRule.domain_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_choice"] = vFn

	vrhDomainChoiceExactValue := v.DomainChoiceExactValueValidationRuleHandler
	rulesDomainChoiceExactValue := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
		"ves.io.schema.rules.string.max_len":  "256",
		"ves.io.schema.rules.string.min_len":  "1",
	}
	vFnMap["domain_choice.exact_value"], err = vrhDomainChoiceExactValue(rulesDomainChoiceExactValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field SimpleWafExclusionRule.domain_choice_exact_value: %s", err)
		panic(errMsg)
	}
	vrhDomainChoiceSuffixValue := v.DomainChoiceSuffixValueValidationRuleHandler
	rulesDomainChoiceSuffixValue := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
		"ves.io.schema.rules.string.max_len":  "256",
		"ves.io.schema.rules.string.min_len":  "1",
	}
	vFnMap["domain_choice.suffix_value"], err = vrhDomainChoiceSuffixValue(rulesDomainChoiceSuffixValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field SimpleWafExclusionRule.domain_choice_suffix_value: %s", err)
		panic(errMsg)
	}

	v.FldValidators["domain_choice.exact_value"] = vFnMap["domain_choice.exact_value"]
	v.FldValidators["domain_choice.suffix_value"] = vFnMap["domain_choice.suffix_value"]

	vrhPathChoice := v.PathChoiceValidationRuleHandler
	rulesPathChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPathChoice(rulesPathChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleWafExclusionRule.path_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["path_choice"] = vFn

	vrhPathChoicePathRegex := v.PathChoicePathRegexValidationRuleHandler
	rulesPathChoicePathRegex := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "256",
		"ves.io.schema.rules.string.regex":     "true",
	}
	vFnMap["path_choice.path_regex"], err = vrhPathChoicePathRegex(rulesPathChoicePathRegex)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field SimpleWafExclusionRule.path_choice_path_regex: %s", err)
		panic(errMsg)
	}
	vrhPathChoicePathPrefix := v.PathChoicePathPrefixValidationRuleHandler
	rulesPathChoicePathPrefix := map[string]string{
		"ves.io.schema.rules.string.http_path": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFnMap["path_choice.path_prefix"], err = vrhPathChoicePathPrefix(rulesPathChoicePathPrefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field SimpleWafExclusionRule.path_choice_path_prefix: %s", err)
		panic(errMsg)
	}

	v.FldValidators["path_choice.path_regex"] = vFnMap["path_choice.path_regex"]
	v.FldValidators["path_choice.path_prefix"] = vFnMap["path_choice.path_prefix"]

	vrhWafAdvancedConfigurationAppFirewallDetectionControl := v.WafAdvancedConfigurationAppFirewallDetectionControlValidationRuleHandler
	rulesWafAdvancedConfigurationAppFirewallDetectionControl := map[string]string{
		"ves.io.schema.rules.message.required_one_nonzero_field": "true",
	}
	vFnMap["waf_advanced_configuration.app_firewall_detection_control"], err = vrhWafAdvancedConfigurationAppFirewallDetectionControl(rulesWafAdvancedConfigurationAppFirewallDetectionControl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field SimpleWafExclusionRule.waf_advanced_configuration_app_firewall_detection_control: %s", err)
		panic(errMsg)
	}

	v.FldValidators["waf_advanced_configuration.app_firewall_detection_control"] = vFnMap["waf_advanced_configuration.app_firewall_detection_control"]

	vrhMethods := v.MethodsValidationRuleHandler
	rulesMethods := map[string]string{
		"ves.io.schema.rules.repeated.items.enum.defined_only": "true",
		"ves.io.schema.rules.repeated.max_items":               "16",
		"ves.io.schema.rules.repeated.unique":                  "true",
	}
	vFn, err = vrhMethods(rulesMethods)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleWafExclusionRule.methods: %s", err)
		panic(errMsg)
	}
	v.FldValidators["methods"] = vFn

	vrhMetadata := v.MetadataValidationRuleHandler
	rulesMetadata := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMetadata(rulesMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleWafExclusionRule.metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metadata"] = vFn

	return v
}()

func SimpleWafExclusionRuleValidator() db.Validator {
	return DefaultSimpleWafExclusionRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *StringMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StringMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StringMatcherType) DeepCopy() *StringMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StringMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StringMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StringMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StringMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateStringMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStringMatcherType) MatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for match")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for match")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated match")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items match")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateStringMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StringMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StringMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["match"]; exists {
		vOpts := append(opts, db.WithValidateField("match"))
		if err := fv(ctx, m.GetMatch(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStringMatcherTypeValidator = func() *ValidateStringMatcherType {
	v := &ValidateStringMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMatch := v.MatchValidationRuleHandler
	rulesMatch := map[string]string{
		"ves.io.schema.rules.message.required":                "true",
		"ves.io.schema.rules.repeated.items.string.max_bytes": "63",
		"ves.io.schema.rules.repeated.max_items":              "64",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhMatch(rulesMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StringMatcherType.match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["match"] = vFn

	return v
}()

func StringMatcherTypeValidator() db.Validator {
	return DefaultStringMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TlsFingerprintMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TlsFingerprintMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TlsFingerprintMatcherType) DeepCopy() *TlsFingerprintMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TlsFingerprintMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TlsFingerprintMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TlsFingerprintMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TlsFingerprintMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateTlsFingerprintMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTlsFingerprintMatcherType) ClassesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(KnownTlsFingerprintClass)
		return int32(i)
	}
	// KnownTlsFingerprintClass_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, KnownTlsFingerprintClass_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for classes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []KnownTlsFingerprintClass, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for classes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]KnownTlsFingerprintClass)
		if !ok {
			return fmt.Errorf("Repeated validation expected []KnownTlsFingerprintClass, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated classes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items classes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateTlsFingerprintMatcherType) ExactValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for exact_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exact_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exact_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exact_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateTlsFingerprintMatcherType) ExcludedValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for excluded_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for excluded_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated excluded_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items excluded_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateTlsFingerprintMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TlsFingerprintMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TlsFingerprintMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["classes"]; exists {
		vOpts := append(opts, db.WithValidateField("classes"))
		if err := fv(ctx, m.GetClasses(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["exact_values"]; exists {
		vOpts := append(opts, db.WithValidateField("exact_values"))
		if err := fv(ctx, m.GetExactValues(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["excluded_values"]; exists {
		vOpts := append(opts, db.WithValidateField("excluded_values"))
		if err := fv(ctx, m.GetExcludedValues(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTlsFingerprintMatcherTypeValidator = func() *ValidateTlsFingerprintMatcherType {
	v := &ValidateTlsFingerprintMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhClasses := v.ClassesValidationRuleHandler
	rulesClasses := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhClasses(rulesClasses)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TlsFingerprintMatcherType.classes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["classes"] = vFn

	vrhExactValues := v.ExactValuesValidationRuleHandler
	rulesExactValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.len": "32",
		"ves.io.schema.rules.repeated.max_items":        "16",
		"ves.io.schema.rules.repeated.unique":           "true",
	}
	vFn, err = vrhExactValues(rulesExactValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TlsFingerprintMatcherType.exact_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exact_values"] = vFn

	vrhExcludedValues := v.ExcludedValuesValidationRuleHandler
	rulesExcludedValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.len": "32",
		"ves.io.schema.rules.repeated.max_items":        "32",
		"ves.io.schema.rules.repeated.unique":           "true",
	}
	vFn, err = vrhExcludedValues(rulesExcludedValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TlsFingerprintMatcherType.excluded_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["excluded_values"] = vFn

	return v
}()

func TlsFingerprintMatcherTypeValidator() db.Validator {
	return DefaultTlsFingerprintMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *URLItem) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *URLItem) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *URLItem) DeepCopy() *URLItem {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &URLItem{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *URLItem) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *URLItem) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return URLItemValidator().Validate(ctx, m, opts...)
}

type ValidateURLItem struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateURLItem) DomainChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_choice")
	}
	return validatorFn, nil
}

func (v *ValidateURLItem) DomainChoiceDomainValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_DomainValue, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_value")
	}
	return oValidatorFn_DomainValue, nil
}
func (v *ValidateURLItem) DomainChoiceDomainRegexValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_DomainRegex, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_regex")
	}
	return oValidatorFn_DomainRegex, nil
}

func (v *ValidateURLItem) PathChoicePathValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_PathValue, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for path_value")
	}
	return oValidatorFn_PathValue, nil
}
func (v *ValidateURLItem) PathChoicePathRegexValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_PathRegex, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for path_regex")
	}
	return oValidatorFn_PathRegex, nil
}
func (v *ValidateURLItem) PathChoicePathPrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_PathPrefix, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for path_prefix")
	}
	return oValidatorFn_PathPrefix, nil
}

func (v *ValidateURLItem) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*URLItem)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *URLItem got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domain_choice"]; exists {
		val := m.GetDomainChoice()
		vOpts := append(opts,
			db.WithValidateField("domain_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDomainChoice().(type) {
	case *URLItem_DomainValue:
		if fv, exists := v.FldValidators["domain_choice.domain_value"]; exists {
			val := m.GetDomainChoice().(*URLItem_DomainValue).DomainValue
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("domain_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *URLItem_DomainRegex:
		if fv, exists := v.FldValidators["domain_choice.domain_regex"]; exists {
			val := m.GetDomainChoice().(*URLItem_DomainRegex).DomainRegex
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("domain_regex"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetPathChoice().(type) {
	case *URLItem_PathValue:
		if fv, exists := v.FldValidators["path_choice.path_value"]; exists {
			val := m.GetPathChoice().(*URLItem_PathValue).PathValue
			vOpts := append(opts,
				db.WithValidateField("path_choice"),
				db.WithValidateField("path_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *URLItem_PathRegex:
		if fv, exists := v.FldValidators["path_choice.path_regex"]; exists {
			val := m.GetPathChoice().(*URLItem_PathRegex).PathRegex
			vOpts := append(opts,
				db.WithValidateField("path_choice"),
				db.WithValidateField("path_regex"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *URLItem_PathPrefix:
		if fv, exists := v.FldValidators["path_choice.path_prefix"]; exists {
			val := m.GetPathChoice().(*URLItem_PathPrefix).PathPrefix
			vOpts := append(opts,
				db.WithValidateField("path_choice"),
				db.WithValidateField("path_prefix"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultURLItemValidator = func() *ValidateURLItem {
	v := &ValidateURLItem{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomainChoice := v.DomainChoiceValidationRuleHandler
	rulesDomainChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDomainChoice(rulesDomainChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for URLItem.domain_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_choice"] = vFn

	vrhDomainChoiceDomainValue := v.DomainChoiceDomainValueValidationRuleHandler
	rulesDomainChoiceDomainValue := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
	}
	vFnMap["domain_choice.domain_value"], err = vrhDomainChoiceDomainValue(rulesDomainChoiceDomainValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field URLItem.domain_choice_domain_value: %s", err)
		panic(errMsg)
	}
	vrhDomainChoiceDomainRegex := v.DomainChoiceDomainRegexValidationRuleHandler
	rulesDomainChoiceDomainRegex := map[string]string{
		"ves.io.schema.rules.string.regex": "true",
	}
	vFnMap["domain_choice.domain_regex"], err = vrhDomainChoiceDomainRegex(rulesDomainChoiceDomainRegex)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field URLItem.domain_choice_domain_regex: %s", err)
		panic(errMsg)
	}

	v.FldValidators["domain_choice.domain_value"] = vFnMap["domain_choice.domain_value"]
	v.FldValidators["domain_choice.domain_regex"] = vFnMap["domain_choice.domain_regex"]

	vrhPathChoicePathValue := v.PathChoicePathValueValidationRuleHandler
	rulesPathChoicePathValue := map[string]string{
		"ves.io.schema.rules.string.http_path": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFnMap["path_choice.path_value"], err = vrhPathChoicePathValue(rulesPathChoicePathValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field URLItem.path_choice_path_value: %s", err)
		panic(errMsg)
	}
	vrhPathChoicePathRegex := v.PathChoicePathRegexValidationRuleHandler
	rulesPathChoicePathRegex := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.regex":   "true",
	}
	vFnMap["path_choice.path_regex"], err = vrhPathChoicePathRegex(rulesPathChoicePathRegex)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field URLItem.path_choice_path_regex: %s", err)
		panic(errMsg)
	}
	vrhPathChoicePathPrefix := v.PathChoicePathPrefixValidationRuleHandler
	rulesPathChoicePathPrefix := map[string]string{
		"ves.io.schema.rules.string.http_path": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFnMap["path_choice.path_prefix"], err = vrhPathChoicePathPrefix(rulesPathChoicePathPrefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field URLItem.path_choice_path_prefix: %s", err)
		panic(errMsg)
	}

	v.FldValidators["path_choice.path_value"] = vFnMap["path_choice.path_value"]
	v.FldValidators["path_choice.path_regex"] = vFnMap["path_choice.path_regex"]
	v.FldValidators["path_choice.path_prefix"] = vFnMap["path_choice.path_prefix"]

	return v
}()

func URLItemValidator() db.Validator {
	return DefaultURLItemValidator
}

// augmented methods on protoc/std generated struct

func (m *URLMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *URLMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *URLMatcherType) DeepCopy() *URLMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &URLMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *URLMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *URLMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return URLMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateURLMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateURLMatcherType) UrlItemsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for url_items")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*URLItem, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := URLItemValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for url_items")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*URLItem)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*URLItem, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated url_items")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items url_items")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateURLMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*URLMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *URLMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_matcher"))
		if err := fv(ctx, m.GetInvertMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["url_items"]; exists {
		vOpts := append(opts, db.WithValidateField("url_items"))
		if err := fv(ctx, m.GetUrlItems(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultURLMatcherTypeValidator = func() *ValidateURLMatcherType {
	v := &ValidateURLMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhUrlItems := v.UrlItemsValidationRuleHandler
	rulesUrlItems := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhUrlItems(rulesUrlItems)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for URLMatcherType.url_items: %s", err)
		panic(errMsg)
	}
	v.FldValidators["url_items"] = vFn

	return v
}()

func URLMatcherTypeValidator() db.Validator {
	return DefaultURLMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *WafAction) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WafAction) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WafAction) DeepCopy() *WafAction {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WafAction{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WafAction) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WafAction) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WafActionValidator().Validate(ctx, m, opts...)
}

type ValidateWafAction struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWafAction) ActionTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for action_type")
	}
	return validatorFn, nil
}

func (v *ValidateWafAction) ActionTypeAppFirewallDetectionControlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	return AppFirewallDetectionControlValidator().Validate, nil
}

func (v *ValidateWafAction) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WafAction)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WafAction got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["action_type"]; exists {
		val := m.GetActionType()
		vOpts := append(opts,
			db.WithValidateField("action_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetActionType().(type) {
	case *WafAction_WafSkipProcessing:
		if fv, exists := v.FldValidators["action_type.waf_skip_processing"]; exists {
			val := m.GetActionType().(*WafAction_WafSkipProcessing).WafSkipProcessing
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("waf_skip_processing"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WafAction_None:
		if fv, exists := v.FldValidators["action_type.none"]; exists {
			val := m.GetActionType().(*WafAction_None).None
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WafAction_WafInMonitoringMode:
		if fv, exists := v.FldValidators["action_type.waf_in_monitoring_mode"]; exists {
			val := m.GetActionType().(*WafAction_WafInMonitoringMode).WafInMonitoringMode
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("waf_in_monitoring_mode"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WafAction_AppFirewallDetectionControl:
		if fv, exists := v.FldValidators["action_type.app_firewall_detection_control"]; exists {
			val := m.GetActionType().(*WafAction_AppFirewallDetectionControl).AppFirewallDetectionControl
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("app_firewall_detection_control"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WafAction_DataGuardControl:
		if fv, exists := v.FldValidators["action_type.data_guard_control"]; exists {
			val := m.GetActionType().(*WafAction_DataGuardControl).DataGuardControl
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("data_guard_control"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WafAction_JwtValidation:
		if fv, exists := v.FldValidators["action_type.jwt_validation"]; exists {
			val := m.GetActionType().(*WafAction_JwtValidation).JwtValidation
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("jwt_validation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WafAction_JwtClaimsValidation:
		if fv, exists := v.FldValidators["action_type.jwt_claims_validation"]; exists {
			val := m.GetActionType().(*WafAction_JwtClaimsValidation).JwtClaimsValidation
			vOpts := append(opts,
				db.WithValidateField("action_type"),
				db.WithValidateField("jwt_claims_validation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWafActionValidator = func() *ValidateWafAction {
	v := &ValidateWafAction{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhActionType := v.ActionTypeValidationRuleHandler
	rulesActionType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhActionType(rulesActionType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WafAction.action_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["action_type"] = vFn

	vrhActionTypeAppFirewallDetectionControl := v.ActionTypeAppFirewallDetectionControlValidationRuleHandler
	rulesActionTypeAppFirewallDetectionControl := map[string]string{
		"ves.io.schema.rules.message.required_one_nonzero_field": "true",
	}
	vFnMap["action_type.app_firewall_detection_control"], err = vrhActionTypeAppFirewallDetectionControl(rulesActionTypeAppFirewallDetectionControl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field WafAction.action_type_app_firewall_detection_control: %s", err)
		panic(errMsg)
	}

	v.FldValidators["action_type.app_firewall_detection_control"] = vFnMap["action_type.app_firewall_detection_control"]

	return v
}()

func WafActionValidator() db.Validator {
	return DefaultWafActionValidator
}

// create setters in HeaderMatcherTypeBasic from HeaderMatcherType for oneof fields
func (r *HeaderMatcherTypeBasic) SetMatchToHeaderMatcherType(o *HeaderMatcherType) error {
	switch of := r.Match.(type) {
	case nil:
		o.Match = nil

	case *HeaderMatcherTypeBasic_CheckNotPresent:
		o.Match = &HeaderMatcherType_CheckNotPresent{CheckNotPresent: of.CheckNotPresent}

	case *HeaderMatcherTypeBasic_CheckPresent:
		o.Match = &HeaderMatcherType_CheckPresent{CheckPresent: of.CheckPresent}

	case *HeaderMatcherTypeBasic_Item:
		o.Match = &HeaderMatcherType_Item{Item: of.Item}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *HeaderMatcherTypeBasic) GetMatchFromHeaderMatcherType(o *HeaderMatcherType) error {
	switch of := o.Match.(type) {
	case nil:
		r.Match = nil

	case *HeaderMatcherType_CheckNotPresent:
		r.Match = &HeaderMatcherTypeBasic_CheckNotPresent{CheckNotPresent: of.CheckNotPresent}

	case *HeaderMatcherType_CheckPresent:
		r.Match = &HeaderMatcherTypeBasic_CheckPresent{CheckPresent: of.CheckPresent}

	case *HeaderMatcherType_Item:
		r.Match = &HeaderMatcherTypeBasic_Item{Item: of.Item}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *HeaderMatcherTypeBasic) fromHeaderMatcherType(f *HeaderMatcherType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.GetMatchFromHeaderMatcherType(f)
	m.Name = f.GetName()
}

func (m *HeaderMatcherTypeBasic) FromHeaderMatcherType(f *HeaderMatcherType) {
	m.fromHeaderMatcherType(f, true)
}

func (m *HeaderMatcherTypeBasic) FromHeaderMatcherTypeWithoutDeepCopy(f *HeaderMatcherType) {
	m.fromHeaderMatcherType(f, false)
}

func (m *HeaderMatcherTypeBasic) toHeaderMatcherType(f *HeaderMatcherType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	m1.SetMatchToHeaderMatcherType(f)
	f.Name = m1.Name
}

func (m *HeaderMatcherTypeBasic) ToHeaderMatcherType(f *HeaderMatcherType) {
	m.toHeaderMatcherType(f, true)
}

func (m *HeaderMatcherTypeBasic) ToHeaderMatcherTypeWithoutDeepCopy(f *HeaderMatcherType) {
	m.toHeaderMatcherType(f, false)
}

func (m *MatcherTypeBasic) fromMatcherType(f *MatcherType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.ExactValues = f.GetExactValues()
	m.RegexValues = f.GetRegexValues()
}

func (m *MatcherTypeBasic) FromMatcherType(f *MatcherType) {
	m.fromMatcherType(f, true)
}

func (m *MatcherTypeBasic) FromMatcherTypeWithoutDeepCopy(f *MatcherType) {
	m.fromMatcherType(f, false)
}

func (m *MatcherTypeBasic) toMatcherType(f *MatcherType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.ExactValues = m1.ExactValues
	f.RegexValues = m1.RegexValues
}

func (m *MatcherTypeBasic) ToMatcherType(f *MatcherType) {
	m.toMatcherType(f, true)
}

func (m *MatcherTypeBasic) ToMatcherTypeWithoutDeepCopy(f *MatcherType) {
	m.toMatcherType(f, false)
}
