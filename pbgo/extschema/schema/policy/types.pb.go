// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/policy/types.proto

package policy

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	waf_rule_list "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/waf_rule_list"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// PolicySetType
//
// x-displayName: "Policy Set Type"
// The type a policy set indicates it's purpose.
// The primary use of the type is to determine the relative order of evaluation when there are multiple policy sets in a namespace. For example, a rate limiting
// policy set is evaluated before a network security policy set. The type is also used to enforce constraints on the action in rules that are part of the policy
// set. For example, a rate limiting policy set cannot contain a rule with an ALLOW or DENY action - the only valid actions are NEXT_POLICY and NEXT_POLICY_SET.
//
// - NETWORK_SECURITY Policy Set is used to apply L7 security to API requests
// - RATE_LIMITING Policy Set is used to rate limit API requests
type PolicySetType int32

const (
	// Network Security
	//
	// x-displayName: "Policy Set for Network Security"
	// Policy Set is used to apply L7 security to API requests
	NETWORK_SECURITY PolicySetType = 0
	// Rate Limiting
	//
	// x-displayName: "Policy Set for Rate Limiting"
	// Policy Set is used to rate limit API requests
	RATE_LIMITING PolicySetType = 1
	// Policy Based Routing
	//
	// x-displayName: "Policy Set for Policy Based Routing"
	// Policy Set is used to perform policy based routing
	POLICY_BASED_ROUTING PolicySetType = 2
	// WAF Exclusion
	//
	// x-displayName: "Policy Set for WAF Exclusion"
	// Policy Set is used to exclude WAF rules that result in false positives in the WAF module
	WAF_EXCLUSION PolicySetType = 3
)

var PolicySetType_name = map[int32]string{
	0: "NETWORK_SECURITY",
	1: "RATE_LIMITING",
	2: "POLICY_BASED_ROUTING",
	3: "WAF_EXCLUSION",
}

var PolicySetType_value = map[string]int32{
	"NETWORK_SECURITY":     0,
	"RATE_LIMITING":        1,
	"POLICY_BASED_ROUTING": 2,
	"WAF_EXCLUSION":        3,
}

func (PolicySetType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{0}
}

// PolicySetScope
//
// x-displayName: "Policy Set Scope"
// The scope of a policy set. This could be per namespace or per virtual host.
type PolicySetScope int32

const (
	// per namespace
	//
	// x-displayName: "Policy Set for Namespace"
	// Policy Set is used for the entire namespace.
	POLICY_SET_SCOPE_NAMESPACE PolicySetScope = 0
	// per virtual host
	//
	// x-displayName: "Policy Set for Namespace"
	// Policy Set is used for a specific virtual host.
	POLICY_SET_SCOPE_VIRTUAL_HOST PolicySetScope = 1
)

var PolicySetScope_name = map[int32]string{
	0: "POLICY_SET_SCOPE_NAMESPACE",
	1: "POLICY_SET_SCOPE_VIRTUAL_HOST",
}

var PolicySetScope_value = map[string]int32{
	"POLICY_SET_SCOPE_NAMESPACE":    0,
	"POLICY_SET_SCOPE_VIRTUAL_HOST": 1,
}

func (PolicySetScope) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{1}
}

// RuleCombiningAlgorithm
//
// x-displayName: "Rule Combining Algorithm"
// The rule combining algorithm for a policy determines how the list of rules in the policy is evaluated.
// If any of the rules is configured with a App Firewall action, the rule combining algorithm must be configured to be FIRST_MATCH.
//
// - FIRST_MATCH Rules are evaluated sequentially till a matching rule is identified
// - ALLOW_OVERRIDES Rules with an ALLOW action are evaluated prior to rules with a DENY action
// - DENY_OVERRIDES Rules with a DENY action are evaluated prior to rules with an ALLOW action
type RuleCombiningAlgorithm int32

const (
	// First Match
	//
	// x-displayName: "First Rule Match"
	// Rules are evaluated sequentially till a matching rule is identified
	FIRST_MATCH RuleCombiningAlgorithm = 0
	// Deny Overrides
	//
	// x-displayName: "Deny Rule Overrides"
	// Rules with a DENY action are evaluated prior to rules with an ALLOW action
	DENY_OVERRIDES RuleCombiningAlgorithm = 1
	// Allow Overrides
	//
	// x-displayName: "Allow Rule Overrides"
	// Rules with an ALLOW action are evaluated prior to rules with a DENY action
	ALLOW_OVERRIDES RuleCombiningAlgorithm = 2
)

var RuleCombiningAlgorithm_name = map[int32]string{
	0: "FIRST_MATCH",
	1: "DENY_OVERRIDES",
	2: "ALLOW_OVERRIDES",
}

var RuleCombiningAlgorithm_value = map[string]int32{
	"FIRST_MATCH":     0,
	"DENY_OVERRIDES":  1,
	"ALLOW_OVERRIDES": 2,
}

func (RuleCombiningAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{2}
}

// Transformer
//
// x-displayName: "Transformer"
// Transformers to be applied on the part of the request before matching.
type Transformer int32

const (
	// transformer none
	//
	// x-displayName: "Transformer None"
	// No transformers enabled
	TRANSFORMER_NONE Transformer = 0
	// lower case
	//
	// x-displayName: "Lower Case"
	// Convert string to lower case
	LOWER_CASE Transformer = 1
	// upper case
	//
	// x-displayName: "Upper Case"
	// Convert string to upper case
	UPPER_CASE Transformer = 2
	// base64 decode
	//
	// x-displayName: "Base64 Decode"
	// Decode string assuming base64 encoding
	BASE64_DECODE Transformer = 3
	// normalize path
	//
	// x-displayName: "Normalize Path"
	// Normalize URL path so that /a/b/../c will be transformed to /a/c
	NORMALIZE_PATH Transformer = 4
	// remove whitespace
	//
	// x-displayName: "Remove Whitespace"
	// Remove whitespaces
	REMOVE_WHITESPACE Transformer = 5
	// URL decode
	//
	// x-displayName: "URL Decode"
	// Decode string assuming URL encoding as per rfc1738
	URL_DECODE Transformer = 6
	// trim left
	//
	// x-displayName: "Trim Left"
	// Remove whitespace from the left side of the input string
	TRIM_LEFT Transformer = 7
	// trim right
	//
	// x-displayName: "Trim Right"
	// Remove whitespace from the right side of the input string
	TRIM_RIGHT Transformer = 8
	// trim
	//
	// x-displayName: "Trim"
	// Remove whitespace from the both sides of the input string
	TRIM Transformer = 9
)

var Transformer_name = map[int32]string{
	0: "TRANSFORMER_NONE",
	1: "LOWER_CASE",
	2: "UPPER_CASE",
	3: "BASE64_DECODE",
	4: "NORMALIZE_PATH",
	5: "REMOVE_WHITESPACE",
	6: "URL_DECODE",
	7: "TRIM_LEFT",
	8: "TRIM_RIGHT",
	9: "TRIM",
}

var Transformer_value = map[string]int32{
	"TRANSFORMER_NONE":  0,
	"LOWER_CASE":        1,
	"UPPER_CASE":        2,
	"BASE64_DECODE":     3,
	"NORMALIZE_PATH":    4,
	"REMOVE_WHITESPACE": 5,
	"URL_DECODE":        6,
	"TRIM_LEFT":         7,
	"TRIM_RIGHT":        8,
	"TRIM":              9,
}

func (Transformer) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{3}
}

// TLS known fingerprint class
//
// x-displayName: "TLS known fingerprint class"
// Specifies known TLS fingerprint classes
type KnownTlsFingerprintClass int32

const (
	// TLS_FINGERPRINT_NONE
	//
	// x-displayName: "TLS Fingerprint None"
	// No TLS fingerprint
	TLS_FINGERPRINT_NONE KnownTlsFingerprintClass = 0
	// ANY_MALICIOUS_FINGERPRINT
	//
	// x-displayName: "Any Known Malicious Fingerprint"
	// TLS fingerprints known to be associated with malicious clients
	ANY_MALICIOUS_FINGERPRINT KnownTlsFingerprintClass = 1
	// ADWARE
	//
	// x-displayName: "ADWARE"
	// TLS fingerprints known to be associated with adware
	ADWARE KnownTlsFingerprintClass = 2
	// ADWIND
	//
	// x-displayName: "ADWIND"
	// TLS fingerprints known to be associated with adwind
	ADWIND KnownTlsFingerprintClass = 3
	// DRIDEX
	//
	// x-displayName: "DRIDEX"
	// TLS fingerprints known to be associated with dridex
	DRIDEX KnownTlsFingerprintClass = 4
	// GOOTKIT
	//
	// x-displayName: "GOOTKIT"
	// TLS fingerprints known to be associated with gootkit
	GOOTKIT KnownTlsFingerprintClass = 5
	// GOZI
	//
	// x-displayName: "GOZI"
	// TLS fingerprints known to be associated with gozi
	GOZI KnownTlsFingerprintClass = 6
	// JBIFROST
	//
	// x-displayName: "JBIFROST"
	// TLS fingerprints known to be associated with jbifrost
	JBIFROST KnownTlsFingerprintClass = 7
	// QUAKBOT
	//
	// x-displayName: "QUAKBOT"
	// TLS fingerprints known to be associated with quakbot
	QUAKBOT KnownTlsFingerprintClass = 8
	// RANSOMWARE
	//
	// x-displayName: "RANSOMWARE"
	// TLS fingerprints known to be associated with ransomware
	RANSOMWARE KnownTlsFingerprintClass = 9
	// TROLDESH
	//
	// x-displayName: "TROLDESH"
	// TLS fingerprints known to be associated with troldesh
	TROLDESH KnownTlsFingerprintClass = 10
	// TOFSEE
	//
	// x-displayName: "TOFSEE"
	// TLS fingerprints known to be associated with tofsee
	TOFSEE KnownTlsFingerprintClass = 11
	// TORRENTLOCKER
	//
	// x-displayName: "TORRENTLOCKER"
	// TLS fingerprints known to be associated with torrentlocker
	TORRENTLOCKER KnownTlsFingerprintClass = 12
	// TRICKBOT
	//
	// x-displayName: "TRICKBOT"
	// TLS fingerprints known to be associated with trickbot
	TRICKBOT KnownTlsFingerprintClass = 13
)

var KnownTlsFingerprintClass_name = map[int32]string{
	0:  "TLS_FINGERPRINT_NONE",
	1:  "ANY_MALICIOUS_FINGERPRINT",
	2:  "ADWARE",
	3:  "ADWIND",
	4:  "DRIDEX",
	5:  "GOOTKIT",
	6:  "GOZI",
	7:  "JBIFROST",
	8:  "QUAKBOT",
	9:  "RANSOMWARE",
	10: "TROLDESH",
	11: "TOFSEE",
	12: "TORRENTLOCKER",
	13: "TRICKBOT",
}

var KnownTlsFingerprintClass_value = map[string]int32{
	"TLS_FINGERPRINT_NONE":      0,
	"ANY_MALICIOUS_FINGERPRINT": 1,
	"ADWARE":                    2,
	"ADWIND":                    3,
	"DRIDEX":                    4,
	"GOOTKIT":                   5,
	"GOZI":                      6,
	"JBIFROST":                  7,
	"QUAKBOT":                   8,
	"RANSOMWARE":                9,
	"TROLDESH":                  10,
	"TOFSEE":                    11,
	"TORRENTLOCKER":             12,
	"TRICKBOT":                  13,
}

func (KnownTlsFingerprintClass) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{4}
}

// CountryCode
//
// x-displayName: "Country Code"
// ISO 3166 Aplpha-2 country codes
type CountryCode int32

const (
	// x-displayName: "None"
	COUNTRY_NONE CountryCode = 0
	// x-displayName: "Andorra"
	COUNTRY_AD CountryCode = 1
	// x-displayName: "United Arab Emirates"
	COUNTRY_AE CountryCode = 2
	// x-displayName: "Afghanistan"
	COUNTRY_AF CountryCode = 3
	// x-displayName: "Antigua and Barbuda"
	COUNTRY_AG CountryCode = 4
	// x-displayName: "Anguilla"
	COUNTRY_AI CountryCode = 5
	// x-displayName: "Albania"
	COUNTRY_AL CountryCode = 6
	// x-displayName: "Armenia"
	COUNTRY_AM CountryCode = 7
	// x-displayName: "Netherlands Antilles"
	COUNTRY_AN CountryCode = 8
	// x-displayName: "Angola"
	COUNTRY_AO CountryCode = 9
	// x-displayName: "Antarctica"
	COUNTRY_AQ CountryCode = 10
	// x-displayName: "Argentina"
	COUNTRY_AR CountryCode = 11
	// x-displayName: "American Samoa"
	COUNTRY_AS CountryCode = 12
	// x-displayName: "Austria"
	COUNTRY_AT CountryCode = 13
	// x-displayName: "Australia"
	COUNTRY_AU CountryCode = 14
	// x-displayName: "Aruba"
	COUNTRY_AW CountryCode = 15
	// x-displayName: "Aland Islands"
	COUNTRY_AX CountryCode = 16
	// x-displayName: "Azerbaijan"
	COUNTRY_AZ CountryCode = 17
	// x-displayName: "Bosnia and Herzegovina"
	COUNTRY_BA CountryCode = 18
	// x-displayName: "Barbados"
	COUNTRY_BB CountryCode = 19
	// x-displayName: "Bangladesh"
	COUNTRY_BD CountryCode = 20
	// x-displayName: "Belgium"
	COUNTRY_BE CountryCode = 21
	// x-displayName: "Burkina Faso"
	COUNTRY_BF CountryCode = 22
	// x-displayName: "Bulgaria"
	COUNTRY_BG CountryCode = 23
	// x-displayName: "Bahrain"
	COUNTRY_BH CountryCode = 24
	// x-displayName: "Burundi"
	COUNTRY_BI CountryCode = 25
	// x-displayName: "Benin"
	COUNTRY_BJ CountryCode = 26
	// x-displayName: "Saint Barthelemy"
	COUNTRY_BL CountryCode = 27
	// x-displayName: "Bermuda"
	COUNTRY_BM CountryCode = 28
	// x-displayName: "Brunei Darussalam"
	COUNTRY_BN CountryCode = 29
	// x-displayName: "Bolivia"
	COUNTRY_BO CountryCode = 30
	// x-displayName: "Saint Eustatius and Saba Bonaire"
	COUNTRY_BQ CountryCode = 31
	// x-displayName: "Brazil"
	COUNTRY_BR CountryCode = 32
	// x-displayName: "Bahamas"
	COUNTRY_BS CountryCode = 33
	// x-displayName: "Bhutan"
	COUNTRY_BT CountryCode = 34
	// x-displayName: "Bouvet Island"
	COUNTRY_BV CountryCode = 35
	// x-displayName: "Botswana"
	COUNTRY_BW CountryCode = 36
	// x-displayName: "Belarus"
	COUNTRY_BY CountryCode = 37
	// x-displayName: "Belize"
	COUNTRY_BZ CountryCode = 38
	// x-displayName: "Canada"
	COUNTRY_CA CountryCode = 39
	// x-displayName: "Cocos (Keeling) Islands"
	COUNTRY_CC CountryCode = 40
	// x-displayName: "The Democratic Republic of Congo"
	COUNTRY_CD CountryCode = 41
	// x-displayName: "Central African Republic"
	COUNTRY_CF CountryCode = 42
	// x-displayName: "Congo"
	COUNTRY_CG CountryCode = 43
	// x-displayName: "Switzerland"
	COUNTRY_CH CountryCode = 44
	// x-displayName: "Cote d'Ivoire"
	COUNTRY_CI CountryCode = 45
	// x-displayName: "Cook Islands"
	COUNTRY_CK CountryCode = 46
	// x-displayName: "Chile"
	COUNTRY_CL CountryCode = 47
	// x-displayName: "Cameroon"
	COUNTRY_CM CountryCode = 48
	// x-displayName: "China"
	COUNTRY_CN CountryCode = 49
	// x-displayName: "Colombia"
	COUNTRY_CO CountryCode = 50
	// x-displayName: "Costa Rica"
	COUNTRY_CR CountryCode = 51
	// x-displayName: "Serbia and Montenegro"
	COUNTRY_CS CountryCode = 52
	// x-displayName: "Cuba"
	COUNTRY_CU CountryCode = 53
	// x-displayName: "Cape Verde"
	COUNTRY_CV CountryCode = 54
	// x-displayName: "Curacao"
	COUNTRY_CW CountryCode = 55
	// x-displayName: "Christmas Island"
	COUNTRY_CX CountryCode = 56
	// x-displayName: "Cyprus"
	COUNTRY_CY CountryCode = 57
	// x-displayName: "Czechia"
	COUNTRY_CZ CountryCode = 58
	// x-displayName: "Germany"
	COUNTRY_DE CountryCode = 59
	// x-displayName: "Djibouti"
	COUNTRY_DJ CountryCode = 60
	// x-displayName: "Denmark"
	COUNTRY_DK CountryCode = 61
	// x-displayName: "Dominica"
	COUNTRY_DM CountryCode = 62
	// x-displayName: "Dominican Republic"
	COUNTRY_DO CountryCode = 63
	// x-displayName: "Algeria"
	COUNTRY_DZ CountryCode = 64
	// x-displayName: "Ecuador"
	COUNTRY_EC CountryCode = 65
	// x-displayName: "Estonia"
	COUNTRY_EE CountryCode = 66
	// x-displayName: "Egypt"
	COUNTRY_EG CountryCode = 67
	// x-displayName: "Western Sahara"
	COUNTRY_EH CountryCode = 68
	// x-displayName: "Eritrea"
	COUNTRY_ER CountryCode = 69
	// x-displayName: "Spain"
	COUNTRY_ES CountryCode = 70
	// x-displayName: "Ethiopia"
	COUNTRY_ET CountryCode = 71
	// x-displayName: "Finland"
	COUNTRY_FI CountryCode = 72
	// x-displayName: "Fiji"
	COUNTRY_FJ CountryCode = 73
	// x-displayName: "Falkland Islands (Malvinas)"
	COUNTRY_FK CountryCode = 74
	// x-displayName: "Federated States of Micronesia"
	COUNTRY_FM CountryCode = 75
	// x-displayName: "Faroe Islands"
	COUNTRY_FO CountryCode = 76
	// x-displayName: "France"
	COUNTRY_FR CountryCode = 77
	// x-displayName: "Gabon"
	COUNTRY_GA CountryCode = 78
	// x-displayName: "United Kingdom"
	COUNTRY_GB CountryCode = 79
	// x-displayName: "Grenada"
	COUNTRY_GD CountryCode = 80
	// x-displayName: "Georgia"
	COUNTRY_GE CountryCode = 81
	// x-displayName: "French Guiana"
	COUNTRY_GF CountryCode = 82
	// x-displayName: "Guernsey"
	COUNTRY_GG CountryCode = 83
	// x-displayName: "Ghana"
	COUNTRY_GH CountryCode = 84
	// x-displayName: "Gibraltar"
	COUNTRY_GI CountryCode = 85
	// x-displayName: "Greenland"
	COUNTRY_GL CountryCode = 86
	// x-displayName: "Gambia"
	COUNTRY_GM CountryCode = 87
	// x-displayName: "Guinea"
	COUNTRY_GN CountryCode = 88
	// x-displayName: "Guadeloupe"
	COUNTRY_GP CountryCode = 89
	// x-displayName: "Equatorial Guinea"
	COUNTRY_GQ CountryCode = 90
	// x-displayName: "Greece"
	COUNTRY_GR CountryCode = 91
	// x-displayName: "South Georgia & The South Sandwich Islands"
	COUNTRY_GS CountryCode = 92
	// x-displayName: "Guatemala"
	COUNTRY_GT CountryCode = 93
	// x-displayName: "Guam"
	COUNTRY_GU CountryCode = 94
	// x-displayName: "Guinea-Bissau"
	COUNTRY_GW CountryCode = 95
	// x-displayName: "Guyana"
	COUNTRY_GY CountryCode = 96
	// x-displayName: "Hong Kong"
	COUNTRY_HK CountryCode = 97
	// x-displayName: "Heard and Mc Donald Islands"
	COUNTRY_HM CountryCode = 98
	// x-displayName: "Honduras"
	COUNTRY_HN CountryCode = 99
	// x-displayName: "Croatia"
	COUNTRY_HR CountryCode = 100
	// x-displayName: "Haiti"
	COUNTRY_HT CountryCode = 101
	// x-displayName: "Hungary"
	COUNTRY_HU CountryCode = 102
	// x-displayName: "Indonesia"
	COUNTRY_ID CountryCode = 103
	// x-displayName: "Ireland"
	COUNTRY_IE CountryCode = 104
	// x-displayName: "Israel"
	COUNTRY_IL CountryCode = 105
	// x-displayName: "Isle of Man"
	COUNTRY_IM CountryCode = 106
	// x-displayName: "India"
	COUNTRY_IN CountryCode = 107
	// x-displayName: "British Indian Ocean Territory"
	COUNTRY_IO CountryCode = 108
	// x-displayName: "Iraq"
	COUNTRY_IQ CountryCode = 109
	// x-displayName: "Islamic Republic of Iran"
	COUNTRY_IR CountryCode = 110
	// x-displayName: "Iceland"
	COUNTRY_IS CountryCode = 111
	// x-displayName: "Italy"
	COUNTRY_IT CountryCode = 112
	// x-displayName: "Jersey"
	COUNTRY_JE CountryCode = 113
	// x-displayName: "Jamaica"
	COUNTRY_JM CountryCode = 114
	// x-displayName: "Jordan"
	COUNTRY_JO CountryCode = 115
	// x-displayName: "Japan"
	COUNTRY_JP CountryCode = 116
	// x-displayName: "Kenya"
	COUNTRY_KE CountryCode = 117
	// x-displayName: "Kyrgyzstan"
	COUNTRY_KG CountryCode = 118
	// x-displayName: "Cambodia"
	COUNTRY_KH CountryCode = 119
	// x-displayName: "Kiribati"
	COUNTRY_KI CountryCode = 120
	// x-displayName: "Comoros"
	COUNTRY_KM CountryCode = 121
	// x-displayName: "Saint Kitts & Nevis"
	COUNTRY_KN CountryCode = 122
	// x-displayName: "Democratic People's Republic of Korea"
	COUNTRY_KP CountryCode = 123
	// x-displayName: "Republic of Korea"
	COUNTRY_KR CountryCode = 124
	// x-displayName: "Kuwait"
	COUNTRY_KW CountryCode = 125
	// x-displayName: "Cayman Islands"
	COUNTRY_KY CountryCode = 126
	// x-displayName: "Kazakstan"
	COUNTRY_KZ CountryCode = 127
	// x-displayName: "People's Democratic Republic Lao"
	COUNTRY_LA CountryCode = 128
	// x-displayName: "Lebanon"
	COUNTRY_LB CountryCode = 129
	// x-displayName: "Saint Lucia"
	COUNTRY_LC CountryCode = 130
	// x-displayName: "Liechtenstein"
	COUNTRY_LI CountryCode = 131
	// x-displayName: "Sri Lanka"
	COUNTRY_LK CountryCode = 132
	// x-displayName: "Liberia"
	COUNTRY_LR CountryCode = 133
	// x-displayName: "Lesotho"
	COUNTRY_LS CountryCode = 134
	// x-displayName: "Lithuania"
	COUNTRY_LT CountryCode = 135
	// x-displayName: "Luxembourg"
	COUNTRY_LU CountryCode = 136
	// x-displayName: "Latvia"
	COUNTRY_LV CountryCode = 137
	// x-displayName: "Libyan Arab Jamahiriya"
	COUNTRY_LY CountryCode = 138
	// x-displayName: "Morocco"
	COUNTRY_MA CountryCode = 139
	// x-displayName: "Monaco"
	COUNTRY_MC CountryCode = 140
	// x-displayName: "Republic of Moldova"
	COUNTRY_MD CountryCode = 141
	// x-displayName: "Montenegro"
	COUNTRY_ME CountryCode = 142
	// x-displayName: "Saint Martin"
	COUNTRY_MF CountryCode = 143
	// x-displayName: "Madagascar"
	COUNTRY_MG CountryCode = 144
	// x-displayName: "Marshall Islands"
	COUNTRY_MH CountryCode = 145
	// x-displayName: "The Former Yugoslav Republic Of Macedonia"
	COUNTRY_MK CountryCode = 146
	// x-displayName: "Mali"
	COUNTRY_ML CountryCode = 147
	// x-displayName: "Myanmar"
	COUNTRY_MM CountryCode = 148
	// x-displayName: "Mongolia"
	COUNTRY_MN CountryCode = 149
	// x-displayName: "Macao"
	COUNTRY_MO CountryCode = 150
	// x-displayName: "Northern Mariana Islands"
	COUNTRY_MP CountryCode = 151
	// x-displayName: "Martinique"
	COUNTRY_MQ CountryCode = 152
	// x-displayName: "Mauritania"
	COUNTRY_MR CountryCode = 153
	// x-displayName: "Montserrat"
	COUNTRY_MS CountryCode = 154
	// x-displayName: "Malta"
	COUNTRY_MT CountryCode = 155
	// x-displayName: "Mauritius"
	COUNTRY_MU CountryCode = 156
	// x-displayName: "Maldives"
	COUNTRY_MV CountryCode = 157
	// x-displayName: "Malawi"
	COUNTRY_MW CountryCode = 158
	// x-displayName: "Mexico"
	COUNTRY_MX CountryCode = 159
	// x-displayName: "Malaysia"
	COUNTRY_MY CountryCode = 160
	// x-displayName: "Mozambique"
	COUNTRY_MZ CountryCode = 161
	// x-displayName: "Namibia"
	COUNTRY_NA CountryCode = 162
	// x-displayName: "New Caledonia"
	COUNTRY_NC CountryCode = 163
	// x-displayName: "Niger"
	COUNTRY_NE CountryCode = 164
	// x-displayName: "Norfolk Island"
	COUNTRY_NF CountryCode = 165
	// x-displayName: "Nigeria"
	COUNTRY_NG CountryCode = 166
	// x-displayName: "Nicaragua"
	COUNTRY_NI CountryCode = 167
	// x-displayName: "Netherlands"
	COUNTRY_NL CountryCode = 168
	// x-displayName: "Norway"
	COUNTRY_NO CountryCode = 169
	// x-displayName: "Nepal"
	COUNTRY_NP CountryCode = 170
	// x-displayName: "Nauru"
	COUNTRY_NR CountryCode = 171
	// x-displayName: "Niue"
	COUNTRY_NU CountryCode = 172
	// x-displayName: "New Zealand"
	COUNTRY_NZ CountryCode = 173
	// x-displayName: "Oman"
	COUNTRY_OM CountryCode = 174
	// x-displayName: "Panama"
	COUNTRY_PA CountryCode = 175
	// x-displayName: "Peru"
	COUNTRY_PE CountryCode = 176
	// x-displayName: "French Polynesia"
	COUNTRY_PF CountryCode = 177
	// x-displayName: "Papua New Guinea"
	COUNTRY_PG CountryCode = 178
	// x-displayName: "Philippines"
	COUNTRY_PH CountryCode = 179
	// x-displayName: "Pakistan"
	COUNTRY_PK CountryCode = 180
	// x-displayName: "Poland"
	COUNTRY_PL CountryCode = 181
	// x-displayName: "Saint Pierre and Miquelon"
	COUNTRY_PM CountryCode = 182
	// x-displayName: "Pitcairn"
	COUNTRY_PN CountryCode = 183
	// x-displayName: "Puerto Rico"
	COUNTRY_PR CountryCode = 184
	// x-displayName: "Palestinian Territory"
	COUNTRY_PS CountryCode = 185
	// x-displayName: "Portugal"
	COUNTRY_PT CountryCode = 186
	// x-displayName: "Palau"
	COUNTRY_PW CountryCode = 187
	// x-displayName: "Paraguay"
	COUNTRY_PY CountryCode = 188
	// x-displayName: "Qatar"
	COUNTRY_QA CountryCode = 189
	// x-displayName: "Reunion"
	COUNTRY_RE CountryCode = 190
	// x-displayName: "Romania"
	COUNTRY_RO CountryCode = 191
	// x-displayName: "Republic of Serbia"
	COUNTRY_RS CountryCode = 192
	// x-displayName: "Russia Federation"
	COUNTRY_RU CountryCode = 193
	// x-displayName: "Rwanda"
	COUNTRY_RW CountryCode = 194
	// x-displayName: "Saudi Arabia"
	COUNTRY_SA CountryCode = 195
	// x-displayName: "Solomon Islands"
	COUNTRY_SB CountryCode = 196
	// x-displayName: "Seychelles"
	COUNTRY_SC CountryCode = 197
	// x-displayName: "Sudan"
	COUNTRY_SD CountryCode = 198
	// x-displayName: "Sweden"
	COUNTRY_SE CountryCode = 199
	// x-displayName: "Singapore"
	COUNTRY_SG CountryCode = 200
	// x-displayName: "Saint Helena"
	COUNTRY_SH CountryCode = 201
	// x-displayName: "Slovenia"
	COUNTRY_SI CountryCode = 202
	// x-displayName: "Svalbard and Jan Mayen"
	COUNTRY_SJ CountryCode = 203
	// x-displayName: "Slovakia"
	COUNTRY_SK CountryCode = 204
	// x-displayName: "Sierra Leone"
	COUNTRY_SL CountryCode = 205
	// x-displayName: "San Marino"
	COUNTRY_SM CountryCode = 206
	// x-displayName: "Senegal"
	COUNTRY_SN CountryCode = 207
	// x-displayName: "Somalia"
	COUNTRY_SO CountryCode = 208
	// x-displayName: "Suriname"
	COUNTRY_SR CountryCode = 209
	// x-displayName: "South Sudan"
	COUNTRY_SS CountryCode = 210
	// x-displayName: "Sao Tome and Principe"
	COUNTRY_ST CountryCode = 211
	// x-displayName: "El Salvador"
	COUNTRY_SV CountryCode = 212
	// x-displayName: "Sint Maarten"
	COUNTRY_SX CountryCode = 213
	// x-displayName: "Syrian Arab Republic"
	COUNTRY_SY CountryCode = 214
	// x-displayName: "Swaziland"
	COUNTRY_SZ CountryCode = 215
	// x-displayName: "Turks and Caicos Islands"
	COUNTRY_TC CountryCode = 216
	// x-displayName: "Chad"
	COUNTRY_TD CountryCode = 217
	// x-displayName: "French Southern Territories"
	COUNTRY_TF CountryCode = 218
	// x-displayName: "Togo"
	COUNTRY_TG CountryCode = 219
	// x-displayName: "Thailand"
	COUNTRY_TH CountryCode = 220
	// x-displayName: "Tajikistan"
	COUNTRY_TJ CountryCode = 221
	// x-displayName: "Tokelau"
	COUNTRY_TK CountryCode = 222
	// x-displayName: "Timor-Leste"
	COUNTRY_TL CountryCode = 223
	// x-displayName: "Turkmenistan"
	COUNTRY_TM CountryCode = 224
	// x-displayName: "Tunisia"
	COUNTRY_TN CountryCode = 225
	// x-displayName: "Tonga"
	COUNTRY_TO CountryCode = 226
	// x-displayName: "Turkey"
	COUNTRY_TR CountryCode = 227
	// x-displayName: "Trinidad and Tobago"
	COUNTRY_TT CountryCode = 228
	// x-displayName: "Tuvalu"
	COUNTRY_TV CountryCode = 229
	// x-displayName: "Taiwan"
	COUNTRY_TW CountryCode = 230
	// x-displayName: "United Republic of Tanzania"
	COUNTRY_TZ CountryCode = 231
	// x-displayName: "Ukraine"
	COUNTRY_UA CountryCode = 232
	// x-displayName: "Uganda"
	COUNTRY_UG CountryCode = 233
	// x-displayName: "United States Minor Outlying Islands"
	COUNTRY_UM CountryCode = 234
	// x-displayName: "United States"
	COUNTRY_US CountryCode = 235
	// x-displayName: "Uruguay"
	COUNTRY_UY CountryCode = 236
	// x-displayName: "Uzbekistan"
	COUNTRY_UZ CountryCode = 237
	// x-displayName: "Holy See (Vatican City State)"
	COUNTRY_VA CountryCode = 238
	// x-displayName: "Saint Vincent and the Grenadines"
	COUNTRY_VC CountryCode = 239
	// x-displayName: "Venezuela"
	COUNTRY_VE CountryCode = 240
	// x-displayName: "British Virgin Islands"
	COUNTRY_VG CountryCode = 241
	// x-displayName: "U.S. Virgin Islands"
	COUNTRY_VI CountryCode = 242
	// x-displayName: "Vietnam"
	COUNTRY_VN CountryCode = 243
	// x-displayName: "Vanuatu"
	COUNTRY_VU CountryCode = 244
	// x-displayName: "Wallis and Futuna"
	COUNTRY_WF CountryCode = 245
	// x-displayName: "Samoa"
	COUNTRY_WS CountryCode = 246
	// x-displayName: "Kosovo"
	COUNTRY_XK CountryCode = 247
	// x-displayName: "Turkish Rep N Cyprus"
	COUNTRY_XT CountryCode = 248
	// x-displayName: "Yemen"
	COUNTRY_YE CountryCode = 249
	// x-displayName: "Mayotte"
	COUNTRY_YT CountryCode = 250
	// x-displayName: "South Africa"
	COUNTRY_ZA CountryCode = 251
	// x-displayName: "Zambia"
	COUNTRY_ZM CountryCode = 252
	// x-displayName: "Zimbabwe"
	COUNTRY_ZW CountryCode = 253
)

var CountryCode_name = map[int32]string{
	0:   "COUNTRY_NONE",
	1:   "COUNTRY_AD",
	2:   "COUNTRY_AE",
	3:   "COUNTRY_AF",
	4:   "COUNTRY_AG",
	5:   "COUNTRY_AI",
	6:   "COUNTRY_AL",
	7:   "COUNTRY_AM",
	8:   "COUNTRY_AN",
	9:   "COUNTRY_AO",
	10:  "COUNTRY_AQ",
	11:  "COUNTRY_AR",
	12:  "COUNTRY_AS",
	13:  "COUNTRY_AT",
	14:  "COUNTRY_AU",
	15:  "COUNTRY_AW",
	16:  "COUNTRY_AX",
	17:  "COUNTRY_AZ",
	18:  "COUNTRY_BA",
	19:  "COUNTRY_BB",
	20:  "COUNTRY_BD",
	21:  "COUNTRY_BE",
	22:  "COUNTRY_BF",
	23:  "COUNTRY_BG",
	24:  "COUNTRY_BH",
	25:  "COUNTRY_BI",
	26:  "COUNTRY_BJ",
	27:  "COUNTRY_BL",
	28:  "COUNTRY_BM",
	29:  "COUNTRY_BN",
	30:  "COUNTRY_BO",
	31:  "COUNTRY_BQ",
	32:  "COUNTRY_BR",
	33:  "COUNTRY_BS",
	34:  "COUNTRY_BT",
	35:  "COUNTRY_BV",
	36:  "COUNTRY_BW",
	37:  "COUNTRY_BY",
	38:  "COUNTRY_BZ",
	39:  "COUNTRY_CA",
	40:  "COUNTRY_CC",
	41:  "COUNTRY_CD",
	42:  "COUNTRY_CF",
	43:  "COUNTRY_CG",
	44:  "COUNTRY_CH",
	45:  "COUNTRY_CI",
	46:  "COUNTRY_CK",
	47:  "COUNTRY_CL",
	48:  "COUNTRY_CM",
	49:  "COUNTRY_CN",
	50:  "COUNTRY_CO",
	51:  "COUNTRY_CR",
	52:  "COUNTRY_CS",
	53:  "COUNTRY_CU",
	54:  "COUNTRY_CV",
	55:  "COUNTRY_CW",
	56:  "COUNTRY_CX",
	57:  "COUNTRY_CY",
	58:  "COUNTRY_CZ",
	59:  "COUNTRY_DE",
	60:  "COUNTRY_DJ",
	61:  "COUNTRY_DK",
	62:  "COUNTRY_DM",
	63:  "COUNTRY_DO",
	64:  "COUNTRY_DZ",
	65:  "COUNTRY_EC",
	66:  "COUNTRY_EE",
	67:  "COUNTRY_EG",
	68:  "COUNTRY_EH",
	69:  "COUNTRY_ER",
	70:  "COUNTRY_ES",
	71:  "COUNTRY_ET",
	72:  "COUNTRY_FI",
	73:  "COUNTRY_FJ",
	74:  "COUNTRY_FK",
	75:  "COUNTRY_FM",
	76:  "COUNTRY_FO",
	77:  "COUNTRY_FR",
	78:  "COUNTRY_GA",
	79:  "COUNTRY_GB",
	80:  "COUNTRY_GD",
	81:  "COUNTRY_GE",
	82:  "COUNTRY_GF",
	83:  "COUNTRY_GG",
	84:  "COUNTRY_GH",
	85:  "COUNTRY_GI",
	86:  "COUNTRY_GL",
	87:  "COUNTRY_GM",
	88:  "COUNTRY_GN",
	89:  "COUNTRY_GP",
	90:  "COUNTRY_GQ",
	91:  "COUNTRY_GR",
	92:  "COUNTRY_GS",
	93:  "COUNTRY_GT",
	94:  "COUNTRY_GU",
	95:  "COUNTRY_GW",
	96:  "COUNTRY_GY",
	97:  "COUNTRY_HK",
	98:  "COUNTRY_HM",
	99:  "COUNTRY_HN",
	100: "COUNTRY_HR",
	101: "COUNTRY_HT",
	102: "COUNTRY_HU",
	103: "COUNTRY_ID",
	104: "COUNTRY_IE",
	105: "COUNTRY_IL",
	106: "COUNTRY_IM",
	107: "COUNTRY_IN",
	108: "COUNTRY_IO",
	109: "COUNTRY_IQ",
	110: "COUNTRY_IR",
	111: "COUNTRY_IS",
	112: "COUNTRY_IT",
	113: "COUNTRY_JE",
	114: "COUNTRY_JM",
	115: "COUNTRY_JO",
	116: "COUNTRY_JP",
	117: "COUNTRY_KE",
	118: "COUNTRY_KG",
	119: "COUNTRY_KH",
	120: "COUNTRY_KI",
	121: "COUNTRY_KM",
	122: "COUNTRY_KN",
	123: "COUNTRY_KP",
	124: "COUNTRY_KR",
	125: "COUNTRY_KW",
	126: "COUNTRY_KY",
	127: "COUNTRY_KZ",
	128: "COUNTRY_LA",
	129: "COUNTRY_LB",
	130: "COUNTRY_LC",
	131: "COUNTRY_LI",
	132: "COUNTRY_LK",
	133: "COUNTRY_LR",
	134: "COUNTRY_LS",
	135: "COUNTRY_LT",
	136: "COUNTRY_LU",
	137: "COUNTRY_LV",
	138: "COUNTRY_LY",
	139: "COUNTRY_MA",
	140: "COUNTRY_MC",
	141: "COUNTRY_MD",
	142: "COUNTRY_ME",
	143: "COUNTRY_MF",
	144: "COUNTRY_MG",
	145: "COUNTRY_MH",
	146: "COUNTRY_MK",
	147: "COUNTRY_ML",
	148: "COUNTRY_MM",
	149: "COUNTRY_MN",
	150: "COUNTRY_MO",
	151: "COUNTRY_MP",
	152: "COUNTRY_MQ",
	153: "COUNTRY_MR",
	154: "COUNTRY_MS",
	155: "COUNTRY_MT",
	156: "COUNTRY_MU",
	157: "COUNTRY_MV",
	158: "COUNTRY_MW",
	159: "COUNTRY_MX",
	160: "COUNTRY_MY",
	161: "COUNTRY_MZ",
	162: "COUNTRY_NA",
	163: "COUNTRY_NC",
	164: "COUNTRY_NE",
	165: "COUNTRY_NF",
	166: "COUNTRY_NG",
	167: "COUNTRY_NI",
	168: "COUNTRY_NL",
	169: "COUNTRY_NO",
	170: "COUNTRY_NP",
	171: "COUNTRY_NR",
	172: "COUNTRY_NU",
	173: "COUNTRY_NZ",
	174: "COUNTRY_OM",
	175: "COUNTRY_PA",
	176: "COUNTRY_PE",
	177: "COUNTRY_PF",
	178: "COUNTRY_PG",
	179: "COUNTRY_PH",
	180: "COUNTRY_PK",
	181: "COUNTRY_PL",
	182: "COUNTRY_PM",
	183: "COUNTRY_PN",
	184: "COUNTRY_PR",
	185: "COUNTRY_PS",
	186: "COUNTRY_PT",
	187: "COUNTRY_PW",
	188: "COUNTRY_PY",
	189: "COUNTRY_QA",
	190: "COUNTRY_RE",
	191: "COUNTRY_RO",
	192: "COUNTRY_RS",
	193: "COUNTRY_RU",
	194: "COUNTRY_RW",
	195: "COUNTRY_SA",
	196: "COUNTRY_SB",
	197: "COUNTRY_SC",
	198: "COUNTRY_SD",
	199: "COUNTRY_SE",
	200: "COUNTRY_SG",
	201: "COUNTRY_SH",
	202: "COUNTRY_SI",
	203: "COUNTRY_SJ",
	204: "COUNTRY_SK",
	205: "COUNTRY_SL",
	206: "COUNTRY_SM",
	207: "COUNTRY_SN",
	208: "COUNTRY_SO",
	209: "COUNTRY_SR",
	210: "COUNTRY_SS",
	211: "COUNTRY_ST",
	212: "COUNTRY_SV",
	213: "COUNTRY_SX",
	214: "COUNTRY_SY",
	215: "COUNTRY_SZ",
	216: "COUNTRY_TC",
	217: "COUNTRY_TD",
	218: "COUNTRY_TF",
	219: "COUNTRY_TG",
	220: "COUNTRY_TH",
	221: "COUNTRY_TJ",
	222: "COUNTRY_TK",
	223: "COUNTRY_TL",
	224: "COUNTRY_TM",
	225: "COUNTRY_TN",
	226: "COUNTRY_TO",
	227: "COUNTRY_TR",
	228: "COUNTRY_TT",
	229: "COUNTRY_TV",
	230: "COUNTRY_TW",
	231: "COUNTRY_TZ",
	232: "COUNTRY_UA",
	233: "COUNTRY_UG",
	234: "COUNTRY_UM",
	235: "COUNTRY_US",
	236: "COUNTRY_UY",
	237: "COUNTRY_UZ",
	238: "COUNTRY_VA",
	239: "COUNTRY_VC",
	240: "COUNTRY_VE",
	241: "COUNTRY_VG",
	242: "COUNTRY_VI",
	243: "COUNTRY_VN",
	244: "COUNTRY_VU",
	245: "COUNTRY_WF",
	246: "COUNTRY_WS",
	247: "COUNTRY_XK",
	248: "COUNTRY_XT",
	249: "COUNTRY_YE",
	250: "COUNTRY_YT",
	251: "COUNTRY_ZA",
	252: "COUNTRY_ZM",
	253: "COUNTRY_ZW",
}

var CountryCode_value = map[string]int32{
	"COUNTRY_NONE": 0,
	"COUNTRY_AD":   1,
	"COUNTRY_AE":   2,
	"COUNTRY_AF":   3,
	"COUNTRY_AG":   4,
	"COUNTRY_AI":   5,
	"COUNTRY_AL":   6,
	"COUNTRY_AM":   7,
	"COUNTRY_AN":   8,
	"COUNTRY_AO":   9,
	"COUNTRY_AQ":   10,
	"COUNTRY_AR":   11,
	"COUNTRY_AS":   12,
	"COUNTRY_AT":   13,
	"COUNTRY_AU":   14,
	"COUNTRY_AW":   15,
	"COUNTRY_AX":   16,
	"COUNTRY_AZ":   17,
	"COUNTRY_BA":   18,
	"COUNTRY_BB":   19,
	"COUNTRY_BD":   20,
	"COUNTRY_BE":   21,
	"COUNTRY_BF":   22,
	"COUNTRY_BG":   23,
	"COUNTRY_BH":   24,
	"COUNTRY_BI":   25,
	"COUNTRY_BJ":   26,
	"COUNTRY_BL":   27,
	"COUNTRY_BM":   28,
	"COUNTRY_BN":   29,
	"COUNTRY_BO":   30,
	"COUNTRY_BQ":   31,
	"COUNTRY_BR":   32,
	"COUNTRY_BS":   33,
	"COUNTRY_BT":   34,
	"COUNTRY_BV":   35,
	"COUNTRY_BW":   36,
	"COUNTRY_BY":   37,
	"COUNTRY_BZ":   38,
	"COUNTRY_CA":   39,
	"COUNTRY_CC":   40,
	"COUNTRY_CD":   41,
	"COUNTRY_CF":   42,
	"COUNTRY_CG":   43,
	"COUNTRY_CH":   44,
	"COUNTRY_CI":   45,
	"COUNTRY_CK":   46,
	"COUNTRY_CL":   47,
	"COUNTRY_CM":   48,
	"COUNTRY_CN":   49,
	"COUNTRY_CO":   50,
	"COUNTRY_CR":   51,
	"COUNTRY_CS":   52,
	"COUNTRY_CU":   53,
	"COUNTRY_CV":   54,
	"COUNTRY_CW":   55,
	"COUNTRY_CX":   56,
	"COUNTRY_CY":   57,
	"COUNTRY_CZ":   58,
	"COUNTRY_DE":   59,
	"COUNTRY_DJ":   60,
	"COUNTRY_DK":   61,
	"COUNTRY_DM":   62,
	"COUNTRY_DO":   63,
	"COUNTRY_DZ":   64,
	"COUNTRY_EC":   65,
	"COUNTRY_EE":   66,
	"COUNTRY_EG":   67,
	"COUNTRY_EH":   68,
	"COUNTRY_ER":   69,
	"COUNTRY_ES":   70,
	"COUNTRY_ET":   71,
	"COUNTRY_FI":   72,
	"COUNTRY_FJ":   73,
	"COUNTRY_FK":   74,
	"COUNTRY_FM":   75,
	"COUNTRY_FO":   76,
	"COUNTRY_FR":   77,
	"COUNTRY_GA":   78,
	"COUNTRY_GB":   79,
	"COUNTRY_GD":   80,
	"COUNTRY_GE":   81,
	"COUNTRY_GF":   82,
	"COUNTRY_GG":   83,
	"COUNTRY_GH":   84,
	"COUNTRY_GI":   85,
	"COUNTRY_GL":   86,
	"COUNTRY_GM":   87,
	"COUNTRY_GN":   88,
	"COUNTRY_GP":   89,
	"COUNTRY_GQ":   90,
	"COUNTRY_GR":   91,
	"COUNTRY_GS":   92,
	"COUNTRY_GT":   93,
	"COUNTRY_GU":   94,
	"COUNTRY_GW":   95,
	"COUNTRY_GY":   96,
	"COUNTRY_HK":   97,
	"COUNTRY_HM":   98,
	"COUNTRY_HN":   99,
	"COUNTRY_HR":   100,
	"COUNTRY_HT":   101,
	"COUNTRY_HU":   102,
	"COUNTRY_ID":   103,
	"COUNTRY_IE":   104,
	"COUNTRY_IL":   105,
	"COUNTRY_IM":   106,
	"COUNTRY_IN":   107,
	"COUNTRY_IO":   108,
	"COUNTRY_IQ":   109,
	"COUNTRY_IR":   110,
	"COUNTRY_IS":   111,
	"COUNTRY_IT":   112,
	"COUNTRY_JE":   113,
	"COUNTRY_JM":   114,
	"COUNTRY_JO":   115,
	"COUNTRY_JP":   116,
	"COUNTRY_KE":   117,
	"COUNTRY_KG":   118,
	"COUNTRY_KH":   119,
	"COUNTRY_KI":   120,
	"COUNTRY_KM":   121,
	"COUNTRY_KN":   122,
	"COUNTRY_KP":   123,
	"COUNTRY_KR":   124,
	"COUNTRY_KW":   125,
	"COUNTRY_KY":   126,
	"COUNTRY_KZ":   127,
	"COUNTRY_LA":   128,
	"COUNTRY_LB":   129,
	"COUNTRY_LC":   130,
	"COUNTRY_LI":   131,
	"COUNTRY_LK":   132,
	"COUNTRY_LR":   133,
	"COUNTRY_LS":   134,
	"COUNTRY_LT":   135,
	"COUNTRY_LU":   136,
	"COUNTRY_LV":   137,
	"COUNTRY_LY":   138,
	"COUNTRY_MA":   139,
	"COUNTRY_MC":   140,
	"COUNTRY_MD":   141,
	"COUNTRY_ME":   142,
	"COUNTRY_MF":   143,
	"COUNTRY_MG":   144,
	"COUNTRY_MH":   145,
	"COUNTRY_MK":   146,
	"COUNTRY_ML":   147,
	"COUNTRY_MM":   148,
	"COUNTRY_MN":   149,
	"COUNTRY_MO":   150,
	"COUNTRY_MP":   151,
	"COUNTRY_MQ":   152,
	"COUNTRY_MR":   153,
	"COUNTRY_MS":   154,
	"COUNTRY_MT":   155,
	"COUNTRY_MU":   156,
	"COUNTRY_MV":   157,
	"COUNTRY_MW":   158,
	"COUNTRY_MX":   159,
	"COUNTRY_MY":   160,
	"COUNTRY_MZ":   161,
	"COUNTRY_NA":   162,
	"COUNTRY_NC":   163,
	"COUNTRY_NE":   164,
	"COUNTRY_NF":   165,
	"COUNTRY_NG":   166,
	"COUNTRY_NI":   167,
	"COUNTRY_NL":   168,
	"COUNTRY_NO":   169,
	"COUNTRY_NP":   170,
	"COUNTRY_NR":   171,
	"COUNTRY_NU":   172,
	"COUNTRY_NZ":   173,
	"COUNTRY_OM":   174,
	"COUNTRY_PA":   175,
	"COUNTRY_PE":   176,
	"COUNTRY_PF":   177,
	"COUNTRY_PG":   178,
	"COUNTRY_PH":   179,
	"COUNTRY_PK":   180,
	"COUNTRY_PL":   181,
	"COUNTRY_PM":   182,
	"COUNTRY_PN":   183,
	"COUNTRY_PR":   184,
	"COUNTRY_PS":   185,
	"COUNTRY_PT":   186,
	"COUNTRY_PW":   187,
	"COUNTRY_PY":   188,
	"COUNTRY_QA":   189,
	"COUNTRY_RE":   190,
	"COUNTRY_RO":   191,
	"COUNTRY_RS":   192,
	"COUNTRY_RU":   193,
	"COUNTRY_RW":   194,
	"COUNTRY_SA":   195,
	"COUNTRY_SB":   196,
	"COUNTRY_SC":   197,
	"COUNTRY_SD":   198,
	"COUNTRY_SE":   199,
	"COUNTRY_SG":   200,
	"COUNTRY_SH":   201,
	"COUNTRY_SI":   202,
	"COUNTRY_SJ":   203,
	"COUNTRY_SK":   204,
	"COUNTRY_SL":   205,
	"COUNTRY_SM":   206,
	"COUNTRY_SN":   207,
	"COUNTRY_SO":   208,
	"COUNTRY_SR":   209,
	"COUNTRY_SS":   210,
	"COUNTRY_ST":   211,
	"COUNTRY_SV":   212,
	"COUNTRY_SX":   213,
	"COUNTRY_SY":   214,
	"COUNTRY_SZ":   215,
	"COUNTRY_TC":   216,
	"COUNTRY_TD":   217,
	"COUNTRY_TF":   218,
	"COUNTRY_TG":   219,
	"COUNTRY_TH":   220,
	"COUNTRY_TJ":   221,
	"COUNTRY_TK":   222,
	"COUNTRY_TL":   223,
	"COUNTRY_TM":   224,
	"COUNTRY_TN":   225,
	"COUNTRY_TO":   226,
	"COUNTRY_TR":   227,
	"COUNTRY_TT":   228,
	"COUNTRY_TV":   229,
	"COUNTRY_TW":   230,
	"COUNTRY_TZ":   231,
	"COUNTRY_UA":   232,
	"COUNTRY_UG":   233,
	"COUNTRY_UM":   234,
	"COUNTRY_US":   235,
	"COUNTRY_UY":   236,
	"COUNTRY_UZ":   237,
	"COUNTRY_VA":   238,
	"COUNTRY_VC":   239,
	"COUNTRY_VE":   240,
	"COUNTRY_VG":   241,
	"COUNTRY_VI":   242,
	"COUNTRY_VN":   243,
	"COUNTRY_VU":   244,
	"COUNTRY_WF":   245,
	"COUNTRY_WS":   246,
	"COUNTRY_XK":   247,
	"COUNTRY_XT":   248,
	"COUNTRY_YE":   249,
	"COUNTRY_YT":   250,
	"COUNTRY_ZA":   251,
	"COUNTRY_ZM":   252,
	"COUNTRY_ZW":   253,
}

func (CountryCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{5}
}

// Rule Action
//
// x-displayName: "Rule Action"
// The rule action determines the disposition of the input request API. If a policy matches a rule with an ALLOW action, the processing of the request proceeds
// forward. If it matches a rule with a DENY action, the processing of the request is terminated and an appropriate message/code returned to the originator. If
// it matches a rule with a NEXT_POLICY_SET action, evaluation of the current policy set terminates and evaluation of the next policy set in the chain begins.
type RuleAction int32

const (
	// DENY
	//
	// x-displayName: "Deny"
	// Deny the request.
	DENY RuleAction = 0
	// ALLOW
	//
	// x-displayName: "Allow"
	// Allow the request to proceed.
	ALLOW RuleAction = 1
	// NEXT_POLICY_SET
	//
	// x-displayName: "Next Policy Set"
	// Terminate evaluation of the current policy set and begin evaluating the next policy set in the chain. Note that the evaluation of any remaining policies
	// in the current policy set is skipped.
	NEXT_POLICY_SET RuleAction = 2
	// NEXT_POLICY
	//
	// x-displayName: "Next Policy"
	// Terminate evaluation of the current policy and begin evaluating the next policy in the policy set. Note that the evaluation of any remaining rules in the
	// current policy is skipped.
	NEXT_POLICY RuleAction = 3
	// LAST_POLICY
	//
	// x-displayName: "Last Policy"
	// Terminate evaluation of the current policy and begin evaluating the last policy in the policy set. Note that the evaluation of any remaining rules in the
	// current policy is skipped.
	LAST_POLICY RuleAction = 4
	// GOTO_POLICY
	//
	// x-displayName: "Goto Policy"
	// Terminate evaluation of the current policy and begin evaluating a specific policy in the policy set. The policy is specified using the goto_policy field in
	// the rule and must be after the current policy in the policy set.
	GOTO_POLICY RuleAction = 5
)

var RuleAction_name = map[int32]string{
	0: "DENY",
	1: "ALLOW",
	2: "NEXT_POLICY_SET",
	3: "NEXT_POLICY",
	4: "LAST_POLICY",
	5: "GOTO_POLICY",
}

var RuleAction_value = map[string]int32{
	"DENY":            0,
	"ALLOW":           1,
	"NEXT_POLICY_SET": 2,
	"NEXT_POLICY":     3,
	"LAST_POLICY":     4,
	"GOTO_POLICY":     5,
}

func (RuleAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{6}
}

// Challenge Action
//
// x-displayName: "Challenge Action"
// The challenge options to use when a policy based challenge is configured.
type ChallengeAction int32

const (
	// DEFAULT_CHALLENGE
	//
	// x-displayName: "Default Challenge"
	// Default challenge.
	DEFAULT_CHALLENGE ChallengeAction = 0
	// ENABLE_JAVASCRIPT_CHALLENGE
	//
	// x-displayName: "Enable Javascript Challenge"
	// Enable javascript challenge.
	ENABLE_JAVASCRIPT_CHALLENGE ChallengeAction = 1
	// ENABLE_CAPTCHA_CHALLENGE
	//
	// x-displayName: "Enable Captcha Challenge"
	// Captcha challenge.
	ENABLE_CAPTCHA_CHALLENGE ChallengeAction = 2
	// DISABLE_CHALLENGE
	//
	// x-displayName: "Disable Challenge"
	// Disable challenge
	DISABLE_CHALLENGE ChallengeAction = 3
	// TEMPORARY_BLOCKING
	//
	// x-displayName: "Block Temporarily"
	// Block the user temporarily.
	TEMPORARY_BLOCKING ChallengeAction = 4
)

var ChallengeAction_name = map[int32]string{
	0: "DEFAULT_CHALLENGE",
	1: "ENABLE_JAVASCRIPT_CHALLENGE",
	2: "ENABLE_CAPTCHA_CHALLENGE",
	3: "DISABLE_CHALLENGE",
	4: "TEMPORARY_BLOCKING",
}

var ChallengeAction_value = map[string]int32{
	"DEFAULT_CHALLENGE":           0,
	"ENABLE_JAVASCRIPT_CHALLENGE": 1,
	"ENABLE_CAPTCHA_CHALLENGE":    2,
	"DISABLE_CHALLENGE":           3,
	"TEMPORARY_BLOCKING":          4,
}

func (ChallengeAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{7}
}

// App Firewall Rule Control
//
// x-displayName: "App Firewall Rule Control"
// App Firewall rule changes to be applied for this request
type WafRuleControl struct {
	// Exclude Rule IDs
	//
	// x-displayName: "Exclude App Firewall Rule List"
	// App Firewall Rule List specifying the rule IDs to be excluded for this request
	ExcludeRuleIds []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=exclude_rule_ids,json=excludeRuleIds,proto3" json:"exclude_rule_ids,omitempty"`
	// Set App Firewall in Monitoring Mode
	//
	// x-displayName: "Set App Firewall in Monitoring Mode"
	// App Firewall will run in monitoring mode without blocking the request
	MonitoringMode bool `protobuf:"varint,2,opt,name=monitoring_mode,json=monitoringMode,proto3" json:"monitoring_mode,omitempty"`
}

func (m *WafRuleControl) Reset()      { *m = WafRuleControl{} }
func (*WafRuleControl) ProtoMessage() {}
func (*WafRuleControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{0}
}
func (m *WafRuleControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WafRuleControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WafRuleControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WafRuleControl.Merge(m, src)
}
func (m *WafRuleControl) XXX_Size() int {
	return m.Size()
}
func (m *WafRuleControl) XXX_DiscardUnknown() {
	xxx_messageInfo_WafRuleControl.DiscardUnknown(m)
}

var xxx_messageInfo_WafRuleControl proto.InternalMessageInfo

func (m *WafRuleControl) GetExcludeRuleIds() []*schema.ObjectRefType {
	if m != nil {
		return m.ExcludeRuleIds
	}
	return nil
}

func (m *WafRuleControl) GetMonitoringMode() bool {
	if m != nil {
		return m.MonitoringMode
	}
	return false
}

// App Firewall Rule Control with inline Rule IDs
//
// x-displayName: "App Firewall Rule Control with inline Rule IDs"
// App Firewall rule changes to be applied for this request
type WafInlineRuleControl struct {
	// Exclude Rule IDs
	//
	// x-displayName: "Exclude App Firewall Rule IDs"
	// App Firewall Rule IDs to be excluded for this request
	ExcludeRuleIds []waf_rule_list.WafRuleID `protobuf:"varint,1,rep,packed,name=exclude_rule_ids,json=excludeRuleIds,proto3,enum=ves.io.schema.waf_rule_list.WafRuleID" json:"exclude_rule_ids,omitempty"`
	// Set App Firewall in Monitoring Mode
	//
	// x-displayName: "Set App Firewall in Monitoring Mode"
	// App Firewall will run in monitoring mode without blocking the request
	MonitoringMode bool `protobuf:"varint,2,opt,name=monitoring_mode,json=monitoringMode,proto3" json:"monitoring_mode,omitempty"`
}

func (m *WafInlineRuleControl) Reset()      { *m = WafInlineRuleControl{} }
func (*WafInlineRuleControl) ProtoMessage() {}
func (*WafInlineRuleControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{1}
}
func (m *WafInlineRuleControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WafInlineRuleControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WafInlineRuleControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WafInlineRuleControl.Merge(m, src)
}
func (m *WafInlineRuleControl) XXX_Size() int {
	return m.Size()
}
func (m *WafInlineRuleControl) XXX_DiscardUnknown() {
	xxx_messageInfo_WafInlineRuleControl.DiscardUnknown(m)
}

var xxx_messageInfo_WafInlineRuleControl proto.InternalMessageInfo

func (m *WafInlineRuleControl) GetExcludeRuleIds() []waf_rule_list.WafRuleID {
	if m != nil {
		return m.ExcludeRuleIds
	}
	return nil
}

func (m *WafInlineRuleControl) GetMonitoringMode() bool {
	if m != nil {
		return m.MonitoringMode
	}
	return false
}

// App Firewall Action
//
// x-displayName: "App Firewall Action"
// Modify App Firewall behavior for a matching request. The modification could either be to entirely skip firewall processing or to customize the firewall rules
// to be applied as defined by App Firewall Rule Control settings.
type WafAction struct {
	// Select Waf Action Type
	//
	// x-displayName: "Select App Firewall Action Type"
	// x-required
	// Select application firewall Action, skip waf processing or skip rules
	//
	// Types that are valid to be assigned to ActionType:
	//	*WafAction_None
	//	*WafAction_WafSkipProcessing
	//	*WafAction_WafRuleControl
	//	*WafAction_WafInlineRuleControl
	//	*WafAction_WafInMonitoringMode
	ActionType isWafAction_ActionType `protobuf_oneof:"action_type"`
}

func (m *WafAction) Reset()      { *m = WafAction{} }
func (*WafAction) ProtoMessage() {}
func (*WafAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{2}
}
func (m *WafAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WafAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WafAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WafAction.Merge(m, src)
}
func (m *WafAction) XXX_Size() int {
	return m.Size()
}
func (m *WafAction) XXX_DiscardUnknown() {
	xxx_messageInfo_WafAction.DiscardUnknown(m)
}

var xxx_messageInfo_WafAction proto.InternalMessageInfo

type isWafAction_ActionType interface {
	isWafAction_ActionType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type WafAction_None struct {
	None *schema.Empty `protobuf:"bytes,3,opt,name=none,proto3,oneof" json:"none,omitempty"`
}
type WafAction_WafSkipProcessing struct {
	WafSkipProcessing *schema.Empty `protobuf:"bytes,1,opt,name=waf_skip_processing,json=wafSkipProcessing,proto3,oneof" json:"waf_skip_processing,omitempty"`
}
type WafAction_WafRuleControl struct {
	WafRuleControl *WafRuleControl `protobuf:"bytes,2,opt,name=waf_rule_control,json=wafRuleControl,proto3,oneof" json:"waf_rule_control,omitempty"`
}
type WafAction_WafInlineRuleControl struct {
	WafInlineRuleControl *WafInlineRuleControl `protobuf:"bytes,4,opt,name=waf_inline_rule_control,json=wafInlineRuleControl,proto3,oneof" json:"waf_inline_rule_control,omitempty"`
}
type WafAction_WafInMonitoringMode struct {
	WafInMonitoringMode *schema.Empty `protobuf:"bytes,6,opt,name=waf_in_monitoring_mode,json=wafInMonitoringMode,proto3,oneof" json:"waf_in_monitoring_mode,omitempty"`
}

func (*WafAction_None) isWafAction_ActionType()                 {}
func (*WafAction_WafSkipProcessing) isWafAction_ActionType()    {}
func (*WafAction_WafRuleControl) isWafAction_ActionType()       {}
func (*WafAction_WafInlineRuleControl) isWafAction_ActionType() {}
func (*WafAction_WafInMonitoringMode) isWafAction_ActionType()  {}

func (m *WafAction) GetActionType() isWafAction_ActionType {
	if m != nil {
		return m.ActionType
	}
	return nil
}

func (m *WafAction) GetNone() *schema.Empty {
	if x, ok := m.GetActionType().(*WafAction_None); ok {
		return x.None
	}
	return nil
}

func (m *WafAction) GetWafSkipProcessing() *schema.Empty {
	if x, ok := m.GetActionType().(*WafAction_WafSkipProcessing); ok {
		return x.WafSkipProcessing
	}
	return nil
}

func (m *WafAction) GetWafRuleControl() *WafRuleControl {
	if x, ok := m.GetActionType().(*WafAction_WafRuleControl); ok {
		return x.WafRuleControl
	}
	return nil
}

func (m *WafAction) GetWafInlineRuleControl() *WafInlineRuleControl {
	if x, ok := m.GetActionType().(*WafAction_WafInlineRuleControl); ok {
		return x.WafInlineRuleControl
	}
	return nil
}

func (m *WafAction) GetWafInMonitoringMode() *schema.Empty {
	if x, ok := m.GetActionType().(*WafAction_WafInMonitoringMode); ok {
		return x.WafInMonitoringMode
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*WafAction) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*WafAction_None)(nil),
		(*WafAction_WafSkipProcessing)(nil),
		(*WafAction_WafRuleControl)(nil),
		(*WafAction_WafInlineRuleControl)(nil),
		(*WafAction_WafInMonitoringMode)(nil),
	}
}

// Prefix Match List
//
// x-displayName: "IP Prefix Match List"
// List of IPv4 Prefix strings to match against.
type PrefixMatchList struct {
	// ip prefixes
	//
	// x-displayName: "IP Prefix List"
	// x-example: "192.168.20.0/24"
	// x-required
	// List of IPv4 prefix strings.
	IpPrefixes []string `protobuf:"bytes,1,rep,name=ip_prefixes,json=ipPrefixes,proto3" json:"ip_prefixes,omitempty"`
	// invert_matcher
	//
	// x-displayName: "Invert Match Result"
	// Invert the match result.
	InvertMatch bool `protobuf:"varint,2,opt,name=invert_match,json=invertMatch,proto3" json:"invert_match,omitempty"`
}

func (m *PrefixMatchList) Reset()      { *m = PrefixMatchList{} }
func (*PrefixMatchList) ProtoMessage() {}
func (*PrefixMatchList) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{3}
}
func (m *PrefixMatchList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrefixMatchList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PrefixMatchList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrefixMatchList.Merge(m, src)
}
func (m *PrefixMatchList) XXX_Size() int {
	return m.Size()
}
func (m *PrefixMatchList) XXX_DiscardUnknown() {
	xxx_messageInfo_PrefixMatchList.DiscardUnknown(m)
}

var xxx_messageInfo_PrefixMatchList proto.InternalMessageInfo

func (m *PrefixMatchList) GetIpPrefixes() []string {
	if m != nil {
		return m.IpPrefixes
	}
	return nil
}

func (m *PrefixMatchList) GetInvertMatch() bool {
	if m != nil {
		return m.InvertMatch
	}
	return false
}

// Asn Match List
//
// x-displayName: "ASN Match List"
// An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy.
type AsnMatchList struct {
	// as numbers
	//
	// x-displayName: "AS Numbers"
	// x-example: "[713, 7932, 847325, 4683, 15269, 1000001]"
	// x-required
	// An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy.
	AsNumbers []uint32 `protobuf:"varint,1,rep,packed,name=as_numbers,json=asNumbers,proto3" json:"as_numbers,omitempty"`
}

func (m *AsnMatchList) Reset()      { *m = AsnMatchList{} }
func (*AsnMatchList) ProtoMessage() {}
func (*AsnMatchList) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{4}
}
func (m *AsnMatchList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AsnMatchList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AsnMatchList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AsnMatchList.Merge(m, src)
}
func (m *AsnMatchList) XXX_Size() int {
	return m.Size()
}
func (m *AsnMatchList) XXX_DiscardUnknown() {
	xxx_messageInfo_AsnMatchList.DiscardUnknown(m)
}

var xxx_messageInfo_AsnMatchList proto.InternalMessageInfo

func (m *AsnMatchList) GetAsNumbers() []uint32 {
	if m != nil {
		return m.AsNumbers
	}
	return nil
}

// SimpleWafExclusionRule
//
// x-displayName: "Simple WAF Exclusion Rule"
// Simple WAF exclusion rule specifies a simple set of match conditions to be matched to skip a list of WAF rule ids
type SimpleWafExclusionRule struct {
	// Domain
	//
	// x-displayName: "Domain"
	// x-example: "mybloggingwebsite.org"
	// x-required
	// Domain to be matched
	//
	// Types that are valid to be assigned to DomainChoice:
	//	*SimpleWafExclusionRule_AnyDomain
	//	*SimpleWafExclusionRule_DomainRegex
	DomainChoice isSimpleWafExclusionRule_DomainChoice `protobuf_oneof:"domain_choice"`
	// Path Regex
	//
	// x-displayName: "Path Regex"
	// x-example: "/blog_id/.*"
	// x-required
	// path regex to be matched
	PathRegex string `protobuf:"bytes,6,opt,name=path_regex,json=pathRegex,proto3" json:"path_regex,omitempty"`
	// Methods
	//
	// x-displayName: "Methods"
	// x-example: "GET"
	// methods to be matched
	Methods []schema.HttpMethod `protobuf:"varint,7,rep,packed,name=methods,proto3,enum=ves.io.schema.HttpMethod" json:"methods,omitempty"`
	// Exclude WAF Rules
	//
	// x-displayName: "Exclude WAF Rules"
	// x-example: "[942260, 942200]"
	// x-required
	// WAF Rules to be excluded when match conditions are met
	ExcludeRuleIds []waf_rule_list.WafRuleID `protobuf:"varint,8,rep,packed,name=exclude_rule_ids,json=excludeRuleIds,proto3,enum=ves.io.schema.waf_rule_list.WafRuleID" json:"exclude_rule_ids,omitempty"`
	// expiration timestamp
	//
	// x-displayName: "Expiration Timestamp"
	// x-example: "2019-12-31:44:34.171543432Z"
	// The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in
	// the configuration but is not applied anymore.
	ExpirationTimestamp *types.Timestamp `protobuf:"bytes,9,opt,name=expiration_timestamp,json=expirationTimestamp,proto3" json:"expiration_timestamp,omitempty"`
	// metadata
	//
	// x-displayName: "Metadata"
	// x-required
	// Common attributes for the rule including name and description.
	Metadata *schema.MessageMetaType `protobuf:"bytes,10,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *SimpleWafExclusionRule) Reset()      { *m = SimpleWafExclusionRule{} }
func (*SimpleWafExclusionRule) ProtoMessage() {}
func (*SimpleWafExclusionRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{5}
}
func (m *SimpleWafExclusionRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimpleWafExclusionRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SimpleWafExclusionRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimpleWafExclusionRule.Merge(m, src)
}
func (m *SimpleWafExclusionRule) XXX_Size() int {
	return m.Size()
}
func (m *SimpleWafExclusionRule) XXX_DiscardUnknown() {
	xxx_messageInfo_SimpleWafExclusionRule.DiscardUnknown(m)
}

var xxx_messageInfo_SimpleWafExclusionRule proto.InternalMessageInfo

type isSimpleWafExclusionRule_DomainChoice interface {
	isSimpleWafExclusionRule_DomainChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type SimpleWafExclusionRule_AnyDomain struct {
	AnyDomain *schema.Empty `protobuf:"bytes,4,opt,name=any_domain,json=anyDomain,proto3,oneof" json:"any_domain,omitempty"`
}
type SimpleWafExclusionRule_DomainRegex struct {
	DomainRegex string `protobuf:"bytes,5,opt,name=domain_regex,json=domainRegex,proto3,oneof" json:"domain_regex,omitempty"`
}

func (*SimpleWafExclusionRule_AnyDomain) isSimpleWafExclusionRule_DomainChoice()   {}
func (*SimpleWafExclusionRule_DomainRegex) isSimpleWafExclusionRule_DomainChoice() {}

func (m *SimpleWafExclusionRule) GetDomainChoice() isSimpleWafExclusionRule_DomainChoice {
	if m != nil {
		return m.DomainChoice
	}
	return nil
}

func (m *SimpleWafExclusionRule) GetAnyDomain() *schema.Empty {
	if x, ok := m.GetDomainChoice().(*SimpleWafExclusionRule_AnyDomain); ok {
		return x.AnyDomain
	}
	return nil
}

func (m *SimpleWafExclusionRule) GetDomainRegex() string {
	if x, ok := m.GetDomainChoice().(*SimpleWafExclusionRule_DomainRegex); ok {
		return x.DomainRegex
	}
	return ""
}

func (m *SimpleWafExclusionRule) GetPathRegex() string {
	if m != nil {
		return m.PathRegex
	}
	return ""
}

func (m *SimpleWafExclusionRule) GetMethods() []schema.HttpMethod {
	if m != nil {
		return m.Methods
	}
	return nil
}

func (m *SimpleWafExclusionRule) GetExcludeRuleIds() []waf_rule_list.WafRuleID {
	if m != nil {
		return m.ExcludeRuleIds
	}
	return nil
}

func (m *SimpleWafExclusionRule) GetExpirationTimestamp() *types.Timestamp {
	if m != nil {
		return m.ExpirationTimestamp
	}
	return nil
}

func (m *SimpleWafExclusionRule) GetMetadata() *schema.MessageMetaType {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SimpleWafExclusionRule) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SimpleWafExclusionRule_AnyDomain)(nil),
		(*SimpleWafExclusionRule_DomainRegex)(nil),
	}
}

// Deny Information
//
// x-displayName: "Deny Information"
// Detailed information including HTTP response code and error message to be sent when the policy or policy set action is DENY.
type DenyInformation struct {
	// response_code
	//
	// x-displayName: "HTTP Response Code"
	// x-example: 400
	// The HTTP status code to use in the response. The default code is Forbidden (403).
	ResponseCode uint32 `protobuf:"varint,1,opt,name=response_code,json=responseCode,proto3" json:"response_code,omitempty"`
	// error_message
	//
	// x-displayName: "Error Message"
	// x-example: "Denied because the URL path contains an unknown object type"
	// An error message associated with a DENY action in a policy or policy set, that is meaningful to the end user. Note that this error message is included
	// in the body but does not constitute the entire body.
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *DenyInformation) Reset()      { *m = DenyInformation{} }
func (*DenyInformation) ProtoMessage() {}
func (*DenyInformation) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{6}
}
func (m *DenyInformation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DenyInformation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DenyInformation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DenyInformation.Merge(m, src)
}
func (m *DenyInformation) XXX_Size() int {
	return m.Size()
}
func (m *DenyInformation) XXX_DiscardUnknown() {
	xxx_messageInfo_DenyInformation.DiscardUnknown(m)
}

var xxx_messageInfo_DenyInformation proto.InternalMessageInfo

func (m *DenyInformation) GetResponseCode() uint32 {
	if m != nil {
		return m.ResponseCode
	}
	return 0
}

func (m *DenyInformation) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

// TlsFingerprintMatcherType
//
// x-displayName: "TLS Fingerprint Matcher"
// A TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known
// classes of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied and the input
// fingerprint is not one of the excluded values.
type TlsFingerprintMatcherType struct {
	// classes
	//
	// x-displayName: "TLS fingerprint classes"
	// x-example: "['ADWARE', 'TRICKBOT']
	// A list of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against.
	Classes []KnownTlsFingerprintClass `protobuf:"varint,1,rep,packed,name=classes,proto3,enum=ves.io.schema.policy.KnownTlsFingerprintClass" json:"classes,omitempty"`
	// exact values
	//
	// x-displayName: "Exact Values"
	// x-example: "['ed6dfd54b01ebe31b7a65b88abfa7297', '16efcf0e00504ddfedde13bfea997952', 'de364c46b0dfc283b5e38c79ceae3f8f']"
	// A list of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.
	ExactValues []string `protobuf:"bytes,2,rep,name=exact_values,json=exactValues,proto3" json:"exact_values,omitempty"`
	// excluded values
	//
	// x-displayName: "Excluded Values"
	// x-example: "['fb00055a1196aeea8d1bc609885ba953', 'b386946a5a44d1ddcc843bc75336dfce']"
	// A list of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one
	// or more known TLS fingerprint classes in the enclosing matcher.
	ExcludedValues []string `protobuf:"bytes,3,rep,name=excluded_values,json=excludedValues,proto3" json:"excluded_values,omitempty"`
}

func (m *TlsFingerprintMatcherType) Reset()      { *m = TlsFingerprintMatcherType{} }
func (*TlsFingerprintMatcherType) ProtoMessage() {}
func (*TlsFingerprintMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{7}
}
func (m *TlsFingerprintMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TlsFingerprintMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TlsFingerprintMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TlsFingerprintMatcherType.Merge(m, src)
}
func (m *TlsFingerprintMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *TlsFingerprintMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_TlsFingerprintMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_TlsFingerprintMatcherType proto.InternalMessageInfo

func (m *TlsFingerprintMatcherType) GetClasses() []KnownTlsFingerprintClass {
	if m != nil {
		return m.Classes
	}
	return nil
}

func (m *TlsFingerprintMatcherType) GetExactValues() []string {
	if m != nil {
		return m.ExactValues
	}
	return nil
}

func (m *TlsFingerprintMatcherType) GetExcludedValues() []string {
	if m != nil {
		return m.ExcludedValues
	}
	return nil
}

// PathMatcherType
//
// x-displayName: "Path Matcher"
// A path matcher specifies multiple criteria for matching an HTTP path string. The match is considered successful if any of the criteria are satisfied. The set
// of supported match criteria includes a list of path prefixes, a list of exact path values and a list of regular expressions.
type PathMatcherType struct {
	// prefix values
	//
	// x-displayName: "Prefix Values"
	// x-example: "['/api/web/namespaces/project179/users/', '/api/config/namespaces/', '/api/data/namespaces/']"
	// A list of path prefix values to match the input HTTP path against.
	PrefixValues []string `protobuf:"bytes,1,rep,name=prefix_values,json=prefixValues,proto3" json:"prefix_values,omitempty"`
	// exact values
	//
	// x-displayName: "Exact Values"
	// x-example: "['/api/web/namespaces/project179/users/user1', '/api/config/namespaces/accounting/bgps', '/api/data/namespaces/project443/virtual_host_101']"
	// A list of exact path values to match the input HTTP path against.
	ExactValues []string `protobuf:"bytes,2,rep,name=exact_values,json=exactValues,proto3" json:"exact_values,omitempty"`
	// regex values
	//
	// x-displayName: "Regex Values"
	// x-example: "['^/api/web/namespaces/abc/users/([a-z]([-a-z0-9]*[a-z0-9])?)$', '/api/data/namespaces/proj404/virtual_hosts/([a-z]([-a-z0-9]*[a-z0-9])?)$']"
	// A list of regular expressions to match the input HTTP path against.
	RegexValues []string `protobuf:"bytes,3,rep,name=regex_values,json=regexValues,proto3" json:"regex_values,omitempty"`
	// transformers
	//
	// x-displayName: "Transformers"
	// x-example: "[BASE64_DECODE, LOWER_CASE]
	// An ordered list of transformers (starting from index 0) to be applied to the path before matching.
	Transformers []Transformer `protobuf:"varint,4,rep,packed,name=transformers,proto3,enum=ves.io.schema.policy.Transformer" json:"transformers,omitempty"`
}

func (m *PathMatcherType) Reset()      { *m = PathMatcherType{} }
func (*PathMatcherType) ProtoMessage() {}
func (*PathMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{8}
}
func (m *PathMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PathMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PathMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PathMatcherType.Merge(m, src)
}
func (m *PathMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *PathMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_PathMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_PathMatcherType proto.InternalMessageInfo

func (m *PathMatcherType) GetPrefixValues() []string {
	if m != nil {
		return m.PrefixValues
	}
	return nil
}

func (m *PathMatcherType) GetExactValues() []string {
	if m != nil {
		return m.ExactValues
	}
	return nil
}

func (m *PathMatcherType) GetRegexValues() []string {
	if m != nil {
		return m.RegexValues
	}
	return nil
}

func (m *PathMatcherType) GetTransformers() []Transformer {
	if m != nil {
		return m.Transformers
	}
	return nil
}

// MatcherType
//
// x-displayName: "Matcher"
// A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set
// of supported match criteria includes a list of exact values and a list of regular expressions.
type MatcherType struct {
	// exact values
	//
	// x-displayName: "Exact Values"
	// x-example: "['new york', 'london', 'sydney', 'tokyo', 'cairo']"
	// A list of exact values to match the input against.
	ExactValues []string `protobuf:"bytes,1,rep,name=exact_values,json=exactValues,proto3" json:"exact_values,omitempty"`
	// regex values
	//
	// x-displayName: "Regex Values"
	// x-example: "['^new .*$', 'san f.*', '.* del .*']"
	// A list of regular expressions to match the input against.
	RegexValues []string `protobuf:"bytes,2,rep,name=regex_values,json=regexValues,proto3" json:"regex_values,omitempty"`
	// transformers
	//
	// x-displayName: "Transformers"
	// x-example: "[BASE64_DECODE, LOWER_CASE]
	// An ordered list of transformers (starting from index 0) to be applied to the path before matching.
	Transformers []Transformer `protobuf:"varint,3,rep,packed,name=transformers,proto3,enum=ves.io.schema.policy.Transformer" json:"transformers,omitempty"`
}

func (m *MatcherType) Reset()      { *m = MatcherType{} }
func (*MatcherType) ProtoMessage() {}
func (*MatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{9}
}
func (m *MatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatcherType.Merge(m, src)
}
func (m *MatcherType) XXX_Size() int {
	return m.Size()
}
func (m *MatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_MatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_MatcherType proto.InternalMessageInfo

func (m *MatcherType) GetExactValues() []string {
	if m != nil {
		return m.ExactValues
	}
	return nil
}

func (m *MatcherType) GetRegexValues() []string {
	if m != nil {
		return m.RegexValues
	}
	return nil
}

func (m *MatcherType) GetTransformers() []Transformer {
	if m != nil {
		return m.Transformers
	}
	return nil
}

// MatcherTypeBasic
//
// x-displayName: "Matcher"
// A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set
// of supported match criteria includes a list of exact values and a list of regular expressions.
type MatcherTypeBasic struct {
	// exact values
	//
	// x-displayName: "Exact Values"
	// x-example: "['new york', 'london', 'sydney', 'tokyo', 'cairo']"
	// A list of exact values to match the input against.
	ExactValues []string `protobuf:"bytes,1,rep,name=exact_values,json=exactValues,proto3" json:"exact_values,omitempty"`
	// regex values
	//
	// x-displayName: "Regex Values"
	// x-example: "['^new .*$', 'san f.*', '.* del .*']"
	// A list of regular expressions to match the input against.
	RegexValues []string `protobuf:"bytes,2,rep,name=regex_values,json=regexValues,proto3" json:"regex_values,omitempty"`
}

func (m *MatcherTypeBasic) Reset()      { *m = MatcherTypeBasic{} }
func (*MatcherTypeBasic) ProtoMessage() {}
func (*MatcherTypeBasic) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{10}
}
func (m *MatcherTypeBasic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatcherTypeBasic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MatcherTypeBasic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatcherTypeBasic.Merge(m, src)
}
func (m *MatcherTypeBasic) XXX_Size() int {
	return m.Size()
}
func (m *MatcherTypeBasic) XXX_DiscardUnknown() {
	xxx_messageInfo_MatcherTypeBasic.DiscardUnknown(m)
}

var xxx_messageInfo_MatcherTypeBasic proto.InternalMessageInfo

func (m *MatcherTypeBasic) GetExactValues() []string {
	if m != nil {
		return m.ExactValues
	}
	return nil
}

func (m *MatcherTypeBasic) GetRegexValues() []string {
	if m != nil {
		return m.RegexValues
	}
	return nil
}

// CookieMatcherType
//
// x-displayName: "Cookie Matcher"
// A cookie matcher specifies the name of a single cookie and the criteria to match it. The input has a list of values for each
// cookie in the request.
// A cookie matcher can check for one of the following:
// * Presence or absence of the cookie
// * At least one of the values for the cookie in the request satisfies the MatcherType item
type CookieMatcherType struct {
	// name
	//
	// x-displayName: "Cookie Name"
	// x-example: "Session"
	// x-required
	// A case-sensitive cookie name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// match
	//
	// x-displayName: "Match Options"
	// x-required
	// Select Match Options.
	//
	// Types that are valid to be assigned to Match:
	//	*CookieMatcherType_Presence
	//	*CookieMatcherType_CheckPresent
	//	*CookieMatcherType_CheckNotPresent
	//	*CookieMatcherType_Item
	Match isCookieMatcherType_Match `protobuf_oneof:"match"`
	// invert_matcher
	//
	// x-displayName: "Invert Matcher"
	// Invert Match of the expression defined
	InvertMatcher bool `protobuf:"varint,4,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *CookieMatcherType) Reset()      { *m = CookieMatcherType{} }
func (*CookieMatcherType) ProtoMessage() {}
func (*CookieMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{11}
}
func (m *CookieMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CookieMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CookieMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CookieMatcherType.Merge(m, src)
}
func (m *CookieMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *CookieMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_CookieMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_CookieMatcherType proto.InternalMessageInfo

type isCookieMatcherType_Match interface {
	isCookieMatcherType_Match()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CookieMatcherType_Presence struct {
	Presence bool `protobuf:"varint,2,opt,name=presence,proto3,oneof" json:"presence,omitempty"`
}
type CookieMatcherType_CheckPresent struct {
	CheckPresent *schema.Empty `protobuf:"bytes,7,opt,name=check_present,json=checkPresent,proto3,oneof" json:"check_present,omitempty"`
}
type CookieMatcherType_CheckNotPresent struct {
	CheckNotPresent *schema.Empty `protobuf:"bytes,8,opt,name=check_not_present,json=checkNotPresent,proto3,oneof" json:"check_not_present,omitempty"`
}
type CookieMatcherType_Item struct {
	Item *MatcherType `protobuf:"bytes,3,opt,name=item,proto3,oneof" json:"item,omitempty"`
}

func (*CookieMatcherType_Presence) isCookieMatcherType_Match()        {}
func (*CookieMatcherType_CheckPresent) isCookieMatcherType_Match()    {}
func (*CookieMatcherType_CheckNotPresent) isCookieMatcherType_Match() {}
func (*CookieMatcherType_Item) isCookieMatcherType_Match()            {}

func (m *CookieMatcherType) GetMatch() isCookieMatcherType_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *CookieMatcherType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CookieMatcherType) GetPresence() bool {
	if x, ok := m.GetMatch().(*CookieMatcherType_Presence); ok {
		return x.Presence
	}
	return false
}

func (m *CookieMatcherType) GetCheckPresent() *schema.Empty {
	if x, ok := m.GetMatch().(*CookieMatcherType_CheckPresent); ok {
		return x.CheckPresent
	}
	return nil
}

func (m *CookieMatcherType) GetCheckNotPresent() *schema.Empty {
	if x, ok := m.GetMatch().(*CookieMatcherType_CheckNotPresent); ok {
		return x.CheckNotPresent
	}
	return nil
}

func (m *CookieMatcherType) GetItem() *MatcherType {
	if x, ok := m.GetMatch().(*CookieMatcherType_Item); ok {
		return x.Item
	}
	return nil
}

func (m *CookieMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CookieMatcherType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CookieMatcherType_Presence)(nil),
		(*CookieMatcherType_CheckPresent)(nil),
		(*CookieMatcherType_CheckNotPresent)(nil),
		(*CookieMatcherType_Item)(nil),
	}
}

// ArgMatcherType
//
// x-displayName: "Argument Matcher"
// A argument matcher specifies the name of a single argument in the body and the criteria to match it.
// A argument matcher can check for one of the following:
// * Presence or absence of the argument
// * At least one of the values for the argument in the request satisfies the MatcherType item
type ArgMatcherType struct {
	// name
	//
	// x-displayName: "Argument Name"
	// x-example: "name"
	// x-example: "phones[_]"
	// x-example: "cars.make.toyota.models[1]"
	// x-example: "cars.make.honda.models[_]"
	// x-example: "cars.make[_].models[_]"
	// x-required
	// A case-sensitive JSON path in the HTTP request body.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// match
	//
	// x-displayName: "Match Options"
	// x-required
	// Select Match Options.
	//
	// Types that are valid to be assigned to Match:
	//	*ArgMatcherType_Presence
	//	*ArgMatcherType_CheckPresent
	//	*ArgMatcherType_CheckNotPresent
	//	*ArgMatcherType_Item
	Match isArgMatcherType_Match `protobuf_oneof:"match"`
	// invert_matcher
	//
	// x-displayName: "Invert Matcher"
	// Invert Match of the expression defined
	InvertMatcher bool `protobuf:"varint,4,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *ArgMatcherType) Reset()      { *m = ArgMatcherType{} }
func (*ArgMatcherType) ProtoMessage() {}
func (*ArgMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{12}
}
func (m *ArgMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ArgMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgMatcherType.Merge(m, src)
}
func (m *ArgMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *ArgMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_ArgMatcherType proto.InternalMessageInfo

type isArgMatcherType_Match interface {
	isArgMatcherType_Match()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ArgMatcherType_Presence struct {
	Presence bool `protobuf:"varint,2,opt,name=presence,proto3,oneof" json:"presence,omitempty"`
}
type ArgMatcherType_CheckPresent struct {
	CheckPresent *schema.Empty `protobuf:"bytes,7,opt,name=check_present,json=checkPresent,proto3,oneof" json:"check_present,omitempty"`
}
type ArgMatcherType_CheckNotPresent struct {
	CheckNotPresent *schema.Empty `protobuf:"bytes,8,opt,name=check_not_present,json=checkNotPresent,proto3,oneof" json:"check_not_present,omitempty"`
}
type ArgMatcherType_Item struct {
	Item *MatcherType `protobuf:"bytes,3,opt,name=item,proto3,oneof" json:"item,omitempty"`
}

func (*ArgMatcherType_Presence) isArgMatcherType_Match()        {}
func (*ArgMatcherType_CheckPresent) isArgMatcherType_Match()    {}
func (*ArgMatcherType_CheckNotPresent) isArgMatcherType_Match() {}
func (*ArgMatcherType_Item) isArgMatcherType_Match()            {}

func (m *ArgMatcherType) GetMatch() isArgMatcherType_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *ArgMatcherType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ArgMatcherType) GetPresence() bool {
	if x, ok := m.GetMatch().(*ArgMatcherType_Presence); ok {
		return x.Presence
	}
	return false
}

func (m *ArgMatcherType) GetCheckPresent() *schema.Empty {
	if x, ok := m.GetMatch().(*ArgMatcherType_CheckPresent); ok {
		return x.CheckPresent
	}
	return nil
}

func (m *ArgMatcherType) GetCheckNotPresent() *schema.Empty {
	if x, ok := m.GetMatch().(*ArgMatcherType_CheckNotPresent); ok {
		return x.CheckNotPresent
	}
	return nil
}

func (m *ArgMatcherType) GetItem() *MatcherType {
	if x, ok := m.GetMatch().(*ArgMatcherType_Item); ok {
		return x.Item
	}
	return nil
}

func (m *ArgMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ArgMatcherType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ArgMatcherType_Presence)(nil),
		(*ArgMatcherType_CheckPresent)(nil),
		(*ArgMatcherType_CheckNotPresent)(nil),
		(*ArgMatcherType_Item)(nil),
	}
}

// HeaderMatcherType
//
// x-displayName: "Header Matcher"
// A header matcher specifies the name of a single HTTP header and the criteria for the input request to match it. The input has a list of actual values for each
// header name in the original HTTP request.
// A header matcher can check for one of the following:
// * Presence or absence of the header in the input
// * At least one of the values for the header in the input satisfies the MatcherType item
type HeaderMatcherType struct {
	// name
	//
	// x-displayName: "Header Name"
	// x-example: "Accept-Encoding"
	// x-required
	// A case-insensitive HTTP header name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// match
	//
	// x-displayName: "Match Options"
	// x-required
	// Select Match Options.
	//
	// Types that are valid to be assigned to Match:
	//	*HeaderMatcherType_Presence
	//	*HeaderMatcherType_CheckPresent
	//	*HeaderMatcherType_CheckNotPresent
	//	*HeaderMatcherType_Item
	Match isHeaderMatcherType_Match `protobuf_oneof:"match"`
	// invert_matcher
	//
	// x-displayName: "Invert Header Matcher"
	// Invert the match result.
	InvertMatcher bool `protobuf:"varint,4,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *HeaderMatcherType) Reset()      { *m = HeaderMatcherType{} }
func (*HeaderMatcherType) ProtoMessage() {}
func (*HeaderMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{13}
}
func (m *HeaderMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeaderMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HeaderMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeaderMatcherType.Merge(m, src)
}
func (m *HeaderMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *HeaderMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_HeaderMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_HeaderMatcherType proto.InternalMessageInfo

type isHeaderMatcherType_Match interface {
	isHeaderMatcherType_Match()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type HeaderMatcherType_Presence struct {
	Presence bool `protobuf:"varint,2,opt,name=presence,proto3,oneof" json:"presence,omitempty"`
}
type HeaderMatcherType_CheckPresent struct {
	CheckPresent *schema.Empty `protobuf:"bytes,7,opt,name=check_present,json=checkPresent,proto3,oneof" json:"check_present,omitempty"`
}
type HeaderMatcherType_CheckNotPresent struct {
	CheckNotPresent *schema.Empty `protobuf:"bytes,8,opt,name=check_not_present,json=checkNotPresent,proto3,oneof" json:"check_not_present,omitempty"`
}
type HeaderMatcherType_Item struct {
	Item *MatcherType `protobuf:"bytes,3,opt,name=item,proto3,oneof" json:"item,omitempty"`
}

func (*HeaderMatcherType_Presence) isHeaderMatcherType_Match()        {}
func (*HeaderMatcherType_CheckPresent) isHeaderMatcherType_Match()    {}
func (*HeaderMatcherType_CheckNotPresent) isHeaderMatcherType_Match() {}
func (*HeaderMatcherType_Item) isHeaderMatcherType_Match()            {}

func (m *HeaderMatcherType) GetMatch() isHeaderMatcherType_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *HeaderMatcherType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HeaderMatcherType) GetPresence() bool {
	if x, ok := m.GetMatch().(*HeaderMatcherType_Presence); ok {
		return x.Presence
	}
	return false
}

func (m *HeaderMatcherType) GetCheckPresent() *schema.Empty {
	if x, ok := m.GetMatch().(*HeaderMatcherType_CheckPresent); ok {
		return x.CheckPresent
	}
	return nil
}

func (m *HeaderMatcherType) GetCheckNotPresent() *schema.Empty {
	if x, ok := m.GetMatch().(*HeaderMatcherType_CheckNotPresent); ok {
		return x.CheckNotPresent
	}
	return nil
}

func (m *HeaderMatcherType) GetItem() *MatcherType {
	if x, ok := m.GetMatch().(*HeaderMatcherType_Item); ok {
		return x.Item
	}
	return nil
}

func (m *HeaderMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*HeaderMatcherType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*HeaderMatcherType_Presence)(nil),
		(*HeaderMatcherType_CheckPresent)(nil),
		(*HeaderMatcherType_CheckNotPresent)(nil),
		(*HeaderMatcherType_Item)(nil),
	}
}

// QueryParameterMatcherType
//
// x-displayName: "Query Parameter Matcher"
// A query parameter matcher specifies the name of a single query parameter and the criteria for the input request to match it. The input has a list of actual
// values for each query parameter name in the original HTTP request.
// A query parameter matcher can check for one of the following:
// * Presence or absence of the query parameter in the input
// * At least one of the values for the query parameter in the input satisfies the MatcherType item
type QueryParameterMatcherType struct {
	// key
	//
	// x-displayName: "Query Parameter Name"
	// x-example: "sourceid"
	// x-required
	// A case-sensitive HTTP query parameter name.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// match
	//
	// x-displayName: "Match Options"
	// x-required
	// Select Match Options.
	//
	// Types that are valid to be assigned to Match:
	//	*QueryParameterMatcherType_Presence
	//	*QueryParameterMatcherType_CheckPresent
	//	*QueryParameterMatcherType_CheckNotPresent
	//	*QueryParameterMatcherType_Item
	Match isQueryParameterMatcherType_Match `protobuf_oneof:"match"`
	// invert_matcher
	//
	// x-displayName: "Invert Query Parameter Matcher"
	// Invert the match result.
	InvertMatcher bool `protobuf:"varint,4,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *QueryParameterMatcherType) Reset()      { *m = QueryParameterMatcherType{} }
func (*QueryParameterMatcherType) ProtoMessage() {}
func (*QueryParameterMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{14}
}
func (m *QueryParameterMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryParameterMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *QueryParameterMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryParameterMatcherType.Merge(m, src)
}
func (m *QueryParameterMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *QueryParameterMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryParameterMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_QueryParameterMatcherType proto.InternalMessageInfo

type isQueryParameterMatcherType_Match interface {
	isQueryParameterMatcherType_Match()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type QueryParameterMatcherType_Presence struct {
	Presence bool `protobuf:"varint,2,opt,name=presence,proto3,oneof" json:"presence,omitempty"`
}
type QueryParameterMatcherType_CheckPresent struct {
	CheckPresent *schema.Empty `protobuf:"bytes,7,opt,name=check_present,json=checkPresent,proto3,oneof" json:"check_present,omitempty"`
}
type QueryParameterMatcherType_CheckNotPresent struct {
	CheckNotPresent *schema.Empty `protobuf:"bytes,8,opt,name=check_not_present,json=checkNotPresent,proto3,oneof" json:"check_not_present,omitempty"`
}
type QueryParameterMatcherType_Item struct {
	Item *MatcherType `protobuf:"bytes,3,opt,name=item,proto3,oneof" json:"item,omitempty"`
}

func (*QueryParameterMatcherType_Presence) isQueryParameterMatcherType_Match()        {}
func (*QueryParameterMatcherType_CheckPresent) isQueryParameterMatcherType_Match()    {}
func (*QueryParameterMatcherType_CheckNotPresent) isQueryParameterMatcherType_Match() {}
func (*QueryParameterMatcherType_Item) isQueryParameterMatcherType_Match()            {}

func (m *QueryParameterMatcherType) GetMatch() isQueryParameterMatcherType_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *QueryParameterMatcherType) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *QueryParameterMatcherType) GetPresence() bool {
	if x, ok := m.GetMatch().(*QueryParameterMatcherType_Presence); ok {
		return x.Presence
	}
	return false
}

func (m *QueryParameterMatcherType) GetCheckPresent() *schema.Empty {
	if x, ok := m.GetMatch().(*QueryParameterMatcherType_CheckPresent); ok {
		return x.CheckPresent
	}
	return nil
}

func (m *QueryParameterMatcherType) GetCheckNotPresent() *schema.Empty {
	if x, ok := m.GetMatch().(*QueryParameterMatcherType_CheckNotPresent); ok {
		return x.CheckNotPresent
	}
	return nil
}

func (m *QueryParameterMatcherType) GetItem() *MatcherType {
	if x, ok := m.GetMatch().(*QueryParameterMatcherType_Item); ok {
		return x.Item
	}
	return nil
}

func (m *QueryParameterMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*QueryParameterMatcherType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*QueryParameterMatcherType_Presence)(nil),
		(*QueryParameterMatcherType_CheckPresent)(nil),
		(*QueryParameterMatcherType_CheckNotPresent)(nil),
		(*QueryParameterMatcherType_Item)(nil),
	}
}

// HttpMethodMatcherType
//
// x-displayName: "HTTP Method Matcher"
// A http method matcher specifies a list of methods to match an input HTTP method. The match is considered successful if the input method is a member of the list.
// The result of the match based on the method list is inverted if invert_matcher is true.
type HttpMethodMatcherType struct {
	// methods
	//
	// x-displayName: "Method List"
	// List of methods values to match against.
	// x-example: "['GET', 'POST', 'DELETE']"
	Methods []schema.HttpMethod `protobuf:"varint,1,rep,packed,name=methods,proto3,enum=ves.io.schema.HttpMethod" json:"methods,omitempty"`
	// invert_matcher
	//
	// x-displayName: "Invert Method Matcher"
	// Invert the match result.
	InvertMatcher bool `protobuf:"varint,2,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *HttpMethodMatcherType) Reset()      { *m = HttpMethodMatcherType{} }
func (*HttpMethodMatcherType) ProtoMessage() {}
func (*HttpMethodMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{15}
}
func (m *HttpMethodMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpMethodMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HttpMethodMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpMethodMatcherType.Merge(m, src)
}
func (m *HttpMethodMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *HttpMethodMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpMethodMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_HttpMethodMatcherType proto.InternalMessageInfo

func (m *HttpMethodMatcherType) GetMethods() []schema.HttpMethod {
	if m != nil {
		return m.Methods
	}
	return nil
}

func (m *HttpMethodMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// RoleMatcherType
//
// x-displayName: "Role Matcher"
// A role matcher specifies a single value for matching an input list of roles. The match is considered successful if the specified value is present in the input
// list.
type RoleMatcherType struct {
	// match
	//
	// x-displayName: "Role"
	// x-required
	// x-example: "ves-io-monitor-role"
	// x-example: "ves-io-uam-role"
	// x-example: "custom-role-security-czar'"
	// Value of the expected role.
	Match string `protobuf:"bytes,1,opt,name=match,proto3" json:"match,omitempty"`
}

func (m *RoleMatcherType) Reset()      { *m = RoleMatcherType{} }
func (*RoleMatcherType) ProtoMessage() {}
func (*RoleMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{16}
}
func (m *RoleMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RoleMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleMatcherType.Merge(m, src)
}
func (m *RoleMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *RoleMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_RoleMatcherType proto.InternalMessageInfo

func (m *RoleMatcherType) GetMatch() string {
	if m != nil {
		return m.Match
	}
	return ""
}

// StringMatcherType
//
// x-displayName: "String Matcher"
// A matcher specifies a list of values for matching an input string. The match is considered successful if the input value is present in the list. The result of
// the match is inverted if invert_matcher is true.
type StringMatcherType struct {
	// match
	//
	// x-displayName: "Exact Values"
	// x-required
	// x-example: "['new york', 'london', 'sydney', 'tokyo', 'cairo']"
	// A list of exact values to match the input against.
	Match []string `protobuf:"bytes,1,rep,name=match,proto3" json:"match,omitempty"`
	// invert_matcher
	//
	// x-displayName: "Invert String Matcher"
	// Invert the match result.
	InvertMatcher bool `protobuf:"varint,2,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *StringMatcherType) Reset()      { *m = StringMatcherType{} }
func (*StringMatcherType) ProtoMessage() {}
func (*StringMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{17}
}
func (m *StringMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StringMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringMatcherType.Merge(m, src)
}
func (m *StringMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *StringMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_StringMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_StringMatcherType proto.InternalMessageInfo

func (m *StringMatcherType) GetMatch() []string {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *StringMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// ip matcher type
//
// x-displayName: "IP Prefix Matcher"
// Match any ip prefix contained in the list of ip_prefix_sets.
// The result of the match is inverted if invert_matcher is true.
type IpMatcherType struct {
	// prefix_sets
	//
	// x-displayName: "IP Prefix Sets"
	// x-required
	// A list of references to ip_prefix_set objects.
	PrefixSets []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=prefix_sets,json=prefixSets,proto3" json:"prefix_sets,omitempty"`
	// invert_matcher
	//
	// x-displayName: "Invert IP Matcher"
	// Invert the match result.
	InvertMatcher bool `protobuf:"varint,2,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *IpMatcherType) Reset()      { *m = IpMatcherType{} }
func (*IpMatcherType) ProtoMessage() {}
func (*IpMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{18}
}
func (m *IpMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IpMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpMatcherType.Merge(m, src)
}
func (m *IpMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *IpMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_IpMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_IpMatcherType proto.InternalMessageInfo

func (m *IpMatcherType) GetPrefixSets() []*schema.ObjectRefType {
	if m != nil {
		return m.PrefixSets
	}
	return nil
}

func (m *IpMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// asn matcher type
//
// x-displayName: "ASN Matcher"
// Match any AS number contained in the list of bgp_asn_sets.
type AsnMatcherType struct {
	// asn_sets
	//
	// x-displayName: "BGP ASN Sets"
	// x-required
	// A list of references to bgp_asn_set objects.
	AsnSets []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=asn_sets,json=asnSets,proto3" json:"asn_sets,omitempty"`
}

func (m *AsnMatcherType) Reset()      { *m = AsnMatcherType{} }
func (*AsnMatcherType) ProtoMessage() {}
func (*AsnMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{19}
}
func (m *AsnMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AsnMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AsnMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AsnMatcherType.Merge(m, src)
}
func (m *AsnMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *AsnMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_AsnMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_AsnMatcherType proto.InternalMessageInfo

func (m *AsnMatcherType) GetAsnSets() []*schema.ObjectRefType {
	if m != nil {
		return m.AsnSets
	}
	return nil
}

// port matcher type
//
// x-displayName: "Port Matcher"
// A port matcher specifies a list of port ranges as match criteria. The match is considered successful if the input port falls within any of the port ranges.
// The result of the match is inverted if invert_matcher is true.
type PortMatcherType struct {
	// port ranges
	//
	// x-displayName: "Port Ranges"
	// x-required
	// x-example: "8000-8191"
	// A list of strings, each of which is a single port value or a tuple of start and end port values separated by "-". The start and end values are considered
	// to be part of the range.
	Ports []string `protobuf:"bytes,1,rep,name=ports,proto3" json:"ports,omitempty"`
	// invert_matcher
	//
	// x-displayName: "Invert Port Matcher"
	// Invert the match result.
	InvertMatcher bool `protobuf:"varint,2,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *PortMatcherType) Reset()      { *m = PortMatcherType{} }
func (*PortMatcherType) ProtoMessage() {}
func (*PortMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{20}
}
func (m *PortMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PortMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortMatcherType.Merge(m, src)
}
func (m *PortMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *PortMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_PortMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_PortMatcherType proto.InternalMessageInfo

func (m *PortMatcherType) GetPorts() []string {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *PortMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// url item
//
// x-displayName: "URL Item"
// A URL item specifies exact or regular expression match criteria for the domain and path.
type URLItem struct {
	// domain choice
	//
	// x-displayName: "Domain Match"
	// x-required
	// Select Domain Match.
	//
	// Types that are valid to be assigned to DomainChoice:
	//	*URLItem_DomainValue
	//	*URLItem_DomainRegex
	DomainChoice isURLItem_DomainChoice `protobuf_oneof:"domain_choice"`
	// path choice
	//
	// x-displayName: "Path Match"
	// Select Path Match.
	//
	// Types that are valid to be assigned to PathChoice:
	//	*URLItem_PathValue
	//	*URLItem_PathPrefix
	//	*URLItem_PathRegex
	PathChoice isURLItem_PathChoice `protobuf_oneof:"path_choice"`
}

func (m *URLItem) Reset()      { *m = URLItem{} }
func (*URLItem) ProtoMessage() {}
func (*URLItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{21}
}
func (m *URLItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *URLItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *URLItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_URLItem.Merge(m, src)
}
func (m *URLItem) XXX_Size() int {
	return m.Size()
}
func (m *URLItem) XXX_DiscardUnknown() {
	xxx_messageInfo_URLItem.DiscardUnknown(m)
}

var xxx_messageInfo_URLItem proto.InternalMessageInfo

type isURLItem_DomainChoice interface {
	isURLItem_DomainChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isURLItem_PathChoice interface {
	isURLItem_PathChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type URLItem_DomainValue struct {
	DomainValue string `protobuf:"bytes,2,opt,name=domain_value,json=domainValue,proto3,oneof" json:"domain_value,omitempty"`
}
type URLItem_DomainRegex struct {
	DomainRegex string `protobuf:"bytes,3,opt,name=domain_regex,json=domainRegex,proto3,oneof" json:"domain_regex,omitempty"`
}
type URLItem_PathValue struct {
	PathValue string `protobuf:"bytes,5,opt,name=path_value,json=pathValue,proto3,oneof" json:"path_value,omitempty"`
}
type URLItem_PathPrefix struct {
	PathPrefix string `protobuf:"bytes,7,opt,name=path_prefix,json=pathPrefix,proto3,oneof" json:"path_prefix,omitempty"`
}
type URLItem_PathRegex struct {
	PathRegex string `protobuf:"bytes,6,opt,name=path_regex,json=pathRegex,proto3,oneof" json:"path_regex,omitempty"`
}

func (*URLItem_DomainValue) isURLItem_DomainChoice() {}
func (*URLItem_DomainRegex) isURLItem_DomainChoice() {}
func (*URLItem_PathValue) isURLItem_PathChoice()     {}
func (*URLItem_PathPrefix) isURLItem_PathChoice()    {}
func (*URLItem_PathRegex) isURLItem_PathChoice()     {}

func (m *URLItem) GetDomainChoice() isURLItem_DomainChoice {
	if m != nil {
		return m.DomainChoice
	}
	return nil
}
func (m *URLItem) GetPathChoice() isURLItem_PathChoice {
	if m != nil {
		return m.PathChoice
	}
	return nil
}

func (m *URLItem) GetDomainValue() string {
	if x, ok := m.GetDomainChoice().(*URLItem_DomainValue); ok {
		return x.DomainValue
	}
	return ""
}

func (m *URLItem) GetDomainRegex() string {
	if x, ok := m.GetDomainChoice().(*URLItem_DomainRegex); ok {
		return x.DomainRegex
	}
	return ""
}

func (m *URLItem) GetPathValue() string {
	if x, ok := m.GetPathChoice().(*URLItem_PathValue); ok {
		return x.PathValue
	}
	return ""
}

func (m *URLItem) GetPathPrefix() string {
	if x, ok := m.GetPathChoice().(*URLItem_PathPrefix); ok {
		return x.PathPrefix
	}
	return ""
}

func (m *URLItem) GetPathRegex() string {
	if x, ok := m.GetPathChoice().(*URLItem_PathRegex); ok {
		return x.PathRegex
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*URLItem) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*URLItem_DomainValue)(nil),
		(*URLItem_DomainRegex)(nil),
		(*URLItem_PathValue)(nil),
		(*URLItem_PathPrefix)(nil),
		(*URLItem_PathRegex)(nil),
	}
}

// url matcher type
//
// x-displayName: "URL Matcher"
// A URL matcher specifies a list of URL items as match criteria. The match is considered successful if the input domain and path match any of the URL items.
// The result of the match is inverted if invert_matcher is true.
type URLMatcherType struct {
	// url items
	//
	// x-displayName: "URL Items"
	// x-required
	// A list of URL items used as match criteria. The match is considered successful if the domain and path match any of the URL items.
	UrlItems []*URLItem `protobuf:"bytes,1,rep,name=url_items,json=urlItems,proto3" json:"url_items,omitempty"`
	// invert_matcher
	//
	// x-displayName: "Invert URL Matcher"
	// Invert the match result.
	InvertMatcher bool `protobuf:"varint,2,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *URLMatcherType) Reset()      { *m = URLMatcherType{} }
func (*URLMatcherType) ProtoMessage() {}
func (*URLMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{22}
}
func (m *URLMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *URLMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *URLMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_URLMatcherType.Merge(m, src)
}
func (m *URLMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *URLMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_URLMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_URLMatcherType proto.InternalMessageInfo

func (m *URLMatcherType) GetUrlItems() []*URLItem {
	if m != nil {
		return m.UrlItems
	}
	return nil
}

func (m *URLMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

// l4 dest matcher type
//
// x-displayName: "L4 Destination Matcher"
// A L4 Destination matcher specifies a list of L4 Destinations as match criteria. The match is considered successful if the destination IP and port match any
// of the L4 Destinations.
// The result of the match is inverted if invert_matcher is true.
type L4DestMatcherType struct {
	// prefixes
	//
	// x-displayName: "L4 Destinations"
	// x-required
	// A list of L4 destinations used as match criteria. The match is considered successful if the destination IP and path match any of the L4 destinations.
	L4Dests []*schema.L4DestType `protobuf:"bytes,4,rep,name=l4_dests,json=l4Dests,proto3" json:"l4_dests,omitempty"`
	// invert_matcher
	//
	// x-displayName: "Invert L4 Destination Matcher"
	// Invert the match result.
	InvertMatcher bool `protobuf:"varint,3,opt,name=invert_matcher,json=invertMatcher,proto3" json:"invert_matcher,omitempty"`
}

func (m *L4DestMatcherType) Reset()      { *m = L4DestMatcherType{} }
func (*L4DestMatcherType) ProtoMessage() {}
func (*L4DestMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d3fbb7e1d0915ae2, []int{23}
}
func (m *L4DestMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L4DestMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *L4DestMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L4DestMatcherType.Merge(m, src)
}
func (m *L4DestMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *L4DestMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_L4DestMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_L4DestMatcherType proto.InternalMessageInfo

func (m *L4DestMatcherType) GetL4Dests() []*schema.L4DestType {
	if m != nil {
		return m.L4Dests
	}
	return nil
}

func (m *L4DestMatcherType) GetInvertMatcher() bool {
	if m != nil {
		return m.InvertMatcher
	}
	return false
}

func init() {
	proto.RegisterEnum("ves.io.schema.policy.PolicySetType", PolicySetType_name, PolicySetType_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.PolicySetType", PolicySetType_name, PolicySetType_value)
	proto.RegisterEnum("ves.io.schema.policy.PolicySetScope", PolicySetScope_name, PolicySetScope_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.PolicySetScope", PolicySetScope_name, PolicySetScope_value)
	proto.RegisterEnum("ves.io.schema.policy.RuleCombiningAlgorithm", RuleCombiningAlgorithm_name, RuleCombiningAlgorithm_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.RuleCombiningAlgorithm", RuleCombiningAlgorithm_name, RuleCombiningAlgorithm_value)
	proto.RegisterEnum("ves.io.schema.policy.Transformer", Transformer_name, Transformer_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.Transformer", Transformer_name, Transformer_value)
	proto.RegisterEnum("ves.io.schema.policy.KnownTlsFingerprintClass", KnownTlsFingerprintClass_name, KnownTlsFingerprintClass_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.KnownTlsFingerprintClass", KnownTlsFingerprintClass_name, KnownTlsFingerprintClass_value)
	proto.RegisterEnum("ves.io.schema.policy.CountryCode", CountryCode_name, CountryCode_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.CountryCode", CountryCode_name, CountryCode_value)
	proto.RegisterEnum("ves.io.schema.policy.RuleAction", RuleAction_name, RuleAction_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.RuleAction", RuleAction_name, RuleAction_value)
	proto.RegisterEnum("ves.io.schema.policy.ChallengeAction", ChallengeAction_name, ChallengeAction_value)
	golang_proto.RegisterEnum("ves.io.schema.policy.ChallengeAction", ChallengeAction_name, ChallengeAction_value)
	proto.RegisterType((*WafRuleControl)(nil), "ves.io.schema.policy.WafRuleControl")
	golang_proto.RegisterType((*WafRuleControl)(nil), "ves.io.schema.policy.WafRuleControl")
	proto.RegisterType((*WafInlineRuleControl)(nil), "ves.io.schema.policy.WafInlineRuleControl")
	golang_proto.RegisterType((*WafInlineRuleControl)(nil), "ves.io.schema.policy.WafInlineRuleControl")
	proto.RegisterType((*WafAction)(nil), "ves.io.schema.policy.WafAction")
	golang_proto.RegisterType((*WafAction)(nil), "ves.io.schema.policy.WafAction")
	proto.RegisterType((*PrefixMatchList)(nil), "ves.io.schema.policy.PrefixMatchList")
	golang_proto.RegisterType((*PrefixMatchList)(nil), "ves.io.schema.policy.PrefixMatchList")
	proto.RegisterType((*AsnMatchList)(nil), "ves.io.schema.policy.AsnMatchList")
	golang_proto.RegisterType((*AsnMatchList)(nil), "ves.io.schema.policy.AsnMatchList")
	proto.RegisterType((*SimpleWafExclusionRule)(nil), "ves.io.schema.policy.SimpleWafExclusionRule")
	golang_proto.RegisterType((*SimpleWafExclusionRule)(nil), "ves.io.schema.policy.SimpleWafExclusionRule")
	proto.RegisterType((*DenyInformation)(nil), "ves.io.schema.policy.DenyInformation")
	golang_proto.RegisterType((*DenyInformation)(nil), "ves.io.schema.policy.DenyInformation")
	proto.RegisterType((*TlsFingerprintMatcherType)(nil), "ves.io.schema.policy.TlsFingerprintMatcherType")
	golang_proto.RegisterType((*TlsFingerprintMatcherType)(nil), "ves.io.schema.policy.TlsFingerprintMatcherType")
	proto.RegisterType((*PathMatcherType)(nil), "ves.io.schema.policy.PathMatcherType")
	golang_proto.RegisterType((*PathMatcherType)(nil), "ves.io.schema.policy.PathMatcherType")
	proto.RegisterType((*MatcherType)(nil), "ves.io.schema.policy.MatcherType")
	golang_proto.RegisterType((*MatcherType)(nil), "ves.io.schema.policy.MatcherType")
	proto.RegisterType((*MatcherTypeBasic)(nil), "ves.io.schema.policy.MatcherTypeBasic")
	golang_proto.RegisterType((*MatcherTypeBasic)(nil), "ves.io.schema.policy.MatcherTypeBasic")
	proto.RegisterType((*CookieMatcherType)(nil), "ves.io.schema.policy.CookieMatcherType")
	golang_proto.RegisterType((*CookieMatcherType)(nil), "ves.io.schema.policy.CookieMatcherType")
	proto.RegisterType((*ArgMatcherType)(nil), "ves.io.schema.policy.ArgMatcherType")
	golang_proto.RegisterType((*ArgMatcherType)(nil), "ves.io.schema.policy.ArgMatcherType")
	proto.RegisterType((*HeaderMatcherType)(nil), "ves.io.schema.policy.HeaderMatcherType")
	golang_proto.RegisterType((*HeaderMatcherType)(nil), "ves.io.schema.policy.HeaderMatcherType")
	proto.RegisterType((*QueryParameterMatcherType)(nil), "ves.io.schema.policy.QueryParameterMatcherType")
	golang_proto.RegisterType((*QueryParameterMatcherType)(nil), "ves.io.schema.policy.QueryParameterMatcherType")
	proto.RegisterType((*HttpMethodMatcherType)(nil), "ves.io.schema.policy.HttpMethodMatcherType")
	golang_proto.RegisterType((*HttpMethodMatcherType)(nil), "ves.io.schema.policy.HttpMethodMatcherType")
	proto.RegisterType((*RoleMatcherType)(nil), "ves.io.schema.policy.RoleMatcherType")
	golang_proto.RegisterType((*RoleMatcherType)(nil), "ves.io.schema.policy.RoleMatcherType")
	proto.RegisterType((*StringMatcherType)(nil), "ves.io.schema.policy.StringMatcherType")
	golang_proto.RegisterType((*StringMatcherType)(nil), "ves.io.schema.policy.StringMatcherType")
	proto.RegisterType((*IpMatcherType)(nil), "ves.io.schema.policy.IpMatcherType")
	golang_proto.RegisterType((*IpMatcherType)(nil), "ves.io.schema.policy.IpMatcherType")
	proto.RegisterType((*AsnMatcherType)(nil), "ves.io.schema.policy.AsnMatcherType")
	golang_proto.RegisterType((*AsnMatcherType)(nil), "ves.io.schema.policy.AsnMatcherType")
	proto.RegisterType((*PortMatcherType)(nil), "ves.io.schema.policy.PortMatcherType")
	golang_proto.RegisterType((*PortMatcherType)(nil), "ves.io.schema.policy.PortMatcherType")
	proto.RegisterType((*URLItem)(nil), "ves.io.schema.policy.URLItem")
	golang_proto.RegisterType((*URLItem)(nil), "ves.io.schema.policy.URLItem")
	proto.RegisterType((*URLMatcherType)(nil), "ves.io.schema.policy.URLMatcherType")
	golang_proto.RegisterType((*URLMatcherType)(nil), "ves.io.schema.policy.URLMatcherType")
	proto.RegisterType((*L4DestMatcherType)(nil), "ves.io.schema.policy.L4DestMatcherType")
	golang_proto.RegisterType((*L4DestMatcherType)(nil), "ves.io.schema.policy.L4DestMatcherType")
}

func init() { proto.RegisterFile("ves.io/schema/policy/types.proto", fileDescriptor_d3fbb7e1d0915ae2) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/policy/types.proto", fileDescriptor_d3fbb7e1d0915ae2)
}

var fileDescriptor_d3fbb7e1d0915ae2 = []byte{
	// 5561 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x9b, 0x79, 0x74, 0x24, 0x49,
	0x7a, 0xd0, 0x95, 0x92, 0xba, 0x5b, 0x1d, 0xea, 0xe3, 0xeb, 0x9a, 0x9e, 0x59, 0x4d, 0xef, 0x8c,
	0xb6, 0x56, 0x5e, 0x3c, 0x43, 0xbb, 0x57, 0x1d, 0x19, 0x19, 0x91, 0x19, 0x31, 0x86, 0xb1, 0x4b,
	0x52, 0x49, 0xaa, 0x56, 0x1d, 0xea, 0xac, 0x52, 0xab, 0xd5, 0x1c, 0x45, 0x9c, 0xea, 0xf2, 0x48,
	0x55, 0xa2, 0xaa, 0x7a, 0x66, 0x1a, 0x58, 0x18, 0x9b, 0x6b, 0x39, 0x7c, 0xb0, 0x1c, 0x5e, 0x83,
	0x6d, 0xc0, 0x1c, 0x36, 0xcb, 0x61, 0x73, 0x83, 0xc5, 0xd1, 0x36, 0xd7, 0x62, 0x0c, 0x0c, 0xa7,
	0x97, 0xdb, 0xdb, 0xc3, 0x31, 0x0b, 0x18, 0x96, 0xc5, 0xd8, 0xbb, 0x06, 0xde, 0xe3, 0x65, 0x55,
	0x49, 0x5d, 0xd1, 0xa3, 0x19, 0xbc, 0xde, 0xdd, 0xf7, 0xfc, 0x47, 0xff, 0x57, 0xbf, 0x5f, 0x46,
	0x44, 0x7e, 0xf9, 0x45, 0x64, 0x64, 0x28, 0x33, 0x84, 0xf2, 0xaf, 0xda, 0xde, 0x62, 0xab, 0x73,
	0xbd, 0xa7, 0xef, 0xda, 0x7d, 0x79, 0xfd, 0xa0, 0xb3, 0xd7, 0xd2, 0xf7, 0xaf, 0xf7, 0xef, 0x1f,
	0xd8, 0xde, 0xe2, 0x41, 0xb7, 0xd3, 0xef, 0xe4, 0x2e, 0x0f, 0x4b, 0x2c, 0x0e, 0x4b, 0x2c, 0x0e,
	0x4b, 0x5c, 0xf9, 0xf0, 0x6e, 0xab, 0x7f, 0xf7, 0x9e, 0x5a, 0xd4, 0x9d, 0xfd, 0xeb, 0xbb, 0x9d,
	0xdd, 0xce, 0xf5, 0x41, 0x61, 0x75, 0xcf, 0x0d, 0x68, 0x00, 0x83, 0x5f, 0xc3, 0x46, 0xae, 0x7c,
	0x60, 0xb7, 0xd3, 0xd9, 0xdd, 0xb3, 0x8f, 0x4a, 0xf5, 0x5b, 0xfb, 0xb6, 0xd7, 0x97, 0xfb, 0x07,
	0xa3, 0x02, 0xef, 0xf3, 0xe3, 0x68, 0xdb, 0xfe, 0xe8, 0xc0, 0xfb, 0xfd, 0x03, 0x9d, 0x83, 0x7e,
	0xab, 0xd3, 0x1e, 0xc5, 0x76, 0xe5, 0x59, 0xff, 0xe0, 0x58, 0xd8, 0x57, 0x9e, 0xf3, 0x0f, 0xbd,
	0x2a, 0xf7, 0x5a, 0x46, 0xf6, 0xed, 0xe8, 0xe8, 0x63, 0x97, 0xfd, 0x6a, 0xcb, 0xbe, 0xd6, 0xf4,
	0x9b, 0x7e, 0xc1, 0x2f, 0xf1, 0x9a, 0x74, 0xcd, 0xee, 0xbd, 0x3d, 0xdb, 0xdc, 0x6b, 0xf5, 0xfa,
	0xe3, 0x27, 0x5a, 0xf8, 0xae, 0x00, 0x5d, 0xd8, 0x96, 0x2e, 0xbd, 0xb7, 0x67, 0x97, 0x3b, 0xed,
	0x7e, 0xb7, 0xb3, 0x97, 0x53, 0x08, 0xec, 0xeb, 0x7a, 0xef, 0x9e, 0xb1, 0xc3, 0x3a, 0x2d, 0xd3,
	0x9b, 0x0b, 0xf2, 0x53, 0x2f, 0xce, 0x92, 0xe7, 0x16, 0xfd, 0x6c, 0xd6, 0xd4, 0x37, 0x58, 0xdd,
	0x4f, 0xad, 0x6b, 0xdc, 0x3f, 0xb0, 0x4b, 0x57, 0x3e, 0xf1, 0x91, 0xf3, 0xde, 0x89, 0x7e, 0xf0,
	0x33, 0x0f, 0xa6, 0x4e, 0x7d, 0x2c, 0x98, 0x84, 0xe9, 0xf4, 0xc2, 0xa8, 0xc5, 0xec, 0x3c, 0x25,
	0xd3, 0xcb, 0xbd, 0x80, 0x2e, 0xee, 0x77, 0xda, 0xad, 0x7e, 0xa7, 0xdb, 0x6a, 0xef, 0x36, 0xf7,
	0x3b, 0xc6, 0xce, 0x4d, 0xe6, 0x83, 0x17, 0x67, 0xd2, 0x0b, 0x8f, 0x74, 0xa5, 0x63, 0xec, 0xc2,
	0xf7, 0x06, 0xe8, 0xf2, 0xb6, 0x74, 0xa5, 0xf6, 0x5e, 0xab, 0x6d, 0xc7, 0xa3, 0x74, 0xef, 0x12,
	0xe5, 0x05, 0xf2, 0xd5, 0x8f, 0x45, 0xe9, 0xc5, 0xb4, 0x38, 0xba, 0xd8, 0xd2, 0xca, 0xd2, 0xe5,
	0xe3, 0xf8, 0xbe, 0xfe, 0xe8, 0xd7, 0x5c, 0xf0, 0x73, 0x8f, 0xf4, 0xfb, 0xa7, 0xd0, 0xd9, 0x6d,
	0xe9, 0x0a, 0x3a, 0xeb, 0x87, 0xdc, 0x55, 0x34, 0xdd, 0xee, 0xb4, 0xed, 0xdc, 0x54, 0x3e, 0x78,
	0x71, 0x96, 0x5c, 0x7e, 0x2c, 0xa4, 0xe2, 0xfe, 0x41, 0xff, 0xfe, 0xfa, 0x44, 0x3a, 0x28, 0x93,
	0x5b, 0x45, 0x4f, 0x65, 0x31, 0xf6, 0x5e, 0x69, 0x1d, 0x34, 0x0f, 0xba, 0x1d, 0x6d, 0x7b, 0xbd,
	0x56, 0x7b, 0x77, 0x2e, 0x78, 0xcf, 0xaa, 0x97, 0x5e, 0x93, 0xae, 0xfe, 0x4a, 0xeb, 0x60, 0xf3,
	0xb8, 0x42, 0x6e, 0x13, 0xc1, 0xf1, 0xb5, 0xea, 0x61, 0x9a, 0x06, 0xb1, 0xce, 0x92, 0x0f, 0x2d,
	0x9e, 0x74, 0x1b, 0x2c, 0xfa, 0x1d, 0xbf, 0x3e, 0x91, 0x5e, 0x78, 0xcd, 0x1f, 0x0a, 0x1a, 0xbd,
	0x2f, 0x6b, 0xb1, 0x35, 0xc8, 0xbe, 0xdf, 0xf0, 0xf4, 0xa0, 0xe1, 0xab, 0xef, 0xda, 0xf0, 0x3b,
	0x7a, 0x6c, 0x7d, 0x22, 0xbd, 0xfc, 0xda, 0x49, 0x3d, 0xb9, 0x81, 0x9e, 0x19, 0x9e, 0xa4, 0xf9,
	0x78, 0xa2, 0x4f, 0xbf, 0x67, 0x06, 0x9e, 0x1a, 0xb4, 0x56, 0xf1, 0x7a, 0x61, 0xe9, 0x43, 0x68,
	0x56, 0x0e, 0x7a, 0xa0, 0x99, 0x8d, 0xf2, 0xdc, 0xd3, 0x0f, 0x0e, 0x83, 0xa9, 0x37, 0x0f, 0x83,
	0x53, 0x0f, 0x0f, 0x83, 0xb3, 0xd1, 0xb5, 0xf8, 0x5a, 0x78, 0x8d, 0x5e, 0x23, 0x37, 0xa6, 0x67,
	0x4e, 0xc1, 0xe9, 0x85, 0x6f, 0x09, 0xd0, 0xc5, 0xcd, 0xae, 0x75, 0xad, 0xd7, 0x2b, 0xb2, 0xaf,
	0xef, 0x96, 0x5b, 0xbd, 0x7e, 0x2e, 0x45, 0xb3, 0x83, 0x5e, 0xc8, 0xac, 0x1d, 0x8e, 0xa8, 0xb3,
	0x4b, 0xe1, 0xe7, 0x0f, 0x83, 0x89, 0x6c, 0x8c, 0xa0, 0x8f, 0x05, 0x67, 0x16, 0x4e, 0x75, 0xa7,
	0x3e, 0x1f, 0x04, 0xc7, 0x83, 0x07, 0x8e, 0x7e, 0xcd, 0x04, 0x63, 0xc3, 0x08, 0x65, 0x3d, 0x33,
	0x6c, 0x24, 0xf7, 0x02, 0x3a, 0xd7, 0x6a, 0xbf, 0x6a, 0xbb, 0xfd, 0xe6, 0x7e, 0x76, 0x9e, 0xe1,
	0xf8, 0x59, 0x9a, 0x7e, 0x70, 0x18, 0x04, 0xe9, 0xec, 0xf0, 0xc8, 0x20, 0x80, 0x85, 0x9b, 0xe8,
	0x5c, 0xa1, 0xd7, 0x7e, 0x14, 0x4c, 0x01, 0x21, 0xd9, 0x6b, 0xb6, 0xef, 0xed, 0x2b, 0xdb, 0x1d,
	0xc6, 0x72, 0x7e, 0x69, 0xe1, 0x28, 0x96, 0xf7, 0x38, 0xf9, 0x59, 0xd9, 0xab, 0x0e, 0x2b, 0x2d,
	0xfc, 0xf0, 0x34, 0x7a, 0xa6, 0xde, 0xda, 0x3f, 0xd8, 0xb3, 0xdb, 0xd2, 0x15, 0xb3, 0xa1, 0xdd,
	0x6b, 0x75, 0xda, 0x59, 0xfa, 0x73, 0x0c, 0x21, 0xd9, 0xbe, 0xdf, 0x34, 0x9d, 0x7d, 0xd9, 0x6a,
	0x8f, 0xfa, 0xf3, 0xdd, 0x72, 0x7d, 0x56, 0xb6, 0xef, 0xaf, 0x0c, 0x0a, 0xe6, 0x04, 0x3a, 0x37,
	0xac, 0xd2, 0xec, 0xda, 0x5d, 0xfb, 0xfa, 0xdc, 0xa9, 0x7c, 0xf0, 0xe2, 0xd9, 0xd1, 0xcd, 0xd4,
	0x9d, 0x9a, 0x7b, 0x63, 0x72, 0xf4, 0xeb, 0xa3, 0x93, 0xc1, 0xfa, 0x44, 0x3a, 0x3b, 0x2c, 0x9b,
	0x66, 0x45, 0x73, 0x11, 0x42, 0x07, 0xb2, 0x7f, 0x77, 0x54, 0xf1, 0xb4, 0x57, 0xf1, 0xc5, 0xe3,
	0x8a, 0x0f, 0x82, 0x20, 0x3d, 0x9b, 0x95, 0x1b, 0x56, 0x2a, 0xa1, 0x33, 0xfb, 0xb6, 0x7f, 0xb7,
	0x63, 0x7a, 0x73, 0x67, 0x06, 0xf7, 0xf7, 0xb3, 0x8f, 0xc5, 0xb8, 0xde, 0xef, 0x1f, 0x54, 0x06,
	0x25, 0x46, 0x8d, 0x7d, 0x53, 0x30, 0x09, 0xe3, 0xe9, 0x38, 0xaa, 0x7f, 0xe2, 0x9c, 0x31, 0xf3,
	0x15, 0x98, 0x33, 0x2a, 0xe8, 0xb2, 0x7d, 0xfd, 0xa0, 0xd5, 0x95, 0xc3, 0x81, 0x78, 0xf4, 0xb0,
	0x98, 0x3b, 0x3b, 0xc8, 0xf1, 0x95, 0xc5, 0xe1, 0xe3, 0x64, 0xf1, 0xe8, 0x71, 0xb2, 0xd8, 0x38,
	0x2a, 0x91, 0x3e, 0xf5, 0xa8, 0xde, 0xb1, 0xcc, 0xbd, 0x84, 0x66, 0xf6, 0x6d, 0x5f, 0x1a, 0xd9,
	0x97, 0x73, 0x68, 0xd0, 0xc4, 0xfc, 0x63, 0xe1, 0x56, 0x6c, 0xaf, 0x27, 0x77, 0x6d, 0xc5, 0xf6,
	0x65, 0x36, 0x15, 0xa7, 0xc7, 0xe5, 0x5f, 0xba, 0xf8, 0xb9, 0x97, 0xcf, 0x85, 0xf8, 0x5a, 0x36,
	0xf4, 0x93, 0x6b, 0xfc, 0x9a, 0x58, 0xca, 0xa3, 0xf3, 0xa3, 0xee, 0xd3, 0x77, 0x3b, 0x2d, 0x6d,
	0x73, 0x17, 0x1f, 0x1c, 0x06, 0xd3, 0x6f, 0x1e, 0x06, 0x53, 0x0f, 0x0f, 0x83, 0x29, 0x7a, 0x8d,
	0xdd, 0x98, 0x9e, 0x09, 0x60, 0xf2, 0xc6, 0xf4, 0xcc, 0x24, 0x4c, 0xdd, 0x98, 0x9e, 0x99, 0x82,
	0xe9, 0x85, 0x1e, 0xba, 0xb8, 0x62, 0xdb, 0xf7, 0x4b, 0x6d, 0xd7, 0xe9, 0xee, 0x0f, 0x82, 0xcb,
	0x5d, 0x47, 0xe7, 0xbb, 0xb6, 0x77, 0xd0, 0x69, 0xf7, 0xb2, 0x29, 0xc1, 0xd8, 0xc1, 0x6c, 0x75,
	0x7e, 0x09, 0x0d, 0xb2, 0x72, 0x75, 0x6a, 0xee, 0xc7, 0xa6, 0xd3, 0x73, 0x47, 0x05, 0x96, 0x3b,
	0xc6, 0x66, 0x15, 0x6c, 0xb7, 0xdb, 0xe9, 0x36, 0xf7, 0x87, 0xb1, 0x0e, 0xee, 0x82, 0xb3, 0xa3,
	0x0a, 0x59, 0xf7, 0x4f, 0xa7, 0xe7, 0x06, 0x05, 0x46, 0xd7, 0xb2, 0x70, 0xf8, 0x02, 0x7a, 0xb6,
	0xb1, 0xd7, 0x5b, 0x6d, 0xb5, 0x77, 0x6d, 0xf7, 0xa0, 0xdb, 0x6a, 0x0f, 0x6f, 0x12, 0xdb, 0xcd,
	0xae, 0x30, 0xa7, 0xd0, 0x19, 0xbd, 0x27, 0x7b, 0x3d, 0x7b, 0x34, 0xeb, 0x2f, 0x9e, 0x3c, 0x13,
	0x6d, 0xb4, 0x3b, 0xaf, 0xb5, 0xfd, 0x66, 0x96, 0xb3, 0x7a, 0x4b, 0x73, 0x9f, 0x3f, 0x0c, 0x26,
	0xdf, 0x79, 0x1f, 0x65, 0xc3, 0x65, 0xd4, 0x70, 0xee, 0xe3, 0x4f, 0xa1, 0x73, 0xf6, 0x75, 0xa9,
	0xfb, 0xcd, 0x57, 0xe5, 0xde, 0x3d, 0xdb, 0x9b, 0x9b, 0x1c, 0xcc, 0x06, 0x3f, 0x99, 0x7b, 0x78,
	0x18, 0xfc, 0x68, 0x0e, 0xe5, 0x43, 0x29, 0x13, 0xe5, 0xb8, 0x12, 0x89, 0x65, 0x14, 0x6b, 0xc9,
	0xac, 0x31, 0x09, 0x73, 0x89, 0xe2, 0x11, 0xa7, 0xca, 0x49, 0x94, 0x8f, 0xb4, 0x91, 0x8c, 0x18,
	0x49, 0xa5, 0xb1, 0x58, 0xb8, 0xd0, 0x25, 0x3c, 0x94, 0x86, 0x58, 0x4e, 0x8c, 0x76, 0x92, 0x60,
	0x94, 0x4f, 0x8c, 0x61, 0xd8, 0x86, 0x21, 0xd1, 0x86, 0x44, 0x49, 0x44, 0x65, 0x14, 0x62, 0x25,
	0xb0, 0x8b, 0x1d, 0xa5, 0x32, 0xd1, 0x06, 0xe5, 0x43, 0x65, 0x23, 0xab, 0xad, 0xb2, 0x4c, 0x4a,
	0x61, 0xa2, 0x98, 0x51, 0x1b, 0xdb, 0x04, 0x47, 0x86, 0x87, 0x2e, 0x16, 0x84, 0xa3, 0xbc, 0x66,
	0x24, 0x62, 0x26, 0x92, 0x5c, 0x09, 0x11, 0x51, 0x95, 0x38, 0xa5, 0x0c, 0xc1, 0xd4, 0x30, 0xac,
	0x34, 0x66, 0xdc, 0xa0, 0xbc, 0x8d, 0x89, 0x64, 0x8e, 0x1a, 0x16, 0x71, 0xad, 0x5c, 0x18, 0x0b,
	0x4d, 0xa4, 0x4b, 0x42, 0x65, 0x35, 0x89, 0x84, 0x50, 0x14, 0xe5, 0x0d, 0x11, 0x11, 0xd3, 0x8c,
	0x3b, 0x1b, 0x27, 0x71, 0x42, 0xa9, 0xb3, 0x5a, 0xf3, 0x38, 0xa4, 0xd6, 0xb2, 0x88, 0xc5, 0x3a,
	0x41, 0x79, 0x63, 0xb5, 0x53, 0x94, 0x4b, 0x16, 0x25, 0x5c, 0x58, 0x65, 0x31, 0x0f, 0x15, 0xe7,
	0x52, 0x2a, 0xc5, 0xb8, 0xb5, 0x11, 0x45, 0x79, 0x16, 0xea, 0x98, 0xea, 0x24, 0xb1, 0x31, 0x76,
	0x91, 0xe0, 0xd8, 0x5a, 0x29, 0x30, 0x8f, 0x85, 0x8a, 0xb9, 0x66, 0x5c, 0x66, 0x91, 0x2a, 0xc1,
	0x25, 0xa1, 0xd6, 0x52, 0x25, 0xc2, 0x88, 0x52, 0xca, 0x9d, 0x53, 0x2c, 0x09, 0xa9, 0x33, 0x3c,
	0xc1, 0x52, 0xa3, 0x7c, 0x44, 0x5d, 0x48, 0x65, 0x2c, 0xa4, 0x49, 0x30, 0x16, 0x5a, 0x32, 0x1e,
	0x47, 0x51, 0x22, 0x48, 0xc8, 0xa5, 0x0b, 0x13, 0x17, 0xa1, 0xbc, 0x49, 0x62, 0x6b, 0x63, 0xea,
	0x54, 0x42, 0x92, 0x28, 0x89, 0x22, 0xad, 0x2c, 0x65, 0x4c, 0x6a, 0x1e, 0x6a, 0x22, 0x88, 0x8d,
	0x51, 0x9e, 0xbb, 0x58, 0x8b, 0x90, 0x1b, 0xad, 0x18, 0x67, 0x56, 0x29, 0x2b, 0x31, 0xb3, 0x44,
	0x6b, 0x41, 0x59, 0x84, 0x6d, 0x94, 0xe5, 0xd4, 0x60, 0xc1, 0x6c, 0xcc, 0x29, 0x17, 0x26, 0xd2,
	0x2c, 0x62, 0x44, 0x24, 0xda, 0x70, 0xe3, 0x9c, 0xc2, 0xb1, 0x56, 0x02, 0xe5, 0x1d, 0x21, 0xca,
	0x18, 0x96, 0xd8, 0x28, 0xeb, 0x40, 0xcb, 0x63, 0x6d, 0x24, 0xc5, 0x46, 0x12, 0xc3, 0xa9, 0xe5,
	0x91, 0x42, 0x79, 0xa7, 0x18, 0xe7, 0x51, 0xe8, 0xb8, 0x20, 0xa1, 0xc0, 0x71, 0x96, 0x32, 0x4a,
	0x2d, 0x61, 0x4a, 0xf3, 0x08, 0x2b, 0xca, 0x50, 0x1e, 0x6b, 0x1d, 0x5a, 0x4e, 0x59, 0xcc, 0x2d,
	0x4d, 0x42, 0x29, 0x43, 0x13, 0x13, 0x69, 0x68, 0xc8, 0xb8, 0x34, 0x36, 0x56, 0x0c, 0xe5, 0x09,
	0x16, 0xc4, 0x86, 0xce, 0x39, 0x45, 0x99, 0x49, 0x2c, 0x95, 0xa1, 0x90, 0x2c, 0x71, 0x42, 0x69,
	0x66, 0x09, 0x8e, 0x24, 0xca, 0x9b, 0x90, 0x4b, 0x6a, 0x24, 0xa7, 0xd2, 0x31, 0x61, 0xc3, 0x10,
	0x73, 0x1e, 0x13, 0x19, 0x09, 0x25, 0x6d, 0xa2, 0x85, 0xa1, 0x28, 0x2f, 0xe3, 0x90, 0x08, 0xe1,
	0x84, 0x62, 0x38, 0x94, 0x46, 0xbb, 0x98, 0x63, 0x25, 0x48, 0xc2, 0x4c, 0x22, 0x0c, 0x95, 0x3a,
	0x46, 0x79, 0x15, 0xf1, 0x58, 0xd0, 0x58, 0x32, 0x49, 0xa9, 0x09, 0x8d, 0xd1, 0x9a, 0xd3, 0x48,
	0xe9, 0x84, 0x45, 0x51, 0x6c, 0x9c, 0xb6, 0x28, 0xcf, 0xa9, 0xe0, 0xce, 0x52, 0x12, 0xf3, 0x24,
	0xa6, 0x46, 0x39, 0x41, 0x62, 0x19, 0x71, 0xc2, 0x23, 0x2b, 0x4c, 0x64, 0xb8, 0xcb, 0x22, 0x35,
	0x26, 0xe4, 0xca, 0x98, 0x88, 0x60, 0x61, 0x65, 0x12, 0x72, 0xc1, 0x05, 0x8e, 0xb0, 0x8c, 0x9d,
	0x88, 0xa2, 0x98, 0xa2, 0x3c, 0x17, 0x22, 0x94, 0x11, 0x4f, 0x2c, 0xcd, 0xda, 0x0f, 0x13, 0x8a,
	0x1d, 0x61, 0x26, 0x76, 0x2c, 0x8c, 0x84, 0x13, 0xc4, 0xa0, 0x7c, 0x64, 0xb8, 0xd0, 0xd8, 0x38,
	0x15, 0x3a, 0x49, 0xa9, 0x08, 0x43, 0xc5, 0x9d, 0x4c, 0x18, 0x89, 0xac, 0xe3, 0xc6, 0x1a, 0x85,
	0xf2, 0x36, 0x8a, 0xb0, 0xd2, 0x52, 0x08, 0xcd, 0x25, 0x23, 0x2c, 0x96, 0x36, 0x24, 0xb1, 0x64,
	0x4c, 0x53, 0x9d, 0x10, 0xa6, 0x19, 0xca, 0xf3, 0xc8, 0x62, 0xaa, 0x34, 0xe3, 0x86, 0x62, 0xe2,
	0x44, 0x1c, 0x45, 0x82, 0x47, 0x5a, 0x39, 0x42, 0x12, 0x42, 0x15, 0x26, 0x28, 0xaf, 0xb8, 0xe3,
	0x61, 0x9c, 0x44, 0x1a, 0xdb, 0xd0, 0x10, 0x21, 0x30, 0x8f, 0x68, 0xec, 0x22, 0x25, 0x15, 0x17,
	0x44, 0x09, 0x85, 0xf2, 0x86, 0xb1, 0xd0, 0x49, 0xa7, 0xa9, 0xa3, 0xd8, 0x85, 0xc6, 0x6a, 0xa2,
	0x14, 0x65, 0x82, 0x63, 0xe5, 0xa4, 0xa0, 0x82, 0xa0, 0x3c, 0x11, 0x98, 0x33, 0x87, 0x23, 0xc7,
	0x2d, 0x97, 0x38, 0x72, 0x58, 0x45, 0x42, 0x68, 0xa6, 0x13, 0xed, 0xb0, 0xc2, 0x8a, 0x67, 0x63,
	0x5d, 0x26, 0xd2, 0x84, 0x94, 0x61, 0xe1, 0x4c, 0x1c, 0x52, 0x9d, 0x28, 0x15, 0x49, 0x86, 0x35,
	0x15, 0x9c, 0x28, 0xae, 0x51, 0x5e, 0xe9, 0x58, 0x47, 0x3c, 0x76, 0x34, 0xbb, 0x11, 0x44, 0xa2,
	0x84, 0x11, 0x96, 0x11, 0x43, 0x13, 0xa2, 0x92, 0x84, 0x18, 0x8e, 0xf2, 0x2a, 0x8c, 0x0c, 0x0e,
	0x39, 0x8d, 0xa5, 0x49, 0x64, 0x48, 0x65, 0x82, 0x95, 0xcb, 0x52, 0x1a, 0xc6, 0x49, 0xc2, 0x74,
	0xc2, 0x51, 0x3e, 0x16, 0xdc, 0x46, 0x31, 0x09, 0x85, 0x8b, 0x44, 0x22, 0x28, 0xc1, 0x4e, 0x12,
	0xc6, 0x43, 0x45, 0x42, 0x23, 0x75, 0x62, 0x35, 0xca, 0x87, 0x49, 0x48, 0x08, 0x4f, 0x38, 0xc6,
	0x52, 0x8b, 0x50, 0x45, 0x54, 0x4b, 0x63, 0x18, 0xe7, 0x54, 0x5b, 0xce, 0x58, 0x9c, 0x45, 0xca,
	0xb0, 0xd1, 0x36, 0xe4, 0xc6, 0x86, 0x4a, 0x85, 0x34, 0xb2, 0xb1, 0x30, 0xb1, 0x31, 0x82, 0x86,
	0x91, 0xe2, 0x11, 0x63, 0xd9, 0x1d, 0x15, 0x32, 0x2c, 0x1d, 0x65, 0x21, 0x55, 0x3c, 0xe6, 0xc6,
	0x3a, 0xc5, 0x19, 0x35, 0x0a, 0xbb, 0x98, 0x48, 0x4a, 0x43, 0x94, 0x37, 0x8e, 0xe9, 0x08, 0xdb,
	0x38, 0xc1, 0x46, 0xc9, 0x6c, 0xb0, 0x91, 0x04, 0x5b, 0x13, 0xc5, 0x38, 0xc6, 0xda, 0x61, 0x46,
	0x51, 0x3e, 0x62, 0x1a, 0xcb, 0x28, 0xd4, 0x94, 0x87, 0x82, 0x24, 0x0e, 0x13, 0x22, 0x23, 0xc5,
	0x22, 0x4c, 0xb2, 0x5b, 0x13, 0xf3, 0xc1, 0x4c, 0xa7, 0xb5, 0x65, 0x2a, 0x89, 0x35, 0x57, 0x61,
	0x42, 0x13, 0x62, 0x30, 0xa1, 0x09, 0xe3, 0x22, 0xc1, 0x92, 0xe2, 0x58, 0xa1, 0xbc, 0x08, 0x43,
	0x9a, 0x08, 0xa9, 0xb9, 0xc4, 0x3c, 0x8c, 0xac, 0x09, 0x09, 0x0d, 0x55, 0x14, 0xf3, 0x58, 0x6b,
	0x23, 0x8d, 0x15, 0x28, 0x8f, 0x23, 0x1b, 0xf2, 0x58, 0x26, 0x8e, 0x47, 0x84, 0x33, 0x2b, 0xa2,
	0x88, 0x86, 0xc6, 0xd2, 0x84, 0x47, 0x11, 0xc5, 0x38, 0xb6, 0x59, 0x3e, 0x9c, 0xa1, 0x22, 0x21,
	0xc4, 0x71, 0x13, 0x86, 0x2e, 0x32, 0x49, 0x6c, 0xb4, 0xe5, 0xd4, 0x71, 0x8b, 0x85, 0x90, 0x49,
	0x76, 0xdf, 0x62, 0x8c, 0x19, 0x93, 0x61, 0x28, 0x62, 0x69, 0xad, 0xe4, 0x26, 0x54, 0x3a, 0xc6,
	0x82, 0x73, 0xa6, 0xa4, 0x60, 0x11, 0xca, 0x63, 0xc1, 0x1d, 0x63, 0x96, 0x24, 0x86, 0x6b, 0xaa,
	0xb0, 0x64, 0x02, 0x87, 0x98, 0x68, 0x65, 0xb2, 0x1e, 0x76, 0xd9, 0x5d, 0x69, 0x23, 0x45, 0xa4,
	0x0a, 0x9d, 0x90, 0x2c, 0x76, 0xc4, 0x29, 0xaa, 0x05, 0xa1, 0xdc, 0x11, 0x47, 0xc3, 0x38, 0x0a,
	0xb3, 0x99, 0x9f, 0xc6, 0x36, 0x0b, 0x44, 0x2a, 0xad, 0x25, 0xb7, 0x52, 0x28, 0x29, 0x45, 0x44,
	0x8c, 0x8c, 0xb9, 0x33, 0x8a, 0x11, 0x81, 0xf2, 0xd4, 0x24, 0x92, 0x70, 0x13, 0x3b, 0x42, 0xe2,
	0xc8, 0x9a, 0x38, 0x34, 0x96, 0x73, 0x2d, 0xe3, 0xd8, 0x2a, 0x1c, 0x86, 0x36, 0x42, 0x79, 0x45,
	0x54, 0x1c, 0x1a, 0x95, 0x28, 0x41, 0x05, 0x96, 0x31, 0x36, 0x24, 0xc1, 0x5a, 0x2b, 0x82, 0x15,
	0x8d, 0x09, 0x27, 0x31, 0xca, 0x0b, 0xc2, 0x12, 0x91, 0xe0, 0xd0, 0x85, 0x94, 0xc5, 0x98, 0x59,
	0x61, 0x8d, 0xc6, 0x0a, 0x87, 0x52, 0xe0, 0x50, 0xc7, 0x86, 0xa1, 0x7c, 0x12, 0x8b, 0x90, 0x88,
	0x44, 0x65, 0xd5, 0x24, 0x0d, 0x49, 0x14, 0x39, 0x83, 0x25, 0x56, 0x52, 0x62, 0x19, 0xc5, 0xd9,
	0xd3, 0x23, 0x8c, 0xad, 0xd3, 0x0e, 0x5b, 0x8c, 0x19, 0xa6, 0xc6, 0x38, 0x6b, 0x8c, 0x0d, 0x23,
	0xe5, 0xac, 0x14, 0x22, 0x11, 0x8c, 0xa0, 0x7c, 0xc8, 0x68, 0x24, 0x13, 0x4d, 0xe3, 0x38, 0x8a,
	0xa4, 0x76, 0x49, 0x36, 0xa9, 0xe1, 0x50, 0x49, 0xad, 0x95, 0xc1, 0x83, 0x31, 0x66, 0x62, 0x87,
	0xa9, 0x62, 0x52, 0x84, 0x38, 0x0c, 0x99, 0xa3, 0x8a, 0x61, 0xab, 0xad, 0xc6, 0xc2, 0x50, 0x2c,
	0x43, 0xe3, 0x50, 0x5e, 0x44, 0x59, 0xd1, 0x84, 0x13, 0x13, 0x53, 0x61, 0xac, 0x62, 0x61, 0x36,
	0xa1, 0x52, 0xab, 0x55, 0x12, 0x52, 0xa5, 0x30, 0xca, 0x33, 0xcb, 0x92, 0x48, 0x0b, 0x2d, 0x1c,
	0x57, 0x32, 0x21, 0xd8, 0x3a, 0xa1, 0x42, 0x6e, 0x85, 0xd3, 0x96, 0x58, 0xe2, 0x12, 0x94, 0x67,
	0x02, 0x4b, 0x12, 0x11, 0x93, 0x3d, 0xda, 0x62, 0x8a, 0x85, 0x93, 0x2a, 0x21, 0x36, 0x61, 0x44,
	0x72, 0x49, 0xe2, 0xec, 0x09, 0xc4, 0xa9, 0x50, 0x98, 0x2a, 0xa3, 0x4c, 0x68, 0x88, 0x12, 0x3c,
	0x72, 0xb1, 0xe5, 0x92, 0xb2, 0xc4, 0xe2, 0x38, 0x22, 0xd9, 0x13, 0x48, 0x68, 0xc2, 0xb8, 0xb0,
	0xa1, 0xc6, 0x56, 0x38, 0x16, 0x45, 0x12, 0x13, 0xa2, 0x63, 0x82, 0x99, 0x13, 0x49, 0x28, 0x6c,
	0x88, 0xf2, 0x22, 0xb6, 0x4a, 0xc6, 0x24, 0x7b, 0x7c, 0x10, 0x45, 0x93, 0x18, 0x27, 0xa1, 0x20,
	0x4a, 0x26, 0x34, 0x1b, 0xd0, 0x4c, 0x49, 0x94, 0x4f, 0x34, 0x0d, 0xb1, 0xb6, 0x3c, 0x22, 0x96,
	0x53, 0x2e, 0xa3, 0x88, 0x84, 0x34, 0x22, 0x5a, 0x48, 0x4e, 0xac, 0x48, 0x48, 0xf6, 0x6c, 0x88,
	0x9d, 0xe1, 0x91, 0x24, 0xa1, 0x13, 0x2e, 0xd2, 0xcc, 0x09, 0xe7, 0x12, 0xc5, 0x74, 0x1c, 0x29,
	0xa5, 0xc3, 0x44, 0x18, 0x94, 0x27, 0x86, 0x27, 0x82, 0x6a, 0x95, 0x28, 0x96, 0xcd, 0x07, 0x89,
	0xb2, 0x96, 0xc4, 0x82, 0xd9, 0x44, 0xe8, 0x90, 0x25, 0x31, 0x46, 0x79, 0x67, 0x38, 0x76, 0x52,
	0xe8, 0x38, 0x24, 0x58, 0x9b, 0x6c, 0xa0, 0x32, 0x82, 0x59, 0x88, 0x5d, 0xa4, 0x63, 0x4a, 0xb3,
	0x67, 0x25, 0x4b, 0x5c, 0x14, 0x53, 0xa2, 0xa8, 0x8d, 0x12, 0x4b, 0xb8, 0x63, 0x5a, 0xd9, 0x08,
	0x13, 0xac, 0x45, 0x14, 0x85, 0x8a, 0x6a, 0x94, 0x17, 0x38, 0xc6, 0x98, 0x92, 0xe1, 0xfc, 0xc7,
	0x6c, 0xc2, 0x98, 0xc2, 0x34, 0xd2, 0x98, 0x25, 0x84, 0x51, 0x99, 0x8d, 0x42, 0xcd, 0xb0, 0x8b,
	0xb3, 0x95, 0x43, 0x98, 0x44, 0x71, 0x12, 0x2b, 0x9a, 0x28, 0x19, 0x63, 0xce, 0x94, 0xc1, 0x3a,
	0xd6, 0xd6, 0xa2, 0xbc, 0x26, 0x38, 0x54, 0x82, 0x38, 0xae, 0x28, 0x8f, 0x9c, 0x8c, 0x38, 0x57,
	0x36, 0x4c, 0xa8, 0x89, 0x63, 0x9e, 0x65, 0x90, 0xa2, 0xbc, 0x12, 0x58, 0x19, 0x65, 0x45, 0x1c,
	0xca, 0x98, 0x72, 0x87, 0x29, 0x49, 0x8c, 0x22, 0xa1, 0x94, 0x32, 0xd6, 0x5a, 0x31, 0x81, 0xf2,
	0xc2, 0xc5, 0x44, 0x53, 0x47, 0x62, 0x25, 0xb0, 0x89, 0x4c, 0xc2, 0x12, 0x65, 0x65, 0x8c, 0x85,
	0xe5, 0xc4, 0x11, 0x2b, 0xdd, 0xf8, 0xdf, 0x56, 0x1f, 0x0f, 0xf2, 0x27, 0x2e, 0xcb, 0x66, 0x07,
	0x4b, 0xb1, 0x5b, 0x83, 0x95, 0x58, 0xee, 0xbb, 0x9f, 0x42, 0x17, 0x47, 0x8b, 0x6e, 0x73, 0xb4,
	0x3a, 0x9b, 0x7a, 0xb2, 0x3a, 0x7b, 0xb2, 0x3a, 0x7b, 0xb2, 0x3a, 0x7b, 0xb2, 0x3a, 0x7b, 0xb2,
	0x3a, 0x7b, 0xb2, 0x3a, 0x7b, 0xb2, 0x3a, 0x7b, 0xb2, 0x3a, 0x7b, 0xb2, 0x3a, 0xfb, 0xca, 0xae,
	0xce, 0xf2, 0x27, 0xbc, 0x02, 0x35, 0xc3, 0x05, 0xda, 0xc2, 0x17, 0x26, 0xd1, 0xc5, 0x4d, 0xd9,
	0xbf, 0x3b, 0xfe, 0xce, 0x6e, 0x1b, 0x9d, 0x1f, 0xbe, 0x58, 0x3f, 0x5a, 0xb1, 0x0d, 0xdf, 0xae,
	0x93, 0xf1, 0xf6, 0xdf, 0x9e, 0x0c, 0xc6, 0xf1, 0xe8, 0xad, 0xf0, 0xe3, 0x8b, 0xc1, 0x73, 0xc3,
	0x86, 0x46, 0xab, 0xc1, 0xad, 0x13, 0xdf, 0xd3, 0xfd, 0x5c, 0xda, 0xf5, 0x16, 0x99, 0x5b, 0xe8,
	0xdc, 0xe0, 0x4d, 0xb5, 0xbf, 0xc0, 0x24, 0x27, 0xb4, 0x73, 0x84, 0x0f, 0x4e, 0xfa, 0x2e, 0x90,
	0x35, 0x3b, 0x68, 0x67, 0xd4, 0x6c, 0x13, 0x9d, 0xeb, 0x77, 0x65, 0xbb, 0xe7, 0x3a, 0xdd, 0x7d,
	0xdb, 0xed, 0xcd, 0x4d, 0x0f, 0xde, 0x5f, 0x7e, 0xf0, 0xe4, 0xf7, 0x97, 0x8d, 0x47, 0x25, 0x97,
	0xe6, 0x1e, 0x1c, 0x8e, 0xb5, 0x7f, 0x76, 0x3c, 0x1d, 0xe3, 0x0d, 0x2e, 0x7c, 0xf3, 0x24, 0x9a,
	0x1d, 0xcf, 0xfb, 0xea, 0x63, 0xe9, 0x19, 0xa6, 0xfd, 0xab, 0xbe, 0xe4, 0x7c, 0x4c, 0x7e, 0x65,
	0xf2, 0x31, 0xf5, 0xe5, 0xce, 0xc7, 0x0f, 0x05, 0x08, 0xc6, 0xf2, 0xb1, 0x24, 0x7b, 0x2d, 0xfd,
	0xf3, 0x3c, 0x29, 0x2f, 0x5d, 0xf8, 0x91, 0x97, 0xc7, 0xfb, 0x70, 0xe1, 0xb3, 0x93, 0xe8, 0xd2,
	0x72, 0xa7, 0xf3, 0x4a, 0xcb, 0x8e, 0xf7, 0xec, 0x3c, 0x9a, 0x6e, 0xcb, 0xfd, 0xe1, 0xcb, 0xf7,
	0xf1, 0x77, 0xe9, 0x93, 0xe9, 0xc0, 0xe7, 0x16, 0xd0, 0xcc, 0x41, 0xd7, 0xf6, 0x6c, 0x5b, 0xdb,
	0xa3, 0xaf, 0x4e, 0x6f, 0x1f, 0x06, 0xc1, 0xfa, 0x44, 0x7a, 0xec, 0x73, 0x5f, 0x8b, 0xce, 0xeb,
	0xbb, 0x56, 0xbf, 0xd2, 0x1c, 0x9a, 0xfe, 0xdc, 0x99, 0xf7, 0xfc, 0x12, 0x74, 0x6e, 0x50, 0x78,
	0x73, 0x58, 0x36, 0xb7, 0x84, 0x2e, 0x0d, 0x2b, 0xb7, 0x3b, 0xfd, 0xe3, 0x06, 0x66, 0xde, 0xb3,
	0x81, 0x8b, 0x83, 0x0a, 0xd5, 0x4e, 0xff, 0xa8, 0x8d, 0x04, 0x4d, 0xb7, 0xfa, 0x76, 0x7f, 0xf4,
	0xa9, 0xf4, 0x5d, 0xfa, 0x7d, 0xec, 0xaa, 0xd7, 0x27, 0xd2, 0x41, 0x85, 0xdc, 0xd7, 0xa0, 0x0b,
	0xe3, 0xdf, 0xd5, 0x6c, 0x77, 0xf0, 0x11, 0xeb, 0xe8, 0xcb, 0xda, 0xf9, 0xb1, 0x2f, 0x6b, 0xb6,
	0xfb, 0xd2, 0xcc, 0xe7, 0x5e, 0x3e, 0x15, 0x5e, 0x8b, 0xaf, 0xd1, 0xa5, 0x2b, 0xe8, 0xd4, 0xa0,
	0x7c, 0xee, 0xd2, 0xe8, 0xe3, 0xe0, 0xe9, 0x87, 0x87, 0xc1, 0xa9, 0xe8, 0x5a, 0x72, 0x8d, 0xdf,
	0x98, 0x9e, 0x39, 0x0d, 0x67, 0x46, 0x9f, 0x07, 0x7f, 0x7a, 0x12, 0x5d, 0x28, 0x74, 0x77, 0xc7,
	0xf3, 0xfd, 0xa2, 0x97, 0xef, 0xa3, 0x4f, 0x57, 0x6f, 0x8f, 0x3a, 0xf4, 0x49, 0xe6, 0xbf, 0x4c,
	0x99, 0xff, 0x99, 0x49, 0x74, 0x69, 0xdd, 0x4a, 0x63, 0xbb, 0xff, 0xff, 0xe4, 0x7f, 0xf2, 0x49,
	0xf2, 0xbf, 0xbc, 0xc9, 0xff, 0xa9, 0x49, 0xf4, 0xec, 0xcd, 0x7b, 0xb6, 0x7b, 0x7f, 0x53, 0x76,
	0xe5, 0xbe, 0xed, 0xfb, 0x9d, 0xf0, 0x1c, 0x9a, 0x7a, 0xc5, 0xde, 0x3f, 0x61, 0xc2, 0xc9, 0xf4,
	0x93, 0xc4, 0x7f, 0x29, 0x89, 0xff, 0xd6, 0x00, 0x3d, 0xfd, 0xe8, 0x5b, 0xf6, 0x78, 0xd2, 0xc7,
	0x3e, 0x81, 0x07, 0x5f, 0xe2, 0x27, 0xf0, 0x77, 0x5e, 0xc3, 0xe4, 0xbb, 0x5e, 0xc3, 0x02, 0x41,
	0x17, 0xd3, 0xce, 0x9e, 0xf7, 0xc4, 0xf9, 0xc0, 0xe8, 0x62, 0x46, 0x23, 0x60, 0xf0, 0xd0, 0x9d,
	0xee, 0x4e, 0xbe, 0xf8, 0x75, 0xe9, 0xd0, 0x2f, 0xbc, 0x11, 0xa0, 0x4b, 0xf5, 0xfe, 0x60, 0x3f,
	0xc6, 0x58, 0x35, 0xfe, 0xa8, 0x5a, 0xf6, 0x78, 0x5c, 0xc8, 0xaa, 0x9d, 0xfd, 0x58, 0x70, 0x7a,
	0x61, 0x50, 0xf7, 0xc4, 0x8f, 0xea, 0xa3, 0xa4, 0x7d, 0x31, 0x01, 0x8f, 0x3e, 0x57, 0x7f, 0x7b,
	0x80, 0xce, 0x97, 0x0e, 0xc6, 0x4f, 0xbf, 0x83, 0x66, 0x47, 0x2b, 0xcf, 0x9e, 0xed, 0xff, 0xec,
	0x77, 0x33, 0x1d, 0xef, 0x04, 0xc9, 0xaa, 0x8d, 0xed, 0x66, 0x42, 0x43, 0x5b, 0xb7, 0xfd, 0x2f,
	0x32, 0xa1, 0x1a, 0x5d, 0x38, 0xda, 0xe0, 0x31, 0x8a, 0xec, 0x26, 0x9a, 0x91, 0xbd, 0xf6, 0xcf,
	0x3e, 0xac, 0xb9, 0x4f, 0x7c, 0x64, 0x56, 0xed, 0x1e, 0x34, 0x47, 0x95, 0xc6, 0x82, 0x3a, 0x23,
	0x7b, 0xed, 0x2c, 0xa2, 0x85, 0xfb, 0xe8, 0xe2, 0x66, 0xa7, 0xeb, 0x7d, 0x2d, 0x17, 0xe8, 0xd4,
	0x41, 0xa7, 0xdb, 0x3f, 0x71, 0x95, 0xf3, 0x03, 0xef, 0xb2, 0x1c, 0x19, 0xd6, 0xf8, 0xe2, 0xae,
	0xef, 0x33, 0x93, 0xe8, 0xcc, 0x56, 0x5a, 0x2e, 0x65, 0x77, 0xcb, 0xe2, 0xf1, 0x3e, 0x91, 0xc1,
	0xca, 0x68, 0xf4, 0xbd, 0xff, 0x68, 0xc0, 0xdc, 0x1d, 0xdb, 0x1c, 0x32, 0x58, 0xf2, 0xe4, 0xae,
	0x3f, 0xb6, 0xaf, 0x64, 0xca, 0x9b, 0x62, 0x1e, 0x04, 0xef, 0xd8, 0x4d, 0xc2, 0x46, 0xbb, 0x49,
	0x86, 0xcd, 0xfb, 0xdb, 0x50, 0x46, 0xcb, 0xfd, 0xe1, 0x86, 0x94, 0xf5, 0xd1, 0x7e, 0x92, 0xe1,
	0x79, 0x12, 0x34, 0x3b, 0xa8, 0x36, 0xec, 0xc3, 0xc1, 0xec, 0xf3, 0xee, 0xf5, 0x06, 0x67, 0x18,
	0x6e, 0xe4, 0x39, 0x3e, 0xdf, 0x49, 0xbb, 0x57, 0xe6, 0xc6, 0x77, 0xaf, 0xac, 0x8f, 0xef, 0x5f,
	0x79, 0xe9, 0xf4, 0xe7, 0x5e, 0x9e, 0x0a, 0xaf, 0xd1, 0x93, 0x37, 0x5e, 0x4c, 0xbe, 0x79, 0x18,
	0x04, 0x0f, 0x0f, 0x83, 0x29, 0x72, 0x2d, 0x5a, 0xca, 0x8f, 0x22, 0x1b, 0x1d, 0xcf, 0xa6, 0x8b,
	0xd3, 0x6f, 0x1e, 0x06, 0xd3, 0xd9, 0x74, 0xc1, 0xae, 0x25, 0xd7, 0xe2, 0xe3, 0xad, 0x19, 0xd3,
	0x70, 0x6a, 0xe1, 0x3b, 0x02, 0x74, 0x61, 0x2b, 0x2d, 0x8f, 0x77, 0xf3, 0x1d, 0x74, 0xf6, 0x5e,
	0x77, 0xaf, 0x99, 0x4d, 0x56, 0x47, 0xa3, 0xe9, 0xf9, 0x93, 0xa7, 0xb7, 0x51, 0x27, 0x2d, 0xcd,
	0xbf, 0xf3, 0xd6, 0xf3, 0x76, 0x12, 0xcd, 0xdc, 0xeb, 0xee, 0x65, 0x05, 0xbf, 0xc8, 0x71, 0xf0,
	0x3d, 0x01, 0xba, 0x54, 0xa6, 0x2b, 0xb6, 0xe7, 0x8d, 0xc2, 0x06, 0x9a, 0xd9, 0xa3, 0x4d, 0x63,
	0x7b, 0xfd, 0xe1, 0x1f, 0x3d, 0xb3, 0xef, 0x98, 0xc7, 0x86, 0x75, 0x06, 0x03, 0x7d, 0xfe, 0x9d,
	0x7f, 0x66, 0x7a, 0x91, 0x9d, 0xd9, 0x1b, 0x94, 0x3d, 0x29, 0xb0, 0xa9, 0xf7, 0x9a, 0x20, 0x8e,
	0xf7, 0xb6, 0x5c, 0xb5, 0xe8, 0xfc, 0xe6, 0x20, 0x1b, 0x75, 0x3b, 0x38, 0x65, 0xee, 0x32, 0x82,
	0x6a, 0xb1, 0xb1, 0x5d, 0x4b, 0x37, 0x9a, 0xf5, 0xe2, 0xf2, 0x56, 0x5a, 0x6a, 0xec, 0xc0, 0x44,
	0xee, 0x12, 0x3a, 0x9f, 0x16, 0x1a, 0xc5, 0x66, 0xb9, 0x54, 0x29, 0x35, 0x4a, 0xd5, 0x35, 0x08,
	0x72, 0x73, 0xe8, 0xf2, 0x66, 0xad, 0x5c, 0x5a, 0xde, 0x69, 0x2e, 0x15, 0xea, 0xc5, 0x95, 0x66,
	0x5a, 0xdb, 0x1a, 0x1c, 0x99, 0xcc, 0x0a, 0x6f, 0x17, 0x56, 0x9b, 0xc5, 0xdb, 0xcb, 0xe5, 0xad,
	0x7a, 0xa9, 0x56, 0x85, 0xa9, 0xab, 0x75, 0x74, 0xe1, 0xf8, 0x34, 0x75, 0xdd, 0x19, 0xac, 0xda,
	0xaf, 0x8c, 0xaa, 0xd7, 0x8b, 0x8d, 0x66, 0x7d, 0xb9, 0xb6, 0x59, 0x6c, 0x56, 0x0b, 0x95, 0x62,
	0x7d, 0xb3, 0xb0, 0x5c, 0x84, 0x89, 0xdc, 0x07, 0xd1, 0xf3, 0xef, 0x38, 0x7e, 0xab, 0x94, 0x36,
	0xb6, 0x0a, 0xe5, 0xe6, 0x7a, 0xad, 0xde, 0x80, 0xe0, 0xea, 0x6d, 0xf4, 0xcc, 0x70, 0x0b, 0xdd,
	0xbe, 0x6a, 0xb5, 0x5b, 0xed, 0xdd, 0xc2, 0xde, 0x6e, 0xa7, 0xdb, 0xea, 0xdf, 0xdd, 0xcf, 0x5d,
	0x44, 0xb3, 0xab, 0xa5, 0xb4, 0xde, 0x68, 0x56, 0x0a, 0x8d, 0xe5, 0x75, 0x98, 0xc8, 0xe5, 0xd0,
	0x85, 0x95, 0x62, 0x75, 0xa7, 0x59, 0xbb, 0x55, 0x4c, 0xd3, 0xd2, 0x4a, 0xb1, 0x0e, 0x41, 0xee,
	0x29, 0x74, 0xb1, 0x50, 0x2e, 0xd7, 0xb6, 0xc7, 0xe4, 0xe4, 0x95, 0x2c, 0x61, 0x13, 0x57, 0x1f,
	0x04, 0x68, 0x76, 0xec, 0x8f, 0xac, 0xdc, 0x15, 0x04, 0x8d, 0xb4, 0x50, 0xad, 0xaf, 0xd6, 0xd2,
	0x4a, 0x31, 0x6d, 0x56, 0x6b, 0xd5, 0x22, 0x4c, 0x0c, 0xca, 0x06, 0xb9, 0x0b, 0x08, 0x95, 0x6b,
	0xdb, 0xc5, 0xb4, 0xb9, 0x5c, 0xa8, 0x17, 0x61, 0xc0, 0x5b, 0x9b, 0x9b, 0x47, 0x3c, 0xc8, 0x46,
	0x96, 0xa0, 0x98, 0x36, 0x57, 0x8a, 0xcb, 0xb5, 0x95, 0x22, 0x4c, 0x65, 0xd1, 0x54, 0x6b, 0x69,
	0xa5, 0x50, 0x2e, 0xdd, 0x29, 0x36, 0x37, 0x0b, 0x8d, 0x75, 0x98, 0xce, 0x3d, 0x8d, 0x2e, 0xa5,
	0xc5, 0x4a, 0xed, 0x56, 0xb1, 0xb9, 0xbd, 0x5e, 0x6a, 0x8c, 0xd2, 0x70, 0x6a, 0xd0, 0x5a, 0x5a,
	0x3e, 0xaa, 0x7a, 0x3a, 0x77, 0x1e, 0x9d, 0x6d, 0xa4, 0xa5, 0x4a, 0xb3, 0x5c, 0x5c, 0x6d, 0xc0,
	0x99, 0xec, 0xf0, 0x00, 0xd3, 0xd2, 0xda, 0x7a, 0x03, 0x66, 0x72, 0x33, 0x68, 0x3a, 0x63, 0x38,
	0x7b, 0xf5, 0x0b, 0x01, 0x9a, 0x7b, 0xb7, 0x7d, 0x3f, 0xb9, 0xe7, 0xd1, 0xe5, 0x46, 0xb9, 0xde,
	0x5c, 0x2d, 0x55, 0xd7, 0x8a, 0xe9, 0x66, 0x5a, 0xaa, 0x36, 0x8e, 0xae, 0x69, 0xea, 0x8d, 0x8f,
	0x04, 0xb9, 0xe7, 0xd1, 0xb3, 0x85, 0xea, 0x4e, 0x33, 0x0b, 0x70, 0xb9, 0x54, 0xdb, 0xf2, 0x0a,
	0x42, 0x90, 0x43, 0xe8, 0x74, 0x61, 0x65, 0xbb, 0x90, 0x66, 0x57, 0x37, 0xfc, 0x5d, 0xaa, 0xae,
	0xc0, 0x54, 0xf6, 0x7b, 0x25, 0xcb, 0xe3, 0x6d, 0x98, 0xce, 0xcd, 0xa2, 0x33, 0x6b, 0xb5, 0x5a,
	0x63, 0xa3, 0xd4, 0x80, 0x53, 0x59, 0x54, 0x6b, 0xb5, 0x3b, 0x25, 0x38, 0x9d, 0x3b, 0x87, 0x66,
	0x6e, 0x2c, 0x95, 0x56, 0xd3, 0xac, 0x03, 0xcf, 0x64, 0x85, 0x6e, 0x6e, 0x15, 0x36, 0x96, 0x6a,
	0x59, 0xe8, 0x17, 0x10, 0xca, 0x52, 0x5c, 0xab, 0x0c, 0x5a, 0x3e, 0x9b, 0x15, 0x6d, 0xa4, 0xb5,
	0xf2, 0x4a, 0xb1, 0xbe, 0x0e, 0x28, 0x6b, 0xbb, 0x51, 0x5b, 0xad, 0x17, 0x8b, 0x30, 0x9b, 0x65,
	0xb4, 0x51, 0x4b, 0xd3, 0x62, 0xb5, 0x51, 0xae, 0x2d, 0x6f, 0x14, 0x53, 0x38, 0x37, 0x2c, 0x5c,
	0x5a, 0x1e, 0x34, 0x75, 0xfe, 0xea, 0x4f, 0xe4, 0xd1, 0xec, 0x72, 0xe7, 0x5e, 0xbb, 0xdf, 0xbd,
	0x3f, 0xd8, 0x76, 0x05, 0xe8, 0xdc, 0x72, 0x6d, 0xab, 0xda, 0x48, 0x77, 0x46, 0x97, 0x99, 0x9d,
	0xec, 0xc8, 0x14, 0x56, 0x86, 0x9d, 0x76, 0xcc, 0xd9, 0x65, 0x8d, 0xf3, 0x2a, 0x4c, 0x79, 0xbc,
	0x06, 0xd3, 0x1e, 0x97, 0x86, 0xdd, 0x74, 0xcc, 0x65, 0x38, 0xed, 0x71, 0x65, 0xd8, 0x4f, 0xc7,
	0x5c, 0x1d, 0x5e, 0xec, 0x31, 0xd7, 0xe0, 0xac, 0xc7, 0x37, 0x01, 0x79, 0x9c, 0xc2, 0xac, 0xc7,
	0x75, 0x38, 0xe7, 0x71, 0x03, 0xce, 0x7b, 0xbc, 0x05, 0x17, 0x3c, 0xde, 0x86, 0x8b, 0x1e, 0xdf,
	0x06, 0xf0, 0xf8, 0x0e, 0x5c, 0x1a, 0xe7, 0xa5, 0x02, 0xe4, 0x3c, 0x5e, 0x82, 0xa7, 0x3c, 0x5e,
	0x81, 0xcb, 0x1e, 0x17, 0xe1, 0x69, 0x8f, 0x57, 0xe1, 0x19, 0x8f, 0xd7, 0xe0, 0x7d, 0x1e, 0xaf,
	0xc3, 0x9c, 0xc7, 0x25, 0x78, 0xd6, 0xe3, 0x1b, 0x70, 0xc5, 0xe3, 0x32, 0xbc, 0xdf, 0xe3, 0x0a,
	0x3c, 0xe7, 0x71, 0x15, 0x9e, 0xf7, 0xb8, 0x06, 0xf3, 0x1e, 0xdf, 0x84, 0x0f, 0x78, 0x9c, 0x42,
	0xde, 0xe3, 0x3a, 0x7c, 0xd0, 0xe3, 0x06, 0x2c, 0x78, 0x7c, 0x0b, 0xbe, 0xca, 0xe3, 0x6d, 0xf8,
	0x90, 0xc7, 0x3b, 0xf0, 0x0b, 0x3c, 0xbe, 0x03, 0x5f, 0x3d, 0xce, 0xcb, 0x05, 0x78, 0xc1, 0xe3,
	0x65, 0x78, 0xd1, 0xe3, 0x15, 0xf8, 0x85, 0x1e, 0xaf, 0xc2, 0x55, 0x8f, 0xd7, 0xe0, 0x6b, 0x3c,
	0x5e, 0x87, 0x6b, 0x1e, 0x97, 0xe0, 0xc3, 0x1e, 0x6f, 0xc0, 0xa2, 0xc7, 0x65, 0xb8, 0xee, 0x71,
	0x05, 0xb0, 0xc7, 0x55, 0x08, 0x3d, 0xae, 0x01, 0xf1, 0x38, 0x85, 0xc8, 0xe3, 0x3a, 0x50, 0x8f,
	0xb7, 0x80, 0x79, 0x7c, 0x0b, 0x62, 0x8f, 0xb7, 0x21, 0xf1, 0xf8, 0x36, 0x70, 0x8f, 0x77, 0x40,
	0x78, 0x7c, 0x07, 0x5e, 0x1a, 0xe7, 0x95, 0x22, 0x7c, 0xad, 0xc7, 0x37, 0xe0, 0x17, 0x79, 0xbc,
	0x01, 0xbf, 0xd8, 0xe3, 0x0a, 0xbc, 0xec, 0x71, 0x0d, 0xbe, 0xce, 0xe3, 0x3b, 0xf0, 0xf5, 0xe3,
	0x5c, 0x5c, 0x86, 0x82, 0xc7, 0x45, 0x58, 0xf2, 0x78, 0x0d, 0x96, 0x3d, 0x5e, 0x87, 0x15, 0x8f,
	0x53, 0x28, 0x7a, 0x5c, 0x87, 0x55, 0x8f, 0x1b, 0xb0, 0x36, 0xce, 0xab, 0x25, 0x58, 0xf7, 0xf8,
	0x06, 0x94, 0x3c, 0xde, 0x80, 0x1b, 0x1e, 0x57, 0x60, 0xc3, 0xe3, 0x1a, 0x94, 0x3d, 0x4e, 0xa1,
	0x32, 0xce, 0x6b, 0x05, 0xa8, 0x7a, 0xbc, 0x04, 0x35, 0x8f, 0x57, 0x60, 0xd3, 0xe3, 0x22, 0xdc,
	0xf4, 0x78, 0x15, 0x52, 0x8f, 0xd7, 0xa0, 0xee, 0xf1, 0x3a, 0x34, 0x3c, 0x2e, 0xc1, 0x96, 0xc7,
	0x65, 0xb8, 0xe5, 0x71, 0x05, 0xb6, 0x3d, 0xae, 0xc2, 0x6d, 0x8f, 0x37, 0x61, 0xc7, 0xe3, 0x9b,
	0x70, 0xc7, 0xe3, 0x14, 0x7e, 0x89, 0xc7, 0x75, 0xf8, 0xa5, 0x1e, 0x37, 0xe0, 0x97, 0x79, 0xbc,
	0x05, 0xbf, 0xdc, 0xe3, 0x6d, 0x68, 0x7a, 0xbc, 0x03, 0xbf, 0x62, 0x9c, 0xd7, 0x37, 0x40, 0x7a,
	0x5c, 0x01, 0xe5, 0x71, 0x15, 0xb4, 0xc7, 0x29, 0x18, 0x8f, 0x1b, 0x60, 0x3d, 0xde, 0x02, 0x37,
	0xce, 0xa5, 0x15, 0xd8, 0xf5, 0xb8, 0x08, 0x77, 0x3d, 0x2e, 0x43, 0xcb, 0xe3, 0x0a, 0x7c, 0x83,
	0xc7, 0x55, 0x78, 0xc5, 0xe3, 0x1a, 0xec, 0x79, 0x7c, 0x13, 0xf6, 0x3d, 0x4e, 0xa1, 0xed, 0x71,
	0x1d, 0x3a, 0x1e, 0x37, 0xe0, 0x60, 0x9c, 0x6f, 0x14, 0xe1, 0x57, 0x7a, 0x5c, 0x81, 0xae, 0xc7,
	0x35, 0xe8, 0x79, 0xbc, 0x09, 0xfd, 0x71, 0xde, 0x28, 0xc2, 0x3d, 0x8f, 0xd7, 0xe0, 0x55, 0x8f,
	0xd7, 0xe1, 0x35, 0x8f, 0x4b, 0xf0, 0xba, 0xc7, 0x15, 0xb8, 0xef, 0x71, 0x15, 0x7e, 0x95, 0xc7,
	0x9b, 0xf0, 0xab, 0x3d, 0x4e, 0xe1, 0xd7, 0x78, 0xbc, 0x0d, 0x1f, 0xf1, 0x78, 0x07, 0x7e, 0xad,
	0xc7, 0x77, 0xe0, 0xd7, 0xe5, 0x2e, 0x3e, 0xe2, 0x72, 0x01, 0xde, 0x08, 0x3c, 0xb1, 0x04, 0xdf,
	0xe8, 0x8b, 0x65, 0xf8, 0x26, 0x5f, 0x94, 0xe0, 0xd7, 0xfb, 0x62, 0x03, 0x7e, 0x83, 0x2f, 0x52,
	0xf8, 0x8d, 0xbe, 0xa8, 0xc3, 0x6f, 0xf2, 0x45, 0x03, 0x7e, 0xb3, 0x2f, 0xb6, 0xe0, 0xa3, 0xbe,
	0xb8, 0x05, 0xbf, 0xc5, 0x17, 0x3b, 0xf0, 0x5b, 0x3d, 0x51, 0x29, 0xc0, 0x6f, 0xf3, 0xc5, 0x32,
	0xfc, 0x76, 0x5f, 0xac, 0xc0, 0x37, 0xfb, 0xa2, 0x08, 0xdf, 0xe2, 0x8b, 0x55, 0xf8, 0x56, 0x5f,
	0xac, 0xc1, 0xb7, 0xf9, 0x62, 0x1d, 0x7e, 0x87, 0x2f, 0x36, 0xe0, 0x63, 0xbe, 0x28, 0xc3, 0xef,
	0xf4, 0x45, 0x05, 0x7e, 0x97, 0x2f, 0xaa, 0xf0, 0xbb, 0x7d, 0x51, 0x83, 0xdf, 0xe3, 0x8b, 0x4d,
	0xf8, 0x76, 0x5f, 0xdc, 0x84, 0x8f, 0xfb, 0x22, 0x85, 0xef, 0xf0, 0x45, 0x1d, 0x7e, 0xaf, 0x2f,
	0x1a, 0xf0, 0xfb, 0x7c, 0xb1, 0x05, 0xdf, 0xe9, 0x8b, 0x5b, 0xf0, 0x5d, 0xbe, 0xd8, 0x86, 0xef,
	0xf6, 0xc5, 0x6d, 0xf8, 0xfd, 0xbe, 0xd8, 0x81, 0x3f, 0xe0, 0x8b, 0x3b, 0xf0, 0x07, 0x3d, 0x51,
	0x2d, 0xc0, 0xf7, 0xf8, 0x62, 0x19, 0xfe, 0x90, 0x2f, 0x8a, 0xf0, 0x87, 0x7d, 0xb1, 0x0a, 0x7f,
	0xc4, 0x17, 0x6b, 0xf0, 0x47, 0x7d, 0x51, 0x82, 0xef, 0xf5, 0x45, 0x19, 0xbe, 0xcf, 0x17, 0x35,
	0xf8, 0x63, 0xbe, 0xd8, 0x84, 0x4f, 0xf8, 0x22, 0x85, 0x3f, 0xee, 0x8b, 0x2d, 0xf8, 0x13, 0xbe,
	0xb8, 0x03, 0x7f, 0xd2, 0x13, 0xb5, 0x0a, 0xfc, 0x29, 0x4f, 0x6c, 0x16, 0xe0, 0xfb, 0x7d, 0x51,
	0x84, 0x1f, 0xf0, 0xc5, 0x2a, 0xfc, 0x69, 0x5f, 0xac, 0xc1, 0x9f, 0xf1, 0xc5, 0x3a, 0xfc, 0x59,
	0x5f, 0x6c, 0xc0, 0x9f, 0xf3, 0x45, 0x19, 0xfe, 0xbc, 0x2f, 0x2a, 0xf0, 0x17, 0x7c, 0x51, 0x85,
	0xbf, 0xe8, 0x8b, 0x14, 0xfe, 0x92, 0x2f, 0xea, 0xf0, 0x97, 0x7d, 0xd1, 0x80, 0x1f, 0xf4, 0xc5,
	0x36, 0x1c, 0xfa, 0x62, 0x07, 0xfe, 0x8a, 0x27, 0x6e, 0x16, 0xe0, 0xaf, 0x7a, 0x22, 0x2d, 0xc2,
	0x5f, 0xf3, 0x45, 0x0d, 0xfe, 0xba, 0x2f, 0xea, 0xf0, 0xc0, 0x17, 0x5b, 0xf0, 0x43, 0xbe, 0xd8,
	0x86, 0x1f, 0xf6, 0x44, 0xbd, 0x00, 0x7f, 0xc3, 0x17, 0x4b, 0xf0, 0x37, 0x7d, 0xb1, 0x0c, 0x7f,
	0xcb, 0x17, 0x2b, 0xf0, 0xb7, 0x7d, 0x51, 0x84, 0xbf, 0xe3, 0x8b, 0x35, 0xf8, 0xa4, 0x2f, 0xd6,
	0xe1, 0xef, 0xfa, 0xa2, 0x04, 0x3f, 0xe2, 0x8b, 0x1b, 0xf0, 0xf7, 0x7c, 0xb1, 0x01, 0x3f, 0xea,
	0x8b, 0x32, 0xfc, 0x7d, 0x5f, 0x54, 0xe0, 0x1f, 0xf8, 0xa2, 0x0a, 0xff, 0xd0, 0x17, 0x35, 0x78,
	0xd3, 0x17, 0x29, 0xfc, 0x23, 0x5f, 0xd4, 0xe1, 0x1f, 0xfb, 0xa2, 0x01, 0xff, 0xc4, 0x17, 0xb7,
	0xe0, 0x9f, 0xfa, 0xe2, 0x36, 0xfc, 0x33, 0x5f, 0xec, 0xc0, 0x3f, 0xf7, 0xc5, 0x1d, 0xf8, 0x31,
	0x4f, 0x34, 0x96, 0xe1, 0x53, 0xbe, 0x58, 0x81, 0x7f, 0xe1, 0x8b, 0x55, 0xf8, 0x97, 0xbe, 0x58,
	0x83, 0x7f, 0xe5, 0x8b, 0x75, 0xf8, 0xd7, 0xbe, 0xb8, 0x01, 0xff, 0xc6, 0x17, 0x1b, 0xf0, 0x6f,
	0x7d, 0x51, 0x86, 0x7f, 0xe7, 0x8b, 0x0a, 0xfc, 0xb8, 0x2f, 0xaa, 0xf0, 0x69, 0x5f, 0xd4, 0xe0,
	0xa1, 0x2f, 0x52, 0x78, 0xcb, 0x17, 0x0d, 0xf8, 0xf7, 0xbe, 0xb8, 0x05, 0xff, 0xc1, 0x17, 0xdb,
	0xf0, 0x1f, 0x7d, 0x71, 0x07, 0xfe, 0x93, 0x27, 0xb6, 0x0a, 0xf0, 0xb6, 0x2f, 0xd6, 0xe0, 0x33,
	0xbe, 0xa8, 0xc0, 0x7f, 0xf6, 0x45, 0x1d, 0xfe, 0x8b, 0x2f, 0x76, 0xe0, 0xbf, 0xfa, 0xe2, 0x0e,
	0xfc, 0x84, 0x27, 0x6e, 0x15, 0xe0, 0xbf, 0xf9, 0x62, 0x19, 0xfe, 0xbb, 0x2f, 0x8a, 0xf0, 0x59,
	0x5f, 0xac, 0xc1, 0xff, 0xf0, 0x45, 0x09, 0x3e, 0xe7, 0x8b, 0x2a, 0xfc, 0x4f, 0x5f, 0x6c, 0xc1,
	0x4f, 0x7a, 0x62, 0x7b, 0x15, 0xfe, 0x97, 0x2f, 0xea, 0xf0, 0x53, 0x9e, 0xb8, 0xbd, 0x01, 0x3f,
	0xed, 0x8b, 0x06, 0x7c, 0xde, 0x13, 0x3b, 0x45, 0xf8, 0x82, 0x2f, 0x1a, 0xf0, 0x33, 0x9e, 0xb8,
	0x53, 0x80, 0xff, 0xed, 0x8b, 0x0a, 0xfc, 0x1f, 0x5f, 0x6c, 0xc3, 0xff, 0x0d, 0xae, 0x7e, 0x63,
	0x80, 0x50, 0x7a, 0x6f, 0xcf, 0x8e, 0xfe, 0xed, 0x75, 0x06, 0x4d, 0xaf, 0x14, 0xab, 0x3b, 0x30,
	0x91, 0x3b, 0x8b, 0x4e, 0x0d, 0x5e, 0x31, 0x41, 0x90, 0x7b, 0x16, 0x5d, 0xac, 0x16, 0x6f, 0x37,
	0x9a, 0x8f, 0x5e, 0x6a, 0x8d, 0xde, 0x36, 0x65, 0xed, 0xcd, 0x8e, 0x1d, 0x82, 0xa9, 0xdc, 0xd3,
	0x68, 0xb6, 0x5c, 0xa8, 0x1f, 0x8b, 0xe9, 0x51, 0xb9, 0xa7, 0xd1, 0xec, 0x5a, 0xad, 0x51, 0x3b,
	0xd2, 0xa7, 0x86, 0x7a, 0xf4, 0xca, 0xea, 0x3b, 0x03, 0x74, 0x71, 0xf9, 0xae, 0xdc, 0xdb, 0xb3,
	0xed, 0xdd, 0xa3, 0x40, 0x9e, 0x46, 0x97, 0x56, 0x8a, 0xab, 0x85, 0xad, 0x72, 0xa3, 0xb9, 0xbc,
	0x5e, 0x28, 0x97, 0x8b, 0xd5, 0xb5, 0x22, 0x4c, 0xe4, 0x3e, 0x80, 0xde, 0x5f, 0xac, 0x16, 0x96,
	0xca, 0xc5, 0xe6, 0x8d, 0xc2, 0xad, 0x42, 0x7d, 0x39, 0x2d, 0x6d, 0x8e, 0x17, 0x08, 0x72, 0xcf,
	0xa1, 0xb9, 0x51, 0x81, 0xe5, 0xc2, 0x66, 0x63, 0x79, 0xbd, 0x30, 0x76, 0x74, 0x72, 0xd0, 0x6a,
	0xa9, 0x3e, 0x3c, 0x7c, 0xac, 0xa7, 0x72, 0xcf, 0xa0, 0x5c, 0xa3, 0x58, 0xd9, 0xac, 0xa5, 0x85,
	0xc1, 0x1f, 0xed, 0xb5, 0xe5, 0x8d, 0x52, 0x75, 0x6d, 0x14, 0xfb, 0xc4, 0xd2, 0x47, 0x83, 0x37,
	0x3f, 0x3d, 0x3f, 0xf1, 0xa9, 0x4f, 0xcf, 0x4f, 0x7c, 0xf6, 0xd3, 0xf3, 0xc1, 0x1b, 0x0f, 0xe7,
	0x83, 0xef, 0x7b, 0x38, 0x1f, 0x7c, 0xf2, 0xe1, 0x7c, 0xf0, 0xe6, 0xc3, 0xf9, 0xe0, 0x53, 0x0f,
	0xe7, 0x83, 0x1f, 0x7f, 0x38, 0x1f, 0xbc, 0xfd, 0x70, 0x7e, 0xe2, 0xb3, 0x0f, 0xe7, 0x83, 0x6f,
	0x7b, 0x6b, 0x7e, 0xe2, 0xc1, 0x5b, 0xf3, 0xc1, 0x9b, 0x6f, 0xcd, 0x4f, 0x7c, 0xea, 0xad, 0xf9,
	0x89, 0x3b, 0x37, 0x76, 0x3b, 0x07, 0xaf, 0xec, 0x2e, 0xbe, 0xda, 0xd9, 0xeb, 0xdb, 0x6e, 0x57,
	0x2e, 0xde, 0xeb, 0x5d, 0x1f, 0xfc, 0x70, 0x9d, 0xee, 0xfe, 0x87, 0x0f, 0xba, 0x9d, 0x57, 0x5b,
	0xc6, 0x76, 0x3f, 0x7c, 0x74, 0xf8, 0xfa, 0x81, 0xda, 0xed, 0x5c, 0xb7, 0xaf, 0xf7, 0x47, 0xff,
	0xf9, 0xed, 0xfd, 0x67, 0xbc, 0x3a, 0x3d, 0xf8, 0x97, 0xc3, 0xe8, 0xff, 0x05, 0x00, 0x00, 0xff,
	0xff, 0xc3, 0xb3, 0x7a, 0xbb, 0x38, 0x3f, 0x00, 0x00,
}

func (x PolicySetType) String() string {
	s, ok := PolicySetType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PolicySetScope) String() string {
	s, ok := PolicySetScope_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RuleCombiningAlgorithm) String() string {
	s, ok := RuleCombiningAlgorithm_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Transformer) String() string {
	s, ok := Transformer_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x KnownTlsFingerprintClass) String() string {
	s, ok := KnownTlsFingerprintClass_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CountryCode) String() string {
	s, ok := CountryCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RuleAction) String() string {
	s, ok := RuleAction_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ChallengeAction) String() string {
	s, ok := ChallengeAction_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *WafRuleControl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafRuleControl)
	if !ok {
		that2, ok := that.(WafRuleControl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ExcludeRuleIds) != len(that1.ExcludeRuleIds) {
		return false
	}
	for i := range this.ExcludeRuleIds {
		if !this.ExcludeRuleIds[i].Equal(that1.ExcludeRuleIds[i]) {
			return false
		}
	}
	if this.MonitoringMode != that1.MonitoringMode {
		return false
	}
	return true
}
func (this *WafInlineRuleControl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafInlineRuleControl)
	if !ok {
		that2, ok := that.(WafInlineRuleControl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ExcludeRuleIds) != len(that1.ExcludeRuleIds) {
		return false
	}
	for i := range this.ExcludeRuleIds {
		if this.ExcludeRuleIds[i] != that1.ExcludeRuleIds[i] {
			return false
		}
	}
	if this.MonitoringMode != that1.MonitoringMode {
		return false
	}
	return true
}
func (this *WafAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafAction)
	if !ok {
		that2, ok := that.(WafAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ActionType == nil {
		if this.ActionType != nil {
			return false
		}
	} else if this.ActionType == nil {
		return false
	} else if !this.ActionType.Equal(that1.ActionType) {
		return false
	}
	return true
}
func (this *WafAction_None) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafAction_None)
	if !ok {
		that2, ok := that.(WafAction_None)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.None.Equal(that1.None) {
		return false
	}
	return true
}
func (this *WafAction_WafSkipProcessing) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafAction_WafSkipProcessing)
	if !ok {
		that2, ok := that.(WafAction_WafSkipProcessing)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.WafSkipProcessing.Equal(that1.WafSkipProcessing) {
		return false
	}
	return true
}
func (this *WafAction_WafRuleControl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafAction_WafRuleControl)
	if !ok {
		that2, ok := that.(WafAction_WafRuleControl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.WafRuleControl.Equal(that1.WafRuleControl) {
		return false
	}
	return true
}
func (this *WafAction_WafInlineRuleControl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafAction_WafInlineRuleControl)
	if !ok {
		that2, ok := that.(WafAction_WafInlineRuleControl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.WafInlineRuleControl.Equal(that1.WafInlineRuleControl) {
		return false
	}
	return true
}
func (this *WafAction_WafInMonitoringMode) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafAction_WafInMonitoringMode)
	if !ok {
		that2, ok := that.(WafAction_WafInMonitoringMode)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.WafInMonitoringMode.Equal(that1.WafInMonitoringMode) {
		return false
	}
	return true
}
func (this *PrefixMatchList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PrefixMatchList)
	if !ok {
		that2, ok := that.(PrefixMatchList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.IpPrefixes) != len(that1.IpPrefixes) {
		return false
	}
	for i := range this.IpPrefixes {
		if this.IpPrefixes[i] != that1.IpPrefixes[i] {
			return false
		}
	}
	if this.InvertMatch != that1.InvertMatch {
		return false
	}
	return true
}
func (this *AsnMatchList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AsnMatchList)
	if !ok {
		that2, ok := that.(AsnMatchList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.AsNumbers) != len(that1.AsNumbers) {
		return false
	}
	for i := range this.AsNumbers {
		if this.AsNumbers[i] != that1.AsNumbers[i] {
			return false
		}
	}
	return true
}
func (this *SimpleWafExclusionRule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimpleWafExclusionRule)
	if !ok {
		that2, ok := that.(SimpleWafExclusionRule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.DomainChoice == nil {
		if this.DomainChoice != nil {
			return false
		}
	} else if this.DomainChoice == nil {
		return false
	} else if !this.DomainChoice.Equal(that1.DomainChoice) {
		return false
	}
	if this.PathRegex != that1.PathRegex {
		return false
	}
	if len(this.Methods) != len(that1.Methods) {
		return false
	}
	for i := range this.Methods {
		if this.Methods[i] != that1.Methods[i] {
			return false
		}
	}
	if len(this.ExcludeRuleIds) != len(that1.ExcludeRuleIds) {
		return false
	}
	for i := range this.ExcludeRuleIds {
		if this.ExcludeRuleIds[i] != that1.ExcludeRuleIds[i] {
			return false
		}
	}
	if !this.ExpirationTimestamp.Equal(that1.ExpirationTimestamp) {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *SimpleWafExclusionRule_AnyDomain) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimpleWafExclusionRule_AnyDomain)
	if !ok {
		that2, ok := that.(SimpleWafExclusionRule_AnyDomain)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyDomain.Equal(that1.AnyDomain) {
		return false
	}
	return true
}
func (this *SimpleWafExclusionRule_DomainRegex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimpleWafExclusionRule_DomainRegex)
	if !ok {
		that2, ok := that.(SimpleWafExclusionRule_DomainRegex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DomainRegex != that1.DomainRegex {
		return false
	}
	return true
}
func (this *DenyInformation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DenyInformation)
	if !ok {
		that2, ok := that.(DenyInformation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ResponseCode != that1.ResponseCode {
		return false
	}
	if this.ErrorMessage != that1.ErrorMessage {
		return false
	}
	return true
}
func (this *TlsFingerprintMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsFingerprintMatcherType)
	if !ok {
		that2, ok := that.(TlsFingerprintMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Classes) != len(that1.Classes) {
		return false
	}
	for i := range this.Classes {
		if this.Classes[i] != that1.Classes[i] {
			return false
		}
	}
	if len(this.ExactValues) != len(that1.ExactValues) {
		return false
	}
	for i := range this.ExactValues {
		if this.ExactValues[i] != that1.ExactValues[i] {
			return false
		}
	}
	if len(this.ExcludedValues) != len(that1.ExcludedValues) {
		return false
	}
	for i := range this.ExcludedValues {
		if this.ExcludedValues[i] != that1.ExcludedValues[i] {
			return false
		}
	}
	return true
}
func (this *PathMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PathMatcherType)
	if !ok {
		that2, ok := that.(PathMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.PrefixValues) != len(that1.PrefixValues) {
		return false
	}
	for i := range this.PrefixValues {
		if this.PrefixValues[i] != that1.PrefixValues[i] {
			return false
		}
	}
	if len(this.ExactValues) != len(that1.ExactValues) {
		return false
	}
	for i := range this.ExactValues {
		if this.ExactValues[i] != that1.ExactValues[i] {
			return false
		}
	}
	if len(this.RegexValues) != len(that1.RegexValues) {
		return false
	}
	for i := range this.RegexValues {
		if this.RegexValues[i] != that1.RegexValues[i] {
			return false
		}
	}
	if len(this.Transformers) != len(that1.Transformers) {
		return false
	}
	for i := range this.Transformers {
		if this.Transformers[i] != that1.Transformers[i] {
			return false
		}
	}
	return true
}
func (this *MatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MatcherType)
	if !ok {
		that2, ok := that.(MatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ExactValues) != len(that1.ExactValues) {
		return false
	}
	for i := range this.ExactValues {
		if this.ExactValues[i] != that1.ExactValues[i] {
			return false
		}
	}
	if len(this.RegexValues) != len(that1.RegexValues) {
		return false
	}
	for i := range this.RegexValues {
		if this.RegexValues[i] != that1.RegexValues[i] {
			return false
		}
	}
	if len(this.Transformers) != len(that1.Transformers) {
		return false
	}
	for i := range this.Transformers {
		if this.Transformers[i] != that1.Transformers[i] {
			return false
		}
	}
	return true
}
func (this *MatcherTypeBasic) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MatcherTypeBasic)
	if !ok {
		that2, ok := that.(MatcherTypeBasic)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ExactValues) != len(that1.ExactValues) {
		return false
	}
	for i := range this.ExactValues {
		if this.ExactValues[i] != that1.ExactValues[i] {
			return false
		}
	}
	if len(this.RegexValues) != len(that1.RegexValues) {
		return false
	}
	for i := range this.RegexValues {
		if this.RegexValues[i] != that1.RegexValues[i] {
			return false
		}
	}
	return true
}
func (this *CookieMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieMatcherType)
	if !ok {
		that2, ok := that.(CookieMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.Match == nil {
		if this.Match != nil {
			return false
		}
	} else if this.Match == nil {
		return false
	} else if !this.Match.Equal(that1.Match) {
		return false
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *CookieMatcherType_Presence) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieMatcherType_Presence)
	if !ok {
		that2, ok := that.(CookieMatcherType_Presence)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Presence != that1.Presence {
		return false
	}
	return true
}
func (this *CookieMatcherType_CheckPresent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieMatcherType_CheckPresent)
	if !ok {
		that2, ok := that.(CookieMatcherType_CheckPresent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckPresent.Equal(that1.CheckPresent) {
		return false
	}
	return true
}
func (this *CookieMatcherType_CheckNotPresent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieMatcherType_CheckNotPresent)
	if !ok {
		that2, ok := that.(CookieMatcherType_CheckNotPresent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckNotPresent.Equal(that1.CheckNotPresent) {
		return false
	}
	return true
}
func (this *CookieMatcherType_Item) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieMatcherType_Item)
	if !ok {
		that2, ok := that.(CookieMatcherType_Item)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Item.Equal(that1.Item) {
		return false
	}
	return true
}
func (this *ArgMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ArgMatcherType)
	if !ok {
		that2, ok := that.(ArgMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.Match == nil {
		if this.Match != nil {
			return false
		}
	} else if this.Match == nil {
		return false
	} else if !this.Match.Equal(that1.Match) {
		return false
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *ArgMatcherType_Presence) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ArgMatcherType_Presence)
	if !ok {
		that2, ok := that.(ArgMatcherType_Presence)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Presence != that1.Presence {
		return false
	}
	return true
}
func (this *ArgMatcherType_CheckPresent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ArgMatcherType_CheckPresent)
	if !ok {
		that2, ok := that.(ArgMatcherType_CheckPresent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckPresent.Equal(that1.CheckPresent) {
		return false
	}
	return true
}
func (this *ArgMatcherType_CheckNotPresent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ArgMatcherType_CheckNotPresent)
	if !ok {
		that2, ok := that.(ArgMatcherType_CheckNotPresent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckNotPresent.Equal(that1.CheckNotPresent) {
		return false
	}
	return true
}
func (this *ArgMatcherType_Item) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ArgMatcherType_Item)
	if !ok {
		that2, ok := that.(ArgMatcherType_Item)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Item.Equal(that1.Item) {
		return false
	}
	return true
}
func (this *HeaderMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType)
	if !ok {
		that2, ok := that.(HeaderMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.Match == nil {
		if this.Match != nil {
			return false
		}
	} else if this.Match == nil {
		return false
	} else if !this.Match.Equal(that1.Match) {
		return false
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *HeaderMatcherType_Presence) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType_Presence)
	if !ok {
		that2, ok := that.(HeaderMatcherType_Presence)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Presence != that1.Presence {
		return false
	}
	return true
}
func (this *HeaderMatcherType_CheckPresent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType_CheckPresent)
	if !ok {
		that2, ok := that.(HeaderMatcherType_CheckPresent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckPresent.Equal(that1.CheckPresent) {
		return false
	}
	return true
}
func (this *HeaderMatcherType_CheckNotPresent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType_CheckNotPresent)
	if !ok {
		that2, ok := that.(HeaderMatcherType_CheckNotPresent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckNotPresent.Equal(that1.CheckNotPresent) {
		return false
	}
	return true
}
func (this *HeaderMatcherType_Item) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType_Item)
	if !ok {
		that2, ok := that.(HeaderMatcherType_Item)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Item.Equal(that1.Item) {
		return false
	}
	return true
}
func (this *QueryParameterMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryParameterMatcherType)
	if !ok {
		that2, ok := that.(QueryParameterMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if that1.Match == nil {
		if this.Match != nil {
			return false
		}
	} else if this.Match == nil {
		return false
	} else if !this.Match.Equal(that1.Match) {
		return false
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *QueryParameterMatcherType_Presence) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryParameterMatcherType_Presence)
	if !ok {
		that2, ok := that.(QueryParameterMatcherType_Presence)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Presence != that1.Presence {
		return false
	}
	return true
}
func (this *QueryParameterMatcherType_CheckPresent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryParameterMatcherType_CheckPresent)
	if !ok {
		that2, ok := that.(QueryParameterMatcherType_CheckPresent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckPresent.Equal(that1.CheckPresent) {
		return false
	}
	return true
}
func (this *QueryParameterMatcherType_CheckNotPresent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryParameterMatcherType_CheckNotPresent)
	if !ok {
		that2, ok := that.(QueryParameterMatcherType_CheckNotPresent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckNotPresent.Equal(that1.CheckNotPresent) {
		return false
	}
	return true
}
func (this *QueryParameterMatcherType_Item) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryParameterMatcherType_Item)
	if !ok {
		that2, ok := that.(QueryParameterMatcherType_Item)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Item.Equal(that1.Item) {
		return false
	}
	return true
}
func (this *HttpMethodMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HttpMethodMatcherType)
	if !ok {
		that2, ok := that.(HttpMethodMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Methods) != len(that1.Methods) {
		return false
	}
	for i := range this.Methods {
		if this.Methods[i] != that1.Methods[i] {
			return false
		}
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *RoleMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoleMatcherType)
	if !ok {
		that2, ok := that.(RoleMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Match != that1.Match {
		return false
	}
	return true
}
func (this *StringMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StringMatcherType)
	if !ok {
		that2, ok := that.(StringMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Match) != len(that1.Match) {
		return false
	}
	for i := range this.Match {
		if this.Match[i] != that1.Match[i] {
			return false
		}
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *IpMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpMatcherType)
	if !ok {
		that2, ok := that.(IpMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.PrefixSets) != len(that1.PrefixSets) {
		return false
	}
	for i := range this.PrefixSets {
		if !this.PrefixSets[i].Equal(that1.PrefixSets[i]) {
			return false
		}
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *AsnMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AsnMatcherType)
	if !ok {
		that2, ok := that.(AsnMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.AsnSets) != len(that1.AsnSets) {
		return false
	}
	for i := range this.AsnSets {
		if !this.AsnSets[i].Equal(that1.AsnSets[i]) {
			return false
		}
	}
	return true
}
func (this *PortMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortMatcherType)
	if !ok {
		that2, ok := that.(PortMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if this.Ports[i] != that1.Ports[i] {
			return false
		}
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *URLItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*URLItem)
	if !ok {
		that2, ok := that.(URLItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.DomainChoice == nil {
		if this.DomainChoice != nil {
			return false
		}
	} else if this.DomainChoice == nil {
		return false
	} else if !this.DomainChoice.Equal(that1.DomainChoice) {
		return false
	}
	if that1.PathChoice == nil {
		if this.PathChoice != nil {
			return false
		}
	} else if this.PathChoice == nil {
		return false
	} else if !this.PathChoice.Equal(that1.PathChoice) {
		return false
	}
	return true
}
func (this *URLItem_DomainValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*URLItem_DomainValue)
	if !ok {
		that2, ok := that.(URLItem_DomainValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DomainValue != that1.DomainValue {
		return false
	}
	return true
}
func (this *URLItem_DomainRegex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*URLItem_DomainRegex)
	if !ok {
		that2, ok := that.(URLItem_DomainRegex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DomainRegex != that1.DomainRegex {
		return false
	}
	return true
}
func (this *URLItem_PathValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*URLItem_PathValue)
	if !ok {
		that2, ok := that.(URLItem_PathValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PathValue != that1.PathValue {
		return false
	}
	return true
}
func (this *URLItem_PathPrefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*URLItem_PathPrefix)
	if !ok {
		that2, ok := that.(URLItem_PathPrefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PathPrefix != that1.PathPrefix {
		return false
	}
	return true
}
func (this *URLItem_PathRegex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*URLItem_PathRegex)
	if !ok {
		that2, ok := that.(URLItem_PathRegex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PathRegex != that1.PathRegex {
		return false
	}
	return true
}
func (this *URLMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*URLMatcherType)
	if !ok {
		that2, ok := that.(URLMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.UrlItems) != len(that1.UrlItems) {
		return false
	}
	for i := range this.UrlItems {
		if !this.UrlItems[i].Equal(that1.UrlItems[i]) {
			return false
		}
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *L4DestMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*L4DestMatcherType)
	if !ok {
		that2, ok := that.(L4DestMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.L4Dests) != len(that1.L4Dests) {
		return false
	}
	for i := range this.L4Dests {
		if !this.L4Dests[i].Equal(that1.L4Dests[i]) {
			return false
		}
	}
	if this.InvertMatcher != that1.InvertMatcher {
		return false
	}
	return true
}
func (this *WafRuleControl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.WafRuleControl{")
	if this.ExcludeRuleIds != nil {
		s = append(s, "ExcludeRuleIds: "+fmt.Sprintf("%#v", this.ExcludeRuleIds)+",\n")
	}
	s = append(s, "MonitoringMode: "+fmt.Sprintf("%#v", this.MonitoringMode)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WafInlineRuleControl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.WafInlineRuleControl{")
	s = append(s, "ExcludeRuleIds: "+fmt.Sprintf("%#v", this.ExcludeRuleIds)+",\n")
	s = append(s, "MonitoringMode: "+fmt.Sprintf("%#v", this.MonitoringMode)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WafAction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&policy.WafAction{")
	if this.ActionType != nil {
		s = append(s, "ActionType: "+fmt.Sprintf("%#v", this.ActionType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WafAction_None) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.WafAction_None{` +
		`None:` + fmt.Sprintf("%#v", this.None) + `}`}, ", ")
	return s
}
func (this *WafAction_WafSkipProcessing) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.WafAction_WafSkipProcessing{` +
		`WafSkipProcessing:` + fmt.Sprintf("%#v", this.WafSkipProcessing) + `}`}, ", ")
	return s
}
func (this *WafAction_WafRuleControl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.WafAction_WafRuleControl{` +
		`WafRuleControl:` + fmt.Sprintf("%#v", this.WafRuleControl) + `}`}, ", ")
	return s
}
func (this *WafAction_WafInlineRuleControl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.WafAction_WafInlineRuleControl{` +
		`WafInlineRuleControl:` + fmt.Sprintf("%#v", this.WafInlineRuleControl) + `}`}, ", ")
	return s
}
func (this *WafAction_WafInMonitoringMode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.WafAction_WafInMonitoringMode{` +
		`WafInMonitoringMode:` + fmt.Sprintf("%#v", this.WafInMonitoringMode) + `}`}, ", ")
	return s
}
func (this *PrefixMatchList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.PrefixMatchList{")
	s = append(s, "IpPrefixes: "+fmt.Sprintf("%#v", this.IpPrefixes)+",\n")
	s = append(s, "InvertMatch: "+fmt.Sprintf("%#v", this.InvertMatch)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AsnMatchList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&policy.AsnMatchList{")
	s = append(s, "AsNumbers: "+fmt.Sprintf("%#v", this.AsNumbers)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SimpleWafExclusionRule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&policy.SimpleWafExclusionRule{")
	if this.DomainChoice != nil {
		s = append(s, "DomainChoice: "+fmt.Sprintf("%#v", this.DomainChoice)+",\n")
	}
	s = append(s, "PathRegex: "+fmt.Sprintf("%#v", this.PathRegex)+",\n")
	s = append(s, "Methods: "+fmt.Sprintf("%#v", this.Methods)+",\n")
	s = append(s, "ExcludeRuleIds: "+fmt.Sprintf("%#v", this.ExcludeRuleIds)+",\n")
	if this.ExpirationTimestamp != nil {
		s = append(s, "ExpirationTimestamp: "+fmt.Sprintf("%#v", this.ExpirationTimestamp)+",\n")
	}
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SimpleWafExclusionRule_AnyDomain) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.SimpleWafExclusionRule_AnyDomain{` +
		`AnyDomain:` + fmt.Sprintf("%#v", this.AnyDomain) + `}`}, ", ")
	return s
}
func (this *SimpleWafExclusionRule_DomainRegex) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.SimpleWafExclusionRule_DomainRegex{` +
		`DomainRegex:` + fmt.Sprintf("%#v", this.DomainRegex) + `}`}, ", ")
	return s
}
func (this *DenyInformation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.DenyInformation{")
	s = append(s, "ResponseCode: "+fmt.Sprintf("%#v", this.ResponseCode)+",\n")
	s = append(s, "ErrorMessage: "+fmt.Sprintf("%#v", this.ErrorMessage)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TlsFingerprintMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&policy.TlsFingerprintMatcherType{")
	s = append(s, "Classes: "+fmt.Sprintf("%#v", this.Classes)+",\n")
	s = append(s, "ExactValues: "+fmt.Sprintf("%#v", this.ExactValues)+",\n")
	s = append(s, "ExcludedValues: "+fmt.Sprintf("%#v", this.ExcludedValues)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PathMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&policy.PathMatcherType{")
	s = append(s, "PrefixValues: "+fmt.Sprintf("%#v", this.PrefixValues)+",\n")
	s = append(s, "ExactValues: "+fmt.Sprintf("%#v", this.ExactValues)+",\n")
	s = append(s, "RegexValues: "+fmt.Sprintf("%#v", this.RegexValues)+",\n")
	s = append(s, "Transformers: "+fmt.Sprintf("%#v", this.Transformers)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&policy.MatcherType{")
	s = append(s, "ExactValues: "+fmt.Sprintf("%#v", this.ExactValues)+",\n")
	s = append(s, "RegexValues: "+fmt.Sprintf("%#v", this.RegexValues)+",\n")
	s = append(s, "Transformers: "+fmt.Sprintf("%#v", this.Transformers)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MatcherTypeBasic) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.MatcherTypeBasic{")
	s = append(s, "ExactValues: "+fmt.Sprintf("%#v", this.ExactValues)+",\n")
	s = append(s, "RegexValues: "+fmt.Sprintf("%#v", this.RegexValues)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CookieMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&policy.CookieMatcherType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Match != nil {
		s = append(s, "Match: "+fmt.Sprintf("%#v", this.Match)+",\n")
	}
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CookieMatcherType_Presence) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.CookieMatcherType_Presence{` +
		`Presence:` + fmt.Sprintf("%#v", this.Presence) + `}`}, ", ")
	return s
}
func (this *CookieMatcherType_CheckPresent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.CookieMatcherType_CheckPresent{` +
		`CheckPresent:` + fmt.Sprintf("%#v", this.CheckPresent) + `}`}, ", ")
	return s
}
func (this *CookieMatcherType_CheckNotPresent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.CookieMatcherType_CheckNotPresent{` +
		`CheckNotPresent:` + fmt.Sprintf("%#v", this.CheckNotPresent) + `}`}, ", ")
	return s
}
func (this *CookieMatcherType_Item) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.CookieMatcherType_Item{` +
		`Item:` + fmt.Sprintf("%#v", this.Item) + `}`}, ", ")
	return s
}
func (this *ArgMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&policy.ArgMatcherType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Match != nil {
		s = append(s, "Match: "+fmt.Sprintf("%#v", this.Match)+",\n")
	}
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ArgMatcherType_Presence) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ArgMatcherType_Presence{` +
		`Presence:` + fmt.Sprintf("%#v", this.Presence) + `}`}, ", ")
	return s
}
func (this *ArgMatcherType_CheckPresent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ArgMatcherType_CheckPresent{` +
		`CheckPresent:` + fmt.Sprintf("%#v", this.CheckPresent) + `}`}, ", ")
	return s
}
func (this *ArgMatcherType_CheckNotPresent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ArgMatcherType_CheckNotPresent{` +
		`CheckNotPresent:` + fmt.Sprintf("%#v", this.CheckNotPresent) + `}`}, ", ")
	return s
}
func (this *ArgMatcherType_Item) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.ArgMatcherType_Item{` +
		`Item:` + fmt.Sprintf("%#v", this.Item) + `}`}, ", ")
	return s
}
func (this *HeaderMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&policy.HeaderMatcherType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Match != nil {
		s = append(s, "Match: "+fmt.Sprintf("%#v", this.Match)+",\n")
	}
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HeaderMatcherType_Presence) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.HeaderMatcherType_Presence{` +
		`Presence:` + fmt.Sprintf("%#v", this.Presence) + `}`}, ", ")
	return s
}
func (this *HeaderMatcherType_CheckPresent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.HeaderMatcherType_CheckPresent{` +
		`CheckPresent:` + fmt.Sprintf("%#v", this.CheckPresent) + `}`}, ", ")
	return s
}
func (this *HeaderMatcherType_CheckNotPresent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.HeaderMatcherType_CheckNotPresent{` +
		`CheckNotPresent:` + fmt.Sprintf("%#v", this.CheckNotPresent) + `}`}, ", ")
	return s
}
func (this *HeaderMatcherType_Item) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.HeaderMatcherType_Item{` +
		`Item:` + fmt.Sprintf("%#v", this.Item) + `}`}, ", ")
	return s
}
func (this *QueryParameterMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&policy.QueryParameterMatcherType{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	if this.Match != nil {
		s = append(s, "Match: "+fmt.Sprintf("%#v", this.Match)+",\n")
	}
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueryParameterMatcherType_Presence) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.QueryParameterMatcherType_Presence{` +
		`Presence:` + fmt.Sprintf("%#v", this.Presence) + `}`}, ", ")
	return s
}
func (this *QueryParameterMatcherType_CheckPresent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.QueryParameterMatcherType_CheckPresent{` +
		`CheckPresent:` + fmt.Sprintf("%#v", this.CheckPresent) + `}`}, ", ")
	return s
}
func (this *QueryParameterMatcherType_CheckNotPresent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.QueryParameterMatcherType_CheckNotPresent{` +
		`CheckNotPresent:` + fmt.Sprintf("%#v", this.CheckNotPresent) + `}`}, ", ")
	return s
}
func (this *QueryParameterMatcherType_Item) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.QueryParameterMatcherType_Item{` +
		`Item:` + fmt.Sprintf("%#v", this.Item) + `}`}, ", ")
	return s
}
func (this *HttpMethodMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.HttpMethodMatcherType{")
	s = append(s, "Methods: "+fmt.Sprintf("%#v", this.Methods)+",\n")
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RoleMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&policy.RoleMatcherType{")
	s = append(s, "Match: "+fmt.Sprintf("%#v", this.Match)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StringMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.StringMatcherType{")
	s = append(s, "Match: "+fmt.Sprintf("%#v", this.Match)+",\n")
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IpMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.IpMatcherType{")
	if this.PrefixSets != nil {
		s = append(s, "PrefixSets: "+fmt.Sprintf("%#v", this.PrefixSets)+",\n")
	}
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AsnMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&policy.AsnMatcherType{")
	if this.AsnSets != nil {
		s = append(s, "AsnSets: "+fmt.Sprintf("%#v", this.AsnSets)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PortMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.PortMatcherType{")
	s = append(s, "Ports: "+fmt.Sprintf("%#v", this.Ports)+",\n")
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *URLItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&policy.URLItem{")
	if this.DomainChoice != nil {
		s = append(s, "DomainChoice: "+fmt.Sprintf("%#v", this.DomainChoice)+",\n")
	}
	if this.PathChoice != nil {
		s = append(s, "PathChoice: "+fmt.Sprintf("%#v", this.PathChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *URLItem_DomainValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.URLItem_DomainValue{` +
		`DomainValue:` + fmt.Sprintf("%#v", this.DomainValue) + `}`}, ", ")
	return s
}
func (this *URLItem_DomainRegex) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.URLItem_DomainRegex{` +
		`DomainRegex:` + fmt.Sprintf("%#v", this.DomainRegex) + `}`}, ", ")
	return s
}
func (this *URLItem_PathValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.URLItem_PathValue{` +
		`PathValue:` + fmt.Sprintf("%#v", this.PathValue) + `}`}, ", ")
	return s
}
func (this *URLItem_PathPrefix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.URLItem_PathPrefix{` +
		`PathPrefix:` + fmt.Sprintf("%#v", this.PathPrefix) + `}`}, ", ")
	return s
}
func (this *URLItem_PathRegex) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&policy.URLItem_PathRegex{` +
		`PathRegex:` + fmt.Sprintf("%#v", this.PathRegex) + `}`}, ", ")
	return s
}
func (this *URLMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.URLMatcherType{")
	if this.UrlItems != nil {
		s = append(s, "UrlItems: "+fmt.Sprintf("%#v", this.UrlItems)+",\n")
	}
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *L4DestMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&policy.L4DestMatcherType{")
	if this.L4Dests != nil {
		s = append(s, "L4Dests: "+fmt.Sprintf("%#v", this.L4Dests)+",\n")
	}
	s = append(s, "InvertMatcher: "+fmt.Sprintf("%#v", this.InvertMatcher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *WafRuleControl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WafRuleControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafRuleControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MonitoringMode {
		i--
		if m.MonitoringMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.ExcludeRuleIds) > 0 {
		for iNdEx := len(m.ExcludeRuleIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExcludeRuleIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WafInlineRuleControl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WafInlineRuleControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafInlineRuleControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MonitoringMode {
		i--
		if m.MonitoringMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.ExcludeRuleIds) > 0 {
		dAtA2 := make([]byte, len(m.ExcludeRuleIds)*10)
		var j1 int
		for _, num := range m.ExcludeRuleIds {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintTypes(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WafAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WafAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActionType != nil {
		{
			size := m.ActionType.Size()
			i -= size
			if _, err := m.ActionType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *WafAction_WafSkipProcessing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafAction_WafSkipProcessing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.WafSkipProcessing != nil {
		{
			size, err := m.WafSkipProcessing.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *WafAction_WafRuleControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafAction_WafRuleControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.WafRuleControl != nil {
		{
			size, err := m.WafRuleControl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *WafAction_None) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafAction_None) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.None != nil {
		{
			size, err := m.None.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *WafAction_WafInlineRuleControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafAction_WafInlineRuleControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.WafInlineRuleControl != nil {
		{
			size, err := m.WafInlineRuleControl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *WafAction_WafInMonitoringMode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafAction_WafInMonitoringMode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.WafInMonitoringMode != nil {
		{
			size, err := m.WafInMonitoringMode.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *PrefixMatchList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrefixMatchList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrefixMatchList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InvertMatch {
		i--
		if m.InvertMatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.IpPrefixes) > 0 {
		for iNdEx := len(m.IpPrefixes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IpPrefixes[iNdEx])
			copy(dAtA[i:], m.IpPrefixes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.IpPrefixes[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AsnMatchList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AsnMatchList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AsnMatchList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AsNumbers) > 0 {
		dAtA9 := make([]byte, len(m.AsNumbers)*10)
		var j8 int
		for _, num := range m.AsNumbers {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintTypes(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SimpleWafExclusionRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimpleWafExclusionRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleWafExclusionRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.ExpirationTimestamp != nil {
		{
			size, err := m.ExpirationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ExcludeRuleIds) > 0 {
		dAtA13 := make([]byte, len(m.ExcludeRuleIds)*10)
		var j12 int
		for _, num := range m.ExcludeRuleIds {
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintTypes(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Methods) > 0 {
		dAtA15 := make([]byte, len(m.Methods)*10)
		var j14 int
		for _, num := range m.Methods {
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		i -= j14
		copy(dAtA[i:], dAtA15[:j14])
		i = encodeVarintTypes(dAtA, i, uint64(j14))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PathRegex) > 0 {
		i -= len(m.PathRegex)
		copy(dAtA[i:], m.PathRegex)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PathRegex)))
		i--
		dAtA[i] = 0x32
	}
	if m.DomainChoice != nil {
		{
			size := m.DomainChoice.Size()
			i -= size
			if _, err := m.DomainChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SimpleWafExclusionRule_AnyDomain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleWafExclusionRule_AnyDomain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyDomain != nil {
		{
			size, err := m.AnyDomain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *SimpleWafExclusionRule_DomainRegex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleWafExclusionRule_DomainRegex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.DomainRegex)
	copy(dAtA[i:], m.DomainRegex)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DomainRegex)))
	i--
	dAtA[i] = 0x2a
	return len(dAtA) - i, nil
}
func (m *DenyInformation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DenyInformation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DenyInformation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.ResponseCode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ResponseCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TlsFingerprintMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsFingerprintMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsFingerprintMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExcludedValues) > 0 {
		for iNdEx := len(m.ExcludedValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExcludedValues[iNdEx])
			copy(dAtA[i:], m.ExcludedValues[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ExcludedValues[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ExactValues) > 0 {
		for iNdEx := len(m.ExactValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExactValues[iNdEx])
			copy(dAtA[i:], m.ExactValues[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ExactValues[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Classes) > 0 {
		dAtA18 := make([]byte, len(m.Classes)*10)
		var j17 int
		for _, num := range m.Classes {
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		i -= j17
		copy(dAtA[i:], dAtA18[:j17])
		i = encodeVarintTypes(dAtA, i, uint64(j17))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PathMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PathMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PathMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Transformers) > 0 {
		dAtA20 := make([]byte, len(m.Transformers)*10)
		var j19 int
		for _, num := range m.Transformers {
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		i -= j19
		copy(dAtA[i:], dAtA20[:j19])
		i = encodeVarintTypes(dAtA, i, uint64(j19))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RegexValues) > 0 {
		for iNdEx := len(m.RegexValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RegexValues[iNdEx])
			copy(dAtA[i:], m.RegexValues[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RegexValues[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ExactValues) > 0 {
		for iNdEx := len(m.ExactValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExactValues[iNdEx])
			copy(dAtA[i:], m.ExactValues[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ExactValues[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PrefixValues) > 0 {
		for iNdEx := len(m.PrefixValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PrefixValues[iNdEx])
			copy(dAtA[i:], m.PrefixValues[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.PrefixValues[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Transformers) > 0 {
		dAtA22 := make([]byte, len(m.Transformers)*10)
		var j21 int
		for _, num := range m.Transformers {
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		i -= j21
		copy(dAtA[i:], dAtA22[:j21])
		i = encodeVarintTypes(dAtA, i, uint64(j21))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RegexValues) > 0 {
		for iNdEx := len(m.RegexValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RegexValues[iNdEx])
			copy(dAtA[i:], m.RegexValues[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RegexValues[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ExactValues) > 0 {
		for iNdEx := len(m.ExactValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExactValues[iNdEx])
			copy(dAtA[i:], m.ExactValues[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ExactValues[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MatcherTypeBasic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatcherTypeBasic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatcherTypeBasic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RegexValues) > 0 {
		for iNdEx := len(m.RegexValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RegexValues[iNdEx])
			copy(dAtA[i:], m.RegexValues[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RegexValues[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ExactValues) > 0 {
		for iNdEx := len(m.ExactValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExactValues[iNdEx])
			copy(dAtA[i:], m.ExactValues[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ExactValues[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CookieMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CookieMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Match != nil {
		{
			size := m.Match.Size()
			i -= size
			if _, err := m.Match.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.InvertMatcher {
		i--
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CookieMatcherType_Presence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieMatcherType_Presence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Presence {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *CookieMatcherType_Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieMatcherType_Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CookieMatcherType_CheckPresent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieMatcherType_CheckPresent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckPresent != nil {
		{
			size, err := m.CheckPresent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *CookieMatcherType_CheckNotPresent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieMatcherType_CheckNotPresent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckNotPresent != nil {
		{
			size, err := m.CheckNotPresent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *ArgMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Match != nil {
		{
			size := m.Match.Size()
			i -= size
			if _, err := m.Match.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.InvertMatcher {
		i--
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ArgMatcherType_Presence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgMatcherType_Presence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Presence {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *ArgMatcherType_Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgMatcherType_Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ArgMatcherType_CheckPresent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgMatcherType_CheckPresent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckPresent != nil {
		{
			size, err := m.CheckPresent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *ArgMatcherType_CheckNotPresent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgMatcherType_CheckNotPresent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckNotPresent != nil {
		{
			size, err := m.CheckNotPresent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *HeaderMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeaderMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Match != nil {
		{
			size := m.Match.Size()
			i -= size
			if _, err := m.Match.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.InvertMatcher {
		i--
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HeaderMatcherType_Presence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherType_Presence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Presence {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *HeaderMatcherType_Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherType_Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *HeaderMatcherType_CheckPresent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherType_CheckPresent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckPresent != nil {
		{
			size, err := m.CheckPresent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *HeaderMatcherType_CheckNotPresent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherType_CheckNotPresent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckNotPresent != nil {
		{
			size, err := m.CheckNotPresent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *QueryParameterMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryParameterMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParameterMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Match != nil {
		{
			size := m.Match.Size()
			i -= size
			if _, err := m.Match.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.InvertMatcher {
		i--
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryParameterMatcherType_Presence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParameterMatcherType_Presence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Presence {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *QueryParameterMatcherType_Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParameterMatcherType_Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *QueryParameterMatcherType_CheckPresent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParameterMatcherType_CheckPresent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckPresent != nil {
		{
			size, err := m.CheckPresent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *QueryParameterMatcherType_CheckNotPresent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParameterMatcherType_CheckNotPresent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckNotPresent != nil {
		{
			size, err := m.CheckNotPresent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *HttpMethodMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpMethodMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpMethodMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InvertMatcher {
		i--
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Methods) > 0 {
		dAtA36 := make([]byte, len(m.Methods)*10)
		var j35 int
		for _, num := range m.Methods {
			for num >= 1<<7 {
				dAtA36[j35] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j35++
			}
			dAtA36[j35] = uint8(num)
			j35++
		}
		i -= j35
		copy(dAtA[i:], dAtA36[:j35])
		i = encodeVarintTypes(dAtA, i, uint64(j35))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RoleMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Match) > 0 {
		i -= len(m.Match)
		copy(dAtA[i:], m.Match)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Match)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StringMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InvertMatcher {
		i--
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Match) > 0 {
		for iNdEx := len(m.Match) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Match[iNdEx])
			copy(dAtA[i:], m.Match[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Match[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IpMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InvertMatcher {
		i--
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.PrefixSets) > 0 {
		for iNdEx := len(m.PrefixSets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PrefixSets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AsnMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AsnMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AsnMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AsnSets) > 0 {
		for iNdEx := len(m.AsnSets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AsnSets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PortMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InvertMatcher {
		i--
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Ports[iNdEx])
			copy(dAtA[i:], m.Ports[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Ports[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *URLItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *URLItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *URLItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PathChoice != nil {
		{
			size := m.PathChoice.Size()
			i -= size
			if _, err := m.PathChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.DomainChoice != nil {
		{
			size := m.DomainChoice.Size()
			i -= size
			if _, err := m.DomainChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *URLItem_DomainValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *URLItem_DomainValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.DomainValue)
	copy(dAtA[i:], m.DomainValue)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DomainValue)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *URLItem_DomainRegex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *URLItem_DomainRegex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.DomainRegex)
	copy(dAtA[i:], m.DomainRegex)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DomainRegex)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *URLItem_PathValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *URLItem_PathValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.PathValue)
	copy(dAtA[i:], m.PathValue)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.PathValue)))
	i--
	dAtA[i] = 0x2a
	return len(dAtA) - i, nil
}
func (m *URLItem_PathRegex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *URLItem_PathRegex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.PathRegex)
	copy(dAtA[i:], m.PathRegex)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.PathRegex)))
	i--
	dAtA[i] = 0x32
	return len(dAtA) - i, nil
}
func (m *URLItem_PathPrefix) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *URLItem_PathPrefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.PathPrefix)
	copy(dAtA[i:], m.PathPrefix)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.PathPrefix)))
	i--
	dAtA[i] = 0x3a
	return len(dAtA) - i, nil
}
func (m *URLMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *URLMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *URLMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InvertMatcher {
		i--
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.UrlItems) > 0 {
		for iNdEx := len(m.UrlItems) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UrlItems[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *L4DestMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4DestMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L4DestMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.L4Dests) > 0 {
		for iNdEx := len(m.L4Dests) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.L4Dests[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.InvertMatcher {
		i--
		if m.InvertMatcher {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *WafRuleControl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ExcludeRuleIds) > 0 {
		for _, e := range m.ExcludeRuleIds {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.MonitoringMode {
		n += 2
	}
	return n
}

func (m *WafInlineRuleControl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ExcludeRuleIds) > 0 {
		l = 0
		for _, e := range m.ExcludeRuleIds {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.MonitoringMode {
		n += 2
	}
	return n
}

func (m *WafAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActionType != nil {
		n += m.ActionType.Size()
	}
	return n
}

func (m *WafAction_WafSkipProcessing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WafSkipProcessing != nil {
		l = m.WafSkipProcessing.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WafAction_WafRuleControl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WafRuleControl != nil {
		l = m.WafRuleControl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WafAction_None) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.None != nil {
		l = m.None.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WafAction_WafInlineRuleControl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WafInlineRuleControl != nil {
		l = m.WafInlineRuleControl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WafAction_WafInMonitoringMode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WafInMonitoringMode != nil {
		l = m.WafInMonitoringMode.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PrefixMatchList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IpPrefixes) > 0 {
		for _, s := range m.IpPrefixes {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InvertMatch {
		n += 2
	}
	return n
}

func (m *AsnMatchList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AsNumbers) > 0 {
		l = 0
		for _, e := range m.AsNumbers {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *SimpleWafExclusionRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DomainChoice != nil {
		n += m.DomainChoice.Size()
	}
	l = len(m.PathRegex)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Methods) > 0 {
		l = 0
		for _, e := range m.Methods {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.ExcludeRuleIds) > 0 {
		l = 0
		for _, e := range m.ExcludeRuleIds {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.ExpirationTimestamp != nil {
		l = m.ExpirationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SimpleWafExclusionRule_AnyDomain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyDomain != nil {
		l = m.AnyDomain.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SimpleWafExclusionRule_DomainRegex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DomainRegex)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *DenyInformation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResponseCode != 0 {
		n += 1 + sovTypes(uint64(m.ResponseCode))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *TlsFingerprintMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Classes) > 0 {
		l = 0
		for _, e := range m.Classes {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.ExactValues) > 0 {
		for _, s := range m.ExactValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ExcludedValues) > 0 {
		for _, s := range m.ExcludedValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *PathMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PrefixValues) > 0 {
		for _, s := range m.PrefixValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ExactValues) > 0 {
		for _, s := range m.ExactValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RegexValues) > 0 {
		for _, s := range m.RegexValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Transformers) > 0 {
		l = 0
		for _, e := range m.Transformers {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *MatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ExactValues) > 0 {
		for _, s := range m.ExactValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RegexValues) > 0 {
		for _, s := range m.RegexValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Transformers) > 0 {
		l = 0
		for _, e := range m.Transformers {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *MatcherTypeBasic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ExactValues) > 0 {
		for _, s := range m.ExactValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RegexValues) > 0 {
		for _, s := range m.RegexValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CookieMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Match != nil {
		n += m.Match.Size()
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *CookieMatcherType_Presence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *CookieMatcherType_Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CookieMatcherType_CheckPresent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckPresent != nil {
		l = m.CheckPresent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CookieMatcherType_CheckNotPresent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckNotPresent != nil {
		l = m.CheckNotPresent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ArgMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Match != nil {
		n += m.Match.Size()
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *ArgMatcherType_Presence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *ArgMatcherType_Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ArgMatcherType_CheckPresent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckPresent != nil {
		l = m.CheckPresent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ArgMatcherType_CheckNotPresent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckNotPresent != nil {
		l = m.CheckNotPresent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HeaderMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Match != nil {
		n += m.Match.Size()
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *HeaderMatcherType_Presence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *HeaderMatcherType_Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HeaderMatcherType_CheckPresent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckPresent != nil {
		l = m.CheckPresent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HeaderMatcherType_CheckNotPresent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckNotPresent != nil {
		l = m.CheckNotPresent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *QueryParameterMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Match != nil {
		n += m.Match.Size()
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *QueryParameterMatcherType_Presence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *QueryParameterMatcherType_Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *QueryParameterMatcherType_CheckPresent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckPresent != nil {
		l = m.CheckPresent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *QueryParameterMatcherType_CheckNotPresent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckNotPresent != nil {
		l = m.CheckNotPresent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HttpMethodMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Methods) > 0 {
		l = 0
		for _, e := range m.Methods {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *RoleMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Match)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StringMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Match) > 0 {
		for _, s := range m.Match {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *IpMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PrefixSets) > 0 {
		for _, e := range m.PrefixSets {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *AsnMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AsnSets) > 0 {
		for _, e := range m.AsnSets {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *PortMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for _, s := range m.Ports {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *URLItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DomainChoice != nil {
		n += m.DomainChoice.Size()
	}
	if m.PathChoice != nil {
		n += m.PathChoice.Size()
	}
	return n
}

func (m *URLItem_DomainValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DomainValue)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *URLItem_DomainRegex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DomainRegex)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *URLItem_PathValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PathValue)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *URLItem_PathRegex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PathRegex)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *URLItem_PathPrefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PathPrefix)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *URLMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UrlItems) > 0 {
		for _, e := range m.UrlItems {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InvertMatcher {
		n += 2
	}
	return n
}

func (m *L4DestMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InvertMatcher {
		n += 2
	}
	if len(m.L4Dests) > 0 {
		for _, e := range m.L4Dests {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *WafRuleControl) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForExcludeRuleIds := "[]*ObjectRefType{"
	for _, f := range this.ExcludeRuleIds {
		repeatedStringForExcludeRuleIds += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForExcludeRuleIds += "}"
	s := strings.Join([]string{`&WafRuleControl{`,
		`ExcludeRuleIds:` + repeatedStringForExcludeRuleIds + `,`,
		`MonitoringMode:` + fmt.Sprintf("%v", this.MonitoringMode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafInlineRuleControl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafInlineRuleControl{`,
		`ExcludeRuleIds:` + fmt.Sprintf("%v", this.ExcludeRuleIds) + `,`,
		`MonitoringMode:` + fmt.Sprintf("%v", this.MonitoringMode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafAction) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafAction{`,
		`ActionType:` + fmt.Sprintf("%v", this.ActionType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafAction_WafSkipProcessing) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafAction_WafSkipProcessing{`,
		`WafSkipProcessing:` + strings.Replace(fmt.Sprintf("%v", this.WafSkipProcessing), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafAction_WafRuleControl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafAction_WafRuleControl{`,
		`WafRuleControl:` + strings.Replace(fmt.Sprintf("%v", this.WafRuleControl), "WafRuleControl", "WafRuleControl", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafAction_None) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafAction_None{`,
		`None:` + strings.Replace(fmt.Sprintf("%v", this.None), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafAction_WafInlineRuleControl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafAction_WafInlineRuleControl{`,
		`WafInlineRuleControl:` + strings.Replace(fmt.Sprintf("%v", this.WafInlineRuleControl), "WafInlineRuleControl", "WafInlineRuleControl", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafAction_WafInMonitoringMode) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafAction_WafInMonitoringMode{`,
		`WafInMonitoringMode:` + strings.Replace(fmt.Sprintf("%v", this.WafInMonitoringMode), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PrefixMatchList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PrefixMatchList{`,
		`IpPrefixes:` + fmt.Sprintf("%v", this.IpPrefixes) + `,`,
		`InvertMatch:` + fmt.Sprintf("%v", this.InvertMatch) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AsnMatchList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AsnMatchList{`,
		`AsNumbers:` + fmt.Sprintf("%v", this.AsNumbers) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SimpleWafExclusionRule) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SimpleWafExclusionRule{`,
		`DomainChoice:` + fmt.Sprintf("%v", this.DomainChoice) + `,`,
		`PathRegex:` + fmt.Sprintf("%v", this.PathRegex) + `,`,
		`Methods:` + fmt.Sprintf("%v", this.Methods) + `,`,
		`ExcludeRuleIds:` + fmt.Sprintf("%v", this.ExcludeRuleIds) + `,`,
		`ExpirationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "MessageMetaType", "schema.MessageMetaType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SimpleWafExclusionRule_AnyDomain) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SimpleWafExclusionRule_AnyDomain{`,
		`AnyDomain:` + strings.Replace(fmt.Sprintf("%v", this.AnyDomain), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SimpleWafExclusionRule_DomainRegex) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SimpleWafExclusionRule_DomainRegex{`,
		`DomainRegex:` + fmt.Sprintf("%v", this.DomainRegex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DenyInformation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DenyInformation{`,
		`ResponseCode:` + fmt.Sprintf("%v", this.ResponseCode) + `,`,
		`ErrorMessage:` + fmt.Sprintf("%v", this.ErrorMessage) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsFingerprintMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsFingerprintMatcherType{`,
		`Classes:` + fmt.Sprintf("%v", this.Classes) + `,`,
		`ExactValues:` + fmt.Sprintf("%v", this.ExactValues) + `,`,
		`ExcludedValues:` + fmt.Sprintf("%v", this.ExcludedValues) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PathMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PathMatcherType{`,
		`PrefixValues:` + fmt.Sprintf("%v", this.PrefixValues) + `,`,
		`ExactValues:` + fmt.Sprintf("%v", this.ExactValues) + `,`,
		`RegexValues:` + fmt.Sprintf("%v", this.RegexValues) + `,`,
		`Transformers:` + fmt.Sprintf("%v", this.Transformers) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MatcherType{`,
		`ExactValues:` + fmt.Sprintf("%v", this.ExactValues) + `,`,
		`RegexValues:` + fmt.Sprintf("%v", this.RegexValues) + `,`,
		`Transformers:` + fmt.Sprintf("%v", this.Transformers) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MatcherTypeBasic) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MatcherTypeBasic{`,
		`ExactValues:` + fmt.Sprintf("%v", this.ExactValues) + `,`,
		`RegexValues:` + fmt.Sprintf("%v", this.RegexValues) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieMatcherType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Match:` + fmt.Sprintf("%v", this.Match) + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieMatcherType_Presence) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieMatcherType_Presence{`,
		`Presence:` + fmt.Sprintf("%v", this.Presence) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieMatcherType_Item) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieMatcherType_Item{`,
		`Item:` + strings.Replace(fmt.Sprintf("%v", this.Item), "MatcherType", "MatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieMatcherType_CheckPresent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieMatcherType_CheckPresent{`,
		`CheckPresent:` + strings.Replace(fmt.Sprintf("%v", this.CheckPresent), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieMatcherType_CheckNotPresent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieMatcherType_CheckNotPresent{`,
		`CheckNotPresent:` + strings.Replace(fmt.Sprintf("%v", this.CheckNotPresent), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ArgMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ArgMatcherType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Match:` + fmt.Sprintf("%v", this.Match) + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ArgMatcherType_Presence) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ArgMatcherType_Presence{`,
		`Presence:` + fmt.Sprintf("%v", this.Presence) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ArgMatcherType_Item) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ArgMatcherType_Item{`,
		`Item:` + strings.Replace(fmt.Sprintf("%v", this.Item), "MatcherType", "MatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ArgMatcherType_CheckPresent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ArgMatcherType_CheckPresent{`,
		`CheckPresent:` + strings.Replace(fmt.Sprintf("%v", this.CheckPresent), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ArgMatcherType_CheckNotPresent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ArgMatcherType_CheckNotPresent{`,
		`CheckNotPresent:` + strings.Replace(fmt.Sprintf("%v", this.CheckNotPresent), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Match:` + fmt.Sprintf("%v", this.Match) + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType_Presence) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType_Presence{`,
		`Presence:` + fmt.Sprintf("%v", this.Presence) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType_Item) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType_Item{`,
		`Item:` + strings.Replace(fmt.Sprintf("%v", this.Item), "MatcherType", "MatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType_CheckPresent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType_CheckPresent{`,
		`CheckPresent:` + strings.Replace(fmt.Sprintf("%v", this.CheckPresent), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType_CheckNotPresent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType_CheckNotPresent{`,
		`CheckNotPresent:` + strings.Replace(fmt.Sprintf("%v", this.CheckNotPresent), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryParameterMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueryParameterMatcherType{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Match:` + fmt.Sprintf("%v", this.Match) + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryParameterMatcherType_Presence) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueryParameterMatcherType_Presence{`,
		`Presence:` + fmt.Sprintf("%v", this.Presence) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryParameterMatcherType_Item) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueryParameterMatcherType_Item{`,
		`Item:` + strings.Replace(fmt.Sprintf("%v", this.Item), "MatcherType", "MatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryParameterMatcherType_CheckPresent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueryParameterMatcherType_CheckPresent{`,
		`CheckPresent:` + strings.Replace(fmt.Sprintf("%v", this.CheckPresent), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryParameterMatcherType_CheckNotPresent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueryParameterMatcherType_CheckNotPresent{`,
		`CheckNotPresent:` + strings.Replace(fmt.Sprintf("%v", this.CheckNotPresent), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HttpMethodMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HttpMethodMatcherType{`,
		`Methods:` + fmt.Sprintf("%v", this.Methods) + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RoleMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RoleMatcherType{`,
		`Match:` + fmt.Sprintf("%v", this.Match) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StringMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StringMatcherType{`,
		`Match:` + fmt.Sprintf("%v", this.Match) + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPrefixSets := "[]*ObjectRefType{"
	for _, f := range this.PrefixSets {
		repeatedStringForPrefixSets += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForPrefixSets += "}"
	s := strings.Join([]string{`&IpMatcherType{`,
		`PrefixSets:` + repeatedStringForPrefixSets + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AsnMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAsnSets := "[]*ObjectRefType{"
	for _, f := range this.AsnSets {
		repeatedStringForAsnSets += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForAsnSets += "}"
	s := strings.Join([]string{`&AsnMatcherType{`,
		`AsnSets:` + repeatedStringForAsnSets + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortMatcherType{`,
		`Ports:` + fmt.Sprintf("%v", this.Ports) + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *URLItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&URLItem{`,
		`DomainChoice:` + fmt.Sprintf("%v", this.DomainChoice) + `,`,
		`PathChoice:` + fmt.Sprintf("%v", this.PathChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *URLItem_DomainValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&URLItem_DomainValue{`,
		`DomainValue:` + fmt.Sprintf("%v", this.DomainValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *URLItem_DomainRegex) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&URLItem_DomainRegex{`,
		`DomainRegex:` + fmt.Sprintf("%v", this.DomainRegex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *URLItem_PathValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&URLItem_PathValue{`,
		`PathValue:` + fmt.Sprintf("%v", this.PathValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *URLItem_PathRegex) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&URLItem_PathRegex{`,
		`PathRegex:` + fmt.Sprintf("%v", this.PathRegex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *URLItem_PathPrefix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&URLItem_PathPrefix{`,
		`PathPrefix:` + fmt.Sprintf("%v", this.PathPrefix) + `,`,
		`}`,
	}, "")
	return s
}
func (this *URLMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForUrlItems := "[]*URLItem{"
	for _, f := range this.UrlItems {
		repeatedStringForUrlItems += strings.Replace(f.String(), "URLItem", "URLItem", 1) + ","
	}
	repeatedStringForUrlItems += "}"
	s := strings.Join([]string{`&URLMatcherType{`,
		`UrlItems:` + repeatedStringForUrlItems + `,`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *L4DestMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForL4Dests := "[]*L4DestType{"
	for _, f := range this.L4Dests {
		repeatedStringForL4Dests += strings.Replace(fmt.Sprintf("%v", f), "L4DestType", "schema.L4DestType", 1) + ","
	}
	repeatedStringForL4Dests += "}"
	s := strings.Join([]string{`&L4DestMatcherType{`,
		`InvertMatcher:` + fmt.Sprintf("%v", this.InvertMatcher) + `,`,
		`L4Dests:` + repeatedStringForL4Dests + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *WafRuleControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WafRuleControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WafRuleControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeRuleIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExcludeRuleIds = append(m.ExcludeRuleIds, &schema.ObjectRefType{})
			if err := m.ExcludeRuleIds[len(m.ExcludeRuleIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonitoringMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MonitoringMode = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WafInlineRuleControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WafInlineRuleControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WafInlineRuleControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v waf_rule_list.WafRuleID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= waf_rule_list.WafRuleID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ExcludeRuleIds = append(m.ExcludeRuleIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ExcludeRuleIds) == 0 {
					m.ExcludeRuleIds = make([]waf_rule_list.WafRuleID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v waf_rule_list.WafRuleID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= waf_rule_list.WafRuleID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ExcludeRuleIds = append(m.ExcludeRuleIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeRuleIds", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonitoringMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MonitoringMode = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WafAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WafAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WafAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafSkipProcessing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionType = &WafAction_WafSkipProcessing{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafRuleControl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WafRuleControl{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionType = &WafAction_WafRuleControl{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field None", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionType = &WafAction_None{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafInlineRuleControl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WafInlineRuleControl{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionType = &WafAction_WafInlineRuleControl{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafInMonitoringMode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionType = &WafAction_WafInMonitoringMode{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrefixMatchList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrefixMatchList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrefixMatchList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpPrefixes = append(m.IpPrefixes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatch = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AsnMatchList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AsnMatchList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AsnMatchList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AsNumbers = append(m.AsNumbers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AsNumbers) == 0 {
					m.AsNumbers = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AsNumbers = append(m.AsNumbers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AsNumbers", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimpleWafExclusionRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleWafExclusionRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleWafExclusionRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyDomain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DomainChoice = &SimpleWafExclusionRule_AnyDomain{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainRegex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainChoice = &SimpleWafExclusionRule_DomainRegex{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathRegex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathRegex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v schema.HttpMethod
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= schema.HttpMethod(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Methods = append(m.Methods, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Methods) == 0 {
					m.Methods = make([]schema.HttpMethod, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v schema.HttpMethod
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= schema.HttpMethod(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Methods = append(m.Methods, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Methods", wireType)
			}
		case 8:
			if wireType == 0 {
				var v waf_rule_list.WafRuleID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= waf_rule_list.WafRuleID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ExcludeRuleIds = append(m.ExcludeRuleIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ExcludeRuleIds) == 0 {
					m.ExcludeRuleIds = make([]waf_rule_list.WafRuleID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v waf_rule_list.WafRuleID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= waf_rule_list.WafRuleID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ExcludeRuleIds = append(m.ExcludeRuleIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeRuleIds", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpirationTimestamp == nil {
				m.ExpirationTimestamp = &types.Timestamp{}
			}
			if err := m.ExpirationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &schema.MessageMetaType{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DenyInformation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DenyInformation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DenyInformation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
			}
			m.ResponseCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsFingerprintMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsFingerprintMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsFingerprintMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v KnownTlsFingerprintClass
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= KnownTlsFingerprintClass(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Classes = append(m.Classes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Classes) == 0 {
					m.Classes = make([]KnownTlsFingerprintClass, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v KnownTlsFingerprintClass
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= KnownTlsFingerprintClass(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Classes = append(m.Classes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Classes", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExactValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExactValues = append(m.ExactValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludedValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExcludedValues = append(m.ExcludedValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PathMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrefixValues = append(m.PrefixValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExactValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExactValues = append(m.ExactValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegexValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegexValues = append(m.RegexValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v Transformer
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Transformer(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Transformers = append(m.Transformers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Transformers) == 0 {
					m.Transformers = make([]Transformer, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Transformer
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Transformer(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Transformers = append(m.Transformers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Transformers", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExactValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExactValues = append(m.ExactValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegexValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegexValues = append(m.RegexValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v Transformer
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Transformer(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Transformers = append(m.Transformers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Transformers) == 0 {
					m.Transformers = make([]Transformer, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Transformer
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Transformer(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Transformers = append(m.Transformers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Transformers", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatcherTypeBasic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatcherTypeBasic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatcherTypeBasic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExactValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExactValues = append(m.ExactValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegexValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegexValues = append(m.RegexValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CookieMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CookieMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CookieMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Presence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Match = &CookieMatcherType_Presence{b}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &CookieMatcherType_Item{v}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckPresent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &CookieMatcherType_CheckPresent{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckNotPresent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &CookieMatcherType_CheckNotPresent{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Presence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Match = &ArgMatcherType_Presence{b}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &ArgMatcherType_Item{v}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckPresent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &ArgMatcherType_CheckPresent{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckNotPresent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &ArgMatcherType_CheckNotPresent{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeaderMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Presence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Match = &HeaderMatcherType_Presence{b}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &HeaderMatcherType_Item{v}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckPresent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &HeaderMatcherType_CheckPresent{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckNotPresent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &HeaderMatcherType_CheckNotPresent{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryParameterMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParameterMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParameterMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Presence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Match = &QueryParameterMatcherType_Presence{b}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &QueryParameterMatcherType_Item{v}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckPresent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &QueryParameterMatcherType_CheckPresent{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckNotPresent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Match = &QueryParameterMatcherType_CheckNotPresent{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpMethodMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpMethodMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpMethodMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v schema.HttpMethod
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= schema.HttpMethod(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Methods = append(m.Methods, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Methods) == 0 {
					m.Methods = make([]schema.HttpMethod, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v schema.HttpMethod
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= schema.HttpMethod(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Methods = append(m.Methods, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Methods", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Match = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Match = append(m.Match, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrefixSets = append(m.PrefixSets, &schema.ObjectRefType{})
			if err := m.PrefixSets[len(m.PrefixSets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AsnMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AsnMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AsnMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AsnSets = append(m.AsnSets, &schema.ObjectRefType{})
			if err := m.AsnSets[len(m.AsnSets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *URLItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: URLItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: URLItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainChoice = &URLItem_DomainValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainRegex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainChoice = &URLItem_DomainRegex{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathChoice = &URLItem_PathValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathRegex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathChoice = &URLItem_PathRegex{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathChoice = &URLItem_PathPrefix{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *URLMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: URLMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: URLMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UrlItems = append(m.UrlItems, &URLItem{})
			if err := m.UrlItems[len(m.UrlItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4DestMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4DestMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4DestMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatcher", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatcher = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4Dests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.L4Dests = append(m.L4Dests, &schema.L4DestType{})
			if err := m.L4Dests[len(m.L4Dests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
