// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package addon_service

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AddonServiceActivationStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AddonServiceActivationStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AddonServiceActivationStatus) DeepCopy() *AddonServiceActivationStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AddonServiceActivationStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AddonServiceActivationStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AddonServiceActivationStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AddonServiceActivationStatusValidator().Validate(ctx, m, opts...)
}

type ValidateAddonServiceActivationStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAddonServiceActivationStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AddonServiceActivationStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AddonServiceActivationStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["access_status"]; exists {

		vOpts := append(opts, db.WithValidateField("access_status"))
		if err := fv(ctx, m.GetAccessStatus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["addon_service_status"]; exists {

		vOpts := append(opts, db.WithValidateField("addon_service_status"))
		if err := fv(ctx, m.GetAddonServiceStatus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["display_name"]; exists {

		vOpts := append(opts, db.WithValidateField("display_name"))
		if err := fv(ctx, m.GetDisplayName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tier"]; exists {

		vOpts := append(opts, db.WithValidateField("tier"))
		if err := fv(ctx, m.GetTier(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAddonServiceActivationStatusValidator = func() *ValidateAddonServiceActivationStatus {
	v := &ValidateAddonServiceActivationStatus{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func AddonServiceActivationStatusValidator() db.Validator {
	return DefaultAddonServiceActivationStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *GetActivationStatusReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetActivationStatusReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetActivationStatusReq) DeepCopy() *GetActivationStatusReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetActivationStatusReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetActivationStatusReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetActivationStatusReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetActivationStatusReqValidator().Validate(ctx, m, opts...)
}

type ValidateGetActivationStatusReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetActivationStatusReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetActivationStatusReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetActivationStatusReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["addon_service"]; exists {

		vOpts := append(opts, db.WithValidateField("addon_service"))
		if err := fv(ctx, m.GetAddonService(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetActivationStatusReqValidator = func() *ValidateGetActivationStatusReq {
	v := &ValidateGetActivationStatusReq{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetActivationStatusReqValidator() db.Validator {
	return DefaultGetActivationStatusReqValidator
}

// augmented methods on protoc/std generated struct

func (m *GetActivationStatusResp) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetActivationStatusResp) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetActivationStatusResp) DeepCopy() *GetActivationStatusResp {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetActivationStatusResp{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetActivationStatusResp) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetActivationStatusResp) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetActivationStatusRespValidator().Validate(ctx, m, opts...)
}

type ValidateGetActivationStatusResp struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetActivationStatusResp) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetActivationStatusResp)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetActivationStatusResp got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetActivationStatusRespValidator = func() *ValidateGetActivationStatusResp {
	v := &ValidateGetActivationStatusResp{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetActivationStatusRespValidator() db.Validator {
	return DefaultGetActivationStatusRespValidator
}

// augmented methods on protoc/std generated struct

func (m *GetAddonServiceDetailsReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetAddonServiceDetailsReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetAddonServiceDetailsReq) DeepCopy() *GetAddonServiceDetailsReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetAddonServiceDetailsReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetAddonServiceDetailsReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetAddonServiceDetailsReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetAddonServiceDetailsReqValidator().Validate(ctx, m, opts...)
}

type ValidateGetAddonServiceDetailsReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetAddonServiceDetailsReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetAddonServiceDetailsReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetAddonServiceDetailsReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetAddonServiceDetailsReqValidator = func() *ValidateGetAddonServiceDetailsReq {
	v := &ValidateGetAddonServiceDetailsReq{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetAddonServiceDetailsReqValidator() db.Validator {
	return DefaultGetAddonServiceDetailsReqValidator
}

// augmented methods on protoc/std generated struct

func (m *GetAddonServiceDetailsResp) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetAddonServiceDetailsResp) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetAddonServiceDetailsResp) DeepCopy() *GetAddonServiceDetailsResp {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetAddonServiceDetailsResp{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetAddonServiceDetailsResp) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetAddonServiceDetailsResp) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetAddonServiceDetailsRespValidator().Validate(ctx, m, opts...)
}

type ValidateGetAddonServiceDetailsResp struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetAddonServiceDetailsResp) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetAddonServiceDetailsResp)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetAddonServiceDetailsResp got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetActivationTypeChoice().(type) {
	case *GetAddonServiceDetailsResp_SelfActivation:
		if fv, exists := v.FldValidators["activation_type_choice.self_activation"]; exists {
			val := m.GetActivationTypeChoice().(*GetAddonServiceDetailsResp_SelfActivation).SelfActivation
			vOpts := append(opts,
				db.WithValidateField("activation_type_choice"),
				db.WithValidateField("self_activation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetAddonServiceDetailsResp_PartiallyManagedActivation:
		if fv, exists := v.FldValidators["activation_type_choice.partially_managed_activation"]; exists {
			val := m.GetActivationTypeChoice().(*GetAddonServiceDetailsResp_PartiallyManagedActivation).PartiallyManagedActivation
			vOpts := append(opts,
				db.WithValidateField("activation_type_choice"),
				db.WithValidateField("partially_managed_activation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetAddonServiceDetailsResp_ManagedActivation:
		if fv, exists := v.FldValidators["activation_type_choice.managed_activation"]; exists {
			val := m.GetActivationTypeChoice().(*GetAddonServiceDetailsResp_ManagedActivation).ManagedActivation
			vOpts := append(opts,
				db.WithValidateField("activation_type_choice"),
				db.WithValidateField("managed_activation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["addon_service_group_display_name"]; exists {

		vOpts := append(opts, db.WithValidateField("addon_service_group_display_name"))
		if err := fv(ctx, m.GetAddonServiceGroupDisplayName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["addon_service_group_name"]; exists {

		vOpts := append(opts, db.WithValidateField("addon_service_group_name"))
		if err := fv(ctx, m.GetAddonServiceGroupName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["display_name"]; exists {

		vOpts := append(opts, db.WithValidateField("display_name"))
		if err := fv(ctx, m.GetDisplayName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tier"]; exists {

		vOpts := append(opts, db.WithValidateField("tier"))
		if err := fv(ctx, m.GetTier(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetAddonServiceDetailsRespValidator = func() *ValidateGetAddonServiceDetailsResp {
	v := &ValidateGetAddonServiceDetailsResp{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["activation_type_choice.self_activation"] = SelfActivationTypeValidator().Validate
	v.FldValidators["activation_type_choice.partially_managed_activation"] = PartiallyManagedActivationTypeValidator().Validate
	v.FldValidators["activation_type_choice.managed_activation"] = FullyManagedActivationTypeValidator().Validate

	return v
}()

func GetAddonServiceDetailsRespValidator() db.Validator {
	return DefaultGetAddonServiceDetailsRespValidator
}

// augmented methods on protoc/std generated struct

func (m *GetAllServiceTiersActivationStatusReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetAllServiceTiersActivationStatusReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetAllServiceTiersActivationStatusReq) DeepCopy() *GetAllServiceTiersActivationStatusReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetAllServiceTiersActivationStatusReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetAllServiceTiersActivationStatusReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetAllServiceTiersActivationStatusReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetAllServiceTiersActivationStatusReqValidator().Validate(ctx, m, opts...)
}

type ValidateGetAllServiceTiersActivationStatusReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetAllServiceTiersActivationStatusReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetAllServiceTiersActivationStatusReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetAllServiceTiersActivationStatusReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["addon_service"]; exists {

		vOpts := append(opts, db.WithValidateField("addon_service"))
		if err := fv(ctx, m.GetAddonService(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetAllServiceTiersActivationStatusReqValidator = func() *ValidateGetAllServiceTiersActivationStatusReq {
	v := &ValidateGetAllServiceTiersActivationStatusReq{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetAllServiceTiersActivationStatusReqValidator() db.Validator {
	return DefaultGetAllServiceTiersActivationStatusReqValidator
}

// augmented methods on protoc/std generated struct

func (m *GetAllServiceTiersActivationStatusResp) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetAllServiceTiersActivationStatusResp) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetAllServiceTiersActivationStatusResp) DeepCopy() *GetAllServiceTiersActivationStatusResp {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetAllServiceTiersActivationStatusResp{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetAllServiceTiersActivationStatusResp) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetAllServiceTiersActivationStatusResp) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetAllServiceTiersActivationStatusRespValidator().Validate(ctx, m, opts...)
}

type ValidateGetAllServiceTiersActivationStatusResp struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetAllServiceTiersActivationStatusResp) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetAllServiceTiersActivationStatusResp)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetAllServiceTiersActivationStatusResp got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["activation_states"]; exists {

		vOpts := append(opts, db.WithValidateField("activation_states"))
		for key, value := range m.GetActivationStates() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetAllServiceTiersActivationStatusRespValidator = func() *ValidateGetAllServiceTiersActivationStatusResp {
	v := &ValidateGetAllServiceTiersActivationStatusResp{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetAllServiceTiersActivationStatusRespValidator() db.Validator {
	return DefaultGetAllServiceTiersActivationStatusRespValidator
}
