// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package addon_service

import (
	"bytes"
	"context"
	"fmt"
	io "io"
	"net/http"
	"strings"

	"github.com/gogo/protobuf/proto"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"google.golang.org/grpc"

	"gopkg.volterra.us/stdlib/client"
	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/errors"
	"gopkg.volterra.us/stdlib/server"
	"gopkg.volterra.us/stdlib/svcfw"
)

var (
	_ = fmt.Sprintf("dummy for fmt import use")
)

// Create CustomAPI GRPC Client satisfying server.CustomClient
type CustomAPIGrpcClient struct {
	conn       *grpc.ClientConn
	grpcClient CustomAPIClient
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error)
}

func (c *CustomAPIGrpcClient) doRPCGetActivationStatus(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetActivationStatusReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.pbac.addon_service.GetActivationStatusReq", yamlReq)
	}
	rsp, err := c.grpcClient.GetActivationStatus(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCGetAddonServiceDetails(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetAddonServiceDetailsReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.pbac.addon_service.GetAddonServiceDetailsReq", yamlReq)
	}
	rsp, err := c.grpcClient.GetAddonServiceDetails(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCGetAllServiceTiersActivationStatus(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetAllServiceTiersActivationStatusReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.pbac.addon_service.GetAllServiceTiersActivationStatusReq", yamlReq)
	}
	rsp, err := c.grpcClient.GetAllServiceTiersActivationStatus(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	if cco.YAMLReq == "" {
		return nil, fmt.Errorf("Error, empty request body")
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := rpcFn(ctx, cco.YAMLReq, cco.GrpcCallOpts...)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using GRPC")
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func NewCustomAPIGrpcClient(cc *grpc.ClientConn) server.CustomClient {
	ccl := &CustomAPIGrpcClient{
		conn:       cc,
		grpcClient: NewCustomAPIClient(cc),
	}
	rpcFns := make(map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error))
	rpcFns["GetActivationStatus"] = ccl.doRPCGetActivationStatus

	rpcFns["GetAddonServiceDetails"] = ccl.doRPCGetAddonServiceDetails

	rpcFns["GetAllServiceTiersActivationStatus"] = ccl.doRPCGetAllServiceTiersActivationStatus

	ccl.rpcFns = rpcFns

	return ccl
}

// Create CustomAPI REST Client satisfying server.CustomClient
type CustomAPIRestClient struct {
	baseURL string
	client  http.Client
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error)
}

func (c *CustomAPIRestClient) doRPCGetActivationStatus(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetActivationStatusReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.pbac.addon_service.GetActivationStatusReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("addon_service", fmt.Sprintf("%v", req.AddonService))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &GetActivationStatusResp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.pbac.addon_service.GetActivationStatusResp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCGetAddonServiceDetails(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetAddonServiceDetailsReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.pbac.addon_service.GetAddonServiceDetailsReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("name", fmt.Sprintf("%v", req.Name))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &GetAddonServiceDetailsResp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.pbac.addon_service.GetAddonServiceDetailsResp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCGetAllServiceTiersActivationStatus(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetAllServiceTiersActivationStatusReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.pbac.addon_service.GetAllServiceTiersActivationStatusReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("addon_service", fmt.Sprintf("%v", req.AddonService))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &GetAllServiceTiersActivationStatusResp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.pbac.addon_service.GetAllServiceTiersActivationStatusResp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	rsp, err := rpcFn(ctx, cco)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using Rest")
	}
	return rsp, nil
}

func NewCustomAPIRestClient(baseURL string, hc http.Client) server.CustomClient {
	ccl := &CustomAPIRestClient{
		baseURL: baseURL,
		client:  hc,
	}

	rpcFns := make(map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error))
	rpcFns["GetActivationStatus"] = ccl.doRPCGetActivationStatus

	rpcFns["GetAddonServiceDetails"] = ccl.doRPCGetAddonServiceDetails

	rpcFns["GetAllServiceTiersActivationStatus"] = ccl.doRPCGetAllServiceTiersActivationStatus

	ccl.rpcFns = rpcFns

	return ccl
}

// Create customAPIInprocClient

// INPROC Client (satisfying CustomAPIClient interface)
type customAPIInprocClient struct {
	CustomAPIServer
}

func (c *customAPIInprocClient) GetActivationStatus(ctx context.Context, in *GetActivationStatusReq, opts ...grpc.CallOption) (*GetActivationStatusResp, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.pbac.addon_service.CustomAPI.GetActivationStatus")
	return c.CustomAPIServer.GetActivationStatus(ctx, in)
}
func (c *customAPIInprocClient) GetAddonServiceDetails(ctx context.Context, in *GetAddonServiceDetailsReq, opts ...grpc.CallOption) (*GetAddonServiceDetailsResp, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.pbac.addon_service.CustomAPI.GetAddonServiceDetails")
	return c.CustomAPIServer.GetAddonServiceDetails(ctx, in)
}
func (c *customAPIInprocClient) GetAllServiceTiersActivationStatus(ctx context.Context, in *GetAllServiceTiersActivationStatusReq, opts ...grpc.CallOption) (*GetAllServiceTiersActivationStatusResp, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.pbac.addon_service.CustomAPI.GetAllServiceTiersActivationStatus")
	return c.CustomAPIServer.GetAllServiceTiersActivationStatus(ctx, in)
}

func NewCustomAPIInprocClient(svc svcfw.Service) CustomAPIClient {
	return &customAPIInprocClient{CustomAPIServer: NewCustomAPIServer(svc)}
}

// RegisterGwCustomAPIHandler registers with grpc-gw with an inproc-client backing so that
// rest to grpc happens without a grpc.Dial (thus avoiding additional certs for mTLS)
func RegisterGwCustomAPIHandler(ctx context.Context, mux *runtime.ServeMux, svc interface{}) error {
	s, ok := svc.(svcfw.Service)
	if !ok {
		return fmt.Errorf("svc is not svcfw.Service")
	}
	return RegisterCustomAPIHandlerClient(ctx, mux, NewCustomAPIInprocClient(s))
}

// Create customAPISrv

// SERVER (satisfying CustomAPIServer interface)
type customAPISrv struct {
	svc svcfw.Service
}

func (s *customAPISrv) GetActivationStatus(ctx context.Context, in *GetActivationStatusReq) (*GetActivationStatusResp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.pbac.addon_service.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *GetActivationStatusResp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.pbac.addon_service.GetActivationStatusReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.GetActivationStatus' operation on 'addon_service'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.pbac.addon_service.CustomAPI.GetActivationStatus"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetActivationStatus(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.pbac.addon_service.GetActivationStatusResp", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) GetAddonServiceDetails(ctx context.Context, in *GetAddonServiceDetailsReq) (*GetAddonServiceDetailsResp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.pbac.addon_service.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *GetAddonServiceDetailsResp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.pbac.addon_service.GetAddonServiceDetailsReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.GetAddonServiceDetails' operation on 'addon_service'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.pbac.addon_service.CustomAPI.GetAddonServiceDetails"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetAddonServiceDetails(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.pbac.addon_service.GetAddonServiceDetailsResp", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) GetAllServiceTiersActivationStatus(ctx context.Context, in *GetAllServiceTiersActivationStatusReq) (*GetAllServiceTiersActivationStatusResp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.pbac.addon_service.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *GetAllServiceTiersActivationStatusResp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.pbac.addon_service.GetAllServiceTiersActivationStatusReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.GetAllServiceTiersActivationStatus' operation on 'addon_service'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.pbac.addon_service.CustomAPI.GetAllServiceTiersActivationStatus"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetAllServiceTiersActivationStatus(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.pbac.addon_service.GetAllServiceTiersActivationStatusResp", rsp)...)

	return rsp, nil
}

func NewCustomAPIServer(svc svcfw.Service) CustomAPIServer {
	return &customAPISrv{svc: svc}
}

var CustomAPISwaggerJSON string = `{
    "swagger": "2.0",
    "info": {
        "title": "addon service",
        "description": "Additional public APIs for addon_service config object.",
        "version": "version not set"
    },
    "schemes": [
        "http",
        "https"
    ],
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ],
    "tags": [],
    "paths": {
        "/public/custom/namespaces/shared/addon_services/{name}": {
            "get": {
                "summary": "Get Addon Service Details",
                "description": "Retrieves addon service information for the given addon service name.",
                "operationId": "ves.io.schema.pbac.addon_service.CustomAPI.GetAddonServiceDetails",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/addon_serviceGetAddonServiceDetailsResp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "name",
                        "description": "name\n\nx-example: \"addon-service-1\"\nName of the addon service",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Name"
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-pbac-addon_service-customapi-getaddonservicedetails"
                },
                "x-ves-proto-rpc": "ves.io.schema.pbac.addon_service.CustomAPI.GetAddonServiceDetails"
            },
            "x-displayname": "Addon Service - UAM Manager Custom APIs",
            "x-ves-proto-service": "ves.io.schema.pbac.addon_service.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/addon_services/{addon_service}/activation-status": {
            "get": {
                "summary": "Addon Service Activation Status",
                "description": "Get current subscription status for an addon service. Response can indicate whether the service was successfully subscribed or in pending state.",
                "operationId": "ves.io.schema.pbac.addon_service.CustomAPI.GetActivationStatus",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/addon_serviceGetActivationStatusResp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "addon_service",
                        "description": "addon_service\n\nx-example: \"addon-service-1\"\nName of the addon_service",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Addon Service"
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-pbac-addon_service-customapi-getactivationstatus"
                },
                "x-ves-proto-rpc": "ves.io.schema.pbac.addon_service.CustomAPI.GetActivationStatus"
            },
            "x-displayname": "Addon Service - UAM Manager Custom APIs",
            "x-ves-proto-service": "ves.io.schema.pbac.addon_service.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/addon_services/{addon_service}/all-activation-status": {
            "get": {
                "summary": "All Addon Service Activation Status",
                "description": "Get current subscription status for all addon services in a feature tier. Response can indicate whether the service was successfully subscribed or in pending state.",
                "operationId": "ves.io.schema.pbac.addon_service.CustomAPI.GetAllServiceTiersActivationStatus",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/addon_serviceGetAllServiceTiersActivationStatusResp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "addon_service",
                        "description": "addon_service\n\nx-example: \"addon-service-1\"\nName of the addon_service feature tier",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Addon Service"
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-pbac-addon_service-customapi-getallservicetiersactivationstatus"
                },
                "x-ves-proto-rpc": "ves.io.schema.pbac.addon_service.CustomAPI.GetAllServiceTiersActivationStatus"
            },
            "x-displayname": "Addon Service - UAM Manager Custom APIs",
            "x-ves-proto-service": "ves.io.schema.pbac.addon_service.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        }
    },
    "definitions": {
        "addon_serviceAddonServiceActivationStatus": {
            "type": "object",
            "description": "x-displayName: \"Addon Service Activation Status\"\nContains single addon service activation status information",
            "title": "AddonServiceActivationStatus",
            "properties": {
                "access_status": {
                    "description": "x-displayName: \"Access control status\"\nAccess evaluation result",
                    "title": "access_status",
                    "$ref": "#/definitions/schemaAddonServiceAccess"
                },
                "addon_service_status": {
                    "description": "x-displayName: \"Addon Service Status\"\nx-example: \"AS_PENDING\"\ncurrent state of addon service subscription.",
                    "title": "addon_service_status",
                    "$ref": "#/definitions/schemaAddonServiceState"
                },
                "display_name": {
                    "type": "string",
                    "description": "x-displayName: \"Display Name\"\nx-example: \"Addon Service 1\"\nDisplay name of the addon service",
                    "title": "display_name"
                },
                "name": {
                    "type": "string",
                    "description": "x-displayName: \"Name\"\nx-example: \"addon-service-1\"\nName of the addon_service",
                    "title": "name"
                },
                "tier": {
                    "description": "x-displayName: \"Tier\"\nTier of the addon service",
                    "title": "tier",
                    "$ref": "#/definitions/schemaAddonServiceTierType"
                }
            }
        },
        "addon_serviceContent": {
            "type": "object",
            "description": "Content holds the subject and the description",
            "title": "Content",
            "x-displayname": "Content",
            "x-ves-proto-message": "ves.io.schema.pbac.addon_service.Content",
            "properties": {
                "description": {
                    "type": "string",
                    "description": " Description of the support ticket",
                    "title": "Description",
                    "x-displayname": "Description"
                },
                "subject": {
                    "type": "string",
                    "description": " Subject of the support ticket",
                    "title": "Subject",
                    "x-displayname": "Subject"
                }
            }
        },
        "addon_serviceCustomSupportTicket": {
            "type": "object",
            "description": "CustomSupportTicket holds the template details provided by the service owner",
            "title": "CustomSupportTicket",
            "x-displayname": "Custom Support Ticket",
            "x-ves-proto-message": "ves.io.schema.pbac.addon_service.CustomSupportTicket",
            "properties": {
                "priority": {
                    "description": " Priority of the ticket",
                    "title": "Priority",
                    "$ref": "#/definitions/customer_supportSupportTicketPriority",
                    "x-displayname": "Priority"
                },
                "service": {
                    "description": " Service which matches the addon",
                    "title": "Service",
                    "$ref": "#/definitions/customer_supportSupportService",
                    "x-displayname": "Service"
                },
                "subscribe_content": {
                    "description": " SubscribeContent holds the content while subscription request",
                    "title": "SubscribeContent",
                    "$ref": "#/definitions/addon_serviceContent",
                    "x-displayname": "SubscribeContent"
                },
                "unsubscribe_content": {
                    "description": " UnsubscribeContent holds the content while unsubscription request",
                    "title": "UnsubscribeContent",
                    "$ref": "#/definitions/addon_serviceContent",
                    "x-displayname": "UnsubscribeContent"
                }
            }
        },
        "addon_serviceFullyManagedActivationType": {
            "type": "object",
            "description": "Managed Activation and require complete manual intervention.",
            "title": "FullyManagedActivationType",
            "x-displayname": "Fully Managed Activation",
            "x-ves-proto-message": "ves.io.schema.pbac.addon_service.FullyManagedActivationType",
            "properties": {
                "notification_preference": {
                    "description": " NotificationPreference preference for receiving addon subscription notifications.",
                    "title": "NotificationPreference",
                    "$ref": "#/definitions/addon_serviceNotificationPreference",
                    "x-displayname": "Notification Preference"
                }
            }
        },
        "addon_serviceGetActivationStatusResp": {
            "type": "object",
            "description": "Response shape for addon service activation status",
            "title": "GetActivationStatusResp",
            "x-displayname": "Addon Service activation status Response",
            "x-ves-proto-message": "ves.io.schema.pbac.addon_service.GetActivationStatusResp",
            "properties": {
                "state": {
                    "description": " current state of addon service subscription.\n\nExample: - \"AS_PENDING\"-",
                    "title": "state",
                    "$ref": "#/definitions/schemaAddonServiceState",
                    "x-displayname": "State",
                    "x-ves-example": "AS_PENDING"
                }
            }
        },
        "addon_serviceGetAddonServiceDetailsResp": {
            "type": "object",
            "description": "Response shape for addon service details",
            "title": "GetAddonServiceDetailsResp",
            "x-displayname": "Get Addon Service Details Response",
            "x-ves-oneof-field-activation_type_choice": "[\"managed_activation\",\"partially_managed_activation\",\"self_activation\"]",
            "x-ves-proto-message": "ves.io.schema.pbac.addon_service.GetAddonServiceDetailsResp",
            "properties": {
                "addon_service_group_display_name": {
                    "type": "string",
                    "description": " Display name of the addon service group.\n\nExample: - \"addon service group 1\"-",
                    "title": "addon_service_group_display_name",
                    "x-displayname": "Addon Service Group Display Name",
                    "x-ves-example": "addon service group 1"
                },
                "addon_service_group_name": {
                    "type": "string",
                    "description": " Name of the addon service group.\n\nExample: - \"addon-service-group-1\"-",
                    "title": "addon_service_group_name",
                    "x-displayname": "Addon Service Group Name",
                    "x-ves-example": "addon-service-group-1"
                },
                "display_name": {
                    "type": "string",
                    "description": " Display Name of the addon service \n\nExample: - \"addon service 1\"-",
                    "title": "display_name",
                    "x-displayname": "Display Name",
                    "x-ves-example": "addon service 1"
                },
                "managed_activation": {
                    "description": "Exclusive with [partially_managed_activation self_activation]\n",
                    "$ref": "#/definitions/addon_serviceFullyManagedActivationType"
                },
                "partially_managed_activation": {
                    "description": "Exclusive with [managed_activation self_activation]\n",
                    "$ref": "#/definitions/addon_servicePartiallyManagedActivationType"
                },
                "self_activation": {
                    "description": "Exclusive with [managed_activation partially_managed_activation]\n",
                    "$ref": "#/definitions/addon_serviceSelfActivationType"
                },
                "tier": {
                    "description": " Tier can be used to group addon services into tiers (e.g. basic, standard, premium, etc)\n\nExample: - \"basic\"-",
                    "title": "tier",
                    "$ref": "#/definitions/schemaAddonServiceTierType",
                    "x-displayname": "Tier",
                    "x-ves-example": "basic"
                }
            }
        },
        "addon_serviceGetAllServiceTiersActivationStatusResp": {
            "type": "object",
            "description": "Response shape for addon service feature tier activation statuses",
            "title": "GetFeatureTierActivationStatusResp",
            "x-displayname": "Addon Service tier activation statuses Response",
            "x-ves-proto-message": "ves.io.schema.pbac.addon_service.GetAllServiceTiersActivationStatusResp",
            "properties": {
                "activation_states": {
                    "type": "object",
                    "description": " current state of addon service subscription. the key is the name of the service.",
                    "title": "state",
                    "x-displayname": "State"
                }
            }
        },
        "addon_serviceNotificationPreference": {
            "type": "object",
            "description": "NotificationPreference preference for receiving addon subscription notifications.",
            "title": "NotificationPreference",
            "x-displayname": "Notification Preference",
            "x-ves-oneof-field-notification_type": "[\"emails\",\"support_ticket_option\"]",
            "x-ves-proto-message": "ves.io.schema.pbac.addon_service.NotificationPreference",
            "properties": {
                "emails": {
                    "description": "Exclusive with [support_ticket_option]\n EmailDL contains the email dl associated with the Addon Subscription.",
                    "title": "EmailDL",
                    "$ref": "#/definitions/pbacEmailDL",
                    "x-displayname": "Addon Subscription Associated Emails"
                },
                "support_ticket_option": {
                    "description": "Exclusive with [emails]\n SupportTicketOption is for holding the support ticket creation option as part of the partially managed activation",
                    "title": "SupportTicketOption",
                    "$ref": "#/definitions/addon_serviceSupportTicketOptions",
                    "x-displayname": "Support Ticket Option"
                }
            }
        },
        "addon_servicePartiallyManagedActivationType": {
            "type": "object",
            "description": "Addon service activation will require partial management from backend or SRE.",
            "title": "PartiallyManagedActivationType",
            "x-displayname": "Partially Managed Activation",
            "x-ves-proto-message": "ves.io.schema.pbac.addon_service.PartiallyManagedActivationType"
        },
        "addon_serviceSelfActivationType": {
            "type": "object",
            "description": "Addon service can be subscribed and activated by user directly without any manual intervention.",
            "title": "SelfActivationType",
            "x-displayname": "Self Activation",
            "x-ves-proto-message": "ves.io.schema.pbac.addon_service.SelfActivationType",
            "properties": {
                "default_tile_name": {
                    "type": "string",
                    "description": " Default landing page for the addon service after successful subscription.\n value should match name of the navigation tile config object.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_len: 32\n",
                    "title": "default_tile_name",
                    "maxLength": 32,
                    "x-displayname": "Default Navigation Tile",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_len": "32"
                    }
                }
            }
        },
        "addon_serviceSupportTicketOptions": {
            "type": "object",
            "description": "SupportTicketOptions deals with whether the support ticket needs to be created",
            "title": "SupportTicketOptions",
            "x-displayname": "Support Ticket Options",
            "x-ves-oneof-field-support_ticket_creation_choice": "[\"no_support_ticket\",\"support_ticket_with_custom_template\",\"support_ticket_with_default_template\"]",
            "x-ves-proto-message": "ves.io.schema.pbac.addon_service.SupportTicketOptions",
            "properties": {
                "no_support_ticket": {
                    "description": "Exclusive with [support_ticket_with_custom_template support_ticket_with_default_template]\n NoSupportTicket indicates support ticket is not required",
                    "title": "NoSupportTicket",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "No Support Ticket"
                },
                "support_ticket_with_custom_template": {
                    "description": "Exclusive with [no_support_ticket support_ticket_with_default_template]\n SupportTicketWithCustomTemplate allows the service owners to choose the template for the support ticket",
                    "title": "SupportTicketWithCustomTemplate",
                    "$ref": "#/definitions/addon_serviceCustomSupportTicket",
                    "x-displayname": "Support Ticket With Custom Template"
                },
                "support_ticket_with_default_template": {
                    "description": "Exclusive with [no_support_ticket support_ticket_with_custom_template]\n SupportTicketWithDefaultTemplate a support ticket with the default template will be created",
                    "title": "SupportTicketWithDefaultTemplate",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Support Ticket With Default Template"
                }
            }
        },
        "customer_supportSupportService": {
            "type": "string",
            "description": "Indicates the list of support service\n\nUnknown Support Service\nAccount Protection Support Service\nAdministration Support Service\nApplication Traffic Insight Support Service\nAudit Logs \u0026 Alerts Support Service\nAuthentication Intelligence Support Service\nBilling Support Service\nClient Side Defense Support Service\nCloud \u0026 Edge Sites Support Service\ndeprecated: use SS_MULTI_CLOUD_NETWORK_CONNECT instead\nDDOS \u0026 Transit Support Service\nDeprecated: use SS_ROUTED_DDOS instead\nDistributed Apps Support Service\nDNS Management Support Service\nLoadBalancers Support Service\ndeprecated: use SS_MULTI_CLOUD_APP_CONNECT instead\nShared Configuration Support Service\nWeb App \u0026 API Protection Support Service\nOther Support Service\nBot Defense Support Service\nContent delivery network Support Service\nObservability Support Service\nDelegated Access Support Service\nNetworking \u0026 security across clouds, edge and on-premises\nConnect apps across clouds, edge and on-premises using Load Balancers\nBIG-IP Access Policy Manager (APM)\nData Intelligence Support Service\nNGINX One Support Service\nWeb App Scanning Support Service\nRouted DDoS Support Service\nMobile App Shield protects mobile apps from reverse engineering, tampering and malware",
            "title": "SupportService",
            "enum": [
                "SS_UNKNOWN",
                "SS_ACCOUNT_PROTECTION",
                "SS_ADMINISTRATION",
                "SS_APPLICATION_TRAFFIC_INSIGHT",
                "SS_AUDIT_LOGS_AND_ALERTS",
                "SS_AUTHENTICATION_INTELLIGENCE",
                "SS_BILLING",
                "SS_CLIENT_SIDE_DEFENSE",
                "SS_CLOUD_AND_EDGE_SITES",
                "SS_DDOS_AND_TRANSIT_SERVICES",
                "SS_DISTRIBUTED_APPS",
                "SS_DNS_MANAGEMENT",
                "SS_LOAD_BALANCERS",
                "SS_SHARED_CONFIGURATION",
                "SS_WEB_APP_AND_API_PROTECTION",
                "SS_OTHER",
                "SS_BOT_DEFENSE",
                "SS_CDN",
                "SS_OBSERVABILITY",
                "SS_DELEGATED_ACCESS",
                "SS_MULTI_CLOUD_NETWORK_CONNECT",
                "SS_MULTI_CLOUD_APP_CONNECT",
                "SS_BIG_IP_APM",
                "SS_DATA_INTELLIGENCE",
                "SS_NGINX_ONE",
                "SS_WEB_APP_SCANNING",
                "SS_ROUTED_DDOS",
                "SS_MOBILE_APP_SHIELD"
            ],
            "default": "SS_UNKNOWN",
            "x-displayname": "Support Service",
            "x-ves-proto-enum": "ves.io.schema.customer_support.SupportService"
        },
        "customer_supportSupportTicketPriority": {
            "type": "string",
            "description": "Support ticket priority helps understand importance of the ticket and focus\nmore on more critical issues.\n\nUnknown/empty priority\nNormal priority issue\nHigh priority issue\nUrgent priority issue",
            "title": "SupportTicketPriority",
            "enum": [
                "PRIORITY_UNKNOWN",
                "PRIORITY_NORMAL",
                "PRIORITY_HIGH",
                "PRIORITY_URGENT"
            ],
            "default": "PRIORITY_UNKNOWN",
            "x-displayname": "Priority",
            "x-ves-proto-enum": "ves.io.schema.customer_support.SupportTicketPriority"
        },
        "ioschemaEmpty": {
            "type": "object",
            "description": "This can be used for messages where no values are needed",
            "title": "Empty",
            "x-displayname": "Empty",
            "x-ves-proto-message": "ves.io.schema.Empty"
        },
        "pbacEmailDL": {
            "type": "object",
            "description": "Addon Subscription Emails associated with the Addon Subscription",
            "title": "EmailDL",
            "x-displayname": "Addon Subscription Associated Emails",
            "x-ves-proto-message": "ves.io.schema.pbac.EmailDL",
            "properties": {
                "email_ids": {
                    "type": "array",
                    "description": " Email ids associated with the Addon Subscription\n\nExample: - \"abc@email.com\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.email: true\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "email_ids",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Emails",
                    "x-ves-example": "abc@email.com",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.email": "true",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "schemaAddonServiceAccess": {
            "type": "string",
            "description": "x-displayName: \"Addon Service Access\"\nState of access into service\n\n - AS_AC_NONE: x-displayName: \"None\"\ndefault state\nThis can mean that addon service is not subscribed or is in pending subscription.\n - AS_AC_ALLOWED: x-displayName: \"Allow\"\naccess is allowed\n - AS_AC_PBAC_DENY: x-displayName: \"PBAC Deny\"\nAddon service is not allowed as part of current plan\n - AS_AC_PBAC_DENY_UPGRADE_PLAN: x-displayName: \"PBAC Deny - Upgrade plan\"\nAddon service is not allowed as part of current plan. To enable it, user is requested to uprade the plan\n - AS_AC_PBAC_DENY_CONTACT_SALES: x-displayName: \"PBAC Deny - Contact Sales\"\nAddon service is not allowed as part of current plan. To enable or to find out more, user is requested to contact sales\n - AS_AC_PBAC_DENY_AS_AC_EOL: x-displayName: \"PBAC Deny - End of  Life\"\nAddon service is not allowed as part of current plan as it is discontinued. User is requested to contact sales discuss alternatives",
            "title": "AddonServiceAccess",
            "enum": [
                "AS_AC_NONE",
                "AS_AC_ALLOWED",
                "AS_AC_PBAC_DENY",
                "AS_AC_PBAC_DENY_UPGRADE_PLAN",
                "AS_AC_PBAC_DENY_CONTACT_SALES",
                "AS_AC_PBAC_DENY_AS_AC_EOL"
            ],
            "default": "AS_AC_NONE"
        },
        "schemaAddonServiceState": {
            "type": "string",
            "description": "State of a service\n\ndefault state\ninitiated subscription request and is pending to activate (requested).\nsuccessfully subscribed\nservice subscription request ended up in error state.",
            "title": "AddonServiceState",
            "enum": [
                "AS_NONE",
                "AS_PENDING",
                "AS_SUBSCRIBED",
                "AS_ERROR"
            ],
            "default": "AS_NONE",
            "x-displayname": "Addon Service State",
            "x-ves-proto-enum": "ves.io.schema.AddonServiceState"
        },
        "schemaAddonServiceTierType": {
            "type": "string",
            "description": "AddonServiceTierType is for identifying the tier of an addon service\n\n - NO_TIER: none\n\nwhen tier is not applicable for a addon service\n - BASIC: basic\n\nbasic\n - STANDARD: standard\n\nstandard\n - ADVANCED: advanced\n\nadvanced\n - PREMIUM: premium\n\npremium",
            "title": "AddonServiceTierType",
            "enum": [
                "NO_TIER",
                "BASIC",
                "STANDARD",
                "ADVANCED",
                "PREMIUM"
            ],
            "default": "NO_TIER",
            "x-displayname": "Addon Service Tier",
            "x-ves-proto-enum": "ves.io.schema.AddonServiceTierType"
        }
    },
    "x-displayname": "Addon Service",
    "x-ves-proto-file": "ves.io/schema/pbac/addon_service/public_customapi_uam.proto"
}`
