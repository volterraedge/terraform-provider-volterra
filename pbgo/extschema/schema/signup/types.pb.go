// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/signup/types.proto

package signup

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	contact "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/contact"
	infraprotect_information "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/infraprotect_information"
	user "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/user"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Signup specification
//
// x-displayName: "Signup"
// desired state of Signup
type GlobalSpecType struct {
	// locale
	//
	// x-displayName: "Locale"
	// x-required
	// x-example: "en-us"
	// locale of this sign up
	Locale string `protobuf:"bytes,1,opt,name=locale,proto3" json:"locale,omitempty"`
	// type
	//
	// x-displayName: "Tenant Type"
	// x-required
	// what tenant type we're processing (FREEMIUM, ENTERPRISE ...)
	Type schema.TenantType `protobuf:"varint,2,opt,name=type,proto3,enum=ves.io.schema.TenantType" json:"type,omitempty"`
	// first_name
	//
	// x-displayName: "First Name"
	// x-example: "John"
	// first name of the customer
	// obsolete
	FirstName string `protobuf:"bytes,3,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	// last_name
	//
	// x-displayName: "Last Name"
	// x-example: "Doe"
	// last name of the customer (the superuser)
	// obsolete
	LastName string `protobuf:"bytes,4,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
	// email
	//
	// x-displayName: "Email"
	// x-example: "customer@email.com"
	// email of the customer (ideally someone who's responsible for the company
	// account)
	// obsolete
	Email string `protobuf:"bytes,5,opt,name=email,proto3" json:"email,omitempty"`
	// contact_number
	//
	// x-displayName: "Contact Number"
	// x-example: "+11234567890"
	// phone contact number
	// obsolete
	ContactNumber string `protobuf:"bytes,6,opt,name=contact_number,json=contactNumber,proto3" json:"contact_number,omitempty"`
	// domain
	//
	// x-displayName: "Domain"
	// x-example: "value"
	// domain the customer chose to use - enterprise customers only.
	Domain string `protobuf:"bytes,8,opt,name=domain,proto3" json:"domain,omitempty"`
	// currency
	//
	// x-displayName: "Currency"
	// x-example: "USD"
	// preferred currency on the tenant level - individual billing accounts may
	// override this.
	Currency string `protobuf:"bytes,9,opt,name=currency,proto3" json:"currency,omitempty"`
	// payment_provider_token
	//
	// x-displayName: "Payment Provider Token"
	// x-example: "tok_1234567890"
	// payment provider token (for credit card details)
	PaymentProviderToken string `protobuf:"bytes,10,opt,name=payment_provider_token,json=paymentProviderToken,proto3" json:"payment_provider_token,omitempty"`
	// billing_address
	//
	// x-displayName: "Billing Address"
	// address associated with the credit card details provided using the payment_provider_token
	// if no billing address is provided then any address tokenized with payment_provider_token will be used - including an empty address.
	BillingAddress *contact.GlobalSpecType `protobuf:"bytes,18,opt,name=billing_address,json=billingAddress,proto3" json:"billing_address,omitempty"`
	// tos_accepted
	//
	// x-displayName: "TOS Accepted"
	// x-example: "1569926163000"
	// t&c accepted date as millis from 01/01/1970 UTC
	TosAccepted int64 `protobuf:"varint,11,opt,name=tos_accepted,json=tosAccepted,proto3" json:"tos_accepted,omitempty"` // Deprecated: Do not use.
	// customer
	//
	// x-displayName: "Customer"
	// customer details (personal/enterprise)
	Customer *user.GlobalSpecType `protobuf:"bytes,12,opt,name=customer,proto3" json:"customer,omitempty"`
	// customer contact
	//
	// x-displayName: "Customer Contact"
	// contact details of the customer
	CustomerContact *contact.GlobalSpecType `protobuf:"bytes,13,opt,name=customer_contact,json=customerContact,proto3" json:"customer_contact,omitempty"`
	// company name
	//
	// x-displayName: "Company Name"
	// x-example: "ACME Ltd."
	// company name (enterprise only)
	CompanyName string `protobuf:"bytes,14,opt,name=company_name,json=companyName,proto3" json:"company_name,omitempty"`
	// company
	//
	// x-displayName: "Company"
	// company details (enterprise only), name, email
	Company *user.GlobalSpecType `protobuf:"bytes,15,opt,name=company,proto3" json:"company,omitempty"`
	// company contact
	//
	// x-displayName: "Company Contact"
	// contact details of the enterprise customer
	CompanyContact *contact.GlobalSpecType `protobuf:"bytes,16,opt,name=company_contact,json=companyContact,proto3" json:"company_contact,omitempty"`
	// token of the user
	//
	// x-displayName: "Token"
	// x-required
	// x-example: "tok_1234567890"
	// token of the user requesting for.
	// Valid tokens are internally generated in the system and shared with respective customers.
	// Onboarding of new customers will proceed only when a valid token along with the email is provided during the signup process.
	Token string `protobuf:"bytes,17,opt,name=token,proto3" json:"token,omitempty"` // Deprecated: Do not use.
	// support_plan_name
	//
	// x-displayName: "Support Plan Name"
	// x-example: "xxxx-yyyy-zzzz-1111"
	// what sort of support plan the customer will be on.
	SupportPlanName string `protobuf:"bytes,19,opt,name=support_plan_name,json=supportPlanName,proto3" json:"support_plan_name,omitempty"` // Deprecated: Do not use.
	// usage_plan_name
	//
	// x-displayName: "Usage Plan Name"
	// x-example: "xxxx-yyyy-zzzz-1111"
	// what sort of usage plan the customer will be on.
	UsagePlanName string `protobuf:"bytes,20,opt,name=usage_plan_name,json=usagePlanName,proto3" json:"usage_plan_name,omitempty"`
	// version of terms of services the customer accepted
	//
	// x-displayName: "TOS version"
	// x-example: "v1.2"
	// indicates the version of ToS customer approved during signup. Any new version will require the customer to re-approve during login.
	TosVersion string `protobuf:"bytes,21,opt,name=tos_version,json=tosVersion,proto3" json:"tos_version,omitempty"`
	// tax exempt flag
	//
	// x-displayName: "Tax exemption"
	// x-example: "TAX_EXEMPT"
	// indicates the customer is tax exempt. once confirmed with the finance team the customer will not be charged taxes.
	TaxExempt schema.TaxExemptionType `protobuf:"varint,22,opt,name=tax_exempt,json=taxExempt,proto3,enum=ves.io.schema.TaxExemptionType" json:"tax_exempt,omitempty"`
	// infra protect info
	//
	// x-displayName: "Infraprotect information"
	// Optional information that allows link any existing Infraprotect customer to Voltconsole
	InfraprotectInfo *infraprotect_information.GlobalSpecType `protobuf:"bytes,23,opt,name=infraprotect_info,json=infraprotectInfo,proto3" json:"infraprotect_info,omitempty"`
	// billing_provider_account_id
	//
	// x-displayName: "Billing provider account id"
	// Id of the billing provider account created to verify the billing info provided with this object.
	// The id is then used to ensure no more duplicate billing account is created.
	BillingProviderAccountId string `protobuf:"bytes,24,opt,name=billing_provider_account_id,json=billingProviderAccountId,proto3" json:"billing_provider_account_id,omitempty"`
	// tos_accepted_at
	//
	// x-displayName: "TosAcceptedAt"
	// x-example: "2020-04-20T12:32:51.341959216Z"
	// tos accepted timestamp.
	TosAcceptedAt *types.Timestamp `protobuf:"bytes,25,opt,name=tos_accepted_at,json=tosAcceptedAt,proto3" json:"tos_accepted_at,omitempty"`
	// sfdc_subscription_id
	//
	// x-displayName: "SFDCSubscriptionID"
	// x-example: "A-S00012023"
	// sales force subscription id
	SfdcSubscriptionId string `protobuf:"bytes,26,opt,name=sfdc_subscription_id,json=sfdcSubscriptionId,proto3" json:"sfdc_subscription_id,omitempty"` // Deprecated: Do not use.
	// crm_info
	//
	// x-displayName: "CrmInfo"
	// message to include crm info in TEEM pipeline.
	// This field is deprecated. use CrmDetails instead
	CrmInfo *CrmInfo `protobuf:"bytes,27,opt,name=crm_info,json=crmInfo,proto3" json:"crm_info,omitempty"` // Deprecated: Do not use.
	// crm_details
	//
	// x-displayName: "CrmDetails"
	// CrmDetails message to include crm info in source pipeline.
	CrmDetails *schema.CRMInfo `protobuf:"bytes,29,opt,name=crm_details,json=crmDetails,proto3" json:"crm_details,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_06020f1e10ed9466, []int{0}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

func (m *GlobalSpecType) GetLocale() string {
	if m != nil {
		return m.Locale
	}
	return ""
}

func (m *GlobalSpecType) GetType() schema.TenantType {
	if m != nil {
		return m.Type
	}
	return schema.UNKNOWN
}

func (m *GlobalSpecType) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *GlobalSpecType) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *GlobalSpecType) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *GlobalSpecType) GetContactNumber() string {
	if m != nil {
		return m.ContactNumber
	}
	return ""
}

func (m *GlobalSpecType) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *GlobalSpecType) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *GlobalSpecType) GetPaymentProviderToken() string {
	if m != nil {
		return m.PaymentProviderToken
	}
	return ""
}

func (m *GlobalSpecType) GetBillingAddress() *contact.GlobalSpecType {
	if m != nil {
		return m.BillingAddress
	}
	return nil
}

// Deprecated: Do not use.
func (m *GlobalSpecType) GetTosAccepted() int64 {
	if m != nil {
		return m.TosAccepted
	}
	return 0
}

func (m *GlobalSpecType) GetCustomer() *user.GlobalSpecType {
	if m != nil {
		return m.Customer
	}
	return nil
}

func (m *GlobalSpecType) GetCustomerContact() *contact.GlobalSpecType {
	if m != nil {
		return m.CustomerContact
	}
	return nil
}

func (m *GlobalSpecType) GetCompanyName() string {
	if m != nil {
		return m.CompanyName
	}
	return ""
}

func (m *GlobalSpecType) GetCompany() *user.GlobalSpecType {
	if m != nil {
		return m.Company
	}
	return nil
}

func (m *GlobalSpecType) GetCompanyContact() *contact.GlobalSpecType {
	if m != nil {
		return m.CompanyContact
	}
	return nil
}

// Deprecated: Do not use.
func (m *GlobalSpecType) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

// Deprecated: Do not use.
func (m *GlobalSpecType) GetSupportPlanName() string {
	if m != nil {
		return m.SupportPlanName
	}
	return ""
}

func (m *GlobalSpecType) GetUsagePlanName() string {
	if m != nil {
		return m.UsagePlanName
	}
	return ""
}

func (m *GlobalSpecType) GetTosVersion() string {
	if m != nil {
		return m.TosVersion
	}
	return ""
}

func (m *GlobalSpecType) GetTaxExempt() schema.TaxExemptionType {
	if m != nil {
		return m.TaxExempt
	}
	return schema.TAX_UNKNOWN
}

func (m *GlobalSpecType) GetInfraprotectInfo() *infraprotect_information.GlobalSpecType {
	if m != nil {
		return m.InfraprotectInfo
	}
	return nil
}

func (m *GlobalSpecType) GetBillingProviderAccountId() string {
	if m != nil {
		return m.BillingProviderAccountId
	}
	return ""
}

func (m *GlobalSpecType) GetTosAcceptedAt() *types.Timestamp {
	if m != nil {
		return m.TosAcceptedAt
	}
	return nil
}

// Deprecated: Do not use.
func (m *GlobalSpecType) GetSfdcSubscriptionId() string {
	if m != nil {
		return m.SfdcSubscriptionId
	}
	return ""
}

// Deprecated: Do not use.
func (m *GlobalSpecType) GetCrmInfo() *CrmInfo {
	if m != nil {
		return m.CrmInfo
	}
	return nil
}

func (m *GlobalSpecType) GetCrmDetails() *schema.CRMInfo {
	if m != nil {
		return m.CrmDetails
	}
	return nil
}

// Create spec of the signup object
//
// x-displayName: "Create Signup"
// Holds all the fields required to receive signup from the client.
type CreateSpecType struct {
	Locale               string                                   `protobuf:"bytes,1,opt,name=locale,proto3" json:"locale,omitempty"`
	Type                 schema.TenantType                        `protobuf:"varint,2,opt,name=type,proto3,enum=ves.io.schema.TenantType" json:"type,omitempty"`
	FirstName            string                                   `protobuf:"bytes,3,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	LastName             string                                   `protobuf:"bytes,4,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
	Email                string                                   `protobuf:"bytes,5,opt,name=email,proto3" json:"email,omitempty"`
	ContactNumber        string                                   `protobuf:"bytes,6,opt,name=contact_number,json=contactNumber,proto3" json:"contact_number,omitempty"`
	Domain               string                                   `protobuf:"bytes,8,opt,name=domain,proto3" json:"domain,omitempty"`
	Currency             string                                   `protobuf:"bytes,9,opt,name=currency,proto3" json:"currency,omitempty"`
	PaymentProviderToken string                                   `protobuf:"bytes,10,opt,name=payment_provider_token,json=paymentProviderToken,proto3" json:"payment_provider_token,omitempty"`
	BillingAddress       *contact.GlobalSpecType                  `protobuf:"bytes,18,opt,name=billing_address,json=billingAddress,proto3" json:"billing_address,omitempty"`
	TosAccepted          int64                                    `protobuf:"varint,11,opt,name=tos_accepted,json=tosAccepted,proto3" json:"tos_accepted,omitempty"` // Deprecated: Do not use.
	Customer             *user.GlobalSpecType                     `protobuf:"bytes,12,opt,name=customer,proto3" json:"customer,omitempty"`
	CustomerContact      *contact.GlobalSpecType                  `protobuf:"bytes,13,opt,name=customer_contact,json=customerContact,proto3" json:"customer_contact,omitempty"`
	CompanyName          string                                   `protobuf:"bytes,14,opt,name=company_name,json=companyName,proto3" json:"company_name,omitempty"`
	Company              *user.GlobalSpecType                     `protobuf:"bytes,15,opt,name=company,proto3" json:"company,omitempty"`
	CompanyContact       *contact.GlobalSpecType                  `protobuf:"bytes,16,opt,name=company_contact,json=companyContact,proto3" json:"company_contact,omitempty"`
	Token                string                                   `protobuf:"bytes,17,opt,name=token,proto3" json:"token,omitempty"`
	SupportPlanName      string                                   `protobuf:"bytes,19,opt,name=support_plan_name,json=supportPlanName,proto3" json:"support_plan_name,omitempty"`
	UsagePlanName        string                                   `protobuf:"bytes,20,opt,name=usage_plan_name,json=usagePlanName,proto3" json:"usage_plan_name,omitempty"`
	TosVersion           string                                   `protobuf:"bytes,21,opt,name=tos_version,json=tosVersion,proto3" json:"tos_version,omitempty"`
	TaxExempt            schema.TaxExemptionType                  `protobuf:"varint,22,opt,name=tax_exempt,json=taxExempt,proto3,enum=ves.io.schema.TaxExemptionType" json:"tax_exempt,omitempty"`
	InfraprotectInfo     *infraprotect_information.GlobalSpecType `protobuf:"bytes,23,opt,name=infraprotect_info,json=infraprotectInfo,proto3" json:"infraprotect_info,omitempty"`
	// tos_accepted_at
	//
	// x-displayName: "TosAcceptedAt"
	// x-example: "2020-04-20T12:32:51.341959216Z"
	// tos accepted timestamp.
	TosAcceptedAt *types.Timestamp `protobuf:"bytes,24,opt,name=tos_accepted_at,json=tosAcceptedAt,proto3" json:"tos_accepted_at,omitempty"`
	// sfdc_subscription_id
	//
	// x-displayName: "SFDCSubscriptionID"
	// x-example: "A-S00012023"
	// sales force subscription id
	SfdcSubscriptionId string `protobuf:"bytes,25,opt,name=sfdc_subscription_id,json=sfdcSubscriptionId,proto3" json:"sfdc_subscription_id,omitempty"` // Deprecated: Do not use.
	// crm_info
	//
	// x-displayName: "CrmInfo"
	// message to include crm info in TEEM pipeline.
	// This field is deprecated. use CrmDetails instead
	CrmInfo *CrmInfo `protobuf:"bytes,26,opt,name=crm_info,json=crmInfo,proto3" json:"crm_info,omitempty"` // Deprecated: Do not use.
	// Crm Details
	//
	// x-displayName: "Crm Details"
	// message to include crm info in source pipeline.
	CrmDetails *schema.CRMInfo `protobuf:"bytes,27,opt,name=crm_details,json=crmDetails,proto3" json:"crm_details,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_06020f1e10ed9466, []int{1}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

func (m *CreateSpecType) GetLocale() string {
	if m != nil {
		return m.Locale
	}
	return ""
}

func (m *CreateSpecType) GetType() schema.TenantType {
	if m != nil {
		return m.Type
	}
	return schema.UNKNOWN
}

func (m *CreateSpecType) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *CreateSpecType) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *CreateSpecType) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *CreateSpecType) GetContactNumber() string {
	if m != nil {
		return m.ContactNumber
	}
	return ""
}

func (m *CreateSpecType) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *CreateSpecType) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *CreateSpecType) GetPaymentProviderToken() string {
	if m != nil {
		return m.PaymentProviderToken
	}
	return ""
}

func (m *CreateSpecType) GetBillingAddress() *contact.GlobalSpecType {
	if m != nil {
		return m.BillingAddress
	}
	return nil
}

// Deprecated: Do not use.
func (m *CreateSpecType) GetTosAccepted() int64 {
	if m != nil {
		return m.TosAccepted
	}
	return 0
}

func (m *CreateSpecType) GetCustomer() *user.GlobalSpecType {
	if m != nil {
		return m.Customer
	}
	return nil
}

func (m *CreateSpecType) GetCustomerContact() *contact.GlobalSpecType {
	if m != nil {
		return m.CustomerContact
	}
	return nil
}

func (m *CreateSpecType) GetCompanyName() string {
	if m != nil {
		return m.CompanyName
	}
	return ""
}

func (m *CreateSpecType) GetCompany() *user.GlobalSpecType {
	if m != nil {
		return m.Company
	}
	return nil
}

func (m *CreateSpecType) GetCompanyContact() *contact.GlobalSpecType {
	if m != nil {
		return m.CompanyContact
	}
	return nil
}

func (m *CreateSpecType) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *CreateSpecType) GetSupportPlanName() string {
	if m != nil {
		return m.SupportPlanName
	}
	return ""
}

func (m *CreateSpecType) GetUsagePlanName() string {
	if m != nil {
		return m.UsagePlanName
	}
	return ""
}

func (m *CreateSpecType) GetTosVersion() string {
	if m != nil {
		return m.TosVersion
	}
	return ""
}

func (m *CreateSpecType) GetTaxExempt() schema.TaxExemptionType {
	if m != nil {
		return m.TaxExempt
	}
	return schema.TAX_UNKNOWN
}

func (m *CreateSpecType) GetInfraprotectInfo() *infraprotect_information.GlobalSpecType {
	if m != nil {
		return m.InfraprotectInfo
	}
	return nil
}

func (m *CreateSpecType) GetTosAcceptedAt() *types.Timestamp {
	if m != nil {
		return m.TosAcceptedAt
	}
	return nil
}

// Deprecated: Do not use.
func (m *CreateSpecType) GetSfdcSubscriptionId() string {
	if m != nil {
		return m.SfdcSubscriptionId
	}
	return ""
}

// Deprecated: Do not use.
func (m *CreateSpecType) GetCrmInfo() *CrmInfo {
	if m != nil {
		return m.CrmInfo
	}
	return nil
}

func (m *CreateSpecType) GetCrmDetails() *schema.CRMInfo {
	if m != nil {
		return m.CrmDetails
	}
	return nil
}

// Replace spec of the signup object
//
// x-displayName: "Replace Signup"
// we don't support updating of the signup object
type ReplaceSpecType struct {
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_06020f1e10ed9466, []int{2}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

// Get spec of the signup object
//
// x-displayName: "Get Signup"
// we don't support retrieving of the signup object
type GetSpecType struct {
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_06020f1e10ed9466, []int{3}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

// fileds of crm info meesage
//
// x-displayName: "Crm Info"
// Deprecated: use the CRMInfo defined in schema/types.proto
type CrmInfo struct {
	// account_id
	//
	// x-displayName: "AccountID"
	// x-example: "SFA-1478257"
	// salesforce account ID
	AccountId string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
	// entitlement_id
	//
	// x-displayName: "EntitlementID"
	// x-example: "e5712007-0560-4fcc-b8c9-f4ffbeaf3e4e"
	EntitlementId string `protobuf:"bytes,2,opt,name=entitlement_id,json=entitlementId,proto3" json:"entitlement_id,omitempty"`
	// subscription_id
	//
	// x-displayName: "SubscriptionId"
	// x-example: "A-S00012023"
	// sales force subscription id
	SubscriptionId string `protobuf:"bytes,3,opt,name=subscription_id,json=subscriptionId,proto3" json:"subscription_id,omitempty"`
	// order_type
	//
	// x-displayName: "OrderType"
	// x-example: "PAID"
	OrderType string `protobuf:"bytes,5,opt,name=order_type,json=orderType,proto3" json:"order_type,omitempty"`
	// Entitled SKUs
	//
	// x-displayName: "Entitled SKUs"
	// x-example: "['F5-V-O-ALL-BASE-PK-B','F5-XC-O-ALL-BOT-STD-B','F5-V-O-ADN-MSH-API-B','F5-V-O-ADN-MSH-RLM-B']"
	// SKU information that is used mostly for reporting purposes.
	EntitledSkus []string `protobuf:"bytes,6,rep,name=entitled_skus,json=entitledSkus,proto3" json:"entitled_skus,omitempty"`
	// Customer Identifier
	//
	// x-displayName: "Customer Identifier"
	// x-example: "HHhd4MFcSzM"
	// Customer identifier is a unique account(tenant) identifier provided by source
	CustomerIdentifier string `protobuf:"bytes,7,opt,name=customer_identifier,json=customerIdentifier,proto3" json:"customer_identifier,omitempty"`
}

func (m *CrmInfo) Reset()      { *m = CrmInfo{} }
func (*CrmInfo) ProtoMessage() {}
func (*CrmInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_06020f1e10ed9466, []int{4}
}
func (m *CrmInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrmInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CrmInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrmInfo.Merge(m, src)
}
func (m *CrmInfo) XXX_Size() int {
	return m.Size()
}
func (m *CrmInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CrmInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CrmInfo proto.InternalMessageInfo

func (m *CrmInfo) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *CrmInfo) GetEntitlementId() string {
	if m != nil {
		return m.EntitlementId
	}
	return ""
}

func (m *CrmInfo) GetSubscriptionId() string {
	if m != nil {
		return m.SubscriptionId
	}
	return ""
}

func (m *CrmInfo) GetOrderType() string {
	if m != nil {
		return m.OrderType
	}
	return ""
}

func (m *CrmInfo) GetEntitledSkus() []string {
	if m != nil {
		return m.EntitledSkus
	}
	return nil
}

func (m *CrmInfo) GetCustomerIdentifier() string {
	if m != nil {
		return m.CustomerIdentifier
	}
	return ""
}

func init() {
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.signup.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.signup.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.signup.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.signup.GetSpecType")
	proto.RegisterType((*CrmInfo)(nil), "ves.io.schema.signup.CrmInfo")
}

func init() { proto.RegisterFile("ves.io/schema/signup/types.proto", fileDescriptor_06020f1e10ed9466) }

var fileDescriptor_06020f1e10ed9466 = []byte{
	// 1166 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x57, 0x4f, 0x6f, 0xdb, 0x36,
	0x14, 0xb7, 0x6a, 0x3b, 0xb6, 0xe9, 0xc4, 0x76, 0x58, 0x2f, 0x63, 0x9c, 0x46, 0x71, 0x83, 0x65,
	0x08, 0x86, 0x45, 0x2e, 0x32, 0x60, 0x7f, 0x8a, 0x2e, 0x40, 0x9c, 0x15, 0x45, 0x02, 0x2c, 0x08,
	0x94, 0x60, 0x87, 0x5d, 0x04, 0x5a, 0xa2, 0x5d, 0x22, 0x92, 0x28, 0x90, 0x94, 0x17, 0x1f, 0x0a,
	0xf4, 0xb0, 0x0f, 0xb0, 0x8f, 0xb1, 0xcf, 0xb0, 0x5d, 0x76, 0xd8, 0xa1, 0xd8, 0x29, 0xc7, 0x00,
	0xbb, 0x2c, 0xce, 0xa5, 0xbb, 0xf5, 0x13, 0x6c, 0x83, 0x28, 0xc9, 0xb3, 0xdc, 0x64, 0x68, 0xb7,
	0xdd, 0xda, 0x9b, 0xde, 0xfb, 0xfd, 0x1e, 0xdf, 0xe3, 0x7b, 0xe4, 0x8f, 0x36, 0x68, 0x0f, 0x89,
	0x30, 0x28, 0xeb, 0x08, 0xfb, 0x31, 0xf1, 0x70, 0x47, 0xd0, 0x81, 0x1f, 0x06, 0x1d, 0x39, 0x0a,
	0x88, 0x30, 0x02, 0xce, 0x24, 0x83, 0xcd, 0x98, 0x61, 0xc4, 0x0c, 0x23, 0x66, 0xb4, 0xb6, 0x06,
	0x54, 0x3e, 0x0e, 0x7b, 0x86, 0xcd, 0xbc, 0xce, 0x80, 0x0d, 0x58, 0x47, 0x91, 0x7b, 0x61, 0x5f,
	0x59, 0xca, 0x50, 0x5f, 0xf1, 0x22, 0xad, 0xe5, 0x01, 0x63, 0x03, 0x97, 0xfc, 0xcd, 0xc2, 0xfe,
	0x28, 0x81, 0xd6, 0x66, 0x21, 0x49, 0x3d, 0x22, 0x24, 0xf6, 0x82, 0x84, 0x70, 0x37, 0x5b, 0xa2,
	0xcd, 0x7c, 0x89, 0x6d, 0x39, 0x5d, 0x63, 0x6b, 0x3b, 0x4b, 0xa1, 0x7e, 0x9f, 0xe3, 0x08, 0x21,
	0xb6, 0xb4, 0xa8, 0xdf, 0x67, 0xdc, 0xc3, 0x92, 0x32, 0x3f, 0x13, 0xb3, 0x92, 0x8d, 0x61, 0x41,
	0xc4, 0x48, 0xc1, 0xe5, 0x2c, 0x38, 0x1d, 0xa7, 0x67, 0xa1, 0x50, 0x10, 0x9e, 0xc1, 0xef, 0x64,
	0xf1, 0x21, 0x76, 0xa9, 0x83, 0x25, 0x49, 0xd0, 0x99, 0x7e, 0x0f, 0x29, 0xf9, 0xc6, 0xca, 0xa4,
	0x5e, 0xff, 0x03, 0x80, 0xda, 0x23, 0x97, 0xf5, 0xb0, 0x7b, 0x1c, 0x10, 0xfb, 0x64, 0x14, 0x10,
	0xb8, 0x04, 0xe6, 0x5c, 0x66, 0x63, 0x97, 0x20, 0xad, 0xad, 0x6d, 0x56, 0xcc, 0xc4, 0x82, 0x5b,
	0xa0, 0x10, 0x65, 0x46, 0xb7, 0xda, 0xda, 0x66, 0x6d, 0x7b, 0xd9, 0xc8, 0x4e, 0xea, 0x84, 0xf8,
	0xd8, 0x97, 0xd1, 0x02, 0xa6, 0xa2, 0xc1, 0x55, 0x00, 0xfa, 0x94, 0x0b, 0x69, 0xf9, 0xd8, 0x23,
	0x28, 0xaf, 0x96, 0xaa, 0x28, 0xcf, 0x21, 0xf6, 0x08, 0x5c, 0x01, 0x15, 0x17, 0xa7, 0x68, 0x41,
	0xa1, 0xe5, 0xc8, 0xa1, 0xc0, 0x26, 0x28, 0x12, 0x0f, 0x53, 0x17, 0x15, 0x15, 0x10, 0x1b, 0x70,
	0x03, 0xd4, 0x92, 0x71, 0x58, 0x7e, 0xe8, 0xf5, 0x08, 0x47, 0x73, 0x0a, 0x5e, 0x48, 0xbc, 0x87,
	0xca, 0x19, 0xd5, 0xef, 0x30, 0x0f, 0x53, 0x1f, 0x95, 0xe3, 0xfa, 0x63, 0x0b, 0xb6, 0x40, 0xd9,
	0x0e, 0x39, 0x27, 0xbe, 0x3d, 0x42, 0x95, 0x38, 0x61, 0x6a, 0xc3, 0xcf, 0xc0, 0x52, 0x80, 0x47,
	0x1e, 0xf1, 0xa5, 0x15, 0x70, 0x36, 0xa4, 0x0e, 0xe1, 0x96, 0x64, 0xa7, 0xc4, 0x47, 0x20, 0x62,
	0x76, 0xf3, 0xcf, 0x9e, 0x68, 0x66, 0x33, 0xa1, 0x1c, 0x25, 0x8c, 0x93, 0x88, 0x00, 0x0f, 0x41,
	0xbd, 0x47, 0x5d, 0x97, 0xfa, 0x03, 0x0b, 0x3b, 0x0e, 0x27, 0x42, 0x20, 0xd8, 0xd6, 0x36, 0xab,
	0xdb, 0x1b, 0x33, 0x1d, 0x4a, 0xaa, 0x34, 0xb2, 0xed, 0x36, 0x6b, 0x49, 0xf4, 0x6e, 0x1c, 0x0c,
	0x37, 0xc0, 0xbc, 0x64, 0xc2, 0xc2, 0xb6, 0x4d, 0x02, 0x49, 0x1c, 0x54, 0x6d, 0x6b, 0x9b, 0xf9,
	0xee, 0x2d, 0xa4, 0x99, 0x55, 0xc9, 0xc4, 0x6e, 0xe2, 0x86, 0x3b, 0xd1, 0x6e, 0x84, 0x64, 0x1e,
	0xe1, 0x68, 0x5e, 0xe5, 0x5b, 0x9f, 0xc9, 0x17, 0x9d, 0x95, 0xd9, 0x64, 0x93, 0x18, 0x78, 0x04,
	0x1a, 0xe9, 0xb7, 0x95, 0x54, 0x86, 0x16, 0x5e, 0xa7, 0xee, 0x7a, 0x1a, 0xbe, 0x17, 0xe3, 0xf0,
	0x2e, 0x98, 0xb7, 0x99, 0x17, 0x60, 0x7f, 0x14, 0x0f, 0xb5, 0xa6, 0x7a, 0x5c, 0x4d, 0x7c, 0x6a,
	0xae, 0x0f, 0x40, 0x29, 0x31, 0x51, 0xfd, 0x95, 0x6b, 0x4e, 0x43, 0xa2, 0x4e, 0xa7, 0x09, 0xd2,
	0x8a, 0x1b, 0xaf, 0xd5, 0xe9, 0x24, 0x3a, 0x2d, 0x18, 0x81, 0x62, 0x3c, 0xe3, 0x45, 0x35, 0xe3,
	0xa8, 0xc5, 0xb1, 0x03, 0x1a, 0x60, 0x51, 0x84, 0x41, 0xc0, 0xb8, 0xb4, 0x02, 0x17, 0xfb, 0xf1,
	0x7e, 0x6e, 0x4f, 0x58, 0xf5, 0x04, 0x3c, 0x72, 0xb1, 0xaf, 0xf6, 0xf5, 0x3e, 0xa8, 0x87, 0x02,
	0x0f, 0xc8, 0x14, 0xbb, 0x19, 0x1f, 0x4d, 0xe5, 0x9e, 0xf0, 0xd6, 0x40, 0x34, 0x43, 0x6b, 0x48,
	0xb8, 0xa0, 0xcc, 0x47, 0xef, 0x28, 0x0e, 0x90, 0x4c, 0x7c, 0x15, 0x7b, 0xe0, 0x0e, 0x00, 0x12,
	0x9f, 0x59, 0xe4, 0x8c, 0x78, 0x81, 0x44, 0x4b, 0xea, 0xa6, 0xad, 0xcd, 0xde, 0x34, 0x7c, 0xf6,
	0x50, 0xe1, 0x94, 0xf9, 0x6a, 0x5f, 0x15, 0x99, 0x7a, 0xa0, 0x0d, 0x16, 0x5f, 0x92, 0x23, 0xf4,
	0xae, 0x6a, 0xd2, 0xc7, 0x33, 0xcb, 0xdc, 0x24, 0x5b, 0xb3, 0x5d, 0x6b, 0x4c, 0x13, 0xf7, 0xfd,
	0x3e, 0x83, 0x9f, 0x83, 0x95, 0xf4, 0xc4, 0x4f, 0x2e, 0x0b, 0xb6, 0x6d, 0x16, 0xfa, 0xd2, 0xa2,
	0x0e, 0x42, 0x6a, 0x57, 0x28, 0xa1, 0xa4, 0x97, 0x65, 0x37, 0x26, 0xec, 0x3b, 0xb0, 0x0b, 0xea,
	0xd3, 0x07, 0xdc, 0xc2, 0x12, 0x2d, 0xab, 0x0a, 0x5b, 0x46, 0x2c, 0xce, 0x46, 0x2a, 0xce, 0xc6,
	0x49, 0x2a, 0xce, 0xe6, 0xc2, 0xd4, 0xd9, 0xdf, 0x95, 0xf0, 0x21, 0x68, 0x8a, 0xbe, 0x63, 0x5b,
	0x22, 0xec, 0x09, 0x9b, 0x53, 0xd5, 0x8b, 0x28, 0x77, 0x4b, 0xcd, 0xe8, 0xf6, 0xc5, 0x13, 0xed,
	0xf9, 0x8f, 0x9a, 0xf6, 0xc3, 0xef, 0x3f, 0xe5, 0x8b, 0x3c, 0x8f, 0x9e, 0x46, 0x43, 0x83, 0x51,
	0xc0, 0xf1, 0x14, 0x7f, 0xdf, 0x81, 0x0f, 0x40, 0xd9, 0xe6, 0x5e, 0xdc, 0xa5, 0x15, 0x55, 0xc3,
	0xaa, 0x71, 0xdd, 0x03, 0x64, 0xec, 0x71, 0x2f, 0xda, 0xba, 0x9a, 0x7e, 0xc9, 0x8e, 0x0d, 0xf8,
	0x09, 0xa8, 0x46, 0xd1, 0x0e, 0x91, 0x98, 0xba, 0x02, 0xad, 0xaa, 0x05, 0x96, 0x66, 0x16, 0xd8,
	0x33, 0xbf, 0x8c, 0xc8, 0x26, 0xb0, 0xb9, 0xf7, 0x45, 0xcc, 0x3c, 0x28, 0x94, 0x4b, 0x8d, 0xf2,
	0x41, 0xa1, 0x7c, 0xa7, 0xb1, 0xba, 0xfe, 0x33, 0x00, 0xb5, 0x3d, 0x4e, 0xb0, 0x24, 0x6f, 0x05,
	0xf8, 0xad, 0x00, 0xbf, 0x59, 0x02, 0xdc, 0xcc, 0x08, 0x70, 0x2a, 0xbe, 0x1f, 0xdc, 0x28, 0xbe,
	0x6f, 0xba, 0xf0, 0x5e, 0xa3, 0x9c, 0xe8, 0xff, 0x52, 0xce, 0xe5, 0x7f, 0xaf, 0x9c, 0xad, 0xff,
	0xaa, 0x9c, 0x2b, 0xaf, 0xaa, 0x9c, 0xf7, 0x17, 0x7f, 0xd9, 0x99, 0xf9, 0xb9, 0x1a, 0x8b, 0xe9,
	0xfa, 0x7b, 0xa0, 0x6e, 0x92, 0xc0, 0xc5, 0xf6, 0x44, 0x46, 0xaf, 0xe1, 0xae, 0xb7, 0x41, 0xf5,
	0x11, 0x91, 0xff, 0xc4, 0xf8, 0xf5, 0x16, 0x28, 0x25, 0x25, 0xc3, 0x7b, 0x00, 0x4c, 0x3d, 0x6b,
	0x4a, 0x8b, 0xbb, 0x8b, 0x2f, 0x35, 0xc8, 0xac, 0xe0, 0xc9, 0xd3, 0xf6, 0x29, 0xa8, 0x11, 0x5f,
	0x52, 0xe9, 0x12, 0xa5, 0x64, 0xd4, 0x51, 0x5a, 0x7d, 0x6d, 0xd4, 0xc2, 0x14, 0x71, 0xdf, 0x81,
	0xf7, 0x41, 0x7d, 0x76, 0x22, 0xf9, 0x9b, 0x42, 0x6b, 0x22, 0x3b, 0x8b, 0x7b, 0x00, 0x30, 0xae,
	0x04, 0x33, 0x7a, 0x1d, 0x8a, 0x37, 0xd6, 0xa9, 0x48, 0xea, 0x85, 0xf9, 0x10, 0xa4, 0xe9, 0x1d,
	0x4b, 0x9c, 0x86, 0x02, 0xcd, 0xb5, 0xf3, 0x9b, 0x95, 0x6e, 0x29, 0x09, 0x32, 0xe7, 0x53, 0xf4,
	0xf8, 0x34, 0x14, 0xb0, 0x0b, 0x6e, 0x4f, 0x94, 0x8a, 0x3a, 0x11, 0xd4, 0xa7, 0x84, 0xa3, 0xd2,
	0xb5, 0x89, 0xfe, 0xd4, 0x4c, 0x98, 0xb2, 0xf7, 0x27, 0xe4, 0x83, 0x42, 0xb9, 0xd0, 0x28, 0x76,
	0xbf, 0xd5, 0xce, 0x2f, 0xf5, 0xdc, 0xc5, 0xa5, 0x9e, 0x7b, 0x71, 0xa9, 0x6b, 0x4f, 0xc7, 0xba,
	0xf6, 0xfd, 0x58, 0xd7, 0x9e, 0x8d, 0x75, 0xed, 0x7c, 0xac, 0x6b, 0x17, 0x63, 0x5d, 0xfb, 0x6d,
	0xac, 0x6b, 0xcf, 0xc7, 0x7a, 0xee, 0xc5, 0x58, 0xd7, 0xbe, 0xbb, 0xd2, 0x73, 0xe7, 0x57, 0x7a,
	0xee, 0xe2, 0x4a, 0xcf, 0x7d, 0x7d, 0x30, 0x60, 0xc1, 0xe9, 0xc0, 0x18, 0x32, 0x57, 0x12, 0xce,
	0x23, 0xa1, 0xea, 0xa8, 0x8f, 0xe8, 0xfa, 0x6c, 0xa5, 0x4f, 0xc6, 0x56, 0x0a, 0x77, 0x82, 0xde,
	0x80, 0x75, 0xc8, 0x99, 0x4c, 0xff, 0x69, 0x4e, 0xff, 0xe1, 0xec, 0xcd, 0xa9, 0x6b, 0xf2, 0xd1,
	0x5f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x78, 0x2d, 0xd7, 0xbf, 0x8f, 0x0e, 0x00, 0x00,
}

func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Locale != that1.Locale {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.FirstName != that1.FirstName {
		return false
	}
	if this.LastName != that1.LastName {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	if this.ContactNumber != that1.ContactNumber {
		return false
	}
	if this.Domain != that1.Domain {
		return false
	}
	if this.Currency != that1.Currency {
		return false
	}
	if this.PaymentProviderToken != that1.PaymentProviderToken {
		return false
	}
	if !this.BillingAddress.Equal(that1.BillingAddress) {
		return false
	}
	if this.TosAccepted != that1.TosAccepted {
		return false
	}
	if !this.Customer.Equal(that1.Customer) {
		return false
	}
	if !this.CustomerContact.Equal(that1.CustomerContact) {
		return false
	}
	if this.CompanyName != that1.CompanyName {
		return false
	}
	if !this.Company.Equal(that1.Company) {
		return false
	}
	if !this.CompanyContact.Equal(that1.CompanyContact) {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	if this.SupportPlanName != that1.SupportPlanName {
		return false
	}
	if this.UsagePlanName != that1.UsagePlanName {
		return false
	}
	if this.TosVersion != that1.TosVersion {
		return false
	}
	if this.TaxExempt != that1.TaxExempt {
		return false
	}
	if !this.InfraprotectInfo.Equal(that1.InfraprotectInfo) {
		return false
	}
	if this.BillingProviderAccountId != that1.BillingProviderAccountId {
		return false
	}
	if !this.TosAcceptedAt.Equal(that1.TosAcceptedAt) {
		return false
	}
	if this.SfdcSubscriptionId != that1.SfdcSubscriptionId {
		return false
	}
	if !this.CrmInfo.Equal(that1.CrmInfo) {
		return false
	}
	if !this.CrmDetails.Equal(that1.CrmDetails) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Locale != that1.Locale {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.FirstName != that1.FirstName {
		return false
	}
	if this.LastName != that1.LastName {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	if this.ContactNumber != that1.ContactNumber {
		return false
	}
	if this.Domain != that1.Domain {
		return false
	}
	if this.Currency != that1.Currency {
		return false
	}
	if this.PaymentProviderToken != that1.PaymentProviderToken {
		return false
	}
	if !this.BillingAddress.Equal(that1.BillingAddress) {
		return false
	}
	if this.TosAccepted != that1.TosAccepted {
		return false
	}
	if !this.Customer.Equal(that1.Customer) {
		return false
	}
	if !this.CustomerContact.Equal(that1.CustomerContact) {
		return false
	}
	if this.CompanyName != that1.CompanyName {
		return false
	}
	if !this.Company.Equal(that1.Company) {
		return false
	}
	if !this.CompanyContact.Equal(that1.CompanyContact) {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	if this.SupportPlanName != that1.SupportPlanName {
		return false
	}
	if this.UsagePlanName != that1.UsagePlanName {
		return false
	}
	if this.TosVersion != that1.TosVersion {
		return false
	}
	if this.TaxExempt != that1.TaxExempt {
		return false
	}
	if !this.InfraprotectInfo.Equal(that1.InfraprotectInfo) {
		return false
	}
	if !this.TosAcceptedAt.Equal(that1.TosAcceptedAt) {
		return false
	}
	if this.SfdcSubscriptionId != that1.SfdcSubscriptionId {
		return false
	}
	if !this.CrmInfo.Equal(that1.CrmInfo) {
		return false
	}
	if !this.CrmDetails.Equal(that1.CrmDetails) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *CrmInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CrmInfo)
	if !ok {
		that2, ok := that.(CrmInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AccountId != that1.AccountId {
		return false
	}
	if this.EntitlementId != that1.EntitlementId {
		return false
	}
	if this.SubscriptionId != that1.SubscriptionId {
		return false
	}
	if this.OrderType != that1.OrderType {
		return false
	}
	if len(this.EntitledSkus) != len(that1.EntitledSkus) {
		return false
	}
	for i := range this.EntitledSkus {
		if this.EntitledSkus[i] != that1.EntitledSkus[i] {
			return false
		}
	}
	if this.CustomerIdentifier != that1.CustomerIdentifier {
		return false
	}
	return true
}
func (this *GlobalSpecType) goString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 31)
	s = append(s, "&signup.GlobalSpecType{")
	s = append(s, "Locale: "+fmt.Sprintf("%#v", this.Locale)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "FirstName: "+fmt.Sprintf("%#v", this.FirstName)+",\n")
	s = append(s, "LastName: "+fmt.Sprintf("%#v", this.LastName)+",\n")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "ContactNumber: "+fmt.Sprintf("%#v", this.ContactNumber)+",\n")
	s = append(s, "Domain: "+fmt.Sprintf("%#v", this.Domain)+",\n")
	s = append(s, "Currency: "+fmt.Sprintf("%#v", this.Currency)+",\n")
	s = append(s, "PaymentProviderToken: "+fmt.Sprintf("%#v", this.PaymentProviderToken)+",\n")
	if this.BillingAddress != nil {
		s = append(s, "BillingAddress: "+fmt.Sprintf("%#v", this.BillingAddress)+",\n")
	}
	s = append(s, "TosAccepted: "+fmt.Sprintf("%#v", this.TosAccepted)+",\n")
	if this.Customer != nil {
		s = append(s, "Customer: "+fmt.Sprintf("%#v", this.Customer)+",\n")
	}
	if this.CustomerContact != nil {
		s = append(s, "CustomerContact: "+fmt.Sprintf("%#v", this.CustomerContact)+",\n")
	}
	s = append(s, "CompanyName: "+fmt.Sprintf("%#v", this.CompanyName)+",\n")
	if this.Company != nil {
		s = append(s, "Company: "+fmt.Sprintf("%#v", this.Company)+",\n")
	}
	if this.CompanyContact != nil {
		s = append(s, "CompanyContact: "+fmt.Sprintf("%#v", this.CompanyContact)+",\n")
	}
	s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	s = append(s, "SupportPlanName: "+fmt.Sprintf("%#v", this.SupportPlanName)+",\n")
	s = append(s, "UsagePlanName: "+fmt.Sprintf("%#v", this.UsagePlanName)+",\n")
	s = append(s, "TosVersion: "+fmt.Sprintf("%#v", this.TosVersion)+",\n")
	s = append(s, "TaxExempt: "+fmt.Sprintf("%#v", this.TaxExempt)+",\n")
	if this.InfraprotectInfo != nil {
		s = append(s, "InfraprotectInfo: "+fmt.Sprintf("%#v", this.InfraprotectInfo)+",\n")
	}
	s = append(s, "BillingProviderAccountId: "+fmt.Sprintf("%#v", this.BillingProviderAccountId)+",\n")
	if this.TosAcceptedAt != nil {
		s = append(s, "TosAcceptedAt: "+fmt.Sprintf("%#v", this.TosAcceptedAt)+",\n")
	}
	s = append(s, "SfdcSubscriptionId: "+fmt.Sprintf("%#v", this.SfdcSubscriptionId)+",\n")
	if this.CrmInfo != nil {
		s = append(s, "CrmInfo: "+fmt.Sprintf("%#v", this.CrmInfo)+",\n")
	}
	if this.CrmDetails != nil {
		s = append(s, "CrmDetails: "+fmt.Sprintf("%#v", this.CrmDetails)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) goString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 30)
	s = append(s, "&signup.CreateSpecType{")
	s = append(s, "Locale: "+fmt.Sprintf("%#v", this.Locale)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "FirstName: "+fmt.Sprintf("%#v", this.FirstName)+",\n")
	s = append(s, "LastName: "+fmt.Sprintf("%#v", this.LastName)+",\n")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "ContactNumber: "+fmt.Sprintf("%#v", this.ContactNumber)+",\n")
	s = append(s, "Domain: "+fmt.Sprintf("%#v", this.Domain)+",\n")
	s = append(s, "Currency: "+fmt.Sprintf("%#v", this.Currency)+",\n")
	s = append(s, "PaymentProviderToken: "+fmt.Sprintf("%#v", this.PaymentProviderToken)+",\n")
	if this.BillingAddress != nil {
		s = append(s, "BillingAddress: "+fmt.Sprintf("%#v", this.BillingAddress)+",\n")
	}
	s = append(s, "TosAccepted: "+fmt.Sprintf("%#v", this.TosAccepted)+",\n")
	if this.Customer != nil {
		s = append(s, "Customer: "+fmt.Sprintf("%#v", this.Customer)+",\n")
	}
	if this.CustomerContact != nil {
		s = append(s, "CustomerContact: "+fmt.Sprintf("%#v", this.CustomerContact)+",\n")
	}
	s = append(s, "CompanyName: "+fmt.Sprintf("%#v", this.CompanyName)+",\n")
	if this.Company != nil {
		s = append(s, "Company: "+fmt.Sprintf("%#v", this.Company)+",\n")
	}
	if this.CompanyContact != nil {
		s = append(s, "CompanyContact: "+fmt.Sprintf("%#v", this.CompanyContact)+",\n")
	}
	s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	s = append(s, "SupportPlanName: "+fmt.Sprintf("%#v", this.SupportPlanName)+",\n")
	s = append(s, "UsagePlanName: "+fmt.Sprintf("%#v", this.UsagePlanName)+",\n")
	s = append(s, "TosVersion: "+fmt.Sprintf("%#v", this.TosVersion)+",\n")
	s = append(s, "TaxExempt: "+fmt.Sprintf("%#v", this.TaxExempt)+",\n")
	if this.InfraprotectInfo != nil {
		s = append(s, "InfraprotectInfo: "+fmt.Sprintf("%#v", this.InfraprotectInfo)+",\n")
	}
	if this.TosAcceptedAt != nil {
		s = append(s, "TosAcceptedAt: "+fmt.Sprintf("%#v", this.TosAcceptedAt)+",\n")
	}
	s = append(s, "SfdcSubscriptionId: "+fmt.Sprintf("%#v", this.SfdcSubscriptionId)+",\n")
	if this.CrmInfo != nil {
		s = append(s, "CrmInfo: "+fmt.Sprintf("%#v", this.CrmInfo)+",\n")
	}
	if this.CrmDetails != nil {
		s = append(s, "CrmDetails: "+fmt.Sprintf("%#v", this.CrmDetails)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&signup.ReplaceSpecType{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&signup.GetSpecType{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CrmInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&signup.CrmInfo{")
	s = append(s, "AccountId: "+fmt.Sprintf("%#v", this.AccountId)+",\n")
	s = append(s, "EntitlementId: "+fmt.Sprintf("%#v", this.EntitlementId)+",\n")
	s = append(s, "SubscriptionId: "+fmt.Sprintf("%#v", this.SubscriptionId)+",\n")
	s = append(s, "OrderType: "+fmt.Sprintf("%#v", this.OrderType)+",\n")
	s = append(s, "EntitledSkus: "+fmt.Sprintf("%#v", this.EntitledSkus)+",\n")
	s = append(s, "CustomerIdentifier: "+fmt.Sprintf("%#v", this.CustomerIdentifier)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CrmDetails != nil {
		{
			size, err := m.CrmDetails.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if m.CrmInfo != nil {
		{
			size, err := m.CrmInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if len(m.SfdcSubscriptionId) > 0 {
		i -= len(m.SfdcSubscriptionId)
		copy(dAtA[i:], m.SfdcSubscriptionId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SfdcSubscriptionId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.TosAcceptedAt != nil {
		{
			size, err := m.TosAcceptedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.BillingProviderAccountId) > 0 {
		i -= len(m.BillingProviderAccountId)
		copy(dAtA[i:], m.BillingProviderAccountId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BillingProviderAccountId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.InfraprotectInfo != nil {
		{
			size, err := m.InfraprotectInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.TaxExempt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TaxExempt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if len(m.TosVersion) > 0 {
		i -= len(m.TosVersion)
		copy(dAtA[i:], m.TosVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TosVersion)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.UsagePlanName) > 0 {
		i -= len(m.UsagePlanName)
		copy(dAtA[i:], m.UsagePlanName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UsagePlanName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.SupportPlanName) > 0 {
		i -= len(m.SupportPlanName)
		copy(dAtA[i:], m.SupportPlanName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SupportPlanName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.BillingAddress != nil {
		{
			size, err := m.BillingAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.CompanyContact != nil {
		{
			size, err := m.CompanyContact.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Company != nil {
		{
			size, err := m.Company.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if len(m.CompanyName) > 0 {
		i -= len(m.CompanyName)
		copy(dAtA[i:], m.CompanyName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CompanyName)))
		i--
		dAtA[i] = 0x72
	}
	if m.CustomerContact != nil {
		{
			size, err := m.CustomerContact.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Customer != nil {
		{
			size, err := m.Customer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.TosAccepted != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TosAccepted))
		i--
		dAtA[i] = 0x58
	}
	if len(m.PaymentProviderToken) > 0 {
		i -= len(m.PaymentProviderToken)
		copy(dAtA[i:], m.PaymentProviderToken)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PaymentProviderToken)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Currency) > 0 {
		i -= len(m.Currency)
		copy(dAtA[i:], m.Currency)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Currency)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ContactNumber) > 0 {
		i -= len(m.ContactNumber)
		copy(dAtA[i:], m.ContactNumber)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ContactNumber)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Email) > 0 {
		i -= len(m.Email)
		copy(dAtA[i:], m.Email)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Email)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.LastName) > 0 {
		i -= len(m.LastName)
		copy(dAtA[i:], m.LastName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LastName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FirstName) > 0 {
		i -= len(m.FirstName)
		copy(dAtA[i:], m.FirstName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FirstName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Locale) > 0 {
		i -= len(m.Locale)
		copy(dAtA[i:], m.Locale)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Locale)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CrmDetails != nil {
		{
			size, err := m.CrmDetails.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.CrmInfo != nil {
		{
			size, err := m.CrmInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if len(m.SfdcSubscriptionId) > 0 {
		i -= len(m.SfdcSubscriptionId)
		copy(dAtA[i:], m.SfdcSubscriptionId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SfdcSubscriptionId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.TosAcceptedAt != nil {
		{
			size, err := m.TosAcceptedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.InfraprotectInfo != nil {
		{
			size, err := m.InfraprotectInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.TaxExempt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TaxExempt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if len(m.TosVersion) > 0 {
		i -= len(m.TosVersion)
		copy(dAtA[i:], m.TosVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TosVersion)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.UsagePlanName) > 0 {
		i -= len(m.UsagePlanName)
		copy(dAtA[i:], m.UsagePlanName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UsagePlanName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.SupportPlanName) > 0 {
		i -= len(m.SupportPlanName)
		copy(dAtA[i:], m.SupportPlanName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SupportPlanName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.BillingAddress != nil {
		{
			size, err := m.BillingAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.CompanyContact != nil {
		{
			size, err := m.CompanyContact.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Company != nil {
		{
			size, err := m.Company.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if len(m.CompanyName) > 0 {
		i -= len(m.CompanyName)
		copy(dAtA[i:], m.CompanyName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CompanyName)))
		i--
		dAtA[i] = 0x72
	}
	if m.CustomerContact != nil {
		{
			size, err := m.CustomerContact.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Customer != nil {
		{
			size, err := m.Customer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.TosAccepted != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TosAccepted))
		i--
		dAtA[i] = 0x58
	}
	if len(m.PaymentProviderToken) > 0 {
		i -= len(m.PaymentProviderToken)
		copy(dAtA[i:], m.PaymentProviderToken)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PaymentProviderToken)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Currency) > 0 {
		i -= len(m.Currency)
		copy(dAtA[i:], m.Currency)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Currency)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ContactNumber) > 0 {
		i -= len(m.ContactNumber)
		copy(dAtA[i:], m.ContactNumber)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ContactNumber)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Email) > 0 {
		i -= len(m.Email)
		copy(dAtA[i:], m.Email)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Email)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.LastName) > 0 {
		i -= len(m.LastName)
		copy(dAtA[i:], m.LastName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LastName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FirstName) > 0 {
		i -= len(m.FirstName)
		copy(dAtA[i:], m.FirstName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FirstName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Locale) > 0 {
		i -= len(m.Locale)
		copy(dAtA[i:], m.Locale)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Locale)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CrmInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrmInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrmInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CustomerIdentifier) > 0 {
		i -= len(m.CustomerIdentifier)
		copy(dAtA[i:], m.CustomerIdentifier)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CustomerIdentifier)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.EntitledSkus) > 0 {
		for iNdEx := len(m.EntitledSkus) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EntitledSkus[iNdEx])
			copy(dAtA[i:], m.EntitledSkus[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.EntitledSkus[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.OrderType) > 0 {
		i -= len(m.OrderType)
		copy(dAtA[i:], m.OrderType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OrderType)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SubscriptionId) > 0 {
		i -= len(m.SubscriptionId)
		copy(dAtA[i:], m.SubscriptionId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubscriptionId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EntitlementId) > 0 {
		i -= len(m.EntitlementId)
		copy(dAtA[i:], m.EntitlementId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EntitlementId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccountId) > 0 {
		i -= len(m.AccountId)
		copy(dAtA[i:], m.AccountId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccountId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Locale)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ContactNumber)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PaymentProviderToken)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TosAccepted != 0 {
		n += 1 + sovTypes(uint64(m.TosAccepted))
	}
	if m.Customer != nil {
		l = m.Customer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CustomerContact != nil {
		l = m.CustomerContact.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CompanyName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Company != nil {
		l = m.Company.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CompanyContact != nil {
		l = m.CompanyContact.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.BillingAddress != nil {
		l = m.BillingAddress.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.SupportPlanName)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.UsagePlanName)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.TosVersion)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.TaxExempt != 0 {
		n += 2 + sovTypes(uint64(m.TaxExempt))
	}
	if m.InfraprotectInfo != nil {
		l = m.InfraprotectInfo.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.BillingProviderAccountId)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.TosAcceptedAt != nil {
		l = m.TosAcceptedAt.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.SfdcSubscriptionId)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.CrmInfo != nil {
		l = m.CrmInfo.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.CrmDetails != nil {
		l = m.CrmDetails.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Locale)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ContactNumber)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PaymentProviderToken)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TosAccepted != 0 {
		n += 1 + sovTypes(uint64(m.TosAccepted))
	}
	if m.Customer != nil {
		l = m.Customer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CustomerContact != nil {
		l = m.CustomerContact.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CompanyName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Company != nil {
		l = m.Company.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CompanyContact != nil {
		l = m.CompanyContact.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.BillingAddress != nil {
		l = m.BillingAddress.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.SupportPlanName)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.UsagePlanName)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.TosVersion)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.TaxExempt != 0 {
		n += 2 + sovTypes(uint64(m.TaxExempt))
	}
	if m.InfraprotectInfo != nil {
		l = m.InfraprotectInfo.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.TosAcceptedAt != nil {
		l = m.TosAcceptedAt.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.SfdcSubscriptionId)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.CrmInfo != nil {
		l = m.CrmInfo.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.CrmDetails != nil {
		l = m.CrmDetails.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CrmInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EntitlementId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubscriptionId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.OrderType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.EntitledSkus) > 0 {
		for _, s := range m.EntitledSkus {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.CustomerIdentifier)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *GlobalSpecType) string() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Locale:` + fmt.Sprintf("%v", this.Locale) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`FirstName:` + fmt.Sprintf("%v", this.FirstName) + `,`,
		`LastName:` + fmt.Sprintf("%v", this.LastName) + `,`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`ContactNumber:` + fmt.Sprintf("%v", this.ContactNumber) + `,`,
		`Domain:` + fmt.Sprintf("%v", this.Domain) + `,`,
		`Currency:` + fmt.Sprintf("%v", this.Currency) + `,`,
		`PaymentProviderToken:` + fmt.Sprintf("%v", this.PaymentProviderToken) + `,`,
		`TosAccepted:` + fmt.Sprintf("%v", this.TosAccepted) + `,`,
		`Customer:` + strings.Replace(fmt.Sprintf("%v", this.Customer), "GlobalSpecType", "user.GlobalSpecType", 1) + `,`,
		`CustomerContact:` + strings.Replace(fmt.Sprintf("%v", this.CustomerContact), "GlobalSpecType", "contact.GlobalSpecType", 1) + `,`,
		`CompanyName:` + fmt.Sprintf("%v", this.CompanyName) + `,`,
		`Company:` + strings.Replace(fmt.Sprintf("%v", this.Company), "GlobalSpecType", "user.GlobalSpecType", 1) + `,`,
		`CompanyContact:` + strings.Replace(fmt.Sprintf("%v", this.CompanyContact), "GlobalSpecType", "contact.GlobalSpecType", 1) + `,`,
		`Token:` + fmt.Sprintf("%v", this.Token) + `,`,
		`BillingAddress:` + strings.Replace(fmt.Sprintf("%v", this.BillingAddress), "GlobalSpecType", "contact.GlobalSpecType", 1) + `,`,
		`SupportPlanName:` + fmt.Sprintf("%v", this.SupportPlanName) + `,`,
		`UsagePlanName:` + fmt.Sprintf("%v", this.UsagePlanName) + `,`,
		`TosVersion:` + fmt.Sprintf("%v", this.TosVersion) + `,`,
		`TaxExempt:` + fmt.Sprintf("%v", this.TaxExempt) + `,`,
		`InfraprotectInfo:` + strings.Replace(fmt.Sprintf("%v", this.InfraprotectInfo), "GlobalSpecType", "infraprotect_information.GlobalSpecType", 1) + `,`,
		`BillingProviderAccountId:` + fmt.Sprintf("%v", this.BillingProviderAccountId) + `,`,
		`TosAcceptedAt:` + strings.Replace(fmt.Sprintf("%v", this.TosAcceptedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`SfdcSubscriptionId:` + fmt.Sprintf("%v", this.SfdcSubscriptionId) + `,`,
		`CrmInfo:` + strings.Replace(this.CrmInfo.String(), "CrmInfo", "CrmInfo", 1) + `,`,
		`CrmDetails:` + strings.Replace(fmt.Sprintf("%v", this.CrmDetails), "CRMInfo", "schema.CRMInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) string() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Locale:` + fmt.Sprintf("%v", this.Locale) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`FirstName:` + fmt.Sprintf("%v", this.FirstName) + `,`,
		`LastName:` + fmt.Sprintf("%v", this.LastName) + `,`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`ContactNumber:` + fmt.Sprintf("%v", this.ContactNumber) + `,`,
		`Domain:` + fmt.Sprintf("%v", this.Domain) + `,`,
		`Currency:` + fmt.Sprintf("%v", this.Currency) + `,`,
		`PaymentProviderToken:` + fmt.Sprintf("%v", this.PaymentProviderToken) + `,`,
		`TosAccepted:` + fmt.Sprintf("%v", this.TosAccepted) + `,`,
		`Customer:` + strings.Replace(fmt.Sprintf("%v", this.Customer), "GlobalSpecType", "user.GlobalSpecType", 1) + `,`,
		`CustomerContact:` + strings.Replace(fmt.Sprintf("%v", this.CustomerContact), "GlobalSpecType", "contact.GlobalSpecType", 1) + `,`,
		`CompanyName:` + fmt.Sprintf("%v", this.CompanyName) + `,`,
		`Company:` + strings.Replace(fmt.Sprintf("%v", this.Company), "GlobalSpecType", "user.GlobalSpecType", 1) + `,`,
		`CompanyContact:` + strings.Replace(fmt.Sprintf("%v", this.CompanyContact), "GlobalSpecType", "contact.GlobalSpecType", 1) + `,`,
		`Token:` + fmt.Sprintf("%v", this.Token) + `,`,
		`BillingAddress:` + strings.Replace(fmt.Sprintf("%v", this.BillingAddress), "GlobalSpecType", "contact.GlobalSpecType", 1) + `,`,
		`SupportPlanName:` + fmt.Sprintf("%v", this.SupportPlanName) + `,`,
		`UsagePlanName:` + fmt.Sprintf("%v", this.UsagePlanName) + `,`,
		`TosVersion:` + fmt.Sprintf("%v", this.TosVersion) + `,`,
		`TaxExempt:` + fmt.Sprintf("%v", this.TaxExempt) + `,`,
		`InfraprotectInfo:` + strings.Replace(fmt.Sprintf("%v", this.InfraprotectInfo), "GlobalSpecType", "infraprotect_information.GlobalSpecType", 1) + `,`,
		`TosAcceptedAt:` + strings.Replace(fmt.Sprintf("%v", this.TosAcceptedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`SfdcSubscriptionId:` + fmt.Sprintf("%v", this.SfdcSubscriptionId) + `,`,
		`CrmInfo:` + strings.Replace(this.CrmInfo.String(), "CrmInfo", "CrmInfo", 1) + `,`,
		`CrmDetails:` + strings.Replace(fmt.Sprintf("%v", this.CrmDetails), "CRMInfo", "schema.CRMInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`}`,
	}, "")
	return s
}
func (this *CrmInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CrmInfo{`,
		`AccountId:` + fmt.Sprintf("%v", this.AccountId) + `,`,
		`EntitlementId:` + fmt.Sprintf("%v", this.EntitlementId) + `,`,
		`SubscriptionId:` + fmt.Sprintf("%v", this.SubscriptionId) + `,`,
		`OrderType:` + fmt.Sprintf("%v", this.OrderType) + `,`,
		`EntitledSkus:` + fmt.Sprintf("%v", this.EntitledSkus) + `,`,
		`CustomerIdentifier:` + fmt.Sprintf("%v", this.CustomerIdentifier) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locale", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locale = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= schema.TenantType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContactNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContactNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentProviderToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentProviderToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TosAccepted", wireType)
			}
			m.TosAccepted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TosAccepted |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Customer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Customer == nil {
				m.Customer = &user.GlobalSpecType{}
			}
			if err := m.Customer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerContact", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CustomerContact == nil {
				m.CustomerContact = &contact.GlobalSpecType{}
			}
			if err := m.CustomerContact.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompanyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompanyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Company", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Company == nil {
				m.Company = &user.GlobalSpecType{}
			}
			if err := m.Company.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompanyContact", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompanyContact == nil {
				m.CompanyContact = &contact.GlobalSpecType{}
			}
			if err := m.CompanyContact.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BillingAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BillingAddress == nil {
				m.BillingAddress = &contact.GlobalSpecType{}
			}
			if err := m.BillingAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportPlanName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupportPlanName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsagePlanName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsagePlanName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TosVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TosVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaxExempt", wireType)
			}
			m.TaxExempt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaxExempt |= schema.TaxExemptionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfraprotectInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InfraprotectInfo == nil {
				m.InfraprotectInfo = &infraprotect_information.GlobalSpecType{}
			}
			if err := m.InfraprotectInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BillingProviderAccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BillingProviderAccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TosAcceptedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TosAcceptedAt == nil {
				m.TosAcceptedAt = &types.Timestamp{}
			}
			if err := m.TosAcceptedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SfdcSubscriptionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SfdcSubscriptionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrmInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CrmInfo == nil {
				m.CrmInfo = &CrmInfo{}
			}
			if err := m.CrmInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrmDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CrmDetails == nil {
				m.CrmDetails = &schema.CRMInfo{}
			}
			if err := m.CrmDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locale", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locale = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= schema.TenantType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContactNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContactNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentProviderToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentProviderToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TosAccepted", wireType)
			}
			m.TosAccepted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TosAccepted |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Customer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Customer == nil {
				m.Customer = &user.GlobalSpecType{}
			}
			if err := m.Customer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerContact", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CustomerContact == nil {
				m.CustomerContact = &contact.GlobalSpecType{}
			}
			if err := m.CustomerContact.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompanyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompanyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Company", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Company == nil {
				m.Company = &user.GlobalSpecType{}
			}
			if err := m.Company.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompanyContact", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompanyContact == nil {
				m.CompanyContact = &contact.GlobalSpecType{}
			}
			if err := m.CompanyContact.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BillingAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BillingAddress == nil {
				m.BillingAddress = &contact.GlobalSpecType{}
			}
			if err := m.BillingAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportPlanName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupportPlanName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsagePlanName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsagePlanName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TosVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TosVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaxExempt", wireType)
			}
			m.TaxExempt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaxExempt |= schema.TaxExemptionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfraprotectInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InfraprotectInfo == nil {
				m.InfraprotectInfo = &infraprotect_information.GlobalSpecType{}
			}
			if err := m.InfraprotectInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TosAcceptedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TosAcceptedAt == nil {
				m.TosAcceptedAt = &types.Timestamp{}
			}
			if err := m.TosAcceptedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SfdcSubscriptionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SfdcSubscriptionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrmInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CrmInfo == nil {
				m.CrmInfo = &CrmInfo{}
			}
			if err := m.CrmInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrmDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CrmDetails == nil {
				m.CrmDetails = &schema.CRMInfo{}
			}
			if err := m.CrmDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrmInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrmInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrmInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntitlementId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntitlementId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubscriptionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntitledSkus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntitledSkus = append(m.EntitledSkus, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerIdentifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerIdentifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
