// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package signup

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_infraprotect_information "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/infraprotect_information"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AccountMeta) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AccountMeta) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AccountMeta) DeepCopy() *AccountMeta {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AccountMeta{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AccountMeta) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AccountMeta) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AccountMetaValidator().Validate(ctx, m, opts...)
}

type ValidateAccountMeta struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAccountMeta) LocaleValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for locale")
	}

	return validatorFn, nil
}

func (v *ValidateAccountMeta) DomainValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain")
	}

	return validatorFn, nil
}

func (v *ValidateAccountMeta) TosVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tos_version")
	}

	return validatorFn, nil
}

func (v *ValidateAccountMeta) TosAcceptedAtValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var (
		reqdValidatorFn db.ValidatorFunc
		err             error
	)

	reqdValidatorFn, err = db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for tos_accepted_at")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if reqdValidatorFn != nil {
			if err = reqdValidatorFn(ctx, val, opts...); err != nil {
				return err
			}
		}
		// TODO: lookup configured third-party type validators
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAccountMeta) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AccountMeta)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AccountMeta got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domain"]; exists {

		vOpts := append(opts, db.WithValidateField("domain"))
		if err := fv(ctx, m.GetDomain(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["locale"]; exists {

		vOpts := append(opts, db.WithValidateField("locale"))
		if err := fv(ctx, m.GetLocale(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tos_accepted_at"]; exists {

		vOpts := append(opts, db.WithValidateField("tos_accepted_at"))
		if err := fv(ctx, m.GetTosAcceptedAt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tos_version"]; exists {

		vOpts := append(opts, db.WithValidateField("tos_version"))
		if err := fv(ctx, m.GetTosVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAccountMetaValidator = func() *ValidateAccountMeta {
	v := &ValidateAccountMeta{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhLocale := v.LocaleValidationRuleHandler
	rulesLocale := map[string]string{
		"ves.io.schema.rules.string.max_len": "16",
	}
	vFn, err = vrhLocale(rulesLocale)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AccountMeta.locale: %s", err)
		panic(errMsg)
	}
	v.FldValidators["locale"] = vFn

	vrhDomain := v.DomainValidationRuleHandler
	rulesDomain := map[string]string{
		"ves.io.schema.rules.string.max_len":         "17",
		"ves.io.schema.rules.string.not_in":          "[\"ves\",\"volterra\"]",
		"ves.io.schema.rules.string.ves_object_name": "true",
	}
	vFn, err = vrhDomain(rulesDomain)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AccountMeta.domain: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain"] = vFn

	vrhTosVersion := v.TosVersionValidationRuleHandler
	rulesTosVersion := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "12",
		"ves.io.schema.rules.string.min_len":   "2",
	}
	vFn, err = vrhTosVersion(rulesTosVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AccountMeta.tos_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tos_version"] = vFn

	vrhTosAcceptedAt := v.TosAcceptedAtValidationRuleHandler
	rulesTosAcceptedAt := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.timestamp.lt_now": "true",
	}
	vFn, err = vrhTosAcceptedAt(rulesTosAcceptedAt)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AccountMeta.tos_accepted_at: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tos_accepted_at"] = vFn

	return v
}()

func AccountMetaValidator() db.Validator {
	return DefaultAccountMetaValidator
}

// augmented methods on protoc/std generated struct

func (m *BillingMeta) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BillingMeta) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BillingMeta) String() string {
	if m == nil {
		return ""
	}
	copy := m.DeepCopy()
	copy.PaymentProviderToken = ""

	return copy.string()
}

func (m *BillingMeta) GoString() string {
	copy := m.DeepCopy()
	copy.PaymentProviderToken = ""

	return copy.goString()
}

// Redact squashes sensitive info in m (in-place)
func (m *BillingMeta) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	m.PaymentProviderToken = ""

	if err := m.GetInfraprotectInfo().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting BillingMeta.infraprotect_info")
	}

	return nil
}

func (m *BillingMeta) DeepCopy() *BillingMeta {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BillingMeta{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BillingMeta) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BillingMeta) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BillingMetaValidator().Validate(ctx, m, opts...)
}

type ValidateBillingMeta struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBillingMeta) PlanNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for plan_name")
	}

	return validatorFn, nil
}

func (v *ValidateBillingMeta) CurrencyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for currency")
	}

	return validatorFn, nil
}

func (v *ValidateBillingMeta) PaymentProviderTokenValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for payment_provider_token")
	}

	return validatorFn, nil
}

func (v *ValidateBillingMeta) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BillingMeta)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BillingMeta got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["billing_address"]; exists {

		vOpts := append(opts, db.WithValidateField("billing_address"))
		if err := fv(ctx, m.GetBillingAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["currency"]; exists {

		vOpts := append(opts, db.WithValidateField("currency"))
		if err := fv(ctx, m.GetCurrency(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["infraprotect_info"]; exists {

		vOpts := append(opts, db.WithValidateField("infraprotect_info"))
		if err := fv(ctx, m.GetInfraprotectInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["payment_provider_token"]; exists {

		vOpts := append(opts, db.WithValidateField("payment_provider_token"))
		if err := fv(ctx, m.GetPaymentProviderToken(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["plan_name"]; exists {

		vOpts := append(opts, db.WithValidateField("plan_name"))
		if err := fv(ctx, m.GetPlanName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tax_exemption"]; exists {

		vOpts := append(opts, db.WithValidateField("tax_exemption"))
		if err := fv(ctx, m.GetTaxExemption(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBillingMetaValidator = func() *ValidateBillingMeta {
	v := &ValidateBillingMeta{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPlanName := v.PlanNameValidationRuleHandler
	rulesPlanName := map[string]string{
		"ves.io.schema.rules.message.required":       "true",
		"ves.io.schema.rules.string.max_len":         "256",
		"ves.io.schema.rules.string.min_len":         "10",
		"ves.io.schema.rules.string.ves_object_name": "true",
	}
	vFn, err = vrhPlanName(rulesPlanName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BillingMeta.plan_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["plan_name"] = vFn

	vrhCurrency := v.CurrencyValidationRuleHandler
	rulesCurrency := map[string]string{
		"ves.io.schema.rules.string.max_len": "6",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFn, err = vrhCurrency(rulesCurrency)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BillingMeta.currency: %s", err)
		panic(errMsg)
	}
	v.FldValidators["currency"] = vFn

	vrhPaymentProviderToken := v.PaymentProviderTokenValidationRuleHandler
	rulesPaymentProviderToken := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhPaymentProviderToken(rulesPaymentProviderToken)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BillingMeta.payment_provider_token: %s", err)
		panic(errMsg)
	}
	v.FldValidators["payment_provider_token"] = vFn

	v.FldValidators["infraprotect_info"] = ves_io_schema_infraprotect_information.GlobalSpecTypeValidator().Validate

	return v
}()

func BillingMetaValidator() db.Validator {
	return DefaultBillingMetaValidator
}

// augmented methods on protoc/std generated struct

func (m *CompanyMeta) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CompanyMeta) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CompanyMeta) DeepCopy() *CompanyMeta {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CompanyMeta{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CompanyMeta) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CompanyMeta) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CompanyMetaValidator().Validate(ctx, m, opts...)
}

type ValidateCompanyMeta struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCompanyMeta) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateCompanyMeta) MailingAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for mailing_address")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCompanyMeta) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CompanyMeta)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CompanyMeta got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["mailing_address"]; exists {

		vOpts := append(opts, db.WithValidateField("mailing_address"))
		if err := fv(ctx, m.GetMailingAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCompanyMetaValidator = func() *ValidateCompanyMeta {
	v := &ValidateCompanyMeta{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.min_len":   "5",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CompanyMeta.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhMailingAddress := v.MailingAddressValidationRuleHandler
	rulesMailingAddress := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMailingAddress(rulesMailingAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CompanyMeta.mailing_address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mailing_address"] = vFn

	return v
}()

func CompanyMetaValidator() db.Validator {
	return DefaultCompanyMetaValidator
}

// augmented methods on protoc/std generated struct

func (m *ContactMeta) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ContactMeta) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ContactMeta) DeepCopy() *ContactMeta {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ContactMeta{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ContactMeta) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ContactMeta) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ContactMetaValidator().Validate(ctx, m, opts...)
}

type ValidateContactMeta struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateContactMeta) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ContactMeta)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ContactMeta got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address1"]; exists {

		vOpts := append(opts, db.WithValidateField("address1"))
		if err := fv(ctx, m.GetAddress1(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["address2"]; exists {

		vOpts := append(opts, db.WithValidateField("address2"))
		if err := fv(ctx, m.GetAddress2(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["city"]; exists {

		vOpts := append(opts, db.WithValidateField("city"))
		if err := fv(ctx, m.GetCity(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["country"]; exists {

		vOpts := append(opts, db.WithValidateField("country"))
		if err := fv(ctx, m.GetCountry(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["county"]; exists {

		vOpts := append(opts, db.WithValidateField("county"))
		if err := fv(ctx, m.GetCounty(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["phone_number"]; exists {

		vOpts := append(opts, db.WithValidateField("phone_number"))
		if err := fv(ctx, m.GetPhoneNumber(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state_code"]; exists {

		vOpts := append(opts, db.WithValidateField("state_code"))
		if err := fv(ctx, m.GetStateCode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["zip_code"]; exists {

		vOpts := append(opts, db.WithValidateField("zip_code"))
		if err := fv(ctx, m.GetZipCode(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultContactMetaValidator = func() *ValidateContactMeta {
	v := &ValidateContactMeta{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ContactMetaValidator() db.Validator {
	return DefaultContactMetaValidator
}

// augmented methods on protoc/std generated struct

func (m *CrmInfoV2) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CrmInfoV2) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CrmInfoV2) DeepCopy() *CrmInfoV2 {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CrmInfoV2{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CrmInfoV2) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CrmInfoV2) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CrmInfoV2Validator().Validate(ctx, m, opts...)
}

type ValidateCrmInfoV2 struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCrmInfoV2) AccountIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for account_id")
	}

	return validatorFn, nil
}

func (v *ValidateCrmInfoV2) EntitlementIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for entitlement_id")
	}

	return validatorFn, nil
}

func (v *ValidateCrmInfoV2) SubscriptionIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for subscription_id")
	}

	return validatorFn, nil
}

func (v *ValidateCrmInfoV2) OrderTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for order_type")
	}

	return validatorFn, nil
}

func (v *ValidateCrmInfoV2) EntitledSkusValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for entitled_skus")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for entitled_skus")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated entitled_skus")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items entitled_skus")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCrmInfoV2) CustomerIdentifierValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for customer_identifier")
	}

	return validatorFn, nil
}

func (v *ValidateCrmInfoV2) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CrmInfoV2)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CrmInfoV2 got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["account_id"]; exists {

		vOpts := append(opts, db.WithValidateField("account_id"))
		if err := fv(ctx, m.GetAccountId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["customer_identifier"]; exists {

		vOpts := append(opts, db.WithValidateField("customer_identifier"))
		if err := fv(ctx, m.GetCustomerIdentifier(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["entitled_skus"]; exists {
		vOpts := append(opts, db.WithValidateField("entitled_skus"))
		if err := fv(ctx, m.GetEntitledSkus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["entitlement_id"]; exists {

		vOpts := append(opts, db.WithValidateField("entitlement_id"))
		if err := fv(ctx, m.GetEntitlementId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["order_type"]; exists {

		vOpts := append(opts, db.WithValidateField("order_type"))
		if err := fv(ctx, m.GetOrderType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["subscription_id"]; exists {

		vOpts := append(opts, db.WithValidateField("subscription_id"))
		if err := fv(ctx, m.GetSubscriptionId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCrmInfoV2Validator = func() *ValidateCrmInfoV2 {
	v := &ValidateCrmInfoV2{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAccountId := v.AccountIdValidationRuleHandler
	rulesAccountId := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhAccountId(rulesAccountId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CrmInfoV2.account_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["account_id"] = vFn

	vrhEntitlementId := v.EntitlementIdValidationRuleHandler
	rulesEntitlementId := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhEntitlementId(rulesEntitlementId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CrmInfoV2.entitlement_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["entitlement_id"] = vFn

	vrhSubscriptionId := v.SubscriptionIdValidationRuleHandler
	rulesSubscriptionId := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhSubscriptionId(rulesSubscriptionId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CrmInfoV2.subscription_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["subscription_id"] = vFn

	vrhOrderType := v.OrderTypeValidationRuleHandler
	rulesOrderType := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhOrderType(rulesOrderType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CrmInfoV2.order_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["order_type"] = vFn

	vrhEntitledSkus := v.EntitledSkusValidationRuleHandler
	rulesEntitledSkus := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_len": "256",
		"ves.io.schema.rules.repeated.max_items":            "64",
	}
	vFn, err = vrhEntitledSkus(rulesEntitledSkus)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CrmInfoV2.entitled_skus: %s", err)
		panic(errMsg)
	}
	v.FldValidators["entitled_skus"] = vFn

	vrhCustomerIdentifier := v.CustomerIdentifierValidationRuleHandler
	rulesCustomerIdentifier := map[string]string{
		"ves.io.schema.rules.string.max_len": "255",
	}
	vFn, err = vrhCustomerIdentifier(rulesCustomerIdentifier)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CrmInfoV2.customer_identifier: %s", err)
		panic(errMsg)
	}
	v.FldValidators["customer_identifier"] = vFn

	return v
}()

func CrmInfoV2Validator() db.Validator {
	return DefaultCrmInfoV2Validator
}

// augmented methods on protoc/std generated struct

func (m *InternalMeta) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *InternalMeta) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *InternalMeta) DeepCopy() *InternalMeta {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &InternalMeta{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *InternalMeta) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *InternalMeta) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return InternalMetaValidator().Validate(ctx, m, opts...)
}

type ValidateInternalMeta struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInternalMeta) F5XcInstanceNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for f5xc_instance_name")
	}

	return validatorFn, nil
}

func (v *ValidateInternalMeta) KcInstanceNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for kc_instance_name")
	}

	return validatorFn, nil
}

func (v *ValidateInternalMeta) TenantIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tenant_id")
	}

	return validatorFn, nil
}

func (v *ValidateInternalMeta) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*InternalMeta)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *InternalMeta got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["f5xc_instance_name"]; exists {

		vOpts := append(opts, db.WithValidateField("f5xc_instance_name"))
		if err := fv(ctx, m.GetF5XcInstanceName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["kc_instance_name"]; exists {

		vOpts := append(opts, db.WithValidateField("kc_instance_name"))
		if err := fv(ctx, m.GetKcInstanceName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tenant_id"]; exists {

		vOpts := append(opts, db.WithValidateField("tenant_id"))
		if err := fv(ctx, m.GetTenantId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInternalMetaValidator = func() *ValidateInternalMeta {
	v := &ValidateInternalMeta{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhF5XcInstanceName := v.F5XcInstanceNameValidationRuleHandler
	rulesF5XcInstanceName := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhF5XcInstanceName(rulesF5XcInstanceName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for InternalMeta.f5xc_instance_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["f5xc_instance_name"] = vFn

	vrhKcInstanceName := v.KcInstanceNameValidationRuleHandler
	rulesKcInstanceName := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhKcInstanceName(rulesKcInstanceName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for InternalMeta.kc_instance_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["kc_instance_name"] = vFn

	vrhTenantId := v.TenantIdValidationRuleHandler
	rulesTenantId := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhTenantId(rulesTenantId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for InternalMeta.tenant_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tenant_id"] = vFn

	return v
}()

func InternalMetaValidator() db.Validator {
	return DefaultInternalMetaValidator
}

// augmented methods on protoc/std generated struct

func (m *MarketplaceAws) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MarketplaceAws) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MarketplaceAws) DeepCopy() *MarketplaceAws {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MarketplaceAws{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MarketplaceAws) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MarketplaceAws) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MarketplaceAwsValidator().Validate(ctx, m, opts...)
}

type ValidateMarketplaceAws struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMarketplaceAws) CrmDetailsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for crm_details")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.CRMInfoValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateMarketplaceAws) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MarketplaceAws)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MarketplaceAws got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["crm_details"]; exists {

		vOpts := append(opts, db.WithValidateField("crm_details"))
		if err := fv(ctx, m.GetCrmDetails(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMarketplaceAwsValidator = func() *ValidateMarketplaceAws {
	v := &ValidateMarketplaceAws{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCrmDetails := v.CrmDetailsValidationRuleHandler
	rulesCrmDetails := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhCrmDetails(rulesCrmDetails)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MarketplaceAws.crm_details: %s", err)
		panic(errMsg)
	}
	v.FldValidators["crm_details"] = vFn

	return v
}()

func MarketplaceAwsValidator() db.Validator {
	return DefaultMarketplaceAwsValidator
}

// augmented methods on protoc/std generated struct

func (m *SourceInternalScaling) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SourceInternalScaling) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SourceInternalScaling) DeepCopy() *SourceInternalScaling {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SourceInternalScaling{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SourceInternalScaling) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SourceInternalScaling) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SourceInternalScalingValidator().Validate(ctx, m, opts...)
}

type ValidateSourceInternalScaling struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSourceInternalScaling) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SourceInternalScaling)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SourceInternalScaling got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSourceInternalScalingValidator = func() *ValidateSourceInternalScaling {
	v := &ValidateSourceInternalScaling{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SourceInternalScalingValidator() db.Validator {
	return DefaultSourceInternalScalingValidator
}

// augmented methods on protoc/std generated struct

func (m *SourceInternalSre) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SourceInternalSre) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SourceInternalSre) DeepCopy() *SourceInternalSre {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SourceInternalSre{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SourceInternalSre) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SourceInternalSre) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SourceInternalSreValidator().Validate(ctx, m, opts...)
}

type ValidateSourceInternalSre struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSourceInternalSre) F5XcInstanceNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for f5xc_instance_name")
	}

	return validatorFn, nil
}

func (v *ValidateSourceInternalSre) KcInstanceNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for kc_instance_name")
	}

	return validatorFn, nil
}

func (v *ValidateSourceInternalSre) TenantIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tenant_id")
	}

	return validatorFn, nil
}

func (v *ValidateSourceInternalSre) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SourceInternalSre)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SourceInternalSre got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["crm_details"]; exists {

		vOpts := append(opts, db.WithValidateField("crm_details"))
		if err := fv(ctx, m.GetCrmDetails(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["crm_info"]; exists {

		vOpts := append(opts, db.WithValidateField("crm_info"))
		if err := fv(ctx, m.GetCrmInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["f5xc_instance_name"]; exists {

		vOpts := append(opts, db.WithValidateField("f5xc_instance_name"))
		if err := fv(ctx, m.GetF5XcInstanceName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["kc_instance_name"]; exists {

		vOpts := append(opts, db.WithValidateField("kc_instance_name"))
		if err := fv(ctx, m.GetKcInstanceName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tenant_id"]; exists {

		vOpts := append(opts, db.WithValidateField("tenant_id"))
		if err := fv(ctx, m.GetTenantId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSourceInternalSreValidator = func() *ValidateSourceInternalSre {
	v := &ValidateSourceInternalSre{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhF5XcInstanceName := v.F5XcInstanceNameValidationRuleHandler
	rulesF5XcInstanceName := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhF5XcInstanceName(rulesF5XcInstanceName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SourceInternalSre.f5xc_instance_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["f5xc_instance_name"] = vFn

	vrhKcInstanceName := v.KcInstanceNameValidationRuleHandler
	rulesKcInstanceName := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhKcInstanceName(rulesKcInstanceName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SourceInternalSre.kc_instance_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["kc_instance_name"] = vFn

	vrhTenantId := v.TenantIdValidationRuleHandler
	rulesTenantId := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhTenantId(rulesTenantId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SourceInternalSre.tenant_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tenant_id"] = vFn

	v.FldValidators["crm_info"] = CrmInfoV2Validator().Validate

	v.FldValidators["crm_details"] = ves_io_schema.CRMInfoValidator().Validate

	return v
}()

func SourceInternalSreValidator() db.Validator {
	return DefaultSourceInternalSreValidator
}

// augmented methods on protoc/std generated struct

func (m *SourceInternalSso) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SourceInternalSso) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SourceInternalSso) DeepCopy() *SourceInternalSso {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SourceInternalSso{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SourceInternalSso) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SourceInternalSso) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SourceInternalSsoValidator().Validate(ctx, m, opts...)
}

type ValidateSourceInternalSso struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSourceInternalSso) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SourceInternalSso)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SourceInternalSso got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSourceInternalSsoValidator = func() *ValidateSourceInternalSso {
	v := &ValidateSourceInternalSso{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SourceInternalSsoValidator() db.Validator {
	return DefaultSourceInternalSsoValidator
}

// augmented methods on protoc/std generated struct

func (m *SourceMarketplace) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SourceMarketplace) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SourceMarketplace) DeepCopy() *SourceMarketplace {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SourceMarketplace{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SourceMarketplace) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SourceMarketplace) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SourceMarketplaceValidator().Validate(ctx, m, opts...)
}

type ValidateSourceMarketplace struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSourceMarketplace) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SourceMarketplace)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SourceMarketplace got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetMarketplaceChoice().(type) {
	case *SourceMarketplace_MarketplaceAws:
		if fv, exists := v.FldValidators["marketplace_choice.marketplace_aws"]; exists {
			val := m.GetMarketplaceChoice().(*SourceMarketplace_MarketplaceAws).MarketplaceAws
			vOpts := append(opts,
				db.WithValidateField("marketplace_choice"),
				db.WithValidateField("marketplace_aws"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSourceMarketplaceValidator = func() *ValidateSourceMarketplace {
	v := &ValidateSourceMarketplace{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["marketplace_choice.marketplace_aws"] = MarketplaceAwsValidator().Validate

	return v
}()

func SourceMarketplaceValidator() db.Validator {
	return DefaultSourceMarketplaceValidator
}

// augmented methods on protoc/std generated struct

func (m *SourceMsp) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SourceMsp) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SourceMsp) DeepCopy() *SourceMsp {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SourceMsp{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SourceMsp) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SourceMsp) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SourceMspValidator().Validate(ctx, m, opts...)
}

type ValidateSourceMsp struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSourceMsp) ChildTenantObjNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for child_tenant_obj_name")
	}

	return validatorFn, nil
}

func (v *ValidateSourceMsp) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SourceMsp)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SourceMsp got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["child_tenant_obj_name"]; exists {

		vOpts := append(opts, db.WithValidateField("child_tenant_obj_name"))
		if err := fv(ctx, m.GetChildTenantObjName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["crm_details"]; exists {

		vOpts := append(opts, db.WithValidateField("crm_details"))
		if err := fv(ctx, m.GetCrmDetails(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["crm_info"]; exists {

		vOpts := append(opts, db.WithValidateField("crm_info"))
		if err := fv(ctx, m.GetCrmInfo(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSourceMspValidator = func() *ValidateSourceMsp {
	v := &ValidateSourceMsp{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChildTenantObjName := v.ChildTenantObjNameValidationRuleHandler
	rulesChildTenantObjName := map[string]string{
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFn, err = vrhChildTenantObjName(rulesChildTenantObjName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SourceMsp.child_tenant_obj_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["child_tenant_obj_name"] = vFn

	v.FldValidators["crm_info"] = CrmInfoV2Validator().Validate

	v.FldValidators["crm_details"] = ves_io_schema.CRMInfoValidator().Validate

	return v
}()

func SourceMspValidator() db.Validator {
	return DefaultSourceMspValidator
}

// augmented methods on protoc/std generated struct

func (m *SourcePlanTransition) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SourcePlanTransition) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SourcePlanTransition) DeepCopy() *SourcePlanTransition {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SourcePlanTransition{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SourcePlanTransition) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SourcePlanTransition) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SourcePlanTransitionValidator().Validate(ctx, m, opts...)
}

type ValidateSourcePlanTransition struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSourcePlanTransition) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SourcePlanTransition)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SourcePlanTransition got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["is_sso_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("is_sso_enabled"))
		if err := fv(ctx, m.GetIsSsoEnabled(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSourcePlanTransitionValidator = func() *ValidateSourcePlanTransition {
	v := &ValidateSourcePlanTransition{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SourcePlanTransitionValidator() db.Validator {
	return DefaultSourcePlanTransitionValidator
}

// augmented methods on protoc/std generated struct

func (m *SourcePublic) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SourcePublic) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SourcePublic) DeepCopy() *SourcePublic {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SourcePublic{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SourcePublic) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SourcePublic) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SourcePublicValidator().Validate(ctx, m, opts...)
}

type ValidateSourcePublic struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSourcePublic) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SourcePublic)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SourcePublic got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSourcePublicValidator = func() *ValidateSourcePublic {
	v := &ValidateSourcePublic{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SourcePublicValidator() db.Validator {
	return DefaultSourcePublicValidator
}

// augmented methods on protoc/std generated struct

func (m *UserMeta) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UserMeta) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UserMeta) DeepCopy() *UserMeta {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UserMeta{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UserMeta) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UserMeta) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UserMetaValidator().Validate(ctx, m, opts...)
}

type ValidateUserMeta struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUserMeta) FirstNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for first_name")
	}

	return validatorFn, nil
}

func (v *ValidateUserMeta) LastNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for last_name")
	}

	return validatorFn, nil
}

func (v *ValidateUserMeta) EmailValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for email")
	}

	return validatorFn, nil
}

func (v *ValidateUserMeta) ContactNumberValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for contact_number")
	}

	return validatorFn, nil
}

func (v *ValidateUserMeta) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UserMeta)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UserMeta got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["contact_number"]; exists {

		vOpts := append(opts, db.WithValidateField("contact_number"))
		if err := fv(ctx, m.GetContactNumber(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["email"]; exists {

		vOpts := append(opts, db.WithValidateField("email"))
		if err := fv(ctx, m.GetEmail(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["first_name"]; exists {

		vOpts := append(opts, db.WithValidateField("first_name"))
		if err := fv(ctx, m.GetFirstName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["last_name"]; exists {

		vOpts := append(opts, db.WithValidateField("last_name"))
		if err := fv(ctx, m.GetLastName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUserMetaValidator = func() *ValidateUserMeta {
	v := &ValidateUserMeta{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhFirstName := v.FirstNameValidationRuleHandler
	rulesFirstName := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhFirstName(rulesFirstName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UserMeta.first_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["first_name"] = vFn

	vrhLastName := v.LastNameValidationRuleHandler
	rulesLastName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhLastName(rulesLastName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UserMeta.last_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["last_name"] = vFn

	vrhEmail := v.EmailValidationRuleHandler
	rulesEmail := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.email":     "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhEmail(rulesEmail)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UserMeta.email: %s", err)
		panic(errMsg)
	}
	v.FldValidators["email"] = vFn

	vrhContactNumber := v.ContactNumberValidationRuleHandler
	rulesContactNumber := map[string]string{
		"ves.io.schema.rules.message.required":    "true",
		"ves.io.schema.rules.string.max_len":      "256",
		"ves.io.schema.rules.string.min_len":      "1",
		"ves.io.schema.rules.string.phone_number": "true",
	}
	vFn, err = vrhContactNumber(rulesContactNumber)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UserMeta.contact_number: %s", err)
		panic(errMsg)
	}
	v.FldValidators["contact_number"] = vFn

	return v
}()

func UserMetaValidator() db.Validator {
	return DefaultUserMetaValidator
}
