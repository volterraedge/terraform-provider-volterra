// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package signup

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_infraprotect_information "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/infraprotect_information"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AccountMeta) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AccountMeta) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AccountMeta) DeepCopy() *AccountMeta {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AccountMeta{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AccountMeta) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AccountMeta) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AccountMetaValidator().Validate(ctx, m, opts...)
}

type ValidateAccountMeta struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAccountMeta) LocaleValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for locale")
	}

	return validatorFn, nil
}

func (v *ValidateAccountMeta) DomainValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain")
	}

	return validatorFn, nil
}

func (v *ValidateAccountMeta) TosVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tos_version")
	}

	return validatorFn, nil
}

func (v *ValidateAccountMeta) TosAcceptedAtValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var (
		reqdValidatorFn db.ValidatorFunc
		err             error
	)

	reqdValidatorFn, err = db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for tos_accepted_at")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if reqdValidatorFn != nil {
			if err = reqdValidatorFn(ctx, val, opts...); err != nil {
				return err
			}
		}
		// TODO: lookup configured third-party type validators
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAccountMeta) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AccountMeta)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AccountMeta got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domain"]; exists {

		vOpts := append(opts, db.WithValidateField("domain"))
		if err := fv(ctx, m.GetDomain(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["locale"]; exists {

		vOpts := append(opts, db.WithValidateField("locale"))
		if err := fv(ctx, m.GetLocale(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tos_accepted_at"]; exists {

		vOpts := append(opts, db.WithValidateField("tos_accepted_at"))
		if err := fv(ctx, m.GetTosAcceptedAt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tos_version"]; exists {

		vOpts := append(opts, db.WithValidateField("tos_version"))
		if err := fv(ctx, m.GetTosVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAccountMetaValidator = func() *ValidateAccountMeta {
	v := &ValidateAccountMeta{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhLocale := v.LocaleValidationRuleHandler
	rulesLocale := map[string]string{
		"ves.io.schema.rules.string.max_len": "16",
	}
	vFn, err = vrhLocale(rulesLocale)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AccountMeta.locale: %s", err)
		panic(errMsg)
	}
	v.FldValidators["locale"] = vFn

	vrhDomain := v.DomainValidationRuleHandler
	rulesDomain := map[string]string{
		"ves.io.schema.rules.string.max_len":         "17",
		"ves.io.schema.rules.string.not_in":          "[\"ves\",\"volterra\"]",
		"ves.io.schema.rules.string.ves_object_name": "true",
	}
	vFn, err = vrhDomain(rulesDomain)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AccountMeta.domain: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain"] = vFn

	vrhTosVersion := v.TosVersionValidationRuleHandler
	rulesTosVersion := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "12",
		"ves.io.schema.rules.string.min_len":   "2",
	}
	vFn, err = vrhTosVersion(rulesTosVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AccountMeta.tos_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tos_version"] = vFn

	vrhTosAcceptedAt := v.TosAcceptedAtValidationRuleHandler
	rulesTosAcceptedAt := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.timestamp.lt_now": "true",
	}
	vFn, err = vrhTosAcceptedAt(rulesTosAcceptedAt)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AccountMeta.tos_accepted_at: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tos_accepted_at"] = vFn

	return v
}()

func AccountMetaValidator() db.Validator {
	return DefaultAccountMetaValidator
}

// augmented methods on protoc/std generated struct

func (m *BillingMeta) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BillingMeta) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BillingMeta) String() string {
	if m == nil {
		return ""
	}
	copy := m.DeepCopy()
	copy.Redact(context.Background())
	return copy.string()
}

func (m *BillingMeta) GoString() string {
	copy := m.DeepCopy()
	copy.Redact(context.Background())
	return copy.goString()
}

// Redact squashes sensitive info in m (in-place)
func (m *BillingMeta) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	m.PaymentProviderToken = ""

	if err := m.GetInfraprotectInfo().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting BillingMeta.infraprotect_info")
	}

	return nil
}

func (m *BillingMeta) DeepCopy() *BillingMeta {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BillingMeta{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BillingMeta) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BillingMeta) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BillingMetaValidator().Validate(ctx, m, opts...)
}

type ValidateBillingMeta struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBillingMeta) PlanNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for plan_name")
	}

	return validatorFn, nil
}

func (v *ValidateBillingMeta) CurrencyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for currency")
	}

	return validatorFn, nil
}

func (v *ValidateBillingMeta) PaymentProviderTokenValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for payment_provider_token")
	}

	return validatorFn, nil
}

func (v *ValidateBillingMeta) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BillingMeta)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BillingMeta got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["billing_address"]; exists {

		vOpts := append(opts, db.WithValidateField("billing_address"))
		if err := fv(ctx, m.GetBillingAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["currency"]; exists {

		vOpts := append(opts, db.WithValidateField("currency"))
		if err := fv(ctx, m.GetCurrency(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["infraprotect_info"]; exists {

		vOpts := append(opts, db.WithValidateField("infraprotect_info"))
		if err := fv(ctx, m.GetInfraprotectInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["payment_provider_token"]; exists {

		vOpts := append(opts, db.WithValidateField("payment_provider_token"))
		if err := fv(ctx, m.GetPaymentProviderToken(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["plan_name"]; exists {

		vOpts := append(opts, db.WithValidateField("plan_name"))
		if err := fv(ctx, m.GetPlanName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tax_exemption"]; exists {

		vOpts := append(opts, db.WithValidateField("tax_exemption"))
		if err := fv(ctx, m.GetTaxExemption(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBillingMetaValidator = func() *ValidateBillingMeta {
	v := &ValidateBillingMeta{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPlanName := v.PlanNameValidationRuleHandler
	rulesPlanName := map[string]string{
		"ves.io.schema.rules.message.required":       "true",
		"ves.io.schema.rules.string.max_len":         "256",
		"ves.io.schema.rules.string.min_len":         "10",
		"ves.io.schema.rules.string.ves_object_name": "true",
	}
	vFn, err = vrhPlanName(rulesPlanName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BillingMeta.plan_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["plan_name"] = vFn

	vrhCurrency := v.CurrencyValidationRuleHandler
	rulesCurrency := map[string]string{
		"ves.io.schema.rules.string.max_len": "6",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFn, err = vrhCurrency(rulesCurrency)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BillingMeta.currency: %s", err)
		panic(errMsg)
	}
	v.FldValidators["currency"] = vFn

	vrhPaymentProviderToken := v.PaymentProviderTokenValidationRuleHandler
	rulesPaymentProviderToken := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhPaymentProviderToken(rulesPaymentProviderToken)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BillingMeta.payment_provider_token: %s", err)
		panic(errMsg)
	}
	v.FldValidators["payment_provider_token"] = vFn

	v.FldValidators["infraprotect_info"] = ves_io_schema_infraprotect_information.GlobalSpecTypeValidator().Validate

	return v
}()

func BillingMetaValidator() db.Validator {
	return DefaultBillingMetaValidator
}

// augmented methods on protoc/std generated struct

func (m *CompanyMeta) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CompanyMeta) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CompanyMeta) DeepCopy() *CompanyMeta {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CompanyMeta{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CompanyMeta) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CompanyMeta) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CompanyMetaValidator().Validate(ctx, m, opts...)
}

type ValidateCompanyMeta struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCompanyMeta) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateCompanyMeta) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CompanyMeta)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CompanyMeta got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["mailing_address"]; exists {

		vOpts := append(opts, db.WithValidateField("mailing_address"))
		if err := fv(ctx, m.GetMailingAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCompanyMetaValidator = func() *ValidateCompanyMeta {
	v := &ValidateCompanyMeta{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CompanyMeta.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func CompanyMetaValidator() db.Validator {
	return DefaultCompanyMetaValidator
}

// augmented methods on protoc/std generated struct

func (m *ContactMeta) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ContactMeta) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ContactMeta) DeepCopy() *ContactMeta {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ContactMeta{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ContactMeta) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ContactMeta) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ContactMetaValidator().Validate(ctx, m, opts...)
}

type ValidateContactMeta struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateContactMeta) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ContactMeta)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ContactMeta got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address1"]; exists {

		vOpts := append(opts, db.WithValidateField("address1"))
		if err := fv(ctx, m.GetAddress1(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["address2"]; exists {

		vOpts := append(opts, db.WithValidateField("address2"))
		if err := fv(ctx, m.GetAddress2(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["city"]; exists {

		vOpts := append(opts, db.WithValidateField("city"))
		if err := fv(ctx, m.GetCity(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["country"]; exists {

		vOpts := append(opts, db.WithValidateField("country"))
		if err := fv(ctx, m.GetCountry(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["county"]; exists {

		vOpts := append(opts, db.WithValidateField("county"))
		if err := fv(ctx, m.GetCounty(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["phone_number"]; exists {

		vOpts := append(opts, db.WithValidateField("phone_number"))
		if err := fv(ctx, m.GetPhoneNumber(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state_code"]; exists {

		vOpts := append(opts, db.WithValidateField("state_code"))
		if err := fv(ctx, m.GetStateCode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["zip_code"]; exists {

		vOpts := append(opts, db.WithValidateField("zip_code"))
		if err := fv(ctx, m.GetZipCode(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultContactMetaValidator = func() *ValidateContactMeta {
	v := &ValidateContactMeta{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ContactMetaValidator() db.Validator {
	return DefaultContactMetaValidator
}

// augmented methods on protoc/std generated struct

func (m *InternalMeta) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *InternalMeta) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *InternalMeta) DeepCopy() *InternalMeta {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &InternalMeta{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *InternalMeta) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *InternalMeta) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return InternalMetaValidator().Validate(ctx, m, opts...)
}

type ValidateInternalMeta struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInternalMeta) F5XcInstanceNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for f5xc_instance_name")
	}

	return validatorFn, nil
}

func (v *ValidateInternalMeta) KcInstanceNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for kc_instance_name")
	}

	return validatorFn, nil
}

func (v *ValidateInternalMeta) TenantIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tenant_id")
	}

	return validatorFn, nil
}

func (v *ValidateInternalMeta) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*InternalMeta)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *InternalMeta got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["f5xc_instance_name"]; exists {

		vOpts := append(opts, db.WithValidateField("f5xc_instance_name"))
		if err := fv(ctx, m.GetF5XcInstanceName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["kc_instance_name"]; exists {

		vOpts := append(opts, db.WithValidateField("kc_instance_name"))
		if err := fv(ctx, m.GetKcInstanceName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tenant_id"]; exists {

		vOpts := append(opts, db.WithValidateField("tenant_id"))
		if err := fv(ctx, m.GetTenantId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInternalMetaValidator = func() *ValidateInternalMeta {
	v := &ValidateInternalMeta{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhF5XcInstanceName := v.F5XcInstanceNameValidationRuleHandler
	rulesF5XcInstanceName := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhF5XcInstanceName(rulesF5XcInstanceName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for InternalMeta.f5xc_instance_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["f5xc_instance_name"] = vFn

	vrhKcInstanceName := v.KcInstanceNameValidationRuleHandler
	rulesKcInstanceName := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhKcInstanceName(rulesKcInstanceName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for InternalMeta.kc_instance_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["kc_instance_name"] = vFn

	vrhTenantId := v.TenantIdValidationRuleHandler
	rulesTenantId := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhTenantId(rulesTenantId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for InternalMeta.tenant_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tenant_id"] = vFn

	return v
}()

func InternalMetaValidator() db.Validator {
	return DefaultInternalMetaValidator
}

// augmented methods on protoc/std generated struct

func (m *SignupTypeInternalScaling) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SignupTypeInternalScaling) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SignupTypeInternalScaling) DeepCopy() *SignupTypeInternalScaling {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SignupTypeInternalScaling{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SignupTypeInternalScaling) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SignupTypeInternalScaling) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SignupTypeInternalScalingValidator().Validate(ctx, m, opts...)
}

type ValidateSignupTypeInternalScaling struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSignupTypeInternalScaling) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SignupTypeInternalScaling)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SignupTypeInternalScaling got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSignupTypeInternalScalingValidator = func() *ValidateSignupTypeInternalScaling {
	v := &ValidateSignupTypeInternalScaling{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SignupTypeInternalScalingValidator() db.Validator {
	return DefaultSignupTypeInternalScalingValidator
}

// augmented methods on protoc/std generated struct

func (m *SignupTypeInternalSre) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SignupTypeInternalSre) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SignupTypeInternalSre) DeepCopy() *SignupTypeInternalSre {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SignupTypeInternalSre{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SignupTypeInternalSre) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SignupTypeInternalSre) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SignupTypeInternalSreValidator().Validate(ctx, m, opts...)
}

type ValidateSignupTypeInternalSre struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSignupTypeInternalSre) F5XcInstanceNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for f5xc_instance_name")
	}

	return validatorFn, nil
}

func (v *ValidateSignupTypeInternalSre) KcInstanceNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for kc_instance_name")
	}

	return validatorFn, nil
}

func (v *ValidateSignupTypeInternalSre) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SignupTypeInternalSre)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SignupTypeInternalSre got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["crm_details"]; exists {

		vOpts := append(opts, db.WithValidateField("crm_details"))
		if err := fv(ctx, m.GetCrmDetails(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["f5xc_instance_name"]; exists {

		vOpts := append(opts, db.WithValidateField("f5xc_instance_name"))
		if err := fv(ctx, m.GetF5XcInstanceName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["is_demo_tenant"]; exists {

		vOpts := append(opts, db.WithValidateField("is_demo_tenant"))
		if err := fv(ctx, m.GetIsDemoTenant(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["kc_instance_name"]; exists {

		vOpts := append(opts, db.WithValidateField("kc_instance_name"))
		if err := fv(ctx, m.GetKcInstanceName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSignupTypeInternalSreValidator = func() *ValidateSignupTypeInternalSre {
	v := &ValidateSignupTypeInternalSre{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhF5XcInstanceName := v.F5XcInstanceNameValidationRuleHandler
	rulesF5XcInstanceName := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhF5XcInstanceName(rulesF5XcInstanceName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SignupTypeInternalSre.f5xc_instance_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["f5xc_instance_name"] = vFn

	vrhKcInstanceName := v.KcInstanceNameValidationRuleHandler
	rulesKcInstanceName := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhKcInstanceName(rulesKcInstanceName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SignupTypeInternalSre.kc_instance_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["kc_instance_name"] = vFn

	v.FldValidators["crm_details"] = ves_io_schema.CRMInfoValidator().Validate

	return v
}()

func SignupTypeInternalSreValidator() db.Validator {
	return DefaultSignupTypeInternalSreValidator
}

// augmented methods on protoc/std generated struct

func (m *SignupTypeInternalSso) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SignupTypeInternalSso) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SignupTypeInternalSso) DeepCopy() *SignupTypeInternalSso {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SignupTypeInternalSso{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SignupTypeInternalSso) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SignupTypeInternalSso) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SignupTypeInternalSsoValidator().Validate(ctx, m, opts...)
}

type ValidateSignupTypeInternalSso struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSignupTypeInternalSso) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SignupTypeInternalSso)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SignupTypeInternalSso got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSignupTypeInternalSsoValidator = func() *ValidateSignupTypeInternalSso {
	v := &ValidateSignupTypeInternalSso{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SignupTypeInternalSsoValidator() db.Validator {
	return DefaultSignupTypeInternalSsoValidator
}

// augmented methods on protoc/std generated struct

func (m *SignupTypeMarketplace) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SignupTypeMarketplace) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SignupTypeMarketplace) DeepCopy() *SignupTypeMarketplace {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SignupTypeMarketplace{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SignupTypeMarketplace) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SignupTypeMarketplace) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SignupTypeMarketplaceValidator().Validate(ctx, m, opts...)
}

type ValidateSignupTypeMarketplace struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSignupTypeMarketplace) CrmDetailsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for crm_details")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.CRMInfoValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSignupTypeMarketplace) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SignupTypeMarketplace)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SignupTypeMarketplace got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["crm_details"]; exists {

		vOpts := append(opts, db.WithValidateField("crm_details"))
		if err := fv(ctx, m.GetCrmDetails(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSignupTypeMarketplaceValidator = func() *ValidateSignupTypeMarketplace {
	v := &ValidateSignupTypeMarketplace{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCrmDetails := v.CrmDetailsValidationRuleHandler
	rulesCrmDetails := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhCrmDetails(rulesCrmDetails)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SignupTypeMarketplace.crm_details: %s", err)
		panic(errMsg)
	}
	v.FldValidators["crm_details"] = vFn

	return v
}()

func SignupTypeMarketplaceValidator() db.Validator {
	return DefaultSignupTypeMarketplaceValidator
}

// augmented methods on protoc/std generated struct

func (m *SignupTypeMsp) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SignupTypeMsp) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SignupTypeMsp) DeepCopy() *SignupTypeMsp {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SignupTypeMsp{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SignupTypeMsp) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SignupTypeMsp) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SignupTypeMspValidator().Validate(ctx, m, opts...)
}

type ValidateSignupTypeMsp struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSignupTypeMsp) ChildTenantObjNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for child_tenant_obj_name")
	}

	return validatorFn, nil
}

func (v *ValidateSignupTypeMsp) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SignupTypeMsp)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SignupTypeMsp got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["child_tenant_obj_name"]; exists {

		vOpts := append(opts, db.WithValidateField("child_tenant_obj_name"))
		if err := fv(ctx, m.GetChildTenantObjName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["crm_details"]; exists {

		vOpts := append(opts, db.WithValidateField("crm_details"))
		if err := fv(ctx, m.GetCrmDetails(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSignupTypeMspValidator = func() *ValidateSignupTypeMsp {
	v := &ValidateSignupTypeMsp{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChildTenantObjName := v.ChildTenantObjNameValidationRuleHandler
	rulesChildTenantObjName := map[string]string{
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFn, err = vrhChildTenantObjName(rulesChildTenantObjName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SignupTypeMsp.child_tenant_obj_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["child_tenant_obj_name"] = vFn

	v.FldValidators["crm_details"] = ves_io_schema.CRMInfoValidator().Validate

	return v
}()

func SignupTypeMspValidator() db.Validator {
	return DefaultSignupTypeMspValidator
}

// augmented methods on protoc/std generated struct

func (m *SignupTypePlanTransition) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SignupTypePlanTransition) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SignupTypePlanTransition) DeepCopy() *SignupTypePlanTransition {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SignupTypePlanTransition{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SignupTypePlanTransition) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SignupTypePlanTransition) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SignupTypePlanTransitionValidator().Validate(ctx, m, opts...)
}

type ValidateSignupTypePlanTransition struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSignupTypePlanTransition) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SignupTypePlanTransition)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SignupTypePlanTransition got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["is_sso_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("is_sso_enabled"))
		if err := fv(ctx, m.GetIsSsoEnabled(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSignupTypePlanTransitionValidator = func() *ValidateSignupTypePlanTransition {
	v := &ValidateSignupTypePlanTransition{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SignupTypePlanTransitionValidator() db.Validator {
	return DefaultSignupTypePlanTransitionValidator
}

// augmented methods on protoc/std generated struct

func (m *SignupTypePublic) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SignupTypePublic) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SignupTypePublic) DeepCopy() *SignupTypePublic {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SignupTypePublic{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SignupTypePublic) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SignupTypePublic) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SignupTypePublicValidator().Validate(ctx, m, opts...)
}

type ValidateSignupTypePublic struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSignupTypePublic) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SignupTypePublic)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SignupTypePublic got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSignupTypePublicValidator = func() *ValidateSignupTypePublic {
	v := &ValidateSignupTypePublic{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SignupTypePublicValidator() db.Validator {
	return DefaultSignupTypePublicValidator
}

// augmented methods on protoc/std generated struct

func (m *UserMeta) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UserMeta) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UserMeta) DeepCopy() *UserMeta {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UserMeta{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UserMeta) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UserMeta) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UserMetaValidator().Validate(ctx, m, opts...)
}

type ValidateUserMeta struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUserMeta) FirstNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for first_name")
	}

	return validatorFn, nil
}

func (v *ValidateUserMeta) LastNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for last_name")
	}

	return validatorFn, nil
}

func (v *ValidateUserMeta) EmailValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for email")
	}

	return validatorFn, nil
}

func (v *ValidateUserMeta) ContactNumberValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for contact_number")
	}

	return validatorFn, nil
}

func (v *ValidateUserMeta) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UserMeta)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UserMeta got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["contact_number"]; exists {

		vOpts := append(opts, db.WithValidateField("contact_number"))
		if err := fv(ctx, m.GetContactNumber(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["email"]; exists {

		vOpts := append(opts, db.WithValidateField("email"))
		if err := fv(ctx, m.GetEmail(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["first_name"]; exists {

		vOpts := append(opts, db.WithValidateField("first_name"))
		if err := fv(ctx, m.GetFirstName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["last_name"]; exists {

		vOpts := append(opts, db.WithValidateField("last_name"))
		if err := fv(ctx, m.GetLastName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUserMetaValidator = func() *ValidateUserMeta {
	v := &ValidateUserMeta{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhFirstName := v.FirstNameValidationRuleHandler
	rulesFirstName := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhFirstName(rulesFirstName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UserMeta.first_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["first_name"] = vFn

	vrhLastName := v.LastNameValidationRuleHandler
	rulesLastName := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhLastName(rulesLastName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UserMeta.last_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["last_name"] = vFn

	vrhEmail := v.EmailValidationRuleHandler
	rulesEmail := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhEmail(rulesEmail)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UserMeta.email: %s", err)
		panic(errMsg)
	}
	v.FldValidators["email"] = vFn

	vrhContactNumber := v.ContactNumberValidationRuleHandler
	rulesContactNumber := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhContactNumber(rulesContactNumber)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UserMeta.contact_number: %s", err)
		panic(errMsg)
	}
	v.FldValidators["contact_number"] = vFn

	return v
}()

func UserMetaValidator() db.Validator {
	return DefaultUserMetaValidator
}
