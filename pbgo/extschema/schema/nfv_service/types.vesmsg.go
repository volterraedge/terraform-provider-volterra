// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package nfv_service

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *BigIqInstanceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BigIqInstanceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *BigIqInstanceType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetPassword().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting BigIqInstanceType.password")
	}

	return nil
}

func (m *BigIqInstanceType) DeepCopy() *BigIqInstanceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BigIqInstanceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BigIqInstanceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BigIqInstanceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BigIqInstanceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateBigIqInstanceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBigIqInstanceType) UsernameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for username")
	}

	return validatorFn, nil
}

func (v *ValidateBigIqInstanceType) PasswordValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for password")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.SecretTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateBigIqInstanceType) LicensePoolNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for license_pool_name")
	}

	return validatorFn, nil
}

func (v *ValidateBigIqInstanceType) SkuNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for sku_name")
	}

	return validatorFn, nil
}

func (v *ValidateBigIqInstanceType) LicenseServerIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for license_server_ip")
	}

	return validatorFn, nil
}

func (v *ValidateBigIqInstanceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BigIqInstanceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BigIqInstanceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["license_pool_name"]; exists {

		vOpts := append(opts, db.WithValidateField("license_pool_name"))
		if err := fv(ctx, m.GetLicensePoolName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["license_server_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("license_server_ip"))
		if err := fv(ctx, m.GetLicenseServerIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["password"]; exists {

		vOpts := append(opts, db.WithValidateField("password"))
		if err := fv(ctx, m.GetPassword(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sku_name"]; exists {

		vOpts := append(opts, db.WithValidateField("sku_name"))
		if err := fv(ctx, m.GetSkuName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["username"]; exists {

		vOpts := append(opts, db.WithValidateField("username"))
		if err := fv(ctx, m.GetUsername(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBigIqInstanceTypeValidator = func() *ValidateBigIqInstanceType {
	v := &ValidateBigIqInstanceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhUsername := v.UsernameValidationRuleHandler
	rulesUsername := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhUsername(rulesUsername)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BigIqInstanceType.username: %s", err)
		panic(errMsg)
	}
	v.FldValidators["username"] = vFn

	vrhPassword := v.PasswordValidationRuleHandler
	rulesPassword := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPassword(rulesPassword)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BigIqInstanceType.password: %s", err)
		panic(errMsg)
	}
	v.FldValidators["password"] = vFn

	vrhLicensePoolName := v.LicensePoolNameValidationRuleHandler
	rulesLicensePoolName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhLicensePoolName(rulesLicensePoolName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BigIqInstanceType.license_pool_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["license_pool_name"] = vFn

	vrhSkuName := v.SkuNameValidationRuleHandler
	rulesSkuName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhSkuName(rulesSkuName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BigIqInstanceType.sku_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["sku_name"] = vFn

	vrhLicenseServerIp := v.LicenseServerIpValidationRuleHandler
	rulesLicenseServerIp := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.ip":        "true",
		"ves.io.schema.rules.string.not_in":    "0.0.0.0",
	}
	vFn, err = vrhLicenseServerIp(rulesLicenseServerIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BigIqInstanceType.license_server_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["license_server_ip"] = vFn

	return v
}()

func BigIqInstanceTypeValidator() db.Validator {
	return DefaultBigIqInstanceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *CreateSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetPaloAltoFwService().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.palo_alto_fw_service")
	}

	if err := m.GetHttpsManagement().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.https_management")
	}

	if err := m.GetF5BigIpAwsService().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.f5_big_ip_aws_service")
	}

	return nil
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *CreateSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetHttpManagementChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetHttpManagementChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetServiceProviderChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetServiceProviderChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetSshManagementChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetSshManagementChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetHttpManagementChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetHttpManagementChoice() == nil {
		return nil, nil
	}
	switch m.GetHttpManagementChoice().(type) {
	case *CreateSpecType_DisableHttpsManagement:

		return nil, nil

	case *CreateSpecType_HttpsManagement:
		drInfos, err := m.GetHttpsManagement().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetHttpsManagement().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "https_management." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetServiceProviderChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetServiceProviderChoice() == nil {
		return nil, nil
	}
	switch m.GetServiceProviderChoice().(type) {
	case *CreateSpecType_PaloAltoFwService:
		drInfos, err := m.GetPaloAltoFwService().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetPaloAltoFwService().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "palo_alto_fw_service." + dri.DRField
		}
		return drInfos, err

	case *CreateSpecType_F5BigIpAwsService:
		drInfos, err := m.GetF5BigIpAwsService().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetF5BigIpAwsService().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "f5_big_ip_aws_service." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetSshManagementChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetSshManagementChoice() == nil {
		return nil, nil
	}
	switch m.GetSshManagementChoice().(type) {
	case *CreateSpecType_DisableSshAccess:

		return nil, nil

	case *CreateSpecType_EnabledSshAccess:
		drInfos, err := m.GetEnabledSshAccess().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetEnabledSshAccess().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "enabled_ssh_access." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) HttpManagementChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for http_management_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) ServiceProviderChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for service_provider_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) SshManagementChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ssh_management_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["http_management_choice"]; exists {
		val := m.GetHttpManagementChoice()
		vOpts := append(opts,
			db.WithValidateField("http_management_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetHttpManagementChoice().(type) {
	case *CreateSpecType_DisableHttpsManagement:
		if fv, exists := v.FldValidators["http_management_choice.disable_https_management"]; exists {
			val := m.GetHttpManagementChoice().(*CreateSpecType_DisableHttpsManagement).DisableHttpsManagement
			vOpts := append(opts,
				db.WithValidateField("http_management_choice"),
				db.WithValidateField("disable_https_management"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_HttpsManagement:
		if fv, exists := v.FldValidators["http_management_choice.https_management"]; exists {
			val := m.GetHttpManagementChoice().(*CreateSpecType_HttpsManagement).HttpsManagement
			vOpts := append(opts,
				db.WithValidateField("http_management_choice"),
				db.WithValidateField("https_management"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["service_provider_choice"]; exists {
		val := m.GetServiceProviderChoice()
		vOpts := append(opts,
			db.WithValidateField("service_provider_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetServiceProviderChoice().(type) {
	case *CreateSpecType_PaloAltoFwService:
		if fv, exists := v.FldValidators["service_provider_choice.palo_alto_fw_service"]; exists {
			val := m.GetServiceProviderChoice().(*CreateSpecType_PaloAltoFwService).PaloAltoFwService
			vOpts := append(opts,
				db.WithValidateField("service_provider_choice"),
				db.WithValidateField("palo_alto_fw_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_F5BigIpAwsService:
		if fv, exists := v.FldValidators["service_provider_choice.f5_big_ip_aws_service"]; exists {
			val := m.GetServiceProviderChoice().(*CreateSpecType_F5BigIpAwsService).F5BigIpAwsService
			vOpts := append(opts,
				db.WithValidateField("service_provider_choice"),
				db.WithValidateField("f5_big_ip_aws_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["ssh_management_choice"]; exists {
		val := m.GetSshManagementChoice()
		vOpts := append(opts,
			db.WithValidateField("ssh_management_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSshManagementChoice().(type) {
	case *CreateSpecType_DisableSshAccess:
		if fv, exists := v.FldValidators["ssh_management_choice.disable_ssh_access"]; exists {
			val := m.GetSshManagementChoice().(*CreateSpecType_DisableSshAccess).DisableSshAccess
			vOpts := append(opts,
				db.WithValidateField("ssh_management_choice"),
				db.WithValidateField("disable_ssh_access"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_EnabledSshAccess:
		if fv, exists := v.FldValidators["ssh_management_choice.enabled_ssh_access"]; exists {
			val := m.GetSshManagementChoice().(*CreateSpecType_EnabledSshAccess).EnabledSshAccess
			vOpts := append(opts,
				db.WithValidateField("ssh_management_choice"),
				db.WithValidateField("enabled_ssh_access"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHttpManagementChoice := v.HttpManagementChoiceValidationRuleHandler
	rulesHttpManagementChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhHttpManagementChoice(rulesHttpManagementChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.http_management_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["http_management_choice"] = vFn

	vrhServiceProviderChoice := v.ServiceProviderChoiceValidationRuleHandler
	rulesServiceProviderChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhServiceProviderChoice(rulesServiceProviderChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.service_provider_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_provider_choice"] = vFn

	vrhSshManagementChoice := v.SshManagementChoiceValidationRuleHandler
	rulesSshManagementChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSshManagementChoice(rulesSshManagementChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.ssh_management_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ssh_management_choice"] = vFn

	v.FldValidators["http_management_choice.https_management"] = ServiceHttpsManagementTypeValidator().Validate

	v.FldValidators["service_provider_choice.palo_alto_fw_service"] = PaloAltoFWAWSTypeValidator().Validate
	v.FldValidators["service_provider_choice.f5_big_ip_aws_service"] = F5BigIpAWSTypeValidator().Validate

	v.FldValidators["ssh_management_choice.enabled_ssh_access"] = SSHManagementTypeValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *EndpointRefType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *EndpointRefType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *EndpointRefType) DeepCopy() *EndpointRefType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &EndpointRefType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *EndpointRefType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *EndpointRefType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EndpointRefTypeValidator().Validate(ctx, m, opts...)
}

func (m *EndpointRefType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetEndpointDRefInfo()

}

func (m *EndpointRefType) GetEndpointDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetEndpoint()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("EndpointRefType.endpoint[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "endpoint.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "endpoint",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetEndpointDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *EndpointRefType) GetEndpointDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "endpoint.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: endpoint")
	}
	for _, ref := range m.GetEndpoint() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateEndpointRefType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEndpointRefType) NodeNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node_name")
	}

	return validatorFn, nil
}

func (v *ValidateEndpointRefType) EndpointValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for endpoint")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for endpoint")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated endpoint")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items endpoint")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateEndpointRefType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*EndpointRefType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *EndpointRefType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["endpoint"]; exists {
		vOpts := append(opts, db.WithValidateField("endpoint"))
		if err := fv(ctx, m.GetEndpoint(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["node_name"]; exists {

		vOpts := append(opts, db.WithValidateField("node_name"))
		if err := fv(ctx, m.GetNodeName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEndpointRefTypeValidator = func() *ValidateEndpointRefType {
	v := &ValidateEndpointRefType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNodeName := v.NodeNameValidationRuleHandler
	rulesNodeName := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
	}
	vFn, err = vrhNodeName(rulesNodeName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EndpointRefType.node_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["node_name"] = vFn

	vrhEndpoint := v.EndpointValidationRuleHandler
	rulesEndpoint := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhEndpoint(rulesEndpoint)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EndpointRefType.endpoint: %s", err)
		panic(errMsg)
	}
	v.FldValidators["endpoint"] = vFn

	return v
}()

func EndpointRefTypeValidator() db.Validator {
	return DefaultEndpointRefTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *EndpointServiceReplaceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *EndpointServiceReplaceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *EndpointServiceReplaceType) DeepCopy() *EndpointServiceReplaceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &EndpointServiceReplaceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *EndpointServiceReplaceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *EndpointServiceReplaceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EndpointServiceReplaceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateEndpointServiceReplaceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEndpointServiceReplaceType) ExternalVipChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for external_vip_choice")
	}
	return validatorFn, nil
}

func (v *ValidateEndpointServiceReplaceType) TcpPortChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tcp_port_choice")
	}
	return validatorFn, nil
}

func (v *ValidateEndpointServiceReplaceType) UdpPortChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for udp_port_choice")
	}
	return validatorFn, nil
}

func (v *ValidateEndpointServiceReplaceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*EndpointServiceReplaceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *EndpointServiceReplaceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["external_vip_choice"]; exists {
		val := m.GetExternalVipChoice()
		vOpts := append(opts,
			db.WithValidateField("external_vip_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetExternalVipChoice().(type) {
	case *EndpointServiceReplaceType_DisableAdvertiseOnSloIp:
		if fv, exists := v.FldValidators["external_vip_choice.disable_advertise_on_slo_ip"]; exists {
			val := m.GetExternalVipChoice().(*EndpointServiceReplaceType_DisableAdvertiseOnSloIp).DisableAdvertiseOnSloIp
			vOpts := append(opts,
				db.WithValidateField("external_vip_choice"),
				db.WithValidateField("disable_advertise_on_slo_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EndpointServiceReplaceType_AdvertiseOnSloIp:
		if fv, exists := v.FldValidators["external_vip_choice.advertise_on_slo_ip"]; exists {
			val := m.GetExternalVipChoice().(*EndpointServiceReplaceType_AdvertiseOnSloIp).AdvertiseOnSloIp
			vOpts := append(opts,
				db.WithValidateField("external_vip_choice"),
				db.WithValidateField("advertise_on_slo_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EndpointServiceReplaceType_AdvertiseOnSloIpExternal:
		if fv, exists := v.FldValidators["external_vip_choice.advertise_on_slo_ip_external"]; exists {
			val := m.GetExternalVipChoice().(*EndpointServiceReplaceType_AdvertiseOnSloIpExternal).AdvertiseOnSloIpExternal
			vOpts := append(opts,
				db.WithValidateField("external_vip_choice"),
				db.WithValidateField("advertise_on_slo_ip_external"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tcp_port_choice"]; exists {
		val := m.GetTcpPortChoice()
		vOpts := append(opts,
			db.WithValidateField("tcp_port_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetTcpPortChoice().(type) {
	case *EndpointServiceReplaceType_DefaultTcpPorts:
		if fv, exists := v.FldValidators["tcp_port_choice.default_tcp_ports"]; exists {
			val := m.GetTcpPortChoice().(*EndpointServiceReplaceType_DefaultTcpPorts).DefaultTcpPorts
			vOpts := append(opts,
				db.WithValidateField("tcp_port_choice"),
				db.WithValidateField("default_tcp_ports"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EndpointServiceReplaceType_HttpPort:
		if fv, exists := v.FldValidators["tcp_port_choice.http_port"]; exists {
			val := m.GetTcpPortChoice().(*EndpointServiceReplaceType_HttpPort).HttpPort
			vOpts := append(opts,
				db.WithValidateField("tcp_port_choice"),
				db.WithValidateField("http_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EndpointServiceReplaceType_HttpsPort:
		if fv, exists := v.FldValidators["tcp_port_choice.https_port"]; exists {
			val := m.GetTcpPortChoice().(*EndpointServiceReplaceType_HttpsPort).HttpsPort
			vOpts := append(opts,
				db.WithValidateField("tcp_port_choice"),
				db.WithValidateField("https_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EndpointServiceReplaceType_CustomTcpPorts:
		if fv, exists := v.FldValidators["tcp_port_choice.custom_tcp_ports"]; exists {
			val := m.GetTcpPortChoice().(*EndpointServiceReplaceType_CustomTcpPorts).CustomTcpPorts
			vOpts := append(opts,
				db.WithValidateField("tcp_port_choice"),
				db.WithValidateField("custom_tcp_ports"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EndpointServiceReplaceType_NoTcpPorts:
		if fv, exists := v.FldValidators["tcp_port_choice.no_tcp_ports"]; exists {
			val := m.GetTcpPortChoice().(*EndpointServiceReplaceType_NoTcpPorts).NoTcpPorts
			vOpts := append(opts,
				db.WithValidateField("tcp_port_choice"),
				db.WithValidateField("no_tcp_ports"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["udp_port_choice"]; exists {
		val := m.GetUdpPortChoice()
		vOpts := append(opts,
			db.WithValidateField("udp_port_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetUdpPortChoice().(type) {
	case *EndpointServiceReplaceType_NoUdpPorts:
		if fv, exists := v.FldValidators["udp_port_choice.no_udp_ports"]; exists {
			val := m.GetUdpPortChoice().(*EndpointServiceReplaceType_NoUdpPorts).NoUdpPorts
			vOpts := append(opts,
				db.WithValidateField("udp_port_choice"),
				db.WithValidateField("no_udp_ports"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EndpointServiceReplaceType_CustomUdpPorts:
		if fv, exists := v.FldValidators["udp_port_choice.custom_udp_ports"]; exists {
			val := m.GetUdpPortChoice().(*EndpointServiceReplaceType_CustomUdpPorts).CustomUdpPorts
			vOpts := append(opts,
				db.WithValidateField("udp_port_choice"),
				db.WithValidateField("custom_udp_ports"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEndpointServiceReplaceTypeValidator = func() *ValidateEndpointServiceReplaceType {
	v := &ValidateEndpointServiceReplaceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhExternalVipChoice := v.ExternalVipChoiceValidationRuleHandler
	rulesExternalVipChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhExternalVipChoice(rulesExternalVipChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EndpointServiceReplaceType.external_vip_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["external_vip_choice"] = vFn

	vrhTcpPortChoice := v.TcpPortChoiceValidationRuleHandler
	rulesTcpPortChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhTcpPortChoice(rulesTcpPortChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EndpointServiceReplaceType.tcp_port_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tcp_port_choice"] = vFn

	vrhUdpPortChoice := v.UdpPortChoiceValidationRuleHandler
	rulesUdpPortChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhUdpPortChoice(rulesUdpPortChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EndpointServiceReplaceType.udp_port_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["udp_port_choice"] = vFn

	v.FldValidators["tcp_port_choice.custom_tcp_ports"] = ves_io_schema.PortRangesTypeValidator().Validate

	v.FldValidators["udp_port_choice.custom_udp_ports"] = ves_io_schema.PortRangesTypeValidator().Validate

	return v
}()

func EndpointServiceReplaceTypeValidator() db.Validator {
	return DefaultEndpointServiceReplaceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *EndpointServiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *EndpointServiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *EndpointServiceType) DeepCopy() *EndpointServiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &EndpointServiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *EndpointServiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *EndpointServiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EndpointServiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateEndpointServiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEndpointServiceType) ExternalVipChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for external_vip_choice")
	}
	return validatorFn, nil
}

func (v *ValidateEndpointServiceType) InsideVipChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_vip_choice")
	}
	return validatorFn, nil
}

func (v *ValidateEndpointServiceType) InsideVipChoiceConfiguredVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ConfiguredVip, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for configured_vip")
	}
	return oValidatorFn_ConfiguredVip, nil
}

func (v *ValidateEndpointServiceType) TcpPortChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tcp_port_choice")
	}
	return validatorFn, nil
}

func (v *ValidateEndpointServiceType) UdpPortChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for udp_port_choice")
	}
	return validatorFn, nil
}

func (v *ValidateEndpointServiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*EndpointServiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *EndpointServiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["external_vip_choice"]; exists {
		val := m.GetExternalVipChoice()
		vOpts := append(opts,
			db.WithValidateField("external_vip_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetExternalVipChoice().(type) {
	case *EndpointServiceType_DisableAdvertiseOnSloIp:
		if fv, exists := v.FldValidators["external_vip_choice.disable_advertise_on_slo_ip"]; exists {
			val := m.GetExternalVipChoice().(*EndpointServiceType_DisableAdvertiseOnSloIp).DisableAdvertiseOnSloIp
			vOpts := append(opts,
				db.WithValidateField("external_vip_choice"),
				db.WithValidateField("disable_advertise_on_slo_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EndpointServiceType_AdvertiseOnSloIp:
		if fv, exists := v.FldValidators["external_vip_choice.advertise_on_slo_ip"]; exists {
			val := m.GetExternalVipChoice().(*EndpointServiceType_AdvertiseOnSloIp).AdvertiseOnSloIp
			vOpts := append(opts,
				db.WithValidateField("external_vip_choice"),
				db.WithValidateField("advertise_on_slo_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EndpointServiceType_AdvertiseOnSloIpExternal:
		if fv, exists := v.FldValidators["external_vip_choice.advertise_on_slo_ip_external"]; exists {
			val := m.GetExternalVipChoice().(*EndpointServiceType_AdvertiseOnSloIpExternal).AdvertiseOnSloIpExternal
			vOpts := append(opts,
				db.WithValidateField("external_vip_choice"),
				db.WithValidateField("advertise_on_slo_ip_external"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["inside_vip_choice"]; exists {
		val := m.GetInsideVipChoice()
		vOpts := append(opts,
			db.WithValidateField("inside_vip_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetInsideVipChoice().(type) {
	case *EndpointServiceType_AutomaticVip:
		if fv, exists := v.FldValidators["inside_vip_choice.automatic_vip"]; exists {
			val := m.GetInsideVipChoice().(*EndpointServiceType_AutomaticVip).AutomaticVip
			vOpts := append(opts,
				db.WithValidateField("inside_vip_choice"),
				db.WithValidateField("automatic_vip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EndpointServiceType_ConfiguredVip:
		if fv, exists := v.FldValidators["inside_vip_choice.configured_vip"]; exists {
			val := m.GetInsideVipChoice().(*EndpointServiceType_ConfiguredVip).ConfiguredVip
			vOpts := append(opts,
				db.WithValidateField("inside_vip_choice"),
				db.WithValidateField("configured_vip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tcp_port_choice"]; exists {
		val := m.GetTcpPortChoice()
		vOpts := append(opts,
			db.WithValidateField("tcp_port_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetTcpPortChoice().(type) {
	case *EndpointServiceType_DefaultTcpPorts:
		if fv, exists := v.FldValidators["tcp_port_choice.default_tcp_ports"]; exists {
			val := m.GetTcpPortChoice().(*EndpointServiceType_DefaultTcpPorts).DefaultTcpPorts
			vOpts := append(opts,
				db.WithValidateField("tcp_port_choice"),
				db.WithValidateField("default_tcp_ports"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EndpointServiceType_HttpPort:
		if fv, exists := v.FldValidators["tcp_port_choice.http_port"]; exists {
			val := m.GetTcpPortChoice().(*EndpointServiceType_HttpPort).HttpPort
			vOpts := append(opts,
				db.WithValidateField("tcp_port_choice"),
				db.WithValidateField("http_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EndpointServiceType_HttpsPort:
		if fv, exists := v.FldValidators["tcp_port_choice.https_port"]; exists {
			val := m.GetTcpPortChoice().(*EndpointServiceType_HttpsPort).HttpsPort
			vOpts := append(opts,
				db.WithValidateField("tcp_port_choice"),
				db.WithValidateField("https_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EndpointServiceType_CustomTcpPorts:
		if fv, exists := v.FldValidators["tcp_port_choice.custom_tcp_ports"]; exists {
			val := m.GetTcpPortChoice().(*EndpointServiceType_CustomTcpPorts).CustomTcpPorts
			vOpts := append(opts,
				db.WithValidateField("tcp_port_choice"),
				db.WithValidateField("custom_tcp_ports"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EndpointServiceType_NoTcpPorts:
		if fv, exists := v.FldValidators["tcp_port_choice.no_tcp_ports"]; exists {
			val := m.GetTcpPortChoice().(*EndpointServiceType_NoTcpPorts).NoTcpPorts
			vOpts := append(opts,
				db.WithValidateField("tcp_port_choice"),
				db.WithValidateField("no_tcp_ports"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["udp_port_choice"]; exists {
		val := m.GetUdpPortChoice()
		vOpts := append(opts,
			db.WithValidateField("udp_port_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetUdpPortChoice().(type) {
	case *EndpointServiceType_NoUdpPorts:
		if fv, exists := v.FldValidators["udp_port_choice.no_udp_ports"]; exists {
			val := m.GetUdpPortChoice().(*EndpointServiceType_NoUdpPorts).NoUdpPorts
			vOpts := append(opts,
				db.WithValidateField("udp_port_choice"),
				db.WithValidateField("no_udp_ports"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EndpointServiceType_CustomUdpPorts:
		if fv, exists := v.FldValidators["udp_port_choice.custom_udp_ports"]; exists {
			val := m.GetUdpPortChoice().(*EndpointServiceType_CustomUdpPorts).CustomUdpPorts
			vOpts := append(opts,
				db.WithValidateField("udp_port_choice"),
				db.WithValidateField("custom_udp_ports"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEndpointServiceTypeValidator = func() *ValidateEndpointServiceType {
	v := &ValidateEndpointServiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhExternalVipChoice := v.ExternalVipChoiceValidationRuleHandler
	rulesExternalVipChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhExternalVipChoice(rulesExternalVipChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EndpointServiceType.external_vip_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["external_vip_choice"] = vFn

	vrhInsideVipChoice := v.InsideVipChoiceValidationRuleHandler
	rulesInsideVipChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhInsideVipChoice(rulesInsideVipChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EndpointServiceType.inside_vip_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_vip_choice"] = vFn

	vrhInsideVipChoiceConfiguredVip := v.InsideVipChoiceConfiguredVipValidationRuleHandler
	rulesInsideVipChoiceConfiguredVip := map[string]string{
		"ves.io.schema.rules.string.ip":     "true",
		"ves.io.schema.rules.string.not_in": "0.0.0.0",
	}
	vFnMap["inside_vip_choice.configured_vip"], err = vrhInsideVipChoiceConfiguredVip(rulesInsideVipChoiceConfiguredVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field EndpointServiceType.inside_vip_choice_configured_vip: %s", err)
		panic(errMsg)
	}

	v.FldValidators["inside_vip_choice.configured_vip"] = vFnMap["inside_vip_choice.configured_vip"]

	vrhTcpPortChoice := v.TcpPortChoiceValidationRuleHandler
	rulesTcpPortChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhTcpPortChoice(rulesTcpPortChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EndpointServiceType.tcp_port_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tcp_port_choice"] = vFn

	vrhUdpPortChoice := v.UdpPortChoiceValidationRuleHandler
	rulesUdpPortChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhUdpPortChoice(rulesUdpPortChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EndpointServiceType.udp_port_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["udp_port_choice"] = vFn

	v.FldValidators["tcp_port_choice.custom_tcp_ports"] = ves_io_schema.PortRangesTypeValidator().Validate

	v.FldValidators["udp_port_choice.custom_udp_ports"] = ves_io_schema.PortRangesTypeValidator().Validate

	return v
}()

func EndpointServiceTypeValidator() db.Validator {
	return DefaultEndpointServiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ExternalNLBInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ExternalNLBInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ExternalNLBInfo) DeepCopy() *ExternalNLBInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ExternalNLBInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ExternalNLBInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ExternalNLBInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ExternalNLBInfoValidator().Validate(ctx, m, opts...)
}

type ValidateExternalNLBInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateExternalNLBInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ExternalNLBInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ExternalNLBInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aws_subnet_info"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_subnet_info"))
		for idx, item := range m.GetAwsSubnetInfo() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["region"]; exists {

		vOpts := append(opts, db.WithValidateField("region"))
		if err := fv(ctx, m.GetRegion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vpc_id"]; exists {

		vOpts := append(opts, db.WithValidateField("vpc_id"))
		if err := fv(ctx, m.GetVpcId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultExternalNLBInfoValidator = func() *ValidateExternalNLBInfo {
	v := &ValidateExternalNLBInfo{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ExternalNLBInfoValidator() db.Validator {
	return DefaultExternalNLBInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *F5BigIpAWSBYOLImageType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *F5BigIpAWSBYOLImageType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *F5BigIpAWSBYOLImageType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetLicense().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting F5BigIpAWSBYOLImageType.license")
	}

	return nil
}

func (m *F5BigIpAWSBYOLImageType) DeepCopy() *F5BigIpAWSBYOLImageType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &F5BigIpAWSBYOLImageType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *F5BigIpAWSBYOLImageType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *F5BigIpAWSBYOLImageType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return F5BigIpAWSBYOLImageTypeValidator().Validate(ctx, m, opts...)
}

type ValidateF5BigIpAWSBYOLImageType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateF5BigIpAWSBYOLImageType) ImageValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for image")
	}

	return validatorFn, nil
}

func (v *ValidateF5BigIpAWSBYOLImageType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*F5BigIpAWSBYOLImageType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *F5BigIpAWSBYOLImageType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["image"]; exists {

		vOpts := append(opts, db.WithValidateField("image"))
		if err := fv(ctx, m.GetImage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["license"]; exists {

		vOpts := append(opts, db.WithValidateField("license"))
		if err := fv(ctx, m.GetLicense(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultF5BigIpAWSBYOLImageTypeValidator = func() *ValidateF5BigIpAWSBYOLImageType {
	v := &ValidateF5BigIpAWSBYOLImageType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhImage := v.ImageValidationRuleHandler
	rulesImage := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.in":        "[\"image1\",\"image2\"]",
	}
	vFn, err = vrhImage(rulesImage)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for F5BigIpAWSBYOLImageType.image: %s", err)
		panic(errMsg)
	}
	v.FldValidators["image"] = vFn

	v.FldValidators["license"] = ves_io_schema.SecretTypeValidator().Validate

	return v
}()

func F5BigIpAWSBYOLImageTypeValidator() db.Validator {
	return DefaultF5BigIpAWSBYOLImageTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *F5BigIpAWSMarketPlaceImageType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *F5BigIpAWSMarketPlaceImageType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *F5BigIpAWSMarketPlaceImageType) DeepCopy() *F5BigIpAWSMarketPlaceImageType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &F5BigIpAWSMarketPlaceImageType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *F5BigIpAWSMarketPlaceImageType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *F5BigIpAWSMarketPlaceImageType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return F5BigIpAWSMarketPlaceImageTypeValidator().Validate(ctx, m, opts...)
}

type ValidateF5BigIpAWSMarketPlaceImageType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateF5BigIpAWSMarketPlaceImageType) AmiChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ami_choice")
	}
	return validatorFn, nil
}

func (v *ValidateF5BigIpAWSMarketPlaceImageType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*F5BigIpAWSMarketPlaceImageType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *F5BigIpAWSMarketPlaceImageType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ami_choice"]; exists {
		val := m.GetAmiChoice()
		vOpts := append(opts,
			db.WithValidateField("ami_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAmiChoice().(type) {
	case *F5BigIpAWSMarketPlaceImageType_AWAFPayG200Mbps:
		if fv, exists := v.FldValidators["ami_choice.AWAFPayG200Mbps"]; exists {
			val := m.GetAmiChoice().(*F5BigIpAWSMarketPlaceImageType_AWAFPayG200Mbps).AWAFPayG200Mbps
			vOpts := append(opts,
				db.WithValidateField("ami_choice"),
				db.WithValidateField("AWAFPayG200Mbps"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *F5BigIpAWSMarketPlaceImageType_AWAFPayG3Gbps:
		if fv, exists := v.FldValidators["ami_choice.AWAFPayG3Gbps"]; exists {
			val := m.GetAmiChoice().(*F5BigIpAWSMarketPlaceImageType_AWAFPayG3Gbps).AWAFPayG3Gbps
			vOpts := append(opts,
				db.WithValidateField("ami_choice"),
				db.WithValidateField("AWAFPayG3Gbps"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *F5BigIpAWSMarketPlaceImageType_BestPlusPayG200Mbps:
		if fv, exists := v.FldValidators["ami_choice.BestPlusPayG200Mbps"]; exists {
			val := m.GetAmiChoice().(*F5BigIpAWSMarketPlaceImageType_BestPlusPayG200Mbps).BestPlusPayG200Mbps
			vOpts := append(opts,
				db.WithValidateField("ami_choice"),
				db.WithValidateField("BestPlusPayG200Mbps"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *F5BigIpAWSMarketPlaceImageType_BestPlusPayg_1Gbps:
		if fv, exists := v.FldValidators["ami_choice.best_plus_payg_1gbps"]; exists {
			val := m.GetAmiChoice().(*F5BigIpAWSMarketPlaceImageType_BestPlusPayg_1Gbps).BestPlusPayg_1Gbps
			vOpts := append(opts,
				db.WithValidateField("ami_choice"),
				db.WithValidateField("best_plus_payg_1gbps"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultF5BigIpAWSMarketPlaceImageTypeValidator = func() *ValidateF5BigIpAWSMarketPlaceImageType {
	v := &ValidateF5BigIpAWSMarketPlaceImageType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAmiChoice := v.AmiChoiceValidationRuleHandler
	rulesAmiChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAmiChoice(rulesAmiChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for F5BigIpAWSMarketPlaceImageType.ami_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ami_choice"] = vFn

	return v
}()

func F5BigIpAWSMarketPlaceImageTypeValidator() db.Validator {
	return DefaultF5BigIpAWSMarketPlaceImageTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *F5BigIpAWSReplaceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *F5BigIpAWSReplaceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *F5BigIpAWSReplaceType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	return nil
}

func (m *F5BigIpAWSReplaceType) DeepCopy() *F5BigIpAWSReplaceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &F5BigIpAWSReplaceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *F5BigIpAWSReplaceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *F5BigIpAWSReplaceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return F5BigIpAWSReplaceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateF5BigIpAWSReplaceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateF5BigIpAWSReplaceType) TagsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for tags")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for tags")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for tags")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map tags")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items tags")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateF5BigIpAWSReplaceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*F5BigIpAWSReplaceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *F5BigIpAWSReplaceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["endpoint_service"]; exists {

		vOpts := append(opts, db.WithValidateField("endpoint_service"))
		if err := fv(ctx, m.GetEndpointService(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tags"]; exists {
		vOpts := append(opts, db.WithValidateField("tags"))
		if err := fv(ctx, m.GetTags(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultF5BigIpAWSReplaceTypeValidator = func() *ValidateF5BigIpAWSReplaceType {
	v := &ValidateF5BigIpAWSReplaceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTags := v.TagsValidationRuleHandler
	rulesTags := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len":   "127",
		"ves.io.schema.rules.map.max_pairs":             "40",
		"ves.io.schema.rules.map.values.string.max_len": "255",
	}
	vFn, err = vrhTags(rulesTags)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for F5BigIpAWSReplaceType.tags: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tags"] = vFn

	v.FldValidators["endpoint_service"] = EndpointServiceReplaceTypeValidator().Validate

	return v
}()

func F5BigIpAWSReplaceTypeValidator() db.Validator {
	return DefaultF5BigIpAWSReplaceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *F5BigIpAWSTGWSiteType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *F5BigIpAWSTGWSiteType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *F5BigIpAWSTGWSiteType) DeepCopy() *F5BigIpAWSTGWSiteType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &F5BigIpAWSTGWSiteType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *F5BigIpAWSTGWSiteType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *F5BigIpAWSTGWSiteType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return F5BigIpAWSTGWSiteTypeValidator().Validate(ctx, m, opts...)
}

func (m *F5BigIpAWSTGWSiteType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetAwsTgwSiteDRefInfo()

}

func (m *F5BigIpAWSTGWSiteType) GetAwsTgwSiteDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetAwsTgwSite()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("aws_tgw_site.Object")
	dri := db.DRefInfo{
		RefdType:   "aws_tgw_site.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "aws_tgw_site",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetAwsTgwSiteDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *F5BigIpAWSTGWSiteType) GetAwsTgwSiteDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "aws_tgw_site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: aws_tgw_site")
	}

	vref := m.GetAwsTgwSite()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "aws_tgw_site.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateF5BigIpAWSTGWSiteType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateF5BigIpAWSTGWSiteType) AwsTgwSiteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for aws_tgw_site")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateF5BigIpAWSTGWSiteType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*F5BigIpAWSTGWSiteType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *F5BigIpAWSTGWSiteType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aws_tgw_site"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_tgw_site"))
		if err := fv(ctx, m.GetAwsTgwSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultF5BigIpAWSTGWSiteTypeValidator = func() *ValidateF5BigIpAWSTGWSiteType {
	v := &ValidateF5BigIpAWSTGWSiteType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAwsTgwSite := v.AwsTgwSiteValidationRuleHandler
	rulesAwsTgwSite := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAwsTgwSite(rulesAwsTgwSite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for F5BigIpAWSTGWSiteType.aws_tgw_site: %s", err)
		panic(errMsg)
	}
	v.FldValidators["aws_tgw_site"] = vFn

	return v
}()

func F5BigIpAWSTGWSiteTypeValidator() db.Validator {
	return DefaultF5BigIpAWSTGWSiteTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *F5BigIpAWSType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *F5BigIpAWSType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *F5BigIpAWSType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetByolImage().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting F5BigIpAWSType.byol_image")
	}

	if err := m.GetAdminPassword().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting F5BigIpAWSType.admin_password")
	}

	return nil
}

func (m *F5BigIpAWSType) DeepCopy() *F5BigIpAWSType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &F5BigIpAWSType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *F5BigIpAWSType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *F5BigIpAWSType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return F5BigIpAWSTypeValidator().Validate(ctx, m, opts...)
}

func (m *F5BigIpAWSType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetSiteTypeChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *F5BigIpAWSType) GetSiteTypeChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetSiteTypeChoice() == nil {
		return nil, nil
	}
	switch m.GetSiteTypeChoice().(type) {
	case *F5BigIpAWSType_AwsTgwSiteParams:
		drInfos, err := m.GetAwsTgwSiteParams().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAwsTgwSiteParams().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "aws_tgw_site_params." + dri.DRField
		}
		return drInfos, err

	case *F5BigIpAWSType_AwsVpcSiteParams:
		drInfos, err := m.GetAwsVpcSiteParams().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAwsVpcSiteParams().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "aws_vpc_site_params." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateF5BigIpAWSType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateF5BigIpAWSType) ImageChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for image_choice")
	}
	return validatorFn, nil
}

func (v *ValidateF5BigIpAWSType) ImageChoiceByolImageValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	return F5BigIpAWSBYOLImageTypeValidator().Validate, nil
}

func (v *ValidateF5BigIpAWSType) SiteTypeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_type_choice")
	}
	return validatorFn, nil
}

func (v *ValidateF5BigIpAWSType) AdminPasswordValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for admin_password")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.SecretTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateF5BigIpAWSType) SshKeyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ssh_key")
	}

	return validatorFn, nil
}

func (v *ValidateF5BigIpAWSType) NodesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for nodes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ServiceNodesAWSType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ServiceNodesAWSTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for nodes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ServiceNodesAWSType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ServiceNodesAWSType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated nodes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items nodes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateF5BigIpAWSType) AdminUsernameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for admin_username")
	}

	return validatorFn, nil
}

func (v *ValidateF5BigIpAWSType) TagsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for tags")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for tags")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for tags")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map tags")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items tags")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateF5BigIpAWSType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*F5BigIpAWSType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *F5BigIpAWSType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["admin_password"]; exists {

		vOpts := append(opts, db.WithValidateField("admin_password"))
		if err := fv(ctx, m.GetAdminPassword(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["admin_username"]; exists {

		vOpts := append(opts, db.WithValidateField("admin_username"))
		if err := fv(ctx, m.GetAdminUsername(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["endpoint_service"]; exists {

		vOpts := append(opts, db.WithValidateField("endpoint_service"))
		if err := fv(ctx, m.GetEndpointService(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["image_choice"]; exists {
		val := m.GetImageChoice()
		vOpts := append(opts,
			db.WithValidateField("image_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetImageChoice().(type) {
	case *F5BigIpAWSType_ByolImage:
		if fv, exists := v.FldValidators["image_choice.byol_image"]; exists {
			val := m.GetImageChoice().(*F5BigIpAWSType_ByolImage).ByolImage
			vOpts := append(opts,
				db.WithValidateField("image_choice"),
				db.WithValidateField("byol_image"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *F5BigIpAWSType_MarketPlaceImage:
		if fv, exists := v.FldValidators["image_choice.market_place_image"]; exists {
			val := m.GetImageChoice().(*F5BigIpAWSType_MarketPlaceImage).MarketPlaceImage
			vOpts := append(opts,
				db.WithValidateField("image_choice"),
				db.WithValidateField("market_place_image"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["nodes"]; exists {
		vOpts := append(opts, db.WithValidateField("nodes"))
		if err := fv(ctx, m.GetNodes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_type_choice"]; exists {
		val := m.GetSiteTypeChoice()
		vOpts := append(opts,
			db.WithValidateField("site_type_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSiteTypeChoice().(type) {
	case *F5BigIpAWSType_AwsTgwSiteParams:
		if fv, exists := v.FldValidators["site_type_choice.aws_tgw_site_params"]; exists {
			val := m.GetSiteTypeChoice().(*F5BigIpAWSType_AwsTgwSiteParams).AwsTgwSiteParams
			vOpts := append(opts,
				db.WithValidateField("site_type_choice"),
				db.WithValidateField("aws_tgw_site_params"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *F5BigIpAWSType_AwsVpcSiteParams:
		if fv, exists := v.FldValidators["site_type_choice.aws_vpc_site_params"]; exists {
			val := m.GetSiteTypeChoice().(*F5BigIpAWSType_AwsVpcSiteParams).AwsVpcSiteParams
			vOpts := append(opts,
				db.WithValidateField("site_type_choice"),
				db.WithValidateField("aws_vpc_site_params"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["ssh_key"]; exists {

		vOpts := append(opts, db.WithValidateField("ssh_key"))
		if err := fv(ctx, m.GetSshKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tags"]; exists {
		vOpts := append(opts, db.WithValidateField("tags"))
		if err := fv(ctx, m.GetTags(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultF5BigIpAWSTypeValidator = func() *ValidateF5BigIpAWSType {
	v := &ValidateF5BigIpAWSType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhImageChoice := v.ImageChoiceValidationRuleHandler
	rulesImageChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhImageChoice(rulesImageChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for F5BigIpAWSType.image_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["image_choice"] = vFn

	vrhImageChoiceByolImage := v.ImageChoiceByolImageValidationRuleHandler
	rulesImageChoiceByolImage := map[string]string{
		"ves.io.schema.rules.string.in": "[\"image1\",\"image2\"]",
	}
	vFnMap["image_choice.byol_image"], err = vrhImageChoiceByolImage(rulesImageChoiceByolImage)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field F5BigIpAWSType.image_choice_byol_image: %s", err)
		panic(errMsg)
	}

	v.FldValidators["image_choice.byol_image"] = vFnMap["image_choice.byol_image"]

	vrhSiteTypeChoice := v.SiteTypeChoiceValidationRuleHandler
	rulesSiteTypeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSiteTypeChoice(rulesSiteTypeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for F5BigIpAWSType.site_type_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_type_choice"] = vFn

	vrhAdminPassword := v.AdminPasswordValidationRuleHandler
	rulesAdminPassword := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAdminPassword(rulesAdminPassword)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for F5BigIpAWSType.admin_password: %s", err)
		panic(errMsg)
	}
	v.FldValidators["admin_password"] = vFn

	vrhSshKey := v.SshKeyValidationRuleHandler
	rulesSshKey := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "8192",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhSshKey(rulesSshKey)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for F5BigIpAWSType.ssh_key: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ssh_key"] = vFn

	vrhNodes := v.NodesValidationRuleHandler
	rulesNodes := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "2",
		"ves.io.schema.rules.repeated.min_items": "1",
	}
	vFn, err = vrhNodes(rulesNodes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for F5BigIpAWSType.nodes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["nodes"] = vFn

	vrhAdminUsername := v.AdminUsernameValidationRuleHandler
	rulesAdminUsername := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFn, err = vrhAdminUsername(rulesAdminUsername)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for F5BigIpAWSType.admin_username: %s", err)
		panic(errMsg)
	}
	v.FldValidators["admin_username"] = vFn

	vrhTags := v.TagsValidationRuleHandler
	rulesTags := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len":   "127",
		"ves.io.schema.rules.map.max_pairs":             "40",
		"ves.io.schema.rules.map.values.string.max_len": "255",
	}
	vFn, err = vrhTags(rulesTags)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for F5BigIpAWSType.tags: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tags"] = vFn

	v.FldValidators["image_choice.market_place_image"] = F5BigIpAWSMarketPlaceImageTypeValidator().Validate

	v.FldValidators["site_type_choice.aws_tgw_site_params"] = F5BigIpAWSTGWSiteTypeValidator().Validate
	v.FldValidators["site_type_choice.aws_vpc_site_params"] = F5BigIpAWSVPCSiteTypeValidator().Validate

	v.FldValidators["endpoint_service"] = EndpointServiceTypeValidator().Validate

	return v
}()

func F5BigIpAWSTypeValidator() db.Validator {
	return DefaultF5BigIpAWSTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *F5BigIpAWSVPCSiteType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *F5BigIpAWSVPCSiteType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *F5BigIpAWSVPCSiteType) DeepCopy() *F5BigIpAWSVPCSiteType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &F5BigIpAWSVPCSiteType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *F5BigIpAWSVPCSiteType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *F5BigIpAWSVPCSiteType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return F5BigIpAWSVPCSiteTypeValidator().Validate(ctx, m, opts...)
}

func (m *F5BigIpAWSVPCSiteType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetAwsVpcSiteDRefInfo()

}

func (m *F5BigIpAWSVPCSiteType) GetAwsVpcSiteDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetAwsVpcSite()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("aws_vpc_site.Object")
	dri := db.DRefInfo{
		RefdType:   "aws_vpc_site.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "aws_vpc_site",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetAwsVpcSiteDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *F5BigIpAWSVPCSiteType) GetAwsVpcSiteDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "aws_vpc_site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: aws_vpc_site")
	}

	vref := m.GetAwsVpcSite()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "aws_vpc_site.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateF5BigIpAWSVPCSiteType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateF5BigIpAWSVPCSiteType) AwsVpcSiteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for aws_vpc_site")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateF5BigIpAWSVPCSiteType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*F5BigIpAWSVPCSiteType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *F5BigIpAWSVPCSiteType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aws_vpc_site"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_vpc_site"))
		if err := fv(ctx, m.GetAwsVpcSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultF5BigIpAWSVPCSiteTypeValidator = func() *ValidateF5BigIpAWSVPCSiteType {
	v := &ValidateF5BigIpAWSVPCSiteType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAwsVpcSite := v.AwsVpcSiteValidationRuleHandler
	rulesAwsVpcSite := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAwsVpcSite(rulesAwsVpcSite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for F5BigIpAWSVPCSiteType.aws_vpc_site: %s", err)
		panic(errMsg)
	}
	v.FldValidators["aws_vpc_site"] = vFn

	return v
}()

func F5BigIpAWSVPCSiteTypeValidator() db.Validator {
	return DefaultF5BigIpAWSVPCSiteTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *F5BigIpAppStackBareMetalType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *F5BigIpAppStackBareMetalType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *F5BigIpAppStackBareMetalType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetAdminPassword().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting F5BigIpAppStackBareMetalType.admin_password")
	}

	if err := m.GetBigiqInstance().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting F5BigIpAppStackBareMetalType.bigiq_instance")
	}

	return nil
}

func (m *F5BigIpAppStackBareMetalType) DeepCopy() *F5BigIpAppStackBareMetalType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &F5BigIpAppStackBareMetalType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *F5BigIpAppStackBareMetalType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *F5BigIpAppStackBareMetalType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return F5BigIpAppStackBareMetalTypeValidator().Validate(ctx, m, opts...)
}

func (m *F5BigIpAppStackBareMetalType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetBareMetalSiteDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetBareMetalSiteDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetNodesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetNodesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *F5BigIpAppStackBareMetalType) GetBareMetalSiteDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetBareMetalSite()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("voltstack_site.Object")
	dri := db.DRefInfo{
		RefdType:   "voltstack_site.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "bare_metal_site",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetBareMetalSiteDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *F5BigIpAppStackBareMetalType) GetBareMetalSiteDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "voltstack_site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: voltstack_site")
	}

	vref := m.GetBareMetalSite()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "voltstack_site.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *F5BigIpAppStackBareMetalType) GetNodesDRefInfo() ([]db.DRefInfo, error) {
	if m.GetNodes() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetNodes() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetNodes() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("nodes[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateF5BigIpAppStackBareMetalType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateF5BigIpAppStackBareMetalType) AdminUsernameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for admin_username")
	}

	return validatorFn, nil
}

func (v *ValidateF5BigIpAppStackBareMetalType) AdminPasswordValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for admin_password")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.SecretTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateF5BigIpAppStackBareMetalType) SshKeyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ssh_key")
	}

	return validatorFn, nil
}

func (v *ValidateF5BigIpAppStackBareMetalType) NodesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for nodes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ServiceNodesBareMetalType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ServiceNodesBareMetalTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for nodes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ServiceNodesBareMetalType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ServiceNodesBareMetalType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated nodes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items nodes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateF5BigIpAppStackBareMetalType) BareMetalSiteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for bare_metal_site")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateF5BigIpAppStackBareMetalType) PublicDownloadUrlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for public_download_url")
	}

	return validatorFn, nil
}

func (v *ValidateF5BigIpAppStackBareMetalType) BigiqInstanceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for bigiq_instance")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := BigIqInstanceTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateF5BigIpAppStackBareMetalType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*F5BigIpAppStackBareMetalType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *F5BigIpAppStackBareMetalType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["admin_password"]; exists {

		vOpts := append(opts, db.WithValidateField("admin_password"))
		if err := fv(ctx, m.GetAdminPassword(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["admin_username"]; exists {

		vOpts := append(opts, db.WithValidateField("admin_username"))
		if err := fv(ctx, m.GetAdminUsername(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bare_metal_site"]; exists {

		vOpts := append(opts, db.WithValidateField("bare_metal_site"))
		if err := fv(ctx, m.GetBareMetalSite(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bigiq_instance"]; exists {

		vOpts := append(opts, db.WithValidateField("bigiq_instance"))
		if err := fv(ctx, m.GetBigiqInstance(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["nodes"]; exists {
		vOpts := append(opts, db.WithValidateField("nodes"))
		if err := fv(ctx, m.GetNodes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["public_download_url"]; exists {

		vOpts := append(opts, db.WithValidateField("public_download_url"))
		if err := fv(ctx, m.GetPublicDownloadUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ssh_key"]; exists {

		vOpts := append(opts, db.WithValidateField("ssh_key"))
		if err := fv(ctx, m.GetSshKey(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultF5BigIpAppStackBareMetalTypeValidator = func() *ValidateF5BigIpAppStackBareMetalType {
	v := &ValidateF5BigIpAppStackBareMetalType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAdminUsername := v.AdminUsernameValidationRuleHandler
	rulesAdminUsername := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFn, err = vrhAdminUsername(rulesAdminUsername)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for F5BigIpAppStackBareMetalType.admin_username: %s", err)
		panic(errMsg)
	}
	v.FldValidators["admin_username"] = vFn

	vrhAdminPassword := v.AdminPasswordValidationRuleHandler
	rulesAdminPassword := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAdminPassword(rulesAdminPassword)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for F5BigIpAppStackBareMetalType.admin_password: %s", err)
		panic(errMsg)
	}
	v.FldValidators["admin_password"] = vFn

	vrhSshKey := v.SshKeyValidationRuleHandler
	rulesSshKey := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "8192",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhSshKey(rulesSshKey)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for F5BigIpAppStackBareMetalType.ssh_key: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ssh_key"] = vFn

	vrhNodes := v.NodesValidationRuleHandler
	rulesNodes := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "1",
		"ves.io.schema.rules.repeated.min_items": "1",
	}
	vFn, err = vrhNodes(rulesNodes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for F5BigIpAppStackBareMetalType.nodes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["nodes"] = vFn

	vrhBareMetalSite := v.BareMetalSiteValidationRuleHandler
	rulesBareMetalSite := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhBareMetalSite(rulesBareMetalSite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for F5BigIpAppStackBareMetalType.bare_metal_site: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bare_metal_site"] = vFn

	vrhPublicDownloadUrl := v.PublicDownloadUrlValidationRuleHandler
	rulesPublicDownloadUrl := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.uri":       "true",
	}
	vFn, err = vrhPublicDownloadUrl(rulesPublicDownloadUrl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for F5BigIpAppStackBareMetalType.public_download_url: %s", err)
		panic(errMsg)
	}
	v.FldValidators["public_download_url"] = vFn

	vrhBigiqInstance := v.BigiqInstanceValidationRuleHandler
	rulesBigiqInstance := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhBigiqInstance(rulesBigiqInstance)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for F5BigIpAppStackBareMetalType.bigiq_instance: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bigiq_instance"] = vFn

	return v
}()

func F5BigIpAppStackBareMetalTypeValidator() db.Validator {
	return DefaultF5BigIpAppStackBareMetalTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ForwardingServiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ForwardingServiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ForwardingServiceType) DeepCopy() *ForwardingServiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ForwardingServiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ForwardingServiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ForwardingServiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ForwardingServiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateForwardingServiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateForwardingServiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ForwardingServiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ForwardingServiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultForwardingServiceTypeValidator = func() *ValidateForwardingServiceType {
	v := &ValidateForwardingServiceType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ForwardingServiceTypeValidator() db.Validator {
	return DefaultForwardingServiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GetSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetPaloAltoFwService().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.palo_alto_fw_service")
	}

	if err := m.GetHttpsManagement().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.https_management")
	}

	if err := m.GetF5BigIpAwsService().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.f5_big_ip_aws_service")
	}

	return nil
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GetSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetHttpManagementChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetHttpManagementChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetServiceProviderChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetServiceProviderChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetSshManagementChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetSshManagementChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetHttpManagementChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetHttpManagementChoice() == nil {
		return nil, nil
	}
	switch m.GetHttpManagementChoice().(type) {
	case *GetSpecType_DisableHttpsManagement:

		return nil, nil

	case *GetSpecType_HttpsManagement:
		drInfos, err := m.GetHttpsManagement().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetHttpsManagement().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "https_management." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetServiceProviderChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetServiceProviderChoice() == nil {
		return nil, nil
	}
	switch m.GetServiceProviderChoice().(type) {
	case *GetSpecType_PaloAltoFwService:
		drInfos, err := m.GetPaloAltoFwService().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetPaloAltoFwService().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "palo_alto_fw_service." + dri.DRField
		}
		return drInfos, err

	case *GetSpecType_F5BigIpAwsService:
		drInfos, err := m.GetF5BigIpAwsService().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetF5BigIpAwsService().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "f5_big_ip_aws_service." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetSshManagementChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetSshManagementChoice() == nil {
		return nil, nil
	}
	switch m.GetSshManagementChoice().(type) {
	case *GetSpecType_DisableSshAccess:

		return nil, nil

	case *GetSpecType_EnabledSshAccess:
		drInfos, err := m.GetEnabledSshAccess().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetEnabledSshAccess().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "enabled_ssh_access." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) HttpManagementChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for http_management_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) ServiceProviderChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for service_provider_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) ServiceTypeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for service_type_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) SshManagementChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ssh_management_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["commands"]; exists {

		vOpts := append(opts, db.WithValidateField("commands"))
		for idx, item := range m.GetCommands() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["finalizer_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("finalizer_timestamp"))
		if err := fv(ctx, m.GetFinalizerTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["force_delete"]; exists {

		vOpts := append(opts, db.WithValidateField("force_delete"))
		if err := fv(ctx, m.GetForceDelete(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["http_management_choice"]; exists {
		val := m.GetHttpManagementChoice()
		vOpts := append(opts,
			db.WithValidateField("http_management_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetHttpManagementChoice().(type) {
	case *GetSpecType_DisableHttpsManagement:
		if fv, exists := v.FldValidators["http_management_choice.disable_https_management"]; exists {
			val := m.GetHttpManagementChoice().(*GetSpecType_DisableHttpsManagement).DisableHttpsManagement
			vOpts := append(opts,
				db.WithValidateField("http_management_choice"),
				db.WithValidateField("disable_https_management"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_HttpsManagement:
		if fv, exists := v.FldValidators["http_management_choice.https_management"]; exists {
			val := m.GetHttpManagementChoice().(*GetSpecType_HttpsManagement).HttpsManagement
			vOpts := append(opts,
				db.WithValidateField("http_management_choice"),
				db.WithValidateField("https_management"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["service_provider_choice"]; exists {
		val := m.GetServiceProviderChoice()
		vOpts := append(opts,
			db.WithValidateField("service_provider_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetServiceProviderChoice().(type) {
	case *GetSpecType_PaloAltoFwService:
		if fv, exists := v.FldValidators["service_provider_choice.palo_alto_fw_service"]; exists {
			val := m.GetServiceProviderChoice().(*GetSpecType_PaloAltoFwService).PaloAltoFwService
			vOpts := append(opts,
				db.WithValidateField("service_provider_choice"),
				db.WithValidateField("palo_alto_fw_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_F5BigIpAwsService:
		if fv, exists := v.FldValidators["service_provider_choice.f5_big_ip_aws_service"]; exists {
			val := m.GetServiceProviderChoice().(*GetSpecType_F5BigIpAwsService).F5BigIpAwsService
			vOpts := append(opts,
				db.WithValidateField("service_provider_choice"),
				db.WithValidateField("f5_big_ip_aws_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["service_type_choice"]; exists {
		val := m.GetServiceTypeChoice()
		vOpts := append(opts,
			db.WithValidateField("service_type_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetServiceTypeChoice().(type) {
	case *GetSpecType_EndpointService:
		if fv, exists := v.FldValidators["service_type_choice.endpoint_service"]; exists {
			val := m.GetServiceTypeChoice().(*GetSpecType_EndpointService).EndpointService
			vOpts := append(opts,
				db.WithValidateField("service_type_choice"),
				db.WithValidateField("endpoint_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_ForwardingService:
		if fv, exists := v.FldValidators["service_type_choice.forwarding_service"]; exists {
			val := m.GetServiceTypeChoice().(*GetSpecType_ForwardingService).ForwardingService
			vOpts := append(opts,
				db.WithValidateField("service_type_choice"),
				db.WithValidateField("forwarding_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_TransparentService:
		if fv, exists := v.FldValidators["service_type_choice.transparent_service"]; exists {
			val := m.GetServiceTypeChoice().(*GetSpecType_TransparentService).TransparentService
			vOpts := append(opts,
				db.WithValidateField("service_type_choice"),
				db.WithValidateField("transparent_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["ssh_management_choice"]; exists {
		val := m.GetSshManagementChoice()
		vOpts := append(opts,
			db.WithValidateField("ssh_management_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSshManagementChoice().(type) {
	case *GetSpecType_DisableSshAccess:
		if fv, exists := v.FldValidators["ssh_management_choice.disable_ssh_access"]; exists {
			val := m.GetSshManagementChoice().(*GetSpecType_DisableSshAccess).DisableSshAccess
			vOpts := append(opts,
				db.WithValidateField("ssh_management_choice"),
				db.WithValidateField("disable_ssh_access"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_EnabledSshAccess:
		if fv, exists := v.FldValidators["ssh_management_choice.enabled_ssh_access"]; exists {
			val := m.GetSshManagementChoice().(*GetSpecType_EnabledSshAccess).EnabledSshAccess
			vOpts := append(opts,
				db.WithValidateField("ssh_management_choice"),
				db.WithValidateField("enabled_ssh_access"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHttpManagementChoice := v.HttpManagementChoiceValidationRuleHandler
	rulesHttpManagementChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhHttpManagementChoice(rulesHttpManagementChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.http_management_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["http_management_choice"] = vFn

	vrhServiceProviderChoice := v.ServiceProviderChoiceValidationRuleHandler
	rulesServiceProviderChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhServiceProviderChoice(rulesServiceProviderChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.service_provider_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_provider_choice"] = vFn

	vrhServiceTypeChoice := v.ServiceTypeChoiceValidationRuleHandler
	rulesServiceTypeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhServiceTypeChoice(rulesServiceTypeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.service_type_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_type_choice"] = vFn

	vrhSshManagementChoice := v.SshManagementChoiceValidationRuleHandler
	rulesSshManagementChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSshManagementChoice(rulesSshManagementChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.ssh_management_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ssh_management_choice"] = vFn

	v.FldValidators["http_management_choice.https_management"] = ServiceHttpsManagementTypeValidator().Validate

	v.FldValidators["service_provider_choice.palo_alto_fw_service"] = PaloAltoFWAWSTypeValidator().Validate
	v.FldValidators["service_provider_choice.f5_big_ip_aws_service"] = F5BigIpAWSTypeValidator().Validate

	v.FldValidators["service_type_choice.endpoint_service"] = EndpointServiceTypeValidator().Validate

	v.FldValidators["ssh_management_choice.enabled_ssh_access"] = SSHManagementTypeValidator().Validate

	v.FldValidators["commands"] = SuggestedCommandsValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GlobalSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetPaloAltoFwService().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.palo_alto_fw_service")
	}

	if err := m.GetHttpsManagement().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.https_management")
	}

	if err := m.GetF5BigIpAwsService().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.f5_big_ip_aws_service")
	}

	if err := m.GetF5BigIpBareMetalType().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.f5_big_ip_bare_metal_type")
	}

	return nil
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetCloudCredentialsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetCloudCredentialsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetFleetDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetFleetDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetHttpManagementChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetHttpManagementChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetK8SManifestParamsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetK8SManifestParamsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetManagementEndpointRefsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetManagementEndpointRefsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetOriginPoolDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetOriginPoolDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetPolicySetDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetPolicySetDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetServiceProviderChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetServiceProviderChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetSiteRefsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetSiteRefsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetSshManagementChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetSshManagementChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTfParamsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTfParamsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetViewInternalDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetViewInternalDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *GlobalSpecType) GetCloudCredentialsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetCloudCredentials()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.cloud_credentials[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "cloud_credentials.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "cloud_credentials",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetCloudCredentialsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetCloudCredentialsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "cloud_credentials.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: cloud_credentials")
	}
	for _, ref := range m.GetCloudCredentials() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetFleetDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetFleet()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.fleet[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "fleet.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "fleet",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetFleetDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetFleetDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "fleet.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: fleet")
	}
	for _, ref := range m.GetFleet() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetHttpManagementChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetHttpManagementChoice() == nil {
		return nil, nil
	}
	switch m.GetHttpManagementChoice().(type) {
	case *GlobalSpecType_DisableHttpsManagement:

		return nil, nil

	case *GlobalSpecType_HttpsManagement:
		drInfos, err := m.GetHttpsManagement().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetHttpsManagement().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "https_management." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

func (m *GlobalSpecType) GetK8SManifestParamsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetK8SManifestParams()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.k8s_manifest_params[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "k8s_manifest_params.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "k8s_manifest_params",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetK8SManifestParamsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetK8SManifestParamsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "k8s_manifest_params.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: k8s_manifest_params")
	}
	for _, ref := range m.GetK8SManifestParams() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetManagementEndpointRefsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetManagementEndpointRefs() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetManagementEndpointRefs() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetManagementEndpointRefs() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("management_endpoint_refs[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

func (m *GlobalSpecType) GetOriginPoolDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetOriginPool()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.origin_pool[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "origin_pool.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "origin_pool",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetOriginPoolDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetOriginPoolDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "origin_pool.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: origin_pool")
	}
	for _, ref := range m.GetOriginPool() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetPolicySetDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetPolicySet()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.policy_set[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "network_policy_set.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "policy_set",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetPolicySetDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetPolicySetDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "network_policy_set.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: network_policy_set")
	}
	for _, ref := range m.GetPolicySet() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetServiceProviderChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetServiceProviderChoice() == nil {
		return nil, nil
	}
	switch m.GetServiceProviderChoice().(type) {
	case *GlobalSpecType_PaloAltoFwService:
		drInfos, err := m.GetPaloAltoFwService().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetPaloAltoFwService().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "palo_alto_fw_service." + dri.DRField
		}
		return drInfos, err

	case *GlobalSpecType_F5BigIpAwsService:
		drInfos, err := m.GetF5BigIpAwsService().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetF5BigIpAwsService().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "f5_big_ip_aws_service." + dri.DRField
		}
		return drInfos, err

	case *GlobalSpecType_F5BigIpBareMetalType:
		drInfos, err := m.GetF5BigIpBareMetalType().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetF5BigIpBareMetalType().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "f5_big_ip_bare_metal_type." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

func (m *GlobalSpecType) GetSiteRefsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetSiteRefs()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.site_refs[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "site.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "site_refs",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetSiteRefsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetSiteRefsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: site")
	}
	for _, ref := range m.GetSiteRefs() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetSshManagementChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetSshManagementChoice() == nil {
		return nil, nil
	}
	switch m.GetSshManagementChoice().(type) {
	case *GlobalSpecType_DisableSshAccess:

		return nil, nil

	case *GlobalSpecType_EnabledSshAccess:
		drInfos, err := m.GetEnabledSshAccess().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetEnabledSshAccess().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "enabled_ssh_access." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

func (m *GlobalSpecType) GetTfParamsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetTfParams()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.tf_params[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "terraform_parameters.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "tf_params",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetTfParamsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetTfParamsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "terraform_parameters.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: terraform_parameters")
	}
	for _, ref := range m.GetTfParams() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetViewInternalDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetViewInternal()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("view_internal.Object")
	dri := db.DRefInfo{
		RefdType:   "view_internal.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "view_internal",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetViewInternalDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetViewInternalDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "view_internal.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: view_internal")
	}

	vref := m.GetViewInternal()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "view_internal.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) HttpManagementChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for http_management_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ServiceProviderChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for service_provider_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ServiceTypeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for service_type_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) SshManagementChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ssh_management_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) PolicySetValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for policy_set")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for policy_set")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated policy_set")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items policy_set")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) InsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_vip")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) OriginPoolValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for origin_pool")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for origin_pool")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated origin_pool")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items origin_pool")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) SiteRefsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for site_refs")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for site_refs")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated site_refs")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items site_refs")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cloud_credentials"]; exists {

		vOpts := append(opts, db.WithValidateField("cloud_credentials"))
		for idx, item := range m.GetCloudCredentials() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["commands"]; exists {

		vOpts := append(opts, db.WithValidateField("commands"))
		for idx, item := range m.GetCommands() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["external_nlb_info"]; exists {

		vOpts := append(opts, db.WithValidateField("external_nlb_info"))
		if err := fv(ctx, m.GetExternalNlbInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["finalizer_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("finalizer_timestamp"))
		if err := fv(ctx, m.GetFinalizerTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["fleet"]; exists {

		vOpts := append(opts, db.WithValidateField("fleet"))
		for idx, item := range m.GetFleet() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["force_delete"]; exists {

		vOpts := append(opts, db.WithValidateField("force_delete"))
		if err := fv(ctx, m.GetForceDelete(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["http_management_choice"]; exists {
		val := m.GetHttpManagementChoice()
		vOpts := append(opts,
			db.WithValidateField("http_management_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetHttpManagementChoice().(type) {
	case *GlobalSpecType_DisableHttpsManagement:
		if fv, exists := v.FldValidators["http_management_choice.disable_https_management"]; exists {
			val := m.GetHttpManagementChoice().(*GlobalSpecType_DisableHttpsManagement).DisableHttpsManagement
			vOpts := append(opts,
				db.WithValidateField("http_management_choice"),
				db.WithValidateField("disable_https_management"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_HttpsManagement:
		if fv, exists := v.FldValidators["http_management_choice.https_management"]; exists {
			val := m.GetHttpManagementChoice().(*GlobalSpecType_HttpsManagement).HttpsManagement
			vOpts := append(opts,
				db.WithValidateField("http_management_choice"),
				db.WithValidateField("https_management"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["inside_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_vip"))
		if err := fv(ctx, m.GetInsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["k8s_manifest_params"]; exists {

		vOpts := append(opts, db.WithValidateField("k8s_manifest_params"))
		for idx, item := range m.GetK8SManifestParams() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["management_endpoint_refs"]; exists {

		vOpts := append(opts, db.WithValidateField("management_endpoint_refs"))
		for idx, item := range m.GetManagementEndpointRefs() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["node_info"]; exists {

		vOpts := append(opts, db.WithValidateField("node_info"))
		for idx, item := range m.GetNodeInfo() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["origin_pool"]; exists {
		vOpts := append(opts, db.WithValidateField("origin_pool"))
		if err := fv(ctx, m.GetOriginPool(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["policy_set"]; exists {
		vOpts := append(opts, db.WithValidateField("policy_set"))
		if err := fv(ctx, m.GetPolicySet(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_provider_choice"]; exists {
		val := m.GetServiceProviderChoice()
		vOpts := append(opts,
			db.WithValidateField("service_provider_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetServiceProviderChoice().(type) {
	case *GlobalSpecType_PaloAltoFwService:
		if fv, exists := v.FldValidators["service_provider_choice.palo_alto_fw_service"]; exists {
			val := m.GetServiceProviderChoice().(*GlobalSpecType_PaloAltoFwService).PaloAltoFwService
			vOpts := append(opts,
				db.WithValidateField("service_provider_choice"),
				db.WithValidateField("palo_alto_fw_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_F5BigIpAwsService:
		if fv, exists := v.FldValidators["service_provider_choice.f5_big_ip_aws_service"]; exists {
			val := m.GetServiceProviderChoice().(*GlobalSpecType_F5BigIpAwsService).F5BigIpAwsService
			vOpts := append(opts,
				db.WithValidateField("service_provider_choice"),
				db.WithValidateField("f5_big_ip_aws_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_F5BigIpBareMetalType:
		if fv, exists := v.FldValidators["service_provider_choice.f5_big_ip_bare_metal_type"]; exists {
			val := m.GetServiceProviderChoice().(*GlobalSpecType_F5BigIpBareMetalType).F5BigIpBareMetalType
			vOpts := append(opts,
				db.WithValidateField("service_provider_choice"),
				db.WithValidateField("f5_big_ip_bare_metal_type"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["service_type"]; exists {

		vOpts := append(opts, db.WithValidateField("service_type"))
		if err := fv(ctx, m.GetServiceType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_type_choice"]; exists {
		val := m.GetServiceTypeChoice()
		vOpts := append(opts,
			db.WithValidateField("service_type_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetServiceTypeChoice().(type) {
	case *GlobalSpecType_EndpointService:
		if fv, exists := v.FldValidators["service_type_choice.endpoint_service"]; exists {
			val := m.GetServiceTypeChoice().(*GlobalSpecType_EndpointService).EndpointService
			vOpts := append(opts,
				db.WithValidateField("service_type_choice"),
				db.WithValidateField("endpoint_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_ForwardingService:
		if fv, exists := v.FldValidators["service_type_choice.forwarding_service"]; exists {
			val := m.GetServiceTypeChoice().(*GlobalSpecType_ForwardingService).ForwardingService
			vOpts := append(opts,
				db.WithValidateField("service_type_choice"),
				db.WithValidateField("forwarding_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_TransparentService:
		if fv, exists := v.FldValidators["service_type_choice.transparent_service"]; exists {
			val := m.GetServiceTypeChoice().(*GlobalSpecType_TransparentService).TransparentService
			vOpts := append(opts,
				db.WithValidateField("service_type_choice"),
				db.WithValidateField("transparent_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["site_refs"]; exists {
		vOpts := append(opts, db.WithValidateField("site_refs"))
		if err := fv(ctx, m.GetSiteRefs(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ssh_management_choice"]; exists {
		val := m.GetSshManagementChoice()
		vOpts := append(opts,
			db.WithValidateField("ssh_management_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSshManagementChoice().(type) {
	case *GlobalSpecType_DisableSshAccess:
		if fv, exists := v.FldValidators["ssh_management_choice.disable_ssh_access"]; exists {
			val := m.GetSshManagementChoice().(*GlobalSpecType_DisableSshAccess).DisableSshAccess
			vOpts := append(opts,
				db.WithValidateField("ssh_management_choice"),
				db.WithValidateField("disable_ssh_access"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_EnabledSshAccess:
		if fv, exists := v.FldValidators["ssh_management_choice.enabled_ssh_access"]; exists {
			val := m.GetSshManagementChoice().(*GlobalSpecType_EnabledSshAccess).EnabledSshAccess
			vOpts := append(opts,
				db.WithValidateField("ssh_management_choice"),
				db.WithValidateField("enabled_ssh_access"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tf_params"]; exists {

		vOpts := append(opts, db.WithValidateField("tf_params"))
		for idx, item := range m.GetTfParams() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["view_internal"]; exists {

		vOpts := append(opts, db.WithValidateField("view_internal"))
		if err := fv(ctx, m.GetViewInternal(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHttpManagementChoice := v.HttpManagementChoiceValidationRuleHandler
	rulesHttpManagementChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhHttpManagementChoice(rulesHttpManagementChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.http_management_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["http_management_choice"] = vFn

	vrhServiceProviderChoice := v.ServiceProviderChoiceValidationRuleHandler
	rulesServiceProviderChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhServiceProviderChoice(rulesServiceProviderChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.service_provider_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_provider_choice"] = vFn

	vrhServiceTypeChoice := v.ServiceTypeChoiceValidationRuleHandler
	rulesServiceTypeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhServiceTypeChoice(rulesServiceTypeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.service_type_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_type_choice"] = vFn

	vrhSshManagementChoice := v.SshManagementChoiceValidationRuleHandler
	rulesSshManagementChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSshManagementChoice(rulesSshManagementChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.ssh_management_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ssh_management_choice"] = vFn

	vrhPolicySet := v.PolicySetValidationRuleHandler
	rulesPolicySet := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhPolicySet(rulesPolicySet)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.policy_set: %s", err)
		panic(errMsg)
	}
	v.FldValidators["policy_set"] = vFn

	vrhInsideVip := v.InsideVipValidationRuleHandler
	rulesInsideVip := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhInsideVip(rulesInsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.inside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_vip"] = vFn

	vrhOriginPool := v.OriginPoolValidationRuleHandler
	rulesOriginPool := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhOriginPool(rulesOriginPool)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.origin_pool: %s", err)
		panic(errMsg)
	}
	v.FldValidators["origin_pool"] = vFn

	vrhSiteRefs := v.SiteRefsValidationRuleHandler
	rulesSiteRefs := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhSiteRefs(rulesSiteRefs)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.site_refs: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_refs"] = vFn

	v.FldValidators["http_management_choice.https_management"] = ServiceHttpsManagementTypeValidator().Validate

	v.FldValidators["service_provider_choice.palo_alto_fw_service"] = PaloAltoFWAWSTypeValidator().Validate
	v.FldValidators["service_provider_choice.f5_big_ip_aws_service"] = F5BigIpAWSTypeValidator().Validate
	v.FldValidators["service_provider_choice.f5_big_ip_bare_metal_type"] = F5BigIpAppStackBareMetalTypeValidator().Validate

	v.FldValidators["service_type_choice.endpoint_service"] = EndpointServiceTypeValidator().Validate

	v.FldValidators["ssh_management_choice.enabled_ssh_access"] = SSHManagementTypeValidator().Validate

	v.FldValidators["management_endpoint_refs"] = EndpointRefTypeValidator().Validate

	v.FldValidators["commands"] = SuggestedCommandsValidator().Validate

	v.FldValidators["view_internal"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *InterfaceDetails) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *InterfaceDetails) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *InterfaceDetails) DeepCopy() *InterfaceDetails {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &InterfaceDetails{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *InterfaceDetails) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *InterfaceDetails) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return InterfaceDetailsValidator().Validate(ctx, m, opts...)
}

func (m *InterfaceDetails) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetInterfaceDRefInfo()

}

func (m *InterfaceDetails) GetInterfaceDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetInterface()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("subnet.Object")
	dri := db.DRefInfo{
		RefdType:   "subnet.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "interface",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetInterfaceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *InterfaceDetails) GetInterfaceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "subnet.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: subnet")
	}

	vref := m.GetInterface()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "subnet.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateInterfaceDetails struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInterfaceDetails) InterfaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for interface")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateInterfaceDetails) NetworkSelfIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network_self_ip")
	}

	return validatorFn, nil
}

func (v *ValidateInterfaceDetails) NetworkGatewayValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network_gateway")
	}

	return validatorFn, nil
}

func (v *ValidateInterfaceDetails) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*InterfaceDetails)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *InterfaceDetails got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["interface"]; exists {

		vOpts := append(opts, db.WithValidateField("interface"))
		if err := fv(ctx, m.GetInterface(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network_gateway"]; exists {

		vOpts := append(opts, db.WithValidateField("network_gateway"))
		if err := fv(ctx, m.GetNetworkGateway(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network_self_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("network_self_ip"))
		if err := fv(ctx, m.GetNetworkSelfIp(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInterfaceDetailsValidator = func() *ValidateInterfaceDetails {
	v := &ValidateInterfaceDetails{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInterface := v.InterfaceValidationRuleHandler
	rulesInterface := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhInterface(rulesInterface)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for InterfaceDetails.interface: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interface"] = vFn

	vrhNetworkSelfIp := v.NetworkSelfIpValidationRuleHandler
	rulesNetworkSelfIp := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.string.ipv4_prefix": "true",
	}
	vFn, err = vrhNetworkSelfIp(rulesNetworkSelfIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for InterfaceDetails.network_self_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_self_ip"] = vFn

	vrhNetworkGateway := v.NetworkGatewayValidationRuleHandler
	rulesNetworkGateway := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFn, err = vrhNetworkGateway(rulesNetworkGateway)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for InterfaceDetails.network_gateway: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_gateway"] = vFn

	return v
}()

func InterfaceDetailsValidator() db.Validator {
	return DefaultInterfaceDetailsValidator
}

// augmented methods on protoc/std generated struct

func (m *NodeInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NodeInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NodeInfo) DeepCopy() *NodeInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NodeInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NodeInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NodeInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NodeInfoValidator().Validate(ctx, m, opts...)
}

type ValidateNodeInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNodeInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NodeInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NodeInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ssh_command"]; exists {

		vOpts := append(opts, db.WithValidateField("ssh_command"))
		if err := fv(ctx, m.GetSshCommand(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNodeInfoValidator = func() *ValidateNodeInfo {
	v := &ValidateNodeInfo{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func NodeInfoValidator() db.Validator {
	return DefaultNodeInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *PANAWSAutoSetupType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PANAWSAutoSetupType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *PANAWSAutoSetupType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetManualSshKeys().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting PANAWSAutoSetupType.manual_ssh_keys")
	}

	if err := m.GetAdminPassword().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting PANAWSAutoSetupType.admin_password")
	}

	return nil
}

func (m *PANAWSAutoSetupType) DeepCopy() *PANAWSAutoSetupType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PANAWSAutoSetupType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PANAWSAutoSetupType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PANAWSAutoSetupType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PANAWSAutoSetupTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePANAWSAutoSetupType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePANAWSAutoSetupType) SshKeysChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ssh_keys_choice")
	}
	return validatorFn, nil
}

func (v *ValidatePANAWSAutoSetupType) AdminUsernameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for admin_username")
	}

	return validatorFn, nil
}

func (v *ValidatePANAWSAutoSetupType) AdminPasswordValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for admin_password")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.SecretTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePANAWSAutoSetupType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PANAWSAutoSetupType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PANAWSAutoSetupType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["admin_password"]; exists {

		vOpts := append(opts, db.WithValidateField("admin_password"))
		if err := fv(ctx, m.GetAdminPassword(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["admin_username"]; exists {

		vOpts := append(opts, db.WithValidateField("admin_username"))
		if err := fv(ctx, m.GetAdminUsername(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ssh_keys_choice"]; exists {
		val := m.GetSshKeysChoice()
		vOpts := append(opts,
			db.WithValidateField("ssh_keys_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSshKeysChoice().(type) {
	case *PANAWSAutoSetupType_ManualSshKeys:
		if fv, exists := v.FldValidators["ssh_keys_choice.manual_ssh_keys"]; exists {
			val := m.GetSshKeysChoice().(*PANAWSAutoSetupType_ManualSshKeys).ManualSshKeys
			vOpts := append(opts,
				db.WithValidateField("ssh_keys_choice"),
				db.WithValidateField("manual_ssh_keys"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PANAWSAutoSetupType_AutogeneratedSshKeys:
		if fv, exists := v.FldValidators["ssh_keys_choice.autogenerated_ssh_keys"]; exists {
			val := m.GetSshKeysChoice().(*PANAWSAutoSetupType_AutogeneratedSshKeys).AutogeneratedSshKeys
			vOpts := append(opts,
				db.WithValidateField("ssh_keys_choice"),
				db.WithValidateField("autogenerated_ssh_keys"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPANAWSAutoSetupTypeValidator = func() *ValidatePANAWSAutoSetupType {
	v := &ValidatePANAWSAutoSetupType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSshKeysChoice := v.SshKeysChoiceValidationRuleHandler
	rulesSshKeysChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSshKeysChoice(rulesSshKeysChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PANAWSAutoSetupType.ssh_keys_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ssh_keys_choice"] = vFn

	vrhAdminUsername := v.AdminUsernameValidationRuleHandler
	rulesAdminUsername := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFn, err = vrhAdminUsername(rulesAdminUsername)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PANAWSAutoSetupType.admin_username: %s", err)
		panic(errMsg)
	}
	v.FldValidators["admin_username"] = vFn

	vrhAdminPassword := v.AdminPasswordValidationRuleHandler
	rulesAdminPassword := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAdminPassword(rulesAdminPassword)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PANAWSAutoSetupType.admin_password: %s", err)
		panic(errMsg)
	}
	v.FldValidators["admin_password"] = vFn

	v.FldValidators["ssh_keys_choice.manual_ssh_keys"] = SSHKeyTypeValidator().Validate

	return v
}()

func PANAWSAutoSetupTypeValidator() db.Validator {
	return DefaultPANAWSAutoSetupTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PaloAltoAzNodesAWSType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PaloAltoAzNodesAWSType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PaloAltoAzNodesAWSType) DeepCopy() *PaloAltoAzNodesAWSType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PaloAltoAzNodesAWSType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PaloAltoAzNodesAWSType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PaloAltoAzNodesAWSType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PaloAltoAzNodesAWSTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePaloAltoAzNodesAWSType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePaloAltoAzNodesAWSType) NodesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for nodes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*PaloAltoServiceNodesAWSType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := PaloAltoServiceNodesAWSTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for nodes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*PaloAltoServiceNodesAWSType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*PaloAltoServiceNodesAWSType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated nodes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items nodes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePaloAltoAzNodesAWSType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PaloAltoAzNodesAWSType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PaloAltoAzNodesAWSType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["nodes"]; exists {
		vOpts := append(opts, db.WithValidateField("nodes"))
		if err := fv(ctx, m.GetNodes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPaloAltoAzNodesAWSTypeValidator = func() *ValidatePaloAltoAzNodesAWSType {
	v := &ValidatePaloAltoAzNodesAWSType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNodes := v.NodesValidationRuleHandler
	rulesNodes := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "2",
		"ves.io.schema.rules.repeated.min_items": "1",
	}
	vFn, err = vrhNodes(rulesNodes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PaloAltoAzNodesAWSType.nodes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["nodes"] = vFn

	return v
}()

func PaloAltoAzNodesAWSTypeValidator() db.Validator {
	return DefaultPaloAltoAzNodesAWSTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PaloAltoFWAWSReplaceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PaloAltoFWAWSReplaceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *PaloAltoFWAWSReplaceType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	return nil
}

func (m *PaloAltoFWAWSReplaceType) DeepCopy() *PaloAltoFWAWSReplaceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PaloAltoFWAWSReplaceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PaloAltoFWAWSReplaceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PaloAltoFWAWSReplaceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PaloAltoFWAWSReplaceTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePaloAltoFWAWSReplaceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePaloAltoFWAWSReplaceType) TagsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for tags")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for tags")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for tags")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map tags")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items tags")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePaloAltoFWAWSReplaceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PaloAltoFWAWSReplaceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PaloAltoFWAWSReplaceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["tags"]; exists {
		vOpts := append(opts, db.WithValidateField("tags"))
		if err := fv(ctx, m.GetTags(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPaloAltoFWAWSReplaceTypeValidator = func() *ValidatePaloAltoFWAWSReplaceType {
	v := &ValidatePaloAltoFWAWSReplaceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTags := v.TagsValidationRuleHandler
	rulesTags := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len":   "127",
		"ves.io.schema.rules.map.max_pairs":             "40",
		"ves.io.schema.rules.map.values.string.max_len": "255",
	}
	vFn, err = vrhTags(rulesTags)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PaloAltoFWAWSReplaceType.tags: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tags"] = vFn

	return v
}()

func PaloAltoFWAWSReplaceTypeValidator() db.Validator {
	return DefaultPaloAltoFWAWSReplaceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PaloAltoFWAWSType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PaloAltoFWAWSType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *PaloAltoFWAWSType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetPanoramaServer().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting PaloAltoFWAWSType.panorama_server")
	}

	if err := m.GetAutoSetup().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting PaloAltoFWAWSType.auto_setup")
	}

	return nil
}

func (m *PaloAltoFWAWSType) DeepCopy() *PaloAltoFWAWSType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PaloAltoFWAWSType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PaloAltoFWAWSType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PaloAltoFWAWSType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PaloAltoFWAWSTypeValidator().Validate(ctx, m, opts...)
}

func (m *PaloAltoFWAWSType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetAwsTgwSiteDRefInfo()

}

func (m *PaloAltoFWAWSType) GetAwsTgwSiteDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetAwsTgwSite()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("aws_tgw_site.Object")
	dri := db.DRefInfo{
		RefdType:   "aws_tgw_site.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "aws_tgw_site",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetAwsTgwSiteDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *PaloAltoFWAWSType) GetAwsTgwSiteDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "aws_tgw_site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: aws_tgw_site")
	}

	vref := m.GetAwsTgwSite()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "aws_tgw_site.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidatePaloAltoFWAWSType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePaloAltoFWAWSType) AmiChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ami_choice")
	}
	return validatorFn, nil
}

func (v *ValidatePaloAltoFWAWSType) SetupOptionsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for setup_options")
	}
	return validatorFn, nil
}

func (v *ValidatePaloAltoFWAWSType) SetupOptionsSshKeyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SshKey, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ssh_key")
	}
	return oValidatorFn_SshKey, nil
}

func (v *ValidatePaloAltoFWAWSType) InstanceTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(PaloAltoFWAWSInstanceType)
		return int32(i)
	}
	// PaloAltoFWAWSInstanceType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, PaloAltoFWAWSInstanceType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for instance_type")
	}

	return validatorFn, nil
}

func (v *ValidatePaloAltoFWAWSType) AwsTgwSiteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for aws_tgw_site")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePaloAltoFWAWSType) ServiceNodesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for service_nodes")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := PaloAltoAzNodesAWSTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePaloAltoFWAWSType) TagsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for tags")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for tags")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for tags")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map tags")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items tags")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePaloAltoFWAWSType) VersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for version")
	}

	return validatorFn, nil
}

func (v *ValidatePaloAltoFWAWSType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PaloAltoFWAWSType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PaloAltoFWAWSType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ami_choice"]; exists {
		val := m.GetAmiChoice()
		vOpts := append(opts,
			db.WithValidateField("ami_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAmiChoice().(type) {
	case *PaloAltoFWAWSType_PanAmiBundle1:
		if fv, exists := v.FldValidators["ami_choice.pan_ami_bundle1"]; exists {
			val := m.GetAmiChoice().(*PaloAltoFWAWSType_PanAmiBundle1).PanAmiBundle1
			vOpts := append(opts,
				db.WithValidateField("ami_choice"),
				db.WithValidateField("pan_ami_bundle1"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PaloAltoFWAWSType_PanAmiBundle2:
		if fv, exists := v.FldValidators["ami_choice.pan_ami_bundle2"]; exists {
			val := m.GetAmiChoice().(*PaloAltoFWAWSType_PanAmiBundle2).PanAmiBundle2
			vOpts := append(opts,
				db.WithValidateField("ami_choice"),
				db.WithValidateField("pan_ami_bundle2"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["aws_tgw_site"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_tgw_site"))
		if err := fv(ctx, m.GetAwsTgwSite(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["instance_type"]; exists {

		vOpts := append(opts, db.WithValidateField("instance_type"))
		if err := fv(ctx, m.GetInstanceType(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetPanaromaConnection().(type) {
	case *PaloAltoFWAWSType_PanoramaServer:
		if fv, exists := v.FldValidators["panaroma_connection.panorama_server"]; exists {
			val := m.GetPanaromaConnection().(*PaloAltoFWAWSType_PanoramaServer).PanoramaServer
			vOpts := append(opts,
				db.WithValidateField("panaroma_connection"),
				db.WithValidateField("panorama_server"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PaloAltoFWAWSType_DisablePanaroma:
		if fv, exists := v.FldValidators["panaroma_connection.disable_panaroma"]; exists {
			val := m.GetPanaromaConnection().(*PaloAltoFWAWSType_DisablePanaroma).DisablePanaroma
			vOpts := append(opts,
				db.WithValidateField("panaroma_connection"),
				db.WithValidateField("disable_panaroma"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["service_nodes"]; exists {

		vOpts := append(opts, db.WithValidateField("service_nodes"))
		if err := fv(ctx, m.GetServiceNodes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["setup_options"]; exists {
		val := m.GetSetupOptions()
		vOpts := append(opts,
			db.WithValidateField("setup_options"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSetupOptions().(type) {
	case *PaloAltoFWAWSType_SshKey:
		if fv, exists := v.FldValidators["setup_options.ssh_key"]; exists {
			val := m.GetSetupOptions().(*PaloAltoFWAWSType_SshKey).SshKey
			vOpts := append(opts,
				db.WithValidateField("setup_options"),
				db.WithValidateField("ssh_key"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PaloAltoFWAWSType_AutoSetup:
		if fv, exists := v.FldValidators["setup_options.auto_setup"]; exists {
			val := m.GetSetupOptions().(*PaloAltoFWAWSType_AutoSetup).AutoSetup
			vOpts := append(opts,
				db.WithValidateField("setup_options"),
				db.WithValidateField("auto_setup"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tags"]; exists {
		vOpts := append(opts, db.WithValidateField("tags"))
		if err := fv(ctx, m.GetTags(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPaloAltoFWAWSTypeValidator = func() *ValidatePaloAltoFWAWSType {
	v := &ValidatePaloAltoFWAWSType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAmiChoice := v.AmiChoiceValidationRuleHandler
	rulesAmiChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAmiChoice(rulesAmiChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PaloAltoFWAWSType.ami_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ami_choice"] = vFn

	vrhSetupOptions := v.SetupOptionsValidationRuleHandler
	rulesSetupOptions := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSetupOptions(rulesSetupOptions)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PaloAltoFWAWSType.setup_options: %s", err)
		panic(errMsg)
	}
	v.FldValidators["setup_options"] = vFn

	vrhSetupOptionsSshKey := v.SetupOptionsSshKeyValidationRuleHandler
	rulesSetupOptionsSshKey := map[string]string{
		"ves.io.schema.rules.string.max_len": "8192",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFnMap["setup_options.ssh_key"], err = vrhSetupOptionsSshKey(rulesSetupOptionsSshKey)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field PaloAltoFWAWSType.setup_options_ssh_key: %s", err)
		panic(errMsg)
	}

	v.FldValidators["setup_options.ssh_key"] = vFnMap["setup_options.ssh_key"]

	vrhInstanceType := v.InstanceTypeValidationRuleHandler
	rulesInstanceType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhInstanceType(rulesInstanceType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PaloAltoFWAWSType.instance_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["instance_type"] = vFn

	vrhAwsTgwSite := v.AwsTgwSiteValidationRuleHandler
	rulesAwsTgwSite := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAwsTgwSite(rulesAwsTgwSite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PaloAltoFWAWSType.aws_tgw_site: %s", err)
		panic(errMsg)
	}
	v.FldValidators["aws_tgw_site"] = vFn

	vrhServiceNodes := v.ServiceNodesValidationRuleHandler
	rulesServiceNodes := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhServiceNodes(rulesServiceNodes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PaloAltoFWAWSType.service_nodes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_nodes"] = vFn

	vrhTags := v.TagsValidationRuleHandler
	rulesTags := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len":   "127",
		"ves.io.schema.rules.map.max_pairs":             "40",
		"ves.io.schema.rules.map.values.string.max_len": "255",
	}
	vFn, err = vrhTags(rulesTags)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PaloAltoFWAWSType.tags: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tags"] = vFn

	vrhVersion := v.VersionValidationRuleHandler
	rulesVersion := map[string]string{
		"ves.io.schema.rules.string.in": "[\"11.0.0\"]",
	}
	vFn, err = vrhVersion(rulesVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PaloAltoFWAWSType.version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["version"] = vFn

	v.FldValidators["panaroma_connection.panorama_server"] = PanoramaServerTypeValidator().Validate

	v.FldValidators["setup_options.auto_setup"] = PANAWSAutoSetupTypeValidator().Validate

	return v
}()

func PaloAltoFWAWSTypeValidator() db.Validator {
	return DefaultPaloAltoFWAWSTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PaloAltoServiceNodesAWSType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PaloAltoServiceNodesAWSType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PaloAltoServiceNodesAWSType) DeepCopy() *PaloAltoServiceNodesAWSType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PaloAltoServiceNodesAWSType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PaloAltoServiceNodesAWSType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PaloAltoServiceNodesAWSType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PaloAltoServiceNodesAWSTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePaloAltoServiceNodesAWSType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePaloAltoServiceNodesAWSType) MgmtSubnetChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mgmt_subnet_choice")
	}
	return validatorFn, nil
}

func (v *ValidatePaloAltoServiceNodesAWSType) NodeNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node_name")
	}

	return validatorFn, nil
}

func (v *ValidatePaloAltoServiceNodesAWSType) AwsAzNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for aws_az_name")
	}

	return validatorFn, nil
}

func (v *ValidatePaloAltoServiceNodesAWSType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PaloAltoServiceNodesAWSType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PaloAltoServiceNodesAWSType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aws_az_name"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_az_name"))
		if err := fv(ctx, m.GetAwsAzName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mgmt_subnet_choice"]; exists {
		val := m.GetMgmtSubnetChoice()
		vOpts := append(opts,
			db.WithValidateField("mgmt_subnet_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMgmtSubnetChoice().(type) {
	case *PaloAltoServiceNodesAWSType_ReservedMgmtSubnet:
		if fv, exists := v.FldValidators["mgmt_subnet_choice.reserved_mgmt_subnet"]; exists {
			val := m.GetMgmtSubnetChoice().(*PaloAltoServiceNodesAWSType_ReservedMgmtSubnet).ReservedMgmtSubnet
			vOpts := append(opts,
				db.WithValidateField("mgmt_subnet_choice"),
				db.WithValidateField("reserved_mgmt_subnet"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PaloAltoServiceNodesAWSType_MgmtSubnet:
		if fv, exists := v.FldValidators["mgmt_subnet_choice.mgmt_subnet"]; exists {
			val := m.GetMgmtSubnetChoice().(*PaloAltoServiceNodesAWSType_MgmtSubnet).MgmtSubnet
			vOpts := append(opts,
				db.WithValidateField("mgmt_subnet_choice"),
				db.WithValidateField("mgmt_subnet"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["node_name"]; exists {

		vOpts := append(opts, db.WithValidateField("node_name"))
		if err := fv(ctx, m.GetNodeName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPaloAltoServiceNodesAWSTypeValidator = func() *ValidatePaloAltoServiceNodesAWSType {
	v := &ValidatePaloAltoServiceNodesAWSType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMgmtSubnetChoice := v.MgmtSubnetChoiceValidationRuleHandler
	rulesMgmtSubnetChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMgmtSubnetChoice(rulesMgmtSubnetChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PaloAltoServiceNodesAWSType.mgmt_subnet_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mgmt_subnet_choice"] = vFn

	vrhNodeName := v.NodeNameValidationRuleHandler
	rulesNodeName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.hostname":  "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhNodeName(rulesNodeName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PaloAltoServiceNodesAWSType.node_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["node_name"] = vFn

	vrhAwsAzName := v.AwsAzNameValidationRuleHandler
	rulesAwsAzName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.pattern":   "^([a-z]{2})-([a-z0-9]{4,20})-([a-z0-9]{2})$",
	}
	vFn, err = vrhAwsAzName(rulesAwsAzName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PaloAltoServiceNodesAWSType.aws_az_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["aws_az_name"] = vFn

	v.FldValidators["mgmt_subnet_choice.mgmt_subnet"] = ves_io_schema_views.CloudSubnetTypeValidator().Validate

	return v
}()

func PaloAltoServiceNodesAWSTypeValidator() db.Validator {
	return DefaultPaloAltoServiceNodesAWSTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PanoramaServerType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PanoramaServerType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *PanoramaServerType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetAuthorizationKey().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting PanoramaServerType.authorization_key")
	}

	return nil
}

func (m *PanoramaServerType) DeepCopy() *PanoramaServerType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PanoramaServerType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PanoramaServerType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PanoramaServerType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PanoramaServerTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePanoramaServerType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePanoramaServerType) ServerValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for server")
	}

	return validatorFn, nil
}

func (v *ValidatePanoramaServerType) AuthorizationKeyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for authorization_key")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.SecretTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePanoramaServerType) TemplateStackNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for template_stack_name")
	}

	return validatorFn, nil
}

func (v *ValidatePanoramaServerType) DeviceGroupNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for device_group_name")
	}

	return validatorFn, nil
}

func (v *ValidatePanoramaServerType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PanoramaServerType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PanoramaServerType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["authorization_key"]; exists {

		vOpts := append(opts, db.WithValidateField("authorization_key"))
		if err := fv(ctx, m.GetAuthorizationKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["device_group_name"]; exists {

		vOpts := append(opts, db.WithValidateField("device_group_name"))
		if err := fv(ctx, m.GetDeviceGroupName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["server"]; exists {

		vOpts := append(opts, db.WithValidateField("server"))
		if err := fv(ctx, m.GetServer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["template_stack_name"]; exists {

		vOpts := append(opts, db.WithValidateField("template_stack_name"))
		if err := fv(ctx, m.GetTemplateStackName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPanoramaServerTypeValidator = func() *ValidatePanoramaServerType {
	v := &ValidatePanoramaServerType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhServer := v.ServerValidationRuleHandler
	rulesServer := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.ip":        "true",
	}
	vFn, err = vrhServer(rulesServer)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PanoramaServerType.server: %s", err)
		panic(errMsg)
	}
	v.FldValidators["server"] = vFn

	vrhAuthorizationKey := v.AuthorizationKeyValidationRuleHandler
	rulesAuthorizationKey := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAuthorizationKey(rulesAuthorizationKey)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PanoramaServerType.authorization_key: %s", err)
		panic(errMsg)
	}
	v.FldValidators["authorization_key"] = vFn

	vrhTemplateStackName := v.TemplateStackNameValidationRuleHandler
	rulesTemplateStackName := map[string]string{
		"ves.io.schema.rules.string.max_len": "128",
	}
	vFn, err = vrhTemplateStackName(rulesTemplateStackName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PanoramaServerType.template_stack_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["template_stack_name"] = vFn

	vrhDeviceGroupName := v.DeviceGroupNameValidationRuleHandler
	rulesDeviceGroupName := map[string]string{
		"ves.io.schema.rules.string.max_len": "128",
	}
	vFn, err = vrhDeviceGroupName(rulesDeviceGroupName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PanoramaServerType.device_group_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["device_group_name"] = vFn

	return v
}()

func PanoramaServerTypeValidator() db.Validator {
	return DefaultPanoramaServerTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ReplaceSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetPaloAltoFwService().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.palo_alto_fw_service")
	}

	if err := m.GetHttpsManagement().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.https_management")
	}

	if err := m.GetF5BigIpAwsService().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.f5_big_ip_aws_service")
	}

	return nil
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *ReplaceSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetHttpManagementChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetHttpManagementChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetSshManagementChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetSshManagementChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetHttpManagementChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetHttpManagementChoice() == nil {
		return nil, nil
	}
	switch m.GetHttpManagementChoice().(type) {
	case *ReplaceSpecType_DisableHttpsManagement:

		return nil, nil

	case *ReplaceSpecType_HttpsManagement:
		drInfos, err := m.GetHttpsManagement().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetHttpsManagement().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "https_management." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetSshManagementChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetSshManagementChoice() == nil {
		return nil, nil
	}
	switch m.GetSshManagementChoice().(type) {
	case *ReplaceSpecType_DisableSshAccess:

		return nil, nil

	case *ReplaceSpecType_EnabledSshAccess:
		drInfos, err := m.GetEnabledSshAccess().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetEnabledSshAccess().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "enabled_ssh_access." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) HttpManagementChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for http_management_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) ServiceProviderChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for service_provider_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) SshManagementChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ssh_management_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["http_management_choice"]; exists {
		val := m.GetHttpManagementChoice()
		vOpts := append(opts,
			db.WithValidateField("http_management_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetHttpManagementChoice().(type) {
	case *ReplaceSpecType_DisableHttpsManagement:
		if fv, exists := v.FldValidators["http_management_choice.disable_https_management"]; exists {
			val := m.GetHttpManagementChoice().(*ReplaceSpecType_DisableHttpsManagement).DisableHttpsManagement
			vOpts := append(opts,
				db.WithValidateField("http_management_choice"),
				db.WithValidateField("disable_https_management"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_HttpsManagement:
		if fv, exists := v.FldValidators["http_management_choice.https_management"]; exists {
			val := m.GetHttpManagementChoice().(*ReplaceSpecType_HttpsManagement).HttpsManagement
			vOpts := append(opts,
				db.WithValidateField("http_management_choice"),
				db.WithValidateField("https_management"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["service_provider_choice"]; exists {
		val := m.GetServiceProviderChoice()
		vOpts := append(opts,
			db.WithValidateField("service_provider_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetServiceProviderChoice().(type) {
	case *ReplaceSpecType_PaloAltoFwService:
		if fv, exists := v.FldValidators["service_provider_choice.palo_alto_fw_service"]; exists {
			val := m.GetServiceProviderChoice().(*ReplaceSpecType_PaloAltoFwService).PaloAltoFwService
			vOpts := append(opts,
				db.WithValidateField("service_provider_choice"),
				db.WithValidateField("palo_alto_fw_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_F5BigIpAwsService:
		if fv, exists := v.FldValidators["service_provider_choice.f5_big_ip_aws_service"]; exists {
			val := m.GetServiceProviderChoice().(*ReplaceSpecType_F5BigIpAwsService).F5BigIpAwsService
			vOpts := append(opts,
				db.WithValidateField("service_provider_choice"),
				db.WithValidateField("f5_big_ip_aws_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["ssh_management_choice"]; exists {
		val := m.GetSshManagementChoice()
		vOpts := append(opts,
			db.WithValidateField("ssh_management_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSshManagementChoice().(type) {
	case *ReplaceSpecType_DisableSshAccess:
		if fv, exists := v.FldValidators["ssh_management_choice.disable_ssh_access"]; exists {
			val := m.GetSshManagementChoice().(*ReplaceSpecType_DisableSshAccess).DisableSshAccess
			vOpts := append(opts,
				db.WithValidateField("ssh_management_choice"),
				db.WithValidateField("disable_ssh_access"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_EnabledSshAccess:
		if fv, exists := v.FldValidators["ssh_management_choice.enabled_ssh_access"]; exists {
			val := m.GetSshManagementChoice().(*ReplaceSpecType_EnabledSshAccess).EnabledSshAccess
			vOpts := append(opts,
				db.WithValidateField("ssh_management_choice"),
				db.WithValidateField("enabled_ssh_access"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHttpManagementChoice := v.HttpManagementChoiceValidationRuleHandler
	rulesHttpManagementChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhHttpManagementChoice(rulesHttpManagementChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.http_management_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["http_management_choice"] = vFn

	vrhServiceProviderChoice := v.ServiceProviderChoiceValidationRuleHandler
	rulesServiceProviderChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhServiceProviderChoice(rulesServiceProviderChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.service_provider_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_provider_choice"] = vFn

	vrhSshManagementChoice := v.SshManagementChoiceValidationRuleHandler
	rulesSshManagementChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSshManagementChoice(rulesSshManagementChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.ssh_management_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ssh_management_choice"] = vFn

	v.FldValidators["http_management_choice.https_management"] = ServiceHttpsManagementTypeValidator().Validate

	v.FldValidators["service_provider_choice.palo_alto_fw_service"] = PaloAltoFWAWSReplaceTypeValidator().Validate
	v.FldValidators["service_provider_choice.f5_big_ip_aws_service"] = F5BigIpAWSReplaceTypeValidator().Validate

	v.FldValidators["ssh_management_choice.enabled_ssh_access"] = SSHManagementTypeValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SSHKeyType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SSHKeyType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *SSHKeyType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetPrivateKey().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting SSHKeyType.private_key")
	}

	return nil
}

func (m *SSHKeyType) DeepCopy() *SSHKeyType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SSHKeyType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SSHKeyType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SSHKeyType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SSHKeyTypeValidator().Validate(ctx, m, opts...)
}

type ValidateSSHKeyType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSSHKeyType) PublicKeyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for public_key")
	}

	return validatorFn, nil
}

func (v *ValidateSSHKeyType) PrivateKeyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for private_key")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.SecretTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSSHKeyType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SSHKeyType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SSHKeyType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["private_key"]; exists {

		vOpts := append(opts, db.WithValidateField("private_key"))
		if err := fv(ctx, m.GetPrivateKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["public_key"]; exists {

		vOpts := append(opts, db.WithValidateField("public_key"))
		if err := fv(ctx, m.GetPublicKey(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSSHKeyTypeValidator = func() *ValidateSSHKeyType {
	v := &ValidateSSHKeyType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPublicKey := v.PublicKeyValidationRuleHandler
	rulesPublicKey := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "8192",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhPublicKey(rulesPublicKey)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SSHKeyType.public_key: %s", err)
		panic(errMsg)
	}
	v.FldValidators["public_key"] = vFn

	vrhPrivateKey := v.PrivateKeyValidationRuleHandler
	rulesPrivateKey := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPrivateKey(rulesPrivateKey)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SSHKeyType.private_key: %s", err)
		panic(errMsg)
	}
	v.FldValidators["private_key"] = vFn

	return v
}()

func SSHKeyTypeValidator() db.Validator {
	return DefaultSSHKeyTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SSHManagementNodePorts) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SSHManagementNodePorts) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SSHManagementNodePorts) DeepCopy() *SSHManagementNodePorts {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SSHManagementNodePorts{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SSHManagementNodePorts) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SSHManagementNodePorts) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SSHManagementNodePortsValidator().Validate(ctx, m, opts...)
}

type ValidateSSHManagementNodePorts struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSSHManagementNodePorts) NodeNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node_name")
	}

	return validatorFn, nil
}

func (v *ValidateSSHManagementNodePorts) SshPortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ssh_port")
	}

	return validatorFn, nil
}

func (v *ValidateSSHManagementNodePorts) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SSHManagementNodePorts)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SSHManagementNodePorts got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["node_name"]; exists {

		vOpts := append(opts, db.WithValidateField("node_name"))
		if err := fv(ctx, m.GetNodeName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ssh_port"]; exists {

		vOpts := append(opts, db.WithValidateField("ssh_port"))
		if err := fv(ctx, m.GetSshPort(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSSHManagementNodePortsValidator = func() *ValidateSSHManagementNodePorts {
	v := &ValidateSSHManagementNodePorts{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNodeName := v.NodeNameValidationRuleHandler
	rulesNodeName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.hostname":  "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhNodeName(rulesNodeName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SSHManagementNodePorts.node_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["node_name"] = vFn

	vrhSshPort := v.SshPortValidationRuleHandler
	rulesSshPort := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "1024",
		"ves.io.schema.rules.uint32.lte":       "65535",
	}
	vFn, err = vrhSshPort(rulesSshPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SSHManagementNodePorts.ssh_port: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ssh_port"] = vFn

	return v
}()

func SSHManagementNodePortsValidator() db.Validator {
	return DefaultSSHManagementNodePortsValidator
}

// augmented methods on protoc/std generated struct

func (m *SSHManagementType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SSHManagementType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SSHManagementType) DeepCopy() *SSHManagementType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SSHManagementType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SSHManagementType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SSHManagementType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SSHManagementTypeValidator().Validate(ctx, m, opts...)
}

func (m *SSHManagementType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetAdvertiseChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *SSHManagementType) GetAdvertiseChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAdvertiseChoice() == nil {
		return nil, nil
	}
	switch m.GetAdvertiseChoice().(type) {
	case *SSHManagementType_AdvertiseOnPublicDefaultVip:

		return nil, nil

	case *SSHManagementType_AdvertiseOnPublic:
		drInfos, err := m.GetAdvertiseOnPublic().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAdvertiseOnPublic().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "advertise_on_public." + dri.DRField
		}
		return drInfos, err

	case *SSHManagementType_AdvertiseOnSloInternetVip:

		return nil, nil

	case *SSHManagementType_AdvertiseOnSli:

		return nil, nil

	case *SSHManagementType_AdvertiseOnSlo:

		return nil, nil

	case *SSHManagementType_AdvertiseOnSloSli:

		return nil, nil

	default:
		return nil, nil
	}

}

type ValidateSSHManagementType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSSHManagementType) NodeSshPortsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for node_ssh_ports")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*SSHManagementNodePorts, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := SSHManagementNodePortsValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for node_ssh_ports")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*SSHManagementNodePorts)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*SSHManagementNodePorts, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated node_ssh_ports")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items node_ssh_ports")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSSHManagementType) DomainSuffixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_suffix")
	}

	return validatorFn, nil
}

func (v *ValidateSSHManagementType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SSHManagementType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SSHManagementType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetAdvertiseChoice().(type) {
	case *SSHManagementType_AdvertiseOnPublicDefaultVip:
		if fv, exists := v.FldValidators["advertise_choice.advertise_on_public_default_vip"]; exists {
			val := m.GetAdvertiseChoice().(*SSHManagementType_AdvertiseOnPublicDefaultVip).AdvertiseOnPublicDefaultVip
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("advertise_on_public_default_vip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SSHManagementType_AdvertiseOnPublic:
		if fv, exists := v.FldValidators["advertise_choice.advertise_on_public"]; exists {
			val := m.GetAdvertiseChoice().(*SSHManagementType_AdvertiseOnPublic).AdvertiseOnPublic
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("advertise_on_public"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SSHManagementType_AdvertiseOnSloInternetVip:
		if fv, exists := v.FldValidators["advertise_choice.advertise_on_slo_internet_vip"]; exists {
			val := m.GetAdvertiseChoice().(*SSHManagementType_AdvertiseOnSloInternetVip).AdvertiseOnSloInternetVip
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("advertise_on_slo_internet_vip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SSHManagementType_AdvertiseOnSli:
		if fv, exists := v.FldValidators["advertise_choice.advertise_on_sli"]; exists {
			val := m.GetAdvertiseChoice().(*SSHManagementType_AdvertiseOnSli).AdvertiseOnSli
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("advertise_on_sli"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SSHManagementType_AdvertiseOnSlo:
		if fv, exists := v.FldValidators["advertise_choice.advertise_on_slo"]; exists {
			val := m.GetAdvertiseChoice().(*SSHManagementType_AdvertiseOnSlo).AdvertiseOnSlo
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("advertise_on_slo"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SSHManagementType_AdvertiseOnSloSli:
		if fv, exists := v.FldValidators["advertise_choice.advertise_on_slo_sli"]; exists {
			val := m.GetAdvertiseChoice().(*SSHManagementType_AdvertiseOnSloSli).AdvertiseOnSloSli
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("advertise_on_slo_sli"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["domain_suffix"]; exists {

		vOpts := append(opts, db.WithValidateField("domain_suffix"))
		if err := fv(ctx, m.GetDomainSuffix(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["node_ssh_ports"]; exists {
		vOpts := append(opts, db.WithValidateField("node_ssh_ports"))
		if err := fv(ctx, m.GetNodeSshPorts(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSSHManagementTypeValidator = func() *ValidateSSHManagementType {
	v := &ValidateSSHManagementType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNodeSshPorts := v.NodeSshPortsValidationRuleHandler
	rulesNodeSshPorts := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "2",
	}
	vFn, err = vrhNodeSshPorts(rulesNodeSshPorts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SSHManagementType.node_ssh_ports: %s", err)
		panic(errMsg)
	}
	v.FldValidators["node_ssh_ports"] = vFn

	vrhDomainSuffix := v.DomainSuffixValidationRuleHandler
	rulesDomainSuffix := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.hostname":  "true",
	}
	vFn, err = vrhDomainSuffix(rulesDomainSuffix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SSHManagementType.domain_suffix: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_suffix"] = vFn

	v.FldValidators["advertise_choice.advertise_on_public"] = ves_io_schema_views.AdvertisePublicValidator().Validate

	return v
}()

func SSHManagementTypeValidator() db.Validator {
	return DefaultSSHManagementTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ServiceHttpsManagementType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ServiceHttpsManagementType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ServiceHttpsManagementType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetAdvertiseOnSliVip().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ServiceHttpsManagementType.advertise_on_sli_vip")
	}

	if err := m.GetAdvertiseOnSloVip().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ServiceHttpsManagementType.advertise_on_slo_vip")
	}

	if err := m.GetAdvertiseOnSloSli().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ServiceHttpsManagementType.advertise_on_slo_sli")
	}

	if err := m.GetAdvertiseOnSloInternetVip().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ServiceHttpsManagementType.advertise_on_slo_internet_vip")
	}

	return nil
}

func (m *ServiceHttpsManagementType) DeepCopy() *ServiceHttpsManagementType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ServiceHttpsManagementType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ServiceHttpsManagementType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ServiceHttpsManagementType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ServiceHttpsManagementTypeValidator().Validate(ctx, m, opts...)
}

func (m *ServiceHttpsManagementType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAdvertiseChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAdvertiseChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetInternetChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetInternetChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *ServiceHttpsManagementType) GetAdvertiseChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAdvertiseChoice() == nil {
		return nil, nil
	}
	switch m.GetAdvertiseChoice().(type) {
	case *ServiceHttpsManagementType_AdvertiseOnSliVip:
		drInfos, err := m.GetAdvertiseOnSliVip().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAdvertiseOnSliVip().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "advertise_on_sli_vip." + dri.DRField
		}
		return drInfos, err

	case *ServiceHttpsManagementType_AdvertiseOnSloVip:
		drInfos, err := m.GetAdvertiseOnSloVip().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAdvertiseOnSloVip().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "advertise_on_slo_vip." + dri.DRField
		}
		return drInfos, err

	case *ServiceHttpsManagementType_AdvertiseOnSloSli:
		drInfos, err := m.GetAdvertiseOnSloSli().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAdvertiseOnSloSli().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "advertise_on_slo_sli." + dri.DRField
		}
		return drInfos, err

	case *ServiceHttpsManagementType_DisableLocal:

		return nil, nil

	case *ServiceHttpsManagementType_AdvertiseOnSloInternetVip:
		drInfos, err := m.GetAdvertiseOnSloInternetVip().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAdvertiseOnSloInternetVip().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "advertise_on_slo_internet_vip." + dri.DRField
		}
		return drInfos, err

	case *ServiceHttpsManagementType_DoNotAdvertiseOnInternet:

		return nil, nil

	case *ServiceHttpsManagementType_AdvertiseOnInternetDefaultVip:

		return nil, nil

	case *ServiceHttpsManagementType_AdvertiseOnInternet:
		drInfos, err := m.GetAdvertiseOnInternet().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAdvertiseOnInternet().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "advertise_on_internet." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *ServiceHttpsManagementType) GetInternetChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetInternetChoice() == nil {
		return nil, nil
	}
	switch m.GetInternetChoice().(type) {
	case *ServiceHttpsManagementType_DoNotAdvertise:

		return nil, nil

	case *ServiceHttpsManagementType_AdvertiseOnPublicDefaultVip:

		return nil, nil

	case *ServiceHttpsManagementType_AdvertiseOnPublic:
		drInfos, err := m.GetAdvertiseOnPublic().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAdvertiseOnPublic().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "advertise_on_public." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateServiceHttpsManagementType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateServiceHttpsManagementType) AdvertiseChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for advertise_choice")
	}
	return validatorFn, nil
}

func (v *ValidateServiceHttpsManagementType) PortChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port_choice")
	}
	return validatorFn, nil
}

func (v *ValidateServiceHttpsManagementType) PortChoiceHttpsPortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_HttpsPort, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for https_port")
	}
	return oValidatorFn_HttpsPort, nil
}

func (v *ValidateServiceHttpsManagementType) DomainSuffixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_suffix")
	}

	return validatorFn, nil
}

func (v *ValidateServiceHttpsManagementType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ServiceHttpsManagementType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ServiceHttpsManagementType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advertise_choice"]; exists {
		val := m.GetAdvertiseChoice()
		vOpts := append(opts,
			db.WithValidateField("advertise_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAdvertiseChoice().(type) {
	case *ServiceHttpsManagementType_AdvertiseOnSliVip:
		if fv, exists := v.FldValidators["advertise_choice.advertise_on_sli_vip"]; exists {
			val := m.GetAdvertiseChoice().(*ServiceHttpsManagementType_AdvertiseOnSliVip).AdvertiseOnSliVip
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("advertise_on_sli_vip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ServiceHttpsManagementType_AdvertiseOnSloVip:
		if fv, exists := v.FldValidators["advertise_choice.advertise_on_slo_vip"]; exists {
			val := m.GetAdvertiseChoice().(*ServiceHttpsManagementType_AdvertiseOnSloVip).AdvertiseOnSloVip
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("advertise_on_slo_vip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ServiceHttpsManagementType_AdvertiseOnSloSli:
		if fv, exists := v.FldValidators["advertise_choice.advertise_on_slo_sli"]; exists {
			val := m.GetAdvertiseChoice().(*ServiceHttpsManagementType_AdvertiseOnSloSli).AdvertiseOnSloSli
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("advertise_on_slo_sli"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ServiceHttpsManagementType_DisableLocal:
		if fv, exists := v.FldValidators["advertise_choice.disable_local"]; exists {
			val := m.GetAdvertiseChoice().(*ServiceHttpsManagementType_DisableLocal).DisableLocal
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("disable_local"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ServiceHttpsManagementType_AdvertiseOnSloInternetVip:
		if fv, exists := v.FldValidators["advertise_choice.advertise_on_slo_internet_vip"]; exists {
			val := m.GetAdvertiseChoice().(*ServiceHttpsManagementType_AdvertiseOnSloInternetVip).AdvertiseOnSloInternetVip
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("advertise_on_slo_internet_vip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ServiceHttpsManagementType_DoNotAdvertiseOnInternet:
		if fv, exists := v.FldValidators["advertise_choice.do_not_advertise_on_internet"]; exists {
			val := m.GetAdvertiseChoice().(*ServiceHttpsManagementType_DoNotAdvertiseOnInternet).DoNotAdvertiseOnInternet
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("do_not_advertise_on_internet"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ServiceHttpsManagementType_AdvertiseOnInternetDefaultVip:
		if fv, exists := v.FldValidators["advertise_choice.advertise_on_internet_default_vip"]; exists {
			val := m.GetAdvertiseChoice().(*ServiceHttpsManagementType_AdvertiseOnInternetDefaultVip).AdvertiseOnInternetDefaultVip
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("advertise_on_internet_default_vip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ServiceHttpsManagementType_AdvertiseOnInternet:
		if fv, exists := v.FldValidators["advertise_choice.advertise_on_internet"]; exists {
			val := m.GetAdvertiseChoice().(*ServiceHttpsManagementType_AdvertiseOnInternet).AdvertiseOnInternet
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("advertise_on_internet"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["domain_suffix"]; exists {

		vOpts := append(opts, db.WithValidateField("domain_suffix"))
		if err := fv(ctx, m.GetDomainSuffix(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetInternetChoice().(type) {
	case *ServiceHttpsManagementType_DoNotAdvertise:
		if fv, exists := v.FldValidators["internet_choice.do_not_advertise"]; exists {
			val := m.GetInternetChoice().(*ServiceHttpsManagementType_DoNotAdvertise).DoNotAdvertise
			vOpts := append(opts,
				db.WithValidateField("internet_choice"),
				db.WithValidateField("do_not_advertise"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ServiceHttpsManagementType_AdvertiseOnPublicDefaultVip:
		if fv, exists := v.FldValidators["internet_choice.advertise_on_public_default_vip"]; exists {
			val := m.GetInternetChoice().(*ServiceHttpsManagementType_AdvertiseOnPublicDefaultVip).AdvertiseOnPublicDefaultVip
			vOpts := append(opts,
				db.WithValidateField("internet_choice"),
				db.WithValidateField("advertise_on_public_default_vip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ServiceHttpsManagementType_AdvertiseOnPublic:
		if fv, exists := v.FldValidators["internet_choice.advertise_on_public"]; exists {
			val := m.GetInternetChoice().(*ServiceHttpsManagementType_AdvertiseOnPublic).AdvertiseOnPublic
			vOpts := append(opts,
				db.WithValidateField("internet_choice"),
				db.WithValidateField("advertise_on_public"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["port_choice"]; exists {
		val := m.GetPortChoice()
		vOpts := append(opts,
			db.WithValidateField("port_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPortChoice().(type) {
	case *ServiceHttpsManagementType_DefaultHttpsPort:
		if fv, exists := v.FldValidators["port_choice.default_https_port"]; exists {
			val := m.GetPortChoice().(*ServiceHttpsManagementType_DefaultHttpsPort).DefaultHttpsPort
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("default_https_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ServiceHttpsManagementType_HttpsPort:
		if fv, exists := v.FldValidators["port_choice.https_port"]; exists {
			val := m.GetPortChoice().(*ServiceHttpsManagementType_HttpsPort).HttpsPort
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("https_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultServiceHttpsManagementTypeValidator = func() *ValidateServiceHttpsManagementType {
	v := &ValidateServiceHttpsManagementType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAdvertiseChoice := v.AdvertiseChoiceValidationRuleHandler
	rulesAdvertiseChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAdvertiseChoice(rulesAdvertiseChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceHttpsManagementType.advertise_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["advertise_choice"] = vFn

	vrhPortChoice := v.PortChoiceValidationRuleHandler
	rulesPortChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPortChoice(rulesPortChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceHttpsManagementType.port_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port_choice"] = vFn

	vrhPortChoiceHttpsPort := v.PortChoiceHttpsPortValidationRuleHandler
	rulesPortChoiceHttpsPort := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFnMap["port_choice.https_port"], err = vrhPortChoiceHttpsPort(rulesPortChoiceHttpsPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ServiceHttpsManagementType.port_choice_https_port: %s", err)
		panic(errMsg)
	}

	v.FldValidators["port_choice.https_port"] = vFnMap["port_choice.https_port"]

	vrhDomainSuffix := v.DomainSuffixValidationRuleHandler
	rulesDomainSuffix := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.hostname":  "true",
	}
	vFn, err = vrhDomainSuffix(rulesDomainSuffix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceHttpsManagementType.domain_suffix: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_suffix"] = vFn

	v.FldValidators["advertise_choice.advertise_on_sli_vip"] = ves_io_schema_views.DownstreamTlsParamsTypeValidator().Validate
	v.FldValidators["advertise_choice.advertise_on_slo_vip"] = ves_io_schema_views.DownstreamTlsParamsTypeValidator().Validate
	v.FldValidators["advertise_choice.advertise_on_slo_sli"] = ves_io_schema_views.DownstreamTlsParamsTypeValidator().Validate
	v.FldValidators["advertise_choice.advertise_on_slo_internet_vip"] = ves_io_schema_views.DownstreamTlsParamsTypeValidator().Validate
	v.FldValidators["advertise_choice.advertise_on_internet"] = ves_io_schema_views.AdvertisePublicValidator().Validate

	v.FldValidators["internet_choice.advertise_on_public"] = ves_io_schema_views.AdvertisePublicValidator().Validate

	return v
}()

func ServiceHttpsManagementTypeValidator() db.Validator {
	return DefaultServiceHttpsManagementTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ServiceNodesAWSType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ServiceNodesAWSType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ServiceNodesAWSType) DeepCopy() *ServiceNodesAWSType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ServiceNodesAWSType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ServiceNodesAWSType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ServiceNodesAWSType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ServiceNodesAWSTypeValidator().Validate(ctx, m, opts...)
}

type ValidateServiceNodesAWSType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateServiceNodesAWSType) MgmtSubnetChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mgmt_subnet_choice")
	}
	return validatorFn, nil
}

func (v *ValidateServiceNodesAWSType) TunnelPrefixChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_prefix_choice")
	}
	return validatorFn, nil
}

func (v *ValidateServiceNodesAWSType) TunnelPrefixChoiceTunnelPrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_TunnelPrefix, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_prefix")
	}
	return oValidatorFn_TunnelPrefix, nil
}

func (v *ValidateServiceNodesAWSType) NodeNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node_name")
	}

	return validatorFn, nil
}

func (v *ValidateServiceNodesAWSType) AwsAzNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for aws_az_name")
	}

	return validatorFn, nil
}

func (v *ValidateServiceNodesAWSType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ServiceNodesAWSType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ServiceNodesAWSType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aws_az_name"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_az_name"))
		if err := fv(ctx, m.GetAwsAzName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mgmt_subnet_choice"]; exists {
		val := m.GetMgmtSubnetChoice()
		vOpts := append(opts,
			db.WithValidateField("mgmt_subnet_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMgmtSubnetChoice().(type) {
	case *ServiceNodesAWSType_ReservedMgmtSubnet:
		if fv, exists := v.FldValidators["mgmt_subnet_choice.reserved_mgmt_subnet"]; exists {
			val := m.GetMgmtSubnetChoice().(*ServiceNodesAWSType_ReservedMgmtSubnet).ReservedMgmtSubnet
			vOpts := append(opts,
				db.WithValidateField("mgmt_subnet_choice"),
				db.WithValidateField("reserved_mgmt_subnet"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ServiceNodesAWSType_MgmtSubnet:
		if fv, exists := v.FldValidators["mgmt_subnet_choice.mgmt_subnet"]; exists {
			val := m.GetMgmtSubnetChoice().(*ServiceNodesAWSType_MgmtSubnet).MgmtSubnet
			vOpts := append(opts,
				db.WithValidateField("mgmt_subnet_choice"),
				db.WithValidateField("mgmt_subnet"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["node_name"]; exists {

		vOpts := append(opts, db.WithValidateField("node_name"))
		if err := fv(ctx, m.GetNodeName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_prefix_choice"]; exists {
		val := m.GetTunnelPrefixChoice()
		vOpts := append(opts,
			db.WithValidateField("tunnel_prefix_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetTunnelPrefixChoice().(type) {
	case *ServiceNodesAWSType_AutomaticPrefix:
		if fv, exists := v.FldValidators["tunnel_prefix_choice.automatic_prefix"]; exists {
			val := m.GetTunnelPrefixChoice().(*ServiceNodesAWSType_AutomaticPrefix).AutomaticPrefix
			vOpts := append(opts,
				db.WithValidateField("tunnel_prefix_choice"),
				db.WithValidateField("automatic_prefix"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ServiceNodesAWSType_TunnelPrefix:
		if fv, exists := v.FldValidators["tunnel_prefix_choice.tunnel_prefix"]; exists {
			val := m.GetTunnelPrefixChoice().(*ServiceNodesAWSType_TunnelPrefix).TunnelPrefix
			vOpts := append(opts,
				db.WithValidateField("tunnel_prefix_choice"),
				db.WithValidateField("tunnel_prefix"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultServiceNodesAWSTypeValidator = func() *ValidateServiceNodesAWSType {
	v := &ValidateServiceNodesAWSType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMgmtSubnetChoice := v.MgmtSubnetChoiceValidationRuleHandler
	rulesMgmtSubnetChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMgmtSubnetChoice(rulesMgmtSubnetChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceNodesAWSType.mgmt_subnet_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mgmt_subnet_choice"] = vFn

	vrhTunnelPrefixChoice := v.TunnelPrefixChoiceValidationRuleHandler
	rulesTunnelPrefixChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhTunnelPrefixChoice(rulesTunnelPrefixChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceNodesAWSType.tunnel_prefix_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_prefix_choice"] = vFn

	vrhTunnelPrefixChoiceTunnelPrefix := v.TunnelPrefixChoiceTunnelPrefixValidationRuleHandler
	rulesTunnelPrefixChoiceTunnelPrefix := map[string]string{
		"ves.io.schema.rules.string.ipv4_prefix": "true",
	}
	vFnMap["tunnel_prefix_choice.tunnel_prefix"], err = vrhTunnelPrefixChoiceTunnelPrefix(rulesTunnelPrefixChoiceTunnelPrefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ServiceNodesAWSType.tunnel_prefix_choice_tunnel_prefix: %s", err)
		panic(errMsg)
	}

	v.FldValidators["tunnel_prefix_choice.tunnel_prefix"] = vFnMap["tunnel_prefix_choice.tunnel_prefix"]

	vrhNodeName := v.NodeNameValidationRuleHandler
	rulesNodeName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.hostname":  "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhNodeName(rulesNodeName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceNodesAWSType.node_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["node_name"] = vFn

	vrhAwsAzName := v.AwsAzNameValidationRuleHandler
	rulesAwsAzName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.pattern":   "^([a-z]{2})-([a-z0-9]{4,20})-([a-z0-9]{2})$",
	}
	vFn, err = vrhAwsAzName(rulesAwsAzName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceNodesAWSType.aws_az_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["aws_az_name"] = vFn

	v.FldValidators["mgmt_subnet_choice.mgmt_subnet"] = ves_io_schema_views.CloudSubnetTypeValidator().Validate

	return v
}()

func ServiceNodesAWSTypeValidator() db.Validator {
	return DefaultServiceNodesAWSTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ServiceNodesBareMetalType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ServiceNodesBareMetalType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ServiceNodesBareMetalType) DeepCopy() *ServiceNodesBareMetalType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ServiceNodesBareMetalType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ServiceNodesBareMetalType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ServiceNodesBareMetalType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ServiceNodesBareMetalTypeValidator().Validate(ctx, m, opts...)
}

func (m *ServiceNodesBareMetalType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetExternalInterfaceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetExternalInterfaceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetInternalInterfaceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetInternalInterfaceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *ServiceNodesBareMetalType) GetExternalInterfaceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetExternalInterface() == nil {
		return nil, nil
	}

	drInfos, err := m.GetExternalInterface().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetExternalInterface().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "external_interface." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *ServiceNodesBareMetalType) GetInternalInterfaceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetInternalInterface() == nil {
		return nil, nil
	}

	drInfos, err := m.GetInternalInterface().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetInternalInterface().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "internal_interface." + dri.DRField
	}
	return drInfos, err

}

type ValidateServiceNodesBareMetalType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateServiceNodesBareMetalType) NodeNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node_name")
	}

	return validatorFn, nil
}

func (v *ValidateServiceNodesBareMetalType) BmVirtualCpuCountValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(BMNodeVirtualCpuCount)
		return int32(i)
	}
	// BMNodeVirtualCpuCount_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, BMNodeVirtualCpuCount_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bm_virtual_cpu_count")
	}

	return validatorFn, nil
}

func (v *ValidateServiceNodesBareMetalType) BmNodeMemorySizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(BMNodeMemorySize)
		return int32(i)
	}
	// BMNodeMemorySize_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, BMNodeMemorySize_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bm_node_memory_size")
	}

	return validatorFn, nil
}

func (v *ValidateServiceNodesBareMetalType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ServiceNodesBareMetalType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ServiceNodesBareMetalType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["bm_node_memory_size"]; exists {

		vOpts := append(opts, db.WithValidateField("bm_node_memory_size"))
		if err := fv(ctx, m.GetBmNodeMemorySize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bm_virtual_cpu_count"]; exists {

		vOpts := append(opts, db.WithValidateField("bm_virtual_cpu_count"))
		if err := fv(ctx, m.GetBmVirtualCpuCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["external_interface"]; exists {

		vOpts := append(opts, db.WithValidateField("external_interface"))
		if err := fv(ctx, m.GetExternalInterface(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["internal_interface"]; exists {

		vOpts := append(opts, db.WithValidateField("internal_interface"))
		if err := fv(ctx, m.GetInternalInterface(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["node_name"]; exists {

		vOpts := append(opts, db.WithValidateField("node_name"))
		if err := fv(ctx, m.GetNodeName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultServiceNodesBareMetalTypeValidator = func() *ValidateServiceNodesBareMetalType {
	v := &ValidateServiceNodesBareMetalType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNodeName := v.NodeNameValidationRuleHandler
	rulesNodeName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.hostname":  "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhNodeName(rulesNodeName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceNodesBareMetalType.node_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["node_name"] = vFn

	vrhBmVirtualCpuCount := v.BmVirtualCpuCountValidationRuleHandler
	rulesBmVirtualCpuCount := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhBmVirtualCpuCount(rulesBmVirtualCpuCount)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceNodesBareMetalType.bm_virtual_cpu_count: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bm_virtual_cpu_count"] = vFn

	vrhBmNodeMemorySize := v.BmNodeMemorySizeValidationRuleHandler
	rulesBmNodeMemorySize := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhBmNodeMemorySize(rulesBmNodeMemorySize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceNodesBareMetalType.bm_node_memory_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bm_node_memory_size"] = vFn

	v.FldValidators["internal_interface"] = InterfaceDetailsValidator().Validate

	v.FldValidators["external_interface"] = InterfaceDetailsValidator().Validate

	return v
}()

func ServiceNodesBareMetalTypeValidator() db.Validator {
	return DefaultServiceNodesBareMetalTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SuggestedCommands) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SuggestedCommands) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SuggestedCommands) DeepCopy() *SuggestedCommands {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SuggestedCommands{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SuggestedCommands) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SuggestedCommands) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SuggestedCommandsValidator().Validate(ctx, m, opts...)
}

type ValidateSuggestedCommands struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSuggestedCommands) CommandValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for command")
	}

	return validatorFn, nil
}

func (v *ValidateSuggestedCommands) DescriptionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for description")
	}

	return validatorFn, nil
}

func (v *ValidateSuggestedCommands) WarningValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for warning")
	}

	return validatorFn, nil
}

func (v *ValidateSuggestedCommands) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SuggestedCommands)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SuggestedCommands got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["command"]; exists {

		vOpts := append(opts, db.WithValidateField("command"))
		if err := fv(ctx, m.GetCommand(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["warning"]; exists {

		vOpts := append(opts, db.WithValidateField("warning"))
		if err := fv(ctx, m.GetWarning(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSuggestedCommandsValidator = func() *ValidateSuggestedCommands {
	v := &ValidateSuggestedCommands{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCommand := v.CommandValidationRuleHandler
	rulesCommand := map[string]string{
		"ves.io.schema.rules.string.max_len": "1024",
	}
	vFn, err = vrhCommand(rulesCommand)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SuggestedCommands.command: %s", err)
		panic(errMsg)
	}
	v.FldValidators["command"] = vFn

	vrhDescription := v.DescriptionValidationRuleHandler
	rulesDescription := map[string]string{
		"ves.io.schema.rules.string.max_len": "8192",
	}
	vFn, err = vrhDescription(rulesDescription)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SuggestedCommands.description: %s", err)
		panic(errMsg)
	}
	v.FldValidators["description"] = vFn

	vrhWarning := v.WarningValidationRuleHandler
	rulesWarning := map[string]string{
		"ves.io.schema.rules.string.max_len": "1024",
	}
	vFn, err = vrhWarning(rulesWarning)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SuggestedCommands.warning: %s", err)
		panic(errMsg)
	}
	v.FldValidators["warning"] = vFn

	return v
}()

func SuggestedCommandsValidator() db.Validator {
	return DefaultSuggestedCommandsValidator
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetHttpManagementChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.HttpManagementChoice.(type) {
	case nil:
		o.HttpManagementChoice = nil

	case *CreateSpecType_DisableHttpsManagement:
		o.HttpManagementChoice = &GlobalSpecType_DisableHttpsManagement{DisableHttpsManagement: of.DisableHttpsManagement}

	case *CreateSpecType_HttpsManagement:
		o.HttpManagementChoice = &GlobalSpecType_HttpsManagement{HttpsManagement: of.HttpsManagement}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetHttpManagementChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.HttpManagementChoice.(type) {
	case nil:
		r.HttpManagementChoice = nil

	case *GlobalSpecType_DisableHttpsManagement:
		r.HttpManagementChoice = &CreateSpecType_DisableHttpsManagement{DisableHttpsManagement: of.DisableHttpsManagement}

	case *GlobalSpecType_HttpsManagement:
		r.HttpManagementChoice = &CreateSpecType_HttpsManagement{HttpsManagement: of.HttpsManagement}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetServiceProviderChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ServiceProviderChoice.(type) {
	case nil:
		o.ServiceProviderChoice = nil

	case *CreateSpecType_F5BigIpAwsService:
		o.ServiceProviderChoice = &GlobalSpecType_F5BigIpAwsService{F5BigIpAwsService: of.F5BigIpAwsService}

	case *CreateSpecType_PaloAltoFwService:
		o.ServiceProviderChoice = &GlobalSpecType_PaloAltoFwService{PaloAltoFwService: of.PaloAltoFwService}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetServiceProviderChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ServiceProviderChoice.(type) {
	case nil:
		r.ServiceProviderChoice = nil

	case *GlobalSpecType_F5BigIpAwsService:
		r.ServiceProviderChoice = &CreateSpecType_F5BigIpAwsService{F5BigIpAwsService: of.F5BigIpAwsService}

	case *GlobalSpecType_PaloAltoFwService:
		r.ServiceProviderChoice = &CreateSpecType_PaloAltoFwService{PaloAltoFwService: of.PaloAltoFwService}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetSshManagementChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.SshManagementChoice.(type) {
	case nil:
		o.SshManagementChoice = nil

	case *CreateSpecType_DisableSshAccess:
		o.SshManagementChoice = &GlobalSpecType_DisableSshAccess{DisableSshAccess: of.DisableSshAccess}

	case *CreateSpecType_EnabledSshAccess:
		o.SshManagementChoice = &GlobalSpecType_EnabledSshAccess{EnabledSshAccess: of.EnabledSshAccess}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetSshManagementChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.SshManagementChoice.(type) {
	case nil:
		r.SshManagementChoice = nil

	case *GlobalSpecType_DisableSshAccess:
		r.SshManagementChoice = &CreateSpecType_DisableSshAccess{DisableSshAccess: of.DisableSshAccess}

	case *GlobalSpecType_EnabledSshAccess:
		r.SshManagementChoice = &CreateSpecType_EnabledSshAccess{EnabledSshAccess: of.EnabledSshAccess}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *CreateSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.GetHttpManagementChoiceFromGlobalSpecType(f)
	m.GetServiceProviderChoiceFromGlobalSpecType(f)
	m.GetSshManagementChoiceFromGlobalSpecType(f)
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *CreateSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *CreateSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	m1.SetHttpManagementChoiceToGlobalSpecType(f)
	m1.SetServiceProviderChoiceToGlobalSpecType(f)
	m1.SetSshManagementChoiceToGlobalSpecType(f)
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *CreateSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in EndpointServiceReplaceType from EndpointServiceType for oneof fields
func (r *EndpointServiceReplaceType) SetExternalVipChoiceToEndpointServiceType(o *EndpointServiceType) error {
	switch of := r.ExternalVipChoice.(type) {
	case nil:
		o.ExternalVipChoice = nil

	case *EndpointServiceReplaceType_AdvertiseOnSloIp:
		o.ExternalVipChoice = &EndpointServiceType_AdvertiseOnSloIp{AdvertiseOnSloIp: of.AdvertiseOnSloIp}

	case *EndpointServiceReplaceType_AdvertiseOnSloIpExternal:
		o.ExternalVipChoice = &EndpointServiceType_AdvertiseOnSloIpExternal{AdvertiseOnSloIpExternal: of.AdvertiseOnSloIpExternal}

	case *EndpointServiceReplaceType_DisableAdvertiseOnSloIp:
		o.ExternalVipChoice = &EndpointServiceType_DisableAdvertiseOnSloIp{DisableAdvertiseOnSloIp: of.DisableAdvertiseOnSloIp}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *EndpointServiceReplaceType) GetExternalVipChoiceFromEndpointServiceType(o *EndpointServiceType) error {
	switch of := o.ExternalVipChoice.(type) {
	case nil:
		r.ExternalVipChoice = nil

	case *EndpointServiceType_AdvertiseOnSloIp:
		r.ExternalVipChoice = &EndpointServiceReplaceType_AdvertiseOnSloIp{AdvertiseOnSloIp: of.AdvertiseOnSloIp}

	case *EndpointServiceType_AdvertiseOnSloIpExternal:
		r.ExternalVipChoice = &EndpointServiceReplaceType_AdvertiseOnSloIpExternal{AdvertiseOnSloIpExternal: of.AdvertiseOnSloIpExternal}

	case *EndpointServiceType_DisableAdvertiseOnSloIp:
		r.ExternalVipChoice = &EndpointServiceReplaceType_DisableAdvertiseOnSloIp{DisableAdvertiseOnSloIp: of.DisableAdvertiseOnSloIp}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in EndpointServiceReplaceType from EndpointServiceType for oneof fields
func (r *EndpointServiceReplaceType) SetTcpPortChoiceToEndpointServiceType(o *EndpointServiceType) error {
	switch of := r.TcpPortChoice.(type) {
	case nil:
		o.TcpPortChoice = nil

	case *EndpointServiceReplaceType_CustomTcpPorts:
		o.TcpPortChoice = &EndpointServiceType_CustomTcpPorts{CustomTcpPorts: of.CustomTcpPorts}

	case *EndpointServiceReplaceType_DefaultTcpPorts:
		o.TcpPortChoice = &EndpointServiceType_DefaultTcpPorts{DefaultTcpPorts: of.DefaultTcpPorts}

	case *EndpointServiceReplaceType_HttpPort:
		o.TcpPortChoice = &EndpointServiceType_HttpPort{HttpPort: of.HttpPort}

	case *EndpointServiceReplaceType_HttpsPort:
		o.TcpPortChoice = &EndpointServiceType_HttpsPort{HttpsPort: of.HttpsPort}

	case *EndpointServiceReplaceType_NoTcpPorts:
		o.TcpPortChoice = &EndpointServiceType_NoTcpPorts{NoTcpPorts: of.NoTcpPorts}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *EndpointServiceReplaceType) GetTcpPortChoiceFromEndpointServiceType(o *EndpointServiceType) error {
	switch of := o.TcpPortChoice.(type) {
	case nil:
		r.TcpPortChoice = nil

	case *EndpointServiceType_CustomTcpPorts:
		r.TcpPortChoice = &EndpointServiceReplaceType_CustomTcpPorts{CustomTcpPorts: of.CustomTcpPorts}

	case *EndpointServiceType_DefaultTcpPorts:
		r.TcpPortChoice = &EndpointServiceReplaceType_DefaultTcpPorts{DefaultTcpPorts: of.DefaultTcpPorts}

	case *EndpointServiceType_HttpPort:
		r.TcpPortChoice = &EndpointServiceReplaceType_HttpPort{HttpPort: of.HttpPort}

	case *EndpointServiceType_HttpsPort:
		r.TcpPortChoice = &EndpointServiceReplaceType_HttpsPort{HttpsPort: of.HttpsPort}

	case *EndpointServiceType_NoTcpPorts:
		r.TcpPortChoice = &EndpointServiceReplaceType_NoTcpPorts{NoTcpPorts: of.NoTcpPorts}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in EndpointServiceReplaceType from EndpointServiceType for oneof fields
func (r *EndpointServiceReplaceType) SetUdpPortChoiceToEndpointServiceType(o *EndpointServiceType) error {
	switch of := r.UdpPortChoice.(type) {
	case nil:
		o.UdpPortChoice = nil

	case *EndpointServiceReplaceType_CustomUdpPorts:
		o.UdpPortChoice = &EndpointServiceType_CustomUdpPorts{CustomUdpPorts: of.CustomUdpPorts}

	case *EndpointServiceReplaceType_NoUdpPorts:
		o.UdpPortChoice = &EndpointServiceType_NoUdpPorts{NoUdpPorts: of.NoUdpPorts}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *EndpointServiceReplaceType) GetUdpPortChoiceFromEndpointServiceType(o *EndpointServiceType) error {
	switch of := o.UdpPortChoice.(type) {
	case nil:
		r.UdpPortChoice = nil

	case *EndpointServiceType_CustomUdpPorts:
		r.UdpPortChoice = &EndpointServiceReplaceType_CustomUdpPorts{CustomUdpPorts: of.CustomUdpPorts}

	case *EndpointServiceType_NoUdpPorts:
		r.UdpPortChoice = &EndpointServiceReplaceType_NoUdpPorts{NoUdpPorts: of.NoUdpPorts}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *EndpointServiceReplaceType) fromEndpointServiceType(f *EndpointServiceType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.GetExternalVipChoiceFromEndpointServiceType(f)
	m.GetTcpPortChoiceFromEndpointServiceType(f)
	m.GetUdpPortChoiceFromEndpointServiceType(f)
}

func (m *EndpointServiceReplaceType) FromEndpointServiceType(f *EndpointServiceType) {
	m.fromEndpointServiceType(f, true)
}

func (m *EndpointServiceReplaceType) FromEndpointServiceTypeWithoutDeepCopy(f *EndpointServiceType) {
	m.fromEndpointServiceType(f, false)
}

func (m *EndpointServiceReplaceType) toEndpointServiceType(f *EndpointServiceType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	m1.SetExternalVipChoiceToEndpointServiceType(f)
	m1.SetTcpPortChoiceToEndpointServiceType(f)
	m1.SetUdpPortChoiceToEndpointServiceType(f)
}

func (m *EndpointServiceReplaceType) ToEndpointServiceType(f *EndpointServiceType) {
	m.toEndpointServiceType(f, true)
}

func (m *EndpointServiceReplaceType) ToEndpointServiceTypeWithoutDeepCopy(f *EndpointServiceType) {
	m.toEndpointServiceType(f, false)
}

func (m *F5BigIpAWSReplaceType) fromF5BigIpAWSType(f *F5BigIpAWSType, withDeepCopy bool) {
	if f == nil {
		return
	}

	if f.GetEndpointService() != nil {
		if m.EndpointService == nil {
			m.EndpointService = &EndpointServiceReplaceType{}
		}
		m.EndpointService.FromEndpointServiceTypeWithoutDeepCopy(f.GetEndpointService())
	} else {
		m.EndpointService = nil
	}

	m.Tags = f.GetTags()
}

func (m *F5BigIpAWSReplaceType) FromF5BigIpAWSType(f *F5BigIpAWSType) {
	m.fromF5BigIpAWSType(f, true)
}

func (m *F5BigIpAWSReplaceType) FromF5BigIpAWSTypeWithoutDeepCopy(f *F5BigIpAWSType) {
	m.fromF5BigIpAWSType(f, false)
}

func (m *F5BigIpAWSReplaceType) toF5BigIpAWSType(f *F5BigIpAWSType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	if m1.EndpointService != nil {
		if f.EndpointService == nil {
			f.EndpointService = &EndpointServiceType{}
		}
	} else if f.EndpointService != nil {
		f.EndpointService = nil
	}

	if m1.EndpointService != nil {
		m1.EndpointService.ToEndpointServiceTypeWithoutDeepCopy(f.EndpointService)
	}

	f.Tags = m1.Tags
}

func (m *F5BigIpAWSReplaceType) ToF5BigIpAWSType(f *F5BigIpAWSType) {
	m.toF5BigIpAWSType(f, true)
}

func (m *F5BigIpAWSReplaceType) ToF5BigIpAWSTypeWithoutDeepCopy(f *F5BigIpAWSType) {
	m.toF5BigIpAWSType(f, false)
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetHttpManagementChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.HttpManagementChoice.(type) {
	case nil:
		o.HttpManagementChoice = nil

	case *GetSpecType_DisableHttpsManagement:
		o.HttpManagementChoice = &GlobalSpecType_DisableHttpsManagement{DisableHttpsManagement: of.DisableHttpsManagement}

	case *GetSpecType_HttpsManagement:
		o.HttpManagementChoice = &GlobalSpecType_HttpsManagement{HttpsManagement: of.HttpsManagement}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetHttpManagementChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.HttpManagementChoice.(type) {
	case nil:
		r.HttpManagementChoice = nil

	case *GlobalSpecType_DisableHttpsManagement:
		r.HttpManagementChoice = &GetSpecType_DisableHttpsManagement{DisableHttpsManagement: of.DisableHttpsManagement}

	case *GlobalSpecType_HttpsManagement:
		r.HttpManagementChoice = &GetSpecType_HttpsManagement{HttpsManagement: of.HttpsManagement}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetServiceProviderChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ServiceProviderChoice.(type) {
	case nil:
		o.ServiceProviderChoice = nil

	case *GetSpecType_F5BigIpAwsService:
		o.ServiceProviderChoice = &GlobalSpecType_F5BigIpAwsService{F5BigIpAwsService: of.F5BigIpAwsService}

	case *GetSpecType_PaloAltoFwService:
		o.ServiceProviderChoice = &GlobalSpecType_PaloAltoFwService{PaloAltoFwService: of.PaloAltoFwService}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetServiceProviderChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ServiceProviderChoice.(type) {
	case nil:
		r.ServiceProviderChoice = nil

	case *GlobalSpecType_F5BigIpAwsService:
		r.ServiceProviderChoice = &GetSpecType_F5BigIpAwsService{F5BigIpAwsService: of.F5BigIpAwsService}

	case *GlobalSpecType_PaloAltoFwService:
		r.ServiceProviderChoice = &GetSpecType_PaloAltoFwService{PaloAltoFwService: of.PaloAltoFwService}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetServiceTypeChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ServiceTypeChoice.(type) {
	case nil:
		o.ServiceTypeChoice = nil

	case *GetSpecType_EndpointService:
		o.ServiceTypeChoice = &GlobalSpecType_EndpointService{EndpointService: of.EndpointService}

	case *GetSpecType_ForwardingService:
		o.ServiceTypeChoice = &GlobalSpecType_ForwardingService{ForwardingService: of.ForwardingService}

	case *GetSpecType_TransparentService:
		o.ServiceTypeChoice = &GlobalSpecType_TransparentService{TransparentService: of.TransparentService}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetServiceTypeChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ServiceTypeChoice.(type) {
	case nil:
		r.ServiceTypeChoice = nil

	case *GlobalSpecType_EndpointService:
		r.ServiceTypeChoice = &GetSpecType_EndpointService{EndpointService: of.EndpointService}

	case *GlobalSpecType_ForwardingService:
		r.ServiceTypeChoice = &GetSpecType_ForwardingService{ForwardingService: of.ForwardingService}

	case *GlobalSpecType_TransparentService:
		r.ServiceTypeChoice = &GetSpecType_TransparentService{TransparentService: of.TransparentService}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetSshManagementChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.SshManagementChoice.(type) {
	case nil:
		o.SshManagementChoice = nil

	case *GetSpecType_DisableSshAccess:
		o.SshManagementChoice = &GlobalSpecType_DisableSshAccess{DisableSshAccess: of.DisableSshAccess}

	case *GetSpecType_EnabledSshAccess:
		o.SshManagementChoice = &GlobalSpecType_EnabledSshAccess{EnabledSshAccess: of.EnabledSshAccess}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetSshManagementChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.SshManagementChoice.(type) {
	case nil:
		r.SshManagementChoice = nil

	case *GlobalSpecType_DisableSshAccess:
		r.SshManagementChoice = &GetSpecType_DisableSshAccess{DisableSshAccess: of.DisableSshAccess}

	case *GlobalSpecType_EnabledSshAccess:
		r.SshManagementChoice = &GetSpecType_EnabledSshAccess{EnabledSshAccess: of.EnabledSshAccess}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *GetSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.Commands = f.GetCommands()
	m.FinalizerTimestamp = f.GetFinalizerTimestamp()
	m.ForceDelete = f.GetForceDelete()
	m.GetHttpManagementChoiceFromGlobalSpecType(f)
	m.GetServiceProviderChoiceFromGlobalSpecType(f)
	m.GetServiceTypeChoiceFromGlobalSpecType(f)
	m.GetSshManagementChoiceFromGlobalSpecType(f)
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *GetSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *GetSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.Commands = m1.Commands
	f.FinalizerTimestamp = m1.FinalizerTimestamp
	f.ForceDelete = m1.ForceDelete
	m1.SetHttpManagementChoiceToGlobalSpecType(f)
	m1.SetServiceProviderChoiceToGlobalSpecType(f)
	m1.SetServiceTypeChoiceToGlobalSpecType(f)
	m1.SetSshManagementChoiceToGlobalSpecType(f)
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *GetSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

func (m *PaloAltoFWAWSReplaceType) fromPaloAltoFWAWSType(f *PaloAltoFWAWSType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.Tags = f.GetTags()
}

func (m *PaloAltoFWAWSReplaceType) FromPaloAltoFWAWSType(f *PaloAltoFWAWSType) {
	m.fromPaloAltoFWAWSType(f, true)
}

func (m *PaloAltoFWAWSReplaceType) FromPaloAltoFWAWSTypeWithoutDeepCopy(f *PaloAltoFWAWSType) {
	m.fromPaloAltoFWAWSType(f, false)
}

func (m *PaloAltoFWAWSReplaceType) toPaloAltoFWAWSType(f *PaloAltoFWAWSType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.Tags = m1.Tags
}

func (m *PaloAltoFWAWSReplaceType) ToPaloAltoFWAWSType(f *PaloAltoFWAWSType) {
	m.toPaloAltoFWAWSType(f, true)
}

func (m *PaloAltoFWAWSReplaceType) ToPaloAltoFWAWSTypeWithoutDeepCopy(f *PaloAltoFWAWSType) {
	m.toPaloAltoFWAWSType(f, false)
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetHttpManagementChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.HttpManagementChoice.(type) {
	case nil:
		o.HttpManagementChoice = nil

	case *ReplaceSpecType_DisableHttpsManagement:
		o.HttpManagementChoice = &GlobalSpecType_DisableHttpsManagement{DisableHttpsManagement: of.DisableHttpsManagement}

	case *ReplaceSpecType_HttpsManagement:
		o.HttpManagementChoice = &GlobalSpecType_HttpsManagement{HttpsManagement: of.HttpsManagement}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetHttpManagementChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.HttpManagementChoice.(type) {
	case nil:
		r.HttpManagementChoice = nil

	case *GlobalSpecType_DisableHttpsManagement:
		r.HttpManagementChoice = &ReplaceSpecType_DisableHttpsManagement{DisableHttpsManagement: of.DisableHttpsManagement}

	case *GlobalSpecType_HttpsManagement:
		r.HttpManagementChoice = &ReplaceSpecType_HttpsManagement{HttpsManagement: of.HttpsManagement}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetServiceProviderChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ServiceProviderChoice.(type) {
	case nil:
		o.ServiceProviderChoice = nil

	case *ReplaceSpecType_F5BigIpAwsService:

		f1 := o.GetF5BigIpAwsService()
		if f1 == nil {
			f1 = &F5BigIpAWSType{}
		}
		of.F5BigIpAwsService.ToF5BigIpAWSTypeWithoutDeepCopy(f1)
		o.ServiceProviderChoice = &GlobalSpecType_F5BigIpAwsService{F5BigIpAwsService: f1}

	case *ReplaceSpecType_PaloAltoFwService:

		f1 := o.GetPaloAltoFwService()
		if f1 == nil {
			f1 = &PaloAltoFWAWSType{}
		}
		of.PaloAltoFwService.ToPaloAltoFWAWSTypeWithoutDeepCopy(f1)
		o.ServiceProviderChoice = &GlobalSpecType_PaloAltoFwService{PaloAltoFwService: f1}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetServiceProviderChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ServiceProviderChoice.(type) {
	case nil:
		r.ServiceProviderChoice = nil

	case *GlobalSpecType_F5BigIpAwsService:

		f1 := &F5BigIpAWSReplaceType{}
		f1.FromF5BigIpAWSTypeWithoutDeepCopy(of.F5BigIpAwsService)
		r.ServiceProviderChoice = &ReplaceSpecType_F5BigIpAwsService{F5BigIpAwsService: f1}

	case *GlobalSpecType_PaloAltoFwService:

		f1 := &PaloAltoFWAWSReplaceType{}
		f1.FromPaloAltoFWAWSTypeWithoutDeepCopy(of.PaloAltoFwService)
		r.ServiceProviderChoice = &ReplaceSpecType_PaloAltoFwService{PaloAltoFwService: f1}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetSshManagementChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.SshManagementChoice.(type) {
	case nil:
		o.SshManagementChoice = nil

	case *ReplaceSpecType_DisableSshAccess:
		o.SshManagementChoice = &GlobalSpecType_DisableSshAccess{DisableSshAccess: of.DisableSshAccess}

	case *ReplaceSpecType_EnabledSshAccess:
		o.SshManagementChoice = &GlobalSpecType_EnabledSshAccess{EnabledSshAccess: of.EnabledSshAccess}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetSshManagementChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.SshManagementChoice.(type) {
	case nil:
		r.SshManagementChoice = nil

	case *GlobalSpecType_DisableSshAccess:
		r.SshManagementChoice = &ReplaceSpecType_DisableSshAccess{DisableSshAccess: of.DisableSshAccess}

	case *GlobalSpecType_EnabledSshAccess:
		r.SshManagementChoice = &ReplaceSpecType_EnabledSshAccess{EnabledSshAccess: of.EnabledSshAccess}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *ReplaceSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.GetHttpManagementChoiceFromGlobalSpecType(f)
	m.GetServiceProviderChoiceFromGlobalSpecType(f)
	m.GetSshManagementChoiceFromGlobalSpecType(f)
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	m1.SetHttpManagementChoiceToGlobalSpecType(f)
	m1.SetServiceProviderChoiceToGlobalSpecType(f)
	m1.SetSshManagementChoiceToGlobalSpecType(f)
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}
