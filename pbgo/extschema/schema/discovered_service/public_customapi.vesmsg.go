// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package discovered_service

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *CreateHTTPLoadBalancerRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateHTTPLoadBalancerRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateHTTPLoadBalancerRequest) DeepCopy() *CreateHTTPLoadBalancerRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateHTTPLoadBalancerRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateHTTPLoadBalancerRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateHTTPLoadBalancerRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateHTTPLoadBalancerRequestValidator().Validate(ctx, m, opts...)
}

func (m *CreateHTTPLoadBalancerRequest) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetHttpLbRequestDRefInfo()

}

// GetDRefInfo for the field's type
func (m *CreateHTTPLoadBalancerRequest) GetHttpLbRequestDRefInfo() ([]db.DRefInfo, error) {
	if m.GetHttpLbRequest() == nil {
		return nil, nil
	}

	drInfos, err := m.GetHttpLbRequest().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetHttpLbRequest().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "http_lb_request." + dri.DRField
	}
	return drInfos, err

}

type ValidateCreateHTTPLoadBalancerRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateHTTPLoadBalancerRequest) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateCreateHTTPLoadBalancerRequest) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateCreateHTTPLoadBalancerRequest) HttpLbRequestValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for http_lb_request")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := HTTPLBRequestValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateHTTPLoadBalancerRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateHTTPLoadBalancerRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateHTTPLoadBalancerRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["http_lb_request"]; exists {

		vOpts := append(opts, db.WithValidateField("http_lb_request"))
		if err := fv(ctx, m.GetHttpLbRequest(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateHTTPLoadBalancerRequestValidator = func() *ValidateCreateHTTPLoadBalancerRequest {
	v := &ValidateCreateHTTPLoadBalancerRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateHTTPLoadBalancerRequest.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateHTTPLoadBalancerRequest.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhHttpLbRequest := v.HttpLbRequestValidationRuleHandler
	rulesHttpLbRequest := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhHttpLbRequest(rulesHttpLbRequest)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateHTTPLoadBalancerRequest.http_lb_request: %s", err)
		panic(errMsg)
	}
	v.FldValidators["http_lb_request"] = vFn

	return v
}()

func CreateHTTPLoadBalancerRequestValidator() db.Validator {
	return DefaultCreateHTTPLoadBalancerRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateHTTPLoadBalancerResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateHTTPLoadBalancerResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateHTTPLoadBalancerResponse) DeepCopy() *CreateHTTPLoadBalancerResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateHTTPLoadBalancerResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateHTTPLoadBalancerResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateHTTPLoadBalancerResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateHTTPLoadBalancerResponseValidator().Validate(ctx, m, opts...)
}

func (m *CreateHTTPLoadBalancerResponse) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetHttpLoadbalancerDRefInfo()

}

func (m *CreateHTTPLoadBalancerResponse) GetHttpLoadbalancerDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetHttpLoadbalancer()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("http_loadbalancer.Object")
	dri := db.DRefInfo{
		RefdType:   "http_loadbalancer.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "http_loadbalancer",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetHttpLoadbalancerDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateHTTPLoadBalancerResponse) GetHttpLoadbalancerDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "http_loadbalancer.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: http_loadbalancer")
	}

	vref := m.GetHttpLoadbalancer()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "http_loadbalancer.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateCreateHTTPLoadBalancerResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateHTTPLoadBalancerResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateHTTPLoadBalancerResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateHTTPLoadBalancerResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["http_loadbalancer"]; exists {

		vOpts := append(opts, db.WithValidateField("http_loadbalancer"))
		if err := fv(ctx, m.GetHttpLoadbalancer(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateHTTPLoadBalancerResponseValidator = func() *ValidateCreateHTTPLoadBalancerResponse {
	v := &ValidateCreateHTTPLoadBalancerResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["http_loadbalancer"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func CreateHTTPLoadBalancerResponseValidator() db.Validator {
	return DefaultCreateHTTPLoadBalancerResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateTCPLoadBalancerRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateTCPLoadBalancerRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateTCPLoadBalancerRequest) DeepCopy() *CreateTCPLoadBalancerRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateTCPLoadBalancerRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateTCPLoadBalancerRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateTCPLoadBalancerRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateTCPLoadBalancerRequestValidator().Validate(ctx, m, opts...)
}

func (m *CreateTCPLoadBalancerRequest) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetTcpLbRequestDRefInfo()

}

// GetDRefInfo for the field's type
func (m *CreateTCPLoadBalancerRequest) GetTcpLbRequestDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTcpLbRequest() == nil {
		return nil, nil
	}

	drInfos, err := m.GetTcpLbRequest().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetTcpLbRequest().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "tcp_lb_request." + dri.DRField
	}
	return drInfos, err

}

type ValidateCreateTCPLoadBalancerRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateTCPLoadBalancerRequest) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateCreateTCPLoadBalancerRequest) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateCreateTCPLoadBalancerRequest) TcpLbRequestValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for tcp_lb_request")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := TCPLBRequestValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateTCPLoadBalancerRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateTCPLoadBalancerRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateTCPLoadBalancerRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tcp_lb_request"]; exists {

		vOpts := append(opts, db.WithValidateField("tcp_lb_request"))
		if err := fv(ctx, m.GetTcpLbRequest(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateTCPLoadBalancerRequestValidator = func() *ValidateCreateTCPLoadBalancerRequest {
	v := &ValidateCreateTCPLoadBalancerRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateTCPLoadBalancerRequest.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateTCPLoadBalancerRequest.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhTcpLbRequest := v.TcpLbRequestValidationRuleHandler
	rulesTcpLbRequest := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhTcpLbRequest(rulesTcpLbRequest)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateTCPLoadBalancerRequest.tcp_lb_request: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tcp_lb_request"] = vFn

	return v
}()

func CreateTCPLoadBalancerRequestValidator() db.Validator {
	return DefaultCreateTCPLoadBalancerRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateTCPLoadBalancerResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateTCPLoadBalancerResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateTCPLoadBalancerResponse) DeepCopy() *CreateTCPLoadBalancerResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateTCPLoadBalancerResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateTCPLoadBalancerResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateTCPLoadBalancerResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateTCPLoadBalancerResponseValidator().Validate(ctx, m, opts...)
}

func (m *CreateTCPLoadBalancerResponse) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetTcpLoadbalancerDRefInfo()

}

func (m *CreateTCPLoadBalancerResponse) GetTcpLoadbalancerDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetTcpLoadbalancer()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("tcp_loadbalancer.Object")
	dri := db.DRefInfo{
		RefdType:   "tcp_loadbalancer.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "tcp_loadbalancer",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetTcpLoadbalancerDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateTCPLoadBalancerResponse) GetTcpLoadbalancerDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "tcp_loadbalancer.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: tcp_loadbalancer")
	}

	vref := m.GetTcpLoadbalancer()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "tcp_loadbalancer.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateCreateTCPLoadBalancerResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateTCPLoadBalancerResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateTCPLoadBalancerResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateTCPLoadBalancerResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["tcp_loadbalancer"]; exists {

		vOpts := append(opts, db.WithValidateField("tcp_loadbalancer"))
		if err := fv(ctx, m.GetTcpLoadbalancer(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateTCPLoadBalancerResponseValidator = func() *ValidateCreateTCPLoadBalancerResponse {
	v := &ValidateCreateTCPLoadBalancerResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["tcp_loadbalancer"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func CreateTCPLoadBalancerResponseValidator() db.Validator {
	return DefaultCreateTCPLoadBalancerResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *DisableWAAPRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DisableWAAPRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DisableWAAPRequest) DeepCopy() *DisableWAAPRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DisableWAAPRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DisableWAAPRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DisableWAAPRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DisableWAAPRequestValidator().Validate(ctx, m, opts...)
}

type ValidateDisableWAAPRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDisableWAAPRequest) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateDisableWAAPRequest) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateDisableWAAPRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DisableWAAPRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DisableWAAPRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDisableWAAPRequestValidator = func() *ValidateDisableWAAPRequest {
	v := &ValidateDisableWAAPRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DisableWAAPRequest.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DisableWAAPRequest.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func DisableWAAPRequestValidator() db.Validator {
	return DefaultDisableWAAPRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *DisableWAAPResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DisableWAAPResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DisableWAAPResponse) DeepCopy() *DisableWAAPResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DisableWAAPResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DisableWAAPResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DisableWAAPResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DisableWAAPResponseValidator().Validate(ctx, m, opts...)
}

type ValidateDisableWAAPResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDisableWAAPResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DisableWAAPResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DisableWAAPResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDisableWAAPResponseValidator = func() *ValidateDisableWAAPResponse {
	v := &ValidateDisableWAAPResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DisableWAAPResponseValidator() db.Validator {
	return DefaultDisableWAAPResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *EnableWAAPRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *EnableWAAPRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *EnableWAAPRequest) DeepCopy() *EnableWAAPRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &EnableWAAPRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *EnableWAAPRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *EnableWAAPRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EnableWAAPRequestValidator().Validate(ctx, m, opts...)
}

type ValidateEnableWAAPRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEnableWAAPRequest) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateEnableWAAPRequest) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateEnableWAAPRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*EnableWAAPRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *EnableWAAPRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEnableWAAPRequestValidator = func() *ValidateEnableWAAPRequest {
	v := &ValidateEnableWAAPRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EnableWAAPRequest.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EnableWAAPRequest.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func EnableWAAPRequestValidator() db.Validator {
	return DefaultEnableWAAPRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *EnableWAAPResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *EnableWAAPResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *EnableWAAPResponse) DeepCopy() *EnableWAAPResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &EnableWAAPResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *EnableWAAPResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *EnableWAAPResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EnableWAAPResponseValidator().Validate(ctx, m, opts...)
}

func (m *EnableWAAPResponse) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetVirtualHostRefDRefInfo()

}

func (m *EnableWAAPResponse) GetVirtualHostRefDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetVirtualHostRef()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("virtual_host.Object")
	dri := db.DRefInfo{
		RefdType:   "virtual_host.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "virtual_host_ref",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetVirtualHostRefDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *EnableWAAPResponse) GetVirtualHostRefDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_host.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_host")
	}

	vref := m.GetVirtualHostRef()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "virtual_host.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateEnableWAAPResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEnableWAAPResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*EnableWAAPResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *EnableWAAPResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["virtual_host_ref"]; exists {

		vOpts := append(opts, db.WithValidateField("virtual_host_ref"))
		if err := fv(ctx, m.GetVirtualHostRef(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEnableWAAPResponseValidator = func() *ValidateEnableWAAPResponse {
	v := &ValidateEnableWAAPResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["virtual_host_ref"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func EnableWAAPResponseValidator() db.Validator {
	return DefaultEnableWAAPResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *HTTPLBRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HTTPLBRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HTTPLBRequest) DeepCopy() *HTTPLBRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HTTPLBRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HTTPLBRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HTTPLBRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HTTPLBRequestValidator().Validate(ctx, m, opts...)
}

func (m *HTTPLBRequest) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAdvertiseChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAdvertiseChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetServerValidationChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetServerValidationChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *HTTPLBRequest) GetAdvertiseChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAdvertiseChoice() == nil {
		return nil, nil
	}
	switch m.GetAdvertiseChoice().(type) {
	case *HTTPLBRequest_AdvertiseOnPublicDefaultVip:

		return nil, nil

	case *HTTPLBRequest_AdvertiseCustom:

		drInfos, err := m.GetAdvertiseCustom().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAdvertiseCustom().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "advertise_custom." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

func (m *HTTPLBRequest) GetServerValidationChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetServerValidationChoice().(type) {
	case *HTTPLBRequest_TrustedCa:

		vref := m.GetTrustedCa()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("trusted_ca_list.Object")
		dri := db.DRefInfo{
			RefdType:   "trusted_ca_list.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "trusted_ca",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	case *HTTPLBRequest_SkipServerVerification:

		return nil, nil

	default:
		return nil, nil
	}
}

// GetServerValidationChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *HTTPLBRequest) GetServerValidationChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetServerValidationChoice().(type) {
	case *HTTPLBRequest_TrustedCa:
		refdType, err := d.TypeForEntryKind("", "", "trusted_ca_list.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: trusted_ca_list")
		}

		vref := m.GetTrustedCa()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "trusted_ca_list.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	case *HTTPLBRequest_SkipServerVerification:

	}

	return entries, nil
}

type ValidateHTTPLBRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHTTPLBRequest) AdvertiseChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for advertise_choice")
	}
	return validatorFn, nil
}

func (v *ValidateHTTPLBRequest) ServerValidationChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for server_validation_choice")
	}
	return validatorFn, nil
}

func (v *ValidateHTTPLBRequest) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateHTTPLBRequest) DomainValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain")
	}

	return validatorFn, nil
}

func (v *ValidateHTTPLBRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HTTPLBRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HTTPLBRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advertise_choice"]; exists {
		val := m.GetAdvertiseChoice()
		vOpts := append(opts,
			db.WithValidateField("advertise_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAdvertiseChoice().(type) {
	case *HTTPLBRequest_AdvertiseOnPublicDefaultVip:
		if fv, exists := v.FldValidators["advertise_choice.advertise_on_public_default_vip"]; exists {
			val := m.GetAdvertiseChoice().(*HTTPLBRequest_AdvertiseOnPublicDefaultVip).AdvertiseOnPublicDefaultVip
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("advertise_on_public_default_vip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HTTPLBRequest_AdvertiseCustom:
		if fv, exists := v.FldValidators["advertise_choice.advertise_custom"]; exists {
			val := m.GetAdvertiseChoice().(*HTTPLBRequest_AdvertiseCustom).AdvertiseCustom
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("advertise_custom"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["domain"]; exists {

		vOpts := append(opts, db.WithValidateField("domain"))
		if err := fv(ctx, m.GetDomain(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["server_validation_choice"]; exists {
		val := m.GetServerValidationChoice()
		vOpts := append(opts,
			db.WithValidateField("server_validation_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetServerValidationChoice().(type) {
	case *HTTPLBRequest_TrustedCa:
		if fv, exists := v.FldValidators["server_validation_choice.trusted_ca"]; exists {
			val := m.GetServerValidationChoice().(*HTTPLBRequest_TrustedCa).TrustedCa
			vOpts := append(opts,
				db.WithValidateField("server_validation_choice"),
				db.WithValidateField("trusted_ca"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HTTPLBRequest_SkipServerVerification:
		if fv, exists := v.FldValidators["server_validation_choice.skip_server_verification"]; exists {
			val := m.GetServerValidationChoice().(*HTTPLBRequest_SkipServerVerification).SkipServerVerification
			vOpts := append(opts,
				db.WithValidateField("server_validation_choice"),
				db.WithValidateField("skip_server_verification"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHTTPLBRequestValidator = func() *ValidateHTTPLBRequest {
	v := &ValidateHTTPLBRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAdvertiseChoice := v.AdvertiseChoiceValidationRuleHandler
	rulesAdvertiseChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAdvertiseChoice(rulesAdvertiseChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HTTPLBRequest.advertise_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["advertise_choice"] = vFn

	vrhServerValidationChoice := v.ServerValidationChoiceValidationRuleHandler
	rulesServerValidationChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhServerValidationChoice(rulesServerValidationChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HTTPLBRequest.server_validation_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["server_validation_choice"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HTTPLBRequest.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhDomain := v.DomainValidationRuleHandler
	rulesDomain := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.vh_domain": "true",
	}
	vFn, err = vrhDomain(rulesDomain)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HTTPLBRequest.domain: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain"] = vFn

	v.FldValidators["advertise_choice.advertise_custom"] = ves_io_schema_views.AdvertiseCustomValidator().Validate

	v.FldValidators["server_validation_choice.trusted_ca"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func HTTPLBRequestValidator() db.Validator {
	return DefaultHTTPLBRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ListServicesRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListServicesRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListServicesRequest) DeepCopy() *ListServicesRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListServicesRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListServicesRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListServicesRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListServicesRequestValidator().Validate(ctx, m, opts...)
}

type ValidateListServicesRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListServicesRequest) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateListServicesRequest) DiscoveredServiceTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for discovered_service_type")
	}

	return validatorFn, nil
}

func (v *ValidateListServicesRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListServicesRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListServicesRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["discovered_service_type"]; exists {

		vOpts := append(opts, db.WithValidateField("discovered_service_type"))
		if err := fv(ctx, m.GetDiscoveredServiceType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListServicesRequestValidator = func() *ValidateListServicesRequest {
	v := &ValidateListServicesRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListServicesRequest.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhDiscoveredServiceType := v.DiscoveredServiceTypeValidationRuleHandler
	rulesDiscoveredServiceType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.in":        "[\"bigip_virtual_server\"]",
	}
	vFn, err = vrhDiscoveredServiceType(rulesDiscoveredServiceType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListServicesRequest.discovered_service_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["discovered_service_type"] = vFn

	return v
}()

func ListServicesRequestValidator() db.Validator {
	return DefaultListServicesRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ListServicesResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListServicesResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListServicesResponse) DeepCopy() *ListServicesResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListServicesResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListServicesResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListServicesResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListServicesResponseValidator().Validate(ctx, m, opts...)
}

func (m *ListServicesResponse) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetItemsDRefInfo()

}

// GetDRefInfo for the field's type
func (m *ListServicesResponse) GetItemsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetItems() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetItems() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetItems() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("items[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateListServicesResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListServicesResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListServicesResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListServicesResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["errors"]; exists {

		vOpts := append(opts, db.WithValidateField("errors"))
		for idx, item := range m.GetErrors() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["items"]; exists {

		vOpts := append(opts, db.WithValidateField("items"))
		for idx, item := range m.GetItems() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListServicesResponseValidator = func() *ValidateListServicesResponse {
	v := &ValidateListServicesResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["items"] = ListServicesResponseItemValidator().Validate

	return v
}()

func ListServicesResponseValidator() db.Validator {
	return DefaultListServicesResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *ListServicesResponseItem) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListServicesResponseItem) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListServicesResponseItem) DeepCopy() *ListServicesResponseItem {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListServicesResponseItem{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListServicesResponseItem) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListServicesResponseItem) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListServicesResponseItemValidator().Validate(ctx, m, opts...)
}

func (m *ListServicesResponseItem) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetGetSpecDRefInfo()

}

// GetDRefInfo for the field's type
func (m *ListServicesResponseItem) GetGetSpecDRefInfo() ([]db.DRefInfo, error) {
	if m.GetGetSpec() == nil {
		return nil, nil
	}

	drInfos, err := m.GetGetSpec().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetGetSpec().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "get_spec." + dri.DRField
	}
	return drInfos, err

}

type ValidateListServicesResponseItem struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListServicesResponseItem) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListServicesResponseItem)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListServicesResponseItem got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["annotations"]; exists {

		vOpts := append(opts, db.WithValidateField("annotations"))
		for key, value := range m.GetAnnotations() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disabled"]; exists {

		vOpts := append(opts, db.WithValidateField("disabled"))
		if err := fv(ctx, m.GetDisabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["get_spec"]; exists {

		vOpts := append(opts, db.WithValidateField("get_spec"))
		if err := fv(ctx, m.GetGetSpec(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["labels"]; exists {

		vOpts := append(opts, db.WithValidateField("labels"))
		for key, value := range m.GetLabels() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["owner_view"]; exists {

		vOpts := append(opts, db.WithValidateField("owner_view"))
		if err := fv(ctx, m.GetOwnerView(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status_set"]; exists {

		vOpts := append(opts, db.WithValidateField("status_set"))
		for idx, item := range m.GetStatusSet() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["system_metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("system_metadata"))
		if err := fv(ctx, m.GetSystemMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tenant"]; exists {

		vOpts := append(opts, db.WithValidateField("tenant"))
		if err := fv(ctx, m.GetTenant(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["uid"]; exists {

		vOpts := append(opts, db.WithValidateField("uid"))
		if err := fv(ctx, m.GetUid(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListServicesResponseItemValidator = func() *ValidateListServicesResponseItem {
	v := &ValidateListServicesResponseItem{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["metadata"] = ves_io_schema.ObjectGetMetaTypeValidator().Validate

	v.FldValidators["get_spec"] = GetSpecTypeValidator().Validate

	v.FldValidators["status_set"] = StatusObjectValidator().Validate

	return v
}()

func ListServicesResponseItemValidator() db.Validator {
	return DefaultListServicesResponseItemValidator
}

// augmented methods on protoc/std generated struct

func (m *TCPLBRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TCPLBRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TCPLBRequest) DeepCopy() *TCPLBRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TCPLBRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TCPLBRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TCPLBRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TCPLBRequestValidator().Validate(ctx, m, opts...)
}

func (m *TCPLBRequest) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetAdvertiseChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *TCPLBRequest) GetAdvertiseChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAdvertiseChoice() == nil {
		return nil, nil
	}
	switch m.GetAdvertiseChoice().(type) {
	case *TCPLBRequest_AdvertiseOnPublicDefaultVip:

		return nil, nil

	case *TCPLBRequest_AdvertiseCustom:

		drInfos, err := m.GetAdvertiseCustom().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAdvertiseCustom().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "advertise_custom." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateTCPLBRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTCPLBRequest) AdvertiseChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for advertise_choice")
	}
	return validatorFn, nil
}

func (v *ValidateTCPLBRequest) PortChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port_choice")
	}
	return validatorFn, nil
}

func (v *ValidateTCPLBRequest) PortChoiceListenPortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ListenPort, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for listen_port")
	}
	return oValidatorFn_ListenPort, nil
}
func (v *ValidateTCPLBRequest) PortChoicePortRangesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_PortRanges, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port_ranges")
	}
	return oValidatorFn_PortRanges, nil
}

func (v *ValidateTCPLBRequest) SniDefaultLbChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for sni_default_lb_choice")
	}
	return validatorFn, nil
}

func (v *ValidateTCPLBRequest) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateTCPLBRequest) DomainValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain")
	}

	return validatorFn, nil
}

func (v *ValidateTCPLBRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TCPLBRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TCPLBRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advertise_choice"]; exists {
		val := m.GetAdvertiseChoice()
		vOpts := append(opts,
			db.WithValidateField("advertise_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAdvertiseChoice().(type) {
	case *TCPLBRequest_AdvertiseOnPublicDefaultVip:
		if fv, exists := v.FldValidators["advertise_choice.advertise_on_public_default_vip"]; exists {
			val := m.GetAdvertiseChoice().(*TCPLBRequest_AdvertiseOnPublicDefaultVip).AdvertiseOnPublicDefaultVip
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("advertise_on_public_default_vip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TCPLBRequest_AdvertiseCustom:
		if fv, exists := v.FldValidators["advertise_choice.advertise_custom"]; exists {
			val := m.GetAdvertiseChoice().(*TCPLBRequest_AdvertiseCustom).AdvertiseCustom
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("advertise_custom"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["domain"]; exists {

		vOpts := append(opts, db.WithValidateField("domain"))
		if err := fv(ctx, m.GetDomain(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["port_choice"]; exists {
		val := m.GetPortChoice()
		vOpts := append(opts,
			db.WithValidateField("port_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPortChoice().(type) {
	case *TCPLBRequest_ListenPort:
		if fv, exists := v.FldValidators["port_choice.listen_port"]; exists {
			val := m.GetPortChoice().(*TCPLBRequest_ListenPort).ListenPort
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("listen_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TCPLBRequest_PortRanges:
		if fv, exists := v.FldValidators["port_choice.port_ranges"]; exists {
			val := m.GetPortChoice().(*TCPLBRequest_PortRanges).PortRanges
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("port_ranges"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["sni_default_lb_choice"]; exists {
		val := m.GetSniDefaultLbChoice()
		vOpts := append(opts,
			db.WithValidateField("sni_default_lb_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSniDefaultLbChoice().(type) {
	case *TCPLBRequest_NoSni:
		if fv, exists := v.FldValidators["sni_default_lb_choice.no_sni"]; exists {
			val := m.GetSniDefaultLbChoice().(*TCPLBRequest_NoSni).NoSni
			vOpts := append(opts,
				db.WithValidateField("sni_default_lb_choice"),
				db.WithValidateField("no_sni"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TCPLBRequest_Sni:
		if fv, exists := v.FldValidators["sni_default_lb_choice.sni"]; exists {
			val := m.GetSniDefaultLbChoice().(*TCPLBRequest_Sni).Sni
			vOpts := append(opts,
				db.WithValidateField("sni_default_lb_choice"),
				db.WithValidateField("sni"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTCPLBRequestValidator = func() *ValidateTCPLBRequest {
	v := &ValidateTCPLBRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAdvertiseChoice := v.AdvertiseChoiceValidationRuleHandler
	rulesAdvertiseChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAdvertiseChoice(rulesAdvertiseChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TCPLBRequest.advertise_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["advertise_choice"] = vFn

	vrhPortChoice := v.PortChoiceValidationRuleHandler
	rulesPortChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPortChoice(rulesPortChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TCPLBRequest.port_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port_choice"] = vFn

	vrhPortChoiceListenPort := v.PortChoiceListenPortValidationRuleHandler
	rulesPortChoiceListenPort := map[string]string{
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFnMap["port_choice.listen_port"], err = vrhPortChoiceListenPort(rulesPortChoiceListenPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field TCPLBRequest.port_choice_listen_port: %s", err)
		panic(errMsg)
	}
	vrhPortChoicePortRanges := v.PortChoicePortRangesValidationRuleHandler
	rulesPortChoicePortRanges := map[string]string{
		"ves.io.schema.rules.string.max_len":                "512",
		"ves.io.schema.rules.string.max_ports":              "64",
		"ves.io.schema.rules.string.min_len":                "1",
		"ves.io.schema.rules.string.unique_port_range_list": "true",
	}
	vFnMap["port_choice.port_ranges"], err = vrhPortChoicePortRanges(rulesPortChoicePortRanges)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field TCPLBRequest.port_choice_port_ranges: %s", err)
		panic(errMsg)
	}

	v.FldValidators["port_choice.listen_port"] = vFnMap["port_choice.listen_port"]
	v.FldValidators["port_choice.port_ranges"] = vFnMap["port_choice.port_ranges"]

	vrhSniDefaultLbChoice := v.SniDefaultLbChoiceValidationRuleHandler
	rulesSniDefaultLbChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSniDefaultLbChoice(rulesSniDefaultLbChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TCPLBRequest.sni_default_lb_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["sni_default_lb_choice"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TCPLBRequest.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhDomain := v.DomainValidationRuleHandler
	rulesDomain := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.vh_domain": "true",
	}
	vFn, err = vrhDomain(rulesDomain)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TCPLBRequest.domain: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain"] = vFn

	v.FldValidators["advertise_choice.advertise_custom"] = ves_io_schema_views.AdvertiseCustomValidator().Validate

	return v
}()

func TCPLBRequestValidator() db.Validator {
	return DefaultTCPLBRequestValidator
}
