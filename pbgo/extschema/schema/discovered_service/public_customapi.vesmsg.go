// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package discovered_service

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *CreateHTTPLoadBalancerRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateHTTPLoadBalancerRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateHTTPLoadBalancerRequest) DeepCopy() *CreateHTTPLoadBalancerRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateHTTPLoadBalancerRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateHTTPLoadBalancerRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateHTTPLoadBalancerRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateHTTPLoadBalancerRequestValidator().Validate(ctx, m, opts...)
}

func (m *CreateHTTPLoadBalancerRequest) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetHttpLbRequestDRefInfo()

}

// GetDRefInfo for the field's type
func (m *CreateHTTPLoadBalancerRequest) GetHttpLbRequestDRefInfo() ([]db.DRefInfo, error) {
	if m.GetHttpLbRequest() == nil {
		return nil, nil
	}

	drInfos, err := m.GetHttpLbRequest().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetHttpLbRequest().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "http_lb_request." + dri.DRField
	}
	return drInfos, err

}

type ValidateCreateHTTPLoadBalancerRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateHTTPLoadBalancerRequest) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateCreateHTTPLoadBalancerRequest) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateCreateHTTPLoadBalancerRequest) HttpLbRequestValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for http_lb_request")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := HTTPLBRequestValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateHTTPLoadBalancerRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateHTTPLoadBalancerRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateHTTPLoadBalancerRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["http_lb_request"]; exists {

		vOpts := append(opts, db.WithValidateField("http_lb_request"))
		if err := fv(ctx, m.GetHttpLbRequest(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateHTTPLoadBalancerRequestValidator = func() *ValidateCreateHTTPLoadBalancerRequest {
	v := &ValidateCreateHTTPLoadBalancerRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateHTTPLoadBalancerRequest.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateHTTPLoadBalancerRequest.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhHttpLbRequest := v.HttpLbRequestValidationRuleHandler
	rulesHttpLbRequest := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhHttpLbRequest(rulesHttpLbRequest)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateHTTPLoadBalancerRequest.http_lb_request: %s", err)
		panic(errMsg)
	}
	v.FldValidators["http_lb_request"] = vFn

	return v
}()

func CreateHTTPLoadBalancerRequestValidator() db.Validator {
	return DefaultCreateHTTPLoadBalancerRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateHTTPLoadBalancerResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateHTTPLoadBalancerResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateHTTPLoadBalancerResponse) DeepCopy() *CreateHTTPLoadBalancerResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateHTTPLoadBalancerResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateHTTPLoadBalancerResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateHTTPLoadBalancerResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateHTTPLoadBalancerResponseValidator().Validate(ctx, m, opts...)
}

func (m *CreateHTTPLoadBalancerResponse) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetHttpLoadbalancerDRefInfo()

}

func (m *CreateHTTPLoadBalancerResponse) GetHttpLoadbalancerDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetHttpLoadbalancer()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("http_loadbalancer.Object")
	dri := db.DRefInfo{
		RefdType:   "http_loadbalancer.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "http_loadbalancer",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetHttpLoadbalancerDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateHTTPLoadBalancerResponse) GetHttpLoadbalancerDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "http_loadbalancer.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: http_loadbalancer")
	}

	vref := m.GetHttpLoadbalancer()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "http_loadbalancer.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateCreateHTTPLoadBalancerResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateHTTPLoadBalancerResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateHTTPLoadBalancerResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateHTTPLoadBalancerResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["http_loadbalancer"]; exists {

		vOpts := append(opts, db.WithValidateField("http_loadbalancer"))
		if err := fv(ctx, m.GetHttpLoadbalancer(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateHTTPLoadBalancerResponseValidator = func() *ValidateCreateHTTPLoadBalancerResponse {
	v := &ValidateCreateHTTPLoadBalancerResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["http_loadbalancer"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func CreateHTTPLoadBalancerResponseValidator() db.Validator {
	return DefaultCreateHTTPLoadBalancerResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateTCPLoadBalancerRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateTCPLoadBalancerRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateTCPLoadBalancerRequest) DeepCopy() *CreateTCPLoadBalancerRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateTCPLoadBalancerRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateTCPLoadBalancerRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateTCPLoadBalancerRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateTCPLoadBalancerRequestValidator().Validate(ctx, m, opts...)
}

func (m *CreateTCPLoadBalancerRequest) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetTcpLbRequestDRefInfo()

}

// GetDRefInfo for the field's type
func (m *CreateTCPLoadBalancerRequest) GetTcpLbRequestDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTcpLbRequest() == nil {
		return nil, nil
	}

	drInfos, err := m.GetTcpLbRequest().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetTcpLbRequest().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "tcp_lb_request." + dri.DRField
	}
	return drInfos, err

}

type ValidateCreateTCPLoadBalancerRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateTCPLoadBalancerRequest) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateCreateTCPLoadBalancerRequest) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateCreateTCPLoadBalancerRequest) TcpLbRequestValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for tcp_lb_request")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := TCPLBRequestValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateTCPLoadBalancerRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateTCPLoadBalancerRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateTCPLoadBalancerRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tcp_lb_request"]; exists {

		vOpts := append(opts, db.WithValidateField("tcp_lb_request"))
		if err := fv(ctx, m.GetTcpLbRequest(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateTCPLoadBalancerRequestValidator = func() *ValidateCreateTCPLoadBalancerRequest {
	v := &ValidateCreateTCPLoadBalancerRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateTCPLoadBalancerRequest.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateTCPLoadBalancerRequest.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhTcpLbRequest := v.TcpLbRequestValidationRuleHandler
	rulesTcpLbRequest := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhTcpLbRequest(rulesTcpLbRequest)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateTCPLoadBalancerRequest.tcp_lb_request: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tcp_lb_request"] = vFn

	return v
}()

func CreateTCPLoadBalancerRequestValidator() db.Validator {
	return DefaultCreateTCPLoadBalancerRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateTCPLoadBalancerResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateTCPLoadBalancerResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateTCPLoadBalancerResponse) DeepCopy() *CreateTCPLoadBalancerResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateTCPLoadBalancerResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateTCPLoadBalancerResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateTCPLoadBalancerResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateTCPLoadBalancerResponseValidator().Validate(ctx, m, opts...)
}

func (m *CreateTCPLoadBalancerResponse) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetTcpLoadbalancerDRefInfo()

}

func (m *CreateTCPLoadBalancerResponse) GetTcpLoadbalancerDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetTcpLoadbalancer()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("tcp_loadbalancer.Object")
	dri := db.DRefInfo{
		RefdType:   "tcp_loadbalancer.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "tcp_loadbalancer",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetTcpLoadbalancerDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateTCPLoadBalancerResponse) GetTcpLoadbalancerDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "tcp_loadbalancer.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: tcp_loadbalancer")
	}

	vref := m.GetTcpLoadbalancer()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "tcp_loadbalancer.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateCreateTCPLoadBalancerResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateTCPLoadBalancerResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateTCPLoadBalancerResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateTCPLoadBalancerResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["tcp_loadbalancer"]; exists {

		vOpts := append(opts, db.WithValidateField("tcp_loadbalancer"))
		if err := fv(ctx, m.GetTcpLoadbalancer(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateTCPLoadBalancerResponseValidator = func() *ValidateCreateTCPLoadBalancerResponse {
	v := &ValidateCreateTCPLoadBalancerResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["tcp_loadbalancer"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func CreateTCPLoadBalancerResponseValidator() db.Validator {
	return DefaultCreateTCPLoadBalancerResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *DisableVisibilityRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DisableVisibilityRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DisableVisibilityRequest) DeepCopy() *DisableVisibilityRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DisableVisibilityRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DisableVisibilityRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DisableVisibilityRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DisableVisibilityRequestValidator().Validate(ctx, m, opts...)
}

type ValidateDisableVisibilityRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDisableVisibilityRequest) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateDisableVisibilityRequest) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateDisableVisibilityRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DisableVisibilityRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DisableVisibilityRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDisableVisibilityRequestValidator = func() *ValidateDisableVisibilityRequest {
	v := &ValidateDisableVisibilityRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DisableVisibilityRequest.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DisableVisibilityRequest.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func DisableVisibilityRequestValidator() db.Validator {
	return DefaultDisableVisibilityRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *DisableVisibilityResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DisableVisibilityResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DisableVisibilityResponse) DeepCopy() *DisableVisibilityResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DisableVisibilityResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DisableVisibilityResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DisableVisibilityResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DisableVisibilityResponseValidator().Validate(ctx, m, opts...)
}

type ValidateDisableVisibilityResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDisableVisibilityResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DisableVisibilityResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DisableVisibilityResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDisableVisibilityResponseValidator = func() *ValidateDisableVisibilityResponse {
	v := &ValidateDisableVisibilityResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DisableVisibilityResponseValidator() db.Validator {
	return DefaultDisableVisibilityResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *EnableVisibilityRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *EnableVisibilityRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *EnableVisibilityRequest) DeepCopy() *EnableVisibilityRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &EnableVisibilityRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *EnableVisibilityRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *EnableVisibilityRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EnableVisibilityRequestValidator().Validate(ctx, m, opts...)
}

type ValidateEnableVisibilityRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEnableVisibilityRequest) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateEnableVisibilityRequest) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateEnableVisibilityRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*EnableVisibilityRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *EnableVisibilityRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEnableVisibilityRequestValidator = func() *ValidateEnableVisibilityRequest {
	v := &ValidateEnableVisibilityRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EnableVisibilityRequest.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EnableVisibilityRequest.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func EnableVisibilityRequestValidator() db.Validator {
	return DefaultEnableVisibilityRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *EnableVisibilityResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *EnableVisibilityResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *EnableVisibilityResponse) DeepCopy() *EnableVisibilityResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &EnableVisibilityResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *EnableVisibilityResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *EnableVisibilityResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EnableVisibilityResponseValidator().Validate(ctx, m, opts...)
}

func (m *EnableVisibilityResponse) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetVirtualHostRefDRefInfo()

}

func (m *EnableVisibilityResponse) GetVirtualHostRefDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetVirtualHostRef()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("virtual_host.Object")
	dri := db.DRefInfo{
		RefdType:   "virtual_host.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "virtual_host_ref",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetVirtualHostRefDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *EnableVisibilityResponse) GetVirtualHostRefDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_host.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_host")
	}

	vref := m.GetVirtualHostRef()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "virtual_host.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateEnableVisibilityResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEnableVisibilityResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*EnableVisibilityResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *EnableVisibilityResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["virtual_host_ref"]; exists {

		vOpts := append(opts, db.WithValidateField("virtual_host_ref"))
		if err := fv(ctx, m.GetVirtualHostRef(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEnableVisibilityResponseValidator = func() *ValidateEnableVisibilityResponse {
	v := &ValidateEnableVisibilityResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["virtual_host_ref"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func EnableVisibilityResponseValidator() db.Validator {
	return DefaultEnableVisibilityResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *HTTPLBRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HTTPLBRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HTTPLBRequest) DeepCopy() *HTTPLBRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HTTPLBRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HTTPLBRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HTTPLBRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HTTPLBRequestValidator().Validate(ctx, m, opts...)
}

func (m *HTTPLBRequest) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAdvertiseChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAdvertiseChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetLoadbalancerTypeDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetLoadbalancerTypeDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetServerValidationChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetServerValidationChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *HTTPLBRequest) GetAdvertiseChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAdvertiseChoice() == nil {
		return nil, nil
	}
	switch m.GetAdvertiseChoice().(type) {
	case *HTTPLBRequest_AdvertiseOnPublicDefaultVip:

		return nil, nil

	case *HTTPLBRequest_AdvertiseCustom:

		drInfos, err := m.GetAdvertiseCustom().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAdvertiseCustom().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "advertise_custom." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *HTTPLBRequest) GetLoadbalancerTypeDRefInfo() ([]db.DRefInfo, error) {
	if m.GetLoadbalancerType() == nil {
		return nil, nil
	}
	switch m.GetLoadbalancerType().(type) {
	case *HTTPLBRequest_HttpsAutoCert:

		return nil, nil

	case *HTTPLBRequest_Https:

		drInfos, err := m.GetHttps().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetHttps().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "https." + dri.DRField
		}
		return drInfos, err

	case *HTTPLBRequest_Http:

		drInfos, err := m.GetHttp().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetHttp().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "http." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

func (m *HTTPLBRequest) GetServerValidationChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetServerValidationChoice().(type) {
	case *HTTPLBRequest_TrustedCa:

		vref := m.GetTrustedCa()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("trusted_ca_list.Object")
		dri := db.DRefInfo{
			RefdType:   "trusted_ca_list.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "trusted_ca",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	case *HTTPLBRequest_SkipServerVerification:

		return nil, nil

	default:
		return nil, nil
	}
}

// GetServerValidationChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *HTTPLBRequest) GetServerValidationChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetServerValidationChoice().(type) {
	case *HTTPLBRequest_TrustedCa:
		refdType, err := d.TypeForEntryKind("", "", "trusted_ca_list.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: trusted_ca_list")
		}

		vref := m.GetTrustedCa()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "trusted_ca_list.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	case *HTTPLBRequest_SkipServerVerification:

	}

	return entries, nil
}

type ValidateHTTPLBRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHTTPLBRequest) AdvertiseChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for advertise_choice")
	}
	return validatorFn, nil
}

func (v *ValidateHTTPLBRequest) LoadbalancerTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for loadbalancer_type")
	}
	return validatorFn, nil
}

func (v *ValidateHTTPLBRequest) ServerValidationChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for server_validation_choice")
	}
	return validatorFn, nil
}

func (v *ValidateHTTPLBRequest) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateHTTPLBRequest) DomainValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain")
	}

	return validatorFn, nil
}

func (v *ValidateHTTPLBRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HTTPLBRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HTTPLBRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advertise_choice"]; exists {
		val := m.GetAdvertiseChoice()
		vOpts := append(opts,
			db.WithValidateField("advertise_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAdvertiseChoice().(type) {
	case *HTTPLBRequest_AdvertiseOnPublicDefaultVip:
		if fv, exists := v.FldValidators["advertise_choice.advertise_on_public_default_vip"]; exists {
			val := m.GetAdvertiseChoice().(*HTTPLBRequest_AdvertiseOnPublicDefaultVip).AdvertiseOnPublicDefaultVip
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("advertise_on_public_default_vip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HTTPLBRequest_AdvertiseCustom:
		if fv, exists := v.FldValidators["advertise_choice.advertise_custom"]; exists {
			val := m.GetAdvertiseChoice().(*HTTPLBRequest_AdvertiseCustom).AdvertiseCustom
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("advertise_custom"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["domain"]; exists {

		vOpts := append(opts, db.WithValidateField("domain"))
		if err := fv(ctx, m.GetDomain(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["loadbalancer_type"]; exists {
		val := m.GetLoadbalancerType()
		vOpts := append(opts,
			db.WithValidateField("loadbalancer_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLoadbalancerType().(type) {
	case *HTTPLBRequest_HttpsAutoCert:
		if fv, exists := v.FldValidators["loadbalancer_type.https_auto_cert"]; exists {
			val := m.GetLoadbalancerType().(*HTTPLBRequest_HttpsAutoCert).HttpsAutoCert
			vOpts := append(opts,
				db.WithValidateField("loadbalancer_type"),
				db.WithValidateField("https_auto_cert"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HTTPLBRequest_Https:
		if fv, exists := v.FldValidators["loadbalancer_type.https"]; exists {
			val := m.GetLoadbalancerType().(*HTTPLBRequest_Https).Https
			vOpts := append(opts,
				db.WithValidateField("loadbalancer_type"),
				db.WithValidateField("https"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HTTPLBRequest_Http:
		if fv, exists := v.FldValidators["loadbalancer_type.http"]; exists {
			val := m.GetLoadbalancerType().(*HTTPLBRequest_Http).Http
			vOpts := append(opts,
				db.WithValidateField("loadbalancer_type"),
				db.WithValidateField("http"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["server_validation_choice"]; exists {
		val := m.GetServerValidationChoice()
		vOpts := append(opts,
			db.WithValidateField("server_validation_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetServerValidationChoice().(type) {
	case *HTTPLBRequest_TrustedCa:
		if fv, exists := v.FldValidators["server_validation_choice.trusted_ca"]; exists {
			val := m.GetServerValidationChoice().(*HTTPLBRequest_TrustedCa).TrustedCa
			vOpts := append(opts,
				db.WithValidateField("server_validation_choice"),
				db.WithValidateField("trusted_ca"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HTTPLBRequest_SkipServerVerification:
		if fv, exists := v.FldValidators["server_validation_choice.skip_server_verification"]; exists {
			val := m.GetServerValidationChoice().(*HTTPLBRequest_SkipServerVerification).SkipServerVerification
			vOpts := append(opts,
				db.WithValidateField("server_validation_choice"),
				db.WithValidateField("skip_server_verification"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHTTPLBRequestValidator = func() *ValidateHTTPLBRequest {
	v := &ValidateHTTPLBRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAdvertiseChoice := v.AdvertiseChoiceValidationRuleHandler
	rulesAdvertiseChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAdvertiseChoice(rulesAdvertiseChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HTTPLBRequest.advertise_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["advertise_choice"] = vFn

	vrhLoadbalancerType := v.LoadbalancerTypeValidationRuleHandler
	rulesLoadbalancerType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLoadbalancerType(rulesLoadbalancerType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HTTPLBRequest.loadbalancer_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["loadbalancer_type"] = vFn

	vrhServerValidationChoice := v.ServerValidationChoiceValidationRuleHandler
	rulesServerValidationChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhServerValidationChoice(rulesServerValidationChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HTTPLBRequest.server_validation_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["server_validation_choice"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HTTPLBRequest.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhDomain := v.DomainValidationRuleHandler
	rulesDomain := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.vh_domain": "true",
	}
	vFn, err = vrhDomain(rulesDomain)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HTTPLBRequest.domain: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain"] = vFn

	v.FldValidators["advertise_choice.advertise_custom"] = ves_io_schema_views.AdvertiseCustomValidator().Validate

	v.FldValidators["loadbalancer_type.https"] = ProxyTypeHttpsValidator().Validate
	v.FldValidators["loadbalancer_type.http"] = ProxyTypeHttpValidator().Validate

	v.FldValidators["server_validation_choice.trusted_ca"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func HTTPLBRequestValidator() db.Validator {
	return DefaultHTTPLBRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ListServicesRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListServicesRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListServicesRequest) DeepCopy() *ListServicesRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListServicesRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListServicesRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListServicesRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListServicesRequestValidator().Validate(ctx, m, opts...)
}

type ValidateListServicesRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListServicesRequest) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateListServicesRequest) ServiceTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for service_type")
	}

	return validatorFn, nil
}

func (v *ValidateListServicesRequest) DiscoveryNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for discovery_name")
	}

	return validatorFn, nil
}

func (v *ValidateListServicesRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListServicesRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListServicesRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["discovery_name"]; exists {

		vOpts := append(opts, db.WithValidateField("discovery_name"))
		if err := fv(ctx, m.GetDiscoveryName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_type"]; exists {

		vOpts := append(opts, db.WithValidateField("service_type"))
		if err := fv(ctx, m.GetServiceType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListServicesRequestValidator = func() *ValidateListServicesRequest {
	v := &ValidateListServicesRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListServicesRequest.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhServiceType := v.ServiceTypeValidationRuleHandler
	rulesServiceType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.in":        "[\"bigip_virtual_server\"]",
	}
	vFn, err = vrhServiceType(rulesServiceType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListServicesRequest.service_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_type"] = vFn

	vrhDiscoveryName := v.DiscoveryNameValidationRuleHandler
	rulesDiscoveryName := map[string]string{
		"ves.io.schema.rules.string.ves_object_name": "true",
	}
	vFn, err = vrhDiscoveryName(rulesDiscoveryName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListServicesRequest.discovery_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["discovery_name"] = vFn

	return v
}()

func ListServicesRequestValidator() db.Validator {
	return DefaultListServicesRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ListServicesResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListServicesResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListServicesResponse) DeepCopy() *ListServicesResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListServicesResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListServicesResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListServicesResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListServicesResponseValidator().Validate(ctx, m, opts...)
}

func (m *ListServicesResponse) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetItemsDRefInfo()

}

// GetDRefInfo for the field's type
func (m *ListServicesResponse) GetItemsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetItems() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetItems() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetItems() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("items[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateListServicesResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListServicesResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListServicesResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListServicesResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["errors"]; exists {

		vOpts := append(opts, db.WithValidateField("errors"))
		for idx, item := range m.GetErrors() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["items"]; exists {

		vOpts := append(opts, db.WithValidateField("items"))
		for idx, item := range m.GetItems() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListServicesResponseValidator = func() *ValidateListServicesResponse {
	v := &ValidateListServicesResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["items"] = ListServicesResponseItemValidator().Validate

	return v
}()

func ListServicesResponseValidator() db.Validator {
	return DefaultListServicesResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *ListServicesResponseItem) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListServicesResponseItem) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListServicesResponseItem) DeepCopy() *ListServicesResponseItem {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListServicesResponseItem{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListServicesResponseItem) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListServicesResponseItem) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListServicesResponseItemValidator().Validate(ctx, m, opts...)
}

func (m *ListServicesResponseItem) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetGetSpecDRefInfo()

}

// GetDRefInfo for the field's type
func (m *ListServicesResponseItem) GetGetSpecDRefInfo() ([]db.DRefInfo, error) {
	if m.GetGetSpec() == nil {
		return nil, nil
	}

	drInfos, err := m.GetGetSpec().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetGetSpec().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "get_spec." + dri.DRField
	}
	return drInfos, err

}

type ValidateListServicesResponseItem struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListServicesResponseItem) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListServicesResponseItem)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListServicesResponseItem got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["annotations"]; exists {

		vOpts := append(opts, db.WithValidateField("annotations"))
		for key, value := range m.GetAnnotations() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disabled"]; exists {

		vOpts := append(opts, db.WithValidateField("disabled"))
		if err := fv(ctx, m.GetDisabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["get_spec"]; exists {

		vOpts := append(opts, db.WithValidateField("get_spec"))
		if err := fv(ctx, m.GetGetSpec(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["labels"]; exists {

		vOpts := append(opts, db.WithValidateField("labels"))
		for key, value := range m.GetLabels() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["owner_view"]; exists {

		vOpts := append(opts, db.WithValidateField("owner_view"))
		if err := fv(ctx, m.GetOwnerView(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status_set"]; exists {

		vOpts := append(opts, db.WithValidateField("status_set"))
		for idx, item := range m.GetStatusSet() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["system_metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("system_metadata"))
		if err := fv(ctx, m.GetSystemMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tenant"]; exists {

		vOpts := append(opts, db.WithValidateField("tenant"))
		if err := fv(ctx, m.GetTenant(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["uid"]; exists {

		vOpts := append(opts, db.WithValidateField("uid"))
		if err := fv(ctx, m.GetUid(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListServicesResponseItemValidator = func() *ValidateListServicesResponseItem {
	v := &ValidateListServicesResponseItem{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["metadata"] = ves_io_schema.ObjectGetMetaTypeValidator().Validate

	v.FldValidators["get_spec"] = GetSpecTypeValidator().Validate

	v.FldValidators["status_set"] = StatusObjectValidator().Validate

	return v
}()

func ListServicesResponseItemValidator() db.Validator {
	return DefaultListServicesResponseItemValidator
}

// augmented methods on protoc/std generated struct

func (m *ProxyTypeHttp) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ProxyTypeHttp) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ProxyTypeHttp) DeepCopy() *ProxyTypeHttp {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ProxyTypeHttp{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ProxyTypeHttp) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ProxyTypeHttp) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ProxyTypeHttpValidator().Validate(ctx, m, opts...)
}

func (m *ProxyTypeHttp) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetAdvertiseChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *ProxyTypeHttp) GetAdvertiseChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAdvertiseChoice() == nil {
		return nil, nil
	}
	switch m.GetAdvertiseChoice().(type) {
	case *ProxyTypeHttp_AdvertiseOnPublicDefaultVip:

		return nil, nil

	case *ProxyTypeHttp_Site:

		drInfos, err := m.GetSite().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSite().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "site." + dri.DRField
		}
		return drInfos, err

	case *ProxyTypeHttp_VirtualSite:

		drInfos, err := m.GetVirtualSite().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetVirtualSite().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "virtual_site." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateProxyTypeHttp struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateProxyTypeHttp) AdvertiseChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for advertise_choice")
	}
	return validatorFn, nil
}

func (v *ValidateProxyTypeHttp) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ProxyTypeHttp)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ProxyTypeHttp got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advertise_choice"]; exists {
		val := m.GetAdvertiseChoice()
		vOpts := append(opts,
			db.WithValidateField("advertise_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAdvertiseChoice().(type) {
	case *ProxyTypeHttp_AdvertiseOnPublicDefaultVip:
		if fv, exists := v.FldValidators["advertise_choice.advertise_on_public_default_vip"]; exists {
			val := m.GetAdvertiseChoice().(*ProxyTypeHttp_AdvertiseOnPublicDefaultVip).AdvertiseOnPublicDefaultVip
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("advertise_on_public_default_vip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ProxyTypeHttp_Site:
		if fv, exists := v.FldValidators["advertise_choice.site"]; exists {
			val := m.GetAdvertiseChoice().(*ProxyTypeHttp_Site).Site
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ProxyTypeHttp_VirtualSite:
		if fv, exists := v.FldValidators["advertise_choice.virtual_site"]; exists {
			val := m.GetAdvertiseChoice().(*ProxyTypeHttp_VirtualSite).VirtualSite
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("virtual_site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultProxyTypeHttpValidator = func() *ValidateProxyTypeHttp {
	v := &ValidateProxyTypeHttp{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAdvertiseChoice := v.AdvertiseChoiceValidationRuleHandler
	rulesAdvertiseChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAdvertiseChoice(rulesAdvertiseChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProxyTypeHttp.advertise_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["advertise_choice"] = vFn

	v.FldValidators["advertise_choice.site"] = WhereSiteValidator().Validate
	v.FldValidators["advertise_choice.virtual_site"] = WhereVirtualSiteValidator().Validate

	return v
}()

func ProxyTypeHttpValidator() db.Validator {
	return DefaultProxyTypeHttpValidator
}

// augmented methods on protoc/std generated struct

func (m *ProxyTypeHttps) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ProxyTypeHttps) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ProxyTypeHttps) DeepCopy() *ProxyTypeHttps {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ProxyTypeHttps{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ProxyTypeHttps) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ProxyTypeHttps) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ProxyTypeHttpsValidator().Validate(ctx, m, opts...)
}

func (m *ProxyTypeHttps) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAdvertiseChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAdvertiseChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetCertificatesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetCertificatesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *ProxyTypeHttps) GetAdvertiseChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAdvertiseChoice() == nil {
		return nil, nil
	}
	switch m.GetAdvertiseChoice().(type) {
	case *ProxyTypeHttps_AdvertiseOnPublicDefaultVip:

		return nil, nil

	case *ProxyTypeHttps_Site:

		drInfos, err := m.GetSite().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSite().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "site." + dri.DRField
		}
		return drInfos, err

	case *ProxyTypeHttps_VirtualSite:

		drInfos, err := m.GetVirtualSite().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetVirtualSite().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "virtual_site." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

func (m *ProxyTypeHttps) GetCertificatesDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetCertificates()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("ProxyTypeHttps.certificates[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "certificate.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "certificates",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetCertificatesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ProxyTypeHttps) GetCertificatesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "certificate.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: certificate")
	}
	for _, ref := range m.GetCertificates() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateProxyTypeHttps struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateProxyTypeHttps) AdvertiseChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for advertise_choice")
	}
	return validatorFn, nil
}

func (v *ValidateProxyTypeHttps) CertificatesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for certificates")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for certificates")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated certificates")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items certificates")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateProxyTypeHttps) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ProxyTypeHttps)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ProxyTypeHttps got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advertise_choice"]; exists {
		val := m.GetAdvertiseChoice()
		vOpts := append(opts,
			db.WithValidateField("advertise_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAdvertiseChoice().(type) {
	case *ProxyTypeHttps_AdvertiseOnPublicDefaultVip:
		if fv, exists := v.FldValidators["advertise_choice.advertise_on_public_default_vip"]; exists {
			val := m.GetAdvertiseChoice().(*ProxyTypeHttps_AdvertiseOnPublicDefaultVip).AdvertiseOnPublicDefaultVip
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("advertise_on_public_default_vip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ProxyTypeHttps_Site:
		if fv, exists := v.FldValidators["advertise_choice.site"]; exists {
			val := m.GetAdvertiseChoice().(*ProxyTypeHttps_Site).Site
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ProxyTypeHttps_VirtualSite:
		if fv, exists := v.FldValidators["advertise_choice.virtual_site"]; exists {
			val := m.GetAdvertiseChoice().(*ProxyTypeHttps_VirtualSite).VirtualSite
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("virtual_site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["certificates"]; exists {
		vOpts := append(opts, db.WithValidateField("certificates"))
		if err := fv(ctx, m.GetCertificates(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultProxyTypeHttpsValidator = func() *ValidateProxyTypeHttps {
	v := &ValidateProxyTypeHttps{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAdvertiseChoice := v.AdvertiseChoiceValidationRuleHandler
	rulesAdvertiseChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAdvertiseChoice(rulesAdvertiseChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProxyTypeHttps.advertise_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["advertise_choice"] = vFn

	vrhCertificates := v.CertificatesValidationRuleHandler
	rulesCertificates := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhCertificates(rulesCertificates)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProxyTypeHttps.certificates: %s", err)
		panic(errMsg)
	}
	v.FldValidators["certificates"] = vFn

	v.FldValidators["advertise_choice.site"] = WhereSiteValidator().Validate
	v.FldValidators["advertise_choice.virtual_site"] = WhereVirtualSiteValidator().Validate

	return v
}()

func ProxyTypeHttpsValidator() db.Validator {
	return DefaultProxyTypeHttpsValidator
}

// augmented methods on protoc/std generated struct

func (m *TCPLBRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TCPLBRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TCPLBRequest) DeepCopy() *TCPLBRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TCPLBRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TCPLBRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TCPLBRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TCPLBRequestValidator().Validate(ctx, m, opts...)
}

func (m *TCPLBRequest) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetAdvertiseChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *TCPLBRequest) GetAdvertiseChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAdvertiseChoice() == nil {
		return nil, nil
	}
	switch m.GetAdvertiseChoice().(type) {
	case *TCPLBRequest_AdvertiseOnPublicDefaultVip:

		return nil, nil

	case *TCPLBRequest_AdvertiseCustom:

		drInfos, err := m.GetAdvertiseCustom().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAdvertiseCustom().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "advertise_custom." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateTCPLBRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTCPLBRequest) AdvertiseChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for advertise_choice")
	}
	return validatorFn, nil
}

func (v *ValidateTCPLBRequest) PortChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port_choice")
	}
	return validatorFn, nil
}

func (v *ValidateTCPLBRequest) PortChoiceListenPortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ListenPort, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for listen_port")
	}
	return oValidatorFn_ListenPort, nil
}
func (v *ValidateTCPLBRequest) PortChoicePortRangesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_PortRanges, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port_ranges")
	}
	return oValidatorFn_PortRanges, nil
}

func (v *ValidateTCPLBRequest) SniDefaultLbChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for sni_default_lb_choice")
	}
	return validatorFn, nil
}

func (v *ValidateTCPLBRequest) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateTCPLBRequest) DomainValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain")
	}

	return validatorFn, nil
}

func (v *ValidateTCPLBRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TCPLBRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TCPLBRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advertise_choice"]; exists {
		val := m.GetAdvertiseChoice()
		vOpts := append(opts,
			db.WithValidateField("advertise_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAdvertiseChoice().(type) {
	case *TCPLBRequest_AdvertiseOnPublicDefaultVip:
		if fv, exists := v.FldValidators["advertise_choice.advertise_on_public_default_vip"]; exists {
			val := m.GetAdvertiseChoice().(*TCPLBRequest_AdvertiseOnPublicDefaultVip).AdvertiseOnPublicDefaultVip
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("advertise_on_public_default_vip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TCPLBRequest_AdvertiseCustom:
		if fv, exists := v.FldValidators["advertise_choice.advertise_custom"]; exists {
			val := m.GetAdvertiseChoice().(*TCPLBRequest_AdvertiseCustom).AdvertiseCustom
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("advertise_custom"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["domain"]; exists {

		vOpts := append(opts, db.WithValidateField("domain"))
		if err := fv(ctx, m.GetDomain(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["port_choice"]; exists {
		val := m.GetPortChoice()
		vOpts := append(opts,
			db.WithValidateField("port_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPortChoice().(type) {
	case *TCPLBRequest_ListenPort:
		if fv, exists := v.FldValidators["port_choice.listen_port"]; exists {
			val := m.GetPortChoice().(*TCPLBRequest_ListenPort).ListenPort
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("listen_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TCPLBRequest_PortRanges:
		if fv, exists := v.FldValidators["port_choice.port_ranges"]; exists {
			val := m.GetPortChoice().(*TCPLBRequest_PortRanges).PortRanges
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("port_ranges"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["sni_default_lb_choice"]; exists {
		val := m.GetSniDefaultLbChoice()
		vOpts := append(opts,
			db.WithValidateField("sni_default_lb_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSniDefaultLbChoice().(type) {
	case *TCPLBRequest_NoSni:
		if fv, exists := v.FldValidators["sni_default_lb_choice.no_sni"]; exists {
			val := m.GetSniDefaultLbChoice().(*TCPLBRequest_NoSni).NoSni
			vOpts := append(opts,
				db.WithValidateField("sni_default_lb_choice"),
				db.WithValidateField("no_sni"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TCPLBRequest_Sni:
		if fv, exists := v.FldValidators["sni_default_lb_choice.sni"]; exists {
			val := m.GetSniDefaultLbChoice().(*TCPLBRequest_Sni).Sni
			vOpts := append(opts,
				db.WithValidateField("sni_default_lb_choice"),
				db.WithValidateField("sni"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTCPLBRequestValidator = func() *ValidateTCPLBRequest {
	v := &ValidateTCPLBRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAdvertiseChoice := v.AdvertiseChoiceValidationRuleHandler
	rulesAdvertiseChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAdvertiseChoice(rulesAdvertiseChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TCPLBRequest.advertise_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["advertise_choice"] = vFn

	vrhPortChoice := v.PortChoiceValidationRuleHandler
	rulesPortChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPortChoice(rulesPortChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TCPLBRequest.port_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port_choice"] = vFn

	vrhPortChoiceListenPort := v.PortChoiceListenPortValidationRuleHandler
	rulesPortChoiceListenPort := map[string]string{
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFnMap["port_choice.listen_port"], err = vrhPortChoiceListenPort(rulesPortChoiceListenPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field TCPLBRequest.port_choice_listen_port: %s", err)
		panic(errMsg)
	}
	vrhPortChoicePortRanges := v.PortChoicePortRangesValidationRuleHandler
	rulesPortChoicePortRanges := map[string]string{
		"ves.io.schema.rules.string.max_len":                "512",
		"ves.io.schema.rules.string.max_ports":              "64",
		"ves.io.schema.rules.string.min_len":                "1",
		"ves.io.schema.rules.string.unique_port_range_list": "true",
	}
	vFnMap["port_choice.port_ranges"], err = vrhPortChoicePortRanges(rulesPortChoicePortRanges)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field TCPLBRequest.port_choice_port_ranges: %s", err)
		panic(errMsg)
	}

	v.FldValidators["port_choice.listen_port"] = vFnMap["port_choice.listen_port"]
	v.FldValidators["port_choice.port_ranges"] = vFnMap["port_choice.port_ranges"]

	vrhSniDefaultLbChoice := v.SniDefaultLbChoiceValidationRuleHandler
	rulesSniDefaultLbChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSniDefaultLbChoice(rulesSniDefaultLbChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TCPLBRequest.sni_default_lb_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["sni_default_lb_choice"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TCPLBRequest.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhDomain := v.DomainValidationRuleHandler
	rulesDomain := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.vh_domain": "true",
	}
	vFn, err = vrhDomain(rulesDomain)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TCPLBRequest.domain: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain"] = vFn

	v.FldValidators["advertise_choice.advertise_custom"] = ves_io_schema_views.AdvertiseCustomValidator().Validate

	return v
}()

func TCPLBRequestValidator() db.Validator {
	return DefaultTCPLBRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *WhereSite) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WhereSite) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WhereSite) DeepCopy() *WhereSite {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WhereSite{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WhereSite) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WhereSite) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WhereSiteValidator().Validate(ctx, m, opts...)
}

func (m *WhereSite) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetSiteDRefInfo()

}

func (m *WhereSite) GetSiteDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetSite()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("WhereSite.site[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "site.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "site",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetSiteDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *WhereSite) GetSiteDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: site")
	}
	for _, ref := range m.GetSite() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateWhereSite struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWhereSite) SiteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for site")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for site")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated site")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items site")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateWhereSite) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WhereSite)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WhereSite got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["site"]; exists {
		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWhereSiteValidator = func() *ValidateWhereSite {
	v := &ValidateWhereSite{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSite := v.SiteValidationRuleHandler
	rulesSite := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhSite(rulesSite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereSite.site: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site"] = vFn

	return v
}()

func WhereSiteValidator() db.Validator {
	return DefaultWhereSiteValidator
}

// augmented methods on protoc/std generated struct

func (m *WhereVirtualSite) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WhereVirtualSite) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WhereVirtualSite) DeepCopy() *WhereVirtualSite {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WhereVirtualSite{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WhereVirtualSite) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WhereVirtualSite) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WhereVirtualSiteValidator().Validate(ctx, m, opts...)
}

func (m *WhereVirtualSite) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetVirtualSiteDRefInfo()

}

func (m *WhereVirtualSite) GetVirtualSiteDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetVirtualSite()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("WhereVirtualSite.virtual_site[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_site.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "virtual_site",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetVirtualSiteDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *WhereVirtualSite) GetVirtualSiteDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_site")
	}
	for _, ref := range m.GetVirtualSite() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateWhereVirtualSite struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWhereVirtualSite) VirtualSiteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for virtual_site")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for virtual_site")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated virtual_site")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items virtual_site")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateWhereVirtualSite) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WhereVirtualSite)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WhereVirtualSite got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["virtual_site"]; exists {
		vOpts := append(opts, db.WithValidateField("virtual_site"))
		if err := fv(ctx, m.GetVirtualSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWhereVirtualSiteValidator = func() *ValidateWhereVirtualSite {
	v := &ValidateWhereVirtualSite{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhVirtualSite := v.VirtualSiteValidationRuleHandler
	rulesVirtualSite := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhVirtualSite(rulesVirtualSite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereVirtualSite.virtual_site: %s", err)
		panic(errMsg)
	}
	v.FldValidators["virtual_site"] = vFn

	return v
}()

func WhereVirtualSiteValidator() db.Validator {
	return DefaultWhereVirtualSiteValidator
}
