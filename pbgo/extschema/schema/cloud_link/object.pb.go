// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/cloud_link/object.proto

package cloud_link

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/vesenv"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Cloud Link Object
//
// x-displayName: "Cloud Link"
// Cloud Link object represents private connectivity from customer network to CE Site or RE Site to CE Site
type Object struct {
	// metadata
	//
	// x-displayName: "Metadata"
	// Standard object's metadata
	Metadata *schema.ObjectMetaType `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// system_metadata
	//
	// x-displayName: "System Metadata"
	// System generated object's metadata
	SystemMetadata *schema.SystemObjectMetaType `protobuf:"bytes,2,opt,name=system_metadata,json=systemMetadata,proto3" json:"system_metadata,omitempty"`
	// spec
	//
	// x-displayName: "Spec"
	// Specification of the desired behavior of the Cloud Link
	Spec *SpecType `protobuf:"bytes,3,opt,name=spec,proto3" json:"spec,omitempty"`
}

func (m *Object) Reset()      { *m = Object{} }
func (*Object) ProtoMessage() {}
func (*Object) Descriptor() ([]byte, []int) {
	return fileDescriptor_c87a7a97fd6ae754, []int{0}
}
func (m *Object) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Object) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Object) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Object.Merge(m, src)
}
func (m *Object) XXX_Size() int {
	return m.Size()
}
func (m *Object) XXX_DiscardUnknown() {
	xxx_messageInfo_Object.DiscardUnknown(m)
}

var xxx_messageInfo_Object proto.InternalMessageInfo

func (m *Object) GetMetadata() *schema.ObjectMetaType {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Object) GetSystemMetadata() *schema.SystemObjectMetaType {
	if m != nil {
		return m.SystemMetadata
	}
	return nil
}

func (m *Object) GetSpec() *SpecType {
	if m != nil {
		return m.Spec
	}
	return nil
}

// Specification for Cloud Link
//
// x-displayName: "Specification"
// Shape of the Cloud Link specification
type SpecType struct {
	// gc_spec
	//
	// x-displayName: "GC Spec"
	GcSpec *GlobalSpecType `protobuf:"bytes,2,opt,name=gc_spec,json=gcSpec,proto3" json:"gc_spec,omitempty"`
}

func (m *SpecType) Reset()      { *m = SpecType{} }
func (*SpecType) ProtoMessage() {}
func (*SpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_c87a7a97fd6ae754, []int{1}
}
func (m *SpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpecType.Merge(m, src)
}
func (m *SpecType) XXX_Size() int {
	return m.Size()
}
func (m *SpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_SpecType.DiscardUnknown(m)
}

var xxx_messageInfo_SpecType proto.InternalMessageInfo

func (m *SpecType) GetGcSpec() *GlobalSpecType {
	if m != nil {
		return m.GcSpec
	}
	return nil
}

// Status for Cloud Link
//
// x-displayName: "Status"
// Most recently observed status of object
type StatusObject struct {
	// metadata
	//
	// x-displayName: "Metadata"
	// Standard status's metadata
	Metadata *schema.StatusMetaType `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// object_refs
	//
	// x-displayName: "Config Object"
	// Reference to object for current status
	ObjectRefs []*schema.ObjectRefType `protobuf:"bytes,2,rep,name=object_refs,json=objectRefs,proto3" json:"object_refs,omitempty"`
	// conditions
	//
	// x-displayName: "Conditions"
	// Conditions reported by various component of the system
	Conditions []*schema.ConditionType `protobuf:"bytes,3,rep,name=conditions,proto3" json:"conditions,omitempty"`
	// Cloud Link Status
	//
	// x-displayName: "Cloud Link Status"
	// Status reported to this Cloud Link and associated cloud components
	//
	// Types that are valid to be assigned to CloudLinkStatus:
	//	*StatusObject_AwsStatus
	//	*StatusObject_AzureStatus
	//	*StatusObject_GcpStatus
	CloudLinkStatus isStatusObject_CloudLinkStatus `protobuf_oneof:"cloud_link_status"`
}

func (m *StatusObject) Reset()      { *m = StatusObject{} }
func (*StatusObject) ProtoMessage() {}
func (*StatusObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_c87a7a97fd6ae754, []int{2}
}
func (m *StatusObject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StatusObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusObject.Merge(m, src)
}
func (m *StatusObject) XXX_Size() int {
	return m.Size()
}
func (m *StatusObject) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusObject.DiscardUnknown(m)
}

var xxx_messageInfo_StatusObject proto.InternalMessageInfo

type isStatusObject_CloudLinkStatus interface {
	isStatusObject_CloudLinkStatus()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type StatusObject_AwsStatus struct {
	AwsStatus *AWSStatusType `protobuf:"bytes,5,opt,name=aws_status,json=awsStatus,proto3,oneof" json:"aws_status,omitempty"`
}
type StatusObject_AzureStatus struct {
	AzureStatus *AzureStatusType `protobuf:"bytes,6,opt,name=azure_status,json=azureStatus,proto3,oneof" json:"azure_status,omitempty"`
}
type StatusObject_GcpStatus struct {
	GcpStatus *GCPStatusType `protobuf:"bytes,7,opt,name=gcp_status,json=gcpStatus,proto3,oneof" json:"gcp_status,omitempty"`
}

func (*StatusObject_AwsStatus) isStatusObject_CloudLinkStatus()   {}
func (*StatusObject_AzureStatus) isStatusObject_CloudLinkStatus() {}
func (*StatusObject_GcpStatus) isStatusObject_CloudLinkStatus()   {}

func (m *StatusObject) GetCloudLinkStatus() isStatusObject_CloudLinkStatus {
	if m != nil {
		return m.CloudLinkStatus
	}
	return nil
}

func (m *StatusObject) GetMetadata() *schema.StatusMetaType {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *StatusObject) GetObjectRefs() []*schema.ObjectRefType {
	if m != nil {
		return m.ObjectRefs
	}
	return nil
}

func (m *StatusObject) GetConditions() []*schema.ConditionType {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *StatusObject) GetAwsStatus() *AWSStatusType {
	if x, ok := m.GetCloudLinkStatus().(*StatusObject_AwsStatus); ok {
		return x.AwsStatus
	}
	return nil
}

func (m *StatusObject) GetAzureStatus() *AzureStatusType {
	if x, ok := m.GetCloudLinkStatus().(*StatusObject_AzureStatus); ok {
		return x.AzureStatus
	}
	return nil
}

func (m *StatusObject) GetGcpStatus() *GCPStatusType {
	if x, ok := m.GetCloudLinkStatus().(*StatusObject_GcpStatus); ok {
		return x.GcpStatus
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StatusObject) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StatusObject_AwsStatus)(nil),
		(*StatusObject_AzureStatus)(nil),
		(*StatusObject_GcpStatus)(nil),
	}
}

// Amazon Web Services (AWS) Cloud Link Status
//
// x-displayName: "Amazon Web Services (AWS) Cloud Link Status"
// Status reported by this Cloud Link and associated Amazon Web Services (AWS) cloud components
type AWSStatusType struct {
	// CloudLink Direct Connect Connection Status
	//
	// x-displayName: "CloudLink Direct Connect Connection Status"
	// Status reported by Amazon Web Services (AWS) CloudLink Connection
	ConnectionStatus []*DirectConnectConnectionStatusType `protobuf:"bytes,2,rep,name=connection_status,json=connectionStatus,proto3" json:"connection_status,omitempty"`
	// Suggested Action
	//
	// x-displayName: "Suggested Action"
	// x-example: "value"
	// Suggested action for customer on error
	SuggestedAction string `protobuf:"bytes,5,opt,name=suggested_action,json=suggestedAction,proto3" json:"suggested_action,omitempty"`
	// Error Description
	//
	// x-displayName: "Error Description"
	// x-example: "value"
	// Description of error on site
	ErrorDescription string `protobuf:"bytes,6,opt,name=error_description,json=errorDescription,proto3" json:"error_description,omitempty"`
	// CloudLink State
	//
	// x-displayName: "CloudLink State"
	// State of the connections with the CloudLink deployment
	CloudLinkState schema.CloudLinkState `protobuf:"varint,7,opt,name=cloud_link_state,json=cloudLinkState,proto3,enum=ves.io.schema.CloudLinkState" json:"cloud_link_state,omitempty"`
	// CloudLink Deployment Status
	//
	// x-displayName: "Status"
	// Status of the CloudLink deployment
	DeploymentStatus CloudLinkDeploymentStatus `protobuf:"varint,8,opt,name=deployment_status,json=deploymentStatus,proto3,enum=ves.io.schema.cloud_link.CloudLinkDeploymentStatus" json:"deployment_status,omitempty"`
}

func (m *AWSStatusType) Reset()      { *m = AWSStatusType{} }
func (*AWSStatusType) ProtoMessage() {}
func (*AWSStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_c87a7a97fd6ae754, []int{3}
}
func (m *AWSStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSStatusType.Merge(m, src)
}
func (m *AWSStatusType) XXX_Size() int {
	return m.Size()
}
func (m *AWSStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSStatusType proto.InternalMessageInfo

func (m *AWSStatusType) GetConnectionStatus() []*DirectConnectConnectionStatusType {
	if m != nil {
		return m.ConnectionStatus
	}
	return nil
}

func (m *AWSStatusType) GetSuggestedAction() string {
	if m != nil {
		return m.SuggestedAction
	}
	return ""
}

func (m *AWSStatusType) GetErrorDescription() string {
	if m != nil {
		return m.ErrorDescription
	}
	return ""
}

func (m *AWSStatusType) GetCloudLinkState() schema.CloudLinkState {
	if m != nil {
		return m.CloudLinkState
	}
	return schema.UP
}

func (m *AWSStatusType) GetDeploymentStatus() CloudLinkDeploymentStatus {
	if m != nil {
		return m.DeploymentStatus
	}
	return IN_PROGRESS
}

// CloudLink Direct Connect Connection Status
//
// x-displayName: "CloudLink Direct Connect Connection Status"
// Status reported by Amazon Web Services (AWS) Direct Connect Connection related to this Cloud Link
type DirectConnectConnectionStatusType struct {
	// Bandwidth
	//
	// x-displayName: "Bandwidth"
	// The bandwidth of the connection.
	Bandwidth string `protobuf:"bytes,1,opt,name=bandwidth,proto3" json:"bandwidth,omitempty"`
	// Connection Id
	//
	// x-displayName: "Connection Id"
	// The ID of the direct connect connection
	ConnectionId string `protobuf:"bytes,2,opt,name=connection_id,json=connectionId,proto3" json:"connection_id,omitempty"`
	// Connection Name
	//
	// x-displayName: "Connection Name"
	// The Name of the connection
	ConnectionName string `protobuf:"bytes,3,opt,name=connection_name,json=connectionName,proto3" json:"connection_name,omitempty"`
	// Connection State
	//
	// x-displayName: "Connection State"
	// The state of the Direct Connect Connection
	ConnectionState string `protobuf:"bytes,4,opt,name=connection_state,json=connectionState,proto3" json:"connection_state,omitempty"`
	// Logical Redundancy Status
	//
	// x-displayName: "Logical Redundancy Status"
	// Whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6)
	HasLogicalRedundancy string `protobuf:"bytes,5,opt,name=has_logical_redundancy,json=hasLogicalRedundancy,proto3" json:"has_logical_redundancy,omitempty"`
	// Location
	//
	// x-displayName: "Location"
	// Location of the connection
	Location string `protobuf:"bytes,6,opt,name=location,proto3" json:"location,omitempty"`
	// Connection Partner
	//
	// x-displayName: "Connection Partner"
	// The name of the AWS Direct Connect service provider associated with the connection.
	PartnerName string `protobuf:"bytes,7,opt,name=partner_name,json=partnerName,proto3" json:"partner_name,omitempty"`
	// Connection Provider
	//
	// x-displayName: "Connection Provider"
	// The name of the service provider associated with the connection.
	ProviderName string `protobuf:"bytes,8,opt,name=provider_name,json=providerName,proto3" json:"provider_name,omitempty"`
	// Region
	//
	// x-displayName: "Region"
	// Region where the connection is located
	Region string `protobuf:"bytes,9,opt,name=region,proto3" json:"region,omitempty"`
	// AWS Tags
	//
	// x-displayName: "AWS Tags"
	// x-example: "dev: staging"
	// AWS Tags is a label consisting of a user-defined key and value which are assocaited with this coonnection.
	// It helps to manage, identify, organize, search for, and filter resources in AWS console.
	Tags map[string]string `protobuf:"bytes,10,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Virtual Local Area Network (VLAN)
	//
	// x-displayName: "Virtual Local Area Network (VLAN)"
	// x-example: "700"
	// Virtual Local Area Network number for the new virtual interface to be configured on the AWS.
	Vlan uint32 `protobuf:"varint,11,opt,name=vlan,proto3" json:"vlan,omitempty"`
	// Jumbo Frame Capable
	//
	// x-displayName: "Jumbo Frame Capable"
	// Indicates whether jumbo frames (9001 MTU) are supported.
	JumboFrameCapable bool `protobuf:"varint,12,opt,name=jumbo_frame_capable,json=jumboFrameCapable,proto3" json:"jumbo_frame_capable,omitempty"`
	// Owner Account
	//
	// x-displayName: "Owner Account"
	// The ID of the AWS account that owns the connection
	OwnerAccount string `protobuf:"bytes,13,opt,name=owner_account,json=ownerAccount,proto3" json:"owner_account,omitempty"`
	// Virtual Interface Status
	//
	// x-displayName: "Virtual Interface Status"
	// Status reported by Amazon Web Services (AWS) Virtual Interface Status related to this Cloud Link
	VifStatus *VirtualInterfaceStatusType `protobuf:"bytes,14,opt,name=vif_status,json=vifStatus,proto3" json:"vif_status,omitempty"`
	// Direct Connect Gateway Status
	//
	// x-displayName: "Direct Connect Gateway Status"
	// Status reported by Amazon Web Services (AWS) Direct Connect Gateway Status and associations related to this Cloud Link
	GatewayStatus *DirectConnectGatewayStatusType `protobuf:"bytes,15,opt,name=gateway_status,json=gatewayStatus,proto3" json:"gateway_status,omitempty"`
	// AWS Object Link
	//
	// x-displayName: "AWS Object Link"
	// Link to Amazon Web Services (AWS) object
	AwsPath string `protobuf:"bytes,17,opt,name=aws_path,json=awsPath,proto3" json:"aws_path,omitempty"`
}

func (m *DirectConnectConnectionStatusType) Reset()      { *m = DirectConnectConnectionStatusType{} }
func (*DirectConnectConnectionStatusType) ProtoMessage() {}
func (*DirectConnectConnectionStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_c87a7a97fd6ae754, []int{4}
}
func (m *DirectConnectConnectionStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DirectConnectConnectionStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DirectConnectConnectionStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirectConnectConnectionStatusType.Merge(m, src)
}
func (m *DirectConnectConnectionStatusType) XXX_Size() int {
	return m.Size()
}
func (m *DirectConnectConnectionStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_DirectConnectConnectionStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_DirectConnectConnectionStatusType proto.InternalMessageInfo

func (m *DirectConnectConnectionStatusType) GetBandwidth() string {
	if m != nil {
		return m.Bandwidth
	}
	return ""
}

func (m *DirectConnectConnectionStatusType) GetConnectionId() string {
	if m != nil {
		return m.ConnectionId
	}
	return ""
}

func (m *DirectConnectConnectionStatusType) GetConnectionName() string {
	if m != nil {
		return m.ConnectionName
	}
	return ""
}

func (m *DirectConnectConnectionStatusType) GetConnectionState() string {
	if m != nil {
		return m.ConnectionState
	}
	return ""
}

func (m *DirectConnectConnectionStatusType) GetHasLogicalRedundancy() string {
	if m != nil {
		return m.HasLogicalRedundancy
	}
	return ""
}

func (m *DirectConnectConnectionStatusType) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *DirectConnectConnectionStatusType) GetPartnerName() string {
	if m != nil {
		return m.PartnerName
	}
	return ""
}

func (m *DirectConnectConnectionStatusType) GetProviderName() string {
	if m != nil {
		return m.ProviderName
	}
	return ""
}

func (m *DirectConnectConnectionStatusType) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *DirectConnectConnectionStatusType) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *DirectConnectConnectionStatusType) GetVlan() uint32 {
	if m != nil {
		return m.Vlan
	}
	return 0
}

func (m *DirectConnectConnectionStatusType) GetJumboFrameCapable() bool {
	if m != nil {
		return m.JumboFrameCapable
	}
	return false
}

func (m *DirectConnectConnectionStatusType) GetOwnerAccount() string {
	if m != nil {
		return m.OwnerAccount
	}
	return ""
}

func (m *DirectConnectConnectionStatusType) GetVifStatus() *VirtualInterfaceStatusType {
	if m != nil {
		return m.VifStatus
	}
	return nil
}

func (m *DirectConnectConnectionStatusType) GetGatewayStatus() *DirectConnectGatewayStatusType {
	if m != nil {
		return m.GatewayStatus
	}
	return nil
}

func (m *DirectConnectConnectionStatusType) GetAwsPath() string {
	if m != nil {
		return m.AwsPath
	}
	return ""
}

// Virtual Interface Status
//
// x-displayName: "Virtual Interface Status"
// Status reported by Amazon Web Services (AWS) Virtual Interface Status related to this Cloud Link
type VirtualInterfaceStatusType struct {
	// Address Family
	//
	// x-displayName: "Address Family"
	// The address family setup for the BGP peer.
	AddressFamily string `protobuf:"bytes,1,opt,name=address_family,json=addressFamily,proto3" json:"address_family,omitempty"`
	// AWS Router Peer IP
	//
	// x-displayName: "AWS Router Peer IP"
	// The BGP peer IP configured on the AWS endpoint
	AmazonAddress string `protobuf:"bytes,2,opt,name=amazon_address,json=amazonAddress,proto3" json:"amazon_address,omitempty"`
	// Amazon Web Services (AWS) ASN
	//
	// x-displayName: "Amazon Web Services (AWS) ASN"
	// The autonomous system number (ASN) for the Amazon side of the connection
	AmazonAsn uint64 `protobuf:"varint,3,opt,name=amazon_asn,json=amazonAsn,proto3" json:"amazon_asn,omitempty"`
	// Border Gateway Protocol (BGP) ASN
	//
	// x-displayName: "Border Gateway Protocol (BGP) ASN"
	// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration
	BgpAsn uint32 `protobuf:"varint,4,opt,name=bgp_asn,json=bgpAsn,proto3" json:"bgp_asn,omitempty"`
	// Connection Id
	//
	// x-displayName: "Connection Id"
	// The ID of the direct connect connection
	ConnectionId string `protobuf:"bytes,5,opt,name=connection_id,json=connectionId,proto3" json:"connection_id,omitempty"`
	// Gateway Id
	//
	// x-displayName: "Gateway Id"
	// The ID of the direct connect gateway
	DirectConnectGatewayId string `protobuf:"bytes,6,opt,name=direct_connect_gateway_id,json=directConnectGatewayId,proto3" json:"direct_connect_gateway_id,omitempty"`
	// Gateway Name
	//
	// x-displayName: "Gateway Name"
	// The Name of the direct connect gateway
	DirectConnectGatewayName string `protobuf:"bytes,7,opt,name=direct_connect_gateway_name,json=directConnectGatewayName,proto3" json:"direct_connect_gateway_name,omitempty"`
	// Virtual Interface State
	//
	// x-displayName: "Virtual Interface State"
	// The state of the virtual interface
	VirtualInterfaceState string `protobuf:"bytes,8,opt,name=virtual_interface_state,json=virtualInterfaceState,proto3" json:"virtual_interface_state,omitempty"`
	// Location
	//
	// x-displayName: "Location"
	// Location where the virtual interface is located
	Location string `protobuf:"bytes,9,opt,name=location,proto3" json:"location,omitempty"`
	// Region
	//
	// x-displayName: "Region"
	// Region where the virtual interface is located
	Region string `protobuf:"bytes,10,opt,name=region,proto3" json:"region,omitempty"`
	// AWS Tags
	//
	// x-displayName: "AWS Tags"
	// x-example: "dev: staging"
	// AWS Tags is a label consisting of a user-defined key and value which are assocaited with this coonnection.
	// It helps to manage, identify, organize, search for, and filter resources in AWS console.
	Tags map[string]string `protobuf:"bytes,11,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Virtual Local Area Network (VLAN)
	//
	// x-displayName: "Virtual Local Area Network (VLAN)"
	// x-example: "700"
	// Virtual Local Area Network number for the new virtual interface to be configured on the AWS.
	Vlan uint32 `protobuf:"varint,12,opt,name=vlan,proto3" json:"vlan,omitempty"`
	// Virtual Interface Id
	//
	// x-displayName: "Virtual Interface Id"
	// ID of the virtual interface
	VirtualInterfaceId string `protobuf:"bytes,13,opt,name=virtual_interface_id,json=virtualInterfaceId,proto3" json:"virtual_interface_id,omitempty"`
	// Virtual Interface Name
	//
	// x-displayName: "Virtual Interface Name"
	// Name of the virtual interface
	VirtualInterfaceName string `protobuf:"bytes,14,opt,name=virtual_interface_name,json=virtualInterfaceName,proto3" json:"virtual_interface_name,omitempty"`
	// Virtual Interface Type
	//
	// x-displayName: "Virtual Interface Type"
	// Type of the virtual interface
	VirtualInterfaceType string `protobuf:"bytes,15,opt,name=virtual_interface_type,json=virtualInterfaceType,proto3" json:"virtual_interface_type,omitempty"`
	// BGP Peers
	//
	// x-displayName: "BGP Peers"
	// The BGP peers configured on this virtual interface.
	BgpPeers []*BGPPeerType `protobuf:"bytes,16,rep,name=bgp_peers,json=bgpPeers,proto3" json:"bgp_peers,omitempty"`
	// Jumbo Frame Capable
	//
	// x-displayName: "Jumbo Frame Capable"
	// Indicates whether jumbo frames (9001 MTU) are supported.
	JumboFrameCapable bool `protobuf:"varint,17,opt,name=jumbo_frame_capable,json=jumboFrameCapable,proto3" json:"jumbo_frame_capable,omitempty"`
	// Maximum Transmission Unit (MTU)
	//
	// x-displayName: "Maximum Transmission Unit (MTU)"
	// The maximum transmission unit (MTU), in bytes.
	Mtu uint32 `protobuf:"varint,18,opt,name=mtu,proto3" json:"mtu,omitempty"`
	// Owner Account
	//
	// x-displayName: "Owner Account"
	// The ID of the AWS account that owns the connection
	OwnerAccount string `protobuf:"bytes,19,opt,name=owner_account,json=ownerAccount,proto3" json:"owner_account,omitempty"`
	// Direct Connect Attachment State
	//
	// x-displayName: "Direct Connect  Attachment State"
	// The state of the Attachment.
	DirectConnectAttachmentState string `protobuf:"bytes,20,opt,name=direct_connect_attachment_state,json=directConnectAttachmentState,proto3" json:"direct_connect_attachment_state,omitempty"`
	// Gateway Attachment State Error
	//
	// x-displayName: "Gateway Attachment State Error"
	// The error message if the state of an object failed to advance.
	AttachmentStateChangeError string `protobuf:"bytes,21,opt,name=attachment_state_change_error,json=attachmentStateChangeError,proto3" json:"attachment_state_change_error,omitempty"`
	// AWS Object Link
	//
	// x-displayName: "AWS Object Link"
	// Link to Amazon Web Services (AWS) object
	AwsPath string `protobuf:"bytes,22,opt,name=aws_path,json=awsPath,proto3" json:"aws_path,omitempty"`
}

func (m *VirtualInterfaceStatusType) Reset()      { *m = VirtualInterfaceStatusType{} }
func (*VirtualInterfaceStatusType) ProtoMessage() {}
func (*VirtualInterfaceStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_c87a7a97fd6ae754, []int{5}
}
func (m *VirtualInterfaceStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VirtualInterfaceStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VirtualInterfaceStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualInterfaceStatusType.Merge(m, src)
}
func (m *VirtualInterfaceStatusType) XXX_Size() int {
	return m.Size()
}
func (m *VirtualInterfaceStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualInterfaceStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualInterfaceStatusType proto.InternalMessageInfo

func (m *VirtualInterfaceStatusType) GetAddressFamily() string {
	if m != nil {
		return m.AddressFamily
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetAmazonAddress() string {
	if m != nil {
		return m.AmazonAddress
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetAmazonAsn() uint64 {
	if m != nil {
		return m.AmazonAsn
	}
	return 0
}

func (m *VirtualInterfaceStatusType) GetBgpAsn() uint32 {
	if m != nil {
		return m.BgpAsn
	}
	return 0
}

func (m *VirtualInterfaceStatusType) GetConnectionId() string {
	if m != nil {
		return m.ConnectionId
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetDirectConnectGatewayId() string {
	if m != nil {
		return m.DirectConnectGatewayId
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetDirectConnectGatewayName() string {
	if m != nil {
		return m.DirectConnectGatewayName
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetVirtualInterfaceState() string {
	if m != nil {
		return m.VirtualInterfaceState
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *VirtualInterfaceStatusType) GetVlan() uint32 {
	if m != nil {
		return m.Vlan
	}
	return 0
}

func (m *VirtualInterfaceStatusType) GetVirtualInterfaceId() string {
	if m != nil {
		return m.VirtualInterfaceId
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetVirtualInterfaceName() string {
	if m != nil {
		return m.VirtualInterfaceName
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetVirtualInterfaceType() string {
	if m != nil {
		return m.VirtualInterfaceType
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetBgpPeers() []*BGPPeerType {
	if m != nil {
		return m.BgpPeers
	}
	return nil
}

func (m *VirtualInterfaceStatusType) GetJumboFrameCapable() bool {
	if m != nil {
		return m.JumboFrameCapable
	}
	return false
}

func (m *VirtualInterfaceStatusType) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *VirtualInterfaceStatusType) GetOwnerAccount() string {
	if m != nil {
		return m.OwnerAccount
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetDirectConnectAttachmentState() string {
	if m != nil {
		return m.DirectConnectAttachmentState
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetAttachmentStateChangeError() string {
	if m != nil {
		return m.AttachmentStateChangeError
	}
	return ""
}

func (m *VirtualInterfaceStatusType) GetAwsPath() string {
	if m != nil {
		return m.AwsPath
	}
	return ""
}

// BGP Peer
//
// x-displayName: "BGP Peer"
// The BGP peer object.
type BGPPeerType struct {
	// Address Family
	//
	// x-displayName: "Address Family"
	// The address family setup for the BGP peer.
	AddressFamily string `protobuf:"bytes,1,opt,name=address_family,json=addressFamily,proto3" json:"address_family,omitempty"`
	// Cloud Provider Router Peer IP
	//
	// x-displayName: "Cloud Provider Router Peer IP"
	// The BGP peer IP configured on the cloud provider endpoint
	CloudProviderAddress string `protobuf:"bytes,8,opt,name=cloud_provider_address,json=cloudProviderAddress,proto3" json:"cloud_provider_address,omitempty"`
	// Cloud Provider ASN
	//
	// x-displayName: "Cloud Provider ASN"
	// The autonomous system number (ASN) for the cloud provider side of the connection
	Asn uint32 `protobuf:"varint,3,opt,name=asn,proto3" json:"asn,omitempty"`
	// BGP Peer IP
	//
	// x-displayName: "BGP Peer IP"
	// The ID of the BGP peer
	BgpPeerId string `protobuf:"bytes,4,opt,name=bgp_peer_id,json=bgpPeerId,proto3" json:"bgp_peer_id,omitempty"`
	// BGP Peer State
	//
	// x-displayName: "BGP Peer State"
	// The state of the BGP peer.
	BgpPeerState string `protobuf:"bytes,5,opt,name=bgp_peer_state,json=bgpPeerState,proto3" json:"bgp_peer_state,omitempty"`
	// BGP Peer Status
	//
	// x-displayName: "BGP Peer Status"
	// The status of the BGP peer.
	BgpStatus string `protobuf:"bytes,6,opt,name=bgp_status,json=bgpStatus,proto3" json:"bgp_status,omitempty"`
	// Customer Peer IP
	//
	// x-displayName: "Customer Peer IP"
	// The BGP peer IP configured on the Customer endpoint
	CustomerAddress string `protobuf:"bytes,7,opt,name=customer_address,json=customerAddress,proto3" json:"customer_address,omitempty"`
}

func (m *BGPPeerType) Reset()      { *m = BGPPeerType{} }
func (*BGPPeerType) ProtoMessage() {}
func (*BGPPeerType) Descriptor() ([]byte, []int) {
	return fileDescriptor_c87a7a97fd6ae754, []int{6}
}
func (m *BGPPeerType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BGPPeerType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BGPPeerType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BGPPeerType.Merge(m, src)
}
func (m *BGPPeerType) XXX_Size() int {
	return m.Size()
}
func (m *BGPPeerType) XXX_DiscardUnknown() {
	xxx_messageInfo_BGPPeerType.DiscardUnknown(m)
}

var xxx_messageInfo_BGPPeerType proto.InternalMessageInfo

func (m *BGPPeerType) GetAddressFamily() string {
	if m != nil {
		return m.AddressFamily
	}
	return ""
}

func (m *BGPPeerType) GetCloudProviderAddress() string {
	if m != nil {
		return m.CloudProviderAddress
	}
	return ""
}

func (m *BGPPeerType) GetAsn() uint32 {
	if m != nil {
		return m.Asn
	}
	return 0
}

func (m *BGPPeerType) GetBgpPeerId() string {
	if m != nil {
		return m.BgpPeerId
	}
	return ""
}

func (m *BGPPeerType) GetBgpPeerState() string {
	if m != nil {
		return m.BgpPeerState
	}
	return ""
}

func (m *BGPPeerType) GetBgpStatus() string {
	if m != nil {
		return m.BgpStatus
	}
	return ""
}

func (m *BGPPeerType) GetCustomerAddress() string {
	if m != nil {
		return m.CustomerAddress
	}
	return ""
}

// Direct Connect Gateway Status
//
// x-displayName: "Direct Connect Gateway Status"
// Status reported by Amazon Web Services (AWS) Direct Connect Gateway Status and associations related to this Cloud Link
type DirectConnectGatewayStatusType struct {
	// Amazon Web Services (AWS) ASN
	//
	// x-displayName: "Amazon Web Services (AWS) ASN"
	// The autonomous system number (ASN) for the Amazon side of the connection
	AmazonAsn uint64 `protobuf:"varint,1,opt,name=amazon_asn,json=amazonAsn,proto3" json:"amazon_asn,omitempty"`
	// Gateway Id
	//
	// x-displayName: "Gateway Id"
	// The ID of the direct connect gateway
	DirectConnectGatewayId string `protobuf:"bytes,2,opt,name=direct_connect_gateway_id,json=directConnectGatewayId,proto3" json:"direct_connect_gateway_id,omitempty"`
	// Gateway Name
	//
	// x-displayName: "Gateway Name"
	// The Name of the direct connect gateway
	DirectConnectGatewayName string `protobuf:"bytes,3,opt,name=direct_connect_gateway_name,json=directConnectGatewayName,proto3" json:"direct_connect_gateway_name,omitempty"`
	// Direct Connect Gateway State
	//
	// x-displayName: "Direct Connect Gateway State"
	// The state of the Direct Connect gateway
	DirectConnectGatewayState string `protobuf:"bytes,4,opt,name=direct_connect_gateway_state,json=directConnectGatewayState,proto3" json:"direct_connect_gateway_state,omitempty"`
	// Direct Connect Gateway Error
	//
	// x-displayName: "Direct Connect Gateway Error"
	// The error message if the state of an object failed to advance
	StateChangeError string `protobuf:"bytes,6,opt,name=state_change_error,json=stateChangeError,proto3" json:"state_change_error,omitempty"`
	// Owner Account
	//
	// x-displayName: "Owner Account"
	// The ID of the AWS account that owns the connection
	OwnerAccount string `protobuf:"bytes,7,opt,name=owner_account,json=ownerAccount,proto3" json:"owner_account,omitempty"`
	// AWS Object Link
	//
	// x-displayName: "AWS Object Link"
	// Link to Amazon Web Services (AWS) object
	AwsPath string `protobuf:"bytes,8,opt,name=aws_path,json=awsPath,proto3" json:"aws_path,omitempty"`
}

func (m *DirectConnectGatewayStatusType) Reset()      { *m = DirectConnectGatewayStatusType{} }
func (*DirectConnectGatewayStatusType) ProtoMessage() {}
func (*DirectConnectGatewayStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_c87a7a97fd6ae754, []int{7}
}
func (m *DirectConnectGatewayStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DirectConnectGatewayStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DirectConnectGatewayStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirectConnectGatewayStatusType.Merge(m, src)
}
func (m *DirectConnectGatewayStatusType) XXX_Size() int {
	return m.Size()
}
func (m *DirectConnectGatewayStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_DirectConnectGatewayStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_DirectConnectGatewayStatusType proto.InternalMessageInfo

func (m *DirectConnectGatewayStatusType) GetAmazonAsn() uint64 {
	if m != nil {
		return m.AmazonAsn
	}
	return 0
}

func (m *DirectConnectGatewayStatusType) GetDirectConnectGatewayId() string {
	if m != nil {
		return m.DirectConnectGatewayId
	}
	return ""
}

func (m *DirectConnectGatewayStatusType) GetDirectConnectGatewayName() string {
	if m != nil {
		return m.DirectConnectGatewayName
	}
	return ""
}

func (m *DirectConnectGatewayStatusType) GetDirectConnectGatewayState() string {
	if m != nil {
		return m.DirectConnectGatewayState
	}
	return ""
}

func (m *DirectConnectGatewayStatusType) GetStateChangeError() string {
	if m != nil {
		return m.StateChangeError
	}
	return ""
}

func (m *DirectConnectGatewayStatusType) GetOwnerAccount() string {
	if m != nil {
		return m.OwnerAccount
	}
	return ""
}

func (m *DirectConnectGatewayStatusType) GetAwsPath() string {
	if m != nil {
		return m.AwsPath
	}
	return ""
}

// Azure Cloud Link Status
//
// x-displayName: "Azure Cloud Link Status"
// Status reported by associated Azure cloud components
type AzureStatusType struct {
}

func (m *AzureStatusType) Reset()      { *m = AzureStatusType{} }
func (*AzureStatusType) ProtoMessage() {}
func (*AzureStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_c87a7a97fd6ae754, []int{8}
}
func (m *AzureStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureStatusType.Merge(m, src)
}
func (m *AzureStatusType) XXX_Size() int {
	return m.Size()
}
func (m *AzureStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureStatusType proto.InternalMessageInfo

// CloudLink GCP Cloud Interconnect Connection Status
//
// x-displayName: "CloudLink GCP Cloud Interconnect Connection Status"
// Status reported by Google Cloud Platform (GCP) Cloud Interconnect attachment related to this Cloud Link
type GCPCloudInterconnectAttachmentStatusType struct {
	// GCP Cloud Interconnect Attachment Name
	//
	// x-displayName: "GCP Cloud Interconnect Attachment Name"
	// The name of the GCP Cloud Interconnect Attachment
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Admin Enabled
	//
	// x-displayName: "Admin Enabled"
	// Whether the GCP Cloud Interconnect attachment is administratively enabled
	AdminEnabled bool `protobuf:"varint,2,opt,name=admin_enabled,json=adminEnabled,proto3" json:"admin_enabled,omitempty"`
	// Operational Status
	//
	// x-displayName: "Operational Status"
	// Provisioning status of this GCP Cloud Interconnect attachment
	OperationalStatus string `protobuf:"bytes,3,opt,name=operational_status,json=operationalStatus,proto3" json:"operational_status,omitempty"`
	// Type
	//
	// x-displayName: "Type"
	// x-required
	// Type of GCP Cloud Interconnect attachment
	Type string `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
	// Router
	//
	// x-displayName: "Cloud Router"
	// Name of the GCP Cloud Router to which this GCP Cloud Interconnect is connected
	Router string `protobuf:"bytes,5,opt,name=router,proto3" json:"router,omitempty"`
	// GCP Cloud Interconnect
	//
	// x-displayName: "GCP Cloud Interconnect"
	// Name of the underlying GCP Cloud Interconnect that this attachment is attached to
	Interconnect string `protobuf:"bytes,6,opt,name=interconnect,proto3" json:"interconnect,omitempty"`
	// Bandwidth
	//
	// x-displayName: "Bandwidth"
	// Provisioned bandwidth capacity for this GCP Cloud Interconnect attachment
	Bandwidth string `protobuf:"bytes,7,opt,name=bandwidth,proto3" json:"bandwidth,omitempty"`
	// Encryption
	//
	// x-displayName: "Encryption"
	// Encryption type for this GCP Cloud Interconnect attachment
	Encryption string `protobuf:"bytes,8,opt,name=encryption,proto3" json:"encryption,omitempty"`
	// Virtual Local Area Network (VLAN)
	//
	// x-displayName: "Virtual Local Area Network (VLAN)"
	// Virtual Local Area Network number for the GCP Cloud Interconnect attachment.
	// This tag is required for any traffic traversing the GCP Cloud Router via this connection.
	Vlan uint32 `protobuf:"varint,9,opt,name=vlan,proto3" json:"vlan,omitempty"`
	// Maximum Transmission Unit (MTU)
	//
	// x-displayName: "Maximum Transmission Unit (MTU)"
	// Maximum Transmission Unit (MTU) for the GCP Cloud Interconnect attachment.
	Mtu uint32 `protobuf:"varint,10,opt,name=mtu,proto3" json:"mtu,omitempty"`
	// Stack Type
	//
	// x-displayName: "Stack Type"
	// TCP/IP Stack Type of the GCP Cloud Interconnect attachment.  Defaults to IPV4_ONLY.
	StackType string `protobuf:"bytes,11,opt,name=stack_type,json=stackType,proto3" json:"stack_type,omitempty"`
	// Cloud Router IP Address
	//
	// x-displayName: "Cloud Router IP Address"
	// IP address of this interconnect attachment on the GCP Cloud Router
	CloudRouterIp string `protobuf:"bytes,12,opt,name=cloud_router_ip,json=cloudRouterIp,proto3" json:"cloud_router_ip,omitempty"`
	// Customer Router IP Address
	//
	// x-displayName: "Customer Router IP Address"
	// IP address of this interconnect attachment on the customer side
	CustomerRouterIp string `protobuf:"bytes,13,opt,name=customer_router_ip,json=customerRouterIp,proto3" json:"customer_router_ip,omitempty"`
	// Availability Domain
	//
	// x-displayName: "Availability Domain"
	// Desired availability domain this attachment. Defaults to AVAILABILITY_DOMAIN_ANY.
	AvailabilityDomain string `protobuf:"bytes,14,opt,name=availability_domain,json=availabilityDomain,proto3" json:"availability_domain,omitempty"`
	// Partner Metadata
	//
	// x-displayName: "Partner Metadata"
	// Partner information for this GCP Cloud Interconnect attachment
	PartnerMetadata *GCPPartnerMetadata `protobuf:"bytes,15,opt,name=partner_metadata,json=partnerMetadata,proto3" json:"partner_metadata,omitempty"`
	// Partner ASN
	//
	// x-displayName: "Partner ASN"
	// Partner Autonomous System Number (ASN) for this GCP Cloud Interconnect attachment
	PartnerAsn uint32 `protobuf:"varint,16,opt,name=partner_asn,json=partnerAsn,proto3" json:"partner_asn,omitempty"`
	// GCP Cloud Interconnect Attachment State
	//
	// x-displayName: "GCP Cloud Interconnect Attachment State"
	// The state of the GCP Cloud Interconnect Attachment.
	AttachmentState string `protobuf:"bytes,17,opt,name=attachment_state,json=attachmentState,proto3" json:"attachment_state,omitempty"`
	// Dataplane Version
	//
	// x-displayName: "GCP Cloud Interconnect Dataplane Version"
	// The dataplane version of the GCP Cloud Interconnect Attachment.
	DataplaneVersion int32 `protobuf:"varint,18,opt,name=dataplane_version,json=dataplaneVersion,proto3" json:"dataplane_version,omitempty"`
	// BGP Peers
	//
	// x-displayName: "BGP Peers"
	// BGP peer status for this GCP Cloud Interconnect.
	BgpPeers []*BGPPeerType `protobuf:"bytes,19,rep,name=bgp_peers,json=bgpPeers,proto3" json:"bgp_peers,omitempty"`
	// Labels
	//
	// x-displayName: "Labels"
	// x-example: "dev: staging"
	// Labels are user-defined keys and values associated with this GCP Cloud Interconnect attachment
	Labels map[string]string `protobuf:"bytes,20,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// GCP Object Link
	//
	// x-displayName: "GCP Cloud Router Link"
	// Link to this interconnect's Cloud Router object in Google Cloud Platform
	GcpPath string `protobuf:"bytes,21,opt,name=gcp_path,json=gcpPath,proto3" json:"gcp_path,omitempty"`
	// Cloud Router VPC Network
	//
	// x-displayName: "Cloud Router VPC Network"
	// VPC Network of this interconnect's Cloud Router
	VpcNetwork string `protobuf:"bytes,22,opt,name=vpc_network,json=vpcNetwork,proto3" json:"vpc_network,omitempty"`
	// Cloud Router Region
	//
	// x-displayName: "Cloud Router Region"
	// Region of this interconnect's Cloud Router
	Region string `protobuf:"bytes,23,opt,name=region,proto3" json:"region,omitempty"`
	// Cloud Router Project ID
	//
	// x-displayName: "Cloud Router Project ID"
	// GCP Project ID of this interconnect's Cloud Router
	Project string `protobuf:"bytes,24,opt,name=project,proto3" json:"project,omitempty"`
}

func (m *GCPCloudInterconnectAttachmentStatusType) Reset() {
	*m = GCPCloudInterconnectAttachmentStatusType{}
}
func (*GCPCloudInterconnectAttachmentStatusType) ProtoMessage() {}
func (*GCPCloudInterconnectAttachmentStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_c87a7a97fd6ae754, []int{9}
}
func (m *GCPCloudInterconnectAttachmentStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPCloudInterconnectAttachmentStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPCloudInterconnectAttachmentStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPCloudInterconnectAttachmentStatusType.Merge(m, src)
}
func (m *GCPCloudInterconnectAttachmentStatusType) XXX_Size() int {
	return m.Size()
}
func (m *GCPCloudInterconnectAttachmentStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPCloudInterconnectAttachmentStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_GCPCloudInterconnectAttachmentStatusType proto.InternalMessageInfo

func (m *GCPCloudInterconnectAttachmentStatusType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GCPCloudInterconnectAttachmentStatusType) GetAdminEnabled() bool {
	if m != nil {
		return m.AdminEnabled
	}
	return false
}

func (m *GCPCloudInterconnectAttachmentStatusType) GetOperationalStatus() string {
	if m != nil {
		return m.OperationalStatus
	}
	return ""
}

func (m *GCPCloudInterconnectAttachmentStatusType) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *GCPCloudInterconnectAttachmentStatusType) GetRouter() string {
	if m != nil {
		return m.Router
	}
	return ""
}

func (m *GCPCloudInterconnectAttachmentStatusType) GetInterconnect() string {
	if m != nil {
		return m.Interconnect
	}
	return ""
}

func (m *GCPCloudInterconnectAttachmentStatusType) GetBandwidth() string {
	if m != nil {
		return m.Bandwidth
	}
	return ""
}

func (m *GCPCloudInterconnectAttachmentStatusType) GetEncryption() string {
	if m != nil {
		return m.Encryption
	}
	return ""
}

func (m *GCPCloudInterconnectAttachmentStatusType) GetVlan() uint32 {
	if m != nil {
		return m.Vlan
	}
	return 0
}

func (m *GCPCloudInterconnectAttachmentStatusType) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *GCPCloudInterconnectAttachmentStatusType) GetStackType() string {
	if m != nil {
		return m.StackType
	}
	return ""
}

func (m *GCPCloudInterconnectAttachmentStatusType) GetCloudRouterIp() string {
	if m != nil {
		return m.CloudRouterIp
	}
	return ""
}

func (m *GCPCloudInterconnectAttachmentStatusType) GetCustomerRouterIp() string {
	if m != nil {
		return m.CustomerRouterIp
	}
	return ""
}

func (m *GCPCloudInterconnectAttachmentStatusType) GetAvailabilityDomain() string {
	if m != nil {
		return m.AvailabilityDomain
	}
	return ""
}

func (m *GCPCloudInterconnectAttachmentStatusType) GetPartnerMetadata() *GCPPartnerMetadata {
	if m != nil {
		return m.PartnerMetadata
	}
	return nil
}

func (m *GCPCloudInterconnectAttachmentStatusType) GetPartnerAsn() uint32 {
	if m != nil {
		return m.PartnerAsn
	}
	return 0
}

func (m *GCPCloudInterconnectAttachmentStatusType) GetAttachmentState() string {
	if m != nil {
		return m.AttachmentState
	}
	return ""
}

func (m *GCPCloudInterconnectAttachmentStatusType) GetDataplaneVersion() int32 {
	if m != nil {
		return m.DataplaneVersion
	}
	return 0
}

func (m *GCPCloudInterconnectAttachmentStatusType) GetBgpPeers() []*BGPPeerType {
	if m != nil {
		return m.BgpPeers
	}
	return nil
}

func (m *GCPCloudInterconnectAttachmentStatusType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *GCPCloudInterconnectAttachmentStatusType) GetGcpPath() string {
	if m != nil {
		return m.GcpPath
	}
	return ""
}

func (m *GCPCloudInterconnectAttachmentStatusType) GetVpcNetwork() string {
	if m != nil {
		return m.VpcNetwork
	}
	return ""
}

func (m *GCPCloudInterconnectAttachmentStatusType) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *GCPCloudInterconnectAttachmentStatusType) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

// GCP Cloud Link Status
//
// x-displayName: "GCP Cloud Link Status"
// Status reported by associated GCP cloud components
type GCPStatusType struct {
	// CloudLink GCP Cloud Interconnect Status
	//
	// x-displayName: "CloudLink GCP Cloud Interconnect Connection Status"
	// Status reported by Google Cloud Platform (GCP) CloudLink Connection
	ConnectionStatus []*GCPCloudInterconnectAttachmentStatusType `protobuf:"bytes,2,rep,name=connection_status,json=connectionStatus,proto3" json:"connection_status,omitempty"`
	// CloudLink State
	//
	// x-displayName: "CloudLink State"
	// State of the connections with the CloudLink deployment
	CloudLinkState schema.CloudLinkState `protobuf:"varint,3,opt,name=cloud_link_state,json=cloudLinkState,proto3,enum=ves.io.schema.CloudLinkState" json:"cloud_link_state,omitempty"`
}

func (m *GCPStatusType) Reset()      { *m = GCPStatusType{} }
func (*GCPStatusType) ProtoMessage() {}
func (*GCPStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_c87a7a97fd6ae754, []int{10}
}
func (m *GCPStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPStatusType.Merge(m, src)
}
func (m *GCPStatusType) XXX_Size() int {
	return m.Size()
}
func (m *GCPStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_GCPStatusType proto.InternalMessageInfo

func (m *GCPStatusType) GetConnectionStatus() []*GCPCloudInterconnectAttachmentStatusType {
	if m != nil {
		return m.ConnectionStatus
	}
	return nil
}

func (m *GCPStatusType) GetCloudLinkState() schema.CloudLinkState {
	if m != nil {
		return m.CloudLinkState
	}
	return schema.UP
}

func init() {
	proto.RegisterType((*Object)(nil), "ves.io.schema.cloud_link.Object")
	golang_proto.RegisterType((*Object)(nil), "ves.io.schema.cloud_link.Object")
	proto.RegisterType((*SpecType)(nil), "ves.io.schema.cloud_link.SpecType")
	golang_proto.RegisterType((*SpecType)(nil), "ves.io.schema.cloud_link.SpecType")
	proto.RegisterType((*StatusObject)(nil), "ves.io.schema.cloud_link.StatusObject")
	golang_proto.RegisterType((*StatusObject)(nil), "ves.io.schema.cloud_link.StatusObject")
	proto.RegisterType((*AWSStatusType)(nil), "ves.io.schema.cloud_link.AWSStatusType")
	golang_proto.RegisterType((*AWSStatusType)(nil), "ves.io.schema.cloud_link.AWSStatusType")
	proto.RegisterType((*DirectConnectConnectionStatusType)(nil), "ves.io.schema.cloud_link.DirectConnectConnectionStatusType")
	golang_proto.RegisterType((*DirectConnectConnectionStatusType)(nil), "ves.io.schema.cloud_link.DirectConnectConnectionStatusType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cloud_link.DirectConnectConnectionStatusType.TagsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cloud_link.DirectConnectConnectionStatusType.TagsEntry")
	proto.RegisterType((*VirtualInterfaceStatusType)(nil), "ves.io.schema.cloud_link.VirtualInterfaceStatusType")
	golang_proto.RegisterType((*VirtualInterfaceStatusType)(nil), "ves.io.schema.cloud_link.VirtualInterfaceStatusType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cloud_link.VirtualInterfaceStatusType.TagsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cloud_link.VirtualInterfaceStatusType.TagsEntry")
	proto.RegisterType((*BGPPeerType)(nil), "ves.io.schema.cloud_link.BGPPeerType")
	golang_proto.RegisterType((*BGPPeerType)(nil), "ves.io.schema.cloud_link.BGPPeerType")
	proto.RegisterType((*DirectConnectGatewayStatusType)(nil), "ves.io.schema.cloud_link.DirectConnectGatewayStatusType")
	golang_proto.RegisterType((*DirectConnectGatewayStatusType)(nil), "ves.io.schema.cloud_link.DirectConnectGatewayStatusType")
	proto.RegisterType((*AzureStatusType)(nil), "ves.io.schema.cloud_link.AzureStatusType")
	golang_proto.RegisterType((*AzureStatusType)(nil), "ves.io.schema.cloud_link.AzureStatusType")
	proto.RegisterType((*GCPCloudInterconnectAttachmentStatusType)(nil), "ves.io.schema.cloud_link.GCPCloudInterconnectAttachmentStatusType")
	golang_proto.RegisterType((*GCPCloudInterconnectAttachmentStatusType)(nil), "ves.io.schema.cloud_link.GCPCloudInterconnectAttachmentStatusType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cloud_link.GCPCloudInterconnectAttachmentStatusType.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cloud_link.GCPCloudInterconnectAttachmentStatusType.LabelsEntry")
	proto.RegisterType((*GCPStatusType)(nil), "ves.io.schema.cloud_link.GCPStatusType")
	golang_proto.RegisterType((*GCPStatusType)(nil), "ves.io.schema.cloud_link.GCPStatusType")
}

func init() {
	proto.RegisterFile("ves.io/schema/cloud_link/object.proto", fileDescriptor_c87a7a97fd6ae754)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/cloud_link/object.proto", fileDescriptor_c87a7a97fd6ae754)
}

var fileDescriptor_c87a7a97fd6ae754 = []byte{
	// 2748 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x59, 0xcb, 0x6f, 0x1b, 0xc7,
	0x19, 0xf7, 0x8a, 0x94, 0x48, 0x7e, 0x12, 0x45, 0x72, 0x2c, 0x2b, 0x6b, 0xc6, 0xa6, 0x15, 0x26,
	0x71, 0x94, 0x44, 0xa4, 0x6c, 0x47, 0x49, 0x63, 0xa5, 0x4d, 0x21, 0x3e, 0xa2, 0xd0, 0xb0, 0x65,
	0x75, 0x24, 0xdb, 0x48, 0xd1, 0x76, 0x3b, 0xdc, 0x1d, 0xad, 0x36, 0x22, 0x77, 0xb7, 0xb3, 0x4b,
	0x2a, 0x0c, 0x50, 0xa0, 0x40, 0x81, 0x36, 0x05, 0x8a, 0x3e, 0x2e, 0x45, 0x0f, 0x05, 0x8a, 0xe6,
	0xd2, 0xa2, 0xe8, 0x5f, 0xd0, 0x5c, 0x92, 0x00, 0x05, 0x8a, 0x9e, 0x8c, 0x9c, 0x82, 0x9e, 0x12,
	0xb9, 0x87, 0xf6, 0x16, 0xe4, 0xd2, 0x5b, 0x51, 0xcc, 0xcc, 0x2e, 0xb9, 0x7c, 0xd9, 0xae, 0xdd,
	0x8b, 0xb4, 0xfb, 0xbd, 0x76, 0xe6, 0x7b, 0xfc, 0xbe, 0x6f, 0x86, 0xf0, 0x6c, 0x97, 0x7a, 0x65,
	0xcb, 0x59, 0xf7, 0xf4, 0x43, 0xda, 0x26, 0xeb, 0x7a, 0xcb, 0xe9, 0x18, 0x5a, 0xcb, 0xb2, 0x8f,
	0xd6, 0x9d, 0xe6, 0xdb, 0x54, 0xf7, 0xcb, 0x2e, 0x73, 0x7c, 0x07, 0xa9, 0x52, 0xac, 0x2c, 0xc5,
	0xca, 0x03, 0xb1, 0x7c, 0xc9, 0xb4, 0xfc, 0xc3, 0x4e, 0xb3, 0xac, 0x3b, 0xed, 0x75, 0xd3, 0x31,
	0x9d, 0x75, 0xa1, 0xd0, 0xec, 0x1c, 0x88, 0x37, 0xf1, 0x22, 0x9e, 0xa4, 0xa1, 0xfc, 0x33, 0x53,
	0xbf, 0xe7, 0xf7, 0x5c, 0xea, 0x05, 0x52, 0x4f, 0x0e, 0x4b, 0x39, 0xae, 0x6f, 0x39, 0x76, 0xc8,
	0x3c, 0x3b, 0xcc, 0x8c, 0xea, 0x9d, 0x1b, 0x66, 0x75, 0x49, 0xcb, 0x32, 0x88, 0x4f, 0x03, 0x6e,
	0x71, 0x84, 0x4b, 0x3d, 0x6a, 0x77, 0x47, 0x8c, 0xaf, 0x8c, 0xc8, 0x58, 0xf4, 0x58, 0x1b, 0x96,
	0xb8, 0x30, 0x2e, 0xe1, 0x45, 0x17, 0x51, 0xfc, 0xe5, 0x2c, 0xcc, 0xdd, 0x14, 0xce, 0x43, 0x57,
	0x21, 0xd9, 0xa6, 0x3e, 0x31, 0x88, 0x4f, 0x54, 0x65, 0x45, 0x59, 0x9d, 0xbf, 0x72, 0xbe, 0x3c,
	0xec, 0x49, 0x29, 0x78, 0x83, 0xfa, 0x64, 0xbf, 0xe7, 0x52, 0xdc, 0x17, 0x47, 0xd7, 0x21, 0xe3,
	0xf5, 0x3c, 0x9f, 0xb6, 0xb5, 0xbe, 0x85, 0x19, 0x61, 0xe1, 0xe9, 0x11, 0x0b, 0x7b, 0x42, 0x6a,
	0xc4, 0xce, 0xa2, 0xd4, 0xbd, 0x11, 0x5a, 0x7b, 0x05, 0xe2, 0x9e, 0x4b, 0x75, 0x35, 0x26, 0x4c,
	0x14, 0xcb, 0xd3, 0xc2, 0x59, 0xde, 0x73, 0xa9, 0x2e, 0x2c, 0x08, 0xf9, 0xcd, 0xbf, 0xc4, 0xde,
	0xfb, 0xba, 0xf2, 0xf1, 0x47, 0xea, 0x4c, 0x56, 0xf9, 0xe4, 0x23, 0xf5, 0x4f, 0x33, 0x70, 0x15,
	0x62, 0xdb, 0xd4, 0x47, 0x57, 0x0e, 0x5e, 0x7e, 0x47, 0x2f, 0x79, 0x54, 0xef, 0x30, 0xda, 0xa6,
	0xde, 0x61, 0xa9, 0x49, 0x3c, 0x4b, 0x2f, 0xb5, 0x1d, 0xdb, 0xf2, 0x1d, 0xb6, 0xc6, 0xbd, 0x58,
	0xb2, 0x9c, 0x92, 0x4d, 0xfd, 0x63, 0x87, 0x1d, 0x95, 0x18, 0x25, 0x06, 0xbc, 0x06, 0x09, 0x4c,
	0xdd, 0x16, 0xd1, 0x29, 0xba, 0x34, 0x59, 0xbd, 0xe3, 0xd1, 0x71, 0xdd, 0x63, 0x66, 0xf9, 0x14,
	0x36, 0x61, 0xae, 0xca, 0x28, 0xf1, 0x1f, 0x51, 0xb7, 0x46, 0x5b, 0xf4, 0x11, 0x75, 0xe3, 0xd7,
	0x2d, 0xef, 0x91, 0x36, 0xfc, 0xf7, 0x8f, 0xd4, 0x1f, 0x29, 0xf0, 0x43, 0x05, 0x1a, 0xdc, 0x95,
	0x65, 0x53, 0xd7, 0xc4, 0x7f, 0xe9, 0x6c, 0x97, 0x39, 0x5d, 0xcb, 0xa0, 0xac, 0x4c, 0x8e, 0xbd,
	0x88, 0xff, 0x35, 0x9e, 0x48, 0xe5, 0x66, 0xcf, 0xd1, 0xcb, 0xba, 0x63, 0xdb, 0x54, 0x97, 0x99,
	0x47, 0x3a, 0xfe, 0xa1, 0x76, 0x44, 0x7b, 0xe8, 0x95, 0xe0, 0x3b, 0x42, 0xa3, 0xc4, 0x35, 0x4a,
	0xdc, 0x68, 0xc9, 0xd4, 0xe5, 0x7f, 0x72, 0xec, 0x95, 0xb8, 0x76, 0xa9, 0x69, 0xba, 0x25, 0xae,
	0x55, 0xf2, 0x9d, 0x23, 0x6a, 0x17, 0x6f, 0x40, 0x32, 0x8c, 0x2c, 0xda, 0x82, 0x44, 0xb0, 0x96,
	0x20, 0xa3, 0x56, 0xa7, 0xa7, 0xc3, 0x76, 0xcb, 0x69, 0x92, 0x56, 0x3f, 0x29, 0xe6, 0x4c, 0x9d,
	0x3f, 0x17, 0xff, 0x1d, 0x83, 0x85, 0x3d, 0x9f, 0xf8, 0x1d, 0xef, 0xa1, 0x13, 0x5d, 0x8a, 0x4f,
	0x4c, 0xf4, 0x79, 0x09, 0x35, 0x1a, 0xa3, 0x07, 0x9e, 0x3a, 0xb3, 0x12, 0x5b, 0x9d, 0xbf, 0x72,
	0x6e, 0x62, 0x99, 0x60, 0x7a, 0xc0, 0x95, 0x2b, 0xe9, 0x3f, 0x7e, 0x1f, 0x06, 0x8b, 0xc4, 0xe0,
	0x84, 0x5c, 0x0f, 0x7d, 0x15, 0x40, 0x77, 0x6c, 0xc3, 0x12, 0x7e, 0x53, 0x63, 0x13, 0x8d, 0x55,
	0x43, 0x01, 0xb1, 0x92, 0x88, 0x3c, 0x7a, 0x13, 0x80, 0x1c, 0x7b, 0x9a, 0x27, 0xd6, 0xaa, 0xce,
	0x8a, 0x8d, 0x3c, 0x37, 0xdd, 0x3b, 0x5b, 0x77, 0xf6, 0xe4, 0xb6, 0xb8, 0xa1, 0x37, 0x4f, 0xe1,
	0x14, 0x39, 0xf6, 0x24, 0x01, 0xed, 0xc0, 0x02, 0x79, 0xb7, 0xc3, 0x68, 0x68, 0x6b, 0x4e, 0xd8,
	0x7a, 0xfe, 0x3e, 0xb6, 0xb8, 0xf4, 0x90, 0xb5, 0x79, 0x32, 0x20, 0xf1, 0x95, 0x99, 0xba, 0x1b,
	0x5a, 0x4b, 0x3c, 0x68, 0x65, 0xdb, 0xd5, 0xdd, 0xe1, 0x95, 0x99, 0xba, 0x2b, 0x09, 0x9b, 0x4f,
	0x7e, 0xf2, 0x7a, 0x16, 0x16, 0x61, 0x21, 0x0c, 0x40, 0xb9, 0x63, 0x19, 0x5f, 0xbe, 0x3e, 0x7b,
	0x79, 0xed, 0xa5, 0xb5, 0x8d, 0xca, 0x59, 0xc8, 0x45, 0x92, 0x51, 0x7e, 0x0d, 0xc5, 0xef, 0x7e,
	0xa0, 0xc4, 0xaf, 0xc5, 0x93, 0xf1, 0xec, 0x6c, 0xf1, 0xb7, 0x31, 0x48, 0x0f, 0x6d, 0x1b, 0x1d,
	0x42, 0x6e, 0x90, 0xaa, 0xe1, 0x02, 0x65, 0x14, 0x5f, 0x9b, 0xbe, 0xc0, 0x9a, 0xc5, 0xa8, 0xee,
	0x57, 0xa5, 0x62, 0xb5, 0xaf, 0x3f, 0xb0, 0x8b, 0xb3, 0xfa, 0x08, 0x15, 0x3d, 0x0f, 0x59, 0xaf,
	0x63, 0x9a, 0xd4, 0xf3, 0xa9, 0xa1, 0x11, 0xc1, 0x11, 0x31, 0x4a, 0xe1, 0x4c, 0x9f, 0xbe, 0x25,
	0xc8, 0xe8, 0x45, 0xc8, 0x51, 0xc6, 0x1c, 0xa6, 0x19, 0xd4, 0xd3, 0x99, 0x25, 0x00, 0x5c, 0xc4,
	0x20, 0x85, 0xb3, 0x82, 0x51, 0x1b, 0xd0, 0xd1, 0x36, 0x64, 0x47, 0x36, 0x4d, 0x85, 0x87, 0x17,
	0xc7, 0x92, 0xb8, 0xca, 0xc5, 0xae, 0x5b, 0xf6, 0x11, 0x5f, 0x11, 0xc5, 0x8b, 0xfa, 0xd0, 0x3b,
	0xfa, 0x2e, 0xe4, 0x0c, 0xea, 0xb6, 0x9c, 0x5e, 0x9b, 0xda, 0x7e, 0xe8, 0x8a, 0xa4, 0xb0, 0xf4,
	0xd2, 0x74, 0x57, 0xf4, 0x8d, 0xd6, 0xfa, 0xba, 0x72, 0xc3, 0x38, 0x6b, 0x8c, 0x50, 0x36, 0xcf,
	0x7c, 0xfc, 0x81, 0x92, 0x83, 0x0c, 0xc0, 0xd6, 0x9d, 0xbd, 0x95, 0xc0, 0x2d, 0xca, 0x95, 0x6b,
	0xf1, 0x64, 0x2c, 0x1b, 0x46, 0xe8, 0x1f, 0x49, 0x78, 0xea, 0x81, 0xde, 0x45, 0xe7, 0x20, 0xd5,
	0x24, 0xb6, 0x71, 0x6c, 0x19, 0xfe, 0xa1, 0xa8, 0xd8, 0x14, 0x1e, 0x10, 0xd0, 0xd3, 0x90, 0x8e,
	0xc4, 0xd4, 0x32, 0x04, 0x50, 0xa4, 0xf0, 0xc2, 0x80, 0xd8, 0x30, 0xd0, 0x73, 0x90, 0x89, 0x08,
	0xd9, 0xa4, 0x4d, 0x45, 0x7b, 0x49, 0xe1, 0xc5, 0x01, 0x79, 0x87, 0xb4, 0x29, 0xfa, 0xb1, 0x02,
	0xd9, 0x91, 0x14, 0xa1, 0x6a, 0x9c, 0x8b, 0x56, 0xbe, 0xf5, 0xe7, 0x7f, 0x7d, 0x18, 0xbb, 0xc3,
	0x6e, 0xe1, 0xa4, 0xc3, 0x0c, 0xca, 0x2c, 0xdb, 0xc4, 0x29, 0x46, 0xbf, 0xd7, 0x11, 0xb1, 0xc4,
	0x09, 0x97, 0xda, 0x86, 0xa0, 0x91, 0x2e, 0xb1, 0x5a, 0xa4, 0xd9, 0xa2, 0x38, 0x6e, 0x38, 0xc7,
	0x36, 0x4e, 0x1a, 0x1c, 0xd0, 0x39, 0x2b, 0x21, 0x9e, 0xa8, 0x81, 0x93, 0x8c, 0x72, 0x14, 0xe0,
	0x6a, 0x1d, 0xfb, 0xc8, 0xe6, 0x52, 0x99, 0xe1, 0x14, 0xa2, 0xe8, 0x26, 0x2c, 0x1f, 0x12, 0x4f,
	0x6b, 0x39, 0xa6, 0xa5, 0x93, 0x96, 0xc6, 0xa8, 0xd1, 0xb1, 0x0d, 0x62, 0xeb, 0x3d, 0x99, 0x47,
	0x95, 0xb3, 0x7c, 0x39, 0x4b, 0x0c, 0x0d, 0x4c, 0xc4, 0x7a, 0xd4, 0xc3, 0x33, 0xb6, 0x83, 0x97,
	0x0e, 0x89, 0x77, 0x5d, 0xea, 0xe1, 0xbe, 0x1a, 0xca, 0x43, 0xb2, 0xe5, 0xe8, 0x24, 0x92, 0x5e,
	0xfd, 0x77, 0xf4, 0x14, 0x2c, 0xb8, 0x84, 0xf9, 0x36, 0x65, 0xd2, 0x39, 0x09, 0xc1, 0x9f, 0x0f,
	0x68, 0xc2, 0x33, 0x4f, 0x43, 0x3a, 0x6c, 0x04, 0x52, 0x26, 0x29, 0xfd, 0x1c, 0x12, 0x85, 0xd0,
	0x32, 0xcc, 0x31, 0x6a, 0xf2, 0x2f, 0xa4, 0x04, 0x37, 0x78, 0x43, 0x6f, 0x41, 0xdc, 0x27, 0xa6,
	0xa7, 0x82, 0xa8, 0xb5, 0xfa, 0x63, 0xd4, 0x5a, 0x79, 0x9f, 0x98, 0x5e, 0xdd, 0xf6, 0x59, 0x0f,
	0x0b, 0x93, 0x08, 0x41, 0xbc, 0xdb, 0x22, 0xb6, 0x3a, 0xbf, 0xa2, 0xac, 0xa6, 0xb1, 0x78, 0x46,
	0x65, 0x38, 0xfd, 0x76, 0xa7, 0xdd, 0x74, 0xb4, 0x03, 0x46, 0xda, 0x54, 0xd3, 0x89, 0xcb, 0xe3,
	0xa1, 0x2e, 0xac, 0x28, 0xab, 0x49, 0x9c, 0x13, 0xac, 0x37, 0x38, 0xa7, 0x2a, 0x19, 0x7c, 0x6f,
	0xce, 0x31, 0xdf, 0x3c, 0xd1, 0x75, 0xa7, 0x63, 0xfb, 0x6a, 0x5a, 0xee, 0x4d, 0x10, 0xb7, 0x24,
	0x0d, 0xed, 0x01, 0x74, 0xad, 0x83, 0xb0, 0x54, 0x16, 0x05, 0xac, 0x6d, 0x4c, 0xdf, 0xc9, 0x6d,
	0x8b, 0xf9, 0x1d, 0xd2, 0x6a, 0xd8, 0x3e, 0x65, 0x07, 0x44, 0x8f, 0xe0, 0x25, 0x4e, 0x75, 0xad,
	0x83, 0xa0, 0x20, 0x34, 0x58, 0x34, 0x89, 0x4f, 0x8f, 0x49, 0x2f, 0x34, 0x9c, 0x11, 0x86, 0x5f,
	0x7d, 0x48, 0x17, 0x6d, 0x4b, 0xe5, 0x88, 0xf1, 0xb4, 0x19, 0x25, 0xa1, 0xb3, 0x90, 0xe4, 0x6d,
	0xc2, 0x25, 0xfe, 0xa1, 0x9a, 0x13, 0xbb, 0x4a, 0x90, 0x63, 0x6f, 0x97, 0xf8, 0x87, 0xf9, 0xaf,
	0x40, 0xaa, 0xef, 0x4c, 0x94, 0x85, 0xd8, 0x11, 0xed, 0x05, 0xe5, 0xc5, 0x1f, 0xd1, 0x12, 0xcc,
	0x76, 0x49, 0xab, 0x43, 0x83, 0x82, 0x92, 0x2f, 0x9b, 0x33, 0xaf, 0x2a, 0x9b, 0xbf, 0x57, 0xfe,
	0xf6, 0x81, 0xf2, 0xbe, 0x02, 0x2b, 0x90, 0x1e, 0x84, 0x68, 0xa5, 0x51, 0xcb, 0x67, 0x46, 0x6a,
	0x11, 0x9e, 0x81, 0x4c, 0x44, 0x82, 0xa7, 0x48, 0x3e, 0x37, 0x56, 0x8a, 0x70, 0x11, 0xb2, 0x11,
	0x29, 0x91, 0xfe, 0x79, 0x34, 0x5e, 0x87, 0xa0, 0x42, 0xaa, 0x12, 0xd6, 0x7d, 0x7e, 0x3e, 0x82,
	0x0a, 0xb0, 0x0c, 0xc9, 0xeb, 0x41, 0x2e, 0xe7, 0x61, 0x90, 0xe7, 0xd7, 0xe2, 0xc9, 0x6c, 0x36,
	0x57, 0x7c, 0x0f, 0x20, 0x3f, 0x3d, 0x1c, 0x68, 0x13, 0x16, 0x89, 0x61, 0x30, 0xea, 0x79, 0xda,
	0x01, 0x69, 0x5b, 0xad, 0xc0, 0x0b, 0x95, 0xd3, 0xbc, 0xc2, 0x16, 0xd9, 0x02, 0x8e, 0x5b, 0x6e,
	0x77, 0x43, 0xfc, 0x7d, 0x05, 0xa7, 0x03, 0xd1, 0x37, 0x84, 0x24, 0x7a, 0x16, 0x16, 0x49, 0x9b,
	0xbc, 0xeb, 0xd8, 0x5a, 0x40, 0x0f, 0xbc, 0x95, 0x96, 0xd4, 0x2d, 0x49, 0x44, 0xe7, 0x01, 0x42,
	0x31, 0xcf, 0x16, 0xd0, 0x13, 0xc7, 0xa9, 0x40, 0xc4, 0xb3, 0xd1, 0x13, 0x90, 0x68, 0x9a, 0xae,
	0xe0, 0xc5, 0x45, 0x1a, 0xcf, 0x35, 0x4d, 0x97, 0x33, 0xc6, 0xc0, 0x6d, 0x76, 0x02, 0xb8, 0x5d,
	0x85, 0xb3, 0x86, 0xc8, 0x09, 0x2d, 0x20, 0x6b, 0x61, 0x4a, 0x59, 0x46, 0x50, 0xe9, 0xcb, 0xc6,
	0x84, 0xa4, 0x69, 0x18, 0xe8, 0x6b, 0xf0, 0xe4, 0x14, 0xd5, 0x08, 0x0c, 0xa8, 0x93, 0x94, 0x45,
	0xb9, 0xff, 0x4a, 0x81, 0x27, 0xba, 0xd2, 0xb1, 0x9a, 0x15, 0x7a, 0x36, 0x00, 0x4d, 0x01, 0x0f,
	0x95, 0xef, 0x70, 0x1f, 0xbe, 0xc5, 0xee, 0x88, 0xd1, 0xe5, 0xc0, 0x62, 0x6d, 0x01, 0x91, 0x5d,
	0xca, 0xac, 0x83, 0x9e, 0x80, 0xc4, 0xc7, 0x84, 0xcd, 0x33, 0xdd, 0x09, 0x71, 0xa5, 0x43, 0x58,
	0x97, 0x1a, 0xc1, 0xba, 0x01, 0x46, 0xc1, 0x10, 0x46, 0xe1, 0x00, 0xa3, 0xe6, 0x05, 0x46, 0xbd,
	0xfe, 0x28, 0x95, 0x3d, 0x15, 0x9c, 0x16, 0x22, 0xe0, 0x74, 0x09, 0x96, 0xc6, 0x7d, 0x66, 0x19,
	0x01, 0xe6, 0xa0, 0xd1, 0x0d, 0x35, 0x0c, 0xb4, 0x01, 0xcb, 0xe3, 0x1a, 0x22, 0x40, 0x8b, 0x42,
	0x67, 0x69, 0x54, 0x47, 0x04, 0xe7, 0xce, 0x24, 0x2d, 0x3e, 0xb3, 0x0b, 0x88, 0x49, 0x55, 0x9e,
	0xe2, 0xa1, 0x39, 0xc7, 0xf2, 0x38, 0xe1, 0x32, 0xab, 0xcb, 0x67, 0x84, 0x39, 0xb7, 0xd3, 0x6c,
	0x59, 0x3a, 0x4e, 0xf8, 0x8c, 0xd8, 0x9e, 0xe5, 0x8f, 0x1b, 0x16, 0xf5, 0x52, 0x81, 0x14, 0xcf,
	0x56, 0x97, 0x52, 0xe6, 0xa9, 0x59, 0xe1, 0xad, 0x67, 0xa7, 0x7b, 0xab, 0xb2, 0xbd, 0xbb, 0x4b,
	0x29, 0x93, 0x93, 0x74, 0xd3, 0x74, 0xf9, 0x8b, 0x37, 0x0d, 0xa1, 0x73, 0xd3, 0x10, 0x3a, 0x0b,
	0xb1, 0xb6, 0xdf, 0x51, 0x91, 0xf0, 0x23, 0x7f, 0x1c, 0xc7, 0xec, 0xd3, 0x13, 0x30, 0xfb, 0x1d,
	0xb8, 0x30, 0x92, 0xdf, 0xc4, 0xf7, 0x89, 0x7e, 0xd8, 0x1f, 0x7a, 0xa8, 0xba, 0x24, 0x9c, 0x71,
	0x99, 0x3b, 0x63, 0x8d, 0xbd, 0x80, 0x53, 0x52, 0x80, 0xe7, 0x5d, 0x52, 0x3e, 0x52, 0x03, 0xa7,
	0x0c, 0xda, 0x27, 0xca, 0x47, 0x6a, 0xe0, 0x73, 0x43, 0x65, 0xb1, 0xd5, 0xb7, 0x2b, 0x33, 0x70,
	0x0b, 0xce, 0x8f, 0x7e, 0x4a, 0xd3, 0x0f, 0x89, 0x6d, 0x52, 0x4d, 0x0c, 0x75, 0xea, 0x19, 0xb1,
	0xdc, 0x3c, 0x19, 0xd6, 0xab, 0x0a, 0x91, 0x3a, 0x97, 0x18, 0x82, 0xee, 0xe5, 0xff, 0x0f, 0x74,
	0x17, 0xdf, 0x8f, 0xc3, 0x7c, 0x24, 0x22, 0x8f, 0x85, 0x7d, 0x1b, 0xb0, 0x3c, 0x7c, 0x40, 0xec,
	0x63, 0xa0, 0x1c, 0x0d, 0x96, 0x04, 0x77, 0x37, 0x60, 0x86, 0x50, 0x98, 0x85, 0x58, 0x88, 0x81,
	0x69, 0xcc, 0x1f, 0x51, 0x01, 0xe6, 0xc3, 0x7c, 0xe2, 0x75, 0x10, 0x0f, 0x26, 0x3c, 0x99, 0x2a,
	0x0d, 0x83, 0xf7, 0xc8, 0x3e, 0x5f, 0xc6, 0x4c, 0x4e, 0x40, 0x57, 0xf9, 0x1a, 0x37, 0xd8, 0x95,
	0x07, 0xe1, 0xc9, 0x04, 0x24, 0x59, 0x08, 0xac, 0xcb, 0x58, 0x5d, 0x05, 0xe0, 0x1f, 0x88, 0x1c,
	0x7f, 0x52, 0x95, 0x3c, 0x37, 0x7e, 0x86, 0x9d, 0xc6, 0x33, 0x1d, 0x37, 0x40, 0xa4, 0x3e, 0xe8,
	0xf0, 0xb5, 0x0d, 0xe6, 0x7c, 0xbd, 0xe3, 0xf9, 0x4e, 0x3b, 0xb2, 0x7b, 0x89, 0x9a, 0x99, 0x90,
	0x1e, 0x6c, 0x7c, 0xf3, 0x77, 0xbc, 0x6b, 0xfe, 0x46, 0x81, 0x2b, 0xb0, 0x2c, 0xc6, 0xe8, 0x95,
	0xd0, 0x33, 0x2b, 0x81, 0x44, 0x5e, 0x9d, 0xe6, 0x50, 0xd1, 0x21, 0x03, 0x73, 0x7d, 0x69, 0x34,
	0xfe, 0x69, 0x28, 0xc2, 0x62, 0x65, 0x7b, 0x77, 0x85, 0x6f, 0x2d, 0xe8, 0xa3, 0xd9, 0x51, 0xe7,
	0x41, 0x1e, 0x80, 0xcb, 0xc8, 0x0d, 0xe4, 0x17, 0xa2, 0x7b, 0xbf, 0x16, 0x4f, 0xce, 0x64, 0x63,
	0xc5, 0x5f, 0xc7, 0xa0, 0x70, 0xff, 0x29, 0x63, 0xa4, 0xa1, 0x29, 0xa3, 0x0d, 0xed, 0xbe, 0x2d,
	0x69, 0xe6, 0x71, 0x5a, 0x52, 0xec, 0x01, 0x2d, 0xc9, 0x81, 0x73, 0x53, 0xd4, 0xa3, 0xb3, 0x7c,
	0x99, 0x47, 0xf7, 0x79, 0xf6, 0xdc, 0xc3, 0xe6, 0xcb, 0x59, 0x63, 0x8a, 0x3b, 0x28, 0x5a, 0x03,
	0x34, 0xa1, 0xba, 0x83, 0xf3, 0x9b, 0x37, 0x5a, 0xd3, 0x63, 0xa8, 0x95, 0x98, 0x80, 0x5a, 0xd1,
	0xc2, 0x4f, 0x0e, 0x15, 0x7e, 0x31, 0x07, 0x99, 0x91, 0xd3, 0x77, 0xf1, 0x4b, 0x80, 0xd5, 0xed,
	0xea, 0xae, 0xc8, 0x29, 0x01, 0xd4, 0xfa, 0x24, 0x44, 0x0a, 0xe2, 0x86, 0x20, 0x2e, 0xdc, 0x28,
	0xc1, 0x42, 0x3c, 0xf3, 0x35, 0x11, 0xa3, 0x6d, 0xd9, 0x1a, 0xb5, 0xf9, 0xfe, 0x65, 0x80, 0x92,
	0x78, 0x41, 0x10, 0xeb, 0x92, 0x86, 0x4a, 0x80, 0x1c, 0x97, 0x32, 0xd1, 0x42, 0x49, 0x2b, 0xac,
	0x15, 0x19, 0x8d, 0x5c, 0x84, 0x13, 0xd4, 0xc5, 0x16, 0xc4, 0x45, 0xab, 0x91, 0xee, 0x2e, 0x71,
	0x77, 0xaf, 0xb2, 0x8b, 0x38, 0x55, 0xab, 0xd7, 0x1a, 0xd5, 0xad, 0xfd, 0x7a, 0x0d, 0x27, 0x76,
	0xb7, 0xf0, 0xfe, 0x4e, 0x1d, 0xe3, 0x6c, 0xf0, 0xa0, 0xed, 0xe2, 0x9b, 0xb7, 0x1b, 0xb5, 0x3a,
	0xc6, 0x42, 0x55, 0xf4, 0x69, 0xa7, 0xe3, 0x53, 0x16, 0x0c, 0x3d, 0xc1, 0x1b, 0x2a, 0xc2, 0x82,
	0x15, 0xd9, 0x66, 0xe0, 0xea, 0x21, 0xda, 0xf0, 0x91, 0x31, 0x31, 0x7a, 0x64, 0xdc, 0x00, 0xa0,
	0xb6, 0xce, 0x7a, 0xf2, 0xa8, 0x2d, 0x07, 0x95, 0x25, 0xbe, 0xc4, 0x0c, 0x4b, 0xe3, 0xf8, 0xce,
	0xcd, 0x9d, 0x3a, 0x9e, 0x6d, 0xec, 0xee, 0xd5, 0xab, 0x38, 0x22, 0x87, 0x56, 0x82, 0x5e, 0xce,
	0xe7, 0x89, 0x74, 0x65, 0x81, 0xcb, 0x27, 0x5e, 0x98, 0x55, 0xff, 0x73, 0x61, 0x55, 0x09, 0x3a,
	0xfb, 0x33, 0xb2, 0x49, 0x81, 0x10, 0x40, 0x5c, 0x20, 0xfd, 0xc2, 0x7c, 0x25, 0x75, 0x79, 0x63,
	0xe3, 0xd2, 0xda, 0xe5, 0x97, 0x2f, 0x5d, 0x92, 0x8d, 0xeb, 0x3c, 0x80, 0xe7, 0x13, 0x5d, 0xde,
	0x9f, 0x89, 0x63, 0x4b, 0x0a, 0xa7, 0x04, 0x45, 0x44, 0xe8, 0x22, 0x64, 0x24, 0x08, 0xc8, 0xed,
	0x6a, 0x96, 0x2b, 0xa6, 0x87, 0x14, 0x4e, 0x0b, 0x32, 0x16, 0xd4, 0x86, 0xcb, 0xf3, 0xae, 0x5f,
	0xfe, 0x03, 0x51, 0x39, 0x44, 0xf4, 0x81, 0xa1, 0x2f, 0xbd, 0x0e, 0xa7, 0x83, 0x04, 0xb7, 0x5a,
	0x96, 0xdf, 0xd3, 0x0c, 0xa7, 0x4d, 0x2c, 0x3b, 0x98, 0x1f, 0x50, 0x94, 0x55, 0x13, 0x1c, 0x74,
	0x07, 0xb2, 0xe1, 0x89, 0xb0, 0x7f, 0x5b, 0x26, 0x8f, 0x26, 0x6b, 0xf7, 0xbd, 0xca, 0xd9, 0x95,
	0x4a, 0xe1, 0x6d, 0x2e, 0xce, 0xb8, 0xc3, 0x04, 0x74, 0x01, 0xc2, 0x63, 0xa5, 0x80, 0x8e, 0xac,
	0xe8, 0x03, 0x10, 0x90, 0x38, 0x76, 0xfc, 0x5c, 0x81, 0xec, 0x58, 0x97, 0x16, 0x47, 0x97, 0x8a,
	0xc1, 0x7d, 0xaa, 0xb1, 0x6f, 0xe3, 0xb9, 0xad, 0xea, 0x7e, 0xe3, 0x76, 0x1d, 0xa7, 0x6f, 0xed,
	0x88, 0xac, 0xd9, 0x6b, 0xdc, 0xdc, 0xa9, 0xd7, 0x70, 0x66, 0xb7, 0xbe, 0x53, 0x6b, 0xec, 0x6c,
	0x6b, 0x61, 0x6e, 0xa9, 0x61, 0x6e, 0xe1, 0xfa, 0x37, 0x6e, 0xd5, 0xf7, 0xf6, 0x35, 0x5c, 0xaf,
	0xd6, 0x1b, 0xb7, 0xeb, 0x35, 0x9c, 0x0d, 0x45, 0xab, 0xb7, 0xf6, 0xf6, 0x6f, 0xde, 0xa8, 0x63,
	0x9c, 0xa8, 0xd5, 0xdf, 0xb8, 0xb5, 0x53, 0xdd, 0xc7, 0x99, 0x91, 0x9e, 0x8c, 0x5e, 0x84, 0x1c,
	0x5f, 0xba, 0xdb, 0x22, 0x36, 0xd5, 0xba, 0x94, 0x79, 0x3c, 0x6d, 0xf8, 0x28, 0x32, 0x8b, 0xb3,
	0x7d, 0xc6, 0x6d, 0x49, 0x1f, 0x9e, 0x8e, 0x4e, 0x3f, 0xda, 0x74, 0x74, 0x00, 0x73, 0x2d, 0xd2,
	0xa4, 0x2d, 0x4f, 0x5d, 0x12, 0x06, 0x76, 0xee, 0xeb, 0xf2, 0x87, 0xaa, 0xfc, 0xf2, 0x75, 0x61,
	0x50, 0x0e, 0xa7, 0x81, 0x75, 0x0e, 0x34, 0xa6, 0xee, 0x4a, 0xa0, 0x91, 0xf3, 0x48, 0xc2, 0xd4,
	0x5d, 0x0e, 0x34, 0x3c, 0x4c, 0x5d, 0x57, 0xd7, 0x82, 0x4b, 0xe2, 0x60, 0xfe, 0x80, 0xae, 0xab,
	0xef, 0x48, 0x4a, 0x64, 0x8c, 0x7e, 0x62, 0x68, 0x8c, 0x56, 0x21, 0xe1, 0x32, 0x87, 0xcf, 0xe9,
	0xaa, 0x2a, 0x4d, 0x06, 0xaf, 0xf9, 0xab, 0x30, 0x1f, 0x59, 0xc4, 0xff, 0x74, 0xe2, 0xfc, 0x19,
	0xef, 0x9d, 0x3f, 0x51, 0xe0, 0x22, 0x9c, 0x8b, 0x6e, 0x74, 0x65, 0xb0, 0x53, 0x79, 0xb8, 0x9c,
	0x93, 0xf0, 0x06, 0xe7, 0x21, 0x27, 0x7b, 0xac, 0x2c, 0x00, 0xc9, 0x4c, 0x86, 0x80, 0xc2, 0xdb,
	0x69, 0x44, 0xb3, 0x7f, 0xe0, 0x1c, 0xcd, 0xba, 0xe9, 0x07, 0xce, 0xe2, 0x67, 0x0a, 0xa4, 0x87,
	0x2e, 0x2e, 0x91, 0x33, 0xfd, 0x6e, 0xb1, 0xf2, 0xf8, 0xe1, 0x9b, 0x70, 0xc5, 0x38, 0xe9, 0x2a,
	0x30, 0xf6, 0x08, 0x57, 0x81, 0x83, 0x8b, 0xba, 0xed, 0xea, 0xee, 0xe0, 0xa2, 0xae, 0xf2, 0x53,
	0xe5, 0xee, 0xe7, 0x85, 0x53, 0x9f, 0x7e, 0x5e, 0x38, 0xf5, 0xc5, 0xe7, 0x05, 0xe5, 0x07, 0x27,
	0x05, 0xe5, 0x0f, 0x27, 0x05, 0xe5, 0xaf, 0x27, 0x05, 0xe5, 0xee, 0x49, 0x41, 0xf9, 0xf4, 0xa4,
	0xa0, 0x7c, 0x76, 0x52, 0x50, 0xfe, 0x79, 0x52, 0x38, 0xf5, 0xc5, 0x49, 0x41, 0xf9, 0xc5, 0xbd,
	0xc2, 0xa9, 0x0f, 0xef, 0x15, 0x94, 0xbb, 0xf7, 0x0a, 0xa7, 0x3e, 0xbd, 0x57, 0x38, 0xf5, 0xcd,
	0x1d, 0xd3, 0x71, 0x8f, 0xcc, 0x72, 0xd7, 0x69, 0xf9, 0x94, 0x31, 0x52, 0xee, 0x78, 0xeb, 0xe2,
	0xe1, 0xc0, 0x61, 0xed, 0x52, 0x38, 0xe0, 0x94, 0x42, 0xf6, 0xba, 0xdb, 0x34, 0x9d, 0x75, 0xfa,
	0x8e, 0x1f, 0xfc, 0x54, 0x35, 0xf6, 0x9b, 0x5b, 0x73, 0x4e, 0xfc, 0x62, 0xf5, 0xd2, 0x7f, 0x03,
	0x00, 0x00, 0xff, 0xff, 0x51, 0x4b, 0x61, 0xea, 0x06, 0x1c, 0x00, 0x00,
}

func (this *Object) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Object)
	if !ok {
		that2, ok := that.(Object)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if !this.SystemMetadata.Equal(that1.SystemMetadata) {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	return true
}
func (this *SpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SpecType)
	if !ok {
		that2, ok := that.(SpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GcSpec.Equal(that1.GcSpec) {
		return false
	}
	return true
}
func (this *StatusObject) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StatusObject)
	if !ok {
		that2, ok := that.(StatusObject)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if len(this.ObjectRefs) != len(that1.ObjectRefs) {
		return false
	}
	for i := range this.ObjectRefs {
		if !this.ObjectRefs[i].Equal(that1.ObjectRefs[i]) {
			return false
		}
	}
	if len(this.Conditions) != len(that1.Conditions) {
		return false
	}
	for i := range this.Conditions {
		if !this.Conditions[i].Equal(that1.Conditions[i]) {
			return false
		}
	}
	if that1.CloudLinkStatus == nil {
		if this.CloudLinkStatus != nil {
			return false
		}
	} else if this.CloudLinkStatus == nil {
		return false
	} else if !this.CloudLinkStatus.Equal(that1.CloudLinkStatus) {
		return false
	}
	return true
}
func (this *StatusObject_AwsStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StatusObject_AwsStatus)
	if !ok {
		that2, ok := that.(StatusObject_AwsStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsStatus.Equal(that1.AwsStatus) {
		return false
	}
	return true
}
func (this *StatusObject_AzureStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StatusObject_AzureStatus)
	if !ok {
		that2, ok := that.(StatusObject_AzureStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AzureStatus.Equal(that1.AzureStatus) {
		return false
	}
	return true
}
func (this *StatusObject_GcpStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StatusObject_GcpStatus)
	if !ok {
		that2, ok := that.(StatusObject_GcpStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GcpStatus.Equal(that1.GcpStatus) {
		return false
	}
	return true
}
func (this *AWSStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSStatusType)
	if !ok {
		that2, ok := that.(AWSStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ConnectionStatus) != len(that1.ConnectionStatus) {
		return false
	}
	for i := range this.ConnectionStatus {
		if !this.ConnectionStatus[i].Equal(that1.ConnectionStatus[i]) {
			return false
		}
	}
	if this.SuggestedAction != that1.SuggestedAction {
		return false
	}
	if this.ErrorDescription != that1.ErrorDescription {
		return false
	}
	if this.CloudLinkState != that1.CloudLinkState {
		return false
	}
	if this.DeploymentStatus != that1.DeploymentStatus {
		return false
	}
	return true
}
func (this *DirectConnectConnectionStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DirectConnectConnectionStatusType)
	if !ok {
		that2, ok := that.(DirectConnectConnectionStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Bandwidth != that1.Bandwidth {
		return false
	}
	if this.ConnectionId != that1.ConnectionId {
		return false
	}
	if this.ConnectionName != that1.ConnectionName {
		return false
	}
	if this.ConnectionState != that1.ConnectionState {
		return false
	}
	if this.HasLogicalRedundancy != that1.HasLogicalRedundancy {
		return false
	}
	if this.Location != that1.Location {
		return false
	}
	if this.PartnerName != that1.PartnerName {
		return false
	}
	if this.ProviderName != that1.ProviderName {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if this.Vlan != that1.Vlan {
		return false
	}
	if this.JumboFrameCapable != that1.JumboFrameCapable {
		return false
	}
	if this.OwnerAccount != that1.OwnerAccount {
		return false
	}
	if !this.VifStatus.Equal(that1.VifStatus) {
		return false
	}
	if !this.GatewayStatus.Equal(that1.GatewayStatus) {
		return false
	}
	if this.AwsPath != that1.AwsPath {
		return false
	}
	return true
}
func (this *VirtualInterfaceStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualInterfaceStatusType)
	if !ok {
		that2, ok := that.(VirtualInterfaceStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AddressFamily != that1.AddressFamily {
		return false
	}
	if this.AmazonAddress != that1.AmazonAddress {
		return false
	}
	if this.AmazonAsn != that1.AmazonAsn {
		return false
	}
	if this.BgpAsn != that1.BgpAsn {
		return false
	}
	if this.ConnectionId != that1.ConnectionId {
		return false
	}
	if this.DirectConnectGatewayId != that1.DirectConnectGatewayId {
		return false
	}
	if this.DirectConnectGatewayName != that1.DirectConnectGatewayName {
		return false
	}
	if this.VirtualInterfaceState != that1.VirtualInterfaceState {
		return false
	}
	if this.Location != that1.Location {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if this.Vlan != that1.Vlan {
		return false
	}
	if this.VirtualInterfaceId != that1.VirtualInterfaceId {
		return false
	}
	if this.VirtualInterfaceName != that1.VirtualInterfaceName {
		return false
	}
	if this.VirtualInterfaceType != that1.VirtualInterfaceType {
		return false
	}
	if len(this.BgpPeers) != len(that1.BgpPeers) {
		return false
	}
	for i := range this.BgpPeers {
		if !this.BgpPeers[i].Equal(that1.BgpPeers[i]) {
			return false
		}
	}
	if this.JumboFrameCapable != that1.JumboFrameCapable {
		return false
	}
	if this.Mtu != that1.Mtu {
		return false
	}
	if this.OwnerAccount != that1.OwnerAccount {
		return false
	}
	if this.DirectConnectAttachmentState != that1.DirectConnectAttachmentState {
		return false
	}
	if this.AttachmentStateChangeError != that1.AttachmentStateChangeError {
		return false
	}
	if this.AwsPath != that1.AwsPath {
		return false
	}
	return true
}
func (this *BGPPeerType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BGPPeerType)
	if !ok {
		that2, ok := that.(BGPPeerType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AddressFamily != that1.AddressFamily {
		return false
	}
	if this.CloudProviderAddress != that1.CloudProviderAddress {
		return false
	}
	if this.Asn != that1.Asn {
		return false
	}
	if this.BgpPeerId != that1.BgpPeerId {
		return false
	}
	if this.BgpPeerState != that1.BgpPeerState {
		return false
	}
	if this.BgpStatus != that1.BgpStatus {
		return false
	}
	if this.CustomerAddress != that1.CustomerAddress {
		return false
	}
	return true
}
func (this *DirectConnectGatewayStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DirectConnectGatewayStatusType)
	if !ok {
		that2, ok := that.(DirectConnectGatewayStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AmazonAsn != that1.AmazonAsn {
		return false
	}
	if this.DirectConnectGatewayId != that1.DirectConnectGatewayId {
		return false
	}
	if this.DirectConnectGatewayName != that1.DirectConnectGatewayName {
		return false
	}
	if this.DirectConnectGatewayState != that1.DirectConnectGatewayState {
		return false
	}
	if this.StateChangeError != that1.StateChangeError {
		return false
	}
	if this.OwnerAccount != that1.OwnerAccount {
		return false
	}
	if this.AwsPath != that1.AwsPath {
		return false
	}
	return true
}
func (this *AzureStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureStatusType)
	if !ok {
		that2, ok := that.(AzureStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *GCPCloudInterconnectAttachmentStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPCloudInterconnectAttachmentStatusType)
	if !ok {
		that2, ok := that.(GCPCloudInterconnectAttachmentStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.AdminEnabled != that1.AdminEnabled {
		return false
	}
	if this.OperationalStatus != that1.OperationalStatus {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Router != that1.Router {
		return false
	}
	if this.Interconnect != that1.Interconnect {
		return false
	}
	if this.Bandwidth != that1.Bandwidth {
		return false
	}
	if this.Encryption != that1.Encryption {
		return false
	}
	if this.Vlan != that1.Vlan {
		return false
	}
	if this.Mtu != that1.Mtu {
		return false
	}
	if this.StackType != that1.StackType {
		return false
	}
	if this.CloudRouterIp != that1.CloudRouterIp {
		return false
	}
	if this.CustomerRouterIp != that1.CustomerRouterIp {
		return false
	}
	if this.AvailabilityDomain != that1.AvailabilityDomain {
		return false
	}
	if !this.PartnerMetadata.Equal(that1.PartnerMetadata) {
		return false
	}
	if this.PartnerAsn != that1.PartnerAsn {
		return false
	}
	if this.AttachmentState != that1.AttachmentState {
		return false
	}
	if this.DataplaneVersion != that1.DataplaneVersion {
		return false
	}
	if len(this.BgpPeers) != len(that1.BgpPeers) {
		return false
	}
	for i := range this.BgpPeers {
		if !this.BgpPeers[i].Equal(that1.BgpPeers[i]) {
			return false
		}
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if this.GcpPath != that1.GcpPath {
		return false
	}
	if this.VpcNetwork != that1.VpcNetwork {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	if this.Project != that1.Project {
		return false
	}
	return true
}
func (this *GCPStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPStatusType)
	if !ok {
		that2, ok := that.(GCPStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ConnectionStatus) != len(that1.ConnectionStatus) {
		return false
	}
	for i := range this.ConnectionStatus {
		if !this.ConnectionStatus[i].Equal(that1.ConnectionStatus[i]) {
			return false
		}
	}
	if this.CloudLinkState != that1.CloudLinkState {
		return false
	}
	return true
}
func (this *Object) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloud_link.Object{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	if this.SystemMetadata != nil {
		s = append(s, "SystemMetadata: "+fmt.Sprintf("%#v", this.SystemMetadata)+",\n")
	}
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_link.SpecType{")
	if this.GcSpec != nil {
		s = append(s, "GcSpec: "+fmt.Sprintf("%#v", this.GcSpec)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StatusObject) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&cloud_link.StatusObject{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	if this.ObjectRefs != nil {
		s = append(s, "ObjectRefs: "+fmt.Sprintf("%#v", this.ObjectRefs)+",\n")
	}
	if this.Conditions != nil {
		s = append(s, "Conditions: "+fmt.Sprintf("%#v", this.Conditions)+",\n")
	}
	if this.CloudLinkStatus != nil {
		s = append(s, "CloudLinkStatus: "+fmt.Sprintf("%#v", this.CloudLinkStatus)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StatusObject_AwsStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_link.StatusObject_AwsStatus{` +
		`AwsStatus:` + fmt.Sprintf("%#v", this.AwsStatus) + `}`}, ", ")
	return s
}
func (this *StatusObject_AzureStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_link.StatusObject_AzureStatus{` +
		`AzureStatus:` + fmt.Sprintf("%#v", this.AzureStatus) + `}`}, ", ")
	return s
}
func (this *StatusObject_GcpStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_link.StatusObject_GcpStatus{` +
		`GcpStatus:` + fmt.Sprintf("%#v", this.GcpStatus) + `}`}, ", ")
	return s
}
func (this *AWSStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&cloud_link.AWSStatusType{")
	if this.ConnectionStatus != nil {
		s = append(s, "ConnectionStatus: "+fmt.Sprintf("%#v", this.ConnectionStatus)+",\n")
	}
	s = append(s, "SuggestedAction: "+fmt.Sprintf("%#v", this.SuggestedAction)+",\n")
	s = append(s, "ErrorDescription: "+fmt.Sprintf("%#v", this.ErrorDescription)+",\n")
	s = append(s, "CloudLinkState: "+fmt.Sprintf("%#v", this.CloudLinkState)+",\n")
	s = append(s, "DeploymentStatus: "+fmt.Sprintf("%#v", this.DeploymentStatus)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DirectConnectConnectionStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 20)
	s = append(s, "&cloud_link.DirectConnectConnectionStatusType{")
	s = append(s, "Bandwidth: "+fmt.Sprintf("%#v", this.Bandwidth)+",\n")
	s = append(s, "ConnectionId: "+fmt.Sprintf("%#v", this.ConnectionId)+",\n")
	s = append(s, "ConnectionName: "+fmt.Sprintf("%#v", this.ConnectionName)+",\n")
	s = append(s, "ConnectionState: "+fmt.Sprintf("%#v", this.ConnectionState)+",\n")
	s = append(s, "HasLogicalRedundancy: "+fmt.Sprintf("%#v", this.HasLogicalRedundancy)+",\n")
	s = append(s, "Location: "+fmt.Sprintf("%#v", this.Location)+",\n")
	s = append(s, "PartnerName: "+fmt.Sprintf("%#v", this.PartnerName)+",\n")
	s = append(s, "ProviderName: "+fmt.Sprintf("%#v", this.ProviderName)+",\n")
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	s = append(s, "Vlan: "+fmt.Sprintf("%#v", this.Vlan)+",\n")
	s = append(s, "JumboFrameCapable: "+fmt.Sprintf("%#v", this.JumboFrameCapable)+",\n")
	s = append(s, "OwnerAccount: "+fmt.Sprintf("%#v", this.OwnerAccount)+",\n")
	if this.VifStatus != nil {
		s = append(s, "VifStatus: "+fmt.Sprintf("%#v", this.VifStatus)+",\n")
	}
	if this.GatewayStatus != nil {
		s = append(s, "GatewayStatus: "+fmt.Sprintf("%#v", this.GatewayStatus)+",\n")
	}
	s = append(s, "AwsPath: "+fmt.Sprintf("%#v", this.AwsPath)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VirtualInterfaceStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 26)
	s = append(s, "&cloud_link.VirtualInterfaceStatusType{")
	s = append(s, "AddressFamily: "+fmt.Sprintf("%#v", this.AddressFamily)+",\n")
	s = append(s, "AmazonAddress: "+fmt.Sprintf("%#v", this.AmazonAddress)+",\n")
	s = append(s, "AmazonAsn: "+fmt.Sprintf("%#v", this.AmazonAsn)+",\n")
	s = append(s, "BgpAsn: "+fmt.Sprintf("%#v", this.BgpAsn)+",\n")
	s = append(s, "ConnectionId: "+fmt.Sprintf("%#v", this.ConnectionId)+",\n")
	s = append(s, "DirectConnectGatewayId: "+fmt.Sprintf("%#v", this.DirectConnectGatewayId)+",\n")
	s = append(s, "DirectConnectGatewayName: "+fmt.Sprintf("%#v", this.DirectConnectGatewayName)+",\n")
	s = append(s, "VirtualInterfaceState: "+fmt.Sprintf("%#v", this.VirtualInterfaceState)+",\n")
	s = append(s, "Location: "+fmt.Sprintf("%#v", this.Location)+",\n")
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	s = append(s, "Vlan: "+fmt.Sprintf("%#v", this.Vlan)+",\n")
	s = append(s, "VirtualInterfaceId: "+fmt.Sprintf("%#v", this.VirtualInterfaceId)+",\n")
	s = append(s, "VirtualInterfaceName: "+fmt.Sprintf("%#v", this.VirtualInterfaceName)+",\n")
	s = append(s, "VirtualInterfaceType: "+fmt.Sprintf("%#v", this.VirtualInterfaceType)+",\n")
	if this.BgpPeers != nil {
		s = append(s, "BgpPeers: "+fmt.Sprintf("%#v", this.BgpPeers)+",\n")
	}
	s = append(s, "JumboFrameCapable: "+fmt.Sprintf("%#v", this.JumboFrameCapable)+",\n")
	s = append(s, "Mtu: "+fmt.Sprintf("%#v", this.Mtu)+",\n")
	s = append(s, "OwnerAccount: "+fmt.Sprintf("%#v", this.OwnerAccount)+",\n")
	s = append(s, "DirectConnectAttachmentState: "+fmt.Sprintf("%#v", this.DirectConnectAttachmentState)+",\n")
	s = append(s, "AttachmentStateChangeError: "+fmt.Sprintf("%#v", this.AttachmentStateChangeError)+",\n")
	s = append(s, "AwsPath: "+fmt.Sprintf("%#v", this.AwsPath)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BGPPeerType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&cloud_link.BGPPeerType{")
	s = append(s, "AddressFamily: "+fmt.Sprintf("%#v", this.AddressFamily)+",\n")
	s = append(s, "CloudProviderAddress: "+fmt.Sprintf("%#v", this.CloudProviderAddress)+",\n")
	s = append(s, "Asn: "+fmt.Sprintf("%#v", this.Asn)+",\n")
	s = append(s, "BgpPeerId: "+fmt.Sprintf("%#v", this.BgpPeerId)+",\n")
	s = append(s, "BgpPeerState: "+fmt.Sprintf("%#v", this.BgpPeerState)+",\n")
	s = append(s, "BgpStatus: "+fmt.Sprintf("%#v", this.BgpStatus)+",\n")
	s = append(s, "CustomerAddress: "+fmt.Sprintf("%#v", this.CustomerAddress)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DirectConnectGatewayStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&cloud_link.DirectConnectGatewayStatusType{")
	s = append(s, "AmazonAsn: "+fmt.Sprintf("%#v", this.AmazonAsn)+",\n")
	s = append(s, "DirectConnectGatewayId: "+fmt.Sprintf("%#v", this.DirectConnectGatewayId)+",\n")
	s = append(s, "DirectConnectGatewayName: "+fmt.Sprintf("%#v", this.DirectConnectGatewayName)+",\n")
	s = append(s, "DirectConnectGatewayState: "+fmt.Sprintf("%#v", this.DirectConnectGatewayState)+",\n")
	s = append(s, "StateChangeError: "+fmt.Sprintf("%#v", this.StateChangeError)+",\n")
	s = append(s, "OwnerAccount: "+fmt.Sprintf("%#v", this.OwnerAccount)+",\n")
	s = append(s, "AwsPath: "+fmt.Sprintf("%#v", this.AwsPath)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&cloud_link.AzureStatusType{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPCloudInterconnectAttachmentStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 28)
	s = append(s, "&cloud_link.GCPCloudInterconnectAttachmentStatusType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "AdminEnabled: "+fmt.Sprintf("%#v", this.AdminEnabled)+",\n")
	s = append(s, "OperationalStatus: "+fmt.Sprintf("%#v", this.OperationalStatus)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Router: "+fmt.Sprintf("%#v", this.Router)+",\n")
	s = append(s, "Interconnect: "+fmt.Sprintf("%#v", this.Interconnect)+",\n")
	s = append(s, "Bandwidth: "+fmt.Sprintf("%#v", this.Bandwidth)+",\n")
	s = append(s, "Encryption: "+fmt.Sprintf("%#v", this.Encryption)+",\n")
	s = append(s, "Vlan: "+fmt.Sprintf("%#v", this.Vlan)+",\n")
	s = append(s, "Mtu: "+fmt.Sprintf("%#v", this.Mtu)+",\n")
	s = append(s, "StackType: "+fmt.Sprintf("%#v", this.StackType)+",\n")
	s = append(s, "CloudRouterIp: "+fmt.Sprintf("%#v", this.CloudRouterIp)+",\n")
	s = append(s, "CustomerRouterIp: "+fmt.Sprintf("%#v", this.CustomerRouterIp)+",\n")
	s = append(s, "AvailabilityDomain: "+fmt.Sprintf("%#v", this.AvailabilityDomain)+",\n")
	if this.PartnerMetadata != nil {
		s = append(s, "PartnerMetadata: "+fmt.Sprintf("%#v", this.PartnerMetadata)+",\n")
	}
	s = append(s, "PartnerAsn: "+fmt.Sprintf("%#v", this.PartnerAsn)+",\n")
	s = append(s, "AttachmentState: "+fmt.Sprintf("%#v", this.AttachmentState)+",\n")
	s = append(s, "DataplaneVersion: "+fmt.Sprintf("%#v", this.DataplaneVersion)+",\n")
	if this.BgpPeers != nil {
		s = append(s, "BgpPeers: "+fmt.Sprintf("%#v", this.BgpPeers)+",\n")
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "GcpPath: "+fmt.Sprintf("%#v", this.GcpPath)+",\n")
	s = append(s, "VpcNetwork: "+fmt.Sprintf("%#v", this.VpcNetwork)+",\n")
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	s = append(s, "Project: "+fmt.Sprintf("%#v", this.Project)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloud_link.GCPStatusType{")
	if this.ConnectionStatus != nil {
		s = append(s, "ConnectionStatus: "+fmt.Sprintf("%#v", this.ConnectionStatus)+",\n")
	}
	s = append(s, "CloudLinkState: "+fmt.Sprintf("%#v", this.CloudLinkState)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringObject(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Object) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Object) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Object) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintObject(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SystemMetadata != nil {
		{
			size, err := m.SystemMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintObject(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintObject(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GcSpec != nil {
		{
			size, err := m.GcSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintObject(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *StatusObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusObject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusObject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CloudLinkStatus != nil {
		{
			size := m.CloudLinkStatus.Size()
			i -= size
			if _, err := m.CloudLinkStatus.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintObject(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ObjectRefs) > 0 {
		for iNdEx := len(m.ObjectRefs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ObjectRefs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintObject(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintObject(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatusObject_AwsStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusObject_AwsStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsStatus != nil {
		{
			size, err := m.AwsStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintObject(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *StatusObject_AzureStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusObject_AzureStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AzureStatus != nil {
		{
			size, err := m.AzureStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintObject(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *StatusObject_GcpStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusObject_GcpStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GcpStatus != nil {
		{
			size, err := m.GcpStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintObject(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *AWSStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeploymentStatus != 0 {
		i = encodeVarintObject(dAtA, i, uint64(m.DeploymentStatus))
		i--
		dAtA[i] = 0x40
	}
	if m.CloudLinkState != 0 {
		i = encodeVarintObject(dAtA, i, uint64(m.CloudLinkState))
		i--
		dAtA[i] = 0x38
	}
	if len(m.ErrorDescription) > 0 {
		i -= len(m.ErrorDescription)
		copy(dAtA[i:], m.ErrorDescription)
		i = encodeVarintObject(dAtA, i, uint64(len(m.ErrorDescription)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SuggestedAction) > 0 {
		i -= len(m.SuggestedAction)
		copy(dAtA[i:], m.SuggestedAction)
		i = encodeVarintObject(dAtA, i, uint64(len(m.SuggestedAction)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ConnectionStatus) > 0 {
		for iNdEx := len(m.ConnectionStatus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ConnectionStatus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintObject(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *DirectConnectConnectionStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirectConnectConnectionStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DirectConnectConnectionStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AwsPath) > 0 {
		i -= len(m.AwsPath)
		copy(dAtA[i:], m.AwsPath)
		i = encodeVarintObject(dAtA, i, uint64(len(m.AwsPath)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.GatewayStatus != nil {
		{
			size, err := m.GatewayStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintObject(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.VifStatus != nil {
		{
			size, err := m.VifStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintObject(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if len(m.OwnerAccount) > 0 {
		i -= len(m.OwnerAccount)
		copy(dAtA[i:], m.OwnerAccount)
		i = encodeVarintObject(dAtA, i, uint64(len(m.OwnerAccount)))
		i--
		dAtA[i] = 0x6a
	}
	if m.JumboFrameCapable {
		i--
		if m.JumboFrameCapable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.Vlan != 0 {
		i = encodeVarintObject(dAtA, i, uint64(m.Vlan))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Tags) > 0 {
		keysForTags := make([]string, 0, len(m.Tags))
		for k := range m.Tags {
			keysForTags = append(keysForTags, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
		for iNdEx := len(keysForTags) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Tags[string(keysForTags[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintObject(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForTags[iNdEx])
			copy(dAtA[i:], keysForTags[iNdEx])
			i = encodeVarintObject(dAtA, i, uint64(len(keysForTags[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintObject(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintObject(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ProviderName) > 0 {
		i -= len(m.ProviderName)
		copy(dAtA[i:], m.ProviderName)
		i = encodeVarintObject(dAtA, i, uint64(len(m.ProviderName)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.PartnerName) > 0 {
		i -= len(m.PartnerName)
		copy(dAtA[i:], m.PartnerName)
		i = encodeVarintObject(dAtA, i, uint64(len(m.PartnerName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintObject(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.HasLogicalRedundancy) > 0 {
		i -= len(m.HasLogicalRedundancy)
		copy(dAtA[i:], m.HasLogicalRedundancy)
		i = encodeVarintObject(dAtA, i, uint64(len(m.HasLogicalRedundancy)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ConnectionState) > 0 {
		i -= len(m.ConnectionState)
		copy(dAtA[i:], m.ConnectionState)
		i = encodeVarintObject(dAtA, i, uint64(len(m.ConnectionState)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ConnectionName) > 0 {
		i -= len(m.ConnectionName)
		copy(dAtA[i:], m.ConnectionName)
		i = encodeVarintObject(dAtA, i, uint64(len(m.ConnectionName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ConnectionId) > 0 {
		i -= len(m.ConnectionId)
		copy(dAtA[i:], m.ConnectionId)
		i = encodeVarintObject(dAtA, i, uint64(len(m.ConnectionId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Bandwidth) > 0 {
		i -= len(m.Bandwidth)
		copy(dAtA[i:], m.Bandwidth)
		i = encodeVarintObject(dAtA, i, uint64(len(m.Bandwidth)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VirtualInterfaceStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualInterfaceStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VirtualInterfaceStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AwsPath) > 0 {
		i -= len(m.AwsPath)
		copy(dAtA[i:], m.AwsPath)
		i = encodeVarintObject(dAtA, i, uint64(len(m.AwsPath)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.AttachmentStateChangeError) > 0 {
		i -= len(m.AttachmentStateChangeError)
		copy(dAtA[i:], m.AttachmentStateChangeError)
		i = encodeVarintObject(dAtA, i, uint64(len(m.AttachmentStateChangeError)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.DirectConnectAttachmentState) > 0 {
		i -= len(m.DirectConnectAttachmentState)
		copy(dAtA[i:], m.DirectConnectAttachmentState)
		i = encodeVarintObject(dAtA, i, uint64(len(m.DirectConnectAttachmentState)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.OwnerAccount) > 0 {
		i -= len(m.OwnerAccount)
		copy(dAtA[i:], m.OwnerAccount)
		i = encodeVarintObject(dAtA, i, uint64(len(m.OwnerAccount)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.Mtu != 0 {
		i = encodeVarintObject(dAtA, i, uint64(m.Mtu))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.JumboFrameCapable {
		i--
		if m.JumboFrameCapable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.BgpPeers) > 0 {
		for iNdEx := len(m.BgpPeers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BgpPeers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintObject(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.VirtualInterfaceType) > 0 {
		i -= len(m.VirtualInterfaceType)
		copy(dAtA[i:], m.VirtualInterfaceType)
		i = encodeVarintObject(dAtA, i, uint64(len(m.VirtualInterfaceType)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.VirtualInterfaceName) > 0 {
		i -= len(m.VirtualInterfaceName)
		copy(dAtA[i:], m.VirtualInterfaceName)
		i = encodeVarintObject(dAtA, i, uint64(len(m.VirtualInterfaceName)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.VirtualInterfaceId) > 0 {
		i -= len(m.VirtualInterfaceId)
		copy(dAtA[i:], m.VirtualInterfaceId)
		i = encodeVarintObject(dAtA, i, uint64(len(m.VirtualInterfaceId)))
		i--
		dAtA[i] = 0x6a
	}
	if m.Vlan != 0 {
		i = encodeVarintObject(dAtA, i, uint64(m.Vlan))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Tags) > 0 {
		keysForTags := make([]string, 0, len(m.Tags))
		for k := range m.Tags {
			keysForTags = append(keysForTags, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
		for iNdEx := len(keysForTags) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Tags[string(keysForTags[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintObject(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForTags[iNdEx])
			copy(dAtA[i:], keysForTags[iNdEx])
			i = encodeVarintObject(dAtA, i, uint64(len(keysForTags[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintObject(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintObject(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintObject(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.VirtualInterfaceState) > 0 {
		i -= len(m.VirtualInterfaceState)
		copy(dAtA[i:], m.VirtualInterfaceState)
		i = encodeVarintObject(dAtA, i, uint64(len(m.VirtualInterfaceState)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.DirectConnectGatewayName) > 0 {
		i -= len(m.DirectConnectGatewayName)
		copy(dAtA[i:], m.DirectConnectGatewayName)
		i = encodeVarintObject(dAtA, i, uint64(len(m.DirectConnectGatewayName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DirectConnectGatewayId) > 0 {
		i -= len(m.DirectConnectGatewayId)
		copy(dAtA[i:], m.DirectConnectGatewayId)
		i = encodeVarintObject(dAtA, i, uint64(len(m.DirectConnectGatewayId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ConnectionId) > 0 {
		i -= len(m.ConnectionId)
		copy(dAtA[i:], m.ConnectionId)
		i = encodeVarintObject(dAtA, i, uint64(len(m.ConnectionId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.BgpAsn != 0 {
		i = encodeVarintObject(dAtA, i, uint64(m.BgpAsn))
		i--
		dAtA[i] = 0x20
	}
	if m.AmazonAsn != 0 {
		i = encodeVarintObject(dAtA, i, uint64(m.AmazonAsn))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AmazonAddress) > 0 {
		i -= len(m.AmazonAddress)
		copy(dAtA[i:], m.AmazonAddress)
		i = encodeVarintObject(dAtA, i, uint64(len(m.AmazonAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AddressFamily) > 0 {
		i -= len(m.AddressFamily)
		copy(dAtA[i:], m.AddressFamily)
		i = encodeVarintObject(dAtA, i, uint64(len(m.AddressFamily)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BGPPeerType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BGPPeerType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CloudProviderAddress) > 0 {
		i -= len(m.CloudProviderAddress)
		copy(dAtA[i:], m.CloudProviderAddress)
		i = encodeVarintObject(dAtA, i, uint64(len(m.CloudProviderAddress)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.CustomerAddress) > 0 {
		i -= len(m.CustomerAddress)
		copy(dAtA[i:], m.CustomerAddress)
		i = encodeVarintObject(dAtA, i, uint64(len(m.CustomerAddress)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.BgpStatus) > 0 {
		i -= len(m.BgpStatus)
		copy(dAtA[i:], m.BgpStatus)
		i = encodeVarintObject(dAtA, i, uint64(len(m.BgpStatus)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.BgpPeerState) > 0 {
		i -= len(m.BgpPeerState)
		copy(dAtA[i:], m.BgpPeerState)
		i = encodeVarintObject(dAtA, i, uint64(len(m.BgpPeerState)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.BgpPeerId) > 0 {
		i -= len(m.BgpPeerId)
		copy(dAtA[i:], m.BgpPeerId)
		i = encodeVarintObject(dAtA, i, uint64(len(m.BgpPeerId)))
		i--
		dAtA[i] = 0x22
	}
	if m.Asn != 0 {
		i = encodeVarintObject(dAtA, i, uint64(m.Asn))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AddressFamily) > 0 {
		i -= len(m.AddressFamily)
		copy(dAtA[i:], m.AddressFamily)
		i = encodeVarintObject(dAtA, i, uint64(len(m.AddressFamily)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DirectConnectGatewayStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirectConnectGatewayStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DirectConnectGatewayStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AwsPath) > 0 {
		i -= len(m.AwsPath)
		copy(dAtA[i:], m.AwsPath)
		i = encodeVarintObject(dAtA, i, uint64(len(m.AwsPath)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.OwnerAccount) > 0 {
		i -= len(m.OwnerAccount)
		copy(dAtA[i:], m.OwnerAccount)
		i = encodeVarintObject(dAtA, i, uint64(len(m.OwnerAccount)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.StateChangeError) > 0 {
		i -= len(m.StateChangeError)
		copy(dAtA[i:], m.StateChangeError)
		i = encodeVarintObject(dAtA, i, uint64(len(m.StateChangeError)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DirectConnectGatewayState) > 0 {
		i -= len(m.DirectConnectGatewayState)
		copy(dAtA[i:], m.DirectConnectGatewayState)
		i = encodeVarintObject(dAtA, i, uint64(len(m.DirectConnectGatewayState)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DirectConnectGatewayName) > 0 {
		i -= len(m.DirectConnectGatewayName)
		copy(dAtA[i:], m.DirectConnectGatewayName)
		i = encodeVarintObject(dAtA, i, uint64(len(m.DirectConnectGatewayName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DirectConnectGatewayId) > 0 {
		i -= len(m.DirectConnectGatewayId)
		copy(dAtA[i:], m.DirectConnectGatewayId)
		i = encodeVarintObject(dAtA, i, uint64(len(m.DirectConnectGatewayId)))
		i--
		dAtA[i] = 0x12
	}
	if m.AmazonAsn != 0 {
		i = encodeVarintObject(dAtA, i, uint64(m.AmazonAsn))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AzureStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GCPCloudInterconnectAttachmentStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPCloudInterconnectAttachmentStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPCloudInterconnectAttachmentStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Project) > 0 {
		i -= len(m.Project)
		copy(dAtA[i:], m.Project)
		i = encodeVarintObject(dAtA, i, uint64(len(m.Project)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintObject(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.VpcNetwork) > 0 {
		i -= len(m.VpcNetwork)
		copy(dAtA[i:], m.VpcNetwork)
		i = encodeVarintObject(dAtA, i, uint64(len(m.VpcNetwork)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.GcpPath) > 0 {
		i -= len(m.GcpPath)
		copy(dAtA[i:], m.GcpPath)
		i = encodeVarintObject(dAtA, i, uint64(len(m.GcpPath)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintObject(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintObject(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintObject(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.BgpPeers) > 0 {
		for iNdEx := len(m.BgpPeers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BgpPeers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintObject(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.DataplaneVersion != 0 {
		i = encodeVarintObject(dAtA, i, uint64(m.DataplaneVersion))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.AttachmentState) > 0 {
		i -= len(m.AttachmentState)
		copy(dAtA[i:], m.AttachmentState)
		i = encodeVarintObject(dAtA, i, uint64(len(m.AttachmentState)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.PartnerAsn != 0 {
		i = encodeVarintObject(dAtA, i, uint64(m.PartnerAsn))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.PartnerMetadata != nil {
		{
			size, err := m.PartnerMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintObject(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if len(m.AvailabilityDomain) > 0 {
		i -= len(m.AvailabilityDomain)
		copy(dAtA[i:], m.AvailabilityDomain)
		i = encodeVarintObject(dAtA, i, uint64(len(m.AvailabilityDomain)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.CustomerRouterIp) > 0 {
		i -= len(m.CustomerRouterIp)
		copy(dAtA[i:], m.CustomerRouterIp)
		i = encodeVarintObject(dAtA, i, uint64(len(m.CustomerRouterIp)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.CloudRouterIp) > 0 {
		i -= len(m.CloudRouterIp)
		copy(dAtA[i:], m.CloudRouterIp)
		i = encodeVarintObject(dAtA, i, uint64(len(m.CloudRouterIp)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.StackType) > 0 {
		i -= len(m.StackType)
		copy(dAtA[i:], m.StackType)
		i = encodeVarintObject(dAtA, i, uint64(len(m.StackType)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Mtu != 0 {
		i = encodeVarintObject(dAtA, i, uint64(m.Mtu))
		i--
		dAtA[i] = 0x50
	}
	if m.Vlan != 0 {
		i = encodeVarintObject(dAtA, i, uint64(m.Vlan))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Encryption) > 0 {
		i -= len(m.Encryption)
		copy(dAtA[i:], m.Encryption)
		i = encodeVarintObject(dAtA, i, uint64(len(m.Encryption)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Bandwidth) > 0 {
		i -= len(m.Bandwidth)
		copy(dAtA[i:], m.Bandwidth)
		i = encodeVarintObject(dAtA, i, uint64(len(m.Bandwidth)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Interconnect) > 0 {
		i -= len(m.Interconnect)
		copy(dAtA[i:], m.Interconnect)
		i = encodeVarintObject(dAtA, i, uint64(len(m.Interconnect)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Router) > 0 {
		i -= len(m.Router)
		copy(dAtA[i:], m.Router)
		i = encodeVarintObject(dAtA, i, uint64(len(m.Router)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintObject(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OperationalStatus) > 0 {
		i -= len(m.OperationalStatus)
		copy(dAtA[i:], m.OperationalStatus)
		i = encodeVarintObject(dAtA, i, uint64(len(m.OperationalStatus)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AdminEnabled {
		i--
		if m.AdminEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintObject(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GCPStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CloudLinkState != 0 {
		i = encodeVarintObject(dAtA, i, uint64(m.CloudLinkState))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ConnectionStatus) > 0 {
		for iNdEx := len(m.ConnectionStatus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ConnectionStatus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintObject(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintObject(dAtA []byte, offset int, v uint64) int {
	offset -= sovObject(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Object) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovObject(uint64(l))
	}
	if m.SystemMetadata != nil {
		l = m.SystemMetadata.Size()
		n += 1 + l + sovObject(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovObject(uint64(l))
	}
	return n
}

func (m *SpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GcSpec != nil {
		l = m.GcSpec.Size()
		n += 1 + l + sovObject(uint64(l))
	}
	return n
}

func (m *StatusObject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovObject(uint64(l))
	}
	if len(m.ObjectRefs) > 0 {
		for _, e := range m.ObjectRefs {
			l = e.Size()
			n += 1 + l + sovObject(uint64(l))
		}
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovObject(uint64(l))
		}
	}
	if m.CloudLinkStatus != nil {
		n += m.CloudLinkStatus.Size()
	}
	return n
}

func (m *StatusObject_AwsStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsStatus != nil {
		l = m.AwsStatus.Size()
		n += 1 + l + sovObject(uint64(l))
	}
	return n
}
func (m *StatusObject_AzureStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AzureStatus != nil {
		l = m.AzureStatus.Size()
		n += 1 + l + sovObject(uint64(l))
	}
	return n
}
func (m *StatusObject_GcpStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GcpStatus != nil {
		l = m.GcpStatus.Size()
		n += 1 + l + sovObject(uint64(l))
	}
	return n
}
func (m *AWSStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ConnectionStatus) > 0 {
		for _, e := range m.ConnectionStatus {
			l = e.Size()
			n += 1 + l + sovObject(uint64(l))
		}
	}
	l = len(m.SuggestedAction)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.ErrorDescription)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	if m.CloudLinkState != 0 {
		n += 1 + sovObject(uint64(m.CloudLinkState))
	}
	if m.DeploymentStatus != 0 {
		n += 1 + sovObject(uint64(m.DeploymentStatus))
	}
	return n
}

func (m *DirectConnectConnectionStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Bandwidth)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.ConnectionId)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.ConnectionName)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.ConnectionState)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.HasLogicalRedundancy)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.PartnerName)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.ProviderName)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovObject(uint64(len(k))) + 1 + len(v) + sovObject(uint64(len(v)))
			n += mapEntrySize + 1 + sovObject(uint64(mapEntrySize))
		}
	}
	if m.Vlan != 0 {
		n += 1 + sovObject(uint64(m.Vlan))
	}
	if m.JumboFrameCapable {
		n += 2
	}
	l = len(m.OwnerAccount)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	if m.VifStatus != nil {
		l = m.VifStatus.Size()
		n += 1 + l + sovObject(uint64(l))
	}
	if m.GatewayStatus != nil {
		l = m.GatewayStatus.Size()
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.AwsPath)
	if l > 0 {
		n += 2 + l + sovObject(uint64(l))
	}
	return n
}

func (m *VirtualInterfaceStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AddressFamily)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.AmazonAddress)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	if m.AmazonAsn != 0 {
		n += 1 + sovObject(uint64(m.AmazonAsn))
	}
	if m.BgpAsn != 0 {
		n += 1 + sovObject(uint64(m.BgpAsn))
	}
	l = len(m.ConnectionId)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.DirectConnectGatewayId)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.DirectConnectGatewayName)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.VirtualInterfaceState)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovObject(uint64(len(k))) + 1 + len(v) + sovObject(uint64(len(v)))
			n += mapEntrySize + 1 + sovObject(uint64(mapEntrySize))
		}
	}
	if m.Vlan != 0 {
		n += 1 + sovObject(uint64(m.Vlan))
	}
	l = len(m.VirtualInterfaceId)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.VirtualInterfaceName)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.VirtualInterfaceType)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	if len(m.BgpPeers) > 0 {
		for _, e := range m.BgpPeers {
			l = e.Size()
			n += 2 + l + sovObject(uint64(l))
		}
	}
	if m.JumboFrameCapable {
		n += 3
	}
	if m.Mtu != 0 {
		n += 2 + sovObject(uint64(m.Mtu))
	}
	l = len(m.OwnerAccount)
	if l > 0 {
		n += 2 + l + sovObject(uint64(l))
	}
	l = len(m.DirectConnectAttachmentState)
	if l > 0 {
		n += 2 + l + sovObject(uint64(l))
	}
	l = len(m.AttachmentStateChangeError)
	if l > 0 {
		n += 2 + l + sovObject(uint64(l))
	}
	l = len(m.AwsPath)
	if l > 0 {
		n += 2 + l + sovObject(uint64(l))
	}
	return n
}

func (m *BGPPeerType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AddressFamily)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	if m.Asn != 0 {
		n += 1 + sovObject(uint64(m.Asn))
	}
	l = len(m.BgpPeerId)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.BgpPeerState)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.BgpStatus)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.CustomerAddress)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.CloudProviderAddress)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	return n
}

func (m *DirectConnectGatewayStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AmazonAsn != 0 {
		n += 1 + sovObject(uint64(m.AmazonAsn))
	}
	l = len(m.DirectConnectGatewayId)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.DirectConnectGatewayName)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.DirectConnectGatewayState)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.StateChangeError)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.OwnerAccount)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.AwsPath)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	return n
}

func (m *AzureStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GCPCloudInterconnectAttachmentStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	if m.AdminEnabled {
		n += 2
	}
	l = len(m.OperationalStatus)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.Router)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.Interconnect)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.Bandwidth)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.Encryption)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	if m.Vlan != 0 {
		n += 1 + sovObject(uint64(m.Vlan))
	}
	if m.Mtu != 0 {
		n += 1 + sovObject(uint64(m.Mtu))
	}
	l = len(m.StackType)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.CloudRouterIp)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.CustomerRouterIp)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	l = len(m.AvailabilityDomain)
	if l > 0 {
		n += 1 + l + sovObject(uint64(l))
	}
	if m.PartnerMetadata != nil {
		l = m.PartnerMetadata.Size()
		n += 1 + l + sovObject(uint64(l))
	}
	if m.PartnerAsn != 0 {
		n += 2 + sovObject(uint64(m.PartnerAsn))
	}
	l = len(m.AttachmentState)
	if l > 0 {
		n += 2 + l + sovObject(uint64(l))
	}
	if m.DataplaneVersion != 0 {
		n += 2 + sovObject(uint64(m.DataplaneVersion))
	}
	if len(m.BgpPeers) > 0 {
		for _, e := range m.BgpPeers {
			l = e.Size()
			n += 2 + l + sovObject(uint64(l))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovObject(uint64(len(k))) + 1 + len(v) + sovObject(uint64(len(v)))
			n += mapEntrySize + 2 + sovObject(uint64(mapEntrySize))
		}
	}
	l = len(m.GcpPath)
	if l > 0 {
		n += 2 + l + sovObject(uint64(l))
	}
	l = len(m.VpcNetwork)
	if l > 0 {
		n += 2 + l + sovObject(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 2 + l + sovObject(uint64(l))
	}
	l = len(m.Project)
	if l > 0 {
		n += 2 + l + sovObject(uint64(l))
	}
	return n
}

func (m *GCPStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ConnectionStatus) > 0 {
		for _, e := range m.ConnectionStatus {
			l = e.Size()
			n += 1 + l + sovObject(uint64(l))
		}
	}
	if m.CloudLinkState != 0 {
		n += 1 + sovObject(uint64(m.CloudLinkState))
	}
	return n
}

func sovObject(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozObject(x uint64) (n int) {
	return sovObject(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Object) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Object{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "ObjectMetaType", "schema.ObjectMetaType", 1) + `,`,
		`SystemMetadata:` + strings.Replace(fmt.Sprintf("%v", this.SystemMetadata), "SystemObjectMetaType", "schema.SystemObjectMetaType", 1) + `,`,
		`Spec:` + strings.Replace(this.Spec.String(), "SpecType", "SpecType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SpecType{`,
		`GcSpec:` + strings.Replace(fmt.Sprintf("%v", this.GcSpec), "GlobalSpecType", "GlobalSpecType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StatusObject) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForObjectRefs := "[]*ObjectRefType{"
	for _, f := range this.ObjectRefs {
		repeatedStringForObjectRefs += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForObjectRefs += "}"
	repeatedStringForConditions := "[]*ConditionType{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += strings.Replace(fmt.Sprintf("%v", f), "ConditionType", "schema.ConditionType", 1) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&StatusObject{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "StatusMetaType", "schema.StatusMetaType", 1) + `,`,
		`ObjectRefs:` + repeatedStringForObjectRefs + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`CloudLinkStatus:` + fmt.Sprintf("%v", this.CloudLinkStatus) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StatusObject_AwsStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StatusObject_AwsStatus{`,
		`AwsStatus:` + strings.Replace(fmt.Sprintf("%v", this.AwsStatus), "AWSStatusType", "AWSStatusType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StatusObject_AzureStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StatusObject_AzureStatus{`,
		`AzureStatus:` + strings.Replace(fmt.Sprintf("%v", this.AzureStatus), "AzureStatusType", "AzureStatusType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StatusObject_GcpStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StatusObject_GcpStatus{`,
		`GcpStatus:` + strings.Replace(fmt.Sprintf("%v", this.GcpStatus), "GCPStatusType", "GCPStatusType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSStatusType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConnectionStatus := "[]*DirectConnectConnectionStatusType{"
	for _, f := range this.ConnectionStatus {
		repeatedStringForConnectionStatus += strings.Replace(f.String(), "DirectConnectConnectionStatusType", "DirectConnectConnectionStatusType", 1) + ","
	}
	repeatedStringForConnectionStatus += "}"
	s := strings.Join([]string{`&AWSStatusType{`,
		`ConnectionStatus:` + repeatedStringForConnectionStatus + `,`,
		`SuggestedAction:` + fmt.Sprintf("%v", this.SuggestedAction) + `,`,
		`ErrorDescription:` + fmt.Sprintf("%v", this.ErrorDescription) + `,`,
		`CloudLinkState:` + fmt.Sprintf("%v", this.CloudLinkState) + `,`,
		`DeploymentStatus:` + fmt.Sprintf("%v", this.DeploymentStatus) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DirectConnectConnectionStatusType) String() string {
	if this == nil {
		return "nil"
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&DirectConnectConnectionStatusType{`,
		`Bandwidth:` + fmt.Sprintf("%v", this.Bandwidth) + `,`,
		`ConnectionId:` + fmt.Sprintf("%v", this.ConnectionId) + `,`,
		`ConnectionName:` + fmt.Sprintf("%v", this.ConnectionName) + `,`,
		`ConnectionState:` + fmt.Sprintf("%v", this.ConnectionState) + `,`,
		`HasLogicalRedundancy:` + fmt.Sprintf("%v", this.HasLogicalRedundancy) + `,`,
		`Location:` + fmt.Sprintf("%v", this.Location) + `,`,
		`PartnerName:` + fmt.Sprintf("%v", this.PartnerName) + `,`,
		`ProviderName:` + fmt.Sprintf("%v", this.ProviderName) + `,`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`Vlan:` + fmt.Sprintf("%v", this.Vlan) + `,`,
		`JumboFrameCapable:` + fmt.Sprintf("%v", this.JumboFrameCapable) + `,`,
		`OwnerAccount:` + fmt.Sprintf("%v", this.OwnerAccount) + `,`,
		`VifStatus:` + strings.Replace(this.VifStatus.String(), "VirtualInterfaceStatusType", "VirtualInterfaceStatusType", 1) + `,`,
		`GatewayStatus:` + strings.Replace(this.GatewayStatus.String(), "DirectConnectGatewayStatusType", "DirectConnectGatewayStatusType", 1) + `,`,
		`AwsPath:` + fmt.Sprintf("%v", this.AwsPath) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VirtualInterfaceStatusType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForBgpPeers := "[]*BGPPeerType{"
	for _, f := range this.BgpPeers {
		repeatedStringForBgpPeers += strings.Replace(f.String(), "BGPPeerType", "BGPPeerType", 1) + ","
	}
	repeatedStringForBgpPeers += "}"
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&VirtualInterfaceStatusType{`,
		`AddressFamily:` + fmt.Sprintf("%v", this.AddressFamily) + `,`,
		`AmazonAddress:` + fmt.Sprintf("%v", this.AmazonAddress) + `,`,
		`AmazonAsn:` + fmt.Sprintf("%v", this.AmazonAsn) + `,`,
		`BgpAsn:` + fmt.Sprintf("%v", this.BgpAsn) + `,`,
		`ConnectionId:` + fmt.Sprintf("%v", this.ConnectionId) + `,`,
		`DirectConnectGatewayId:` + fmt.Sprintf("%v", this.DirectConnectGatewayId) + `,`,
		`DirectConnectGatewayName:` + fmt.Sprintf("%v", this.DirectConnectGatewayName) + `,`,
		`VirtualInterfaceState:` + fmt.Sprintf("%v", this.VirtualInterfaceState) + `,`,
		`Location:` + fmt.Sprintf("%v", this.Location) + `,`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`Vlan:` + fmt.Sprintf("%v", this.Vlan) + `,`,
		`VirtualInterfaceId:` + fmt.Sprintf("%v", this.VirtualInterfaceId) + `,`,
		`VirtualInterfaceName:` + fmt.Sprintf("%v", this.VirtualInterfaceName) + `,`,
		`VirtualInterfaceType:` + fmt.Sprintf("%v", this.VirtualInterfaceType) + `,`,
		`BgpPeers:` + repeatedStringForBgpPeers + `,`,
		`JumboFrameCapable:` + fmt.Sprintf("%v", this.JumboFrameCapable) + `,`,
		`Mtu:` + fmt.Sprintf("%v", this.Mtu) + `,`,
		`OwnerAccount:` + fmt.Sprintf("%v", this.OwnerAccount) + `,`,
		`DirectConnectAttachmentState:` + fmt.Sprintf("%v", this.DirectConnectAttachmentState) + `,`,
		`AttachmentStateChangeError:` + fmt.Sprintf("%v", this.AttachmentStateChangeError) + `,`,
		`AwsPath:` + fmt.Sprintf("%v", this.AwsPath) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BGPPeerType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BGPPeerType{`,
		`AddressFamily:` + fmt.Sprintf("%v", this.AddressFamily) + `,`,
		`Asn:` + fmt.Sprintf("%v", this.Asn) + `,`,
		`BgpPeerId:` + fmt.Sprintf("%v", this.BgpPeerId) + `,`,
		`BgpPeerState:` + fmt.Sprintf("%v", this.BgpPeerState) + `,`,
		`BgpStatus:` + fmt.Sprintf("%v", this.BgpStatus) + `,`,
		`CustomerAddress:` + fmt.Sprintf("%v", this.CustomerAddress) + `,`,
		`CloudProviderAddress:` + fmt.Sprintf("%v", this.CloudProviderAddress) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DirectConnectGatewayStatusType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DirectConnectGatewayStatusType{`,
		`AmazonAsn:` + fmt.Sprintf("%v", this.AmazonAsn) + `,`,
		`DirectConnectGatewayId:` + fmt.Sprintf("%v", this.DirectConnectGatewayId) + `,`,
		`DirectConnectGatewayName:` + fmt.Sprintf("%v", this.DirectConnectGatewayName) + `,`,
		`DirectConnectGatewayState:` + fmt.Sprintf("%v", this.DirectConnectGatewayState) + `,`,
		`StateChangeError:` + fmt.Sprintf("%v", this.StateChangeError) + `,`,
		`OwnerAccount:` + fmt.Sprintf("%v", this.OwnerAccount) + `,`,
		`AwsPath:` + fmt.Sprintf("%v", this.AwsPath) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureStatusType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureStatusType{`,
		`}`,
	}, "")
	return s
}
func (this *GCPCloudInterconnectAttachmentStatusType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForBgpPeers := "[]*BGPPeerType{"
	for _, f := range this.BgpPeers {
		repeatedStringForBgpPeers += strings.Replace(f.String(), "BGPPeerType", "BGPPeerType", 1) + ","
	}
	repeatedStringForBgpPeers += "}"
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&GCPCloudInterconnectAttachmentStatusType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`AdminEnabled:` + fmt.Sprintf("%v", this.AdminEnabled) + `,`,
		`OperationalStatus:` + fmt.Sprintf("%v", this.OperationalStatus) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Router:` + fmt.Sprintf("%v", this.Router) + `,`,
		`Interconnect:` + fmt.Sprintf("%v", this.Interconnect) + `,`,
		`Bandwidth:` + fmt.Sprintf("%v", this.Bandwidth) + `,`,
		`Encryption:` + fmt.Sprintf("%v", this.Encryption) + `,`,
		`Vlan:` + fmt.Sprintf("%v", this.Vlan) + `,`,
		`Mtu:` + fmt.Sprintf("%v", this.Mtu) + `,`,
		`StackType:` + fmt.Sprintf("%v", this.StackType) + `,`,
		`CloudRouterIp:` + fmt.Sprintf("%v", this.CloudRouterIp) + `,`,
		`CustomerRouterIp:` + fmt.Sprintf("%v", this.CustomerRouterIp) + `,`,
		`AvailabilityDomain:` + fmt.Sprintf("%v", this.AvailabilityDomain) + `,`,
		`PartnerMetadata:` + strings.Replace(fmt.Sprintf("%v", this.PartnerMetadata), "GCPPartnerMetadata", "GCPPartnerMetadata", 1) + `,`,
		`PartnerAsn:` + fmt.Sprintf("%v", this.PartnerAsn) + `,`,
		`AttachmentState:` + fmt.Sprintf("%v", this.AttachmentState) + `,`,
		`DataplaneVersion:` + fmt.Sprintf("%v", this.DataplaneVersion) + `,`,
		`BgpPeers:` + repeatedStringForBgpPeers + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`GcpPath:` + fmt.Sprintf("%v", this.GcpPath) + `,`,
		`VpcNetwork:` + fmt.Sprintf("%v", this.VpcNetwork) + `,`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`Project:` + fmt.Sprintf("%v", this.Project) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPStatusType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConnectionStatus := "[]*GCPCloudInterconnectAttachmentStatusType{"
	for _, f := range this.ConnectionStatus {
		repeatedStringForConnectionStatus += strings.Replace(f.String(), "GCPCloudInterconnectAttachmentStatusType", "GCPCloudInterconnectAttachmentStatusType", 1) + ","
	}
	repeatedStringForConnectionStatus += "}"
	s := strings.Join([]string{`&GCPStatusType{`,
		`ConnectionStatus:` + repeatedStringForConnectionStatus + `,`,
		`CloudLinkState:` + fmt.Sprintf("%v", this.CloudLinkState) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringObject(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Object) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowObject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Object: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Object: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &schema.ObjectMetaType{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SystemMetadata == nil {
				m.SystemMetadata = &schema.SystemObjectMetaType{}
			}
			if err := m.SystemMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &SpecType{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipObject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowObject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GcSpec == nil {
				m.GcSpec = &GlobalSpecType{}
			}
			if err := m.GcSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipObject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowObject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &schema.StatusMetaType{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectRefs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectRefs = append(m.ObjectRefs, &schema.ObjectRefType{})
			if err := m.ObjectRefs[len(m.ObjectRefs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &schema.ConditionType{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSStatusType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CloudLinkStatus = &StatusObject_AwsStatus{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureStatusType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CloudLinkStatus = &StatusObject_AzureStatus{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcpStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GCPStatusType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CloudLinkStatus = &StatusObject_GcpStatus{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipObject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowObject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectionStatus = append(m.ConnectionStatus, &DirectConnectConnectionStatusType{})
			if err := m.ConnectionStatus[len(m.ConnectionStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuggestedAction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SuggestedAction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudLinkState", wireType)
			}
			m.CloudLinkState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CloudLinkState |= schema.CloudLinkState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentStatus", wireType)
			}
			m.DeploymentStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeploymentStatus |= CloudLinkDeploymentStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipObject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DirectConnectConnectionStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowObject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectConnectConnectionStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectConnectConnectionStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bandwidth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bandwidth = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectionState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasLogicalRedundancy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HasLogicalRedundancy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartnerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartnerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowObject
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowObject
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthObject
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthObject
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowObject
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthObject
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthObject
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipObject(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthObject
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vlan", wireType)
			}
			m.Vlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vlan |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JumboFrameCapable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.JumboFrameCapable = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerAccount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VifStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VifStatus == nil {
				m.VifStatus = &VirtualInterfaceStatusType{}
			}
			if err := m.VifStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GatewayStatus == nil {
				m.GatewayStatus = &DirectConnectGatewayStatusType{}
			}
			if err := m.GatewayStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipObject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualInterfaceStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowObject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualInterfaceStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualInterfaceStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressFamily", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressFamily = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmazonAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmazonAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmazonAsn", wireType)
			}
			m.AmazonAsn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AmazonAsn |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpAsn", wireType)
			}
			m.BgpAsn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BgpAsn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectConnectGatewayId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirectConnectGatewayId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectConnectGatewayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirectConnectGatewayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualInterfaceState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualInterfaceState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowObject
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowObject
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthObject
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthObject
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowObject
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthObject
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthObject
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipObject(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthObject
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vlan", wireType)
			}
			m.Vlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vlan |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualInterfaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualInterfaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualInterfaceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualInterfaceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualInterfaceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualInterfaceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpPeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpPeers = append(m.BgpPeers, &BGPPeerType{})
			if err := m.BgpPeers[len(m.BgpPeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JumboFrameCapable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.JumboFrameCapable = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerAccount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectConnectAttachmentState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirectConnectAttachmentState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachmentStateChangeError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttachmentStateChangeError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipObject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowObject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressFamily", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressFamily = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asn", wireType)
			}
			m.Asn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Asn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpPeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpPeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpPeerState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpPeerState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudProviderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudProviderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipObject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DirectConnectGatewayStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowObject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectConnectGatewayStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectConnectGatewayStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmazonAsn", wireType)
			}
			m.AmazonAsn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AmazonAsn |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectConnectGatewayId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirectConnectGatewayId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectConnectGatewayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirectConnectGatewayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectConnectGatewayState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirectConnectGatewayState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateChangeError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateChangeError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerAccount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipObject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowObject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipObject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPCloudInterconnectAttachmentStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowObject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPCloudInterconnectAttachmentStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPCloudInterconnectAttachmentStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdminEnabled = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationalStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperationalStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Router", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Router = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interconnect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interconnect = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bandwidth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bandwidth = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encryption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vlan", wireType)
			}
			m.Vlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vlan |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StackType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StackType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudRouterIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudRouterIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerRouterIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerRouterIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailabilityDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailabilityDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartnerMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PartnerMetadata == nil {
				m.PartnerMetadata = &GCPPartnerMetadata{}
			}
			if err := m.PartnerMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartnerAsn", wireType)
			}
			m.PartnerAsn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartnerAsn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachmentState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttachmentState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataplaneVersion", wireType)
			}
			m.DataplaneVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataplaneVersion |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpPeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpPeers = append(m.BgpPeers, &BGPPeerType{})
			if err := m.BgpPeers[len(m.BgpPeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowObject
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowObject
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthObject
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthObject
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowObject
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthObject
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthObject
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipObject(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthObject
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcpPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GcpPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcNetwork", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcNetwork = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Project", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Project = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipObject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowObject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthObject
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthObject
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectionStatus = append(m.ConnectionStatus, &GCPCloudInterconnectAttachmentStatusType{})
			if err := m.ConnectionStatus[len(m.ConnectionStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudLinkState", wireType)
			}
			m.CloudLinkState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowObject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CloudLinkState |= schema.CloudLinkState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipObject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthObject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipObject(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowObject
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowObject
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowObject
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthObject
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupObject
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthObject
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthObject        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowObject          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupObject = fmt.Errorf("proto: unexpected end of group")
)
