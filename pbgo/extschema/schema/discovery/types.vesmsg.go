//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//
package discovery

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *ConsulAccessInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ConsulAccessInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ConsulAccessInfo) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetConnectionInfo().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ConsulAccessInfo.connection_info")
	}

	if err := m.GetHttpBasicAuthInfo().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ConsulAccessInfo.http_basic_auth_info")
	}

	return nil
}

func (m *ConsulAccessInfo) DeepCopy() *ConsulAccessInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ConsulAccessInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ConsulAccessInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ConsulAccessInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ConsulAccessInfoValidator().Validate(ctx, m, opts...)
}

type ValidateConsulAccessInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateConsulAccessInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ConsulAccessInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ConsulAccessInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["connection_info"]; exists {

		vOpts := append(opts, db.WithValidateField("connection_info"))
		if err := fv(ctx, m.GetConnectionInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["http_basic_auth_info"]; exists {

		vOpts := append(opts, db.WithValidateField("http_basic_auth_info"))
		if err := fv(ctx, m.GetHttpBasicAuthInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["scheme"]; exists {

		vOpts := append(opts, db.WithValidateField("scheme"))
		if err := fv(ctx, m.GetScheme(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultConsulAccessInfoValidator = func() *ValidateConsulAccessInfo {
	v := &ValidateConsulAccessInfo{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["connection_info"] = RestConfigTypeValidator().Validate

	v.FldValidators["http_basic_auth_info"] = ConsulHttpBasicAuthInfoTypeValidator().Validate

	return v
}()

func ConsulAccessInfoValidator() db.Validator {
	return DefaultConsulAccessInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *ConsulDiscoveryType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ConsulDiscoveryType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ConsulDiscoveryType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetAccessInfo().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ConsulDiscoveryType.access_info")
	}

	return nil
}

func (m *ConsulDiscoveryType) DeepCopy() *ConsulDiscoveryType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ConsulDiscoveryType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ConsulDiscoveryType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ConsulDiscoveryType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ConsulDiscoveryTypeValidator().Validate(ctx, m, opts...)
}

type ValidateConsulDiscoveryType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateConsulDiscoveryType) AccessInfoValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for access_info")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateConsulDiscoveryType) PublishInfoValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for publish_info")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ConsulVipDiscoveryInfoTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateConsulDiscoveryType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ConsulDiscoveryType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ConsulDiscoveryType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["access_info"]; exists {

		vOpts := append(opts, db.WithValidateField("access_info"))
		if err := fv(ctx, m.GetAccessInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["publish_info"]; exists {

		vOpts := append(opts, db.WithValidateField("publish_info"))
		if err := fv(ctx, m.GetPublishInfo(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultConsulDiscoveryTypeValidator = func() *ValidateConsulDiscoveryType {
	v := &ValidateConsulDiscoveryType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAccessInfo := v.AccessInfoValidationRuleHandler
	rulesAccessInfo := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAccessInfo(rulesAccessInfo)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ConsulDiscoveryType.access_info: %s", err)
		panic(errMsg)
	}
	v.FldValidators["access_info"] = vFn

	vrhPublishInfo := v.PublishInfoValidationRuleHandler
	rulesPublishInfo := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPublishInfo(rulesPublishInfo)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ConsulDiscoveryType.publish_info: %s", err)
		panic(errMsg)
	}
	v.FldValidators["publish_info"] = vFn

	return v
}()

func ConsulDiscoveryTypeValidator() db.Validator {
	return DefaultConsulDiscoveryTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ConsulHttpBasicAuthInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ConsulHttpBasicAuthInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ConsulHttpBasicAuthInfoType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetPasswdUrl().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ConsulHttpBasicAuthInfoType.passwd_url")
	}

	return nil
}

func (m *ConsulHttpBasicAuthInfoType) DeepCopy() *ConsulHttpBasicAuthInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ConsulHttpBasicAuthInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ConsulHttpBasicAuthInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ConsulHttpBasicAuthInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ConsulHttpBasicAuthInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateConsulHttpBasicAuthInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateConsulHttpBasicAuthInfoType) UserNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for user_name")
	}

	return validatorFn, nil
}

func (v *ValidateConsulHttpBasicAuthInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ConsulHttpBasicAuthInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ConsulHttpBasicAuthInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["passwd_url"]; exists {

		vOpts := append(opts, db.WithValidateField("passwd_url"))
		if err := fv(ctx, m.GetPasswdUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user_name"]; exists {

		vOpts := append(opts, db.WithValidateField("user_name"))
		if err := fv(ctx, m.GetUserName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultConsulHttpBasicAuthInfoTypeValidator = func() *ValidateConsulHttpBasicAuthInfoType {
	v := &ValidateConsulHttpBasicAuthInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhUserName := v.UserNameValidationRuleHandler
	rulesUserName := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhUserName(rulesUserName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ConsulHttpBasicAuthInfoType.user_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["user_name"] = vFn

	v.FldValidators["passwd_url"] = ves_io_schema.SecretTypeValidator().Validate

	return v
}()

func ConsulHttpBasicAuthInfoTypeValidator() db.Validator {
	return DefaultConsulHttpBasicAuthInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ConsulVipDiscoveryInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ConsulVipDiscoveryInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ConsulVipDiscoveryInfoType) DeepCopy() *ConsulVipDiscoveryInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ConsulVipDiscoveryInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ConsulVipDiscoveryInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ConsulVipDiscoveryInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ConsulVipDiscoveryInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateConsulVipDiscoveryInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateConsulVipDiscoveryInfoType) PublishChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for publish_choice")
	}
	return validatorFn, nil
}

func (v *ValidateConsulVipDiscoveryInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ConsulVipDiscoveryInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ConsulVipDiscoveryInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["publish_choice"]; exists {
		val := m.GetPublishChoice()
		vOpts := append(opts,
			db.WithValidateField("publish_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPublishChoice().(type) {
	case *ConsulVipDiscoveryInfoType_Disable:
		if fv, exists := v.FldValidators["publish_choice.disable"]; exists {
			val := m.GetPublishChoice().(*ConsulVipDiscoveryInfoType_Disable).Disable
			vOpts := append(opts,
				db.WithValidateField("publish_choice"),
				db.WithValidateField("disable"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ConsulVipDiscoveryInfoType_Publish:
		if fv, exists := v.FldValidators["publish_choice.publish"]; exists {
			val := m.GetPublishChoice().(*ConsulVipDiscoveryInfoType_Publish).Publish
			vOpts := append(opts,
				db.WithValidateField("publish_choice"),
				db.WithValidateField("publish"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultConsulVipDiscoveryInfoTypeValidator = func() *ValidateConsulVipDiscoveryInfoType {
	v := &ValidateConsulVipDiscoveryInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPublishChoice := v.PublishChoiceValidationRuleHandler
	rulesPublishChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPublishChoice(rulesPublishChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ConsulVipDiscoveryInfoType.publish_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["publish_choice"] = vFn

	return v
}()

func ConsulVipDiscoveryInfoTypeValidator() db.Validator {
	return DefaultConsulVipDiscoveryInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *CreateSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetDiscoveryK8S().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.discovery_k8s")
	}

	if err := m.GetDiscoveryConsul().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.discovery_consul")
	}

	return nil
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *CreateSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetWhereDRefInfo()

}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetWhereDRefInfo() ([]db.DRefInfo, error) {
	if m.GetWhere() == nil {
		return nil, nil
	}

	drInfos, err := m.GetWhere().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetWhere().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "where." + dri.DRField
	}
	return drInfos, err

}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) DiscoveryChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for discovery_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) WhereValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for where")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["discovery_choice"]; exists {
		val := m.GetDiscoveryChoice()
		vOpts := append(opts,
			db.WithValidateField("discovery_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDiscoveryChoice().(type) {
	case *CreateSpecType_DiscoveryK8S:
		if fv, exists := v.FldValidators["discovery_choice.discovery_k8s"]; exists {
			val := m.GetDiscoveryChoice().(*CreateSpecType_DiscoveryK8S).DiscoveryK8S
			vOpts := append(opts,
				db.WithValidateField("discovery_choice"),
				db.WithValidateField("discovery_k8s"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_DiscoveryConsul:
		if fv, exists := v.FldValidators["discovery_choice.discovery_consul"]; exists {
			val := m.GetDiscoveryChoice().(*CreateSpecType_DiscoveryConsul).DiscoveryConsul
			vOpts := append(opts,
				db.WithValidateField("discovery_choice"),
				db.WithValidateField("discovery_consul"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["where"]; exists {

		vOpts := append(opts, db.WithValidateField("where"))
		if err := fv(ctx, m.GetWhere(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDiscoveryChoice := v.DiscoveryChoiceValidationRuleHandler
	rulesDiscoveryChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDiscoveryChoice(rulesDiscoveryChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.discovery_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["discovery_choice"] = vFn

	vrhWhere := v.WhereValidationRuleHandler
	rulesWhere := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhWhere(rulesWhere)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.where: %s", err)
		panic(errMsg)
	}
	v.FldValidators["where"] = vFn

	v.FldValidators["discovery_choice.discovery_k8s"] = K8SDiscoveryTypeValidator().Validate
	v.FldValidators["discovery_choice.discovery_consul"] = ConsulDiscoveryTypeValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DiscoveredServiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DiscoveredServiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DiscoveredServiceType) DeepCopy() *DiscoveredServiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DiscoveredServiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DiscoveredServiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DiscoveredServiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DiscoveredServiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateDiscoveredServiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDiscoveredServiceType) ServiceNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for service_name")
	}

	return validatorFn, nil
}

func (v *ValidateDiscoveredServiceType) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateDiscoveredServiceType) ServiceTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for service_type")
	}

	return validatorFn, nil
}

func (v *ValidateDiscoveredServiceType) ClusterIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cluster_ip")
	}

	return validatorFn, nil
}

func (v *ValidateDiscoveredServiceType) LabelsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for labels")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for labels")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for labels")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map labels")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items labels")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDiscoveredServiceType) PortMapValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapUint32KeyRules(rules)
	itemKeyFn, err := db.NewUint32ValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for port_map")
	}
	itemValRules := db.GetMapUint32ValueRules(rules)
	itemValFn, err := db.NewUint32ValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for port_map")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[uint32]uint32, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for port_map")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[uint32]uint32)
		if !ok {
			return fmt.Errorf("Map validation expected map[ uint32 ]uint32, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map port_map")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items port_map")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDiscoveredServiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DiscoveredServiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DiscoveredServiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cluster_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("cluster_ip"))
		if err := fv(ctx, m.GetClusterIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["labels"]; exists {
		vOpts := append(opts, db.WithValidateField("labels"))
		if err := fv(ctx, m.GetLabels(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["pods"]; exists {

		vOpts := append(opts, db.WithValidateField("pods"))
		for idx, item := range m.GetPods() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["port_map"]; exists {
		vOpts := append(opts, db.WithValidateField("port_map"))
		if err := fv(ctx, m.GetPortMap(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ports"]; exists {

		vOpts := append(opts, db.WithValidateField("ports"))
		for idx, item := range m.GetPorts() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["service_name"]; exists {

		vOpts := append(opts, db.WithValidateField("service_name"))
		if err := fv(ctx, m.GetServiceName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_type"]; exists {

		vOpts := append(opts, db.WithValidateField("service_type"))
		if err := fv(ctx, m.GetServiceType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDiscoveredServiceTypeValidator = func() *ValidateDiscoveredServiceType {
	v := &ValidateDiscoveredServiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhServiceName := v.ServiceNameValidationRuleHandler
	rulesServiceName := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhServiceName(rulesServiceName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DiscoveredServiceType.service_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_name"] = vFn

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DiscoveredServiceType.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhServiceType := v.ServiceTypeValidationRuleHandler
	rulesServiceType := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhServiceType(rulesServiceType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DiscoveredServiceType.service_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_type"] = vFn

	vrhClusterIp := v.ClusterIpValidationRuleHandler
	rulesClusterIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhClusterIp(rulesClusterIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DiscoveredServiceType.cluster_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cluster_ip"] = vFn

	vrhLabels := v.LabelsValidationRuleHandler
	rulesLabels := map[string]string{
		"ves.io.schema.rules.map.max_pairs":                     "16",
		"ves.io.schema.rules.map.values.string.k8s_label_value": "true",
	}
	vFn, err = vrhLabels(rulesLabels)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DiscoveredServiceType.labels: %s", err)
		panic(errMsg)
	}
	v.FldValidators["labels"] = vFn

	vrhPortMap := v.PortMapValidationRuleHandler
	rulesPortMap := map[string]string{
		"ves.io.schema.rules.map.keys.uint32.gte":   "1",
		"ves.io.schema.rules.map.keys.uint32.lte":   "65535",
		"ves.io.schema.rules.map.values.uint32.gte": "1",
		"ves.io.schema.rules.map.values.uint32.lte": "65535",
	}
	vFn, err = vrhPortMap(rulesPortMap)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DiscoveredServiceType.port_map: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port_map"] = vFn

	v.FldValidators["ports"] = PortInfoTypeValidator().Validate

	return v
}()

func DiscoveredServiceTypeValidator() db.Validator {
	return DefaultDiscoveredServiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GetSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetDiscoveryK8S().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.discovery_k8s")
	}

	if err := m.GetDiscoveryConsul().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.discovery_consul")
	}

	return nil
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GetSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetWhereDRefInfo()

}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetWhereDRefInfo() ([]db.DRefInfo, error) {
	if m.GetWhere() == nil {
		return nil, nil
	}

	drInfos, err := m.GetWhere().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetWhere().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "where." + dri.DRField
	}
	return drInfos, err

}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) DiscoveryChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for discovery_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) WhereValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for where")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) TypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.DiscoveryType)
		return int32(i)
	}
	// ves_io_schema.DiscoveryType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.DiscoveryType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for type")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["discovery_choice"]; exists {
		val := m.GetDiscoveryChoice()
		vOpts := append(opts,
			db.WithValidateField("discovery_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDiscoveryChoice().(type) {
	case *GetSpecType_DiscoveryK8S:
		if fv, exists := v.FldValidators["discovery_choice.discovery_k8s"]; exists {
			val := m.GetDiscoveryChoice().(*GetSpecType_DiscoveryK8S).DiscoveryK8S
			vOpts := append(opts,
				db.WithValidateField("discovery_choice"),
				db.WithValidateField("discovery_k8s"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_DiscoveryConsul:
		if fv, exists := v.FldValidators["discovery_choice.discovery_consul"]; exists {
			val := m.GetDiscoveryChoice().(*GetSpecType_DiscoveryConsul).DiscoveryConsul
			vOpts := append(opts,
				db.WithValidateField("discovery_choice"),
				db.WithValidateField("discovery_consul"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["publish_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("publish_vip"))
		if err := fv(ctx, m.GetPublishVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["where"]; exists {

		vOpts := append(opts, db.WithValidateField("where"))
		if err := fv(ctx, m.GetWhere(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDiscoveryChoice := v.DiscoveryChoiceValidationRuleHandler
	rulesDiscoveryChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDiscoveryChoice(rulesDiscoveryChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.discovery_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["discovery_choice"] = vFn

	vrhWhere := v.WhereValidationRuleHandler
	rulesWhere := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhWhere(rulesWhere)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.where: %s", err)
		panic(errMsg)
	}
	v.FldValidators["where"] = vFn

	vrhType := v.TypeValidationRuleHandler
	rulesType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhType(rulesType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["type"] = vFn

	v.FldValidators["discovery_choice.discovery_k8s"] = K8SDiscoveryTypeValidator().Validate
	v.FldValidators["discovery_choice.discovery_consul"] = ConsulDiscoveryTypeValidator().Validate

	v.FldValidators["publish_vip"] = VipDiscoveryInfoTypeValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GlobalSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetK8S().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.k8s")
	}

	if err := m.GetConsul().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.consul")
	}

	if err := m.GetDiscoveryK8S().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.discovery_k8s")
	}

	if err := m.GetDiscoveryConsul().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.discovery_consul")
	}

	return nil
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetWhereDRefInfo()

}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetWhereDRefInfo() ([]db.DRefInfo, error) {
	if m.GetWhere() == nil {
		return nil, nil
	}

	drInfos, err := m.GetWhere().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetWhere().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "where." + dri.DRField
	}
	return drInfos, err

}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) DiscoveryChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for discovery_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) WhereValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for where")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) TypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.DiscoveryType)
		return int32(i)
	}
	// ves_io_schema.DiscoveryType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.DiscoveryType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for type")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetAccessInfo().(type) {
	case *GlobalSpecType_K8S:
		if fv, exists := v.FldValidators["access_info.k8s"]; exists {
			val := m.GetAccessInfo().(*GlobalSpecType_K8S).K8S
			vOpts := append(opts,
				db.WithValidateField("access_info"),
				db.WithValidateField("k8s"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Consul:
		if fv, exists := v.FldValidators["access_info.consul"]; exists {
			val := m.GetAccessInfo().(*GlobalSpecType_Consul).Consul
			vOpts := append(opts,
				db.WithValidateField("access_info"),
				db.WithValidateField("consul"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["discovery_choice"]; exists {
		val := m.GetDiscoveryChoice()
		vOpts := append(opts,
			db.WithValidateField("discovery_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDiscoveryChoice().(type) {
	case *GlobalSpecType_DiscoveryK8S:
		if fv, exists := v.FldValidators["discovery_choice.discovery_k8s"]; exists {
			val := m.GetDiscoveryChoice().(*GlobalSpecType_DiscoveryK8S).DiscoveryK8S
			vOpts := append(opts,
				db.WithValidateField("discovery_choice"),
				db.WithValidateField("discovery_k8s"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_DiscoveryConsul:
		if fv, exists := v.FldValidators["discovery_choice.discovery_consul"]; exists {
			val := m.GetDiscoveryChoice().(*GlobalSpecType_DiscoveryConsul).DiscoveryConsul
			vOpts := append(opts,
				db.WithValidateField("discovery_choice"),
				db.WithValidateField("discovery_consul"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["publish_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("publish_vip"))
		if err := fv(ctx, m.GetPublishVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["where"]; exists {

		vOpts := append(opts, db.WithValidateField("where"))
		if err := fv(ctx, m.GetWhere(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDiscoveryChoice := v.DiscoveryChoiceValidationRuleHandler
	rulesDiscoveryChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDiscoveryChoice(rulesDiscoveryChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.discovery_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["discovery_choice"] = vFn

	vrhWhere := v.WhereValidationRuleHandler
	rulesWhere := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhWhere(rulesWhere)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.where: %s", err)
		panic(errMsg)
	}
	v.FldValidators["where"] = vFn

	vrhType := v.TypeValidationRuleHandler
	rulesType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhType(rulesType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["type"] = vFn

	v.FldValidators["access_info.k8s"] = K8SAccessInfoValidator().Validate
	v.FldValidators["access_info.consul"] = ConsulAccessInfoValidator().Validate

	v.FldValidators["discovery_choice.discovery_k8s"] = K8SDiscoveryTypeValidator().Validate
	v.FldValidators["discovery_choice.discovery_consul"] = ConsulDiscoveryTypeValidator().Validate

	v.FldValidators["publish_vip"] = VipDiscoveryInfoTypeValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *K8SAccessInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *K8SAccessInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *K8SAccessInfo) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetKubeconfigUrl().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting K8SAccessInfo.kubeconfig_url")
	}

	if err := m.GetConnectionInfo().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting K8SAccessInfo.connection_info")
	}

	return nil
}

func (m *K8SAccessInfo) DeepCopy() *K8SAccessInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &K8SAccessInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *K8SAccessInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *K8SAccessInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return K8SAccessInfoValidator().Validate(ctx, m, opts...)
}

type ValidateK8SAccessInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateK8SAccessInfo) ConfigTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for config_type")
	}
	return validatorFn, nil
}

func (v *ValidateK8SAccessInfo) K8SPodNetworkChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for k8s_pod_network_choice")
	}
	return validatorFn, nil
}

func (v *ValidateK8SAccessInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*K8SAccessInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *K8SAccessInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["config_type"]; exists {
		val := m.GetConfigType()
		vOpts := append(opts,
			db.WithValidateField("config_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetConfigType().(type) {
	case *K8SAccessInfo_KubeconfigUrl:
		if fv, exists := v.FldValidators["config_type.kubeconfig_url"]; exists {
			val := m.GetConfigType().(*K8SAccessInfo_KubeconfigUrl).KubeconfigUrl
			vOpts := append(opts,
				db.WithValidateField("config_type"),
				db.WithValidateField("kubeconfig_url"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *K8SAccessInfo_ConnectionInfo:
		if fv, exists := v.FldValidators["config_type.connection_info"]; exists {
			val := m.GetConfigType().(*K8SAccessInfo_ConnectionInfo).ConnectionInfo
			vOpts := append(opts,
				db.WithValidateField("config_type"),
				db.WithValidateField("connection_info"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *K8SAccessInfo_InCluster:
		if fv, exists := v.FldValidators["config_type.in_cluster"]; exists {
			val := m.GetConfigType().(*K8SAccessInfo_InCluster).InCluster
			vOpts := append(opts,
				db.WithValidateField("config_type"),
				db.WithValidateField("in_cluster"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["k8s_pod_network_choice"]; exists {
		val := m.GetK8SPodNetworkChoice()
		vOpts := append(opts,
			db.WithValidateField("k8s_pod_network_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetK8SPodNetworkChoice().(type) {
	case *K8SAccessInfo_Isolated:
		if fv, exists := v.FldValidators["k8s_pod_network_choice.isolated"]; exists {
			val := m.GetK8SPodNetworkChoice().(*K8SAccessInfo_Isolated).Isolated
			vOpts := append(opts,
				db.WithValidateField("k8s_pod_network_choice"),
				db.WithValidateField("isolated"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *K8SAccessInfo_Reachable:
		if fv, exists := v.FldValidators["k8s_pod_network_choice.reachable"]; exists {
			val := m.GetK8SPodNetworkChoice().(*K8SAccessInfo_Reachable).Reachable
			vOpts := append(opts,
				db.WithValidateField("k8s_pod_network_choice"),
				db.WithValidateField("reachable"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultK8SAccessInfoValidator = func() *ValidateK8SAccessInfo {
	v := &ValidateK8SAccessInfo{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhConfigType := v.ConfigTypeValidationRuleHandler
	rulesConfigType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhConfigType(rulesConfigType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for K8SAccessInfo.config_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["config_type"] = vFn

	vrhK8SPodNetworkChoice := v.K8SPodNetworkChoiceValidationRuleHandler
	rulesK8SPodNetworkChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhK8SPodNetworkChoice(rulesK8SPodNetworkChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for K8SAccessInfo.k8s_pod_network_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["k8s_pod_network_choice"] = vFn

	v.FldValidators["config_type.kubeconfig_url"] = ves_io_schema.SecretTypeValidator().Validate
	v.FldValidators["config_type.connection_info"] = RestConfigTypeValidator().Validate

	return v
}()

func K8SAccessInfoValidator() db.Validator {
	return DefaultK8SAccessInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *K8SDelegationType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *K8SDelegationType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *K8SDelegationType) DeepCopy() *K8SDelegationType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &K8SDelegationType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *K8SDelegationType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *K8SDelegationType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return K8SDelegationTypeValidator().Validate(ctx, m, opts...)
}

type ValidateK8SDelegationType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateK8SDelegationType) SubdomainValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for subdomain")
	}

	return validatorFn, nil
}

func (v *ValidateK8SDelegationType) DnsModeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(K8SDNSMode)
		return int32(i)
	}
	// K8SDNSMode_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, K8SDNSMode_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dns_mode")
	}

	return validatorFn, nil
}

func (v *ValidateK8SDelegationType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*K8SDelegationType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *K8SDelegationType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["dns_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_mode"))
		if err := fv(ctx, m.GetDnsMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["subdomain"]; exists {

		vOpts := append(opts, db.WithValidateField("subdomain"))
		if err := fv(ctx, m.GetSubdomain(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultK8SDelegationTypeValidator = func() *ValidateK8SDelegationType {
	v := &ValidateK8SDelegationType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSubdomain := v.SubdomainValidationRuleHandler
	rulesSubdomain := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFn, err = vrhSubdomain(rulesSubdomain)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for K8SDelegationType.subdomain: %s", err)
		panic(errMsg)
	}
	v.FldValidators["subdomain"] = vFn

	vrhDnsMode := v.DnsModeValidationRuleHandler
	rulesDnsMode := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDnsMode(rulesDnsMode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for K8SDelegationType.dns_mode: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_mode"] = vFn

	return v
}()

func K8SDelegationTypeValidator() db.Validator {
	return DefaultK8SDelegationTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *K8SDiscoveryType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *K8SDiscoveryType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *K8SDiscoveryType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetAccessInfo().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting K8SDiscoveryType.access_info")
	}

	return nil
}

func (m *K8SDiscoveryType) DeepCopy() *K8SDiscoveryType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &K8SDiscoveryType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *K8SDiscoveryType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *K8SDiscoveryType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return K8SDiscoveryTypeValidator().Validate(ctx, m, opts...)
}

type ValidateK8SDiscoveryType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateK8SDiscoveryType) AccessInfoValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for access_info")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := K8SAccessInfoValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateK8SDiscoveryType) PublishInfoValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for publish_info")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := K8SVipDiscoveryInfoTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateK8SDiscoveryType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*K8SDiscoveryType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *K8SDiscoveryType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["access_info"]; exists {

		vOpts := append(opts, db.WithValidateField("access_info"))
		if err := fv(ctx, m.GetAccessInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["publish_info"]; exists {

		vOpts := append(opts, db.WithValidateField("publish_info"))
		if err := fv(ctx, m.GetPublishInfo(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultK8SDiscoveryTypeValidator = func() *ValidateK8SDiscoveryType {
	v := &ValidateK8SDiscoveryType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAccessInfo := v.AccessInfoValidationRuleHandler
	rulesAccessInfo := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAccessInfo(rulesAccessInfo)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for K8SDiscoveryType.access_info: %s", err)
		panic(errMsg)
	}
	v.FldValidators["access_info"] = vFn

	vrhPublishInfo := v.PublishInfoValidationRuleHandler
	rulesPublishInfo := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPublishInfo(rulesPublishInfo)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for K8SDiscoveryType.publish_info: %s", err)
		panic(errMsg)
	}
	v.FldValidators["publish_info"] = vFn

	return v
}()

func K8SDiscoveryTypeValidator() db.Validator {
	return DefaultK8SDiscoveryTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *K8SPublishType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *K8SPublishType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *K8SPublishType) DeepCopy() *K8SPublishType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &K8SPublishType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *K8SPublishType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *K8SPublishType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return K8SPublishTypeValidator().Validate(ctx, m, opts...)
}

type ValidateK8SPublishType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateK8SPublishType) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateK8SPublishType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*K8SPublishType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *K8SPublishType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultK8SPublishTypeValidator = func() *ValidateK8SPublishType {
	v := &ValidateK8SPublishType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for K8SPublishType.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	return v
}()

func K8SPublishTypeValidator() db.Validator {
	return DefaultK8SPublishTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *K8SVipDiscoveryInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *K8SVipDiscoveryInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *K8SVipDiscoveryInfoType) DeepCopy() *K8SVipDiscoveryInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &K8SVipDiscoveryInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *K8SVipDiscoveryInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *K8SVipDiscoveryInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return K8SVipDiscoveryInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateK8SVipDiscoveryInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateK8SVipDiscoveryInfoType) PublishChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for publish_choice")
	}
	return validatorFn, nil
}

func (v *ValidateK8SVipDiscoveryInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*K8SVipDiscoveryInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *K8SVipDiscoveryInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["publish_choice"]; exists {
		val := m.GetPublishChoice()
		vOpts := append(opts,
			db.WithValidateField("publish_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPublishChoice().(type) {
	case *K8SVipDiscoveryInfoType_Disable:
		if fv, exists := v.FldValidators["publish_choice.disable"]; exists {
			val := m.GetPublishChoice().(*K8SVipDiscoveryInfoType_Disable).Disable
			vOpts := append(opts,
				db.WithValidateField("publish_choice"),
				db.WithValidateField("disable"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *K8SVipDiscoveryInfoType_Publish:
		if fv, exists := v.FldValidators["publish_choice.publish"]; exists {
			val := m.GetPublishChoice().(*K8SVipDiscoveryInfoType_Publish).Publish
			vOpts := append(opts,
				db.WithValidateField("publish_choice"),
				db.WithValidateField("publish"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *K8SVipDiscoveryInfoType_PublishFqdns:
		if fv, exists := v.FldValidators["publish_choice.publish_fqdns"]; exists {
			val := m.GetPublishChoice().(*K8SVipDiscoveryInfoType_PublishFqdns).PublishFqdns
			vOpts := append(opts,
				db.WithValidateField("publish_choice"),
				db.WithValidateField("publish_fqdns"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *K8SVipDiscoveryInfoType_DnsDelegation:
		if fv, exists := v.FldValidators["publish_choice.dns_delegation"]; exists {
			val := m.GetPublishChoice().(*K8SVipDiscoveryInfoType_DnsDelegation).DnsDelegation
			vOpts := append(opts,
				db.WithValidateField("publish_choice"),
				db.WithValidateField("dns_delegation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultK8SVipDiscoveryInfoTypeValidator = func() *ValidateK8SVipDiscoveryInfoType {
	v := &ValidateK8SVipDiscoveryInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPublishChoice := v.PublishChoiceValidationRuleHandler
	rulesPublishChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPublishChoice(rulesPublishChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for K8SVipDiscoveryInfoType.publish_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["publish_choice"] = vFn

	v.FldValidators["publish_choice.publish"] = K8SPublishTypeValidator().Validate
	v.FldValidators["publish_choice.dns_delegation"] = K8SDelegationTypeValidator().Validate

	return v
}()

func K8SVipDiscoveryInfoTypeValidator() db.Validator {
	return DefaultK8SVipDiscoveryInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PodInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PodInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PodInfoType) DeepCopy() *PodInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PodInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PodInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PodInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PodInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePodInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePodInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PodInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PodInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ip"]; exists {

		vOpts := append(opts, db.WithValidateField("ip"))
		if err := fv(ctx, m.GetIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["pod_name"]; exists {

		vOpts := append(opts, db.WithValidateField("pod_name"))
		if err := fv(ctx, m.GetPodName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPodInfoTypeValidator = func() *ValidatePodInfoType {
	v := &ValidatePodInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func PodInfoTypeValidator() db.Validator {
	return DefaultPodInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PortInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PortInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PortInfoType) DeepCopy() *PortInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PortInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PortInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PortInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PortInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePortInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePortInfoType) PortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port")
	}

	return validatorFn, nil
}

func (v *ValidatePortInfoType) ProtocolValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for protocol")
	}

	return validatorFn, nil
}

func (v *ValidatePortInfoType) TargetPortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for target_port")
	}

	return validatorFn, nil
}

func (v *ValidatePortInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PortInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PortInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["port"]; exists {

		vOpts := append(opts, db.WithValidateField("port"))
		if err := fv(ctx, m.GetPort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["protocol"]; exists {

		vOpts := append(opts, db.WithValidateField("protocol"))
		if err := fv(ctx, m.GetProtocol(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["target_port"]; exists {

		vOpts := append(opts, db.WithValidateField("target_port"))
		if err := fv(ctx, m.GetTargetPort(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPortInfoTypeValidator = func() *ValidatePortInfoType {
	v := &ValidatePortInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPort := v.PortValidationRuleHandler
	rulesPort := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "1",
		"ves.io.schema.rules.uint32.lte":       "65535",
	}
	vFn, err = vrhPort(rulesPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PortInfoType.port: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port"] = vFn

	vrhProtocol := v.ProtocolValidationRuleHandler
	rulesProtocol := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhProtocol(rulesProtocol)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PortInfoType.protocol: %s", err)
		panic(errMsg)
	}
	v.FldValidators["protocol"] = vFn

	vrhTargetPort := v.TargetPortValidationRuleHandler
	rulesTargetPort := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "1",
		"ves.io.schema.rules.uint32.lte":       "65535",
	}
	vFn, err = vrhTargetPort(rulesTargetPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PortInfoType.target_port: %s", err)
		panic(errMsg)
	}
	v.FldValidators["target_port"] = vFn

	return v
}()

func PortInfoTypeValidator() db.Validator {
	return DefaultPortInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ReplaceSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetDiscoveryK8S().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.discovery_k8s")
	}

	if err := m.GetDiscoveryConsul().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.discovery_consul")
	}

	return nil
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *ReplaceSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetWhereDRefInfo()

}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetWhereDRefInfo() ([]db.DRefInfo, error) {
	if m.GetWhere() == nil {
		return nil, nil
	}

	drInfos, err := m.GetWhere().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetWhere().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "where." + dri.DRField
	}
	return drInfos, err

}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) DiscoveryChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for discovery_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) WhereValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for where")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["discovery_choice"]; exists {
		val := m.GetDiscoveryChoice()
		vOpts := append(opts,
			db.WithValidateField("discovery_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDiscoveryChoice().(type) {
	case *ReplaceSpecType_DiscoveryK8S:
		if fv, exists := v.FldValidators["discovery_choice.discovery_k8s"]; exists {
			val := m.GetDiscoveryChoice().(*ReplaceSpecType_DiscoveryK8S).DiscoveryK8S
			vOpts := append(opts,
				db.WithValidateField("discovery_choice"),
				db.WithValidateField("discovery_k8s"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_DiscoveryConsul:
		if fv, exists := v.FldValidators["discovery_choice.discovery_consul"]; exists {
			val := m.GetDiscoveryChoice().(*ReplaceSpecType_DiscoveryConsul).DiscoveryConsul
			vOpts := append(opts,
				db.WithValidateField("discovery_choice"),
				db.WithValidateField("discovery_consul"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["where"]; exists {

		vOpts := append(opts, db.WithValidateField("where"))
		if err := fv(ctx, m.GetWhere(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDiscoveryChoice := v.DiscoveryChoiceValidationRuleHandler
	rulesDiscoveryChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDiscoveryChoice(rulesDiscoveryChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.discovery_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["discovery_choice"] = vFn

	vrhWhere := v.WhereValidationRuleHandler
	rulesWhere := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhWhere(rulesWhere)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.where: %s", err)
		panic(errMsg)
	}
	v.FldValidators["where"] = vFn

	v.FldValidators["discovery_choice.discovery_k8s"] = K8SDiscoveryTypeValidator().Validate
	v.FldValidators["discovery_choice.discovery_consul"] = ConsulDiscoveryTypeValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *RestConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RestConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *RestConfigType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetTlsInfo().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting RestConfigType.tls_info")
	}

	return nil
}

func (m *RestConfigType) DeepCopy() *RestConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RestConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RestConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RestConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RestConfigTypeValidator().Validate(ctx, m, opts...)
}

type ValidateRestConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRestConfigType) ApiServerValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for api_server")
	}

	return validatorFn, nil
}

func (v *ValidateRestConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RestConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RestConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_server"]; exists {

		vOpts := append(opts, db.WithValidateField("api_server"))
		if err := fv(ctx, m.GetApiServer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tls_info"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_info"))
		if err := fv(ctx, m.GetTlsInfo(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRestConfigTypeValidator = func() *ValidateRestConfigType {
	v := &ValidateRestConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhApiServer := v.ApiServerValidationRuleHandler
	rulesApiServer := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.hostport":  "true",
		"ves.io.schema.rules.string.max_len":   "262",
	}
	vFn, err = vrhApiServer(rulesApiServer)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RestConfigType.api_server: %s", err)
		panic(errMsg)
	}
	v.FldValidators["api_server"] = vFn

	v.FldValidators["tls_info"] = TLSClientConfigTypeValidator().Validate

	return v
}()

func RestConfigTypeValidator() db.Validator {
	return DefaultRestConfigTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TLSClientConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TLSClientConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *TLSClientConfigType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetCertificateUrl().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting TLSClientConfigType.certificate_url")
	}

	if err := m.GetKeyUrl().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting TLSClientConfigType.key_url")
	}

	if err := m.GetCaCertificateUrl().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting TLSClientConfigType.ca_certificate_url")
	}

	return nil
}

func (m *TLSClientConfigType) DeepCopy() *TLSClientConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TLSClientConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TLSClientConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TLSClientConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TLSClientConfigTypeValidator().Validate(ctx, m, opts...)
}

type ValidateTLSClientConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTLSClientConfigType) ServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for server_name")
	}

	return validatorFn, nil
}

func (v *ValidateTLSClientConfigType) CertificateValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for certificate")
	}

	return validatorFn, nil
}

func (v *ValidateTLSClientConfigType) TrustedCaUrlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for trusted_ca_url")
	}

	return validatorFn, nil
}

func (v *ValidateTLSClientConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TLSClientConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TLSClientConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ca_certificate_url"]; exists {

		vOpts := append(opts, db.WithValidateField("ca_certificate_url"))
		if err := fv(ctx, m.GetCaCertificateUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["certificate"]; exists {

		vOpts := append(opts, db.WithValidateField("certificate"))
		if err := fv(ctx, m.GetCertificate(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["certificate_url"]; exists {

		vOpts := append(opts, db.WithValidateField("certificate_url"))
		if err := fv(ctx, m.GetCertificateUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["key_url"]; exists {

		vOpts := append(opts, db.WithValidateField("key_url"))
		if err := fv(ctx, m.GetKeyUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["server_name"]; exists {

		vOpts := append(opts, db.WithValidateField("server_name"))
		if err := fv(ctx, m.GetServerName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["trusted_ca_url"]; exists {

		vOpts := append(opts, db.WithValidateField("trusted_ca_url"))
		if err := fv(ctx, m.GetTrustedCaUrl(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTLSClientConfigTypeValidator = func() *ValidateTLSClientConfigType {
	v := &ValidateTLSClientConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhServerName := v.ServerNameValidationRuleHandler
	rulesServerName := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
		"ves.io.schema.rules.string.max_len":  "256",
	}
	vFn, err = vrhServerName(rulesServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TLSClientConfigType.server_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["server_name"] = vFn

	vrhCertificate := v.CertificateValidationRuleHandler
	rulesCertificate := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "131072",
		"ves.io.schema.rules.string.uri_ref":   "true",
	}
	vFn, err = vrhCertificate(rulesCertificate)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TLSClientConfigType.certificate: %s", err)
		panic(errMsg)
	}
	v.FldValidators["certificate"] = vFn

	vrhTrustedCaUrl := v.TrustedCaUrlValidationRuleHandler
	rulesTrustedCaUrl := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "131072",
		"ves.io.schema.rules.string.uri_ref":   "true",
	}
	vFn, err = vrhTrustedCaUrl(rulesTrustedCaUrl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TLSClientConfigType.trusted_ca_url: %s", err)
		panic(errMsg)
	}
	v.FldValidators["trusted_ca_url"] = vFn

	v.FldValidators["certificate_url"] = ves_io_schema.SecretTypeValidator().Validate

	v.FldValidators["key_url"] = ves_io_schema.SecretTypeValidator().Validate

	v.FldValidators["ca_certificate_url"] = ves_io_schema.SecretTypeValidator().Validate

	return v
}()

func TLSClientConfigTypeValidator() db.Validator {
	return DefaultTLSClientConfigTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VerStatusType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VerStatusType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VerStatusType) DeepCopy() *VerStatusType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VerStatusType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VerStatusType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VerStatusType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VerStatusTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVerStatusType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVerStatusType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VerStatusType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VerStatusType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["connected"]; exists {

		vOpts := append(opts, db.WithValidateField("connected"))
		if err := fv(ctx, m.GetConnected(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["services"]; exists {

		vOpts := append(opts, db.WithValidateField("services"))
		for idx, item := range m.GetServices() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVerStatusTypeValidator = func() *ValidateVerStatusType {
	v := &ValidateVerStatusType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["services"] = DiscoveredServiceTypeValidator().Validate

	return v
}()

func VerStatusTypeValidator() db.Validator {
	return DefaultVerStatusTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VipDiscoveryInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VipDiscoveryInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VipDiscoveryInfoType) DeepCopy() *VipDiscoveryInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VipDiscoveryInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VipDiscoveryInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VipDiscoveryInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VipDiscoveryInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVipDiscoveryInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVipDiscoveryInfoType) SubdomainValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for subdomain")
	}

	return validatorFn, nil
}

func (v *ValidateVipDiscoveryInfoType) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateVipDiscoveryInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VipDiscoveryInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VipDiscoveryInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["dns_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_mode"))
		if err := fv(ctx, m.GetDnsMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["publish_virtual_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("publish_virtual_ip"))
		if err := fv(ctx, m.GetPublishVirtualIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["subdomain"]; exists {

		vOpts := append(opts, db.WithValidateField("subdomain"))
		if err := fv(ctx, m.GetSubdomain(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVipDiscoveryInfoTypeValidator = func() *ValidateVipDiscoveryInfoType {
	v := &ValidateVipDiscoveryInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSubdomain := v.SubdomainValidationRuleHandler
	rulesSubdomain := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhSubdomain(rulesSubdomain)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VipDiscoveryInfoType.subdomain: %s", err)
		panic(errMsg)
	}
	v.FldValidators["subdomain"] = vFn

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VipDiscoveryInfoType.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	return v
}()

func VipDiscoveryInfoTypeValidator() db.Validator {
	return DefaultVipDiscoveryInfoTypeValidator
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetDiscoveryChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DiscoveryChoice.(type) {
	case nil:
		o.DiscoveryChoice = nil

	case *CreateSpecType_DiscoveryConsul:
		o.DiscoveryChoice = &GlobalSpecType_DiscoveryConsul{DiscoveryConsul: of.DiscoveryConsul}

	case *CreateSpecType_DiscoveryK8S:
		o.DiscoveryChoice = &GlobalSpecType_DiscoveryK8S{DiscoveryK8S: of.DiscoveryK8S}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetDiscoveryChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DiscoveryChoice.(type) {
	case nil:
		r.DiscoveryChoice = nil

	case *GlobalSpecType_DiscoveryConsul:
		r.DiscoveryChoice = &CreateSpecType_DiscoveryConsul{DiscoveryConsul: of.DiscoveryConsul}

	case *GlobalSpecType_DiscoveryK8S:
		r.DiscoveryChoice = &CreateSpecType_DiscoveryK8S{DiscoveryK8S: of.DiscoveryK8S}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.GetDiscoveryChoiceFromGlobalSpecType(f)
	m.Where = f.GetWhere()
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	m1.SetDiscoveryChoiceToGlobalSpecType(f)
	f.Where = m1.Where
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetDiscoveryChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DiscoveryChoice.(type) {
	case nil:
		o.DiscoveryChoice = nil

	case *GetSpecType_DiscoveryConsul:
		o.DiscoveryChoice = &GlobalSpecType_DiscoveryConsul{DiscoveryConsul: of.DiscoveryConsul}

	case *GetSpecType_DiscoveryK8S:
		o.DiscoveryChoice = &GlobalSpecType_DiscoveryK8S{DiscoveryK8S: of.DiscoveryK8S}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetDiscoveryChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DiscoveryChoice.(type) {
	case nil:
		r.DiscoveryChoice = nil

	case *GlobalSpecType_DiscoveryConsul:
		r.DiscoveryChoice = &GetSpecType_DiscoveryConsul{DiscoveryConsul: of.DiscoveryConsul}

	case *GlobalSpecType_DiscoveryK8S:
		r.DiscoveryChoice = &GetSpecType_DiscoveryK8S{DiscoveryK8S: of.DiscoveryK8S}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.GetDiscoveryChoiceFromGlobalSpecType(f)
	m.PublishVip = f.GetPublishVip()
	m.Type = f.GetType()
	m.Where = f.GetWhere()
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	m1.SetDiscoveryChoiceToGlobalSpecType(f)
	f.PublishVip = m1.PublishVip
	f.Type = m1.Type
	f.Where = m1.Where
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetDiscoveryChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DiscoveryChoice.(type) {
	case nil:
		o.DiscoveryChoice = nil

	case *ReplaceSpecType_DiscoveryConsul:
		o.DiscoveryChoice = &GlobalSpecType_DiscoveryConsul{DiscoveryConsul: of.DiscoveryConsul}

	case *ReplaceSpecType_DiscoveryK8S:
		o.DiscoveryChoice = &GlobalSpecType_DiscoveryK8S{DiscoveryK8S: of.DiscoveryK8S}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetDiscoveryChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DiscoveryChoice.(type) {
	case nil:
		r.DiscoveryChoice = nil

	case *GlobalSpecType_DiscoveryConsul:
		r.DiscoveryChoice = &ReplaceSpecType_DiscoveryConsul{DiscoveryConsul: of.DiscoveryConsul}

	case *GlobalSpecType_DiscoveryK8S:
		r.DiscoveryChoice = &ReplaceSpecType_DiscoveryK8S{DiscoveryK8S: of.DiscoveryK8S}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.GetDiscoveryChoiceFromGlobalSpecType(f)
	m.Where = f.GetWhere()
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	m1.SetDiscoveryChoiceToGlobalSpecType(f)
	f.Where = m1.Where
}
