// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package discovery

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *CbipAdminCredentials) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CbipAdminCredentials) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *CbipAdminCredentials) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetPassword().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CbipAdminCredentials.password")
	}

	return nil
}

func (m *CbipAdminCredentials) DeepCopy() *CbipAdminCredentials {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CbipAdminCredentials{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CbipAdminCredentials) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CbipAdminCredentials) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CbipAdminCredentialsValidator().Validate(ctx, m, opts...)
}

type ValidateCbipAdminCredentials struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCbipAdminCredentials) UsernameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for username")
	}

	return validatorFn, nil
}

func (v *ValidateCbipAdminCredentials) PasswordValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for password")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.SecretTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCbipAdminCredentials) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CbipAdminCredentials)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CbipAdminCredentials got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["password"]; exists {

		vOpts := append(opts, db.WithValidateField("password"))
		if err := fv(ctx, m.GetPassword(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["username"]; exists {

		vOpts := append(opts, db.WithValidateField("username"))
		if err := fv(ctx, m.GetUsername(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCbipAdminCredentialsValidator = func() *ValidateCbipAdminCredentials {
	v := &ValidateCbipAdminCredentials{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhUsername := v.UsernameValidationRuleHandler
	rulesUsername := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhUsername(rulesUsername)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CbipAdminCredentials.username: %s", err)
		panic(errMsg)
	}
	v.FldValidators["username"] = vFn

	vrhPassword := v.PasswordValidationRuleHandler
	rulesPassword := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPassword(rulesPassword)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CbipAdminCredentials.password: %s", err)
		panic(errMsg)
	}
	v.FldValidators["password"] = vFn

	return v
}()

func CbipAdminCredentialsValidator() db.Validator {
	return DefaultCbipAdminCredentialsValidator
}

// augmented methods on protoc/std generated struct

func (m *CbipCertificateAuthority) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CbipCertificateAuthority) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CbipCertificateAuthority) DeepCopy() *CbipCertificateAuthority {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CbipCertificateAuthority{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CbipCertificateAuthority) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CbipCertificateAuthority) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CbipCertificateAuthorityValidator().Validate(ctx, m, opts...)
}

func (m *CbipCertificateAuthority) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetServerValidationChoiceDRefInfo()

}

func (m *CbipCertificateAuthority) GetServerValidationChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetServerValidationChoice().(type) {
	case *CbipCertificateAuthority_TrustedCa:

		vref := m.GetTrustedCa()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("trusted_ca_list.Object")
		dri := db.DRefInfo{
			RefdType:   "trusted_ca_list.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "trusted_ca",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	case *CbipCertificateAuthority_SkipServerVerification:

		return nil, nil

	default:
		return nil, nil
	}
}

// GetServerValidationChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CbipCertificateAuthority) GetServerValidationChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetServerValidationChoice().(type) {
	case *CbipCertificateAuthority_TrustedCa:
		refdType, err := d.TypeForEntryKind("", "", "trusted_ca_list.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: trusted_ca_list")
		}

		vref := m.GetTrustedCa()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "trusted_ca_list.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	case *CbipCertificateAuthority_SkipServerVerification:

	}

	return entries, nil
}

type ValidateCbipCertificateAuthority struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCbipCertificateAuthority) ServerValidationChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for server_validation_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCbipCertificateAuthority) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CbipCertificateAuthority)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CbipCertificateAuthority got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["server_validation_choice"]; exists {
		val := m.GetServerValidationChoice()
		vOpts := append(opts,
			db.WithValidateField("server_validation_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetServerValidationChoice().(type) {
	case *CbipCertificateAuthority_TrustedCa:
		if fv, exists := v.FldValidators["server_validation_choice.trusted_ca"]; exists {
			val := m.GetServerValidationChoice().(*CbipCertificateAuthority_TrustedCa).TrustedCa
			vOpts := append(opts,
				db.WithValidateField("server_validation_choice"),
				db.WithValidateField("trusted_ca"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CbipCertificateAuthority_SkipServerVerification:
		if fv, exists := v.FldValidators["server_validation_choice.skip_server_verification"]; exists {
			val := m.GetServerValidationChoice().(*CbipCertificateAuthority_SkipServerVerification).SkipServerVerification
			vOpts := append(opts,
				db.WithValidateField("server_validation_choice"),
				db.WithValidateField("skip_server_verification"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCbipCertificateAuthorityValidator = func() *ValidateCbipCertificateAuthority {
	v := &ValidateCbipCertificateAuthority{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhServerValidationChoice := v.ServerValidationChoiceValidationRuleHandler
	rulesServerValidationChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhServerValidationChoice(rulesServerValidationChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CbipCertificateAuthority.server_validation_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["server_validation_choice"] = vFn

	v.FldValidators["server_validation_choice.trusted_ca"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func CbipCertificateAuthorityValidator() db.Validator {
	return DefaultCbipCertificateAuthorityValidator
}

// augmented methods on protoc/std generated struct

func (m *CbipCluster) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CbipCluster) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *CbipCluster) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetCbipDevices() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting CbipCluster.cbip_devices idx %v", idx)
		}
	}

	return nil
}

func (m *CbipCluster) DeepCopy() *CbipCluster {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CbipCluster{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CbipCluster) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CbipCluster) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CbipClusterValidator().Validate(ctx, m, opts...)
}

func (m *CbipCluster) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetCbipDevicesDRefInfo()

}

// GetDRefInfo for the field's type
func (m *CbipCluster) GetCbipDevicesDRefInfo() ([]db.DRefInfo, error) {
	if m.GetCbipDevices() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetCbipDevices() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetCbipDevices() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("cbip_devices[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateCbipCluster struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCbipCluster) MetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for metadata")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.MessageMetaTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCbipCluster) CbipDevicesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for cbip_devices")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*CbipDeviceConfig, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := CbipDeviceConfigValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cbip_devices")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*CbipDeviceConfig)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*CbipDeviceConfig, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cbip_devices")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cbip_devices")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCbipCluster) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CbipCluster)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CbipCluster got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cbip_devices"]; exists {
		vOpts := append(opts, db.WithValidateField("cbip_devices"))
		if err := fv(ctx, m.GetCbipDevices(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCbipClusterValidator = func() *ValidateCbipCluster {
	v := &ValidateCbipCluster{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMetadata := v.MetadataValidationRuleHandler
	rulesMetadata := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMetadata(rulesMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CbipCluster.metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metadata"] = vFn

	vrhCbipDevices := v.CbipDevicesValidationRuleHandler
	rulesCbipDevices := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhCbipDevices(rulesCbipDevices)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CbipCluster.cbip_devices: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cbip_devices"] = vFn

	return v
}()

func CbipClusterValidator() db.Validator {
	return DefaultCbipClusterValidator
}

// augmented methods on protoc/std generated struct

func (m *CbipDeviceConfig) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CbipDeviceConfig) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *CbipDeviceConfig) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetAdminCredentials().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CbipDeviceConfig.admin_credentials")
	}

	return nil
}

func (m *CbipDeviceConfig) DeepCopy() *CbipDeviceConfig {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CbipDeviceConfig{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CbipDeviceConfig) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CbipDeviceConfig) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CbipDeviceConfigValidator().Validate(ctx, m, opts...)
}

func (m *CbipDeviceConfig) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetCbipCertificateAuthorityDRefInfo()

}

// GetDRefInfo for the field's type
func (m *CbipDeviceConfig) GetCbipCertificateAuthorityDRefInfo() ([]db.DRefInfo, error) {
	if m.GetCbipCertificateAuthority() == nil {
		return nil, nil
	}

	drInfos, err := m.GetCbipCertificateAuthority().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetCbipCertificateAuthority().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "cbip_certificate_authority." + dri.DRField
	}
	return drInfos, err

}

type ValidateCbipDeviceConfig struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCbipDeviceConfig) CbipMgmtIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cbip_mgmt_ip")
	}

	return validatorFn, nil
}

func (v *ValidateCbipDeviceConfig) AdminCredentialsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for admin_credentials")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := CbipAdminCredentialsValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCbipDeviceConfig) CbipCertificateAuthorityValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for cbip_certificate_authority")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := CbipCertificateAuthorityValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCbipDeviceConfig) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CbipDeviceConfig)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CbipDeviceConfig got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["admin_credentials"]; exists {

		vOpts := append(opts, db.WithValidateField("admin_credentials"))
		if err := fv(ctx, m.GetAdminCredentials(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cbip_certificate_authority"]; exists {

		vOpts := append(opts, db.WithValidateField("cbip_certificate_authority"))
		if err := fv(ctx, m.GetCbipCertificateAuthority(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cbip_mgmt_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("cbip_mgmt_ip"))
		if err := fv(ctx, m.GetCbipMgmtIp(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetNamespaceMappingChoice().(type) {
	case *CbipDeviceConfig_DefaultAll:
		if fv, exists := v.FldValidators["namespace_mapping_choice.default_all"]; exists {
			val := m.GetNamespaceMappingChoice().(*CbipDeviceConfig_DefaultAll).DefaultAll
			vOpts := append(opts,
				db.WithValidateField("namespace_mapping_choice"),
				db.WithValidateField("default_all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CbipDeviceConfig_NamespaceMapping:
		if fv, exists := v.FldValidators["namespace_mapping_choice.namespace_mapping"]; exists {
			val := m.GetNamespaceMappingChoice().(*CbipDeviceConfig_NamespaceMapping).NamespaceMapping
			vOpts := append(opts,
				db.WithValidateField("namespace_mapping_choice"),
				db.WithValidateField("namespace_mapping"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["virtual_server_filter"]; exists {

		vOpts := append(opts, db.WithValidateField("virtual_server_filter"))
		if err := fv(ctx, m.GetVirtualServerFilter(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCbipDeviceConfigValidator = func() *ValidateCbipDeviceConfig {
	v := &ValidateCbipDeviceConfig{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCbipMgmtIp := v.CbipMgmtIpValidationRuleHandler
	rulesCbipMgmtIp := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.ipv4":      "true",
	}
	vFn, err = vrhCbipMgmtIp(rulesCbipMgmtIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CbipDeviceConfig.cbip_mgmt_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cbip_mgmt_ip"] = vFn

	vrhAdminCredentials := v.AdminCredentialsValidationRuleHandler
	rulesAdminCredentials := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAdminCredentials(rulesAdminCredentials)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CbipDeviceConfig.admin_credentials: %s", err)
		panic(errMsg)
	}
	v.FldValidators["admin_credentials"] = vFn

	vrhCbipCertificateAuthority := v.CbipCertificateAuthorityValidationRuleHandler
	rulesCbipCertificateAuthority := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhCbipCertificateAuthority(rulesCbipCertificateAuthority)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CbipDeviceConfig.cbip_certificate_authority: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cbip_certificate_authority"] = vFn

	v.FldValidators["namespace_mapping_choice.namespace_mapping"] = NamespaceMappingValidator().Validate

	v.FldValidators["virtual_server_filter"] = VirtualServerFilterValidator().Validate

	return v
}()

func CbipDeviceConfigValidator() db.Validator {
	return DefaultCbipDeviceConfigValidator
}

// augmented methods on protoc/std generated struct

func (m *CbipDiscoveryType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CbipDiscoveryType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *CbipDiscoveryType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetCbipClusters() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting CbipDiscoveryType.cbip_clusters idx %v", idx)
		}
	}

	return nil
}

func (m *CbipDiscoveryType) DeepCopy() *CbipDiscoveryType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CbipDiscoveryType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CbipDiscoveryType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CbipDiscoveryType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CbipDiscoveryTypeValidator().Validate(ctx, m, opts...)
}

func (m *CbipDiscoveryType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetCbipClustersDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetCbipClustersDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetServerCaDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetServerCaDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *CbipDiscoveryType) GetCbipClustersDRefInfo() ([]db.DRefInfo, error) {
	if m.GetCbipClusters() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetCbipClusters() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetCbipClusters() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("cbip_clusters[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

func (m *CbipDiscoveryType) GetServerCaDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetServerCa()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("CbipDiscoveryType.server_ca[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "trusted_ca_list.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "server_ca",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetServerCaDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CbipDiscoveryType) GetServerCaDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "trusted_ca_list.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: trusted_ca_list")
	}
	for _, ref := range m.GetServerCa() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateCbipDiscoveryType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCbipDiscoveryType) CbipClustersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for cbip_clusters")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*CbipCluster, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := CbipClusterValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cbip_clusters")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*CbipCluster)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*CbipCluster, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cbip_clusters")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cbip_clusters")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCbipDiscoveryType) ServerCaValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for server_ca")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for server_ca")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated server_ca")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items server_ca")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCbipDiscoveryType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CbipDiscoveryType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CbipDiscoveryType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cbip_clusters"]; exists {
		vOpts := append(opts, db.WithValidateField("cbip_clusters"))
		if err := fv(ctx, m.GetCbipClusters(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["internal_lb_domain"]; exists {

		vOpts := append(opts, db.WithValidateField("internal_lb_domain"))
		if err := fv(ctx, m.GetInternalLbDomain(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["server_ca"]; exists {
		vOpts := append(opts, db.WithValidateField("server_ca"))
		if err := fv(ctx, m.GetServerCa(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCbipDiscoveryTypeValidator = func() *ValidateCbipDiscoveryType {
	v := &ValidateCbipDiscoveryType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCbipClusters := v.CbipClustersValidationRuleHandler
	rulesCbipClusters := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhCbipClusters(rulesCbipClusters)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CbipDiscoveryType.cbip_clusters: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cbip_clusters"] = vFn

	vrhServerCa := v.ServerCaValidationRuleHandler
	rulesServerCa := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhServerCa(rulesServerCa)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CbipDiscoveryType.server_ca: %s", err)
		panic(errMsg)
	}
	v.FldValidators["server_ca"] = vFn

	return v
}()

func CbipDiscoveryTypeValidator() db.Validator {
	return DefaultCbipDiscoveryTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ConsulAccessInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ConsulAccessInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ConsulAccessInfo) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetConnectionInfo().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ConsulAccessInfo.connection_info")
	}

	if err := m.GetHttpBasicAuthInfo().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ConsulAccessInfo.http_basic_auth_info")
	}

	return nil
}

func (m *ConsulAccessInfo) DeepCopy() *ConsulAccessInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ConsulAccessInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ConsulAccessInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ConsulAccessInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ConsulAccessInfoValidator().Validate(ctx, m, opts...)
}

type ValidateConsulAccessInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateConsulAccessInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ConsulAccessInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ConsulAccessInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["connection_info"]; exists {

		vOpts := append(opts, db.WithValidateField("connection_info"))
		if err := fv(ctx, m.GetConnectionInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["http_basic_auth_info"]; exists {

		vOpts := append(opts, db.WithValidateField("http_basic_auth_info"))
		if err := fv(ctx, m.GetHttpBasicAuthInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["scheme"]; exists {

		vOpts := append(opts, db.WithValidateField("scheme"))
		if err := fv(ctx, m.GetScheme(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultConsulAccessInfoValidator = func() *ValidateConsulAccessInfo {
	v := &ValidateConsulAccessInfo{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["connection_info"] = RestConfigTypeValidator().Validate

	v.FldValidators["http_basic_auth_info"] = ConsulHttpBasicAuthInfoTypeValidator().Validate

	return v
}()

func ConsulAccessInfoValidator() db.Validator {
	return DefaultConsulAccessInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *ConsulDiscoveryType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ConsulDiscoveryType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ConsulDiscoveryType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetAccessInfo().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ConsulDiscoveryType.access_info")
	}

	return nil
}

func (m *ConsulDiscoveryType) DeepCopy() *ConsulDiscoveryType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ConsulDiscoveryType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ConsulDiscoveryType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ConsulDiscoveryType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ConsulDiscoveryTypeValidator().Validate(ctx, m, opts...)
}

type ValidateConsulDiscoveryType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateConsulDiscoveryType) AccessInfoValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for access_info")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateConsulDiscoveryType) PublishInfoValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for publish_info")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ConsulVipDiscoveryInfoTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateConsulDiscoveryType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ConsulDiscoveryType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ConsulDiscoveryType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["access_info"]; exists {

		vOpts := append(opts, db.WithValidateField("access_info"))
		if err := fv(ctx, m.GetAccessInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["publish_info"]; exists {

		vOpts := append(opts, db.WithValidateField("publish_info"))
		if err := fv(ctx, m.GetPublishInfo(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultConsulDiscoveryTypeValidator = func() *ValidateConsulDiscoveryType {
	v := &ValidateConsulDiscoveryType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAccessInfo := v.AccessInfoValidationRuleHandler
	rulesAccessInfo := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAccessInfo(rulesAccessInfo)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ConsulDiscoveryType.access_info: %s", err)
		panic(errMsg)
	}
	v.FldValidators["access_info"] = vFn

	vrhPublishInfo := v.PublishInfoValidationRuleHandler
	rulesPublishInfo := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPublishInfo(rulesPublishInfo)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ConsulDiscoveryType.publish_info: %s", err)
		panic(errMsg)
	}
	v.FldValidators["publish_info"] = vFn

	return v
}()

func ConsulDiscoveryTypeValidator() db.Validator {
	return DefaultConsulDiscoveryTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ConsulHttpBasicAuthInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ConsulHttpBasicAuthInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ConsulHttpBasicAuthInfoType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetPasswdUrl().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ConsulHttpBasicAuthInfoType.passwd_url")
	}

	return nil
}

func (m *ConsulHttpBasicAuthInfoType) DeepCopy() *ConsulHttpBasicAuthInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ConsulHttpBasicAuthInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ConsulHttpBasicAuthInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ConsulHttpBasicAuthInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ConsulHttpBasicAuthInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateConsulHttpBasicAuthInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateConsulHttpBasicAuthInfoType) UserNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for user_name")
	}

	return validatorFn, nil
}

func (v *ValidateConsulHttpBasicAuthInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ConsulHttpBasicAuthInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ConsulHttpBasicAuthInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["passwd_url"]; exists {

		vOpts := append(opts, db.WithValidateField("passwd_url"))
		if err := fv(ctx, m.GetPasswdUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user_name"]; exists {

		vOpts := append(opts, db.WithValidateField("user_name"))
		if err := fv(ctx, m.GetUserName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultConsulHttpBasicAuthInfoTypeValidator = func() *ValidateConsulHttpBasicAuthInfoType {
	v := &ValidateConsulHttpBasicAuthInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhUserName := v.UserNameValidationRuleHandler
	rulesUserName := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhUserName(rulesUserName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ConsulHttpBasicAuthInfoType.user_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["user_name"] = vFn

	v.FldValidators["passwd_url"] = ves_io_schema.SecretTypeValidator().Validate

	return v
}()

func ConsulHttpBasicAuthInfoTypeValidator() db.Validator {
	return DefaultConsulHttpBasicAuthInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ConsulVipDiscoveryInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ConsulVipDiscoveryInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ConsulVipDiscoveryInfoType) DeepCopy() *ConsulVipDiscoveryInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ConsulVipDiscoveryInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ConsulVipDiscoveryInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ConsulVipDiscoveryInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ConsulVipDiscoveryInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateConsulVipDiscoveryInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateConsulVipDiscoveryInfoType) PublishChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for publish_choice")
	}
	return validatorFn, nil
}

func (v *ValidateConsulVipDiscoveryInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ConsulVipDiscoveryInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ConsulVipDiscoveryInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["publish_choice"]; exists {
		val := m.GetPublishChoice()
		vOpts := append(opts,
			db.WithValidateField("publish_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPublishChoice().(type) {
	case *ConsulVipDiscoveryInfoType_Disable:
		if fv, exists := v.FldValidators["publish_choice.disable"]; exists {
			val := m.GetPublishChoice().(*ConsulVipDiscoveryInfoType_Disable).Disable
			vOpts := append(opts,
				db.WithValidateField("publish_choice"),
				db.WithValidateField("disable"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ConsulVipDiscoveryInfoType_Publish:
		if fv, exists := v.FldValidators["publish_choice.publish"]; exists {
			val := m.GetPublishChoice().(*ConsulVipDiscoveryInfoType_Publish).Publish
			vOpts := append(opts,
				db.WithValidateField("publish_choice"),
				db.WithValidateField("publish"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultConsulVipDiscoveryInfoTypeValidator = func() *ValidateConsulVipDiscoveryInfoType {
	v := &ValidateConsulVipDiscoveryInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPublishChoice := v.PublishChoiceValidationRuleHandler
	rulesPublishChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPublishChoice(rulesPublishChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ConsulVipDiscoveryInfoType.publish_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["publish_choice"] = vFn

	return v
}()

func ConsulVipDiscoveryInfoTypeValidator() db.Validator {
	return DefaultConsulVipDiscoveryInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *CreateSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetDiscoveryK8S().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.discovery_k8s")
	}

	if err := m.GetDiscoveryConsul().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.discovery_consul")
	}

	if err := m.GetDiscoveryCbip().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.discovery_cbip")
	}

	return nil
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *CreateSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetDiscoveryChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDiscoveryChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetWhereDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetWhereDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetDiscoveryChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDiscoveryChoice() == nil {
		return nil, nil
	}
	switch m.GetDiscoveryChoice().(type) {
	case *CreateSpecType_DiscoveryK8S:

		return nil, nil

	case *CreateSpecType_DiscoveryConsul:

		return nil, nil

	case *CreateSpecType_DiscoveryCbip:

		drInfos, err := m.GetDiscoveryCbip().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetDiscoveryCbip().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "discovery_cbip." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetWhereDRefInfo() ([]db.DRefInfo, error) {
	if m.GetWhere() == nil {
		return nil, nil
	}

	drInfos, err := m.GetWhere().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetWhere().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "where." + dri.DRField
	}
	return drInfos, err

}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) ClusterIdentifierChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cluster_identifier_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) ClusterIdentifierChoiceClusterIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ClusterId, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cluster_id")
	}
	return oValidatorFn_ClusterId, nil
}

func (v *ValidateCreateSpecType) DiscoveryChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for discovery_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) WhereValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for where")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.NetworkSiteRefSelectorValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cluster_identifier_choice"]; exists {
		val := m.GetClusterIdentifierChoice()
		vOpts := append(opts,
			db.WithValidateField("cluster_identifier_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetClusterIdentifierChoice().(type) {
	case *CreateSpecType_NoClusterId:
		if fv, exists := v.FldValidators["cluster_identifier_choice.no_cluster_id"]; exists {
			val := m.GetClusterIdentifierChoice().(*CreateSpecType_NoClusterId).NoClusterId
			vOpts := append(opts,
				db.WithValidateField("cluster_identifier_choice"),
				db.WithValidateField("no_cluster_id"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_ClusterId:
		if fv, exists := v.FldValidators["cluster_identifier_choice.cluster_id"]; exists {
			val := m.GetClusterIdentifierChoice().(*CreateSpecType_ClusterId).ClusterId
			vOpts := append(opts,
				db.WithValidateField("cluster_identifier_choice"),
				db.WithValidateField("cluster_id"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["discovery_choice"]; exists {
		val := m.GetDiscoveryChoice()
		vOpts := append(opts,
			db.WithValidateField("discovery_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDiscoveryChoice().(type) {
	case *CreateSpecType_DiscoveryK8S:
		if fv, exists := v.FldValidators["discovery_choice.discovery_k8s"]; exists {
			val := m.GetDiscoveryChoice().(*CreateSpecType_DiscoveryK8S).DiscoveryK8S
			vOpts := append(opts,
				db.WithValidateField("discovery_choice"),
				db.WithValidateField("discovery_k8s"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_DiscoveryConsul:
		if fv, exists := v.FldValidators["discovery_choice.discovery_consul"]; exists {
			val := m.GetDiscoveryChoice().(*CreateSpecType_DiscoveryConsul).DiscoveryConsul
			vOpts := append(opts,
				db.WithValidateField("discovery_choice"),
				db.WithValidateField("discovery_consul"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_DiscoveryCbip:
		if fv, exists := v.FldValidators["discovery_choice.discovery_cbip"]; exists {
			val := m.GetDiscoveryChoice().(*CreateSpecType_DiscoveryCbip).DiscoveryCbip
			vOpts := append(opts,
				db.WithValidateField("discovery_choice"),
				db.WithValidateField("discovery_cbip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["where"]; exists {

		vOpts := append(opts, db.WithValidateField("where"))
		if err := fv(ctx, m.GetWhere(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhClusterIdentifierChoice := v.ClusterIdentifierChoiceValidationRuleHandler
	rulesClusterIdentifierChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhClusterIdentifierChoice(rulesClusterIdentifierChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.cluster_identifier_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cluster_identifier_choice"] = vFn

	vrhClusterIdentifierChoiceClusterId := v.ClusterIdentifierChoiceClusterIdValidationRuleHandler
	rulesClusterIdentifierChoiceClusterId := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFnMap["cluster_identifier_choice.cluster_id"], err = vrhClusterIdentifierChoiceClusterId(rulesClusterIdentifierChoiceClusterId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field CreateSpecType.cluster_identifier_choice_cluster_id: %s", err)
		panic(errMsg)
	}

	v.FldValidators["cluster_identifier_choice.cluster_id"] = vFnMap["cluster_identifier_choice.cluster_id"]

	vrhDiscoveryChoice := v.DiscoveryChoiceValidationRuleHandler
	rulesDiscoveryChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDiscoveryChoice(rulesDiscoveryChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.discovery_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["discovery_choice"] = vFn

	vrhWhere := v.WhereValidationRuleHandler
	rulesWhere := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhWhere(rulesWhere)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.where: %s", err)
		panic(errMsg)
	}
	v.FldValidators["where"] = vFn

	v.FldValidators["discovery_choice.discovery_k8s"] = K8SDiscoveryTypeValidator().Validate
	v.FldValidators["discovery_choice.discovery_consul"] = ConsulDiscoveryTypeValidator().Validate
	v.FldValidators["discovery_choice.discovery_cbip"] = CbipDiscoveryTypeValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DiscoveredServiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DiscoveredServiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DiscoveredServiceType) DeepCopy() *DiscoveredServiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DiscoveredServiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DiscoveredServiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DiscoveredServiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DiscoveredServiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateDiscoveredServiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDiscoveredServiceType) ServiceNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for service_name")
	}

	return validatorFn, nil
}

func (v *ValidateDiscoveredServiceType) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateDiscoveredServiceType) ServiceTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for service_type")
	}

	return validatorFn, nil
}

func (v *ValidateDiscoveredServiceType) ClusterIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cluster_ip")
	}

	return validatorFn, nil
}

func (v *ValidateDiscoveredServiceType) LabelsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for labels")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for labels")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for labels")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map labels")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items labels")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDiscoveredServiceType) PortMapValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapUint32KeyRules(rules)
	itemKeyFn, err := db.NewUint32ValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for port_map")
	}
	itemValRules := db.GetMapUint32ValueRules(rules)
	itemValFn, err := db.NewUint32ValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for port_map")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[uint32]uint32, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for port_map")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[uint32]uint32)
		if !ok {
			return fmt.Errorf("Map validation expected map[ uint32 ]uint32, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map port_map")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items port_map")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDiscoveredServiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DiscoveredServiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DiscoveredServiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cluster_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("cluster_ip"))
		if err := fv(ctx, m.GetClusterIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["labels"]; exists {
		vOpts := append(opts, db.WithValidateField("labels"))
		if err := fv(ctx, m.GetLabels(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["pods"]; exists {

		vOpts := append(opts, db.WithValidateField("pods"))
		for idx, item := range m.GetPods() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["port_map"]; exists {
		vOpts := append(opts, db.WithValidateField("port_map"))
		if err := fv(ctx, m.GetPortMap(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ports"]; exists {

		vOpts := append(opts, db.WithValidateField("ports"))
		for idx, item := range m.GetPorts() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["service_name"]; exists {

		vOpts := append(opts, db.WithValidateField("service_name"))
		if err := fv(ctx, m.GetServiceName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_type"]; exists {

		vOpts := append(opts, db.WithValidateField("service_type"))
		if err := fv(ctx, m.GetServiceType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDiscoveredServiceTypeValidator = func() *ValidateDiscoveredServiceType {
	v := &ValidateDiscoveredServiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhServiceName := v.ServiceNameValidationRuleHandler
	rulesServiceName := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhServiceName(rulesServiceName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DiscoveredServiceType.service_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_name"] = vFn

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DiscoveredServiceType.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhServiceType := v.ServiceTypeValidationRuleHandler
	rulesServiceType := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhServiceType(rulesServiceType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DiscoveredServiceType.service_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_type"] = vFn

	vrhClusterIp := v.ClusterIpValidationRuleHandler
	rulesClusterIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhClusterIp(rulesClusterIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DiscoveredServiceType.cluster_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cluster_ip"] = vFn

	vrhLabels := v.LabelsValidationRuleHandler
	rulesLabels := map[string]string{
		"ves.io.schema.rules.map.max_pairs":                     "16",
		"ves.io.schema.rules.map.values.string.k8s_label_value": "true",
	}
	vFn, err = vrhLabels(rulesLabels)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DiscoveredServiceType.labels: %s", err)
		panic(errMsg)
	}
	v.FldValidators["labels"] = vFn

	vrhPortMap := v.PortMapValidationRuleHandler
	rulesPortMap := map[string]string{
		"ves.io.schema.rules.map.keys.uint32.gte":   "1",
		"ves.io.schema.rules.map.keys.uint32.lte":   "65535",
		"ves.io.schema.rules.map.values.uint32.gte": "1",
		"ves.io.schema.rules.map.values.uint32.lte": "65535",
	}
	vFn, err = vrhPortMap(rulesPortMap)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DiscoveredServiceType.port_map: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port_map"] = vFn

	v.FldValidators["ports"] = PortInfoTypeValidator().Validate

	return v
}()

func DiscoveredServiceTypeValidator() db.Validator {
	return DefaultDiscoveredServiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GetSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetDiscoveryK8S().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.discovery_k8s")
	}

	if err := m.GetDiscoveryConsul().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.discovery_consul")
	}

	if err := m.GetDiscoveryCbip().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.discovery_cbip")
	}

	return nil
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GetSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetDiscoveryChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDiscoveryChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetWhereDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetWhereDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetDiscoveryChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDiscoveryChoice() == nil {
		return nil, nil
	}
	switch m.GetDiscoveryChoice().(type) {
	case *GetSpecType_DiscoveryK8S:

		return nil, nil

	case *GetSpecType_DiscoveryConsul:

		return nil, nil

	case *GetSpecType_DiscoveryCbip:

		drInfos, err := m.GetDiscoveryCbip().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetDiscoveryCbip().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "discovery_cbip." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetWhereDRefInfo() ([]db.DRefInfo, error) {
	if m.GetWhere() == nil {
		return nil, nil
	}

	drInfos, err := m.GetWhere().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetWhere().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "where." + dri.DRField
	}
	return drInfos, err

}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) ClusterIdentifierChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cluster_identifier_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) ClusterIdentifierChoiceClusterIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ClusterId, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cluster_id")
	}
	return oValidatorFn_ClusterId, nil
}

func (v *ValidateGetSpecType) DiscoveryChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for discovery_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) WhereValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for where")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.NetworkSiteRefSelectorValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) TypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.DiscoveryType)
		return int32(i)
	}
	// ves_io_schema.DiscoveryType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.DiscoveryType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for type")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cluster_identifier_choice"]; exists {
		val := m.GetClusterIdentifierChoice()
		vOpts := append(opts,
			db.WithValidateField("cluster_identifier_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetClusterIdentifierChoice().(type) {
	case *GetSpecType_NoClusterId:
		if fv, exists := v.FldValidators["cluster_identifier_choice.no_cluster_id"]; exists {
			val := m.GetClusterIdentifierChoice().(*GetSpecType_NoClusterId).NoClusterId
			vOpts := append(opts,
				db.WithValidateField("cluster_identifier_choice"),
				db.WithValidateField("no_cluster_id"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_ClusterId:
		if fv, exists := v.FldValidators["cluster_identifier_choice.cluster_id"]; exists {
			val := m.GetClusterIdentifierChoice().(*GetSpecType_ClusterId).ClusterId
			vOpts := append(opts,
				db.WithValidateField("cluster_identifier_choice"),
				db.WithValidateField("cluster_id"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["discovery_choice"]; exists {
		val := m.GetDiscoveryChoice()
		vOpts := append(opts,
			db.WithValidateField("discovery_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDiscoveryChoice().(type) {
	case *GetSpecType_DiscoveryK8S:
		if fv, exists := v.FldValidators["discovery_choice.discovery_k8s"]; exists {
			val := m.GetDiscoveryChoice().(*GetSpecType_DiscoveryK8S).DiscoveryK8S
			vOpts := append(opts,
				db.WithValidateField("discovery_choice"),
				db.WithValidateField("discovery_k8s"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_DiscoveryConsul:
		if fv, exists := v.FldValidators["discovery_choice.discovery_consul"]; exists {
			val := m.GetDiscoveryChoice().(*GetSpecType_DiscoveryConsul).DiscoveryConsul
			vOpts := append(opts,
				db.WithValidateField("discovery_choice"),
				db.WithValidateField("discovery_consul"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_DiscoveryCbip:
		if fv, exists := v.FldValidators["discovery_choice.discovery_cbip"]; exists {
			val := m.GetDiscoveryChoice().(*GetSpecType_DiscoveryCbip).DiscoveryCbip
			vOpts := append(opts,
				db.WithValidateField("discovery_choice"),
				db.WithValidateField("discovery_cbip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["publish_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("publish_vip"))
		if err := fv(ctx, m.GetPublishVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["where"]; exists {

		vOpts := append(opts, db.WithValidateField("where"))
		if err := fv(ctx, m.GetWhere(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhClusterIdentifierChoice := v.ClusterIdentifierChoiceValidationRuleHandler
	rulesClusterIdentifierChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhClusterIdentifierChoice(rulesClusterIdentifierChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.cluster_identifier_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cluster_identifier_choice"] = vFn

	vrhClusterIdentifierChoiceClusterId := v.ClusterIdentifierChoiceClusterIdValidationRuleHandler
	rulesClusterIdentifierChoiceClusterId := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFnMap["cluster_identifier_choice.cluster_id"], err = vrhClusterIdentifierChoiceClusterId(rulesClusterIdentifierChoiceClusterId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GetSpecType.cluster_identifier_choice_cluster_id: %s", err)
		panic(errMsg)
	}

	v.FldValidators["cluster_identifier_choice.cluster_id"] = vFnMap["cluster_identifier_choice.cluster_id"]

	vrhDiscoveryChoice := v.DiscoveryChoiceValidationRuleHandler
	rulesDiscoveryChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDiscoveryChoice(rulesDiscoveryChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.discovery_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["discovery_choice"] = vFn

	vrhWhere := v.WhereValidationRuleHandler
	rulesWhere := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhWhere(rulesWhere)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.where: %s", err)
		panic(errMsg)
	}
	v.FldValidators["where"] = vFn

	vrhType := v.TypeValidationRuleHandler
	rulesType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhType(rulesType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["type"] = vFn

	v.FldValidators["discovery_choice.discovery_k8s"] = K8SDiscoveryTypeValidator().Validate
	v.FldValidators["discovery_choice.discovery_consul"] = ConsulDiscoveryTypeValidator().Validate
	v.FldValidators["discovery_choice.discovery_cbip"] = CbipDiscoveryTypeValidator().Validate

	v.FldValidators["publish_vip"] = VipDiscoveryInfoTypeValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GlobalSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetK8S().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.k8s")
	}

	if err := m.GetConsul().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.consul")
	}

	if err := m.GetDiscoveryK8S().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.discovery_k8s")
	}

	if err := m.GetDiscoveryConsul().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.discovery_consul")
	}

	if err := m.GetDiscoveryCbip().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.discovery_cbip")
	}

	return nil
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetDiscoveryChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDiscoveryChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetViewInternalDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetViewInternalDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetWhereDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetWhereDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetDiscoveryChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDiscoveryChoice() == nil {
		return nil, nil
	}
	switch m.GetDiscoveryChoice().(type) {
	case *GlobalSpecType_DiscoveryK8S:

		return nil, nil

	case *GlobalSpecType_DiscoveryConsul:

		return nil, nil

	case *GlobalSpecType_DiscoveryCbip:

		drInfos, err := m.GetDiscoveryCbip().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetDiscoveryCbip().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "discovery_cbip." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

func (m *GlobalSpecType) GetViewInternalDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetViewInternal()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("view_internal.Object")
	dri := db.DRefInfo{
		RefdType:   "view_internal.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "view_internal",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetViewInternalDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetViewInternalDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "view_internal.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: view_internal")
	}

	vref := m.GetViewInternal()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "view_internal.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetWhereDRefInfo() ([]db.DRefInfo, error) {
	if m.GetWhere() == nil {
		return nil, nil
	}

	drInfos, err := m.GetWhere().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetWhere().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "where." + dri.DRField
	}
	return drInfos, err

}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) ClusterIdentifierChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cluster_identifier_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ClusterIdentifierChoiceClusterIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ClusterId, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cluster_id")
	}
	return oValidatorFn_ClusterId, nil
}

func (v *ValidateGlobalSpecType) DiscoveryChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for discovery_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) WhereValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for where")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.NetworkSiteRefSelectorValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) TypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.DiscoveryType)
		return int32(i)
	}
	// ves_io_schema.DiscoveryType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.DiscoveryType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for type")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ClusterIdentifierValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cluster_identifier")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetAccessInfo().(type) {
	case *GlobalSpecType_K8S:
		if fv, exists := v.FldValidators["access_info.k8s"]; exists {
			val := m.GetAccessInfo().(*GlobalSpecType_K8S).K8S
			vOpts := append(opts,
				db.WithValidateField("access_info"),
				db.WithValidateField("k8s"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Consul:
		if fv, exists := v.FldValidators["access_info.consul"]; exists {
			val := m.GetAccessInfo().(*GlobalSpecType_Consul).Consul
			vOpts := append(opts,
				db.WithValidateField("access_info"),
				db.WithValidateField("consul"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["cluster_identifier"]; exists {

		vOpts := append(opts, db.WithValidateField("cluster_identifier"))
		if err := fv(ctx, m.GetClusterIdentifier(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cluster_identifier_choice"]; exists {
		val := m.GetClusterIdentifierChoice()
		vOpts := append(opts,
			db.WithValidateField("cluster_identifier_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetClusterIdentifierChoice().(type) {
	case *GlobalSpecType_NoClusterId:
		if fv, exists := v.FldValidators["cluster_identifier_choice.no_cluster_id"]; exists {
			val := m.GetClusterIdentifierChoice().(*GlobalSpecType_NoClusterId).NoClusterId
			vOpts := append(opts,
				db.WithValidateField("cluster_identifier_choice"),
				db.WithValidateField("no_cluster_id"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_ClusterId:
		if fv, exists := v.FldValidators["cluster_identifier_choice.cluster_id"]; exists {
			val := m.GetClusterIdentifierChoice().(*GlobalSpecType_ClusterId).ClusterId
			vOpts := append(opts,
				db.WithValidateField("cluster_identifier_choice"),
				db.WithValidateField("cluster_id"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["discovery_choice"]; exists {
		val := m.GetDiscoveryChoice()
		vOpts := append(opts,
			db.WithValidateField("discovery_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDiscoveryChoice().(type) {
	case *GlobalSpecType_DiscoveryK8S:
		if fv, exists := v.FldValidators["discovery_choice.discovery_k8s"]; exists {
			val := m.GetDiscoveryChoice().(*GlobalSpecType_DiscoveryK8S).DiscoveryK8S
			vOpts := append(opts,
				db.WithValidateField("discovery_choice"),
				db.WithValidateField("discovery_k8s"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_DiscoveryConsul:
		if fv, exists := v.FldValidators["discovery_choice.discovery_consul"]; exists {
			val := m.GetDiscoveryChoice().(*GlobalSpecType_DiscoveryConsul).DiscoveryConsul
			vOpts := append(opts,
				db.WithValidateField("discovery_choice"),
				db.WithValidateField("discovery_consul"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_DiscoveryCbip:
		if fv, exists := v.FldValidators["discovery_choice.discovery_cbip"]; exists {
			val := m.GetDiscoveryChoice().(*GlobalSpecType_DiscoveryCbip).DiscoveryCbip
			vOpts := append(opts,
				db.WithValidateField("discovery_choice"),
				db.WithValidateField("discovery_cbip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["publish_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("publish_vip"))
		if err := fv(ctx, m.GetPublishVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["view_internal"]; exists {

		vOpts := append(opts, db.WithValidateField("view_internal"))
		if err := fv(ctx, m.GetViewInternal(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["where"]; exists {

		vOpts := append(opts, db.WithValidateField("where"))
		if err := fv(ctx, m.GetWhere(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhClusterIdentifierChoice := v.ClusterIdentifierChoiceValidationRuleHandler
	rulesClusterIdentifierChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhClusterIdentifierChoice(rulesClusterIdentifierChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.cluster_identifier_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cluster_identifier_choice"] = vFn

	vrhClusterIdentifierChoiceClusterId := v.ClusterIdentifierChoiceClusterIdValidationRuleHandler
	rulesClusterIdentifierChoiceClusterId := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFnMap["cluster_identifier_choice.cluster_id"], err = vrhClusterIdentifierChoiceClusterId(rulesClusterIdentifierChoiceClusterId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GlobalSpecType.cluster_identifier_choice_cluster_id: %s", err)
		panic(errMsg)
	}

	v.FldValidators["cluster_identifier_choice.cluster_id"] = vFnMap["cluster_identifier_choice.cluster_id"]

	vrhDiscoveryChoice := v.DiscoveryChoiceValidationRuleHandler
	rulesDiscoveryChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDiscoveryChoice(rulesDiscoveryChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.discovery_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["discovery_choice"] = vFn

	vrhWhere := v.WhereValidationRuleHandler
	rulesWhere := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhWhere(rulesWhere)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.where: %s", err)
		panic(errMsg)
	}
	v.FldValidators["where"] = vFn

	vrhType := v.TypeValidationRuleHandler
	rulesType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhType(rulesType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["type"] = vFn

	vrhClusterIdentifier := v.ClusterIdentifierValidationRuleHandler
	rulesClusterIdentifier := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhClusterIdentifier(rulesClusterIdentifier)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.cluster_identifier: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cluster_identifier"] = vFn

	v.FldValidators["access_info.k8s"] = K8SAccessInfoValidator().Validate
	v.FldValidators["access_info.consul"] = ConsulAccessInfoValidator().Validate

	v.FldValidators["discovery_choice.discovery_k8s"] = K8SDiscoveryTypeValidator().Validate
	v.FldValidators["discovery_choice.discovery_consul"] = ConsulDiscoveryTypeValidator().Validate
	v.FldValidators["discovery_choice.discovery_cbip"] = CbipDiscoveryTypeValidator().Validate

	v.FldValidators["publish_vip"] = VipDiscoveryInfoTypeValidator().Validate

	v.FldValidators["view_internal"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *K8SAccessInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *K8SAccessInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *K8SAccessInfo) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetKubeconfigUrl().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting K8SAccessInfo.kubeconfig_url")
	}

	if err := m.GetConnectionInfo().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting K8SAccessInfo.connection_info")
	}

	return nil
}

func (m *K8SAccessInfo) DeepCopy() *K8SAccessInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &K8SAccessInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *K8SAccessInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *K8SAccessInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return K8SAccessInfoValidator().Validate(ctx, m, opts...)
}

type ValidateK8SAccessInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateK8SAccessInfo) ConfigTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for config_type")
	}
	return validatorFn, nil
}

func (v *ValidateK8SAccessInfo) K8SPodNetworkChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for k8s_pod_network_choice")
	}
	return validatorFn, nil
}

func (v *ValidateK8SAccessInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*K8SAccessInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *K8SAccessInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["config_type"]; exists {
		val := m.GetConfigType()
		vOpts := append(opts,
			db.WithValidateField("config_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetConfigType().(type) {
	case *K8SAccessInfo_KubeconfigUrl:
		if fv, exists := v.FldValidators["config_type.kubeconfig_url"]; exists {
			val := m.GetConfigType().(*K8SAccessInfo_KubeconfigUrl).KubeconfigUrl
			vOpts := append(opts,
				db.WithValidateField("config_type"),
				db.WithValidateField("kubeconfig_url"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *K8SAccessInfo_ConnectionInfo:
		if fv, exists := v.FldValidators["config_type.connection_info"]; exists {
			val := m.GetConfigType().(*K8SAccessInfo_ConnectionInfo).ConnectionInfo
			vOpts := append(opts,
				db.WithValidateField("config_type"),
				db.WithValidateField("connection_info"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *K8SAccessInfo_InCluster:
		if fv, exists := v.FldValidators["config_type.in_cluster"]; exists {
			val := m.GetConfigType().(*K8SAccessInfo_InCluster).InCluster
			vOpts := append(opts,
				db.WithValidateField("config_type"),
				db.WithValidateField("in_cluster"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["k8s_pod_network_choice"]; exists {
		val := m.GetK8SPodNetworkChoice()
		vOpts := append(opts,
			db.WithValidateField("k8s_pod_network_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetK8SPodNetworkChoice().(type) {
	case *K8SAccessInfo_Isolated:
		if fv, exists := v.FldValidators["k8s_pod_network_choice.isolated"]; exists {
			val := m.GetK8SPodNetworkChoice().(*K8SAccessInfo_Isolated).Isolated
			vOpts := append(opts,
				db.WithValidateField("k8s_pod_network_choice"),
				db.WithValidateField("isolated"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *K8SAccessInfo_Reachable:
		if fv, exists := v.FldValidators["k8s_pod_network_choice.reachable"]; exists {
			val := m.GetK8SPodNetworkChoice().(*K8SAccessInfo_Reachable).Reachable
			vOpts := append(opts,
				db.WithValidateField("k8s_pod_network_choice"),
				db.WithValidateField("reachable"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultK8SAccessInfoValidator = func() *ValidateK8SAccessInfo {
	v := &ValidateK8SAccessInfo{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhConfigType := v.ConfigTypeValidationRuleHandler
	rulesConfigType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhConfigType(rulesConfigType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for K8SAccessInfo.config_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["config_type"] = vFn

	vrhK8SPodNetworkChoice := v.K8SPodNetworkChoiceValidationRuleHandler
	rulesK8SPodNetworkChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhK8SPodNetworkChoice(rulesK8SPodNetworkChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for K8SAccessInfo.k8s_pod_network_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["k8s_pod_network_choice"] = vFn

	v.FldValidators["config_type.kubeconfig_url"] = ves_io_schema.SecretTypeValidator().Validate
	v.FldValidators["config_type.connection_info"] = RestConfigTypeValidator().Validate

	return v
}()

func K8SAccessInfoValidator() db.Validator {
	return DefaultK8SAccessInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *K8SDelegationType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *K8SDelegationType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *K8SDelegationType) DeepCopy() *K8SDelegationType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &K8SDelegationType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *K8SDelegationType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *K8SDelegationType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return K8SDelegationTypeValidator().Validate(ctx, m, opts...)
}

type ValidateK8SDelegationType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateK8SDelegationType) SubdomainValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for subdomain")
	}

	return validatorFn, nil
}

func (v *ValidateK8SDelegationType) DnsModeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(K8SDNSMode)
		return int32(i)
	}
	// K8SDNSMode_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, K8SDNSMode_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dns_mode")
	}

	return validatorFn, nil
}

func (v *ValidateK8SDelegationType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*K8SDelegationType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *K8SDelegationType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["dns_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_mode"))
		if err := fv(ctx, m.GetDnsMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["subdomain"]; exists {

		vOpts := append(opts, db.WithValidateField("subdomain"))
		if err := fv(ctx, m.GetSubdomain(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultK8SDelegationTypeValidator = func() *ValidateK8SDelegationType {
	v := &ValidateK8SDelegationType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSubdomain := v.SubdomainValidationRuleHandler
	rulesSubdomain := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFn, err = vrhSubdomain(rulesSubdomain)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for K8SDelegationType.subdomain: %s", err)
		panic(errMsg)
	}
	v.FldValidators["subdomain"] = vFn

	vrhDnsMode := v.DnsModeValidationRuleHandler
	rulesDnsMode := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDnsMode(rulesDnsMode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for K8SDelegationType.dns_mode: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_mode"] = vFn

	return v
}()

func K8SDelegationTypeValidator() db.Validator {
	return DefaultK8SDelegationTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *K8SDiscoveryType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *K8SDiscoveryType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *K8SDiscoveryType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetAccessInfo().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting K8SDiscoveryType.access_info")
	}

	return nil
}

func (m *K8SDiscoveryType) DeepCopy() *K8SDiscoveryType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &K8SDiscoveryType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *K8SDiscoveryType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *K8SDiscoveryType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return K8SDiscoveryTypeValidator().Validate(ctx, m, opts...)
}

type ValidateK8SDiscoveryType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateK8SDiscoveryType) AccessInfoValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for access_info")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := K8SAccessInfoValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateK8SDiscoveryType) PublishInfoValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for publish_info")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := K8SVipDiscoveryInfoTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateK8SDiscoveryType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*K8SDiscoveryType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *K8SDiscoveryType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["access_info"]; exists {

		vOpts := append(opts, db.WithValidateField("access_info"))
		if err := fv(ctx, m.GetAccessInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["publish_info"]; exists {

		vOpts := append(opts, db.WithValidateField("publish_info"))
		if err := fv(ctx, m.GetPublishInfo(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultK8SDiscoveryTypeValidator = func() *ValidateK8SDiscoveryType {
	v := &ValidateK8SDiscoveryType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAccessInfo := v.AccessInfoValidationRuleHandler
	rulesAccessInfo := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAccessInfo(rulesAccessInfo)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for K8SDiscoveryType.access_info: %s", err)
		panic(errMsg)
	}
	v.FldValidators["access_info"] = vFn

	vrhPublishInfo := v.PublishInfoValidationRuleHandler
	rulesPublishInfo := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPublishInfo(rulesPublishInfo)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for K8SDiscoveryType.publish_info: %s", err)
		panic(errMsg)
	}
	v.FldValidators["publish_info"] = vFn

	return v
}()

func K8SDiscoveryTypeValidator() db.Validator {
	return DefaultK8SDiscoveryTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *K8SPublishType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *K8SPublishType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *K8SPublishType) DeepCopy() *K8SPublishType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &K8SPublishType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *K8SPublishType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *K8SPublishType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return K8SPublishTypeValidator().Validate(ctx, m, opts...)
}

type ValidateK8SPublishType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateK8SPublishType) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateK8SPublishType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*K8SPublishType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *K8SPublishType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultK8SPublishTypeValidator = func() *ValidateK8SPublishType {
	v := &ValidateK8SPublishType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for K8SPublishType.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	return v
}()

func K8SPublishTypeValidator() db.Validator {
	return DefaultK8SPublishTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *K8SVipDiscoveryInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *K8SVipDiscoveryInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *K8SVipDiscoveryInfoType) DeepCopy() *K8SVipDiscoveryInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &K8SVipDiscoveryInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *K8SVipDiscoveryInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *K8SVipDiscoveryInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return K8SVipDiscoveryInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateK8SVipDiscoveryInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateK8SVipDiscoveryInfoType) PublishChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for publish_choice")
	}
	return validatorFn, nil
}

func (v *ValidateK8SVipDiscoveryInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*K8SVipDiscoveryInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *K8SVipDiscoveryInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["publish_choice"]; exists {
		val := m.GetPublishChoice()
		vOpts := append(opts,
			db.WithValidateField("publish_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPublishChoice().(type) {
	case *K8SVipDiscoveryInfoType_Disable:
		if fv, exists := v.FldValidators["publish_choice.disable"]; exists {
			val := m.GetPublishChoice().(*K8SVipDiscoveryInfoType_Disable).Disable
			vOpts := append(opts,
				db.WithValidateField("publish_choice"),
				db.WithValidateField("disable"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *K8SVipDiscoveryInfoType_Publish:
		if fv, exists := v.FldValidators["publish_choice.publish"]; exists {
			val := m.GetPublishChoice().(*K8SVipDiscoveryInfoType_Publish).Publish
			vOpts := append(opts,
				db.WithValidateField("publish_choice"),
				db.WithValidateField("publish"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *K8SVipDiscoveryInfoType_PublishFqdns:
		if fv, exists := v.FldValidators["publish_choice.publish_fqdns"]; exists {
			val := m.GetPublishChoice().(*K8SVipDiscoveryInfoType_PublishFqdns).PublishFqdns
			vOpts := append(opts,
				db.WithValidateField("publish_choice"),
				db.WithValidateField("publish_fqdns"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *K8SVipDiscoveryInfoType_DnsDelegation:
		if fv, exists := v.FldValidators["publish_choice.dns_delegation"]; exists {
			val := m.GetPublishChoice().(*K8SVipDiscoveryInfoType_DnsDelegation).DnsDelegation
			vOpts := append(opts,
				db.WithValidateField("publish_choice"),
				db.WithValidateField("dns_delegation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultK8SVipDiscoveryInfoTypeValidator = func() *ValidateK8SVipDiscoveryInfoType {
	v := &ValidateK8SVipDiscoveryInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPublishChoice := v.PublishChoiceValidationRuleHandler
	rulesPublishChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPublishChoice(rulesPublishChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for K8SVipDiscoveryInfoType.publish_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["publish_choice"] = vFn

	v.FldValidators["publish_choice.publish"] = K8SPublishTypeValidator().Validate
	v.FldValidators["publish_choice.dns_delegation"] = K8SDelegationTypeValidator().Validate

	return v
}()

func K8SVipDiscoveryInfoTypeValidator() db.Validator {
	return DefaultK8SVipDiscoveryInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *NamespaceMapping) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NamespaceMapping) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NamespaceMapping) DeepCopy() *NamespaceMapping {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NamespaceMapping{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NamespaceMapping) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NamespaceMapping) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NamespaceMappingValidator().Validate(ctx, m, opts...)
}

type ValidateNamespaceMapping struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNamespaceMapping) ItemsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for items")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*NamespaceMappingItem, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := NamespaceMappingItemValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for items")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*NamespaceMappingItem)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*NamespaceMappingItem, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated items")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items items")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateNamespaceMapping) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NamespaceMapping)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NamespaceMapping got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["items"]; exists {
		vOpts := append(opts, db.WithValidateField("items"))
		if err := fv(ctx, m.GetItems(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNamespaceMappingValidator = func() *ValidateNamespaceMapping {
	v := &ValidateNamespaceMapping{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhItems := v.ItemsValidationRuleHandler
	rulesItems := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhItems(rulesItems)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for NamespaceMapping.items: %s", err)
		panic(errMsg)
	}
	v.FldValidators["items"] = vFn

	return v
}()

func NamespaceMappingValidator() db.Validator {
	return DefaultNamespaceMappingValidator
}

// augmented methods on protoc/std generated struct

func (m *NamespaceMappingItem) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NamespaceMappingItem) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NamespaceMappingItem) DeepCopy() *NamespaceMappingItem {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NamespaceMappingItem{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NamespaceMappingItem) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NamespaceMappingItem) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NamespaceMappingItemValidator().Validate(ctx, m, opts...)
}

type ValidateNamespaceMappingItem struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNamespaceMappingItem) PartitionRegexValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for partition_regex")
	}

	return validatorFn, nil
}

func (v *ValidateNamespaceMappingItem) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NamespaceMappingItem)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NamespaceMappingItem got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["partition_regex"]; exists {

		vOpts := append(opts, db.WithValidateField("partition_regex"))
		if err := fv(ctx, m.GetPartitionRegex(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNamespaceMappingItemValidator = func() *ValidateNamespaceMappingItem {
	v := &ValidateNamespaceMappingItem{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPartitionRegex := v.PartitionRegexValidationRuleHandler
	rulesPartitionRegex := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.regex":   "true",
	}
	vFn, err = vrhPartitionRegex(rulesPartitionRegex)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for NamespaceMappingItem.partition_regex: %s", err)
		panic(errMsg)
	}
	v.FldValidators["partition_regex"] = vFn

	return v
}()

func NamespaceMappingItemValidator() db.Validator {
	return DefaultNamespaceMappingItemValidator
}

// augmented methods on protoc/std generated struct

func (m *PodInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PodInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PodInfoType) DeepCopy() *PodInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PodInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PodInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PodInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PodInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePodInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePodInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PodInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PodInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ip"]; exists {

		vOpts := append(opts, db.WithValidateField("ip"))
		if err := fv(ctx, m.GetIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["pod_name"]; exists {

		vOpts := append(opts, db.WithValidateField("pod_name"))
		if err := fv(ctx, m.GetPodName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPodInfoTypeValidator = func() *ValidatePodInfoType {
	v := &ValidatePodInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func PodInfoTypeValidator() db.Validator {
	return DefaultPodInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PortInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PortInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PortInfoType) DeepCopy() *PortInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PortInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PortInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PortInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PortInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePortInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePortInfoType) PortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port")
	}

	return validatorFn, nil
}

func (v *ValidatePortInfoType) ProtocolValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for protocol")
	}

	return validatorFn, nil
}

func (v *ValidatePortInfoType) TargetPortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for target_port")
	}

	return validatorFn, nil
}

func (v *ValidatePortInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PortInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PortInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["port"]; exists {

		vOpts := append(opts, db.WithValidateField("port"))
		if err := fv(ctx, m.GetPort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["protocol"]; exists {

		vOpts := append(opts, db.WithValidateField("protocol"))
		if err := fv(ctx, m.GetProtocol(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["target_port"]; exists {

		vOpts := append(opts, db.WithValidateField("target_port"))
		if err := fv(ctx, m.GetTargetPort(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPortInfoTypeValidator = func() *ValidatePortInfoType {
	v := &ValidatePortInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPort := v.PortValidationRuleHandler
	rulesPort := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "1",
		"ves.io.schema.rules.uint32.lte":       "65535",
	}
	vFn, err = vrhPort(rulesPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PortInfoType.port: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port"] = vFn

	vrhProtocol := v.ProtocolValidationRuleHandler
	rulesProtocol := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhProtocol(rulesProtocol)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PortInfoType.protocol: %s", err)
		panic(errMsg)
	}
	v.FldValidators["protocol"] = vFn

	vrhTargetPort := v.TargetPortValidationRuleHandler
	rulesTargetPort := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "1",
		"ves.io.schema.rules.uint32.lte":       "65535",
	}
	vFn, err = vrhTargetPort(rulesTargetPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PortInfoType.target_port: %s", err)
		panic(errMsg)
	}
	v.FldValidators["target_port"] = vFn

	return v
}()

func PortInfoTypeValidator() db.Validator {
	return DefaultPortInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ReplaceSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetDiscoveryK8S().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.discovery_k8s")
	}

	if err := m.GetDiscoveryConsul().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.discovery_consul")
	}

	if err := m.GetDiscoveryCbip().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.discovery_cbip")
	}

	return nil
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *ReplaceSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetDiscoveryChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDiscoveryChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetWhereDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetWhereDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetDiscoveryChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDiscoveryChoice() == nil {
		return nil, nil
	}
	switch m.GetDiscoveryChoice().(type) {
	case *ReplaceSpecType_DiscoveryK8S:

		return nil, nil

	case *ReplaceSpecType_DiscoveryConsul:

		return nil, nil

	case *ReplaceSpecType_DiscoveryCbip:

		drInfos, err := m.GetDiscoveryCbip().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetDiscoveryCbip().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "discovery_cbip." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetWhereDRefInfo() ([]db.DRefInfo, error) {
	if m.GetWhere() == nil {
		return nil, nil
	}

	drInfos, err := m.GetWhere().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetWhere().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "where." + dri.DRField
	}
	return drInfos, err

}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) ClusterIdentifierChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cluster_identifier_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) ClusterIdentifierChoiceClusterIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ClusterId, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cluster_id")
	}
	return oValidatorFn_ClusterId, nil
}

func (v *ValidateReplaceSpecType) DiscoveryChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for discovery_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) WhereValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for where")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.NetworkSiteRefSelectorValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cluster_identifier_choice"]; exists {
		val := m.GetClusterIdentifierChoice()
		vOpts := append(opts,
			db.WithValidateField("cluster_identifier_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetClusterIdentifierChoice().(type) {
	case *ReplaceSpecType_NoClusterId:
		if fv, exists := v.FldValidators["cluster_identifier_choice.no_cluster_id"]; exists {
			val := m.GetClusterIdentifierChoice().(*ReplaceSpecType_NoClusterId).NoClusterId
			vOpts := append(opts,
				db.WithValidateField("cluster_identifier_choice"),
				db.WithValidateField("no_cluster_id"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_ClusterId:
		if fv, exists := v.FldValidators["cluster_identifier_choice.cluster_id"]; exists {
			val := m.GetClusterIdentifierChoice().(*ReplaceSpecType_ClusterId).ClusterId
			vOpts := append(opts,
				db.WithValidateField("cluster_identifier_choice"),
				db.WithValidateField("cluster_id"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["discovery_choice"]; exists {
		val := m.GetDiscoveryChoice()
		vOpts := append(opts,
			db.WithValidateField("discovery_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDiscoveryChoice().(type) {
	case *ReplaceSpecType_DiscoveryK8S:
		if fv, exists := v.FldValidators["discovery_choice.discovery_k8s"]; exists {
			val := m.GetDiscoveryChoice().(*ReplaceSpecType_DiscoveryK8S).DiscoveryK8S
			vOpts := append(opts,
				db.WithValidateField("discovery_choice"),
				db.WithValidateField("discovery_k8s"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_DiscoveryConsul:
		if fv, exists := v.FldValidators["discovery_choice.discovery_consul"]; exists {
			val := m.GetDiscoveryChoice().(*ReplaceSpecType_DiscoveryConsul).DiscoveryConsul
			vOpts := append(opts,
				db.WithValidateField("discovery_choice"),
				db.WithValidateField("discovery_consul"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_DiscoveryCbip:
		if fv, exists := v.FldValidators["discovery_choice.discovery_cbip"]; exists {
			val := m.GetDiscoveryChoice().(*ReplaceSpecType_DiscoveryCbip).DiscoveryCbip
			vOpts := append(opts,
				db.WithValidateField("discovery_choice"),
				db.WithValidateField("discovery_cbip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["where"]; exists {

		vOpts := append(opts, db.WithValidateField("where"))
		if err := fv(ctx, m.GetWhere(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhClusterIdentifierChoice := v.ClusterIdentifierChoiceValidationRuleHandler
	rulesClusterIdentifierChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhClusterIdentifierChoice(rulesClusterIdentifierChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.cluster_identifier_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cluster_identifier_choice"] = vFn

	vrhClusterIdentifierChoiceClusterId := v.ClusterIdentifierChoiceClusterIdValidationRuleHandler
	rulesClusterIdentifierChoiceClusterId := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFnMap["cluster_identifier_choice.cluster_id"], err = vrhClusterIdentifierChoiceClusterId(rulesClusterIdentifierChoiceClusterId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ReplaceSpecType.cluster_identifier_choice_cluster_id: %s", err)
		panic(errMsg)
	}

	v.FldValidators["cluster_identifier_choice.cluster_id"] = vFnMap["cluster_identifier_choice.cluster_id"]

	vrhDiscoveryChoice := v.DiscoveryChoiceValidationRuleHandler
	rulesDiscoveryChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDiscoveryChoice(rulesDiscoveryChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.discovery_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["discovery_choice"] = vFn

	vrhWhere := v.WhereValidationRuleHandler
	rulesWhere := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhWhere(rulesWhere)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.where: %s", err)
		panic(errMsg)
	}
	v.FldValidators["where"] = vFn

	v.FldValidators["discovery_choice.discovery_k8s"] = K8SDiscoveryTypeValidator().Validate
	v.FldValidators["discovery_choice.discovery_consul"] = ConsulDiscoveryTypeValidator().Validate
	v.FldValidators["discovery_choice.discovery_cbip"] = CbipDiscoveryTypeValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *RestConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RestConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *RestConfigType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetTlsInfo().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting RestConfigType.tls_info")
	}

	return nil
}

func (m *RestConfigType) DeepCopy() *RestConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RestConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RestConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RestConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RestConfigTypeValidator().Validate(ctx, m, opts...)
}

type ValidateRestConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRestConfigType) ApiServerValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for api_server")
	}

	return validatorFn, nil
}

func (v *ValidateRestConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RestConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RestConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_server"]; exists {

		vOpts := append(opts, db.WithValidateField("api_server"))
		if err := fv(ctx, m.GetApiServer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tls_info"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_info"))
		if err := fv(ctx, m.GetTlsInfo(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRestConfigTypeValidator = func() *ValidateRestConfigType {
	v := &ValidateRestConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhApiServer := v.ApiServerValidationRuleHandler
	rulesApiServer := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.hostport":  "true",
		"ves.io.schema.rules.string.max_len":   "262",
	}
	vFn, err = vrhApiServer(rulesApiServer)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RestConfigType.api_server: %s", err)
		panic(errMsg)
	}
	v.FldValidators["api_server"] = vFn

	v.FldValidators["tls_info"] = TLSClientConfigTypeValidator().Validate

	return v
}()

func RestConfigTypeValidator() db.Validator {
	return DefaultRestConfigTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TLSClientConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TLSClientConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *TLSClientConfigType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetCertificateUrl().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting TLSClientConfigType.certificate_url")
	}

	if err := m.GetKeyUrl().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting TLSClientConfigType.key_url")
	}

	if err := m.GetCaCertificateUrl().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting TLSClientConfigType.ca_certificate_url")
	}

	return nil
}

func (m *TLSClientConfigType) DeepCopy() *TLSClientConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TLSClientConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TLSClientConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TLSClientConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TLSClientConfigTypeValidator().Validate(ctx, m, opts...)
}

type ValidateTLSClientConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTLSClientConfigType) ServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for server_name")
	}

	return validatorFn, nil
}

func (v *ValidateTLSClientConfigType) CertificateValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for certificate")
	}

	return validatorFn, nil
}

func (v *ValidateTLSClientConfigType) TrustedCaUrlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for trusted_ca_url")
	}

	return validatorFn, nil
}

func (v *ValidateTLSClientConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TLSClientConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TLSClientConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ca_certificate_url"]; exists {

		vOpts := append(opts, db.WithValidateField("ca_certificate_url"))
		if err := fv(ctx, m.GetCaCertificateUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["certificate"]; exists {

		vOpts := append(opts, db.WithValidateField("certificate"))
		if err := fv(ctx, m.GetCertificate(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["certificate_url"]; exists {

		vOpts := append(opts, db.WithValidateField("certificate_url"))
		if err := fv(ctx, m.GetCertificateUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["key_url"]; exists {

		vOpts := append(opts, db.WithValidateField("key_url"))
		if err := fv(ctx, m.GetKeyUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["server_name"]; exists {

		vOpts := append(opts, db.WithValidateField("server_name"))
		if err := fv(ctx, m.GetServerName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["trusted_ca_url"]; exists {

		vOpts := append(opts, db.WithValidateField("trusted_ca_url"))
		if err := fv(ctx, m.GetTrustedCaUrl(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTLSClientConfigTypeValidator = func() *ValidateTLSClientConfigType {
	v := &ValidateTLSClientConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhServerName := v.ServerNameValidationRuleHandler
	rulesServerName := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
		"ves.io.schema.rules.string.max_len":  "256",
	}
	vFn, err = vrhServerName(rulesServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TLSClientConfigType.server_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["server_name"] = vFn

	vrhCertificate := v.CertificateValidationRuleHandler
	rulesCertificate := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "131072",
		"ves.io.schema.rules.string.uri_ref":   "true",
	}
	vFn, err = vrhCertificate(rulesCertificate)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TLSClientConfigType.certificate: %s", err)
		panic(errMsg)
	}
	v.FldValidators["certificate"] = vFn

	vrhTrustedCaUrl := v.TrustedCaUrlValidationRuleHandler
	rulesTrustedCaUrl := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "131072",
		"ves.io.schema.rules.string.uri_ref":   "true",
	}
	vFn, err = vrhTrustedCaUrl(rulesTrustedCaUrl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TLSClientConfigType.trusted_ca_url: %s", err)
		panic(errMsg)
	}
	v.FldValidators["trusted_ca_url"] = vFn

	v.FldValidators["certificate_url"] = ves_io_schema.SecretTypeValidator().Validate

	v.FldValidators["key_url"] = ves_io_schema.SecretTypeValidator().Validate

	v.FldValidators["ca_certificate_url"] = ves_io_schema.SecretTypeValidator().Validate

	return v
}()

func TLSClientConfigTypeValidator() db.Validator {
	return DefaultTLSClientConfigTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VerStatusType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VerStatusType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VerStatusType) DeepCopy() *VerStatusType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VerStatusType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VerStatusType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VerStatusType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VerStatusTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVerStatusType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVerStatusType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VerStatusType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VerStatusType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["connected"]; exists {

		vOpts := append(opts, db.WithValidateField("connected"))
		if err := fv(ctx, m.GetConnected(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["services"]; exists {

		vOpts := append(opts, db.WithValidateField("services"))
		for idx, item := range m.GetServices() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVerStatusTypeValidator = func() *ValidateVerStatusType {
	v := &ValidateVerStatusType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["services"] = DiscoveredServiceTypeValidator().Validate

	return v
}()

func VerStatusTypeValidator() db.Validator {
	return DefaultVerStatusTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VipDiscoveryInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VipDiscoveryInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VipDiscoveryInfoType) DeepCopy() *VipDiscoveryInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VipDiscoveryInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VipDiscoveryInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VipDiscoveryInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VipDiscoveryInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVipDiscoveryInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVipDiscoveryInfoType) SubdomainValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for subdomain")
	}

	return validatorFn, nil
}

func (v *ValidateVipDiscoveryInfoType) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateVipDiscoveryInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VipDiscoveryInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VipDiscoveryInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["dns_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_mode"))
		if err := fv(ctx, m.GetDnsMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["publish_virtual_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("publish_virtual_ip"))
		if err := fv(ctx, m.GetPublishVirtualIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["subdomain"]; exists {

		vOpts := append(opts, db.WithValidateField("subdomain"))
		if err := fv(ctx, m.GetSubdomain(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVipDiscoveryInfoTypeValidator = func() *ValidateVipDiscoveryInfoType {
	v := &ValidateVipDiscoveryInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSubdomain := v.SubdomainValidationRuleHandler
	rulesSubdomain := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhSubdomain(rulesSubdomain)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VipDiscoveryInfoType.subdomain: %s", err)
		panic(errMsg)
	}
	v.FldValidators["subdomain"] = vFn

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VipDiscoveryInfoType.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	return v
}()

func VipDiscoveryInfoTypeValidator() db.Validator {
	return DefaultVipDiscoveryInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VirtualServerFilter) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VirtualServerFilter) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VirtualServerFilter) DeepCopy() *VirtualServerFilter {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VirtualServerFilter{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VirtualServerFilter) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VirtualServerFilter) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VirtualServerFilterValidator().Validate(ctx, m, opts...)
}

type ValidateVirtualServerFilter struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVirtualServerFilter) NameRegexValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name_regex")
	}

	return validatorFn, nil
}

func (v *ValidateVirtualServerFilter) DescriptionRegexValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for description_regex")
	}

	return validatorFn, nil
}

func (v *ValidateVirtualServerFilter) ProtocolsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for protocols")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for protocols")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated protocols")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items protocols")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateVirtualServerFilter) PortRangesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port_ranges")
	}

	return validatorFn, nil
}

func (v *ValidateVirtualServerFilter) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VirtualServerFilter)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VirtualServerFilter got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["description_regex"]; exists {

		vOpts := append(opts, db.WithValidateField("description_regex"))
		if err := fv(ctx, m.GetDescriptionRegex(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["discover_disabled_virtual_servers"]; exists {

		vOpts := append(opts, db.WithValidateField("discover_disabled_virtual_servers"))
		if err := fv(ctx, m.GetDiscoverDisabledVirtualServers(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name_regex"]; exists {

		vOpts := append(opts, db.WithValidateField("name_regex"))
		if err := fv(ctx, m.GetNameRegex(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["port_ranges"]; exists {

		vOpts := append(opts, db.WithValidateField("port_ranges"))
		if err := fv(ctx, m.GetPortRanges(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["protocols"]; exists {
		vOpts := append(opts, db.WithValidateField("protocols"))
		if err := fv(ctx, m.GetProtocols(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVirtualServerFilterValidator = func() *ValidateVirtualServerFilter {
	v := &ValidateVirtualServerFilter{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNameRegex := v.NameRegexValidationRuleHandler
	rulesNameRegex := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.regex":   "true",
	}
	vFn, err = vrhNameRegex(rulesNameRegex)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VirtualServerFilter.name_regex: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name_regex"] = vFn

	vrhDescriptionRegex := v.DescriptionRegexValidationRuleHandler
	rulesDescriptionRegex := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.regex":   "true",
	}
	vFn, err = vrhDescriptionRegex(rulesDescriptionRegex)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VirtualServerFilter.description_regex: %s", err)
		panic(errMsg)
	}
	v.FldValidators["description_regex"] = vFn

	vrhProtocols := v.ProtocolsValidationRuleHandler
	rulesProtocols := map[string]string{
		"ves.io.schema.rules.repeated.unique": "true",
		"ves.io.schema.rules.string.in":       "[\"HTTPS\",\"HTTP\",\"TCP\"]",
	}
	vFn, err = vrhProtocols(rulesProtocols)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VirtualServerFilter.protocols: %s", err)
		panic(errMsg)
	}
	v.FldValidators["protocols"] = vFn

	vrhPortRanges := v.PortRangesValidationRuleHandler
	rulesPortRanges := map[string]string{
		"ves.io.schema.rules.string.max_len":                "512",
		"ves.io.schema.rules.string.max_ports":              "1024",
		"ves.io.schema.rules.string.unique_port_range_list": "true",
	}
	vFn, err = vrhPortRanges(rulesPortRanges)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VirtualServerFilter.port_ranges: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port_ranges"] = vFn

	return v
}()

func VirtualServerFilterValidator() db.Validator {
	return DefaultVirtualServerFilterValidator
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetClusterIdentifierChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ClusterIdentifierChoice.(type) {
	case nil:
		o.ClusterIdentifierChoice = nil

	case *CreateSpecType_ClusterId:
		o.ClusterIdentifierChoice = &GlobalSpecType_ClusterId{ClusterId: of.ClusterId}

	case *CreateSpecType_NoClusterId:
		o.ClusterIdentifierChoice = &GlobalSpecType_NoClusterId{NoClusterId: of.NoClusterId}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetClusterIdentifierChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ClusterIdentifierChoice.(type) {
	case nil:
		r.ClusterIdentifierChoice = nil

	case *GlobalSpecType_ClusterId:
		r.ClusterIdentifierChoice = &CreateSpecType_ClusterId{ClusterId: of.ClusterId}

	case *GlobalSpecType_NoClusterId:
		r.ClusterIdentifierChoice = &CreateSpecType_NoClusterId{NoClusterId: of.NoClusterId}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetDiscoveryChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DiscoveryChoice.(type) {
	case nil:
		o.DiscoveryChoice = nil

	case *CreateSpecType_DiscoveryCbip:
		o.DiscoveryChoice = &GlobalSpecType_DiscoveryCbip{DiscoveryCbip: of.DiscoveryCbip}

	case *CreateSpecType_DiscoveryConsul:
		o.DiscoveryChoice = &GlobalSpecType_DiscoveryConsul{DiscoveryConsul: of.DiscoveryConsul}

	case *CreateSpecType_DiscoveryK8S:
		o.DiscoveryChoice = &GlobalSpecType_DiscoveryK8S{DiscoveryK8S: of.DiscoveryK8S}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetDiscoveryChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DiscoveryChoice.(type) {
	case nil:
		r.DiscoveryChoice = nil

	case *GlobalSpecType_DiscoveryCbip:
		r.DiscoveryChoice = &CreateSpecType_DiscoveryCbip{DiscoveryCbip: of.DiscoveryCbip}

	case *GlobalSpecType_DiscoveryConsul:
		r.DiscoveryChoice = &CreateSpecType_DiscoveryConsul{DiscoveryConsul: of.DiscoveryConsul}

	case *GlobalSpecType_DiscoveryK8S:
		r.DiscoveryChoice = &CreateSpecType_DiscoveryK8S{DiscoveryK8S: of.DiscoveryK8S}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *CreateSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.GetClusterIdentifierChoiceFromGlobalSpecType(f)
	m.GetDiscoveryChoiceFromGlobalSpecType(f)
	m.Where = f.GetWhere()
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *CreateSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *CreateSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	m1.SetClusterIdentifierChoiceToGlobalSpecType(f)
	m1.SetDiscoveryChoiceToGlobalSpecType(f)
	f.Where = m1.Where
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *CreateSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetClusterIdentifierChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ClusterIdentifierChoice.(type) {
	case nil:
		o.ClusterIdentifierChoice = nil

	case *GetSpecType_ClusterId:
		o.ClusterIdentifierChoice = &GlobalSpecType_ClusterId{ClusterId: of.ClusterId}

	case *GetSpecType_NoClusterId:
		o.ClusterIdentifierChoice = &GlobalSpecType_NoClusterId{NoClusterId: of.NoClusterId}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetClusterIdentifierChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ClusterIdentifierChoice.(type) {
	case nil:
		r.ClusterIdentifierChoice = nil

	case *GlobalSpecType_ClusterId:
		r.ClusterIdentifierChoice = &GetSpecType_ClusterId{ClusterId: of.ClusterId}

	case *GlobalSpecType_NoClusterId:
		r.ClusterIdentifierChoice = &GetSpecType_NoClusterId{NoClusterId: of.NoClusterId}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetDiscoveryChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DiscoveryChoice.(type) {
	case nil:
		o.DiscoveryChoice = nil

	case *GetSpecType_DiscoveryCbip:
		o.DiscoveryChoice = &GlobalSpecType_DiscoveryCbip{DiscoveryCbip: of.DiscoveryCbip}

	case *GetSpecType_DiscoveryConsul:
		o.DiscoveryChoice = &GlobalSpecType_DiscoveryConsul{DiscoveryConsul: of.DiscoveryConsul}

	case *GetSpecType_DiscoveryK8S:
		o.DiscoveryChoice = &GlobalSpecType_DiscoveryK8S{DiscoveryK8S: of.DiscoveryK8S}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetDiscoveryChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DiscoveryChoice.(type) {
	case nil:
		r.DiscoveryChoice = nil

	case *GlobalSpecType_DiscoveryCbip:
		r.DiscoveryChoice = &GetSpecType_DiscoveryCbip{DiscoveryCbip: of.DiscoveryCbip}

	case *GlobalSpecType_DiscoveryConsul:
		r.DiscoveryChoice = &GetSpecType_DiscoveryConsul{DiscoveryConsul: of.DiscoveryConsul}

	case *GlobalSpecType_DiscoveryK8S:
		r.DiscoveryChoice = &GetSpecType_DiscoveryK8S{DiscoveryK8S: of.DiscoveryK8S}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *GetSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.GetClusterIdentifierChoiceFromGlobalSpecType(f)
	m.GetDiscoveryChoiceFromGlobalSpecType(f)
	m.PublishVip = f.GetPublishVip()
	m.Type = f.GetType()
	m.Where = f.GetWhere()
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *GetSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *GetSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	m1.SetClusterIdentifierChoiceToGlobalSpecType(f)
	m1.SetDiscoveryChoiceToGlobalSpecType(f)
	f.PublishVip = m1.PublishVip
	f.Type = m1.Type
	f.Where = m1.Where
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *GetSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetClusterIdentifierChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ClusterIdentifierChoice.(type) {
	case nil:
		o.ClusterIdentifierChoice = nil

	case *ReplaceSpecType_ClusterId:
		o.ClusterIdentifierChoice = &GlobalSpecType_ClusterId{ClusterId: of.ClusterId}

	case *ReplaceSpecType_NoClusterId:
		o.ClusterIdentifierChoice = &GlobalSpecType_NoClusterId{NoClusterId: of.NoClusterId}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetClusterIdentifierChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ClusterIdentifierChoice.(type) {
	case nil:
		r.ClusterIdentifierChoice = nil

	case *GlobalSpecType_ClusterId:
		r.ClusterIdentifierChoice = &ReplaceSpecType_ClusterId{ClusterId: of.ClusterId}

	case *GlobalSpecType_NoClusterId:
		r.ClusterIdentifierChoice = &ReplaceSpecType_NoClusterId{NoClusterId: of.NoClusterId}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetDiscoveryChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DiscoveryChoice.(type) {
	case nil:
		o.DiscoveryChoice = nil

	case *ReplaceSpecType_DiscoveryCbip:
		o.DiscoveryChoice = &GlobalSpecType_DiscoveryCbip{DiscoveryCbip: of.DiscoveryCbip}

	case *ReplaceSpecType_DiscoveryConsul:
		o.DiscoveryChoice = &GlobalSpecType_DiscoveryConsul{DiscoveryConsul: of.DiscoveryConsul}

	case *ReplaceSpecType_DiscoveryK8S:
		o.DiscoveryChoice = &GlobalSpecType_DiscoveryK8S{DiscoveryK8S: of.DiscoveryK8S}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetDiscoveryChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DiscoveryChoice.(type) {
	case nil:
		r.DiscoveryChoice = nil

	case *GlobalSpecType_DiscoveryCbip:
		r.DiscoveryChoice = &ReplaceSpecType_DiscoveryCbip{DiscoveryCbip: of.DiscoveryCbip}

	case *GlobalSpecType_DiscoveryConsul:
		r.DiscoveryChoice = &ReplaceSpecType_DiscoveryConsul{DiscoveryConsul: of.DiscoveryConsul}

	case *GlobalSpecType_DiscoveryK8S:
		r.DiscoveryChoice = &ReplaceSpecType_DiscoveryK8S{DiscoveryK8S: of.DiscoveryK8S}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *ReplaceSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.GetClusterIdentifierChoiceFromGlobalSpecType(f)
	m.GetDiscoveryChoiceFromGlobalSpecType(f)
	m.Where = f.GetWhere()
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	m1.SetClusterIdentifierChoiceToGlobalSpecType(f)
	m1.SetDiscoveryChoiceToGlobalSpecType(f)
	f.Where = m1.Where
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}
