// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/discovery/types.proto

package discovery

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// REST scheme
//
// x-displayName: "Scheme"
// Scheme to use when doing REST API to discovery server
type SchemeType int32

const (
	// x-displayName: "HTTP"
	// http:// Scheme
	HTTP SchemeType = 0
	// x-displayName: "HTTPS"
	// https:// Scheme
	HTTPS SchemeType = 1
)

var SchemeType_name = map[int32]string{
	0: "HTTP",
	1: "HTTPS",
}

var SchemeType_value = map[string]int32{
	"HTTP":  0,
	"HTTPS": 1,
}

func (SchemeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{0}
}

// VirtualIPDiscoveryType
//
// x-displayName: "Virtual IP Discovery"
// How is the Virtual IP discovery done
// Two modes are possible
//
//	DNS_DELEGATION: Program DNS delegation for a sub-domain in external K8s cluster
//	PUBLISH_SERVICE: Create/Register a service in external K8s/consul cluster
type VirtualIPDiscoveryType int32

const (
	// x-displayName: "DNS Delegation"
	// DNS sub domain is delegated to volterra site.
	DNS_DELEGATION VirtualIPDiscoveryType = 0
	// x-displayName: "Publish"
	// Name to VIP mapping is published in external discovery service
	PUBLISH_SERVICE VirtualIPDiscoveryType = 1
)

var VirtualIPDiscoveryType_name = map[int32]string{
	0: "DNS_DELEGATION",
	1: "PUBLISH_SERVICE",
}

var VirtualIPDiscoveryType_value = map[string]int32{
	"DNS_DELEGATION":  0,
	"PUBLISH_SERVICE": 1,
}

func (VirtualIPDiscoveryType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{1}
}

// K8SDNSMode
//
// x-displayName: "DNS Mode"
// Two modes are possible
type K8SDNSMode int32

const (
	// x-displayName: "Core DNS"
	// CoreDNS: Whether external K8s cluster is running core-dns
	CORE_DNS K8SDNSMode = 0
	// x-displayName: "K8s DNS"
	// KubeDNS: External K8s cluster is running kube-dns
	KUBE_DNS K8SDNSMode = 1
)

var K8SDNSMode_name = map[int32]string{
	0: "CORE_DNS",
	1: "KUBE_DNS",
}

var K8SDNSMode_value = map[string]int32{
	"CORE_DNS": 0,
	"KUBE_DNS": 1,
}

func (K8SDNSMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{2}
}

// VER status for k8s and consul Discovery
//
// x-displayName: "VER Status"
// This VER status is per site on which discovery is happening and it lists all services that site has discovered.
type VerStatusType struct {
	// Connection status
	//
	// x-displayName: "Connection Status"
	// Indicates connection status to external discovery service
	Connected bool `protobuf:"varint,1,opt,name=connected,proto3" json:"connected,omitempty"`
	// Origin site
	//
	// x-displayName: "Site"
	// Name of the site that reported this status
	Site string `protobuf:"bytes,2,opt,name=site,proto3" json:"site,omitempty"`
	// Type of discovery
	//
	// x-displayName: "External Discovery"
	// Service discovery type. Possible values are K8S and Consul
	Type schema.DiscoveryType `protobuf:"varint,3,opt,name=type,proto3,enum=ves.io.schema.DiscoveryType" json:"type,omitempty"`
	// Discovered Services
	//
	// x-displayName: "Discovered Services"
	// List of discovered services
	Services []*DiscoveredServiceType `protobuf:"bytes,4,rep,name=services,proto3" json:"services,omitempty"`
}

func (m *VerStatusType) Reset()      { *m = VerStatusType{} }
func (*VerStatusType) ProtoMessage() {}
func (*VerStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{0}
}
func (m *VerStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VerStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerStatusType.Merge(m, src)
}
func (m *VerStatusType) XXX_Size() int {
	return m.Size()
}
func (m *VerStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_VerStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_VerStatusType proto.InternalMessageInfo

func (m *VerStatusType) GetConnected() bool {
	if m != nil {
		return m.Connected
	}
	return false
}

func (m *VerStatusType) GetSite() string {
	if m != nil {
		return m.Site
	}
	return ""
}

func (m *VerStatusType) GetType() schema.DiscoveryType {
	if m != nil {
		return m.Type
	}
	return schema.INVALID_DISCOVERY
}

func (m *VerStatusType) GetServices() []*DiscoveredServiceType {
	if m != nil {
		return m.Services
	}
	return nil
}

// Pod info
//
// x-displayName: "POD"
// Information about POD providing the service
type PodInfoType struct {
	// POD name
	//
	// x-example: "mypod-nk8wr"
	// x-displayName: "Name"
	// Name of the Pod
	PodName string `protobuf:"bytes,1,opt,name=pod_name,json=podName,proto3" json:"pod_name,omitempty"`
	// IP Address
	//
	// x-displayName: "IP"
	// x-example: "192.1.2.3"
	// IP Address of the POD
	Ip string `protobuf:"bytes,2,opt,name=ip,proto3" json:"ip,omitempty"`
}

func (m *PodInfoType) Reset()      { *m = PodInfoType{} }
func (*PodInfoType) ProtoMessage() {}
func (*PodInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{1}
}
func (m *PodInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PodInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodInfoType.Merge(m, src)
}
func (m *PodInfoType) XXX_Size() int {
	return m.Size()
}
func (m *PodInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_PodInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_PodInfoType proto.InternalMessageInfo

func (m *PodInfoType) GetPodName() string {
	if m != nil {
		return m.PodName
	}
	return ""
}

func (m *PodInfoType) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

// Port information
//
// x-displayName: "Port details"
// Information about port and protocol on which the service is provided
type PortInfoType struct {
	// Port
	//
	// x-displayName: "Port number"
	// x-required
	// x-example: "8080"
	// Port number on which the service is exposed
	Port uint32 `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty"`
	// Protocol
	//
	// x-displayName: "Protocol"
	// x-required
	// x-example: "TCP"
	// Protocol on which the service is exposed
	Protocol string `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// Target Port
	//
	// x-displayName: "Target Port number"
	// x-required
	// x-example: "8081"
	// Port on which the pods targeted by the service can be reached.
	// TargetPort of Kubernetes service when its type is ClusterIP.
	// NodePort of Kubernetes service when its type is NodePort.
	TargetPort uint32 `protobuf:"varint,3,opt,name=target_port,json=targetPort,proto3" json:"target_port,omitempty"`
}

func (m *PortInfoType) Reset()      { *m = PortInfoType{} }
func (*PortInfoType) ProtoMessage() {}
func (*PortInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{2}
}
func (m *PortInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PortInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortInfoType.Merge(m, src)
}
func (m *PortInfoType) XXX_Size() int {
	return m.Size()
}
func (m *PortInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_PortInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_PortInfoType proto.InternalMessageInfo

func (m *PortInfoType) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *PortInfoType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *PortInfoType) GetTargetPort() uint32 {
	if m != nil {
		return m.TargetPort
	}
	return 0
}

// Discovered Service
//
// x-displayName: "Service"
// Details of each Discovered Service
type DiscoveredServiceType struct {
	// Service name
	//
	// x-displayName: "Service"
	// x-example: "myservice"
	// Name of the discovered service
	ServiceName string `protobuf:"bytes,1,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "mynamespace"
	// Namespace of the discovered service
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Service Type
	//
	// x-displayName: "Type"
	// x-example: "NodePort"
	// Type of discovered service. Examples include "ClusterIP", "NodePort" etc
	ServiceType string `protobuf:"bytes,3,opt,name=service_type,json=serviceType,proto3" json:"service_type,omitempty"`
	// Service IP
	//
	// x-displayName: "IP"
	// x-example: "192.1.2.3"
	// IP Address of the service
	ClusterIp string `protobuf:"bytes,4,opt,name=cluster_ip,json=clusterIp,proto3" json:"cluster_ip,omitempty"`
	// Service labels
	//
	// x-displayName: "Labels"
	// Key value pairs defined as labels for the service
	Labels map[string]string `protobuf:"bytes,5,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// POD list
	//
	// x-displayName: "PODs"
	// List of pod-name to IP address mappings for the service
	Pods []*PodInfoType `protobuf:"bytes,6,rep,name=pods,proto3" json:"pods,omitempty"`
	// Port mapping
	//
	// x-displayName: "Port Mapping"
	// port number to target port mapping for ClusterIP service
	// port number to node-port mapping for NodePort service
	PortMap map[uint32]uint32 `protobuf:"bytes,7,rep,name=port_map,json=portMap,proto3" json:"port_map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"` // Deprecated: Do not use.
	// Port list
	//
	// x-displayName: "Ports"
	// List of ports along with protocol on which the service is exposed.
	Ports []*PortInfoType `protobuf:"bytes,8,rep,name=ports,proto3" json:"ports,omitempty"`
	// Service IPv6
	//
	// x-displayName: "IPv6"
	// x-example: "2001:0db8:85a3:0000:0000:8a2e:0370:7334"
	// IPv6 Address of the service
	ClusterIpv6 string `protobuf:"bytes,10,opt,name=cluster_ipv6,json=clusterIpv6,proto3" json:"cluster_ipv6,omitempty"`
}

func (m *DiscoveredServiceType) Reset()      { *m = DiscoveredServiceType{} }
func (*DiscoveredServiceType) ProtoMessage() {}
func (*DiscoveredServiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{3}
}
func (m *DiscoveredServiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiscoveredServiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DiscoveredServiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiscoveredServiceType.Merge(m, src)
}
func (m *DiscoveredServiceType) XXX_Size() int {
	return m.Size()
}
func (m *DiscoveredServiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_DiscoveredServiceType.DiscardUnknown(m)
}

var xxx_messageInfo_DiscoveredServiceType proto.InternalMessageInfo

func (m *DiscoveredServiceType) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *DiscoveredServiceType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *DiscoveredServiceType) GetServiceType() string {
	if m != nil {
		return m.ServiceType
	}
	return ""
}

func (m *DiscoveredServiceType) GetClusterIp() string {
	if m != nil {
		return m.ClusterIp
	}
	return ""
}

func (m *DiscoveredServiceType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *DiscoveredServiceType) GetPods() []*PodInfoType {
	if m != nil {
		return m.Pods
	}
	return nil
}

// Deprecated: Do not use.
func (m *DiscoveredServiceType) GetPortMap() map[uint32]uint32 {
	if m != nil {
		return m.PortMap
	}
	return nil
}

func (m *DiscoveredServiceType) GetPorts() []*PortInfoType {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *DiscoveredServiceType) GetClusterIpv6() string {
	if m != nil {
		return m.ClusterIpv6
	}
	return ""
}

// TLS config
//
// x-displayName: "Client TLS Config"
// TLS config for client of discovery service
type TLSClientConfigType struct {
	// Server Name
	//
	// x-displayName: "SNI name"
	// x-example: "k8s.acme.com"
	// ServerName is passed to the server for SNI and is used in the client to check server
	// certificates against. If ServerName is empty, the hostname used to contact the
	// server is used
	ServerName string `protobuf:"bytes,1,opt,name=server_name,json=serverName,proto3" json:"server_name,omitempty"`
	// Client credentials
	//
	// x-displayName: "Client Credentials"
	// F5XC Secret. URL to fetch the client certificate file
	CertificateUrl *schema.SecretType `protobuf:"bytes,2,opt,name=certificate_url,json=certificateUrl,proto3" json:"certificate_url,omitempty"` // Deprecated: Do not use.
	// The TLS certificate URL.
	//
	// x-displayName: "Client Certificate"
	// x-example: "value"
	// Client  certificate is PEM-encoded certificate or certificate-chain.
	Certificate string `protobuf:"bytes,5,opt,name=certificate,proto3" json:"certificate,omitempty"`
	// Private Key
	//
	// x-displayName: "Client Private Key"
	// Client private key file containing data in PEM format including the PEM headers.
	// The data in this key file has to match accompanying certificate.
	// The data may be optionally secured using BlindFold.
	KeyUrl *schema.SecretType `protobuf:"bytes,3,opt,name=key_url,json=keyUrl,proto3" json:"key_url,omitempty"`
	// Server CA certificates
	//
	// x-displayName: "Server CA Certificates"
	// F5XC Secret. URL to fetch the server CA certificate file
	CaCertificateUrl *schema.SecretType `protobuf:"bytes,4,opt,name=ca_certificate_url,json=caCertificateUrl,proto3" json:"ca_certificate_url,omitempty"` // Deprecated: Do not use.
	// Server CA certificates
	//
	// x-displayName: "Server CA Certificates"
	// x-example: "value"
	// The URL or value for trusted Server CA certificate or certificate chain
	// Certificates in PEM format including the PEM headers.
	TrustedCaUrl string `protobuf:"bytes,6,opt,name=trusted_ca_url,json=trustedCaUrl,proto3" json:"trusted_ca_url,omitempty"`
}

func (m *TLSClientConfigType) Reset()      { *m = TLSClientConfigType{} }
func (*TLSClientConfigType) ProtoMessage() {}
func (*TLSClientConfigType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{4}
}
func (m *TLSClientConfigType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLSClientConfigType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TLSClientConfigType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSClientConfigType.Merge(m, src)
}
func (m *TLSClientConfigType) XXX_Size() int {
	return m.Size()
}
func (m *TLSClientConfigType) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSClientConfigType.DiscardUnknown(m)
}

var xxx_messageInfo_TLSClientConfigType proto.InternalMessageInfo

func (m *TLSClientConfigType) GetServerName() string {
	if m != nil {
		return m.ServerName
	}
	return ""
}

// Deprecated: Do not use.
func (m *TLSClientConfigType) GetCertificateUrl() *schema.SecretType {
	if m != nil {
		return m.CertificateUrl
	}
	return nil
}

func (m *TLSClientConfigType) GetCertificate() string {
	if m != nil {
		return m.Certificate
	}
	return ""
}

func (m *TLSClientConfigType) GetKeyUrl() *schema.SecretType {
	if m != nil {
		return m.KeyUrl
	}
	return nil
}

// Deprecated: Do not use.
func (m *TLSClientConfigType) GetCaCertificateUrl() *schema.SecretType {
	if m != nil {
		return m.CaCertificateUrl
	}
	return nil
}

func (m *TLSClientConfigType) GetTrustedCaUrl() string {
	if m != nil {
		return m.TrustedCaUrl
	}
	return ""
}

// REST API config
//
// x-displayName: "REST API Config"
// Configuration details to access discovery service rest API.
type RestConfigType struct {
	// Discovery Service API server
	//
	// x-displayName: "API Server and Port"
	// x-required
	// x-example: "api.acme.com:4430"
	// API server must be a fully qualified domain string and port specified as host:port pair
	ApiServer string `protobuf:"bytes,1,opt,name=api_server,json=apiServer,proto3" json:"api_server,omitempty"`
	// TLS parameters
	//
	// x-displayName: "TLS Parameters"
	// TLS settings to enable transport layer security
	TlsInfo *TLSClientConfigType `protobuf:"bytes,2,opt,name=tls_info,json=tlsInfo,proto3" json:"tls_info,omitempty"`
}

func (m *RestConfigType) Reset()      { *m = RestConfigType{} }
func (*RestConfigType) ProtoMessage() {}
func (*RestConfigType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{5}
}
func (m *RestConfigType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestConfigType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RestConfigType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestConfigType.Merge(m, src)
}
func (m *RestConfigType) XXX_Size() int {
	return m.Size()
}
func (m *RestConfigType) XXX_DiscardUnknown() {
	xxx_messageInfo_RestConfigType.DiscardUnknown(m)
}

var xxx_messageInfo_RestConfigType proto.InternalMessageInfo

func (m *RestConfigType) GetApiServer() string {
	if m != nil {
		return m.ApiServer
	}
	return ""
}

func (m *RestConfigType) GetTlsInfo() *TLSClientConfigType {
	if m != nil {
		return m.TlsInfo
	}
	return nil
}

// K8S access info
//
// x-displayName: "K8s API Server"
// K8S API server access
type K8SAccessInfo struct {
	// Oneof for K8s config
	//
	// x-displayName: "Select Kubernetes Credentials"
	// x-required
	// Kubernetes credentials can be kubeconfig or TLS param
	//
	// Types that are valid to be assigned to ConfigType:
	//	*K8SAccessInfo_KubeconfigUrl
	//	*K8SAccessInfo_ConnectionInfo
	//	*K8SAccessInfo_InCluster
	ConfigType isK8SAccessInfo_ConfigType `protobuf_oneof:"config_type"`
	// Kubernetes Network reachability
	//
	// x-displayName: "Kubernetes POD network reachability"
	// x-required
	// Specify which IP addresses to discover from Kubernetes services based
	// on reachability of Kubernetes POD
	//
	// Types that are valid to be assigned to K8SPodNetworkChoice:
	//	*K8SAccessInfo_Isolated
	//	*K8SAccessInfo_Reachable
	K8SPodNetworkChoice isK8SAccessInfo_K8SPodNetworkChoice `protobuf_oneof:"k8s_pod_network_choice"`
}

func (m *K8SAccessInfo) Reset()      { *m = K8SAccessInfo{} }
func (*K8SAccessInfo) ProtoMessage() {}
func (*K8SAccessInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{6}
}
func (m *K8SAccessInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *K8SAccessInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *K8SAccessInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K8SAccessInfo.Merge(m, src)
}
func (m *K8SAccessInfo) XXX_Size() int {
	return m.Size()
}
func (m *K8SAccessInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_K8SAccessInfo.DiscardUnknown(m)
}

var xxx_messageInfo_K8SAccessInfo proto.InternalMessageInfo

type isK8SAccessInfo_ConfigType interface {
	isK8SAccessInfo_ConfigType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isK8SAccessInfo_K8SPodNetworkChoice interface {
	isK8SAccessInfo_K8SPodNetworkChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type K8SAccessInfo_KubeconfigUrl struct {
	KubeconfigUrl *schema.SecretType `protobuf:"bytes,1,opt,name=kubeconfig_url,json=kubeconfigUrl,proto3,oneof" json:"kubeconfig_url,omitempty"`
}
type K8SAccessInfo_ConnectionInfo struct {
	ConnectionInfo *RestConfigType `protobuf:"bytes,2,opt,name=connection_info,json=connectionInfo,proto3,oneof" json:"connection_info,omitempty"`
}
type K8SAccessInfo_InCluster struct {
	InCluster bool `protobuf:"varint,3,opt,name=in_cluster,json=inCluster,proto3,oneof" json:"in_cluster,omitempty"`
}
type K8SAccessInfo_Isolated struct {
	Isolated *schema.Empty `protobuf:"bytes,4,opt,name=isolated,proto3,oneof" json:"isolated,omitempty"`
}
type K8SAccessInfo_Reachable struct {
	Reachable *schema.Empty `protobuf:"bytes,5,opt,name=reachable,proto3,oneof" json:"reachable,omitempty"`
}

func (*K8SAccessInfo_KubeconfigUrl) isK8SAccessInfo_ConfigType()      {}
func (*K8SAccessInfo_ConnectionInfo) isK8SAccessInfo_ConfigType()     {}
func (*K8SAccessInfo_InCluster) isK8SAccessInfo_ConfigType()          {}
func (*K8SAccessInfo_Isolated) isK8SAccessInfo_K8SPodNetworkChoice()  {}
func (*K8SAccessInfo_Reachable) isK8SAccessInfo_K8SPodNetworkChoice() {}

func (m *K8SAccessInfo) GetConfigType() isK8SAccessInfo_ConfigType {
	if m != nil {
		return m.ConfigType
	}
	return nil
}
func (m *K8SAccessInfo) GetK8SPodNetworkChoice() isK8SAccessInfo_K8SPodNetworkChoice {
	if m != nil {
		return m.K8SPodNetworkChoice
	}
	return nil
}

func (m *K8SAccessInfo) GetKubeconfigUrl() *schema.SecretType {
	if x, ok := m.GetConfigType().(*K8SAccessInfo_KubeconfigUrl); ok {
		return x.KubeconfigUrl
	}
	return nil
}

func (m *K8SAccessInfo) GetConnectionInfo() *RestConfigType {
	if x, ok := m.GetConfigType().(*K8SAccessInfo_ConnectionInfo); ok {
		return x.ConnectionInfo
	}
	return nil
}

func (m *K8SAccessInfo) GetInCluster() bool {
	if x, ok := m.GetConfigType().(*K8SAccessInfo_InCluster); ok {
		return x.InCluster
	}
	return false
}

func (m *K8SAccessInfo) GetIsolated() *schema.Empty {
	if x, ok := m.GetK8SPodNetworkChoice().(*K8SAccessInfo_Isolated); ok {
		return x.Isolated
	}
	return nil
}

func (m *K8SAccessInfo) GetReachable() *schema.Empty {
	if x, ok := m.GetK8SPodNetworkChoice().(*K8SAccessInfo_Reachable); ok {
		return x.Reachable
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*K8SAccessInfo) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*K8SAccessInfo_KubeconfigUrl)(nil),
		(*K8SAccessInfo_ConnectionInfo)(nil),
		(*K8SAccessInfo_InCluster)(nil),
		(*K8SAccessInfo_Isolated)(nil),
		(*K8SAccessInfo_Reachable)(nil),
	}
}

// Hashicorp Consul Credentials
//
// x-displayName: "Hashicorp Consul Credentials"
// Authentication parameters to access Hashicorp Consul.
type ConsulHttpBasicAuthInfoType struct {
	// username
	//
	// x-displayName: "User Name"
	// x-example: "Joe"
	// username in consul
	UserName string `protobuf:"bytes,1,opt,name=user_name,json=userName,proto3" json:"user_name,omitempty"`
	// password
	//
	// x-displayName: "Password"
	// F5XC Secret. URL for password, needs to be fetched from this path
	PasswdUrl *schema.SecretType `protobuf:"bytes,2,opt,name=passwd_url,json=passwdUrl,proto3" json:"passwd_url,omitempty"`
}

func (m *ConsulHttpBasicAuthInfoType) Reset()      { *m = ConsulHttpBasicAuthInfoType{} }
func (*ConsulHttpBasicAuthInfoType) ProtoMessage() {}
func (*ConsulHttpBasicAuthInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{7}
}
func (m *ConsulHttpBasicAuthInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsulHttpBasicAuthInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConsulHttpBasicAuthInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsulHttpBasicAuthInfoType.Merge(m, src)
}
func (m *ConsulHttpBasicAuthInfoType) XXX_Size() int {
	return m.Size()
}
func (m *ConsulHttpBasicAuthInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsulHttpBasicAuthInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_ConsulHttpBasicAuthInfoType proto.InternalMessageInfo

func (m *ConsulHttpBasicAuthInfoType) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *ConsulHttpBasicAuthInfoType) GetPasswdUrl() *schema.SecretType {
	if m != nil {
		return m.PasswdUrl
	}
	return nil
}

// ConsulAccessInfo
//
// x-displayName: "Hashicorp Consul Parameters"
// Hashicorp Consul API server information
type ConsulAccessInfo struct {
	// Connection Parameters
	//
	// x-displayName: "Connection Parameters"
	// Configuration details to access Hashicorp Consul API service using REST.
	ConnectionInfo *RestConfigType `protobuf:"bytes,1,opt,name=connection_info,json=connectionInfo,proto3" json:"connection_info,omitempty"`
	// Scheme
	//
	// x-displayName: "Scheme"
	// scheme
	Scheme SchemeType `protobuf:"varint,2,opt,name=scheme,proto3,enum=ves.io.schema.discovery.SchemeType" json:"scheme,omitempty"` // Deprecated: Do not use.
	// Http authentication parameters
	//
	// x-displayName: "HTTP Authentication Parameters"
	// Username and password used for HTTP/HTTPS access
	HttpBasicAuthInfo *ConsulHttpBasicAuthInfoType `protobuf:"bytes,3,opt,name=http_basic_auth_info,json=httpBasicAuthInfo,proto3" json:"http_basic_auth_info,omitempty"`
}

func (m *ConsulAccessInfo) Reset()      { *m = ConsulAccessInfo{} }
func (*ConsulAccessInfo) ProtoMessage() {}
func (*ConsulAccessInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{8}
}
func (m *ConsulAccessInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsulAccessInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConsulAccessInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsulAccessInfo.Merge(m, src)
}
func (m *ConsulAccessInfo) XXX_Size() int {
	return m.Size()
}
func (m *ConsulAccessInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsulAccessInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ConsulAccessInfo proto.InternalMessageInfo

func (m *ConsulAccessInfo) GetConnectionInfo() *RestConfigType {
	if m != nil {
		return m.ConnectionInfo
	}
	return nil
}

// Deprecated: Do not use.
func (m *ConsulAccessInfo) GetScheme() SchemeType {
	if m != nil {
		return m.Scheme
	}
	return HTTP
}

func (m *ConsulAccessInfo) GetHttpBasicAuthInfo() *ConsulHttpBasicAuthInfoType {
	if m != nil {
		return m.HttpBasicAuthInfo
	}
	return nil
}

// VIP Discovery Info Type
//
// x-displayName: "VIP Publish Configuration"
// K8S Configuration to publish VIPs
type VipDiscoveryInfoType struct {
	// enable/disable publish VIP
	//
	// x-displayName: "VIP Publish Enable"
	// Are we publishing Virtual Host domains to Virtual IP mapping to external cluster
	PublishVirtualIp bool `protobuf:"varint,1,opt,name=publish_virtual_ip,json=publishVirtualIp,proto3" json:"publish_virtual_ip,omitempty"`
	// VIP publish method
	//
	// x-displayName: "VIP Publish Method"
	// How is Virtual IP discovery performed
	// Two modes are possible
	//   DNS_DELEGATION: Program DNS delegation for a sub-domain in external cluster
	//   PUBLISH_SERVICE: Create/Register a service in external K8s/consul cluster
	Type VirtualIPDiscoveryType `protobuf:"varint,2,opt,name=type,proto3,enum=ves.io.schema.discovery.VirtualIPDiscoveryType" json:"type,omitempty"`
	// DNS delegation sub-domain
	//
	// x-displayName: "Subdomain"
	// Subdomain for which DNS delegation is done
	// F5XC Edge Router will only respond for DNS queries on this sub-domain
	// While programming the DNS DELEGATE on external cluster, VER will take ownership of this
	// sub-domain
	Subdomain string `protobuf:"bytes,3,opt,name=subdomain,proto3" json:"subdomain,omitempty"`
	// DNS mode
	//
	// x-displayName: "DNS Mode"
	// When virtual IP is published with DNS delegation, this field indicates whether
	// external K8s is running core DNS or kube DNS
	DnsMode K8SDNSMode `protobuf:"varint,4,opt,name=dns_mode,json=dnsMode,proto3,enum=ves.io.schema.discovery.K8SDNSMode" json:"dns_mode,omitempty"`
	// default namespace
	//
	// x-displayName: "Default Namespace"
	// When virtual IP is published with "PUBLISH_SERVICE" mode, this field indicates the namespace
	// where the service/endpoints needs to be created if the domain name doesn't specify it
	// explicitly. K8S administrator of the external K8s should ensure this namespace is created
	Namespace string `protobuf:"bytes,5,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *VipDiscoveryInfoType) Reset()      { *m = VipDiscoveryInfoType{} }
func (*VipDiscoveryInfoType) ProtoMessage() {}
func (*VipDiscoveryInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{9}
}
func (m *VipDiscoveryInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VipDiscoveryInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VipDiscoveryInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VipDiscoveryInfoType.Merge(m, src)
}
func (m *VipDiscoveryInfoType) XXX_Size() int {
	return m.Size()
}
func (m *VipDiscoveryInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_VipDiscoveryInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_VipDiscoveryInfoType proto.InternalMessageInfo

func (m *VipDiscoveryInfoType) GetPublishVirtualIp() bool {
	if m != nil {
		return m.PublishVirtualIp
	}
	return false
}

func (m *VipDiscoveryInfoType) GetType() VirtualIPDiscoveryType {
	if m != nil {
		return m.Type
	}
	return DNS_DELEGATION
}

func (m *VipDiscoveryInfoType) GetSubdomain() string {
	if m != nil {
		return m.Subdomain
	}
	return ""
}

func (m *VipDiscoveryInfoType) GetDnsMode() K8SDNSMode {
	if m != nil {
		return m.DnsMode
	}
	return CORE_DNS
}

func (m *VipDiscoveryInfoType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// K8SPublishType
//
// x-displayName: "K8SPublishType"
type K8SPublishType struct {
	// namespace
	//
	// x-displayName: "Default Namespace"
	// x-required
	// x-example: "default"
	// The namespace where the service/endpoints need to be created if it's not included in the domain.
	// The external K8S administrator needs to ensure that the namespace exists.
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *K8SPublishType) Reset()      { *m = K8SPublishType{} }
func (*K8SPublishType) ProtoMessage() {}
func (*K8SPublishType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{10}
}
func (m *K8SPublishType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *K8SPublishType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *K8SPublishType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K8SPublishType.Merge(m, src)
}
func (m *K8SPublishType) XXX_Size() int {
	return m.Size()
}
func (m *K8SPublishType) XXX_DiscardUnknown() {
	xxx_messageInfo_K8SPublishType.DiscardUnknown(m)
}

var xxx_messageInfo_K8SPublishType proto.InternalMessageInfo

func (m *K8SPublishType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// K8SDelegationType
//
// x-displayName: "K8SDelegationType"
type K8SDelegationType struct {
	// subdomain
	//
	// x-displayName: "Subdomain"
	// x-example: "value"
	// x-required
	// The DNS subdomain for which F5XC will respond to DNS queries.
	Subdomain string `protobuf:"bytes,1,opt,name=subdomain,proto3" json:"subdomain,omitempty"`
	// DNS mode
	//
	// x-displayName: "DNS Mode"
	// x-required
	// Indicates whether external K8S is running core DNS or kube DNS
	DnsMode K8SDNSMode `protobuf:"varint,2,opt,name=dns_mode,json=dnsMode,proto3,enum=ves.io.schema.discovery.K8SDNSMode" json:"dns_mode,omitempty"`
}

func (m *K8SDelegationType) Reset()      { *m = K8SDelegationType{} }
func (*K8SDelegationType) ProtoMessage() {}
func (*K8SDelegationType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{11}
}
func (m *K8SDelegationType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *K8SDelegationType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *K8SDelegationType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K8SDelegationType.Merge(m, src)
}
func (m *K8SDelegationType) XXX_Size() int {
	return m.Size()
}
func (m *K8SDelegationType) XXX_DiscardUnknown() {
	xxx_messageInfo_K8SDelegationType.DiscardUnknown(m)
}

var xxx_messageInfo_K8SDelegationType proto.InternalMessageInfo

func (m *K8SDelegationType) GetSubdomain() string {
	if m != nil {
		return m.Subdomain
	}
	return ""
}

func (m *K8SDelegationType) GetDnsMode() K8SDNSMode {
	if m != nil {
		return m.DnsMode
	}
	return CORE_DNS
}

// K8S VIP Discovery Info Type
//
// x-displayName: "VIP Publish Configurations"
// K8S Configuration to publish VIPs
type K8SVipDiscoveryInfoType struct {
	// publish choice
	//
	// x-displayName: "Select VIP Publishing or DNS Delegation"
	// x-required
	// Select VIP Publishing or DNS Delegation
	//
	// Types that are valid to be assigned to PublishChoice:
	//	*K8SVipDiscoveryInfoType_Disable
	//	*K8SVipDiscoveryInfoType_Publish
	//	*K8SVipDiscoveryInfoType_PublishFqdns
	//	*K8SVipDiscoveryInfoType_DnsDelegation
	PublishChoice isK8SVipDiscoveryInfoType_PublishChoice `protobuf_oneof:"publish_choice"`
}

func (m *K8SVipDiscoveryInfoType) Reset()      { *m = K8SVipDiscoveryInfoType{} }
func (*K8SVipDiscoveryInfoType) ProtoMessage() {}
func (*K8SVipDiscoveryInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{12}
}
func (m *K8SVipDiscoveryInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *K8SVipDiscoveryInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *K8SVipDiscoveryInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K8SVipDiscoveryInfoType.Merge(m, src)
}
func (m *K8SVipDiscoveryInfoType) XXX_Size() int {
	return m.Size()
}
func (m *K8SVipDiscoveryInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_K8SVipDiscoveryInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_K8SVipDiscoveryInfoType proto.InternalMessageInfo

type isK8SVipDiscoveryInfoType_PublishChoice interface {
	isK8SVipDiscoveryInfoType_PublishChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type K8SVipDiscoveryInfoType_Disable struct {
	Disable *schema.Empty `protobuf:"bytes,2,opt,name=disable,proto3,oneof" json:"disable,omitempty"`
}
type K8SVipDiscoveryInfoType_Publish struct {
	Publish *K8SPublishType `protobuf:"bytes,3,opt,name=publish,proto3,oneof" json:"publish,omitempty"`
}
type K8SVipDiscoveryInfoType_PublishFqdns struct {
	PublishFqdns *schema.Empty `protobuf:"bytes,4,opt,name=publish_fqdns,json=publishFqdns,proto3,oneof" json:"publish_fqdns,omitempty"`
}
type K8SVipDiscoveryInfoType_DnsDelegation struct {
	DnsDelegation *K8SDelegationType `protobuf:"bytes,5,opt,name=dns_delegation,json=dnsDelegation,proto3,oneof" json:"dns_delegation,omitempty"`
}

func (*K8SVipDiscoveryInfoType_Disable) isK8SVipDiscoveryInfoType_PublishChoice()       {}
func (*K8SVipDiscoveryInfoType_Publish) isK8SVipDiscoveryInfoType_PublishChoice()       {}
func (*K8SVipDiscoveryInfoType_PublishFqdns) isK8SVipDiscoveryInfoType_PublishChoice()  {}
func (*K8SVipDiscoveryInfoType_DnsDelegation) isK8SVipDiscoveryInfoType_PublishChoice() {}

func (m *K8SVipDiscoveryInfoType) GetPublishChoice() isK8SVipDiscoveryInfoType_PublishChoice {
	if m != nil {
		return m.PublishChoice
	}
	return nil
}

func (m *K8SVipDiscoveryInfoType) GetDisable() *schema.Empty {
	if x, ok := m.GetPublishChoice().(*K8SVipDiscoveryInfoType_Disable); ok {
		return x.Disable
	}
	return nil
}

func (m *K8SVipDiscoveryInfoType) GetPublish() *K8SPublishType {
	if x, ok := m.GetPublishChoice().(*K8SVipDiscoveryInfoType_Publish); ok {
		return x.Publish
	}
	return nil
}

func (m *K8SVipDiscoveryInfoType) GetPublishFqdns() *schema.Empty {
	if x, ok := m.GetPublishChoice().(*K8SVipDiscoveryInfoType_PublishFqdns); ok {
		return x.PublishFqdns
	}
	return nil
}

func (m *K8SVipDiscoveryInfoType) GetDnsDelegation() *K8SDelegationType {
	if x, ok := m.GetPublishChoice().(*K8SVipDiscoveryInfoType_DnsDelegation); ok {
		return x.DnsDelegation
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*K8SVipDiscoveryInfoType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*K8SVipDiscoveryInfoType_Disable)(nil),
		(*K8SVipDiscoveryInfoType_Publish)(nil),
		(*K8SVipDiscoveryInfoType_PublishFqdns)(nil),
		(*K8SVipDiscoveryInfoType_DnsDelegation)(nil),
	}
}

// Consul VIP Discovery Info Type
//
// x-displayName: "VIP Publish Configuration"
// Consul Configuration to publish VIPs
type ConsulVipDiscoveryInfoType struct {
	// publish choice
	//
	// x-displayName: "Enable/Disable VIP Publishing"
	// x-required
	// Enable or disable VIP Publishing.
	//
	// Types that are valid to be assigned to PublishChoice:
	//	*ConsulVipDiscoveryInfoType_Disable
	//	*ConsulVipDiscoveryInfoType_Publish
	PublishChoice isConsulVipDiscoveryInfoType_PublishChoice `protobuf_oneof:"publish_choice"`
}

func (m *ConsulVipDiscoveryInfoType) Reset()      { *m = ConsulVipDiscoveryInfoType{} }
func (*ConsulVipDiscoveryInfoType) ProtoMessage() {}
func (*ConsulVipDiscoveryInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{13}
}
func (m *ConsulVipDiscoveryInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsulVipDiscoveryInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConsulVipDiscoveryInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsulVipDiscoveryInfoType.Merge(m, src)
}
func (m *ConsulVipDiscoveryInfoType) XXX_Size() int {
	return m.Size()
}
func (m *ConsulVipDiscoveryInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsulVipDiscoveryInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_ConsulVipDiscoveryInfoType proto.InternalMessageInfo

type isConsulVipDiscoveryInfoType_PublishChoice interface {
	isConsulVipDiscoveryInfoType_PublishChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ConsulVipDiscoveryInfoType_Disable struct {
	Disable *schema.Empty `protobuf:"bytes,2,opt,name=disable,proto3,oneof" json:"disable,omitempty"`
}
type ConsulVipDiscoveryInfoType_Publish struct {
	Publish *schema.Empty `protobuf:"bytes,3,opt,name=publish,proto3,oneof" json:"publish,omitempty"`
}

func (*ConsulVipDiscoveryInfoType_Disable) isConsulVipDiscoveryInfoType_PublishChoice() {}
func (*ConsulVipDiscoveryInfoType_Publish) isConsulVipDiscoveryInfoType_PublishChoice() {}

func (m *ConsulVipDiscoveryInfoType) GetPublishChoice() isConsulVipDiscoveryInfoType_PublishChoice {
	if m != nil {
		return m.PublishChoice
	}
	return nil
}

func (m *ConsulVipDiscoveryInfoType) GetDisable() *schema.Empty {
	if x, ok := m.GetPublishChoice().(*ConsulVipDiscoveryInfoType_Disable); ok {
		return x.Disable
	}
	return nil
}

func (m *ConsulVipDiscoveryInfoType) GetPublish() *schema.Empty {
	if x, ok := m.GetPublishChoice().(*ConsulVipDiscoveryInfoType_Publish); ok {
		return x.Publish
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ConsulVipDiscoveryInfoType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ConsulVipDiscoveryInfoType_Disable)(nil),
		(*ConsulVipDiscoveryInfoType_Publish)(nil),
	}
}

// K8s discovery type
//
// x-displayName: "K8S Discovery Configuration"
// Discovery configuration for K8s.
type K8SDiscoveryType struct {
	// Kubernetes Credentials
	//
	// x-displayName: "Access Credentials"
	// x-required
	// Credentials can be kubeconfig file or mTLS using PKI certificates
	AccessInfo *K8SAccessInfo `protobuf:"bytes,1,opt,name=access_info,json=accessInfo,proto3" json:"access_info,omitempty"`
	// publish info
	//
	// x-displayName: "VIP Publishing Configuration"
	// x-required
	// Configuration to publish VIPs
	PublishInfo *K8SVipDiscoveryInfoType `protobuf:"bytes,2,opt,name=publish_info,json=publishInfo,proto3" json:"publish_info,omitempty"`
	// Mapping Preference
	//
	// x-displayName: "Mapping Preference"
	// Select the mapping between K8s namespaces from which services will be discovered, and App Namespace to the discovered services will be shared.
	//
	// Types that are valid to be assigned to NamespaceMappingChoice:
	//	*K8SDiscoveryType_DefaultAll
	//	*K8SDiscoveryType_NamespaceMapping
	NamespaceMappingChoice isK8SDiscoveryType_NamespaceMappingChoice `protobuf_oneof:"namespace_mapping_choice"`
}

func (m *K8SDiscoveryType) Reset()      { *m = K8SDiscoveryType{} }
func (*K8SDiscoveryType) ProtoMessage() {}
func (*K8SDiscoveryType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{14}
}
func (m *K8SDiscoveryType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *K8SDiscoveryType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *K8SDiscoveryType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K8SDiscoveryType.Merge(m, src)
}
func (m *K8SDiscoveryType) XXX_Size() int {
	return m.Size()
}
func (m *K8SDiscoveryType) XXX_DiscardUnknown() {
	xxx_messageInfo_K8SDiscoveryType.DiscardUnknown(m)
}

var xxx_messageInfo_K8SDiscoveryType proto.InternalMessageInfo

type isK8SDiscoveryType_NamespaceMappingChoice interface {
	isK8SDiscoveryType_NamespaceMappingChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type K8SDiscoveryType_DefaultAll struct {
	DefaultAll *schema.Empty `protobuf:"bytes,4,opt,name=default_all,json=defaultAll,proto3,oneof" json:"default_all,omitempty"`
}
type K8SDiscoveryType_NamespaceMapping struct {
	NamespaceMapping *K8SNamespaceMapping `protobuf:"bytes,5,opt,name=namespace_mapping,json=namespaceMapping,proto3,oneof" json:"namespace_mapping,omitempty"`
}

func (*K8SDiscoveryType_DefaultAll) isK8SDiscoveryType_NamespaceMappingChoice()       {}
func (*K8SDiscoveryType_NamespaceMapping) isK8SDiscoveryType_NamespaceMappingChoice() {}

func (m *K8SDiscoveryType) GetNamespaceMappingChoice() isK8SDiscoveryType_NamespaceMappingChoice {
	if m != nil {
		return m.NamespaceMappingChoice
	}
	return nil
}

func (m *K8SDiscoveryType) GetAccessInfo() *K8SAccessInfo {
	if m != nil {
		return m.AccessInfo
	}
	return nil
}

func (m *K8SDiscoveryType) GetPublishInfo() *K8SVipDiscoveryInfoType {
	if m != nil {
		return m.PublishInfo
	}
	return nil
}

func (m *K8SDiscoveryType) GetDefaultAll() *schema.Empty {
	if x, ok := m.GetNamespaceMappingChoice().(*K8SDiscoveryType_DefaultAll); ok {
		return x.DefaultAll
	}
	return nil
}

func (m *K8SDiscoveryType) GetNamespaceMapping() *K8SNamespaceMapping {
	if x, ok := m.GetNamespaceMappingChoice().(*K8SDiscoveryType_NamespaceMapping); ok {
		return x.NamespaceMapping
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*K8SDiscoveryType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*K8SDiscoveryType_DefaultAll)(nil),
		(*K8SDiscoveryType_NamespaceMapping)(nil),
	}
}

// consul discovery type
//
// x-displayName: "Consul Discovery Configuration"
// Discovery configuration for Hashicorp Consul
type ConsulDiscoveryType struct {
	// Hashicorp Consul Credentials
	//
	// x-displayName: "Access Credentials"
	// x-required
	// Credentials to access Hashicorp Consul service discovery
	AccessInfo *ConsulAccessInfo `protobuf:"bytes,1,opt,name=access_info,json=accessInfo,proto3" json:"access_info,omitempty"`
	// publish info
	//
	// x-displayName: "VIP Publishing Configuration"
	// x-required
	// Configuration to publish VIPs
	PublishInfo *ConsulVipDiscoveryInfoType `protobuf:"bytes,2,opt,name=publish_info,json=publishInfo,proto3" json:"publish_info,omitempty"`
	// Mapping Preference
	//
	// x-displayName: "Mapping Preference"
	// Select the mapping between Consul namespaces from which services will be discovered, and App Namespace to the discovered services will be shared.
	//
	// Types that are valid to be assigned to NamespaceMappingChoice:
	//	*ConsulDiscoveryType_DefaultAll
	//	*ConsulDiscoveryType_NamespaceMapping
	NamespaceMappingChoice isConsulDiscoveryType_NamespaceMappingChoice `protobuf_oneof:"namespace_mapping_choice"`
}

func (m *ConsulDiscoveryType) Reset()      { *m = ConsulDiscoveryType{} }
func (*ConsulDiscoveryType) ProtoMessage() {}
func (*ConsulDiscoveryType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{15}
}
func (m *ConsulDiscoveryType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsulDiscoveryType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConsulDiscoveryType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsulDiscoveryType.Merge(m, src)
}
func (m *ConsulDiscoveryType) XXX_Size() int {
	return m.Size()
}
func (m *ConsulDiscoveryType) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsulDiscoveryType.DiscardUnknown(m)
}

var xxx_messageInfo_ConsulDiscoveryType proto.InternalMessageInfo

type isConsulDiscoveryType_NamespaceMappingChoice interface {
	isConsulDiscoveryType_NamespaceMappingChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ConsulDiscoveryType_DefaultAll struct {
	DefaultAll *schema.Empty `protobuf:"bytes,4,opt,name=default_all,json=defaultAll,proto3,oneof" json:"default_all,omitempty"`
}
type ConsulDiscoveryType_NamespaceMapping struct {
	NamespaceMapping *ConsulNamespaceMapping `protobuf:"bytes,5,opt,name=namespace_mapping,json=namespaceMapping,proto3,oneof" json:"namespace_mapping,omitempty"`
}

func (*ConsulDiscoveryType_DefaultAll) isConsulDiscoveryType_NamespaceMappingChoice()       {}
func (*ConsulDiscoveryType_NamespaceMapping) isConsulDiscoveryType_NamespaceMappingChoice() {}

func (m *ConsulDiscoveryType) GetNamespaceMappingChoice() isConsulDiscoveryType_NamespaceMappingChoice {
	if m != nil {
		return m.NamespaceMappingChoice
	}
	return nil
}

func (m *ConsulDiscoveryType) GetAccessInfo() *ConsulAccessInfo {
	if m != nil {
		return m.AccessInfo
	}
	return nil
}

func (m *ConsulDiscoveryType) GetPublishInfo() *ConsulVipDiscoveryInfoType {
	if m != nil {
		return m.PublishInfo
	}
	return nil
}

// Deprecated: Do not use.
func (m *ConsulDiscoveryType) GetDefaultAll() *schema.Empty {
	if x, ok := m.GetNamespaceMappingChoice().(*ConsulDiscoveryType_DefaultAll); ok {
		return x.DefaultAll
	}
	return nil
}

// Deprecated: Do not use.
func (m *ConsulDiscoveryType) GetNamespaceMapping() *ConsulNamespaceMapping {
	if x, ok := m.GetNamespaceMappingChoice().(*ConsulDiscoveryType_NamespaceMapping); ok {
		return x.NamespaceMapping
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ConsulDiscoveryType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ConsulDiscoveryType_DefaultAll)(nil),
		(*ConsulDiscoveryType_NamespaceMapping)(nil),
	}
}

// Classic BIG-IP Discovery Type
//
// x-displayName: "Classic BIG-IP Discovery Configuration"
// Discovery configuration for Classic BIG-IP
type CbipDiscoveryType struct {
	// Classic BIG-IP Clusters
	//
	// x-displayName: "Classic BIG-IP Clusters"
	// x-required
	// List of Classic BIG-IP clusters. A BIG-IP cluster is a set of BIG-IP devices which
	// are in an Active-Active or Active-Standby setup or even a standalone BIG-IP device.
	CbipClusters []*CbipCluster `protobuf:"bytes,1,rep,name=cbip_clusters,json=cbipClusters,proto3" json:"cbip_clusters,omitempty"`
	// Internal LB
	//
	// x-displayName: "Internal LB domain"
	// Domain name of the internal LB
	InternalLbDomain string `protobuf:"bytes,2,opt,name=internal_lb_domain,json=internalLbDomain,proto3" json:"internal_lb_domain,omitempty"` // Deprecated: Do not use.
	// Server CA certificate to connect to internal LB
	//
	// x-displayName: "Server CA certificate"
	// Server CA certificate to connect to LB
	ServerCa []*schema.ObjectRefType `protobuf:"bytes,3,rep,name=server_ca,json=serverCa,proto3" json:"server_ca,omitempty"`
}

func (m *CbipDiscoveryType) Reset()      { *m = CbipDiscoveryType{} }
func (*CbipDiscoveryType) ProtoMessage() {}
func (*CbipDiscoveryType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{16}
}
func (m *CbipDiscoveryType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CbipDiscoveryType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CbipDiscoveryType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CbipDiscoveryType.Merge(m, src)
}
func (m *CbipDiscoveryType) XXX_Size() int {
	return m.Size()
}
func (m *CbipDiscoveryType) XXX_DiscardUnknown() {
	xxx_messageInfo_CbipDiscoveryType.DiscardUnknown(m)
}

var xxx_messageInfo_CbipDiscoveryType proto.InternalMessageInfo

func (m *CbipDiscoveryType) GetCbipClusters() []*CbipCluster {
	if m != nil {
		return m.CbipClusters
	}
	return nil
}

// Deprecated: Do not use.
func (m *CbipDiscoveryType) GetInternalLbDomain() string {
	if m != nil {
		return m.InternalLbDomain
	}
	return ""
}

func (m *CbipDiscoveryType) GetServerCa() []*schema.ObjectRefType {
	if m != nil {
		return m.ServerCa
	}
	return nil
}

// Third Party Application
//
// x-displayName: "Discovery"
// Configure third party log source applications to send logs to your XC environment. Define application names and allowed IP ranges using CIDR notation.
// See Tech Docs for details setup instractions.
type ThirdPartyDiscoveryType struct {
	// Third Party Application
	//
	// x-required
	// x-displayName: "Application Source Name"
	// Defines names to identify and distingish log source system or platforms
	Applications []string `protobuf:"bytes,1,rep,name=applications,proto3" json:"applications,omitempty"`
	// source IP
	//
	// x-required
	// x-displayName: "Source Subnet IP"
	// x-example: "1.1.1.0/24 or 2001:10/64"
	// Source IP of the packet to match
	SourceCidr []string `protobuf:"bytes,2,rep,name=source_cidr,json=sourceCidr,proto3" json:"source_cidr,omitempty"`
	// expiration_timestamp
	//
	// x-displayName: "Expiration Time"
	// This discovery service expiration timestamp
	ExpirationTimestamp *types.Timestamp `protobuf:"bytes,3,opt,name=expiration_timestamp,json=expirationTimestamp,proto3" json:"expiration_timestamp,omitempty"`
}

func (m *ThirdPartyDiscoveryType) Reset()      { *m = ThirdPartyDiscoveryType{} }
func (*ThirdPartyDiscoveryType) ProtoMessage() {}
func (*ThirdPartyDiscoveryType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{17}
}
func (m *ThirdPartyDiscoveryType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThirdPartyDiscoveryType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ThirdPartyDiscoveryType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThirdPartyDiscoveryType.Merge(m, src)
}
func (m *ThirdPartyDiscoveryType) XXX_Size() int {
	return m.Size()
}
func (m *ThirdPartyDiscoveryType) XXX_DiscardUnknown() {
	xxx_messageInfo_ThirdPartyDiscoveryType.DiscardUnknown(m)
}

var xxx_messageInfo_ThirdPartyDiscoveryType proto.InternalMessageInfo

func (m *ThirdPartyDiscoveryType) GetApplications() []string {
	if m != nil {
		return m.Applications
	}
	return nil
}

func (m *ThirdPartyDiscoveryType) GetSourceCidr() []string {
	if m != nil {
		return m.SourceCidr
	}
	return nil
}

func (m *ThirdPartyDiscoveryType) GetExpirationTimestamp() *types.Timestamp {
	if m != nil {
		return m.ExpirationTimestamp
	}
	return nil
}

// Classic BIG-IP Cluster
//
// x-displayName: "Classic BIG-IP Cluster"
// A BIG-IP cluster is a set of BIG-IP devices which are in an
// Active-Active or Active-Standby setup or even a standalone BIG-IP device.
type CbipCluster struct {
	// metadata
	//
	// x-required
	// x-displayName: "Metadata"
	// Common attributes for the device configuration including name and description.
	Metadata *schema.MessageMetaType `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Classic BIG-IP Devices
	//
	// x-displayName: "Classic BIG-IP Devices"
	// x-required
	// List of Classic BIG-IP devices.
	CbipDevices []*CbipDeviceConfig `protobuf:"bytes,2,rep,name=cbip_devices,json=cbipDevices,proto3" json:"cbip_devices,omitempty"` // Deprecated: Do not use.
	// Classic BIG-IP Devices
	//
	// x-displayName: "Management IP"
	// x-required
	// x-example: "['10.1.1.1', '10.2.2.2']"
	// IP Addresses of Classic BIG-IP devices. Hostname is not supported.
	CbipMgmtIps []string `protobuf:"bytes,3,rep,name=cbip_mgmt_ips,json=cbipMgmtIps,proto3" json:"cbip_mgmt_ips,omitempty"`
	// Classic BIG-IP Admin Credentials
	//
	// x-displayName: "Admin Credentials"
	// x-required
	AdminCredentials *CbipAdminCredentials `protobuf:"bytes,4,opt,name=admin_credentials,json=adminCredentials,proto3" json:"admin_credentials,omitempty"`
	// Classic BIG-IP Root CA Certificate
	//
	// x-displayName: "Root CA Certificate"
	// x-required
	CbipCertificateAuthority *CbipCertificateAuthority `protobuf:"bytes,5,opt,name=cbip_certificate_authority,json=cbipCertificateAuthority,proto3" json:"cbip_certificate_authority,omitempty"`
	// Virtual Server Filter
	//
	// x-displayName: "Virtual Server Filter"
	// Filters to discover only required BIG-IP Virtual Servers. The Virtual Server will be discovered only if it matches all criteria specified below. A blank criteria will be treated as match all.
	VirtualServerFilter *VirtualServerFilter `protobuf:"bytes,6,opt,name=virtual_server_filter,json=virtualServerFilter,proto3" json:"virtual_server_filter,omitempty"`
	// Mapping Preference
	//
	// x-displayName: "Mapping Preference"
	// Select the mapping between BIG-IP partition from which services will be discovered, and App Namespace to the discovered services will be shared.
	//
	// Types that are valid to be assigned to NamespaceMappingChoice:
	//	*CbipCluster_DefaultAll
	//	*CbipCluster_NamespaceMapping
	NamespaceMappingChoice isCbipCluster_NamespaceMappingChoice `protobuf_oneof:"namespace_mapping_choice"`
	// Classic BIG-IP Management Port
	//
	// x-displayName: "Management Port"
	MgmtPort *ManagementPort `protobuf:"bytes,10,opt,name=mgmt_port,json=mgmtPort,proto3" json:"mgmt_port,omitempty"`
}

func (m *CbipCluster) Reset()      { *m = CbipCluster{} }
func (*CbipCluster) ProtoMessage() {}
func (*CbipCluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{18}
}
func (m *CbipCluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CbipCluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CbipCluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CbipCluster.Merge(m, src)
}
func (m *CbipCluster) XXX_Size() int {
	return m.Size()
}
func (m *CbipCluster) XXX_DiscardUnknown() {
	xxx_messageInfo_CbipCluster.DiscardUnknown(m)
}

var xxx_messageInfo_CbipCluster proto.InternalMessageInfo

type isCbipCluster_NamespaceMappingChoice interface {
	isCbipCluster_NamespaceMappingChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CbipCluster_DefaultAll struct {
	DefaultAll *schema.Empty `protobuf:"bytes,8,opt,name=default_all,json=defaultAll,proto3,oneof" json:"default_all,omitempty"`
}
type CbipCluster_NamespaceMapping struct {
	NamespaceMapping *NamespaceMapping `protobuf:"bytes,9,opt,name=namespace_mapping,json=namespaceMapping,proto3,oneof" json:"namespace_mapping,omitempty"`
}

func (*CbipCluster_DefaultAll) isCbipCluster_NamespaceMappingChoice()       {}
func (*CbipCluster_NamespaceMapping) isCbipCluster_NamespaceMappingChoice() {}

func (m *CbipCluster) GetNamespaceMappingChoice() isCbipCluster_NamespaceMappingChoice {
	if m != nil {
		return m.NamespaceMappingChoice
	}
	return nil
}

func (m *CbipCluster) GetMetadata() *schema.MessageMetaType {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// Deprecated: Do not use.
func (m *CbipCluster) GetCbipDevices() []*CbipDeviceConfig {
	if m != nil {
		return m.CbipDevices
	}
	return nil
}

func (m *CbipCluster) GetCbipMgmtIps() []string {
	if m != nil {
		return m.CbipMgmtIps
	}
	return nil
}

func (m *CbipCluster) GetAdminCredentials() *CbipAdminCredentials {
	if m != nil {
		return m.AdminCredentials
	}
	return nil
}

func (m *CbipCluster) GetCbipCertificateAuthority() *CbipCertificateAuthority {
	if m != nil {
		return m.CbipCertificateAuthority
	}
	return nil
}

func (m *CbipCluster) GetVirtualServerFilter() *VirtualServerFilter {
	if m != nil {
		return m.VirtualServerFilter
	}
	return nil
}

func (m *CbipCluster) GetDefaultAll() *schema.Empty {
	if x, ok := m.GetNamespaceMappingChoice().(*CbipCluster_DefaultAll); ok {
		return x.DefaultAll
	}
	return nil
}

func (m *CbipCluster) GetNamespaceMapping() *NamespaceMapping {
	if x, ok := m.GetNamespaceMappingChoice().(*CbipCluster_NamespaceMapping); ok {
		return x.NamespaceMapping
	}
	return nil
}

func (m *CbipCluster) GetMgmtPort() *ManagementPort {
	if m != nil {
		return m.MgmtPort
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CbipCluster) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CbipCluster_DefaultAll)(nil),
		(*CbipCluster_NamespaceMapping)(nil),
	}
}

// Classic BIG-IP Configuration
//
// x-displayName: "Classic BIG-IP Configuration"
type CbipDeviceConfig struct {
	// Management IP
	//
	// x-displayName: "Management IP"
	// x-required
	// x-example: "10.1.1.1"
	// IP Address of the Classic BIG-IP device. Hostname is not supported.
	CbipMgmtIp string `protobuf:"bytes,1,opt,name=cbip_mgmt_ip,json=cbipMgmtIp,proto3" json:"cbip_mgmt_ip,omitempty"` // Deprecated: Do not use.
	// Classic BIG-IP Admin Credentials
	//
	// x-displayName: "Admin Credentials"
	// x-required
	AdminCredentials *CbipAdminCredentials `protobuf:"bytes,2,opt,name=admin_credentials,json=adminCredentials,proto3" json:"admin_credentials,omitempty"` // Deprecated: Do not use.
	// Classic BIG-IP Root CA Certificate
	//
	// x-displayName: "Root CA Certificate"
	// x-required
	CbipCertificateAuthority *CbipCertificateAuthority `protobuf:"bytes,3,opt,name=cbip_certificate_authority,json=cbipCertificateAuthority,proto3" json:"cbip_certificate_authority,omitempty"` // Deprecated: Do not use.
	// Virtual Server Filter
	//
	// x-displayName: "Virtual Server Filter"
	// Filters to discover only required BIG-IP Virtual Servers. The Virtual Server will be discovered only if it matches all criteria specified below. A blank criteria will be treated as match all.
	VirtualServerFilter *VirtualServerFilter `protobuf:"bytes,4,opt,name=virtual_server_filter,json=virtualServerFilter,proto3" json:"virtual_server_filter,omitempty"` // Deprecated: Do not use.
	// Namespace Mapping Choice
	//
	// x-displayName: "Namespace Mapping Choice"
	// Select the mapping between BIG-IP partition from which services will be discovered, and App Namespace to the discovered services will be shared.
	//
	// Types that are valid to be assigned to NamespaceMappingChoice:
	//	*CbipDeviceConfig_DefaultAll
	//	*CbipDeviceConfig_NamespaceMapping
	NamespaceMappingChoice isCbipDeviceConfig_NamespaceMappingChoice `protobuf_oneof:"namespace_mapping_choice"`
}

func (m *CbipDeviceConfig) Reset()      { *m = CbipDeviceConfig{} }
func (*CbipDeviceConfig) ProtoMessage() {}
func (*CbipDeviceConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{19}
}
func (m *CbipDeviceConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CbipDeviceConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CbipDeviceConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CbipDeviceConfig.Merge(m, src)
}
func (m *CbipDeviceConfig) XXX_Size() int {
	return m.Size()
}
func (m *CbipDeviceConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CbipDeviceConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CbipDeviceConfig proto.InternalMessageInfo

type isCbipDeviceConfig_NamespaceMappingChoice interface {
	isCbipDeviceConfig_NamespaceMappingChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CbipDeviceConfig_DefaultAll struct {
	DefaultAll *schema.Empty `protobuf:"bytes,6,opt,name=default_all,json=defaultAll,proto3,oneof" json:"default_all,omitempty"`
}
type CbipDeviceConfig_NamespaceMapping struct {
	NamespaceMapping *NamespaceMapping `protobuf:"bytes,7,opt,name=namespace_mapping,json=namespaceMapping,proto3,oneof" json:"namespace_mapping,omitempty"`
}

func (*CbipDeviceConfig_DefaultAll) isCbipDeviceConfig_NamespaceMappingChoice()       {}
func (*CbipDeviceConfig_NamespaceMapping) isCbipDeviceConfig_NamespaceMappingChoice() {}

func (m *CbipDeviceConfig) GetNamespaceMappingChoice() isCbipDeviceConfig_NamespaceMappingChoice {
	if m != nil {
		return m.NamespaceMappingChoice
	}
	return nil
}

// Deprecated: Do not use.
func (m *CbipDeviceConfig) GetCbipMgmtIp() string {
	if m != nil {
		return m.CbipMgmtIp
	}
	return ""
}

// Deprecated: Do not use.
func (m *CbipDeviceConfig) GetAdminCredentials() *CbipAdminCredentials {
	if m != nil {
		return m.AdminCredentials
	}
	return nil
}

// Deprecated: Do not use.
func (m *CbipDeviceConfig) GetCbipCertificateAuthority() *CbipCertificateAuthority {
	if m != nil {
		return m.CbipCertificateAuthority
	}
	return nil
}

// Deprecated: Do not use.
func (m *CbipDeviceConfig) GetVirtualServerFilter() *VirtualServerFilter {
	if m != nil {
		return m.VirtualServerFilter
	}
	return nil
}

// Deprecated: Do not use.
func (m *CbipDeviceConfig) GetDefaultAll() *schema.Empty {
	if x, ok := m.GetNamespaceMappingChoice().(*CbipDeviceConfig_DefaultAll); ok {
		return x.DefaultAll
	}
	return nil
}

// Deprecated: Do not use.
func (m *CbipDeviceConfig) GetNamespaceMapping() *NamespaceMapping {
	if x, ok := m.GetNamespaceMappingChoice().(*CbipDeviceConfig_NamespaceMapping); ok {
		return x.NamespaceMapping
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CbipDeviceConfig) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CbipDeviceConfig_DefaultAll)(nil),
		(*CbipDeviceConfig_NamespaceMapping)(nil),
	}
}

// Classic BIG-IP Admin Credentials
//
// x-displayName: "Admin Credentials"
type CbipAdminCredentials struct {
	// Classic BIG-IP Admin Username
	//
	// x-example: "admin"
	// x-displayName: "Admin Username"
	// x-required
	// Username used to log into an admin account on the BIG-IP device
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	// Classic BIG-IP Admin Password
	//
	// x-displayName: "Admin Password"
	// x-required
	// Password used to log into an admin account on the BIG-IP device
	Password *schema.SecretType `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
}

func (m *CbipAdminCredentials) Reset()      { *m = CbipAdminCredentials{} }
func (*CbipAdminCredentials) ProtoMessage() {}
func (*CbipAdminCredentials) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{20}
}
func (m *CbipAdminCredentials) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CbipAdminCredentials) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CbipAdminCredentials) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CbipAdminCredentials.Merge(m, src)
}
func (m *CbipAdminCredentials) XXX_Size() int {
	return m.Size()
}
func (m *CbipAdminCredentials) XXX_DiscardUnknown() {
	xxx_messageInfo_CbipAdminCredentials.DiscardUnknown(m)
}

var xxx_messageInfo_CbipAdminCredentials proto.InternalMessageInfo

func (m *CbipAdminCredentials) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *CbipAdminCredentials) GetPassword() *schema.SecretType {
	if m != nil {
		return m.Password
	}
	return nil
}

// Management Port
//
// x-displayName: "Management Port"
type ManagementPort struct {
	// Management Port
	//
	// x-displayName: "Management Port"
	// x-example: "443"
	// Management Port of the BIGIP HA cluster
	Port uint32 `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty"`
}

func (m *ManagementPort) Reset()      { *m = ManagementPort{} }
func (*ManagementPort) ProtoMessage() {}
func (*ManagementPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{21}
}
func (m *ManagementPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ManagementPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ManagementPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ManagementPort.Merge(m, src)
}
func (m *ManagementPort) XXX_Size() int {
	return m.Size()
}
func (m *ManagementPort) XXX_DiscardUnknown() {
	xxx_messageInfo_ManagementPort.DiscardUnknown(m)
}

var xxx_messageInfo_ManagementPort proto.InternalMessageInfo

func (m *ManagementPort) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// BIG-IP Root CA Certificate
//
// x-displayName: "Root CA Certificate"
// BIG-IP Root CA Certificate
type CbipCertificateAuthority struct {
	// BIG-IP Root CA Certificate
	//
	// x-displayName: "Root CA Certificate"
	// x-required
	// BIG-IP Root CA Certificate choice
	//
	// Types that are valid to be assigned to ServerValidationChoice:
	//	*CbipCertificateAuthority_TrustedCa
	//	*CbipCertificateAuthority_SkipServerVerification
	ServerValidationChoice isCbipCertificateAuthority_ServerValidationChoice `protobuf_oneof:"server_validation_choice"`
}

func (m *CbipCertificateAuthority) Reset()      { *m = CbipCertificateAuthority{} }
func (*CbipCertificateAuthority) ProtoMessage() {}
func (*CbipCertificateAuthority) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{22}
}
func (m *CbipCertificateAuthority) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CbipCertificateAuthority) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CbipCertificateAuthority) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CbipCertificateAuthority.Merge(m, src)
}
func (m *CbipCertificateAuthority) XXX_Size() int {
	return m.Size()
}
func (m *CbipCertificateAuthority) XXX_DiscardUnknown() {
	xxx_messageInfo_CbipCertificateAuthority.DiscardUnknown(m)
}

var xxx_messageInfo_CbipCertificateAuthority proto.InternalMessageInfo

type isCbipCertificateAuthority_ServerValidationChoice interface {
	isCbipCertificateAuthority_ServerValidationChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CbipCertificateAuthority_TrustedCa struct {
	TrustedCa *views.ObjectRefType `protobuf:"bytes,2,opt,name=trusted_ca,json=trustedCa,proto3,oneof" json:"trusted_ca,omitempty"`
}
type CbipCertificateAuthority_SkipServerVerification struct {
	SkipServerVerification *schema.Empty `protobuf:"bytes,3,opt,name=skip_server_verification,json=skipServerVerification,proto3,oneof" json:"skip_server_verification,omitempty"`
}

func (*CbipCertificateAuthority_TrustedCa) isCbipCertificateAuthority_ServerValidationChoice() {}
func (*CbipCertificateAuthority_SkipServerVerification) isCbipCertificateAuthority_ServerValidationChoice() {
}

func (m *CbipCertificateAuthority) GetServerValidationChoice() isCbipCertificateAuthority_ServerValidationChoice {
	if m != nil {
		return m.ServerValidationChoice
	}
	return nil
}

func (m *CbipCertificateAuthority) GetTrustedCa() *views.ObjectRefType {
	if x, ok := m.GetServerValidationChoice().(*CbipCertificateAuthority_TrustedCa); ok {
		return x.TrustedCa
	}
	return nil
}

func (m *CbipCertificateAuthority) GetSkipServerVerification() *schema.Empty {
	if x, ok := m.GetServerValidationChoice().(*CbipCertificateAuthority_SkipServerVerification); ok {
		return x.SkipServerVerification
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CbipCertificateAuthority) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CbipCertificateAuthority_TrustedCa)(nil),
		(*CbipCertificateAuthority_SkipServerVerification)(nil),
	}
}

// Virtual Server Filter
//
// x-displayName: "Virtual Server Filter"
// Filters to discover only required BIG-IP Virtual Servers. The Virtual Server will be discovered only if it matches all criteria specified below. A blank criteria will be treated as match all.
type VirtualServerFilter struct {
	// Regex To Match Virtual Server Name
	//
	// x-displayName: "Regex To Match Virtual Server Name"
	// Regex to match Virtual Server name
	NameRegex string `protobuf:"bytes,4,opt,name=name_regex,json=nameRegex,proto3" json:"name_regex,omitempty"`
	// Regex To Match Virtual Server Description
	//
	// x-displayName: "Regex To Match Virtual Server Description"
	// Regex to match Virtual Server description
	DescriptionRegex string `protobuf:"bytes,5,opt,name=description_regex,json=descriptionRegex,proto3" json:"description_regex,omitempty"`
	// protocols
	//
	// x-displayName: "Protocol(s)"
	// x-example: "TCP"
	// Filter by protocol(s)
	Protocols []string `protobuf:"bytes,6,rep,name=protocols,proto3" json:"protocols,omitempty"`
	// Port_ranges
	//
	// x-displayName: "Port Ranges"
	// x-example: "80,443,8080-8191,9080"
	// A string containing a comma separated list of individual service ports or port ranges.
	// Each port range consists of a single port or two ports separated by "-". For example, 8000-8191.
	// Maximum number of ports allowed is 1024.
	PortRanges string `protobuf:"bytes,7,opt,name=port_ranges,json=portRanges,proto3" json:"port_ranges,omitempty"`
	// Discover Disabled Virtual Servers
	//
	// x-displayName: "Discover Disabled Virtual Servers"
	// When checked, disabled virtual servers will be included
	DiscoverDisabledVirtualServers bool `protobuf:"varint,8,opt,name=discover_disabled_virtual_servers,json=discoverDisabledVirtualServers,proto3" json:"discover_disabled_virtual_servers,omitempty"`
}

func (m *VirtualServerFilter) Reset()      { *m = VirtualServerFilter{} }
func (*VirtualServerFilter) ProtoMessage() {}
func (*VirtualServerFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{23}
}
func (m *VirtualServerFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VirtualServerFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VirtualServerFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualServerFilter.Merge(m, src)
}
func (m *VirtualServerFilter) XXX_Size() int {
	return m.Size()
}
func (m *VirtualServerFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualServerFilter.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualServerFilter proto.InternalMessageInfo

func (m *VirtualServerFilter) GetNameRegex() string {
	if m != nil {
		return m.NameRegex
	}
	return ""
}

func (m *VirtualServerFilter) GetDescriptionRegex() string {
	if m != nil {
		return m.DescriptionRegex
	}
	return ""
}

func (m *VirtualServerFilter) GetProtocols() []string {
	if m != nil {
		return m.Protocols
	}
	return nil
}

func (m *VirtualServerFilter) GetPortRanges() string {
	if m != nil {
		return m.PortRanges
	}
	return ""
}

func (m *VirtualServerFilter) GetDiscoverDisabledVirtualServers() bool {
	if m != nil {
		return m.DiscoverDisabledVirtualServers
	}
	return false
}

// Namespace Mapping
//
// x-displayName: "Namespace Mapping"
// Select the mapping between BIG-IP partition from which services will be discovered and App Namespace to which the discovered services will be shared.
type NamespaceMapping struct {
	// Partition to Namespace Mapping
	//
	// x-displayName: "Partition to Namespace Mapping"
	// x-required
	// Map BIG-IP partition(s) to App Namespaces
	Items []*NamespaceMappingItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *NamespaceMapping) Reset()      { *m = NamespaceMapping{} }
func (*NamespaceMapping) ProtoMessage() {}
func (*NamespaceMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{24}
}
func (m *NamespaceMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamespaceMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NamespaceMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamespaceMapping.Merge(m, src)
}
func (m *NamespaceMapping) XXX_Size() int {
	return m.Size()
}
func (m *NamespaceMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_NamespaceMapping.DiscardUnknown(m)
}

var xxx_messageInfo_NamespaceMapping proto.InternalMessageInfo

func (m *NamespaceMapping) GetItems() []*NamespaceMappingItem {
	if m != nil {
		return m.Items
	}
	return nil
}

// Namespace Mapping Item
//
// x-displayName: "Namespace Mapping Item"
// Map BIG-IP partition(s) to an App Namespace. If not specified, all virtual
// servers will be discovered under shared namespace.
type NamespaceMappingItem struct {
	// Classic BIG-IP Partition Regex
	//
	// x-displayName: "Regex To Match BIG-IP device partition(s)"
	// The regex here will be used to match BIG-IP partition(s).
	PartitionRegex string `protobuf:"bytes,1,opt,name=partition_regex,json=partitionRegex,proto3" json:"partition_regex,omitempty"`
	// App Namespace
	//
	// x-displayName: "App Namespace"
	// Select a namespace
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *NamespaceMappingItem) Reset()      { *m = NamespaceMappingItem{} }
func (*NamespaceMappingItem) ProtoMessage() {}
func (*NamespaceMappingItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{25}
}
func (m *NamespaceMappingItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamespaceMappingItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NamespaceMappingItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamespaceMappingItem.Merge(m, src)
}
func (m *NamespaceMappingItem) XXX_Size() int {
	return m.Size()
}
func (m *NamespaceMappingItem) XXX_DiscardUnknown() {
	xxx_messageInfo_NamespaceMappingItem.DiscardUnknown(m)
}

var xxx_messageInfo_NamespaceMappingItem proto.InternalMessageInfo

func (m *NamespaceMappingItem) GetPartitionRegex() string {
	if m != nil {
		return m.PartitionRegex
	}
	return ""
}

func (m *NamespaceMappingItem) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// K8S Namespace Mapping
//
// x-displayName: "K8S Namespace Mapping"
// Select the mapping between K8s namespaces from which services will be discovered and App Namespace to which the discovered services will be shared.
type K8SNamespaceMapping struct {
	// K8S Namespace to App Namespace Mapping
	//
	// x-displayName: "Regex Matching"
	// x-required
	// Map K8s namespace(s) to App Namespaces. In Shared Configuration, Discovered Services can only be mapped to a single App Namespace, which is determined by the first matched regex.
	Items []*K8SNamespaceMappingItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *K8SNamespaceMapping) Reset()      { *m = K8SNamespaceMapping{} }
func (*K8SNamespaceMapping) ProtoMessage() {}
func (*K8SNamespaceMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{26}
}
func (m *K8SNamespaceMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *K8SNamespaceMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *K8SNamespaceMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K8SNamespaceMapping.Merge(m, src)
}
func (m *K8SNamespaceMapping) XXX_Size() int {
	return m.Size()
}
func (m *K8SNamespaceMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_K8SNamespaceMapping.DiscardUnknown(m)
}

var xxx_messageInfo_K8SNamespaceMapping proto.InternalMessageInfo

func (m *K8SNamespaceMapping) GetItems() []*K8SNamespaceMappingItem {
	if m != nil {
		return m.Items
	}
	return nil
}

// K8S Namespace Mapping Item
//
// x-displayName: "K8S Namespace Mapping Item"
// Map K8s Namespace(s) to an App Namespace. If not specified, all virtual
// servers will be discovered under shared namespace.
type K8SNamespaceMappingItem struct {
	// Kubernetes Namespace Regex
	//
	// x-displayName: "K8S Namespaces"
	// The regex here will be used to match K8s namespace(s).
	NamespaceRegex string `protobuf:"bytes,1,opt,name=namespace_regex,json=namespaceRegex,proto3" json:"namespace_regex,omitempty"`
	// App Namespace
	//
	// x-displayName: "F5XC Application Namespaces"
	// Select a namespace
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *K8SNamespaceMappingItem) Reset()      { *m = K8SNamespaceMappingItem{} }
func (*K8SNamespaceMappingItem) ProtoMessage() {}
func (*K8SNamespaceMappingItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{27}
}
func (m *K8SNamespaceMappingItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *K8SNamespaceMappingItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *K8SNamespaceMappingItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K8SNamespaceMappingItem.Merge(m, src)
}
func (m *K8SNamespaceMappingItem) XXX_Size() int {
	return m.Size()
}
func (m *K8SNamespaceMappingItem) XXX_DiscardUnknown() {
	xxx_messageInfo_K8SNamespaceMappingItem.DiscardUnknown(m)
}

var xxx_messageInfo_K8SNamespaceMappingItem proto.InternalMessageInfo

func (m *K8SNamespaceMappingItem) GetNamespaceRegex() string {
	if m != nil {
		return m.NamespaceRegex
	}
	return ""
}

func (m *K8SNamespaceMappingItem) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// Consul Namespace Mapping
//
// x-displayName: "Consul Namespace Mapping"
// Select the mapping between Consul namespaces from which services will be discovered and App Namespace to which the discovered services will be shared.
type ConsulNamespaceMapping struct {
	// Consul Namespace to App Namespace Mapping
	//
	// x-displayName: "Regex Matching"
	// x-required
	// Map Consul namespace(s) to App Namespaces
	Items []*ConsulNamespaceMappingItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *ConsulNamespaceMapping) Reset()      { *m = ConsulNamespaceMapping{} }
func (*ConsulNamespaceMapping) ProtoMessage() {}
func (*ConsulNamespaceMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{28}
}
func (m *ConsulNamespaceMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsulNamespaceMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConsulNamespaceMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsulNamespaceMapping.Merge(m, src)
}
func (m *ConsulNamespaceMapping) XXX_Size() int {
	return m.Size()
}
func (m *ConsulNamespaceMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsulNamespaceMapping.DiscardUnknown(m)
}

var xxx_messageInfo_ConsulNamespaceMapping proto.InternalMessageInfo

func (m *ConsulNamespaceMapping) GetItems() []*ConsulNamespaceMappingItem {
	if m != nil {
		return m.Items
	}
	return nil
}

// Consul Namespace Mapping Item
//
// x-displayName: "Consul Namespace Mapping Item"
// Map Consul Namespace(s) to an App Namespace. If not specified, all virtual
// servers will be discovered under shared namespace.
type ConsulNamespaceMappingItem struct {
	// Consul Namespace Regex
	//
	// x-displayName: "Consul Namespaces"
	// The regex here will be used to match Consul namespace(s).
	NamespaceRegex string `protobuf:"bytes,1,opt,name=namespace_regex,json=namespaceRegex,proto3" json:"namespace_regex,omitempty"`
	// App Namespace
	//
	// x-displayName: "F5XC Application Namespaces"
	// Select a namespace
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *ConsulNamespaceMappingItem) Reset()      { *m = ConsulNamespaceMappingItem{} }
func (*ConsulNamespaceMappingItem) ProtoMessage() {}
func (*ConsulNamespaceMappingItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{29}
}
func (m *ConsulNamespaceMappingItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsulNamespaceMappingItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConsulNamespaceMappingItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsulNamespaceMappingItem.Merge(m, src)
}
func (m *ConsulNamespaceMappingItem) XXX_Size() int {
	return m.Size()
}
func (m *ConsulNamespaceMappingItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsulNamespaceMappingItem.DiscardUnknown(m)
}

var xxx_messageInfo_ConsulNamespaceMappingItem proto.InternalMessageInfo

func (m *ConsulNamespaceMappingItem) GetNamespaceRegex() string {
	if m != nil {
		return m.NamespaceRegex
	}
	return ""
}

func (m *ConsulNamespaceMappingItem) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// Specification for discovery
//
// x-displayName: "Specification"
// Desired state of discovery
type GlobalSpecType struct {
	// Where
	//
	// x-displayName: "Site"
	// x-required
	// Site for which discovery is valid.
	Where *schema.NetworkSiteRefSelector `protobuf:"bytes,1,opt,name=where,proto3" json:"where,omitempty"`
	// discovery choice
	//
	// x-displayName: "Discovery Method:"
	// x-required
	// Select discovery method
	//
	// Types that are valid to be assigned to DiscoveryChoice:
	//	*GlobalSpecType_DiscoveryK8S
	//	*GlobalSpecType_DiscoveryConsul
	//	*GlobalSpecType_DiscoveryCbip
	//	*GlobalSpecType_DiscoveryThirdParty
	DiscoveryChoice isGlobalSpecType_DiscoveryChoice `protobuf_oneof:"discovery_choice"`
	// Discovery type
	//
	// x-displayName: "Type of Discovery"
	// x-required
	// Type of discovery K8s or consul
	Type schema.DiscoveryType `protobuf:"varint,2,opt,name=type,proto3,enum=ves.io.schema.DiscoveryType" json:"type,omitempty"`
	// VIP publish
	//
	// x-displayName: "VIP Publishing configuration"
	// Configuration to publish VIP(s) in to a discovery service.
	PublishVip *VipDiscoveryInfoType `protobuf:"bytes,3,opt,name=publish_vip,json=publishVip,proto3" json:"publish_vip,omitempty"`
	// Access Info
	//
	// x-displayName: "Select How Endpoints are Discovered"
	// Endpoints can be discovered from Kubernetes service configuration or Consul
	//
	// Types that are valid to be assigned to AccessInfo:
	//	*GlobalSpecType_K8S
	//	*GlobalSpecType_Consul
	AccessInfo isGlobalSpecType_AccessInfo `protobuf_oneof:"access_info"`
	// discovery cluster identifier
	//
	// x-displayName: "Select Discovery Cluster Identifier"
	// x-example: "debug-cluster"
	// Specify identifier for discovery cluster. This identifier can be
	// specified in endpoint object to discover only from this discovery object.
	// This is useful when a site has multiple discovery objects and endpoint wants
	// to discover from few of them. The default behaviour for endpoint is to
	// discover from all discovery objects of the site.
	ClusterIdentifier string `protobuf:"bytes,10,opt,name=cluster_identifier,json=clusterIdentifier,proto3" json:"cluster_identifier,omitempty"` // Deprecated: Do not use.
	// cluster identifier choice
	//
	// x-displayName: "Select Discovery Cluster Identifier"
	// x-required
	// Specify identifier for discovery cluster. This identifier can be
	// specified in endpoint object to discover only from this discovery object.
	// This is useful when a site has multiple discovery objects and endpoint wants
	// to discover from few of them. The default behaviour for endpoint is to
	// discover from all discovery objects of the site.
	//
	// Types that are valid to be assigned to ClusterIdentifierChoice:
	//	*GlobalSpecType_NoClusterId
	//	*GlobalSpecType_ClusterId
	ClusterIdentifierChoice isGlobalSpecType_ClusterIdentifierChoice `protobuf_oneof:"cluster_identifier_choice"`
	// view_internal
	//
	// x-displayName: "View Internal"
	// Reference to view internal object
	ViewInternal *views.ObjectRefType `protobuf:"bytes,1000,opt,name=view_internal,json=viewInternal,proto3" json:"view_internal,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{30}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_DiscoveryChoice interface {
	isGlobalSpecType_DiscoveryChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_AccessInfo interface {
	isGlobalSpecType_AccessInfo()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_ClusterIdentifierChoice interface {
	isGlobalSpecType_ClusterIdentifierChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_DiscoveryK8S struct {
	DiscoveryK8S *K8SDiscoveryType `protobuf:"bytes,8,opt,name=discovery_k8s,json=discoveryK8s,proto3,oneof" json:"discovery_k8s,omitempty"`
}
type GlobalSpecType_DiscoveryConsul struct {
	DiscoveryConsul *ConsulDiscoveryType `protobuf:"bytes,9,opt,name=discovery_consul,json=discoveryConsul,proto3,oneof" json:"discovery_consul,omitempty"`
}
type GlobalSpecType_DiscoveryCbip struct {
	DiscoveryCbip *CbipDiscoveryType `protobuf:"bytes,14,opt,name=discovery_cbip,json=discoveryCbip,proto3,oneof" json:"discovery_cbip,omitempty"`
}
type GlobalSpecType_DiscoveryThirdParty struct {
	DiscoveryThirdParty *ThirdPartyDiscoveryType `protobuf:"bytes,15,opt,name=discovery_third_party,json=discoveryThirdParty,proto3,oneof" json:"discovery_third_party,omitempty"`
}
type GlobalSpecType_K8S struct {
	K8S *K8SAccessInfo `protobuf:"bytes,4,opt,name=k8s,proto3,oneof" json:"k8s,omitempty"`
}
type GlobalSpecType_Consul struct {
	Consul *ConsulAccessInfo `protobuf:"bytes,5,opt,name=consul,proto3,oneof" json:"consul,omitempty"`
}
type GlobalSpecType_NoClusterId struct {
	NoClusterId *schema.Empty `protobuf:"bytes,12,opt,name=no_cluster_id,json=noClusterId,proto3,oneof" json:"no_cluster_id,omitempty"`
}
type GlobalSpecType_ClusterId struct {
	ClusterId string `protobuf:"bytes,13,opt,name=cluster_id,json=clusterId,proto3,oneof" json:"cluster_id,omitempty"`
}

func (*GlobalSpecType_DiscoveryK8S) isGlobalSpecType_DiscoveryChoice()        {}
func (*GlobalSpecType_DiscoveryConsul) isGlobalSpecType_DiscoveryChoice()     {}
func (*GlobalSpecType_DiscoveryCbip) isGlobalSpecType_DiscoveryChoice()       {}
func (*GlobalSpecType_DiscoveryThirdParty) isGlobalSpecType_DiscoveryChoice() {}
func (*GlobalSpecType_K8S) isGlobalSpecType_AccessInfo()                      {}
func (*GlobalSpecType_Consul) isGlobalSpecType_AccessInfo()                   {}
func (*GlobalSpecType_NoClusterId) isGlobalSpecType_ClusterIdentifierChoice() {}
func (*GlobalSpecType_ClusterId) isGlobalSpecType_ClusterIdentifierChoice()   {}

func (m *GlobalSpecType) GetDiscoveryChoice() isGlobalSpecType_DiscoveryChoice {
	if m != nil {
		return m.DiscoveryChoice
	}
	return nil
}
func (m *GlobalSpecType) GetAccessInfo() isGlobalSpecType_AccessInfo {
	if m != nil {
		return m.AccessInfo
	}
	return nil
}
func (m *GlobalSpecType) GetClusterIdentifierChoice() isGlobalSpecType_ClusterIdentifierChoice {
	if m != nil {
		return m.ClusterIdentifierChoice
	}
	return nil
}

func (m *GlobalSpecType) GetWhere() *schema.NetworkSiteRefSelector {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *GlobalSpecType) GetDiscoveryK8S() *K8SDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*GlobalSpecType_DiscoveryK8S); ok {
		return x.DiscoveryK8S
	}
	return nil
}

func (m *GlobalSpecType) GetDiscoveryConsul() *ConsulDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*GlobalSpecType_DiscoveryConsul); ok {
		return x.DiscoveryConsul
	}
	return nil
}

func (m *GlobalSpecType) GetDiscoveryCbip() *CbipDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*GlobalSpecType_DiscoveryCbip); ok {
		return x.DiscoveryCbip
	}
	return nil
}

func (m *GlobalSpecType) GetDiscoveryThirdParty() *ThirdPartyDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*GlobalSpecType_DiscoveryThirdParty); ok {
		return x.DiscoveryThirdParty
	}
	return nil
}

func (m *GlobalSpecType) GetType() schema.DiscoveryType {
	if m != nil {
		return m.Type
	}
	return schema.INVALID_DISCOVERY
}

func (m *GlobalSpecType) GetPublishVip() *VipDiscoveryInfoType {
	if m != nil {
		return m.PublishVip
	}
	return nil
}

func (m *GlobalSpecType) GetK8S() *K8SAccessInfo {
	if x, ok := m.GetAccessInfo().(*GlobalSpecType_K8S); ok {
		return x.K8S
	}
	return nil
}

func (m *GlobalSpecType) GetConsul() *ConsulAccessInfo {
	if x, ok := m.GetAccessInfo().(*GlobalSpecType_Consul); ok {
		return x.Consul
	}
	return nil
}

// Deprecated: Do not use.
func (m *GlobalSpecType) GetClusterIdentifier() string {
	if m != nil {
		return m.ClusterIdentifier
	}
	return ""
}

func (m *GlobalSpecType) GetNoClusterId() *schema.Empty {
	if x, ok := m.GetClusterIdentifierChoice().(*GlobalSpecType_NoClusterId); ok {
		return x.NoClusterId
	}
	return nil
}

func (m *GlobalSpecType) GetClusterId() string {
	if x, ok := m.GetClusterIdentifierChoice().(*GlobalSpecType_ClusterId); ok {
		return x.ClusterId
	}
	return ""
}

func (m *GlobalSpecType) GetViewInternal() *views.ObjectRefType {
	if m != nil {
		return m.ViewInternal
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_DiscoveryK8S)(nil),
		(*GlobalSpecType_DiscoveryConsul)(nil),
		(*GlobalSpecType_DiscoveryCbip)(nil),
		(*GlobalSpecType_DiscoveryThirdParty)(nil),
		(*GlobalSpecType_K8S)(nil),
		(*GlobalSpecType_Consul)(nil),
		(*GlobalSpecType_NoClusterId)(nil),
		(*GlobalSpecType_ClusterId)(nil),
	}
}

// Create discovery
//
// x-displayName: "Create Discovery"
// API to create discovery object for a site or virtual site in system namespace
type CreateSpecType struct {
	Where *schema.NetworkSiteRefSelector `protobuf:"bytes,1,opt,name=where,proto3" json:"where,omitempty"`
	// Types that are valid to be assigned to DiscoveryChoice:
	//	*CreateSpecType_DiscoveryK8S
	//	*CreateSpecType_DiscoveryConsul
	//	*CreateSpecType_DiscoveryCbip
	//	*CreateSpecType_DiscoveryThirdParty
	DiscoveryChoice isCreateSpecType_DiscoveryChoice `protobuf_oneof:"discovery_choice"`
	// Types that are valid to be assigned to ClusterIdentifierChoice:
	//	*CreateSpecType_NoClusterId
	//	*CreateSpecType_ClusterId
	ClusterIdentifierChoice isCreateSpecType_ClusterIdentifierChoice `protobuf_oneof:"cluster_identifier_choice"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{31}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_DiscoveryChoice interface {
	isCreateSpecType_DiscoveryChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_ClusterIdentifierChoice interface {
	isCreateSpecType_ClusterIdentifierChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_DiscoveryK8S struct {
	DiscoveryK8S *K8SDiscoveryType `protobuf:"bytes,8,opt,name=discovery_k8s,json=discoveryK8s,proto3,oneof" json:"discovery_k8s,omitempty"`
}
type CreateSpecType_DiscoveryConsul struct {
	DiscoveryConsul *ConsulDiscoveryType `protobuf:"bytes,9,opt,name=discovery_consul,json=discoveryConsul,proto3,oneof" json:"discovery_consul,omitempty"`
}
type CreateSpecType_DiscoveryCbip struct {
	DiscoveryCbip *CbipDiscoveryType `protobuf:"bytes,14,opt,name=discovery_cbip,json=discoveryCbip,proto3,oneof" json:"discovery_cbip,omitempty"`
}
type CreateSpecType_DiscoveryThirdParty struct {
	DiscoveryThirdParty *ThirdPartyDiscoveryType `protobuf:"bytes,15,opt,name=discovery_third_party,json=discoveryThirdParty,proto3,oneof" json:"discovery_third_party,omitempty"`
}
type CreateSpecType_NoClusterId struct {
	NoClusterId *schema.Empty `protobuf:"bytes,12,opt,name=no_cluster_id,json=noClusterId,proto3,oneof" json:"no_cluster_id,omitempty"`
}
type CreateSpecType_ClusterId struct {
	ClusterId string `protobuf:"bytes,13,opt,name=cluster_id,json=clusterId,proto3,oneof" json:"cluster_id,omitempty"`
}

func (*CreateSpecType_DiscoveryK8S) isCreateSpecType_DiscoveryChoice()        {}
func (*CreateSpecType_DiscoveryConsul) isCreateSpecType_DiscoveryChoice()     {}
func (*CreateSpecType_DiscoveryCbip) isCreateSpecType_DiscoveryChoice()       {}
func (*CreateSpecType_DiscoveryThirdParty) isCreateSpecType_DiscoveryChoice() {}
func (*CreateSpecType_NoClusterId) isCreateSpecType_ClusterIdentifierChoice() {}
func (*CreateSpecType_ClusterId) isCreateSpecType_ClusterIdentifierChoice()   {}

func (m *CreateSpecType) GetDiscoveryChoice() isCreateSpecType_DiscoveryChoice {
	if m != nil {
		return m.DiscoveryChoice
	}
	return nil
}
func (m *CreateSpecType) GetClusterIdentifierChoice() isCreateSpecType_ClusterIdentifierChoice {
	if m != nil {
		return m.ClusterIdentifierChoice
	}
	return nil
}

func (m *CreateSpecType) GetWhere() *schema.NetworkSiteRefSelector {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *CreateSpecType) GetDiscoveryK8S() *K8SDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*CreateSpecType_DiscoveryK8S); ok {
		return x.DiscoveryK8S
	}
	return nil
}

func (m *CreateSpecType) GetDiscoveryConsul() *ConsulDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*CreateSpecType_DiscoveryConsul); ok {
		return x.DiscoveryConsul
	}
	return nil
}

func (m *CreateSpecType) GetDiscoveryCbip() *CbipDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*CreateSpecType_DiscoveryCbip); ok {
		return x.DiscoveryCbip
	}
	return nil
}

func (m *CreateSpecType) GetDiscoveryThirdParty() *ThirdPartyDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*CreateSpecType_DiscoveryThirdParty); ok {
		return x.DiscoveryThirdParty
	}
	return nil
}

func (m *CreateSpecType) GetNoClusterId() *schema.Empty {
	if x, ok := m.GetClusterIdentifierChoice().(*CreateSpecType_NoClusterId); ok {
		return x.NoClusterId
	}
	return nil
}

func (m *CreateSpecType) GetClusterId() string {
	if x, ok := m.GetClusterIdentifierChoice().(*CreateSpecType_ClusterId); ok {
		return x.ClusterId
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_DiscoveryK8S)(nil),
		(*CreateSpecType_DiscoveryConsul)(nil),
		(*CreateSpecType_DiscoveryCbip)(nil),
		(*CreateSpecType_DiscoveryThirdParty)(nil),
		(*CreateSpecType_NoClusterId)(nil),
		(*CreateSpecType_ClusterId)(nil),
	}
}

// Replace discovery
//
// x-displayName: "Replace Discovery"
// API to replace discovery object for a site or virtual site in system namespace
type ReplaceSpecType struct {
	Where *schema.NetworkSiteRefSelector `protobuf:"bytes,1,opt,name=where,proto3" json:"where,omitempty"`
	// Types that are valid to be assigned to DiscoveryChoice:
	//	*ReplaceSpecType_DiscoveryK8S
	//	*ReplaceSpecType_DiscoveryConsul
	//	*ReplaceSpecType_DiscoveryCbip
	//	*ReplaceSpecType_DiscoveryThirdParty
	DiscoveryChoice isReplaceSpecType_DiscoveryChoice `protobuf_oneof:"discovery_choice"`
	// Types that are valid to be assigned to ClusterIdentifierChoice:
	//	*ReplaceSpecType_NoClusterId
	//	*ReplaceSpecType_ClusterId
	ClusterIdentifierChoice isReplaceSpecType_ClusterIdentifierChoice `protobuf_oneof:"cluster_identifier_choice"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{32}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_DiscoveryChoice interface {
	isReplaceSpecType_DiscoveryChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_ClusterIdentifierChoice interface {
	isReplaceSpecType_ClusterIdentifierChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_DiscoveryK8S struct {
	DiscoveryK8S *K8SDiscoveryType `protobuf:"bytes,8,opt,name=discovery_k8s,json=discoveryK8s,proto3,oneof" json:"discovery_k8s,omitempty"`
}
type ReplaceSpecType_DiscoveryConsul struct {
	DiscoveryConsul *ConsulDiscoveryType `protobuf:"bytes,9,opt,name=discovery_consul,json=discoveryConsul,proto3,oneof" json:"discovery_consul,omitempty"`
}
type ReplaceSpecType_DiscoveryCbip struct {
	DiscoveryCbip *CbipDiscoveryType `protobuf:"bytes,14,opt,name=discovery_cbip,json=discoveryCbip,proto3,oneof" json:"discovery_cbip,omitempty"`
}
type ReplaceSpecType_DiscoveryThirdParty struct {
	DiscoveryThirdParty *ThirdPartyDiscoveryType `protobuf:"bytes,15,opt,name=discovery_third_party,json=discoveryThirdParty,proto3,oneof" json:"discovery_third_party,omitempty"`
}
type ReplaceSpecType_NoClusterId struct {
	NoClusterId *schema.Empty `protobuf:"bytes,12,opt,name=no_cluster_id,json=noClusterId,proto3,oneof" json:"no_cluster_id,omitempty"`
}
type ReplaceSpecType_ClusterId struct {
	ClusterId string `protobuf:"bytes,13,opt,name=cluster_id,json=clusterId,proto3,oneof" json:"cluster_id,omitempty"`
}

func (*ReplaceSpecType_DiscoveryK8S) isReplaceSpecType_DiscoveryChoice()        {}
func (*ReplaceSpecType_DiscoveryConsul) isReplaceSpecType_DiscoveryChoice()     {}
func (*ReplaceSpecType_DiscoveryCbip) isReplaceSpecType_DiscoveryChoice()       {}
func (*ReplaceSpecType_DiscoveryThirdParty) isReplaceSpecType_DiscoveryChoice() {}
func (*ReplaceSpecType_NoClusterId) isReplaceSpecType_ClusterIdentifierChoice() {}
func (*ReplaceSpecType_ClusterId) isReplaceSpecType_ClusterIdentifierChoice()   {}

func (m *ReplaceSpecType) GetDiscoveryChoice() isReplaceSpecType_DiscoveryChoice {
	if m != nil {
		return m.DiscoveryChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetClusterIdentifierChoice() isReplaceSpecType_ClusterIdentifierChoice {
	if m != nil {
		return m.ClusterIdentifierChoice
	}
	return nil
}

func (m *ReplaceSpecType) GetWhere() *schema.NetworkSiteRefSelector {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *ReplaceSpecType) GetDiscoveryK8S() *K8SDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*ReplaceSpecType_DiscoveryK8S); ok {
		return x.DiscoveryK8S
	}
	return nil
}

func (m *ReplaceSpecType) GetDiscoveryConsul() *ConsulDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*ReplaceSpecType_DiscoveryConsul); ok {
		return x.DiscoveryConsul
	}
	return nil
}

func (m *ReplaceSpecType) GetDiscoveryCbip() *CbipDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*ReplaceSpecType_DiscoveryCbip); ok {
		return x.DiscoveryCbip
	}
	return nil
}

func (m *ReplaceSpecType) GetDiscoveryThirdParty() *ThirdPartyDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*ReplaceSpecType_DiscoveryThirdParty); ok {
		return x.DiscoveryThirdParty
	}
	return nil
}

func (m *ReplaceSpecType) GetNoClusterId() *schema.Empty {
	if x, ok := m.GetClusterIdentifierChoice().(*ReplaceSpecType_NoClusterId); ok {
		return x.NoClusterId
	}
	return nil
}

func (m *ReplaceSpecType) GetClusterId() string {
	if x, ok := m.GetClusterIdentifierChoice().(*ReplaceSpecType_ClusterId); ok {
		return x.ClusterId
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_DiscoveryK8S)(nil),
		(*ReplaceSpecType_DiscoveryConsul)(nil),
		(*ReplaceSpecType_DiscoveryCbip)(nil),
		(*ReplaceSpecType_DiscoveryThirdParty)(nil),
		(*ReplaceSpecType_NoClusterId)(nil),
		(*ReplaceSpecType_ClusterId)(nil),
	}
}

// Get discovery
//
// x-displayName: "Get Discovery"
// API to Get discovery object for a site or virtual site in system namespace
type GetSpecType struct {
	Where      *schema.NetworkSiteRefSelector `protobuf:"bytes,1,opt,name=where,proto3" json:"where,omitempty"`
	Type       schema.DiscoveryType           `protobuf:"varint,2,opt,name=type,proto3,enum=ves.io.schema.DiscoveryType" json:"type,omitempty"`
	PublishVip *VipDiscoveryInfoType          `protobuf:"bytes,3,opt,name=publish_vip,json=publishVip,proto3" json:"publish_vip,omitempty"`
	// Types that are valid to be assigned to DiscoveryChoice:
	//	*GetSpecType_DiscoveryK8S
	//	*GetSpecType_DiscoveryConsul
	//	*GetSpecType_DiscoveryCbip
	//	*GetSpecType_DiscoveryThirdParty
	DiscoveryChoice isGetSpecType_DiscoveryChoice `protobuf_oneof:"discovery_choice"`
	// Types that are valid to be assigned to ClusterIdentifierChoice:
	//	*GetSpecType_NoClusterId
	//	*GetSpecType_ClusterId
	ClusterIdentifierChoice isGetSpecType_ClusterIdentifierChoice `protobuf_oneof:"cluster_identifier_choice"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{33}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_DiscoveryChoice interface {
	isGetSpecType_DiscoveryChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_ClusterIdentifierChoice interface {
	isGetSpecType_ClusterIdentifierChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_DiscoveryK8S struct {
	DiscoveryK8S *K8SDiscoveryType `protobuf:"bytes,8,opt,name=discovery_k8s,json=discoveryK8s,proto3,oneof" json:"discovery_k8s,omitempty"`
}
type GetSpecType_DiscoveryConsul struct {
	DiscoveryConsul *ConsulDiscoveryType `protobuf:"bytes,9,opt,name=discovery_consul,json=discoveryConsul,proto3,oneof" json:"discovery_consul,omitempty"`
}
type GetSpecType_DiscoveryCbip struct {
	DiscoveryCbip *CbipDiscoveryType `protobuf:"bytes,14,opt,name=discovery_cbip,json=discoveryCbip,proto3,oneof" json:"discovery_cbip,omitempty"`
}
type GetSpecType_DiscoveryThirdParty struct {
	DiscoveryThirdParty *ThirdPartyDiscoveryType `protobuf:"bytes,15,opt,name=discovery_third_party,json=discoveryThirdParty,proto3,oneof" json:"discovery_third_party,omitempty"`
}
type GetSpecType_NoClusterId struct {
	NoClusterId *schema.Empty `protobuf:"bytes,12,opt,name=no_cluster_id,json=noClusterId,proto3,oneof" json:"no_cluster_id,omitempty"`
}
type GetSpecType_ClusterId struct {
	ClusterId string `protobuf:"bytes,13,opt,name=cluster_id,json=clusterId,proto3,oneof" json:"cluster_id,omitempty"`
}

func (*GetSpecType_DiscoveryK8S) isGetSpecType_DiscoveryChoice()        {}
func (*GetSpecType_DiscoveryConsul) isGetSpecType_DiscoveryChoice()     {}
func (*GetSpecType_DiscoveryCbip) isGetSpecType_DiscoveryChoice()       {}
func (*GetSpecType_DiscoveryThirdParty) isGetSpecType_DiscoveryChoice() {}
func (*GetSpecType_NoClusterId) isGetSpecType_ClusterIdentifierChoice() {}
func (*GetSpecType_ClusterId) isGetSpecType_ClusterIdentifierChoice()   {}

func (m *GetSpecType) GetDiscoveryChoice() isGetSpecType_DiscoveryChoice {
	if m != nil {
		return m.DiscoveryChoice
	}
	return nil
}
func (m *GetSpecType) GetClusterIdentifierChoice() isGetSpecType_ClusterIdentifierChoice {
	if m != nil {
		return m.ClusterIdentifierChoice
	}
	return nil
}

func (m *GetSpecType) GetWhere() *schema.NetworkSiteRefSelector {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *GetSpecType) GetType() schema.DiscoveryType {
	if m != nil {
		return m.Type
	}
	return schema.INVALID_DISCOVERY
}

func (m *GetSpecType) GetPublishVip() *VipDiscoveryInfoType {
	if m != nil {
		return m.PublishVip
	}
	return nil
}

func (m *GetSpecType) GetDiscoveryK8S() *K8SDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*GetSpecType_DiscoveryK8S); ok {
		return x.DiscoveryK8S
	}
	return nil
}

func (m *GetSpecType) GetDiscoveryConsul() *ConsulDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*GetSpecType_DiscoveryConsul); ok {
		return x.DiscoveryConsul
	}
	return nil
}

func (m *GetSpecType) GetDiscoveryCbip() *CbipDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*GetSpecType_DiscoveryCbip); ok {
		return x.DiscoveryCbip
	}
	return nil
}

func (m *GetSpecType) GetDiscoveryThirdParty() *ThirdPartyDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*GetSpecType_DiscoveryThirdParty); ok {
		return x.DiscoveryThirdParty
	}
	return nil
}

func (m *GetSpecType) GetNoClusterId() *schema.Empty {
	if x, ok := m.GetClusterIdentifierChoice().(*GetSpecType_NoClusterId); ok {
		return x.NoClusterId
	}
	return nil
}

func (m *GetSpecType) GetClusterId() string {
	if x, ok := m.GetClusterIdentifierChoice().(*GetSpecType_ClusterId); ok {
		return x.ClusterId
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_DiscoveryK8S)(nil),
		(*GetSpecType_DiscoveryConsul)(nil),
		(*GetSpecType_DiscoveryCbip)(nil),
		(*GetSpecType_DiscoveryThirdParty)(nil),
		(*GetSpecType_NoClusterId)(nil),
		(*GetSpecType_ClusterId)(nil),
	}
}

func init() {
	proto.RegisterEnum("ves.io.schema.discovery.SchemeType", SchemeType_name, SchemeType_value)
	golang_proto.RegisterEnum("ves.io.schema.discovery.SchemeType", SchemeType_name, SchemeType_value)
	proto.RegisterEnum("ves.io.schema.discovery.VirtualIPDiscoveryType", VirtualIPDiscoveryType_name, VirtualIPDiscoveryType_value)
	golang_proto.RegisterEnum("ves.io.schema.discovery.VirtualIPDiscoveryType", VirtualIPDiscoveryType_name, VirtualIPDiscoveryType_value)
	proto.RegisterEnum("ves.io.schema.discovery.K8SDNSMode", K8SDNSMode_name, K8SDNSMode_value)
	golang_proto.RegisterEnum("ves.io.schema.discovery.K8SDNSMode", K8SDNSMode_name, K8SDNSMode_value)
	proto.RegisterType((*VerStatusType)(nil), "ves.io.schema.discovery.VerStatusType")
	golang_proto.RegisterType((*VerStatusType)(nil), "ves.io.schema.discovery.VerStatusType")
	proto.RegisterType((*PodInfoType)(nil), "ves.io.schema.discovery.PodInfoType")
	golang_proto.RegisterType((*PodInfoType)(nil), "ves.io.schema.discovery.PodInfoType")
	proto.RegisterType((*PortInfoType)(nil), "ves.io.schema.discovery.PortInfoType")
	golang_proto.RegisterType((*PortInfoType)(nil), "ves.io.schema.discovery.PortInfoType")
	proto.RegisterType((*DiscoveredServiceType)(nil), "ves.io.schema.discovery.DiscoveredServiceType")
	golang_proto.RegisterType((*DiscoveredServiceType)(nil), "ves.io.schema.discovery.DiscoveredServiceType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.discovery.DiscoveredServiceType.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.discovery.DiscoveredServiceType.LabelsEntry")
	proto.RegisterMapType((map[uint32]uint32)(nil), "ves.io.schema.discovery.DiscoveredServiceType.PortMapEntry")
	golang_proto.RegisterMapType((map[uint32]uint32)(nil), "ves.io.schema.discovery.DiscoveredServiceType.PortMapEntry")
	proto.RegisterType((*TLSClientConfigType)(nil), "ves.io.schema.discovery.TLSClientConfigType")
	golang_proto.RegisterType((*TLSClientConfigType)(nil), "ves.io.schema.discovery.TLSClientConfigType")
	proto.RegisterType((*RestConfigType)(nil), "ves.io.schema.discovery.RestConfigType")
	golang_proto.RegisterType((*RestConfigType)(nil), "ves.io.schema.discovery.RestConfigType")
	proto.RegisterType((*K8SAccessInfo)(nil), "ves.io.schema.discovery.K8SAccessInfo")
	golang_proto.RegisterType((*K8SAccessInfo)(nil), "ves.io.schema.discovery.K8SAccessInfo")
	proto.RegisterType((*ConsulHttpBasicAuthInfoType)(nil), "ves.io.schema.discovery.ConsulHttpBasicAuthInfoType")
	golang_proto.RegisterType((*ConsulHttpBasicAuthInfoType)(nil), "ves.io.schema.discovery.ConsulHttpBasicAuthInfoType")
	proto.RegisterType((*ConsulAccessInfo)(nil), "ves.io.schema.discovery.ConsulAccessInfo")
	golang_proto.RegisterType((*ConsulAccessInfo)(nil), "ves.io.schema.discovery.ConsulAccessInfo")
	proto.RegisterType((*VipDiscoveryInfoType)(nil), "ves.io.schema.discovery.VipDiscoveryInfoType")
	golang_proto.RegisterType((*VipDiscoveryInfoType)(nil), "ves.io.schema.discovery.VipDiscoveryInfoType")
	proto.RegisterType((*K8SPublishType)(nil), "ves.io.schema.discovery.K8SPublishType")
	golang_proto.RegisterType((*K8SPublishType)(nil), "ves.io.schema.discovery.K8SPublishType")
	proto.RegisterType((*K8SDelegationType)(nil), "ves.io.schema.discovery.K8SDelegationType")
	golang_proto.RegisterType((*K8SDelegationType)(nil), "ves.io.schema.discovery.K8SDelegationType")
	proto.RegisterType((*K8SVipDiscoveryInfoType)(nil), "ves.io.schema.discovery.K8SVipDiscoveryInfoType")
	golang_proto.RegisterType((*K8SVipDiscoveryInfoType)(nil), "ves.io.schema.discovery.K8SVipDiscoveryInfoType")
	proto.RegisterType((*ConsulVipDiscoveryInfoType)(nil), "ves.io.schema.discovery.ConsulVipDiscoveryInfoType")
	golang_proto.RegisterType((*ConsulVipDiscoveryInfoType)(nil), "ves.io.schema.discovery.ConsulVipDiscoveryInfoType")
	proto.RegisterType((*K8SDiscoveryType)(nil), "ves.io.schema.discovery.K8SDiscoveryType")
	golang_proto.RegisterType((*K8SDiscoveryType)(nil), "ves.io.schema.discovery.K8SDiscoveryType")
	proto.RegisterType((*ConsulDiscoveryType)(nil), "ves.io.schema.discovery.ConsulDiscoveryType")
	golang_proto.RegisterType((*ConsulDiscoveryType)(nil), "ves.io.schema.discovery.ConsulDiscoveryType")
	proto.RegisterType((*CbipDiscoveryType)(nil), "ves.io.schema.discovery.CbipDiscoveryType")
	golang_proto.RegisterType((*CbipDiscoveryType)(nil), "ves.io.schema.discovery.CbipDiscoveryType")
	proto.RegisterType((*ThirdPartyDiscoveryType)(nil), "ves.io.schema.discovery.ThirdPartyDiscoveryType")
	golang_proto.RegisterType((*ThirdPartyDiscoveryType)(nil), "ves.io.schema.discovery.ThirdPartyDiscoveryType")
	proto.RegisterType((*CbipCluster)(nil), "ves.io.schema.discovery.CbipCluster")
	golang_proto.RegisterType((*CbipCluster)(nil), "ves.io.schema.discovery.CbipCluster")
	proto.RegisterType((*CbipDeviceConfig)(nil), "ves.io.schema.discovery.CbipDeviceConfig")
	golang_proto.RegisterType((*CbipDeviceConfig)(nil), "ves.io.schema.discovery.CbipDeviceConfig")
	proto.RegisterType((*CbipAdminCredentials)(nil), "ves.io.schema.discovery.CbipAdminCredentials")
	golang_proto.RegisterType((*CbipAdminCredentials)(nil), "ves.io.schema.discovery.CbipAdminCredentials")
	proto.RegisterType((*ManagementPort)(nil), "ves.io.schema.discovery.ManagementPort")
	golang_proto.RegisterType((*ManagementPort)(nil), "ves.io.schema.discovery.ManagementPort")
	proto.RegisterType((*CbipCertificateAuthority)(nil), "ves.io.schema.discovery.CbipCertificateAuthority")
	golang_proto.RegisterType((*CbipCertificateAuthority)(nil), "ves.io.schema.discovery.CbipCertificateAuthority")
	proto.RegisterType((*VirtualServerFilter)(nil), "ves.io.schema.discovery.VirtualServerFilter")
	golang_proto.RegisterType((*VirtualServerFilter)(nil), "ves.io.schema.discovery.VirtualServerFilter")
	proto.RegisterType((*NamespaceMapping)(nil), "ves.io.schema.discovery.NamespaceMapping")
	golang_proto.RegisterType((*NamespaceMapping)(nil), "ves.io.schema.discovery.NamespaceMapping")
	proto.RegisterType((*NamespaceMappingItem)(nil), "ves.io.schema.discovery.NamespaceMappingItem")
	golang_proto.RegisterType((*NamespaceMappingItem)(nil), "ves.io.schema.discovery.NamespaceMappingItem")
	proto.RegisterType((*K8SNamespaceMapping)(nil), "ves.io.schema.discovery.K8SNamespaceMapping")
	golang_proto.RegisterType((*K8SNamespaceMapping)(nil), "ves.io.schema.discovery.K8SNamespaceMapping")
	proto.RegisterType((*K8SNamespaceMappingItem)(nil), "ves.io.schema.discovery.K8SNamespaceMappingItem")
	golang_proto.RegisterType((*K8SNamespaceMappingItem)(nil), "ves.io.schema.discovery.K8SNamespaceMappingItem")
	proto.RegisterType((*ConsulNamespaceMapping)(nil), "ves.io.schema.discovery.ConsulNamespaceMapping")
	golang_proto.RegisterType((*ConsulNamespaceMapping)(nil), "ves.io.schema.discovery.ConsulNamespaceMapping")
	proto.RegisterType((*ConsulNamespaceMappingItem)(nil), "ves.io.schema.discovery.ConsulNamespaceMappingItem")
	golang_proto.RegisterType((*ConsulNamespaceMappingItem)(nil), "ves.io.schema.discovery.ConsulNamespaceMappingItem")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.discovery.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.discovery.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.discovery.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.discovery.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.discovery.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.discovery.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.discovery.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.discovery.GetSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/discovery/types.proto", fileDescriptor_1beabb40327c3d92)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/discovery/types.proto", fileDescriptor_1beabb40327c3d92)
}

var fileDescriptor_1beabb40327c3d92 = []byte{
	// 4190 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x7b, 0x5d, 0x6c, 0x1b, 0x57,
	0x76, 0x30, 0x2f, 0xff, 0x44, 0x1e, 0x4a, 0x14, 0x75, 0x2d, 0xdb, 0x13, 0xda, 0x1f, 0x4d, 0x33,
	0x9b, 0x5d, 0x59, 0xa1, 0xa8, 0x3f, 0xc7, 0x56, 0x64, 0x6c, 0xbe, 0x88, 0x94, 0x63, 0xc9, 0xb6,
	0x14, 0x75, 0x28, 0x3b, 0xe9, 0xee, 0xa2, 0xec, 0x90, 0x73, 0x45, 0x4d, 0x3d, 0xe4, 0xcc, 0xce,
	0x0c, 0x65, 0xeb, 0xc1, 0x0b, 0x6f, 0x80, 0x6e, 0x5b, 0xb7, 0xbb, 0x08, 0xd2, 0x97, 0x36, 0x28,
	0x50, 0xb4, 0x4f, 0xbb, 0x41, 0xd1, 0x87, 0x3e, 0xf4, 0x61, 0xa9, 0x02, 0x46, 0x80, 0x02, 0x81,
	0x5f, 0xaa, 0xb7, 0x35, 0xd2, 0xa2, 0x48, 0xe4, 0x97, 0x34, 0x2f, 0x0d, 0xf6, 0xa5, 0x41, 0x5e,
	0x52, 0xdc, 0x3b, 0x77, 0x86, 0xc3, 0x5f, 0x49, 0x8e, 0x51, 0xec, 0x43, 0x9e, 0x34, 0xbc, 0xf7,
	0x9c, 0x73, 0xcf, 0x3d, 0x7f, 0xf7, 0xdc, 0x73, 0xae, 0xe0, 0xc5, 0x1d, 0x62, 0xe6, 0x14, 0x6d,
	0xda, 0xac, 0x6c, 0x93, 0x9a, 0x34, 0x2d, 0x2b, 0x66, 0x45, 0xdb, 0x21, 0xc6, 0xee, 0xb4, 0xb5,
	0xab, 0x13, 0x33, 0xa7, 0x1b, 0x9a, 0xa5, 0xe1, 0xd3, 0x36, 0x50, 0xce, 0x06, 0xca, 0xb9, 0x40,
	0xc9, 0xa9, 0xaa, 0x62, 0x6d, 0x37, 0xca, 0xb9, 0x8a, 0x56, 0x9b, 0xae, 0x6a, 0x55, 0x6d, 0x9a,
	0xc1, 0x97, 0x1b, 0x5b, 0xec, 0x17, 0xfb, 0xc1, 0xbe, 0x6c, 0x3a, 0xc9, 0x73, 0x55, 0x4d, 0xab,
	0xaa, 0xa4, 0x05, 0x65, 0x29, 0x35, 0x62, 0x5a, 0x52, 0x4d, 0xe7, 0x00, 0x67, 0xda, 0xb9, 0xd1,
	0x74, 0x4b, 0xd1, 0xea, 0x9c, 0x8b, 0xe4, 0x0b, 0xed, 0x93, 0x1e, 0x06, 0x93, 0x67, 0xdb, 0xa7,
	0x76, 0x24, 0x55, 0x91, 0x25, 0x8b, 0xf0, 0xd9, 0x74, 0xc7, 0xac, 0x42, 0xee, 0x96, 0xda, 0x49,
	0x9f, 0xeb, 0x86, 0x30, 0xbd, 0x0b, 0x64, 0xfe, 0x03, 0xc1, 0xc8, 0x6d, 0x62, 0x14, 0x2d, 0xc9,
	0x6a, 0x98, 0x9b, 0xbb, 0x3a, 0xc1, 0x67, 0x21, 0x5a, 0xd1, 0xea, 0x75, 0x52, 0xb1, 0x88, 0x2c,
	0xa0, 0x34, 0x9a, 0x88, 0x88, 0xad, 0x01, 0x8c, 0x21, 0x68, 0x2a, 0x16, 0x11, 0xfc, 0x69, 0x34,
	0x11, 0x15, 0xd9, 0x37, 0x9e, 0x81, 0x20, 0x25, 0x29, 0x04, 0xd2, 0x68, 0x22, 0x3e, 0x77, 0x36,
	0xd7, 0x2e, 0xd4, 0x65, 0x47, 0xa8, 0x94, 0xba, 0xc8, 0x20, 0xf1, 0x75, 0x88, 0x98, 0xc4, 0xd8,
	0x51, 0x2a, 0xc4, 0x14, 0x82, 0xe9, 0xc0, 0x44, 0x6c, 0x2e, 0x97, 0xeb, 0xa3, 0x0a, 0x17, 0x9f,
	0xc8, 0x45, 0x1b, 0x85, 0xd1, 0x71, 0xf1, 0x17, 0xcf, 0x7c, 0xd8, 0x44, 0xa7, 0xe1, 0x24, 0xc0,
	0xed, 0xab, 0x62, 0xda, 0xde, 0x07, 0x1e, 0x9a, 0xcd, 0xce, 0x65, 0xe7, 0xb3, 0x17, 0x33, 0xcb,
	0x10, 0xdb, 0xd0, 0xe4, 0xd5, 0xfa, 0x96, 0xc6, 0xf6, 0x76, 0x0e, 0x22, 0xba, 0x26, 0x97, 0xea,
	0x52, 0x8d, 0xb0, 0xad, 0x45, 0xf3, 0xc1, 0x2f, 0x9b, 0xc8, 0x27, 0x0e, 0xe9, 0x9a, 0xbc, 0x2e,
	0xd5, 0x08, 0x1e, 0x07, 0xbf, 0xa2, 0xdb, 0x9b, 0xe3, 0x53, 0x7e, 0x45, 0xcf, 0xdc, 0x87, 0xe1,
	0x0d, 0xcd, 0xb0, 0x5c, 0x32, 0xe7, 0x21, 0xa8, 0x6b, 0x86, 0xc5, 0x48, 0x8c, 0xe4, 0x47, 0x7e,
	0xfd, 0x5f, 0x8f, 0x02, 0x91, 0xc9, 0xb0, 0xf0, 0xf5, 0xd7, 0x81, 0x09, 0x24, 0xb2, 0x29, 0x9c,
	0x84, 0x08, 0x13, 0x70, 0x45, 0x53, 0xb9, 0xac, 0xdc, 0xdf, 0x38, 0x07, 0x31, 0x4b, 0x32, 0xaa,
	0xc4, 0x2a, 0x31, 0x2a, 0x81, 0x5e, 0x54, 0xc0, 0x86, 0xa0, 0xcb, 0x66, 0xfe, 0x27, 0x02, 0x27,
	0x7b, 0x4a, 0x01, 0xcf, 0xc0, 0x30, 0x97, 0x83, 0x77, 0x4f, 0x23, 0x94, 0x71, 0x4a, 0x2e, 0x68,
	0xf8, 0x85, 0xd7, 0xc5, 0x18, 0x07, 0x61, 0x1b, 0x7c, 0x19, 0xa2, 0x14, 0xd2, 0xd4, 0xa5, 0x0a,
	0x57, 0x62, 0x27, 0x78, 0x6b, 0xde, 0x4b, 0xde, 0x55, 0x70, 0x5f, 0xf2, 0x8c, 0xa1, 0x2c, 0x40,
	0x45, 0x6d, 0x98, 0x16, 0x31, 0x4a, 0x8a, 0x2e, 0x04, 0xbb, 0xe0, 0x75, 0x24, 0x46, 0x39, 0xc0,
	0xaa, 0x8e, 0xef, 0x41, 0x58, 0x95, 0xca, 0x44, 0x35, 0x85, 0x10, 0x33, 0x82, 0xc5, 0xe3, 0x19,
	0x41, 0xee, 0x26, 0x43, 0xbe, 0x5a, 0xb7, 0x8c, 0xdd, 0xfc, 0x77, 0xe8, 0x0a, 0xa1, 0xf7, 0x91,
	0x3f, 0x91, 0xa0, 0x5f, 0xf0, 0x3e, 0x1a, 0x9a, 0x0c, 0x19, 0x81, 0x7d, 0x84, 0x0e, 0x3e, 0xf9,
	0xd7, 0x40, 0xf8, 0xe1, 0x1e, 0xf2, 0x47, 0x7c, 0x22, 0x5f, 0x0f, 0x2f, 0x50, 0x0d, 0xca, 0xa6,
	0x10, 0x66, 0xeb, 0x7e, 0xa7, 0xef, 0xba, 0x1e, 0xe3, 0x11, 0x19, 0x06, 0xfe, 0xe3, 0x00, 0xb5,
	0x21, 0xc3, 0x2a, 0xd5, 0x24, 0x5d, 0x18, 0x62, 0xe8, 0x57, 0x8e, 0xc9, 0x36, 0x55, 0xea, 0x9a,
	0xa4, 0xdb, 0x7c, 0xff, 0x83, 0xff, 0xc9, 0x7d, 0xf4, 0x59, 0x13, 0x21, 0xca, 0xf5, 0xc8, 0xfb,
	0x08, 0x32, 0xae, 0x11, 0x38, 0x23, 0x93, 0xee, 0x08, 0xdd, 0xca, 0xf4, 0xc3, 0x3d, 0xf4, 0x32,
	0xbe, 0xf0, 0x79, 0x13, 0xbd, 0xb4, 0x5a, 0xaf, 0x68, 0x35, 0xa5, 0x5e, 0x4d, 0x53, 0x86, 0xd2,
	0xf5, 0x46, 0xad, 0x4c, 0x8c, 0xb4, 0xb5, 0x2d, 0x59, 0xe9, 0x3a, 0x21, 0xb2, 0x99, 0x36, 0x48,
	0x4d, 0xd2, 0x29, 0x4e, 0xea, 0xe1, 0x1e, 0x4a, 0x62, 0xe1, 0xa0, 0x89, 0xc6, 0x5d, 0x1c, 0xca,
	0x45, 0x7a, 0x9d, 0xe1, 0x50, 0x10, 0x78, 0xb8, 0x87, 0xc2, 0x38, 0xf8, 0x51, 0x13, 0xf9, 0x5a,
	0x02, 0x63, 0x0b, 0xbe, 0xf5, 0x70, 0x0f, 0x15, 0x93, 0xbf, 0xf7, 0x79, 0x13, 0xad, 0xbd, 0xd9,
	0xb0, 0xaa, 0x5a, 0xcf, 0x05, 0xef, 0x2a, 0xaa, 0x9a, 0xae, 0x6a, 0x69, 0x4b, 0x4b, 0x3b, 0xfa,
	0xdd, 0x48, 0x3b, 0x3e, 0x9a, 0xd6, 0x8c, 0x74, 0x5d, 0x93, 0xc9, 0x14, 0x43, 0x73, 0x46, 0x5d,
	0xc6, 0x92, 0x8c, 0x31, 0x97, 0x76, 0x2f, 0xc6, 0x92, 0x8c, 0x31, 0x01, 0x51, 0x4f, 0x65, 0xc2,
	0xc3, 0x57, 0x20, 0x44, 0x3f, 0x4d, 0x21, 0xc2, 0x74, 0xf0, 0xd2, 0x00, 0x15, 0xb6, 0x3c, 0x57,
	0xb4, 0x71, 0xa8, 0x61, 0xb7, 0xcc, 0x74, 0xe7, 0x92, 0x00, 0xbd, 0x0c, 0x35, 0xe6, 0x1a, 0xea,
	0xce, 0xa5, 0xe4, 0xab, 0x10, 0xf3, 0x58, 0x1b, 0x4e, 0x40, 0xe0, 0x0e, 0xd9, 0xb5, 0xfd, 0x4d,
	0xa4, 0x9f, 0x78, 0x1c, 0x42, 0x3b, 0x92, 0xda, 0x70, 0x22, 0xa3, 0xfd, 0x63, 0xd1, 0xbf, 0x80,
	0x92, 0x8b, 0x76, 0xf4, 0x70, 0x34, 0xee, 0xc5, 0x1d, 0xe9, 0x81, 0x3b, 0xe2, 0xc1, 0x5d, 0xbc,
	0xff, 0xb8, 0x89, 0x76, 0xe1, 0x05, 0x18, 0xe2, 0xf6, 0x93, 0x8c, 0xb7, 0x7b, 0x3c, 0x08, 0x10,
	0x5d, 0x77, 0xfc, 0x35, 0x19, 0xf3, 0x38, 0x37, 0x9c, 0x82, 0x20, 0xdd, 0xb2, 0x17, 0x83, 0x3a,
	0x31, 0x60, 0xf0, 0xaf, 0x6e, 0x24, 0x87, 0xbd, 0x8e, 0x4a, 0x61, 0x57, 0x37, 0x76, 0x2e, 0x51,
	0x58, 0xaf, 0x5c, 0x32, 0xef, 0x04, 0xe1, 0xc4, 0xe6, 0xcd, 0x62, 0x41, 0x55, 0x48, 0xdd, 0x2a,
	0x68, 0xf5, 0x2d, 0xa5, 0xca, 0xdc, 0x7c, 0x01, 0x98, 0xd7, 0x13, 0xc3, 0x1b, 0x76, 0x4e, 0x3b,
	0xe2, 0x0b, 0x19, 0x01, 0xe1, 0x81, 0x9f, 0x0b, 0x72, 0x1b, 0x89, 0x60, 0xc3, 0xb2, 0xf8, 0xb3,
	0x06, 0xa3, 0x15, 0x62, 0x58, 0xca, 0x96, 0x52, 0x91, 0x2c, 0x52, 0x6a, 0x18, 0x76, 0x78, 0x8c,
	0xcd, 0xbd, 0xd0, 0xa1, 0xc0, 0x22, 0xa9, 0x18, 0xc4, 0xa2, 0xab, 0xe5, 0xa3, 0xdc, 0x43, 0x04,
	0x24, 0xc6, 0x3d, 0xc8, 0xb7, 0x0c, 0x15, 0x5f, 0x87, 0x98, 0x67, 0x44, 0x08, 0x31, 0x46, 0x26,
	0xbe, 0x6c, 0xa2, 0xe0, 0xdf, 0xef, 0xa1, 0x98, 0x4e, 0x6a, 0xd9, 0x74, 0x59, 0x32, 0xc9, 0xa5,
	0x8b, 0x94, 0x9b, 0xb0, 0x11, 0x9c, 0x78, 0xf0, 0x20, 0xc2, 0x59, 0x7c, 0x17, 0x51, 0x15, 0xb7,
	0x90, 0xf1, 0x02, 0x0c, 0xdd, 0x21, 0xbb, 0x8c, 0xa5, 0xc0, 0x61, 0x2c, 0x05, 0xf7, 0x9b, 0x08,
	0x89, 0xe1, 0x3b, 0x64, 0x97, 0x72, 0x21, 0x02, 0xae, 0x48, 0xa5, 0xce, 0x7d, 0x05, 0x8f, 0xb1,
	0xaf, 0x44, 0x45, 0x2a, 0xb4, 0xef, 0x6c, 0x1d, 0xe2, 0x96, 0x41, 0x55, 0x21, 0x97, 0x2a, 0x12,
	0xa3, 0x17, 0x3e, 0xe6, 0xe6, 0x86, 0x39, 0x7e, 0x41, 0xba, 0x65, 0xa8, 0x8b, 0x0b, 0x1f, 0x36,
	0xd1, 0x45, 0x10, 0x60, 0xac, 0xc8, 0x94, 0x91, 0xde, 0x90, 0x0c, 0xa9, 0x46, 0x2c, 0x62, 0x98,
	0x38, 0x30, 0x9b, 0xbd, 0x44, 0x67, 0x6c, 0x35, 0xb7, 0xcd, 0xbc, 0x92, 0x9d, 0xcf, 0xfc, 0x15,
	0x82, 0xb8, 0x48, 0x4c, 0xaf, 0xfe, 0x2f, 0x03, 0x48, 0xba, 0x52, 0xb2, 0xf5, 0xca, 0xd5, 0x2f,
	0x78, 0xd5, 0xff, 0x33, 0x3f, 0xff, 0xfa, 0x04, 0x21, 0x31, 0x2a, 0xe9, 0x8a, 0xbd, 0x2a, 0x5e,
	0x83, 0x88, 0xa5, 0x9a, 0x25, 0xa5, 0xbe, 0xa5, 0x71, 0xbd, 0x67, 0xfb, 0x3a, 0x6e, 0x0f, 0xc3,
	0xe3, 0x72, 0x1f, 0xb2, 0x54, 0x93, 0xba, 0x74, 0xe6, 0x9f, 0x02, 0x30, 0x72, 0x63, 0xa1, 0xb8,
	0x54, 0xa9, 0x10, 0x93, 0x8d, 0xe0, 0x15, 0x88, 0xdf, 0x69, 0x94, 0x49, 0x85, 0xa1, 0x30, 0xb1,
	0xa1, 0x23, 0xe9, 0x72, 0xc5, 0x27, 0x8e, 0xb4, 0x10, 0x6d, 0xa5, 0x8e, 0xf2, 0xb4, 0x47, 0xd1,
	0xea, 0x5e, 0x8e, 0xbf, 0xd7, 0x97, 0xe3, 0x76, 0x29, 0xad, 0xf8, 0xc4, 0x78, 0x8b, 0x02, 0xe3,
	0x6e, 0x02, 0x40, 0xa9, 0x97, 0xb8, 0x8b, 0x31, 0x2b, 0x8b, 0xe4, 0x87, 0xb8, 0x15, 0xac, 0xf8,
	0xc4, 0xa8, 0x52, 0x2f, 0xd8, 0x73, 0x78, 0x01, 0x22, 0x8a, 0xa9, 0xa9, 0x12, 0x4d, 0xc2, 0x6c,
	0x43, 0x1a, 0xef, 0x58, 0xf6, 0x6a, 0x4d, 0xb7, 0x76, 0xf3, 0xc1, 0x47, 0x14, 0x15, 0x89, 0x2e,
	0x34, 0x5e, 0x84, 0xa8, 0x41, 0xa4, 0xca, 0xb6, 0x54, 0x56, 0x6d, 0x87, 0x38, 0x0c, 0xb5, 0x05,
	0xbe, 0x18, 0xf9, 0xed, 0x6b, 0xa1, 0xd9, 0x99, 0xec, 0xec, 0x6c, 0x3e, 0x05, 0x31, 0x2e, 0x43,
	0x96, 0xb0, 0x8d, 0x52, 0xd8, 0xfd, 0x26, 0x82, 0x83, 0x26, 0x0a, 0xcc, 0x66, 0xe7, 0xf2, 0x53,
	0x70, 0xea, 0xce, 0x82, 0x59, 0x62, 0xd9, 0x14, 0xb1, 0xee, 0x6a, 0xc6, 0x9d, 0x52, 0x65, 0x5b,
	0x53, 0x2a, 0x04, 0x9f, 0x78, 0xd4, 0x44, 0x34, 0x5a, 0x53, 0xf0, 0x18, 0x05, 0xbf, 0x98, 0x7d,
	0xe5, 0x7a, 0x30, 0x02, 0x89, 0xd8, 0xf5, 0x60, 0x24, 0x96, 0x18, 0xce, 0xfc, 0x19, 0x82, 0x33,
	0x05, 0xad, 0x6e, 0x36, 0xd4, 0x15, 0xcb, 0xd2, 0xf3, 0x92, 0xa9, 0x54, 0x96, 0x1a, 0xd6, 0xb6,
	0x9b, 0x5d, 0x4d, 0x42, 0xb4, 0x61, 0xb6, 0x87, 0x96, 0x8e, 0x94, 0x23, 0x42, 0xe7, 0x59, 0x38,
	0x79, 0x0d, 0x40, 0x97, 0x4c, 0xf3, 0xae, 0x7c, 0xb4, 0x48, 0x62, 0x9b, 0x4f, 0xd4, 0x46, 0xb9,
	0x65, 0xa8, 0x99, 0xbf, 0xf4, 0x43, 0xc2, 0xe6, 0xc5, 0x63, 0x43, 0x1b, 0xdd, 0x9a, 0x47, 0xc7,
	0xd2, 0x7c, 0x97, 0xde, 0xdf, 0x80, 0x30, 0x43, 0xb1, 0x23, 0x7c, 0x7c, 0xee, 0xc5, 0xbe, 0x84,
	0x8a, 0x0c, 0xac, 0x33, 0x3c, 0x70, 0x6c, 0x4c, 0x60, 0x7c, 0xdb, 0xb2, 0xf4, 0x52, 0x99, 0x0a,
	0xad, 0x24, 0x35, 0xac, 0x6d, 0x9b, 0x3d, 0x3b, 0x5e, 0x5d, 0xec, 0x4b, 0x75, 0x80, 0xb8, 0xc5,
	0xb1, 0xed, 0xce, 0xe1, 0xcc, 0x3f, 0xfb, 0x61, 0xfc, 0xb6, 0xa2, 0xbb, 0x99, 0xbb, 0xab, 0x9a,
	0x39, 0xc0, 0x7a, 0xa3, 0xac, 0x2a, 0xe6, 0x76, 0x69, 0x47, 0x31, 0xac, 0x86, 0xa4, 0xd2, 0x34,
	0x8f, 0x5d, 0x12, 0x78, 0xba, 0x9c, 0xe0, 0xf3, 0xb7, 0xed, 0xe9, 0x55, 0x1d, 0xaf, 0xf2, 0xdb,
	0x81, 0xbd, 0xf3, 0xe9, 0xbe, 0x3c, 0x3a, 0x18, 0x1b, 0x6d, 0x17, 0x06, 0x4e, 0xd6, 0xbe, 0x36,
	0x64, 0x21, 0x6a, 0x36, 0xca, 0xb2, 0x56, 0x93, 0x94, 0x3a, 0x4f, 0x46, 0xe3, 0xed, 0x87, 0x8e,
	0xd8, 0x02, 0xc0, 0xcb, 0x10, 0x91, 0xeb, 0x66, 0xa9, 0xa6, 0xc9, 0x84, 0xb9, 0xd0, 0x20, 0xb1,
	0xdf, 0x58, 0x28, 0x2e, 0xaf, 0x17, 0xd7, 0x34, 0xd9, 0x59, 0x70, 0x48, 0xae, 0x9b, 0xf4, 0x67,
	0x7b, 0xc2, 0x1c, 0x1a, 0x9c, 0x30, 0x67, 0xbe, 0x0f, 0xf1, 0x1b, 0x0b, 0xc5, 0x0d, 0x5b, 0x04,
	0x4c, 0x62, 0x6d, 0xe8, 0xe8, 0x10, 0xf4, 0x3f, 0x41, 0x30, 0x46, 0x39, 0x21, 0x2a, 0xa9, 0x4a,
	0xd4, 0x78, 0x36, 0xbb, 0x76, 0x8d, 0x8e, 0xb3, 0x6b, 0xff, 0xb3, 0xee, 0x3a, 0xf3, 0x6f, 0x7e,
	0x38, 0x7d, 0x63, 0xa1, 0xd8, 0xd3, 0x08, 0x66, 0x60, 0x48, 0x56, 0x4c, 0x16, 0x5e, 0xfc, 0xfd,
	0xc3, 0xcb, 0x0a, 0xa5, 0x66, 0x83, 0xe1, 0x02, 0x0c, 0x71, 0xb3, 0xe0, 0x96, 0xfa, 0xbd, 0x41,
	0x2c, 0x79, 0xc4, 0x47, 0x89, 0x70, 0x4c, 0x7c, 0x05, 0x46, 0x1c, 0xdb, 0xdb, 0xfa, 0xb1, 0x5c,
	0x37, 0x07, 0x85, 0xc5, 0x15, 0x9f, 0x38, 0xcc, 0x81, 0xdf, 0xa0, 0xb0, 0xb8, 0x08, 0x71, 0x2a,
	0x15, 0xd9, 0x95, 0x2c, 0x8f, 0x8c, 0x93, 0x03, 0x65, 0xd3, 0xa6, 0x07, 0x7a, 0x42, 0xc8, 0x75,
	0xb3, 0x35, 0x98, 0x7f, 0x09, 0xe2, 0x0e, 0x47, 0x9e, 0xd8, 0xe7, 0xa7, 0x31, 0xe6, 0xa0, 0x89,
	0x86, 0xd8, 0x0d, 0x94, 0xc5, 0x3e, 0x94, 0xf0, 0x67, 0x7e, 0x85, 0x20, 0x69, 0xbb, 0xe1, 0x73,
	0x12, 0xea, 0x4c, 0xa7, 0x50, 0xfb, 0x62, 0x70, 0xb0, 0xfc, 0xf9, 0x2e, 0x7e, 0x47, 0x3d, 0xfc,
	0x06, 0xe6, 0xb2, 0xf3, 0x9c, 0xd7, 0xff, 0x0e, 0x40, 0x82, 0xee, 0xdf, 0xeb, 0x88, 0xf8, 0x1a,
	0xc4, 0x24, 0x16, 0x23, 0xbd, 0x11, 0xf1, 0xbb, 0x83, 0xe4, 0xd7, 0x0a, 0xa9, 0x22, 0x48, 0xad,
	0xf0, 0x5a, 0x04, 0x47, 0x37, 0xde, 0x53, 0x75, 0x66, 0x10, 0xa5, 0x5e, 0x22, 0x13, 0x63, 0x9c,
	0x0a, 0x27, 0x1a, 0x93, 0xc9, 0x96, 0xd4, 0x50, 0xad, 0x92, 0xa4, 0xaa, 0x03, 0x8f, 0xcc, 0xe4,
	0x07, 0x7b, 0xe8, 0xd4, 0xdc, 0xb8, 0xb9, 0x2d, 0x19, 0x44, 0x9e, 0xb2, 0x4f, 0xb9, 0x86, 0xc1,
	0x54, 0xba, 0xe2, 0x13, 0x81, 0x93, 0x59, 0x52, 0x55, 0xfc, 0x43, 0x18, 0x73, 0x9d, 0x93, 0xde,
	0xf7, 0x74, 0xa5, 0x5e, 0xe5, 0x86, 0x93, 0x1d, 0xc4, 0xae, 0x9b, 0x91, 0xaf, 0xd9, 0x38, 0x2b,
	0x3e, 0x31, 0x51, 0xef, 0x18, 0x5b, 0x7c, 0xfb, 0xc3, 0x26, 0xda, 0x84, 0xd3, 0x80, 0x6d, 0x31,
	0xa5, 0x0b, 0x06, 0x91, 0x49, 0xdd, 0x52, 0x24, 0xd5, 0xc4, 0x68, 0x16, 0xce, 0xc3, 0xd9, 0xdb,
	0xab, 0x1b, 0x69, 0xee, 0x0c, 0xf4, 0x5e, 0x54, 0xf0, 0x72, 0x8a, 0xd1, 0x1c, 0x9c, 0x82, 0x31,
	0x77, 0xa5, 0x34, 0x27, 0x8b, 0xd1, 0x7c, 0xfe, 0x65, 0x10, 0xba, 0xd8, 0xf6, 0x6a, 0x9c, 0x9e,
	0x82, 0x81, 0xd6, 0xc9, 0x1c, 0x48, 0x04, 0x33, 0xff, 0x18, 0x84, 0x13, 0xb6, 0x75, 0xb6, 0x2b,
	0xfd, 0x7a, 0x2f, 0xa5, 0x5f, 0x38, 0xe4, 0x9c, 0xe9, 0xa3, 0xf7, 0xdb, 0x3d, 0xf5, 0x3e, 0x7f,
	0x08, 0xb1, 0xc3, 0x55, 0xff, 0xa3, 0xa3, 0xab, 0xfe, 0x45, 0x7e, 0xa4, 0xf6, 0xb7, 0x00, 0x01,
	0x75, 0xd8, 0x80, 0xd1, 0xdf, 0x06, 0xa6, 0x0f, 0x61, 0xbd, 0xd3, 0x0c, 0xf2, 0xf8, 0xc9, 0x7d,
	0x74, 0x70, 0x3f, 0x7c, 0xab, 0xde, 0x30, 0x89, 0x6c, 0x1f, 0xed, 0xff, 0xc7, 0xa6, 0xb1, 0x34,
	0xc0, 0x34, 0x5e, 0xea, 0x30, 0x8d, 0x2f, 0x9a, 0x08, 0x3d, 0xfc, 0x0a, 0xc5, 0x65, 0x52, 0xd3,
	0x66, 0xb3, 0x16, 0x31, 0xad, 0x6c, 0xc5, 0xb0, 0xb8, 0xc1, 0x3c, 0xf5, 0xc3, 0x58, 0xa1, 0xec,
	0xd1, 0x0d, 0x33, 0x17, 0x05, 0x46, 0x2a, 0x65, 0x45, 0x77, 0x32, 0x5c, 0x53, 0x40, 0x87, 0xd4,
	0x57, 0x28, 0x09, 0x9e, 0xf2, 0xe6, 0x53, 0xec, 0x40, 0x7b, 0x0f, 0xf9, 0x13, 0x69, 0xe7, 0x2b,
	0x82, 0x9c, 0x2f, 0x01, 0x89, 0xc3, 0x95, 0x16, 0xb0, 0x89, 0x5f, 0x07, 0xac, 0xd4, 0x2d, 0x62,
	0xd4, 0x25, 0xb5, 0xa4, 0x96, 0x4b, 0xfc, 0x78, 0xb4, 0x2b, 0x5a, 0x3d, 0xe4, 0x2c, 0x26, 0x1c,
	0xe8, 0x9b, 0xe5, 0x65, 0xfb, 0xa4, 0xfc, 0x03, 0x88, 0xf2, 0x4b, 0x6c, 0x45, 0x12, 0x02, 0x8c,
	0xd1, 0xce, 0xda, 0xe5, 0x9b, 0xe5, 0x3f, 0x22, 0x15, 0x4b, 0x24, 0x5b, 0x2c, 0x15, 0x79, 0xf1,
	0x83, 0xfb, 0xa3, 0x9e, 0x3b, 0x99, 0xaa, 0x98, 0x96, 0xa7, 0x76, 0xc3, 0x38, 0x47, 0x76, 0x61,
	0x92, 0x18, 0x05, 0x69, 0x71, 0xe9, 0x71, 0x13, 0x7d, 0x1f, 0xae, 0xc0, 0xe9, 0x82, 0x2a, 0x99,
	0xa6, 0x52, 0x49, 0xe7, 0x57, 0xaf, 0x4d, 0xad, 0x6e, 0xa4, 0x9d, 0x2d, 0xe4, 0xd3, 0x1d, 0xd2,
	0x4a, 0x04, 0x33, 0x23, 0x35, 0x62, 0x49, 0xb2, 0x64, 0x49, 0x39, 0xaa, 0xa6, 0xcc, 0xaf, 0xfc,
	0x70, 0x7a, 0x73, 0x5b, 0x31, 0xe4, 0x0d, 0xc9, 0xb0, 0x76, 0xdb, 0x65, 0xfd, 0x23, 0x18, 0x96,
	0x74, 0x5d, 0xa5, 0x17, 0x46, 0x45, 0xab, 0xdb, 0xa2, 0x8e, 0xe6, 0x17, 0x9c, 0xcc, 0x20, 0xfc,
	0x1e, 0x0a, 0x24, 0x1e, 0xf9, 0x7b, 0x49, 0x92, 0x27, 0x0e, 0xbf, 0xe4, 0xa5, 0xb1, 0xf7, 0xf6,
	0x90, 0x3f, 0xe1, 0x13, 0xdb, 0xa8, 0xe1, 0xb7, 0x21, 0x66, 0x6a, 0x0d, 0xa3, 0x42, 0x4a, 0x15,
	0x45, 0x36, 0x04, 0x3f, 0x23, 0x7e, 0xd9, 0x4d, 0x3b, 0xe8, 0x5e, 0x43, 0x47, 0xa7, 0x0d, 0x36,
	0xad, 0x82, 0x22, 0x1b, 0xf8, 0x36, 0x8c, 0x93, 0x7b, 0xba, 0x62, 0xdb, 0x6a, 0xc9, 0x2d, 0x94,
	0xf3, 0x43, 0x2c, 0x99, 0xb3, 0x4b, 0xe9, 0x39, 0xa7, 0x94, 0x9e, 0xdb, 0x74, 0x20, 0xdc, 0x9b,
	0x92, 0x78, 0xa2, 0x45, 0xc0, 0x9d, 0xcd, 0xfc, 0x7b, 0x04, 0x62, 0x1e, 0x73, 0xc2, 0x8b, 0x10,
	0x71, 0x84, 0xc9, 0xe3, 0x56, 0xaa, 0x43, 0xbb, 0x6b, 0xc4, 0x34, 0xa5, 0x2a, 0x59, 0x23, 0x96,
	0x64, 0xd7, 0x94, 0x1d, 0x78, 0xfc, 0x13, 0x60, 0xc6, 0x56, 0x92, 0x89, 0x5d, 0xa3, 0xf6, 0x33,
	0xeb, 0xb8, 0x30, 0xd0, 0x8c, 0x97, 0x19, 0xac, 0xed, 0x89, 0xf9, 0x19, 0x66, 0x81, 0x89, 0x35,
	0x6d, 0x87, 0xc8, 0x9e, 0x9a, 0x58, 0x9b, 0xad, 0x44, 0x5a, 0x52, 0x13, 0x90, 0x18, 0xab, 0xb8,
	0x34, 0x4c, 0x5c, 0xe2, 0x96, 0x51, 0xab, 0xd6, 0xac, 0x92, 0xa2, 0x9b, 0xcc, 0x3c, 0xa3, 0xf9,
	0x2b, 0x8e, 0xfc, 0xa3, 0xef, 0xa1, 0x70, 0x26, 0x68, 0xf8, 0xef, 0xf5, 0xa0, 0xe6, 0xd5, 0x86,
	0x57, 0x07, 0x6c, 0x81, 0xb5, 0x6a, 0xcd, 0x5a, 0xd5, 0x4d, 0xfc, 0x03, 0x18, 0x93, 0xe4, 0x1a,
	0xbd, 0x8b, 0xb6, 0x42, 0x0b, 0x8f, 0x9c, 0x53, 0x03, 0x77, 0xb9, 0x44, 0xb1, 0x3c, 0xf1, 0x48,
	0x4c, 0x48, 0x1d, 0x23, 0x58, 0x83, 0xa4, 0x6d, 0xd6, 0x9e, 0x7a, 0x08, 0xbd, 0xaa, 0x68, 0x86,
	0x62, 0xed, 0xf2, 0xd0, 0x39, 0x3b, 0x38, 0x22, 0xb4, 0x30, 0x97, 0x1c, 0x44, 0x51, 0xa8, 0xf4,
	0x99, 0xc1, 0x7f, 0x08, 0x27, 0x9d, 0xdb, 0x08, 0x77, 0xe8, 0x2d, 0x45, 0xa5, 0x17, 0xec, 0xf0,
	0x21, 0x47, 0x35, 0xbf, 0x72, 0xd8, 0xb5, 0x89, 0x37, 0x18, 0x8e, 0x78, 0x62, 0xa7, 0x7b, 0xb0,
	0x33, 0xbb, 0x88, 0x3c, 0x97, 0xec, 0xe2, 0xed, 0x5e, 0x27, 0x4b, 0xf4, 0x90, 0x13, 0xf6, 0x28,
	0xa9, 0x05, 0x5e, 0x86, 0x28, 0xb3, 0x1c, 0xd6, 0x5e, 0x80, 0x43, 0x32, 0xee, 0x35, 0xa9, 0x2e,
	0x55, 0x49, 0x8d, 0xd4, 0x59, 0xb3, 0x41, 0x8c, 0x50, 0x4c, 0xfa, 0xb5, 0xf8, 0x1b, 0xf4, 0x61,
	0x13, 0x59, 0x70, 0x06, 0x4e, 0xf5, 0x0e, 0x60, 0xf6, 0x51, 0x74, 0x92, 0x0f, 0xf2, 0xa3, 0x6a,
	0x99, 0x58, 0x92, 0xa2, 0x9a, 0x38, 0x32, 0x9f, 0x9d, 0x9d, 0xa1, 0xe9, 0x2f, 0x24, 0xe1, 0x24,
	0x97, 0x73, 0x9a, 0x97, 0x9e, 0xb8, 0x50, 0xd1, 0xa5, 0x3e, 0xc7, 0xd4, 0xe5, 0xc7, 0x4d, 0xf4,
	0x43, 0xc8, 0xc1, 0x99, 0xde, 0xeb, 0xa6, 0x29, 0x4a, 0x72, 0x14, 0xda, 0x63, 0x25, 0x5c, 0xe8,
	0xe2, 0x93, 0x7b, 0xd3, 0xe2, 0x68, 0x87, 0x37, 0x1d, 0x9a, 0x20, 0x45, 0xf6, 0x9b, 0x68, 0x88,
	0x9e, 0x82, 0x0b, 0xd9, 0x57, 0xaf, 0x07, 0x23, 0x43, 0x89, 0x48, 0xe6, 0x37, 0x43, 0x90, 0xe8,
	0xf4, 0x72, 0x7c, 0x83, 0x87, 0x09, 0x4e, 0x98, 0x5f, 0xce, 0x2e, 0xf4, 0xf7, 0x7d, 0xcf, 0xcd,
	0xef, 0x1e, 0x75, 0x7a, 0x68, 0xf9, 0x24, 0xbe, 0xd7, 0xcb, 0x25, 0xfd, 0xcf, 0xe0, 0x92, 0xf9,
	0xb3, 0xfd, 0x19, 0xa0, 0x07, 0x61, 0x97, 0xc3, 0xfe, 0x1c, 0x0d, 0xf4, 0xd8, 0xc0, 0x33, 0x7a,
	0xec, 0x21, 0x7c, 0xf4, 0xf7, 0xe7, 0x9f, 0xf4, 0xf3, 0xe7, 0xe0, 0xf1, 0xfd, 0xf9, 0x10, 0x26,
	0x7a, 0x7a, 0x7b, 0x47, 0x42, 0x19, 0x7e, 0xbe, 0x09, 0xe5, 0x4e, 0x2f, 0xb7, 0x1f, 0x3a, 0xa6,
	0xdb, 0x0f, 0xde, 0x56, 0xcf, 0xa4, 0xf2, 0x3f, 0x11, 0xcb, 0x2a, 0x53, 0xfd, 0x3c, 0x36, 0xc4,
	0x7a, 0xa6, 0x03, 0xdc, 0xf5, 0x62, 0x1f, 0x77, 0x7d, 0xe5, 0x71, 0x13, 0xfd, 0x14, 0xc1, 0x39,
	0x18, 0x69, 0x85, 0x92, 0xf4, 0xea, 0x06, 0x6b, 0x26, 0x78, 0xbc, 0x03, 0x72, 0x10, 0x67, 0xa6,
	0x9a, 0xbe, 0x65, 0xd2, 0x44, 0xac, 0x46, 0x92, 0x67, 0x21, 0xd9, 0x65, 0xf2, 0xb9, 0x06, 0x9f,
	0x6d, 0xc1, 0x6f, 0x48, 0xa6, 0x79, 0x57, 0x33, 0xe4, 0xde, 0xf0, 0x3a, 0x9f, 0xcd, 0x4f, 0x0f,
	0xf0, 0x6a, 0x7a, 0x31, 0x0f, 0xef, 0x37, 0x51, 0x88, 0x7a, 0xf5, 0xa5, 0xec, 0x65, 0x9a, 0xdb,
	0x5e, 0x0f, 0x46, 0x42, 0x89, 0x70, 0xe6, 0xa7, 0x08, 0xc6, 0x7b, 0xb9, 0x11, 0xce, 0x42, 0xc4,
	0xe1, 0x85, 0x7b, 0x76, 0xc2, 0xf1, 0xdf, 0x21, 0x23, 0x94, 0x40, 0xc2, 0x03, 0xbf, 0xe8, 0x42,
	0xe0, 0x2b, 0x10, 0x71, 0x38, 0x39, 0x5a, 0x1d, 0xd2, 0x27, 0xba, 0x08, 0x99, 0xab, 0x10, 0x6f,
	0x0f, 0xc3, 0x78, 0xbe, 0xad, 0xc5, 0x7c, 0xee, 0x63, 0x9a, 0x92, 0x5f, 0x9c, 0x77, 0xe3, 0xc7,
	0xa4, 0xdf, 0x6e, 0x0f, 0x86, 0x27, 0x83, 0xc2, 0xd7, 0x5f, 0x07, 0xec, 0xa6, 0x73, 0xe6, 0x4b,
	0x04, 0x42, 0x3f, 0x6f, 0xc4, 0x6f, 0x01, 0xb4, 0x92, 0x57, 0xce, 0x62, 0xa6, 0x83, 0x45, 0xf6,
	0x3e, 0xa0, 0x23, 0xeb, 0xc5, 0xdd, 0x59, 0xef, 0x8a, 0x4f, 0x8c, 0xba, 0xcd, 0x05, 0xbc, 0x01,
	0x82, 0x79, 0x47, 0xd1, 0x1d, 0x5f, 0xdd, 0x21, 0x86, 0xbd, 0x36, 0x35, 0xfe, 0xc1, 0x95, 0x89,
	0x53, 0x14, 0xcf, 0xb6, 0xb2, 0xdb, 0x1e, 0x2c, 0x1a, 0x9f, 0x1d, 0x62, 0xf6, 0x83, 0x07, 0x9a,
	0x29, 0x7a, 0xe2, 0x73, 0xa0, 0xbb, 0x64, 0xf1, 0x77, 0x01, 0x38, 0xd1, 0xc3, 0xfd, 0xf1, 0x0c,
	0x00, 0x55, 0x4f, 0xc9, 0x20, 0x55, 0x72, 0x8f, 0x37, 0xa4, 0xc7, 0x1c, 0x31, 0x46, 0x8c, 0xb0,
	0xf0, 0xc0, 0xff, 0x08, 0x21, 0xbb, 0x08, 0x27, 0x52, 0x18, 0xfc, 0x1a, 0x8c, 0xc9, 0xc4, 0xac,
	0x18, 0x0a, 0x7b, 0x48, 0xc1, 0x11, 0x43, 0xfd, 0x10, 0x13, 0x1e, 0x58, 0x1b, 0x5f, 0x82, 0xa8,
	0xd3, 0xe9, 0xb7, 0xfb, 0xcb, 0xd1, 0x7c, 0x81, 0x39, 0xeb, 0xc8, 0xba, 0x66, 0xa5, 0xcd, 0x86,
	0x4e, 0x55, 0x45, 0xe4, 0x8f, 0x9b, 0x28, 0xb4, 0xb2, 0xb9, 0xb9, 0x51, 0xf4, 0xe6, 0x84, 0x76,
	0xfe, 0x3c, 0x6e, 0x60, 0xd1, 0x9e, 0x13, 0x83, 0xf4, 0x8f, 0x18, 0xd8, 0x2c, 0x6c, 0x88, 0x2d,
	0xaa, 0xf4, 0x56, 0xce, 0x5a, 0xd0, 0x86, 0x54, 0xaf, 0x12, 0x93, 0x05, 0x8f, 0x68, 0xfe, 0x82,
	0x5b, 0x0f, 0x0c, 0xf2, 0x7e, 0xd0, 0x7e, 0xd0, 0xed, 0x07, 0x7d, 0xe4, 0x77, 0x32, 0xf3, 0x27,
	0x41, 0x24, 0x02, 0xc5, 0x16, 0x19, 0x32, 0x5e, 0x85, 0xf3, 0x4e, 0x98, 0x29, 0xf1, 0xd2, 0x92,
	0x5c, 0x6a, 0x0f, 0xbf, 0x26, 0x4b, 0x78, 0x22, 0x62, 0xca, 0x01, 0x5c, 0xe6, 0x70, 0x6d, 0x02,
	0x37, 0x17, 0x87, 0x7f, 0xfb, 0x5a, 0x74, 0x81, 0x9e, 0xf9, 0xd9, 0x4b, 0xd9, 0xcb, 0xb6, 0x5e,
	0xae, 0x07, 0x23, 0xfe, 0x44, 0x80, 0xdf, 0x19, 0xdf, 0x41, 0x90, 0xe8, 0x0c, 0x64, 0xb8, 0x0e,
	0x21, 0xc5, 0x22, 0x35, 0xe7, 0xaa, 0x38, 0x75, 0xe4, 0x10, 0xb8, 0x6a, 0x91, 0x1a, 0xdf, 0x74,
	0xdf, 0x3b, 0xa3, 0x37, 0xff, 0xb5, 0x97, 0xc9, 0xfc, 0x35, 0x82, 0xf1, 0x5e, 0xa4, 0xf0, 0xeb,
	0x30, 0xaa, 0x4b, 0x86, 0xa5, 0x78, 0xb4, 0xce, 0xfb, 0x9a, 0x1f, 0x37, 0x91, 0x3f, 0x37, 0xd9,
	0xad, 0xfb, 0xb8, 0x0b, 0x6f, 0x6b, 0xfe, 0xff, 0x77, 0xbf, 0xad, 0x38, 0xff, 0xeb, 0x3d, 0x14,
	0x8f, 0xa0, 0x09, 0x34, 0x83, 0x16, 0xc3, 0xf6, 0xb9, 0xc0, 0x7a, 0xda, 0xef, 0xef, 0xa1, 0xb0,
	0x7d, 0x5a, 0x78, 0xeb, 0xbf, 0x7f, 0x8a, 0xe0, 0x44, 0x8f, 0xf2, 0x11, 0xfe, 0x71, 0xbb, 0x8c,
	0x66, 0x8e, 0x53, 0x7b, 0x7a, 0x46, 0x31, 0xfd, 0x0d, 0x62, 0x05, 0xe0, 0x7e, 0x92, 0x6a, 0x05,
	0xda, 0xa3, 0x49, 0xca, 0x85, 0x7f, 0x4e, 0x92, 0xfa, 0x05, 0x82, 0x53, 0xbd, 0x8b, 0x2c, 0xd8,
	0x6a, 0x17, 0xd6, 0xfc, 0x31, 0x8b, 0x34, 0xcf, 0x28, 0xaf, 0xbf, 0x75, 0xcb, 0xbb, 0xbf, 0xab,
	0x22, 0x7b, 0x02, 0x10, 0xbf, 0xa6, 0x6a, 0x65, 0x49, 0x2d, 0xea, 0xa4, 0xc2, 0x4a, 0x08, 0x4b,
	0x10, 0xba, 0xbb, 0x4d, 0x0c, 0xc2, 0xef, 0xc7, 0x9d, 0x6f, 0x28, 0xd6, 0xed, 0xc6, 0x5e, 0x51,
	0xb1, 0x88, 0x48, 0xb6, 0x8a, 0x44, 0x25, 0x15, 0x4b, 0x33, 0xf2, 0xc1, 0x77, 0xff, 0x05, 0x21,
	0xd1, 0xc6, 0xc4, 0x3a, 0x8c, 0xb8, 0x12, 0x2d, 0xdd, 0x59, 0x30, 0xf9, 0xdd, 0xe8, 0xc2, 0xc0,
	0xba, 0x7a, 0x5b, 0x83, 0x27, 0xb5, 0x3f, 0x30, 0x7f, 0x5a, 0xf1, 0x89, 0xc3, 0x2e, 0xf6, 0x8d,
	0x05, 0x13, 0xef, 0x42, 0xa2, 0xb5, 0x62, 0x85, 0x89, 0x9c, 0xdf, 0x9a, 0xb2, 0x87, 0xa8, 0xfa,
	0xb8, 0xeb, 0x8e, 0xba, 0x04, 0x6c, 0x7c, 0x6c, 0x42, 0xdc, 0xb3, 0x74, 0x59, 0xd1, 0x85, 0xf8,
	0x21, 0x5d, 0x84, 0xae, 0x12, 0x59, 0x3e, 0xf5, 0xf9, 0xfd, 0x33, 0xed, 0x15, 0xb5, 0xac, 0x69,
	0x49, 0x55, 0xa5, 0x5e, 0xcd, 0xea, 0x86, 0x26, 0xb3, 0x2e, 0x83, 0xbb, 0x6c, 0x59, 0xd1, 0xf1,
	0xcf, 0x10, 0x9c, 0x6c, 0xad, 0x6a, 0x6d, 0x2b, 0x86, 0x5c, 0xa2, 0x81, 0x67, 0x57, 0x18, 0x3d,
	0xa4, 0x70, 0xde, 0xa7, 0x72, 0x74, 0x04, 0x16, 0x4e, 0xb8, 0x44, 0x5a, 0x34, 0xf0, 0xab, 0x6d,
	0x8d, 0xbc, 0x81, 0xcf, 0xfc, 0x5a, 0xa5, 0x1a, 0xbb, 0x71, 0xf7, 0x16, 0xc4, 0x5a, 0x7d, 0x43,
	0xa7, 0xd4, 0x33, 0x35, 0x20, 0x8f, 0xef, 0xae, 0xf9, 0xb6, 0x48, 0x82, 0xdb, 0x62, 0xd4, 0x71,
	0x01, 0x02, 0xd4, 0xe8, 0x82, 0xc7, 0x69, 0x46, 0xb4, 0x3a, 0xee, 0x48, 0xa4, 0xd8, 0xf8, 0x26,
	0x84, 0xb9, 0x1d, 0x85, 0x8e, 0x59, 0xdf, 0xf6, 0x92, 0xe2, 0x34, 0xf0, 0x1b, 0x80, 0xdd, 0x37,
	0x34, 0x2c, 0x97, 0xdc, 0x52, 0x88, 0xc1, 0x5f, 0x18, 0x9d, 0xe6, 0xe0, 0xed, 0xed, 0x3b, 0x01,
	0x89, 0x63, 0xce, 0x5b, 0x23, 0x17, 0x03, 0x2f, 0xc2, 0x48, 0x5d, 0x2b, 0xb5, 0x48, 0x09, 0xc3,
	0x03, 0x72, 0x29, 0xbf, 0x18, 0xab, 0x6b, 0x05, 0x87, 0x06, 0x9e, 0xf6, 0xbc, 0xee, 0x91, 0x85,
	0x91, 0x5e, 0x3d, 0xc3, 0x15, 0x7f, 0xeb, 0x25, 0x9e, 0x8c, 0x25, 0x18, 0x61, 0xaf, 0x47, 0x9d,
	0x22, 0xa9, 0xf0, 0xd9, 0xd0, 0x91, 0x13, 0xc4, 0xd3, 0x1f, 0xdc, 0x6f, 0x47, 0x76, 0x14, 0x35,
	0x4c, 0x47, 0x57, 0xf9, 0xe0, 0xe2, 0x8d, 0x0f, 0x9b, 0xe8, 0x1a, 0x00, 0x84, 0xde, 0x62, 0x81,
	0x03, 0xcd, 0xc2, 0x49, 0x48, 0xb8, 0x6a, 0x4e, 0xaf, 0x11, 0x6b, 0x5b, 0x93, 0x31, 0xba, 0x0c,
	0x19, 0x38, 0xdb, 0x1a, 0x76, 0xee, 0xfc, 0x1e, 0xc1, 0xf8, 0x67, 0x67, 0xf3, 0xdf, 0x6d, 0x0b,
	0x02, 0x76, 0x66, 0x88, 0x3d, 0x37, 0xf7, 0xf0, 0x42, 0xf6, 0xd5, 0xec, 0xec, 0xc5, 0x7c, 0xa6,
	0xad, 0x7f, 0x61, 0xbf, 0x4d, 0xd8, 0x6f, 0xa2, 0xb0, 0xa7, 0xc4, 0x9d, 0xcf, 0xc1, 0x0b, 0xdd,
	0x0a, 0x73, 0x88, 0x8e, 0x3d, 0x6a, 0xa2, 0x61, 0xfe, 0x92, 0x21, 0x34, 0x3b, 0x97, 0x9d, 0x9d,
	0xb7, 0x0b, 0x02, 0xd7, 0x83, 0x91, 0x70, 0x62, 0x88, 0xbf, 0x68, 0xf8, 0x79, 0x08, 0xe2, 0x05,
	0x83, 0x48, 0x16, 0x71, 0x43, 0xeb, 0x95, 0x67, 0x09, 0xad, 0x4e, 0x50, 0xdd, 0xf8, 0xa6, 0x41,
	0xb5, 0x2b, 0x68, 0xfe, 0xfe, 0xf3, 0x09, 0x9a, 0xbd, 0x82, 0x62, 0xf1, 0x9b, 0x07, 0xc5, 0xee,
	0xa0, 0xb7, 0xf5, 0x9c, 0x63, 0x5e, 0xbf, 0x98, 0x76, 0x2c, 0x27, 0x43, 0xed, 0x4e, 0x76, 0xae,
	0xdb, 0xc9, 0x56, 0x3c, 0xcf, 0x5b, 0xe5, 0xc5, 0xb1, 0xc7, 0xaf, 0x75, 0x9c, 0xb8, 0xf9, 0x89,
	0x1e, 0x76, 0x3b, 0xfe, 0xce, 0x57, 0xa8, 0x6b, 0x34, 0xbf, 0x38, 0xc8, 0x2a, 0xff, 0xdf, 0x3b,
	0x5f, 0xa1, 0xfe, 0xd3, 0x99, 0x5f, 0x84, 0x60, 0x54, 0x24, 0xba, 0x2a, 0x55, 0xbe, 0x35, 0xc8,
	0x6f, 0x0d, 0xf2, 0x77, 0xc0, 0x20, 0xff, 0x22, 0x0c, 0xb1, 0x6b, 0xc4, 0x7a, 0x3e, 0xc6, 0x38,
	0x73, 0xf4, 0x3c, 0x84, 0xa7, 0x1f, 0xeb, 0xdf, 0x3c, 0xfd, 0x68, 0xcb, 0x3a, 0xbe, 0x75, 0x87,
	0x6f, 0xdd, 0xe1, 0x1b, 0xb8, 0xc3, 0xe4, 0x79, 0x80, 0xd6, 0x3b, 0x3f, 0x1c, 0x01, 0x56, 0xe5,
	0x49, 0xf8, 0x70, 0x14, 0xec, 0xb2, 0x4f, 0x02, 0x4d, 0x2e, 0xc1, 0xa9, 0xde, 0x0f, 0xe2, 0x30,
	0x86, 0xf8, 0xf2, 0x7a, 0xb1, 0xb4, 0x7c, 0xf5, 0xe6, 0xd5, 0x6b, 0x4b, 0x9b, 0xab, 0x6f, 0xae,
	0x27, 0x7c, 0xf8, 0x04, 0x8c, 0x6e, 0xdc, 0xca, 0xdf, 0x5c, 0x2d, 0xae, 0x94, 0x8a, 0x57, 0xc5,
	0xdb, 0xab, 0x85, 0xab, 0x09, 0x34, 0x39, 0x01, 0xd0, 0x7a, 0xe0, 0x85, 0x87, 0x21, 0x52, 0x78,
	0x53, 0xbc, 0x5a, 0x5a, 0x5e, 0x2f, 0x26, 0x7c, 0xf4, 0xd7, 0x8d, 0x5b, 0x79, 0xfb, 0x17, 0xca,
	0xff, 0x39, 0xda, 0xff, 0x34, 0xe5, 0x7b, 0xf2, 0x69, 0xca, 0xf7, 0xc5, 0xa7, 0x29, 0xf4, 0xe0,
	0x20, 0x85, 0x7e, 0x79, 0x90, 0x42, 0x1f, 0x1d, 0xa4, 0xd0, 0xfe, 0x41, 0x0a, 0x3d, 0x39, 0x48,
	0xa1, 0x4f, 0x0e, 0x52, 0xe8, 0xb3, 0x83, 0x94, 0xef, 0x8b, 0x83, 0x14, 0x7a, 0xf7, 0x69, 0xca,
	0xf7, 0xe8, 0x69, 0x0a, 0xed, 0x3f, 0x4d, 0xf9, 0x9e, 0x3c, 0x4d, 0xf9, 0x7e, 0xb0, 0x56, 0xd5,
	0xf4, 0x3b, 0xd5, 0xdc, 0x8e, 0xa6, 0x5a, 0xc4, 0x30, 0xa4, 0x5c, 0xc3, 0x9c, 0x66, 0x1f, 0x5b,
	0x9a, 0x51, 0x9b, 0xd2, 0x0d, 0x6d, 0x47, 0x91, 0x89, 0x31, 0xe5, 0x4c, 0x4f, 0xeb, 0xe5, 0xaa,
	0x36, 0x4d, 0xee, 0x59, 0xfc, 0x7f, 0x92, 0x3a, 0xff, 0x41, 0xab, 0x1c, 0x66, 0x85, 0xae, 0xf9,
	0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x48, 0x5c, 0x12, 0x6c, 0xc2, 0x35, 0x00, 0x00,
}

func (x SchemeType) String() string {
	s, ok := SchemeType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x VirtualIPDiscoveryType) String() string {
	s, ok := VirtualIPDiscoveryType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x K8SDNSMode) String() string {
	s, ok := K8SDNSMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *VerStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VerStatusType)
	if !ok {
		that2, ok := that.(VerStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Connected != that1.Connected {
		return false
	}
	if this.Site != that1.Site {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.Services) != len(that1.Services) {
		return false
	}
	for i := range this.Services {
		if !this.Services[i].Equal(that1.Services[i]) {
			return false
		}
	}
	return true
}
func (this *PodInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodInfoType)
	if !ok {
		that2, ok := that.(PodInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PodName != that1.PodName {
		return false
	}
	if this.Ip != that1.Ip {
		return false
	}
	return true
}
func (this *PortInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortInfoType)
	if !ok {
		that2, ok := that.(PortInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if this.TargetPort != that1.TargetPort {
		return false
	}
	return true
}
func (this *DiscoveredServiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DiscoveredServiceType)
	if !ok {
		that2, ok := that.(DiscoveredServiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServiceName != that1.ServiceName {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.ServiceType != that1.ServiceType {
		return false
	}
	if this.ClusterIp != that1.ClusterIp {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Pods) != len(that1.Pods) {
		return false
	}
	for i := range this.Pods {
		if !this.Pods[i].Equal(that1.Pods[i]) {
			return false
		}
	}
	if len(this.PortMap) != len(that1.PortMap) {
		return false
	}
	for i := range this.PortMap {
		if this.PortMap[i] != that1.PortMap[i] {
			return false
		}
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if !this.Ports[i].Equal(that1.Ports[i]) {
			return false
		}
	}
	if this.ClusterIpv6 != that1.ClusterIpv6 {
		return false
	}
	return true
}
func (this *TLSClientConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TLSClientConfigType)
	if !ok {
		that2, ok := that.(TLSClientConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	if !this.CertificateUrl.Equal(that1.CertificateUrl) {
		return false
	}
	if this.Certificate != that1.Certificate {
		return false
	}
	if !this.KeyUrl.Equal(that1.KeyUrl) {
		return false
	}
	if !this.CaCertificateUrl.Equal(that1.CaCertificateUrl) {
		return false
	}
	if this.TrustedCaUrl != that1.TrustedCaUrl {
		return false
	}
	return true
}
func (this *RestConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RestConfigType)
	if !ok {
		that2, ok := that.(RestConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ApiServer != that1.ApiServer {
		return false
	}
	if !this.TlsInfo.Equal(that1.TlsInfo) {
		return false
	}
	return true
}
func (this *K8SAccessInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SAccessInfo)
	if !ok {
		that2, ok := that.(K8SAccessInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ConfigType == nil {
		if this.ConfigType != nil {
			return false
		}
	} else if this.ConfigType == nil {
		return false
	} else if !this.ConfigType.Equal(that1.ConfigType) {
		return false
	}
	if that1.K8SPodNetworkChoice == nil {
		if this.K8SPodNetworkChoice != nil {
			return false
		}
	} else if this.K8SPodNetworkChoice == nil {
		return false
	} else if !this.K8SPodNetworkChoice.Equal(that1.K8SPodNetworkChoice) {
		return false
	}
	return true
}
func (this *K8SAccessInfo_KubeconfigUrl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SAccessInfo_KubeconfigUrl)
	if !ok {
		that2, ok := that.(K8SAccessInfo_KubeconfigUrl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.KubeconfigUrl.Equal(that1.KubeconfigUrl) {
		return false
	}
	return true
}
func (this *K8SAccessInfo_ConnectionInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SAccessInfo_ConnectionInfo)
	if !ok {
		that2, ok := that.(K8SAccessInfo_ConnectionInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ConnectionInfo.Equal(that1.ConnectionInfo) {
		return false
	}
	return true
}
func (this *K8SAccessInfo_InCluster) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SAccessInfo_InCluster)
	if !ok {
		that2, ok := that.(K8SAccessInfo_InCluster)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.InCluster != that1.InCluster {
		return false
	}
	return true
}
func (this *K8SAccessInfo_Isolated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SAccessInfo_Isolated)
	if !ok {
		that2, ok := that.(K8SAccessInfo_Isolated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Isolated.Equal(that1.Isolated) {
		return false
	}
	return true
}
func (this *K8SAccessInfo_Reachable) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SAccessInfo_Reachable)
	if !ok {
		that2, ok := that.(K8SAccessInfo_Reachable)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Reachable.Equal(that1.Reachable) {
		return false
	}
	return true
}
func (this *ConsulHttpBasicAuthInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsulHttpBasicAuthInfoType)
	if !ok {
		that2, ok := that.(ConsulHttpBasicAuthInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UserName != that1.UserName {
		return false
	}
	if !this.PasswdUrl.Equal(that1.PasswdUrl) {
		return false
	}
	return true
}
func (this *ConsulAccessInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsulAccessInfo)
	if !ok {
		that2, ok := that.(ConsulAccessInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ConnectionInfo.Equal(that1.ConnectionInfo) {
		return false
	}
	if this.Scheme != that1.Scheme {
		return false
	}
	if !this.HttpBasicAuthInfo.Equal(that1.HttpBasicAuthInfo) {
		return false
	}
	return true
}
func (this *VipDiscoveryInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VipDiscoveryInfoType)
	if !ok {
		that2, ok := that.(VipDiscoveryInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PublishVirtualIp != that1.PublishVirtualIp {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Subdomain != that1.Subdomain {
		return false
	}
	if this.DnsMode != that1.DnsMode {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	return true
}
func (this *K8SPublishType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SPublishType)
	if !ok {
		that2, ok := that.(K8SPublishType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	return true
}
func (this *K8SDelegationType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SDelegationType)
	if !ok {
		that2, ok := that.(K8SDelegationType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Subdomain != that1.Subdomain {
		return false
	}
	if this.DnsMode != that1.DnsMode {
		return false
	}
	return true
}
func (this *K8SVipDiscoveryInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SVipDiscoveryInfoType)
	if !ok {
		that2, ok := that.(K8SVipDiscoveryInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PublishChoice == nil {
		if this.PublishChoice != nil {
			return false
		}
	} else if this.PublishChoice == nil {
		return false
	} else if !this.PublishChoice.Equal(that1.PublishChoice) {
		return false
	}
	return true
}
func (this *K8SVipDiscoveryInfoType_Disable) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SVipDiscoveryInfoType_Disable)
	if !ok {
		that2, ok := that.(K8SVipDiscoveryInfoType_Disable)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Disable.Equal(that1.Disable) {
		return false
	}
	return true
}
func (this *K8SVipDiscoveryInfoType_Publish) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SVipDiscoveryInfoType_Publish)
	if !ok {
		that2, ok := that.(K8SVipDiscoveryInfoType_Publish)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Publish.Equal(that1.Publish) {
		return false
	}
	return true
}
func (this *K8SVipDiscoveryInfoType_PublishFqdns) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SVipDiscoveryInfoType_PublishFqdns)
	if !ok {
		that2, ok := that.(K8SVipDiscoveryInfoType_PublishFqdns)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PublishFqdns.Equal(that1.PublishFqdns) {
		return false
	}
	return true
}
func (this *K8SVipDiscoveryInfoType_DnsDelegation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SVipDiscoveryInfoType_DnsDelegation)
	if !ok {
		that2, ok := that.(K8SVipDiscoveryInfoType_DnsDelegation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DnsDelegation.Equal(that1.DnsDelegation) {
		return false
	}
	return true
}
func (this *ConsulVipDiscoveryInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsulVipDiscoveryInfoType)
	if !ok {
		that2, ok := that.(ConsulVipDiscoveryInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PublishChoice == nil {
		if this.PublishChoice != nil {
			return false
		}
	} else if this.PublishChoice == nil {
		return false
	} else if !this.PublishChoice.Equal(that1.PublishChoice) {
		return false
	}
	return true
}
func (this *ConsulVipDiscoveryInfoType_Disable) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsulVipDiscoveryInfoType_Disable)
	if !ok {
		that2, ok := that.(ConsulVipDiscoveryInfoType_Disable)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Disable.Equal(that1.Disable) {
		return false
	}
	return true
}
func (this *ConsulVipDiscoveryInfoType_Publish) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsulVipDiscoveryInfoType_Publish)
	if !ok {
		that2, ok := that.(ConsulVipDiscoveryInfoType_Publish)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Publish.Equal(that1.Publish) {
		return false
	}
	return true
}
func (this *K8SDiscoveryType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SDiscoveryType)
	if !ok {
		that2, ok := that.(K8SDiscoveryType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AccessInfo.Equal(that1.AccessInfo) {
		return false
	}
	if !this.PublishInfo.Equal(that1.PublishInfo) {
		return false
	}
	if that1.NamespaceMappingChoice == nil {
		if this.NamespaceMappingChoice != nil {
			return false
		}
	} else if this.NamespaceMappingChoice == nil {
		return false
	} else if !this.NamespaceMappingChoice.Equal(that1.NamespaceMappingChoice) {
		return false
	}
	return true
}
func (this *K8SDiscoveryType_DefaultAll) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SDiscoveryType_DefaultAll)
	if !ok {
		that2, ok := that.(K8SDiscoveryType_DefaultAll)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultAll.Equal(that1.DefaultAll) {
		return false
	}
	return true
}
func (this *K8SDiscoveryType_NamespaceMapping) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SDiscoveryType_NamespaceMapping)
	if !ok {
		that2, ok := that.(K8SDiscoveryType_NamespaceMapping)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NamespaceMapping.Equal(that1.NamespaceMapping) {
		return false
	}
	return true
}
func (this *ConsulDiscoveryType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsulDiscoveryType)
	if !ok {
		that2, ok := that.(ConsulDiscoveryType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AccessInfo.Equal(that1.AccessInfo) {
		return false
	}
	if !this.PublishInfo.Equal(that1.PublishInfo) {
		return false
	}
	if that1.NamespaceMappingChoice == nil {
		if this.NamespaceMappingChoice != nil {
			return false
		}
	} else if this.NamespaceMappingChoice == nil {
		return false
	} else if !this.NamespaceMappingChoice.Equal(that1.NamespaceMappingChoice) {
		return false
	}
	return true
}
func (this *ConsulDiscoveryType_DefaultAll) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsulDiscoveryType_DefaultAll)
	if !ok {
		that2, ok := that.(ConsulDiscoveryType_DefaultAll)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultAll.Equal(that1.DefaultAll) {
		return false
	}
	return true
}
func (this *ConsulDiscoveryType_NamespaceMapping) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsulDiscoveryType_NamespaceMapping)
	if !ok {
		that2, ok := that.(ConsulDiscoveryType_NamespaceMapping)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NamespaceMapping.Equal(that1.NamespaceMapping) {
		return false
	}
	return true
}
func (this *CbipDiscoveryType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CbipDiscoveryType)
	if !ok {
		that2, ok := that.(CbipDiscoveryType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.CbipClusters) != len(that1.CbipClusters) {
		return false
	}
	for i := range this.CbipClusters {
		if !this.CbipClusters[i].Equal(that1.CbipClusters[i]) {
			return false
		}
	}
	if this.InternalLbDomain != that1.InternalLbDomain {
		return false
	}
	if len(this.ServerCa) != len(that1.ServerCa) {
		return false
	}
	for i := range this.ServerCa {
		if !this.ServerCa[i].Equal(that1.ServerCa[i]) {
			return false
		}
	}
	return true
}
func (this *ThirdPartyDiscoveryType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ThirdPartyDiscoveryType)
	if !ok {
		that2, ok := that.(ThirdPartyDiscoveryType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Applications) != len(that1.Applications) {
		return false
	}
	for i := range this.Applications {
		if this.Applications[i] != that1.Applications[i] {
			return false
		}
	}
	if len(this.SourceCidr) != len(that1.SourceCidr) {
		return false
	}
	for i := range this.SourceCidr {
		if this.SourceCidr[i] != that1.SourceCidr[i] {
			return false
		}
	}
	if !this.ExpirationTimestamp.Equal(that1.ExpirationTimestamp) {
		return false
	}
	return true
}
func (this *CbipCluster) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CbipCluster)
	if !ok {
		that2, ok := that.(CbipCluster)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if len(this.CbipDevices) != len(that1.CbipDevices) {
		return false
	}
	for i := range this.CbipDevices {
		if !this.CbipDevices[i].Equal(that1.CbipDevices[i]) {
			return false
		}
	}
	if len(this.CbipMgmtIps) != len(that1.CbipMgmtIps) {
		return false
	}
	for i := range this.CbipMgmtIps {
		if this.CbipMgmtIps[i] != that1.CbipMgmtIps[i] {
			return false
		}
	}
	if !this.AdminCredentials.Equal(that1.AdminCredentials) {
		return false
	}
	if !this.CbipCertificateAuthority.Equal(that1.CbipCertificateAuthority) {
		return false
	}
	if !this.VirtualServerFilter.Equal(that1.VirtualServerFilter) {
		return false
	}
	if that1.NamespaceMappingChoice == nil {
		if this.NamespaceMappingChoice != nil {
			return false
		}
	} else if this.NamespaceMappingChoice == nil {
		return false
	} else if !this.NamespaceMappingChoice.Equal(that1.NamespaceMappingChoice) {
		return false
	}
	if !this.MgmtPort.Equal(that1.MgmtPort) {
		return false
	}
	return true
}
func (this *CbipCluster_DefaultAll) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CbipCluster_DefaultAll)
	if !ok {
		that2, ok := that.(CbipCluster_DefaultAll)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultAll.Equal(that1.DefaultAll) {
		return false
	}
	return true
}
func (this *CbipCluster_NamespaceMapping) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CbipCluster_NamespaceMapping)
	if !ok {
		that2, ok := that.(CbipCluster_NamespaceMapping)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NamespaceMapping.Equal(that1.NamespaceMapping) {
		return false
	}
	return true
}
func (this *CbipDeviceConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CbipDeviceConfig)
	if !ok {
		that2, ok := that.(CbipDeviceConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CbipMgmtIp != that1.CbipMgmtIp {
		return false
	}
	if !this.AdminCredentials.Equal(that1.AdminCredentials) {
		return false
	}
	if !this.CbipCertificateAuthority.Equal(that1.CbipCertificateAuthority) {
		return false
	}
	if !this.VirtualServerFilter.Equal(that1.VirtualServerFilter) {
		return false
	}
	if that1.NamespaceMappingChoice == nil {
		if this.NamespaceMappingChoice != nil {
			return false
		}
	} else if this.NamespaceMappingChoice == nil {
		return false
	} else if !this.NamespaceMappingChoice.Equal(that1.NamespaceMappingChoice) {
		return false
	}
	return true
}
func (this *CbipDeviceConfig_DefaultAll) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CbipDeviceConfig_DefaultAll)
	if !ok {
		that2, ok := that.(CbipDeviceConfig_DefaultAll)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultAll.Equal(that1.DefaultAll) {
		return false
	}
	return true
}
func (this *CbipDeviceConfig_NamespaceMapping) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CbipDeviceConfig_NamespaceMapping)
	if !ok {
		that2, ok := that.(CbipDeviceConfig_NamespaceMapping)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NamespaceMapping.Equal(that1.NamespaceMapping) {
		return false
	}
	return true
}
func (this *CbipAdminCredentials) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CbipAdminCredentials)
	if !ok {
		that2, ok := that.(CbipAdminCredentials)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Username != that1.Username {
		return false
	}
	if !this.Password.Equal(that1.Password) {
		return false
	}
	return true
}
func (this *ManagementPort) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ManagementPort)
	if !ok {
		that2, ok := that.(ManagementPort)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	return true
}
func (this *CbipCertificateAuthority) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CbipCertificateAuthority)
	if !ok {
		that2, ok := that.(CbipCertificateAuthority)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ServerValidationChoice == nil {
		if this.ServerValidationChoice != nil {
			return false
		}
	} else if this.ServerValidationChoice == nil {
		return false
	} else if !this.ServerValidationChoice.Equal(that1.ServerValidationChoice) {
		return false
	}
	return true
}
func (this *CbipCertificateAuthority_TrustedCa) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CbipCertificateAuthority_TrustedCa)
	if !ok {
		that2, ok := that.(CbipCertificateAuthority_TrustedCa)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TrustedCa.Equal(that1.TrustedCa) {
		return false
	}
	return true
}
func (this *CbipCertificateAuthority_SkipServerVerification) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CbipCertificateAuthority_SkipServerVerification)
	if !ok {
		that2, ok := that.(CbipCertificateAuthority_SkipServerVerification)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SkipServerVerification.Equal(that1.SkipServerVerification) {
		return false
	}
	return true
}
func (this *VirtualServerFilter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualServerFilter)
	if !ok {
		that2, ok := that.(VirtualServerFilter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NameRegex != that1.NameRegex {
		return false
	}
	if this.DescriptionRegex != that1.DescriptionRegex {
		return false
	}
	if len(this.Protocols) != len(that1.Protocols) {
		return false
	}
	for i := range this.Protocols {
		if this.Protocols[i] != that1.Protocols[i] {
			return false
		}
	}
	if this.PortRanges != that1.PortRanges {
		return false
	}
	if this.DiscoverDisabledVirtualServers != that1.DiscoverDisabledVirtualServers {
		return false
	}
	return true
}
func (this *NamespaceMapping) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamespaceMapping)
	if !ok {
		that2, ok := that.(NamespaceMapping)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *NamespaceMappingItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamespaceMappingItem)
	if !ok {
		that2, ok := that.(NamespaceMappingItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PartitionRegex != that1.PartitionRegex {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	return true
}
func (this *K8SNamespaceMapping) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SNamespaceMapping)
	if !ok {
		that2, ok := that.(K8SNamespaceMapping)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *K8SNamespaceMappingItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SNamespaceMappingItem)
	if !ok {
		that2, ok := that.(K8SNamespaceMappingItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NamespaceRegex != that1.NamespaceRegex {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	return true
}
func (this *ConsulNamespaceMapping) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsulNamespaceMapping)
	if !ok {
		that2, ok := that.(ConsulNamespaceMapping)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *ConsulNamespaceMappingItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsulNamespaceMappingItem)
	if !ok {
		that2, ok := that.(ConsulNamespaceMappingItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NamespaceRegex != that1.NamespaceRegex {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Where.Equal(that1.Where) {
		return false
	}
	if that1.DiscoveryChoice == nil {
		if this.DiscoveryChoice != nil {
			return false
		}
	} else if this.DiscoveryChoice == nil {
		return false
	} else if !this.DiscoveryChoice.Equal(that1.DiscoveryChoice) {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.PublishVip.Equal(that1.PublishVip) {
		return false
	}
	if that1.AccessInfo == nil {
		if this.AccessInfo != nil {
			return false
		}
	} else if this.AccessInfo == nil {
		return false
	} else if !this.AccessInfo.Equal(that1.AccessInfo) {
		return false
	}
	if this.ClusterIdentifier != that1.ClusterIdentifier {
		return false
	}
	if that1.ClusterIdentifierChoice == nil {
		if this.ClusterIdentifierChoice != nil {
			return false
		}
	} else if this.ClusterIdentifierChoice == nil {
		return false
	} else if !this.ClusterIdentifierChoice.Equal(that1.ClusterIdentifierChoice) {
		return false
	}
	if !this.ViewInternal.Equal(that1.ViewInternal) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DiscoveryK8S) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DiscoveryK8S)
	if !ok {
		that2, ok := that.(GlobalSpecType_DiscoveryK8S)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryK8S.Equal(that1.DiscoveryK8S) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DiscoveryConsul) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DiscoveryConsul)
	if !ok {
		that2, ok := that.(GlobalSpecType_DiscoveryConsul)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryConsul.Equal(that1.DiscoveryConsul) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DiscoveryCbip) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DiscoveryCbip)
	if !ok {
		that2, ok := that.(GlobalSpecType_DiscoveryCbip)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryCbip.Equal(that1.DiscoveryCbip) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DiscoveryThirdParty) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DiscoveryThirdParty)
	if !ok {
		that2, ok := that.(GlobalSpecType_DiscoveryThirdParty)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryThirdParty.Equal(that1.DiscoveryThirdParty) {
		return false
	}
	return true
}
func (this *GlobalSpecType_K8S) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_K8S)
	if !ok {
		that2, ok := that.(GlobalSpecType_K8S)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.K8S.Equal(that1.K8S) {
		return false
	}
	return true
}
func (this *GlobalSpecType_Consul) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Consul)
	if !ok {
		that2, ok := that.(GlobalSpecType_Consul)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Consul.Equal(that1.Consul) {
		return false
	}
	return true
}
func (this *GlobalSpecType_NoClusterId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_NoClusterId)
	if !ok {
		that2, ok := that.(GlobalSpecType_NoClusterId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoClusterId.Equal(that1.NoClusterId) {
		return false
	}
	return true
}
func (this *GlobalSpecType_ClusterId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ClusterId)
	if !ok {
		that2, ok := that.(GlobalSpecType_ClusterId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClusterId != that1.ClusterId {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Where.Equal(that1.Where) {
		return false
	}
	if that1.DiscoveryChoice == nil {
		if this.DiscoveryChoice != nil {
			return false
		}
	} else if this.DiscoveryChoice == nil {
		return false
	} else if !this.DiscoveryChoice.Equal(that1.DiscoveryChoice) {
		return false
	}
	if that1.ClusterIdentifierChoice == nil {
		if this.ClusterIdentifierChoice != nil {
			return false
		}
	} else if this.ClusterIdentifierChoice == nil {
		return false
	} else if !this.ClusterIdentifierChoice.Equal(that1.ClusterIdentifierChoice) {
		return false
	}
	return true
}
func (this *CreateSpecType_DiscoveryK8S) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DiscoveryK8S)
	if !ok {
		that2, ok := that.(CreateSpecType_DiscoveryK8S)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryK8S.Equal(that1.DiscoveryK8S) {
		return false
	}
	return true
}
func (this *CreateSpecType_DiscoveryConsul) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DiscoveryConsul)
	if !ok {
		that2, ok := that.(CreateSpecType_DiscoveryConsul)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryConsul.Equal(that1.DiscoveryConsul) {
		return false
	}
	return true
}
func (this *CreateSpecType_DiscoveryCbip) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DiscoveryCbip)
	if !ok {
		that2, ok := that.(CreateSpecType_DiscoveryCbip)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryCbip.Equal(that1.DiscoveryCbip) {
		return false
	}
	return true
}
func (this *CreateSpecType_DiscoveryThirdParty) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DiscoveryThirdParty)
	if !ok {
		that2, ok := that.(CreateSpecType_DiscoveryThirdParty)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryThirdParty.Equal(that1.DiscoveryThirdParty) {
		return false
	}
	return true
}
func (this *CreateSpecType_NoClusterId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_NoClusterId)
	if !ok {
		that2, ok := that.(CreateSpecType_NoClusterId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoClusterId.Equal(that1.NoClusterId) {
		return false
	}
	return true
}
func (this *CreateSpecType_ClusterId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ClusterId)
	if !ok {
		that2, ok := that.(CreateSpecType_ClusterId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClusterId != that1.ClusterId {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Where.Equal(that1.Where) {
		return false
	}
	if that1.DiscoveryChoice == nil {
		if this.DiscoveryChoice != nil {
			return false
		}
	} else if this.DiscoveryChoice == nil {
		return false
	} else if !this.DiscoveryChoice.Equal(that1.DiscoveryChoice) {
		return false
	}
	if that1.ClusterIdentifierChoice == nil {
		if this.ClusterIdentifierChoice != nil {
			return false
		}
	} else if this.ClusterIdentifierChoice == nil {
		return false
	} else if !this.ClusterIdentifierChoice.Equal(that1.ClusterIdentifierChoice) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DiscoveryK8S) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DiscoveryK8S)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DiscoveryK8S)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryK8S.Equal(that1.DiscoveryK8S) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DiscoveryConsul) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DiscoveryConsul)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DiscoveryConsul)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryConsul.Equal(that1.DiscoveryConsul) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DiscoveryCbip) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DiscoveryCbip)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DiscoveryCbip)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryCbip.Equal(that1.DiscoveryCbip) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DiscoveryThirdParty) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DiscoveryThirdParty)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DiscoveryThirdParty)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryThirdParty.Equal(that1.DiscoveryThirdParty) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_NoClusterId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_NoClusterId)
	if !ok {
		that2, ok := that.(ReplaceSpecType_NoClusterId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoClusterId.Equal(that1.NoClusterId) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ClusterId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ClusterId)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ClusterId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClusterId != that1.ClusterId {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Where.Equal(that1.Where) {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.PublishVip.Equal(that1.PublishVip) {
		return false
	}
	if that1.DiscoveryChoice == nil {
		if this.DiscoveryChoice != nil {
			return false
		}
	} else if this.DiscoveryChoice == nil {
		return false
	} else if !this.DiscoveryChoice.Equal(that1.DiscoveryChoice) {
		return false
	}
	if that1.ClusterIdentifierChoice == nil {
		if this.ClusterIdentifierChoice != nil {
			return false
		}
	} else if this.ClusterIdentifierChoice == nil {
		return false
	} else if !this.ClusterIdentifierChoice.Equal(that1.ClusterIdentifierChoice) {
		return false
	}
	return true
}
func (this *GetSpecType_DiscoveryK8S) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DiscoveryK8S)
	if !ok {
		that2, ok := that.(GetSpecType_DiscoveryK8S)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryK8S.Equal(that1.DiscoveryK8S) {
		return false
	}
	return true
}
func (this *GetSpecType_DiscoveryConsul) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DiscoveryConsul)
	if !ok {
		that2, ok := that.(GetSpecType_DiscoveryConsul)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryConsul.Equal(that1.DiscoveryConsul) {
		return false
	}
	return true
}
func (this *GetSpecType_DiscoveryCbip) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DiscoveryCbip)
	if !ok {
		that2, ok := that.(GetSpecType_DiscoveryCbip)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryCbip.Equal(that1.DiscoveryCbip) {
		return false
	}
	return true
}
func (this *GetSpecType_DiscoveryThirdParty) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DiscoveryThirdParty)
	if !ok {
		that2, ok := that.(GetSpecType_DiscoveryThirdParty)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryThirdParty.Equal(that1.DiscoveryThirdParty) {
		return false
	}
	return true
}
func (this *GetSpecType_NoClusterId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_NoClusterId)
	if !ok {
		that2, ok := that.(GetSpecType_NoClusterId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoClusterId.Equal(that1.NoClusterId) {
		return false
	}
	return true
}
func (this *GetSpecType_ClusterId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ClusterId)
	if !ok {
		that2, ok := that.(GetSpecType_ClusterId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClusterId != that1.ClusterId {
		return false
	}
	return true
}
func (this *VerStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&discovery.VerStatusType{")
	s = append(s, "Connected: "+fmt.Sprintf("%#v", this.Connected)+",\n")
	s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.Services != nil {
		s = append(s, "Services: "+fmt.Sprintf("%#v", this.Services)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PodInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&discovery.PodInfoType{")
	s = append(s, "PodName: "+fmt.Sprintf("%#v", this.PodName)+",\n")
	s = append(s, "Ip: "+fmt.Sprintf("%#v", this.Ip)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PortInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&discovery.PortInfoType{")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	s = append(s, "TargetPort: "+fmt.Sprintf("%#v", this.TargetPort)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DiscoveredServiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&discovery.DiscoveredServiceType{")
	s = append(s, "ServiceName: "+fmt.Sprintf("%#v", this.ServiceName)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "ServiceType: "+fmt.Sprintf("%#v", this.ServiceType)+",\n")
	s = append(s, "ClusterIp: "+fmt.Sprintf("%#v", this.ClusterIp)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	if this.Pods != nil {
		s = append(s, "Pods: "+fmt.Sprintf("%#v", this.Pods)+",\n")
	}
	keysForPortMap := make([]uint32, 0, len(this.PortMap))
	for k, _ := range this.PortMap {
		keysForPortMap = append(keysForPortMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForPortMap)
	mapStringForPortMap := "map[uint32]uint32{"
	for _, k := range keysForPortMap {
		mapStringForPortMap += fmt.Sprintf("%#v: %#v,", k, this.PortMap[k])
	}
	mapStringForPortMap += "}"
	if this.PortMap != nil {
		s = append(s, "PortMap: "+mapStringForPortMap+",\n")
	}
	if this.Ports != nil {
		s = append(s, "Ports: "+fmt.Sprintf("%#v", this.Ports)+",\n")
	}
	s = append(s, "ClusterIpv6: "+fmt.Sprintf("%#v", this.ClusterIpv6)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLSClientConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&discovery.TLSClientConfigType{")
	s = append(s, "ServerName: "+fmt.Sprintf("%#v", this.ServerName)+",\n")
	if this.CertificateUrl != nil {
		s = append(s, "CertificateUrl: "+fmt.Sprintf("%#v", this.CertificateUrl)+",\n")
	}
	s = append(s, "Certificate: "+fmt.Sprintf("%#v", this.Certificate)+",\n")
	if this.KeyUrl != nil {
		s = append(s, "KeyUrl: "+fmt.Sprintf("%#v", this.KeyUrl)+",\n")
	}
	if this.CaCertificateUrl != nil {
		s = append(s, "CaCertificateUrl: "+fmt.Sprintf("%#v", this.CaCertificateUrl)+",\n")
	}
	s = append(s, "TrustedCaUrl: "+fmt.Sprintf("%#v", this.TrustedCaUrl)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RestConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&discovery.RestConfigType{")
	s = append(s, "ApiServer: "+fmt.Sprintf("%#v", this.ApiServer)+",\n")
	if this.TlsInfo != nil {
		s = append(s, "TlsInfo: "+fmt.Sprintf("%#v", this.TlsInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SAccessInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&discovery.K8SAccessInfo{")
	if this.ConfigType != nil {
		s = append(s, "ConfigType: "+fmt.Sprintf("%#v", this.ConfigType)+",\n")
	}
	if this.K8SPodNetworkChoice != nil {
		s = append(s, "K8SPodNetworkChoice: "+fmt.Sprintf("%#v", this.K8SPodNetworkChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SAccessInfo_KubeconfigUrl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SAccessInfo_KubeconfigUrl{` +
		`KubeconfigUrl:` + fmt.Sprintf("%#v", this.KubeconfigUrl) + `}`}, ", ")
	return s
}
func (this *K8SAccessInfo_ConnectionInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SAccessInfo_ConnectionInfo{` +
		`ConnectionInfo:` + fmt.Sprintf("%#v", this.ConnectionInfo) + `}`}, ", ")
	return s
}
func (this *K8SAccessInfo_InCluster) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SAccessInfo_InCluster{` +
		`InCluster:` + fmt.Sprintf("%#v", this.InCluster) + `}`}, ", ")
	return s
}
func (this *K8SAccessInfo_Isolated) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SAccessInfo_Isolated{` +
		`Isolated:` + fmt.Sprintf("%#v", this.Isolated) + `}`}, ", ")
	return s
}
func (this *K8SAccessInfo_Reachable) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SAccessInfo_Reachable{` +
		`Reachable:` + fmt.Sprintf("%#v", this.Reachable) + `}`}, ", ")
	return s
}
func (this *ConsulHttpBasicAuthInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&discovery.ConsulHttpBasicAuthInfoType{")
	s = append(s, "UserName: "+fmt.Sprintf("%#v", this.UserName)+",\n")
	if this.PasswdUrl != nil {
		s = append(s, "PasswdUrl: "+fmt.Sprintf("%#v", this.PasswdUrl)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConsulAccessInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&discovery.ConsulAccessInfo{")
	if this.ConnectionInfo != nil {
		s = append(s, "ConnectionInfo: "+fmt.Sprintf("%#v", this.ConnectionInfo)+",\n")
	}
	s = append(s, "Scheme: "+fmt.Sprintf("%#v", this.Scheme)+",\n")
	if this.HttpBasicAuthInfo != nil {
		s = append(s, "HttpBasicAuthInfo: "+fmt.Sprintf("%#v", this.HttpBasicAuthInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VipDiscoveryInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&discovery.VipDiscoveryInfoType{")
	s = append(s, "PublishVirtualIp: "+fmt.Sprintf("%#v", this.PublishVirtualIp)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Subdomain: "+fmt.Sprintf("%#v", this.Subdomain)+",\n")
	s = append(s, "DnsMode: "+fmt.Sprintf("%#v", this.DnsMode)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SPublishType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&discovery.K8SPublishType{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SDelegationType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&discovery.K8SDelegationType{")
	s = append(s, "Subdomain: "+fmt.Sprintf("%#v", this.Subdomain)+",\n")
	s = append(s, "DnsMode: "+fmt.Sprintf("%#v", this.DnsMode)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SVipDiscoveryInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&discovery.K8SVipDiscoveryInfoType{")
	if this.PublishChoice != nil {
		s = append(s, "PublishChoice: "+fmt.Sprintf("%#v", this.PublishChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SVipDiscoveryInfoType_Disable) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SVipDiscoveryInfoType_Disable{` +
		`Disable:` + fmt.Sprintf("%#v", this.Disable) + `}`}, ", ")
	return s
}
func (this *K8SVipDiscoveryInfoType_Publish) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SVipDiscoveryInfoType_Publish{` +
		`Publish:` + fmt.Sprintf("%#v", this.Publish) + `}`}, ", ")
	return s
}
func (this *K8SVipDiscoveryInfoType_PublishFqdns) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SVipDiscoveryInfoType_PublishFqdns{` +
		`PublishFqdns:` + fmt.Sprintf("%#v", this.PublishFqdns) + `}`}, ", ")
	return s
}
func (this *K8SVipDiscoveryInfoType_DnsDelegation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SVipDiscoveryInfoType_DnsDelegation{` +
		`DnsDelegation:` + fmt.Sprintf("%#v", this.DnsDelegation) + `}`}, ", ")
	return s
}
func (this *ConsulVipDiscoveryInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&discovery.ConsulVipDiscoveryInfoType{")
	if this.PublishChoice != nil {
		s = append(s, "PublishChoice: "+fmt.Sprintf("%#v", this.PublishChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConsulVipDiscoveryInfoType_Disable) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.ConsulVipDiscoveryInfoType_Disable{` +
		`Disable:` + fmt.Sprintf("%#v", this.Disable) + `}`}, ", ")
	return s
}
func (this *ConsulVipDiscoveryInfoType_Publish) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.ConsulVipDiscoveryInfoType_Publish{` +
		`Publish:` + fmt.Sprintf("%#v", this.Publish) + `}`}, ", ")
	return s
}
func (this *K8SDiscoveryType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&discovery.K8SDiscoveryType{")
	if this.AccessInfo != nil {
		s = append(s, "AccessInfo: "+fmt.Sprintf("%#v", this.AccessInfo)+",\n")
	}
	if this.PublishInfo != nil {
		s = append(s, "PublishInfo: "+fmt.Sprintf("%#v", this.PublishInfo)+",\n")
	}
	if this.NamespaceMappingChoice != nil {
		s = append(s, "NamespaceMappingChoice: "+fmt.Sprintf("%#v", this.NamespaceMappingChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SDiscoveryType_DefaultAll) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SDiscoveryType_DefaultAll{` +
		`DefaultAll:` + fmt.Sprintf("%#v", this.DefaultAll) + `}`}, ", ")
	return s
}
func (this *K8SDiscoveryType_NamespaceMapping) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SDiscoveryType_NamespaceMapping{` +
		`NamespaceMapping:` + fmt.Sprintf("%#v", this.NamespaceMapping) + `}`}, ", ")
	return s
}
func (this *ConsulDiscoveryType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&discovery.ConsulDiscoveryType{")
	if this.AccessInfo != nil {
		s = append(s, "AccessInfo: "+fmt.Sprintf("%#v", this.AccessInfo)+",\n")
	}
	if this.PublishInfo != nil {
		s = append(s, "PublishInfo: "+fmt.Sprintf("%#v", this.PublishInfo)+",\n")
	}
	if this.NamespaceMappingChoice != nil {
		s = append(s, "NamespaceMappingChoice: "+fmt.Sprintf("%#v", this.NamespaceMappingChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConsulDiscoveryType_DefaultAll) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.ConsulDiscoveryType_DefaultAll{` +
		`DefaultAll:` + fmt.Sprintf("%#v", this.DefaultAll) + `}`}, ", ")
	return s
}
func (this *ConsulDiscoveryType_NamespaceMapping) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.ConsulDiscoveryType_NamespaceMapping{` +
		`NamespaceMapping:` + fmt.Sprintf("%#v", this.NamespaceMapping) + `}`}, ", ")
	return s
}
func (this *CbipDiscoveryType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&discovery.CbipDiscoveryType{")
	if this.CbipClusters != nil {
		s = append(s, "CbipClusters: "+fmt.Sprintf("%#v", this.CbipClusters)+",\n")
	}
	s = append(s, "InternalLbDomain: "+fmt.Sprintf("%#v", this.InternalLbDomain)+",\n")
	if this.ServerCa != nil {
		s = append(s, "ServerCa: "+fmt.Sprintf("%#v", this.ServerCa)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ThirdPartyDiscoveryType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&discovery.ThirdPartyDiscoveryType{")
	s = append(s, "Applications: "+fmt.Sprintf("%#v", this.Applications)+",\n")
	s = append(s, "SourceCidr: "+fmt.Sprintf("%#v", this.SourceCidr)+",\n")
	if this.ExpirationTimestamp != nil {
		s = append(s, "ExpirationTimestamp: "+fmt.Sprintf("%#v", this.ExpirationTimestamp)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CbipCluster) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&discovery.CbipCluster{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	if this.CbipDevices != nil {
		s = append(s, "CbipDevices: "+fmt.Sprintf("%#v", this.CbipDevices)+",\n")
	}
	s = append(s, "CbipMgmtIps: "+fmt.Sprintf("%#v", this.CbipMgmtIps)+",\n")
	if this.AdminCredentials != nil {
		s = append(s, "AdminCredentials: "+fmt.Sprintf("%#v", this.AdminCredentials)+",\n")
	}
	if this.CbipCertificateAuthority != nil {
		s = append(s, "CbipCertificateAuthority: "+fmt.Sprintf("%#v", this.CbipCertificateAuthority)+",\n")
	}
	if this.VirtualServerFilter != nil {
		s = append(s, "VirtualServerFilter: "+fmt.Sprintf("%#v", this.VirtualServerFilter)+",\n")
	}
	if this.NamespaceMappingChoice != nil {
		s = append(s, "NamespaceMappingChoice: "+fmt.Sprintf("%#v", this.NamespaceMappingChoice)+",\n")
	}
	if this.MgmtPort != nil {
		s = append(s, "MgmtPort: "+fmt.Sprintf("%#v", this.MgmtPort)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CbipCluster_DefaultAll) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.CbipCluster_DefaultAll{` +
		`DefaultAll:` + fmt.Sprintf("%#v", this.DefaultAll) + `}`}, ", ")
	return s
}
func (this *CbipCluster_NamespaceMapping) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.CbipCluster_NamespaceMapping{` +
		`NamespaceMapping:` + fmt.Sprintf("%#v", this.NamespaceMapping) + `}`}, ", ")
	return s
}
func (this *CbipDeviceConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&discovery.CbipDeviceConfig{")
	s = append(s, "CbipMgmtIp: "+fmt.Sprintf("%#v", this.CbipMgmtIp)+",\n")
	if this.AdminCredentials != nil {
		s = append(s, "AdminCredentials: "+fmt.Sprintf("%#v", this.AdminCredentials)+",\n")
	}
	if this.CbipCertificateAuthority != nil {
		s = append(s, "CbipCertificateAuthority: "+fmt.Sprintf("%#v", this.CbipCertificateAuthority)+",\n")
	}
	if this.VirtualServerFilter != nil {
		s = append(s, "VirtualServerFilter: "+fmt.Sprintf("%#v", this.VirtualServerFilter)+",\n")
	}
	if this.NamespaceMappingChoice != nil {
		s = append(s, "NamespaceMappingChoice: "+fmt.Sprintf("%#v", this.NamespaceMappingChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CbipDeviceConfig_DefaultAll) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.CbipDeviceConfig_DefaultAll{` +
		`DefaultAll:` + fmt.Sprintf("%#v", this.DefaultAll) + `}`}, ", ")
	return s
}
func (this *CbipDeviceConfig_NamespaceMapping) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.CbipDeviceConfig_NamespaceMapping{` +
		`NamespaceMapping:` + fmt.Sprintf("%#v", this.NamespaceMapping) + `}`}, ", ")
	return s
}
func (this *CbipAdminCredentials) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&discovery.CbipAdminCredentials{")
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	if this.Password != nil {
		s = append(s, "Password: "+fmt.Sprintf("%#v", this.Password)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ManagementPort) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&discovery.ManagementPort{")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CbipCertificateAuthority) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&discovery.CbipCertificateAuthority{")
	if this.ServerValidationChoice != nil {
		s = append(s, "ServerValidationChoice: "+fmt.Sprintf("%#v", this.ServerValidationChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CbipCertificateAuthority_TrustedCa) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.CbipCertificateAuthority_TrustedCa{` +
		`TrustedCa:` + fmt.Sprintf("%#v", this.TrustedCa) + `}`}, ", ")
	return s
}
func (this *CbipCertificateAuthority_SkipServerVerification) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.CbipCertificateAuthority_SkipServerVerification{` +
		`SkipServerVerification:` + fmt.Sprintf("%#v", this.SkipServerVerification) + `}`}, ", ")
	return s
}
func (this *VirtualServerFilter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&discovery.VirtualServerFilter{")
	s = append(s, "NameRegex: "+fmt.Sprintf("%#v", this.NameRegex)+",\n")
	s = append(s, "DescriptionRegex: "+fmt.Sprintf("%#v", this.DescriptionRegex)+",\n")
	s = append(s, "Protocols: "+fmt.Sprintf("%#v", this.Protocols)+",\n")
	s = append(s, "PortRanges: "+fmt.Sprintf("%#v", this.PortRanges)+",\n")
	s = append(s, "DiscoverDisabledVirtualServers: "+fmt.Sprintf("%#v", this.DiscoverDisabledVirtualServers)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NamespaceMapping) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&discovery.NamespaceMapping{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NamespaceMappingItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&discovery.NamespaceMappingItem{")
	s = append(s, "PartitionRegex: "+fmt.Sprintf("%#v", this.PartitionRegex)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SNamespaceMapping) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&discovery.K8SNamespaceMapping{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SNamespaceMappingItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&discovery.K8SNamespaceMappingItem{")
	s = append(s, "NamespaceRegex: "+fmt.Sprintf("%#v", this.NamespaceRegex)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConsulNamespaceMapping) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&discovery.ConsulNamespaceMapping{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConsulNamespaceMappingItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&discovery.ConsulNamespaceMappingItem{")
	s = append(s, "NamespaceRegex: "+fmt.Sprintf("%#v", this.NamespaceRegex)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&discovery.GlobalSpecType{")
	if this.Where != nil {
		s = append(s, "Where: "+fmt.Sprintf("%#v", this.Where)+",\n")
	}
	if this.DiscoveryChoice != nil {
		s = append(s, "DiscoveryChoice: "+fmt.Sprintf("%#v", this.DiscoveryChoice)+",\n")
	}
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.PublishVip != nil {
		s = append(s, "PublishVip: "+fmt.Sprintf("%#v", this.PublishVip)+",\n")
	}
	if this.AccessInfo != nil {
		s = append(s, "AccessInfo: "+fmt.Sprintf("%#v", this.AccessInfo)+",\n")
	}
	s = append(s, "ClusterIdentifier: "+fmt.Sprintf("%#v", this.ClusterIdentifier)+",\n")
	if this.ClusterIdentifierChoice != nil {
		s = append(s, "ClusterIdentifierChoice: "+fmt.Sprintf("%#v", this.ClusterIdentifierChoice)+",\n")
	}
	if this.ViewInternal != nil {
		s = append(s, "ViewInternal: "+fmt.Sprintf("%#v", this.ViewInternal)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_DiscoveryK8S) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GlobalSpecType_DiscoveryK8S{` +
		`DiscoveryK8S:` + fmt.Sprintf("%#v", this.DiscoveryK8S) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DiscoveryConsul) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GlobalSpecType_DiscoveryConsul{` +
		`DiscoveryConsul:` + fmt.Sprintf("%#v", this.DiscoveryConsul) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DiscoveryCbip) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GlobalSpecType_DiscoveryCbip{` +
		`DiscoveryCbip:` + fmt.Sprintf("%#v", this.DiscoveryCbip) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DiscoveryThirdParty) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GlobalSpecType_DiscoveryThirdParty{` +
		`DiscoveryThirdParty:` + fmt.Sprintf("%#v", this.DiscoveryThirdParty) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_K8S) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GlobalSpecType_K8S{` +
		`K8S:` + fmt.Sprintf("%#v", this.K8S) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_Consul) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GlobalSpecType_Consul{` +
		`Consul:` + fmt.Sprintf("%#v", this.Consul) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_NoClusterId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GlobalSpecType_NoClusterId{` +
		`NoClusterId:` + fmt.Sprintf("%#v", this.NoClusterId) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ClusterId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GlobalSpecType_ClusterId{` +
		`ClusterId:` + fmt.Sprintf("%#v", this.ClusterId) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&discovery.CreateSpecType{")
	if this.Where != nil {
		s = append(s, "Where: "+fmt.Sprintf("%#v", this.Where)+",\n")
	}
	if this.DiscoveryChoice != nil {
		s = append(s, "DiscoveryChoice: "+fmt.Sprintf("%#v", this.DiscoveryChoice)+",\n")
	}
	if this.ClusterIdentifierChoice != nil {
		s = append(s, "ClusterIdentifierChoice: "+fmt.Sprintf("%#v", this.ClusterIdentifierChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_DiscoveryK8S) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.CreateSpecType_DiscoveryK8S{` +
		`DiscoveryK8S:` + fmt.Sprintf("%#v", this.DiscoveryK8S) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DiscoveryConsul) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.CreateSpecType_DiscoveryConsul{` +
		`DiscoveryConsul:` + fmt.Sprintf("%#v", this.DiscoveryConsul) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DiscoveryCbip) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.CreateSpecType_DiscoveryCbip{` +
		`DiscoveryCbip:` + fmt.Sprintf("%#v", this.DiscoveryCbip) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DiscoveryThirdParty) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.CreateSpecType_DiscoveryThirdParty{` +
		`DiscoveryThirdParty:` + fmt.Sprintf("%#v", this.DiscoveryThirdParty) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_NoClusterId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.CreateSpecType_NoClusterId{` +
		`NoClusterId:` + fmt.Sprintf("%#v", this.NoClusterId) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ClusterId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.CreateSpecType_ClusterId{` +
		`ClusterId:` + fmt.Sprintf("%#v", this.ClusterId) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&discovery.ReplaceSpecType{")
	if this.Where != nil {
		s = append(s, "Where: "+fmt.Sprintf("%#v", this.Where)+",\n")
	}
	if this.DiscoveryChoice != nil {
		s = append(s, "DiscoveryChoice: "+fmt.Sprintf("%#v", this.DiscoveryChoice)+",\n")
	}
	if this.ClusterIdentifierChoice != nil {
		s = append(s, "ClusterIdentifierChoice: "+fmt.Sprintf("%#v", this.ClusterIdentifierChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_DiscoveryK8S) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.ReplaceSpecType_DiscoveryK8S{` +
		`DiscoveryK8S:` + fmt.Sprintf("%#v", this.DiscoveryK8S) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DiscoveryConsul) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.ReplaceSpecType_DiscoveryConsul{` +
		`DiscoveryConsul:` + fmt.Sprintf("%#v", this.DiscoveryConsul) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DiscoveryCbip) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.ReplaceSpecType_DiscoveryCbip{` +
		`DiscoveryCbip:` + fmt.Sprintf("%#v", this.DiscoveryCbip) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DiscoveryThirdParty) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.ReplaceSpecType_DiscoveryThirdParty{` +
		`DiscoveryThirdParty:` + fmt.Sprintf("%#v", this.DiscoveryThirdParty) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_NoClusterId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.ReplaceSpecType_NoClusterId{` +
		`NoClusterId:` + fmt.Sprintf("%#v", this.NoClusterId) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ClusterId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.ReplaceSpecType_ClusterId{` +
		`ClusterId:` + fmt.Sprintf("%#v", this.ClusterId) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&discovery.GetSpecType{")
	if this.Where != nil {
		s = append(s, "Where: "+fmt.Sprintf("%#v", this.Where)+",\n")
	}
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.PublishVip != nil {
		s = append(s, "PublishVip: "+fmt.Sprintf("%#v", this.PublishVip)+",\n")
	}
	if this.DiscoveryChoice != nil {
		s = append(s, "DiscoveryChoice: "+fmt.Sprintf("%#v", this.DiscoveryChoice)+",\n")
	}
	if this.ClusterIdentifierChoice != nil {
		s = append(s, "ClusterIdentifierChoice: "+fmt.Sprintf("%#v", this.ClusterIdentifierChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_DiscoveryK8S) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GetSpecType_DiscoveryK8S{` +
		`DiscoveryK8S:` + fmt.Sprintf("%#v", this.DiscoveryK8S) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DiscoveryConsul) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GetSpecType_DiscoveryConsul{` +
		`DiscoveryConsul:` + fmt.Sprintf("%#v", this.DiscoveryConsul) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DiscoveryCbip) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GetSpecType_DiscoveryCbip{` +
		`DiscoveryCbip:` + fmt.Sprintf("%#v", this.DiscoveryCbip) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DiscoveryThirdParty) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GetSpecType_DiscoveryThirdParty{` +
		`DiscoveryThirdParty:` + fmt.Sprintf("%#v", this.DiscoveryThirdParty) + `}`}, ", ")
	return s
}
func (this *GetSpecType_NoClusterId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GetSpecType_NoClusterId{` +
		`NoClusterId:` + fmt.Sprintf("%#v", this.NoClusterId) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ClusterId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GetSpecType_ClusterId{` +
		`ClusterId:` + fmt.Sprintf("%#v", this.ClusterId) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *VerStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Services) > 0 {
		for iNdEx := len(m.Services) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Services[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Site) > 0 {
		i -= len(m.Site)
		copy(dAtA[i:], m.Site)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Site)))
		i--
		dAtA[i] = 0x12
	}
	if m.Connected {
		i--
		if m.Connected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PodInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PodName) > 0 {
		i -= len(m.PodName)
		copy(dAtA[i:], m.PodName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PodName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PortInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TargetPort != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TargetPort))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0x12
	}
	if m.Port != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DiscoveredServiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscoveredServiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiscoveredServiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ClusterIpv6) > 0 {
		i -= len(m.ClusterIpv6)
		copy(dAtA[i:], m.ClusterIpv6)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterIpv6)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.PortMap) > 0 {
		keysForPortMap := make([]uint32, 0, len(m.PortMap))
		for k := range m.PortMap {
			keysForPortMap = append(keysForPortMap, uint32(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint32s(keysForPortMap)
		for iNdEx := len(keysForPortMap) - 1; iNdEx >= 0; iNdEx-- {
			v := m.PortMap[uint32(keysForPortMap[iNdEx])]
			baseI := i
			i = encodeVarintTypes(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintTypes(dAtA, i, uint64(keysForPortMap[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Pods) > 0 {
		for iNdEx := len(m.Pods) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ClusterIp) > 0 {
		i -= len(m.ClusterIp)
		copy(dAtA[i:], m.ClusterIp)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterIp)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ServiceType) > 0 {
		i -= len(m.ServiceType)
		copy(dAtA[i:], m.ServiceType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ServiceType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ServiceName) > 0 {
		i -= len(m.ServiceName)
		copy(dAtA[i:], m.ServiceName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ServiceName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLSClientConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSClientConfigType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLSClientConfigType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TrustedCaUrl) > 0 {
		i -= len(m.TrustedCaUrl)
		copy(dAtA[i:], m.TrustedCaUrl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TrustedCaUrl)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Certificate) > 0 {
		i -= len(m.Certificate)
		copy(dAtA[i:], m.Certificate)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Certificate)))
		i--
		dAtA[i] = 0x2a
	}
	if m.CaCertificateUrl != nil {
		{
			size, err := m.CaCertificateUrl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.KeyUrl != nil {
		{
			size, err := m.KeyUrl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.CertificateUrl != nil {
		{
			size, err := m.CertificateUrl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ServerName) > 0 {
		i -= len(m.ServerName)
		copy(dAtA[i:], m.ServerName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RestConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestConfigType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RestConfigType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TlsInfo != nil {
		{
			size, err := m.TlsInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ApiServer) > 0 {
		i -= len(m.ApiServer)
		copy(dAtA[i:], m.ApiServer)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ApiServer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *K8SAccessInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SAccessInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SAccessInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.K8SPodNetworkChoice != nil {
		{
			size := m.K8SPodNetworkChoice.Size()
			i -= size
			if _, err := m.K8SPodNetworkChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ConfigType != nil {
		{
			size := m.ConfigType.Size()
			i -= size
			if _, err := m.ConfigType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *K8SAccessInfo_KubeconfigUrl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SAccessInfo_KubeconfigUrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.KubeconfigUrl != nil {
		{
			size, err := m.KubeconfigUrl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *K8SAccessInfo_ConnectionInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SAccessInfo_ConnectionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConnectionInfo != nil {
		{
			size, err := m.ConnectionInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *K8SAccessInfo_InCluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SAccessInfo_InCluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.InCluster {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *K8SAccessInfo_Isolated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SAccessInfo_Isolated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Isolated != nil {
		{
			size, err := m.Isolated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *K8SAccessInfo_Reachable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SAccessInfo_Reachable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Reachable != nil {
		{
			size, err := m.Reachable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ConsulHttpBasicAuthInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsulHttpBasicAuthInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsulHttpBasicAuthInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PasswdUrl != nil {
		{
			size, err := m.PasswdUrl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsulAccessInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsulAccessInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsulAccessInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HttpBasicAuthInfo != nil {
		{
			size, err := m.HttpBasicAuthInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Scheme != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Scheme))
		i--
		dAtA[i] = 0x10
	}
	if m.ConnectionInfo != nil {
		{
			size, err := m.ConnectionInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VipDiscoveryInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VipDiscoveryInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VipDiscoveryInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x2a
	}
	if m.DnsMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DnsMode))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Subdomain) > 0 {
		i -= len(m.Subdomain)
		copy(dAtA[i:], m.Subdomain)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Subdomain)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.PublishVirtualIp {
		i--
		if m.PublishVirtualIp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *K8SPublishType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SPublishType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SPublishType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *K8SDelegationType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SDelegationType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SDelegationType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DnsMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DnsMode))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Subdomain) > 0 {
		i -= len(m.Subdomain)
		copy(dAtA[i:], m.Subdomain)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Subdomain)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *K8SVipDiscoveryInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SVipDiscoveryInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SVipDiscoveryInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PublishChoice != nil {
		{
			size := m.PublishChoice.Size()
			i -= size
			if _, err := m.PublishChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *K8SVipDiscoveryInfoType_Disable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SVipDiscoveryInfoType_Disable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Disable != nil {
		{
			size, err := m.Disable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *K8SVipDiscoveryInfoType_Publish) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SVipDiscoveryInfoType_Publish) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Publish != nil {
		{
			size, err := m.Publish.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *K8SVipDiscoveryInfoType_PublishFqdns) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SVipDiscoveryInfoType_PublishFqdns) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PublishFqdns != nil {
		{
			size, err := m.PublishFqdns.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *K8SVipDiscoveryInfoType_DnsDelegation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SVipDiscoveryInfoType_DnsDelegation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DnsDelegation != nil {
		{
			size, err := m.DnsDelegation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ConsulVipDiscoveryInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsulVipDiscoveryInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsulVipDiscoveryInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PublishChoice != nil {
		{
			size := m.PublishChoice.Size()
			i -= size
			if _, err := m.PublishChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ConsulVipDiscoveryInfoType_Disable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsulVipDiscoveryInfoType_Disable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Disable != nil {
		{
			size, err := m.Disable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ConsulVipDiscoveryInfoType_Publish) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsulVipDiscoveryInfoType_Publish) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Publish != nil {
		{
			size, err := m.Publish.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *K8SDiscoveryType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SDiscoveryType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SDiscoveryType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NamespaceMappingChoice != nil {
		{
			size := m.NamespaceMappingChoice.Size()
			i -= size
			if _, err := m.NamespaceMappingChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.PublishInfo != nil {
		{
			size, err := m.PublishInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.AccessInfo != nil {
		{
			size, err := m.AccessInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *K8SDiscoveryType_DefaultAll) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SDiscoveryType_DefaultAll) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultAll != nil {
		{
			size, err := m.DefaultAll.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *K8SDiscoveryType_NamespaceMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SDiscoveryType_NamespaceMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NamespaceMapping != nil {
		{
			size, err := m.NamespaceMapping.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ConsulDiscoveryType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsulDiscoveryType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsulDiscoveryType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NamespaceMappingChoice != nil {
		{
			size := m.NamespaceMappingChoice.Size()
			i -= size
			if _, err := m.NamespaceMappingChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.PublishInfo != nil {
		{
			size, err := m.PublishInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.AccessInfo != nil {
		{
			size, err := m.AccessInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsulDiscoveryType_DefaultAll) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsulDiscoveryType_DefaultAll) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultAll != nil {
		{
			size, err := m.DefaultAll.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ConsulDiscoveryType_NamespaceMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsulDiscoveryType_NamespaceMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NamespaceMapping != nil {
		{
			size, err := m.NamespaceMapping.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *CbipDiscoveryType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CbipDiscoveryType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CbipDiscoveryType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ServerCa) > 0 {
		for iNdEx := len(m.ServerCa) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ServerCa[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.InternalLbDomain) > 0 {
		i -= len(m.InternalLbDomain)
		copy(dAtA[i:], m.InternalLbDomain)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InternalLbDomain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CbipClusters) > 0 {
		for iNdEx := len(m.CbipClusters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CbipClusters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ThirdPartyDiscoveryType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThirdPartyDiscoveryType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThirdPartyDiscoveryType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpirationTimestamp != nil {
		{
			size, err := m.ExpirationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SourceCidr) > 0 {
		for iNdEx := len(m.SourceCidr) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SourceCidr[iNdEx])
			copy(dAtA[i:], m.SourceCidr[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.SourceCidr[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Applications) > 0 {
		for iNdEx := len(m.Applications) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Applications[iNdEx])
			copy(dAtA[i:], m.Applications[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Applications[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CbipCluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CbipCluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CbipCluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MgmtPort != nil {
		{
			size, err := m.MgmtPort.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.NamespaceMappingChoice != nil {
		{
			size := m.NamespaceMappingChoice.Size()
			i -= size
			if _, err := m.NamespaceMappingChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.VirtualServerFilter != nil {
		{
			size, err := m.VirtualServerFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.CbipCertificateAuthority != nil {
		{
			size, err := m.CbipCertificateAuthority.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.AdminCredentials != nil {
		{
			size, err := m.AdminCredentials.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.CbipMgmtIps) > 0 {
		for iNdEx := len(m.CbipMgmtIps) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CbipMgmtIps[iNdEx])
			copy(dAtA[i:], m.CbipMgmtIps[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.CbipMgmtIps[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CbipDevices) > 0 {
		for iNdEx := len(m.CbipDevices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CbipDevices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CbipCluster_DefaultAll) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CbipCluster_DefaultAll) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultAll != nil {
		{
			size, err := m.DefaultAll.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *CbipCluster_NamespaceMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CbipCluster_NamespaceMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NamespaceMapping != nil {
		{
			size, err := m.NamespaceMapping.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *CbipDeviceConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CbipDeviceConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CbipDeviceConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NamespaceMappingChoice != nil {
		{
			size := m.NamespaceMappingChoice.Size()
			i -= size
			if _, err := m.NamespaceMappingChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.VirtualServerFilter != nil {
		{
			size, err := m.VirtualServerFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.CbipCertificateAuthority != nil {
		{
			size, err := m.CbipCertificateAuthority.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AdminCredentials != nil {
		{
			size, err := m.AdminCredentials.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.CbipMgmtIp) > 0 {
		i -= len(m.CbipMgmtIp)
		copy(dAtA[i:], m.CbipMgmtIp)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CbipMgmtIp)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CbipDeviceConfig_DefaultAll) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CbipDeviceConfig_DefaultAll) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultAll != nil {
		{
			size, err := m.DefaultAll.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *CbipDeviceConfig_NamespaceMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CbipDeviceConfig_NamespaceMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NamespaceMapping != nil {
		{
			size, err := m.NamespaceMapping.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *CbipAdminCredentials) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CbipAdminCredentials) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CbipAdminCredentials) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Password != nil {
		{
			size, err := m.Password.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ManagementPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ManagementPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ManagementPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CbipCertificateAuthority) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CbipCertificateAuthority) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CbipCertificateAuthority) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ServerValidationChoice != nil {
		{
			size := m.ServerValidationChoice.Size()
			i -= size
			if _, err := m.ServerValidationChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CbipCertificateAuthority_TrustedCa) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CbipCertificateAuthority_TrustedCa) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TrustedCa != nil {
		{
			size, err := m.TrustedCa.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CbipCertificateAuthority_SkipServerVerification) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CbipCertificateAuthority_SkipServerVerification) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SkipServerVerification != nil {
		{
			size, err := m.SkipServerVerification.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *VirtualServerFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualServerFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VirtualServerFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DiscoverDisabledVirtualServers {
		i--
		if m.DiscoverDisabledVirtualServers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.PortRanges) > 0 {
		i -= len(m.PortRanges)
		copy(dAtA[i:], m.PortRanges)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PortRanges)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Protocols) > 0 {
		for iNdEx := len(m.Protocols) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Protocols[iNdEx])
			copy(dAtA[i:], m.Protocols[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Protocols[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.DescriptionRegex) > 0 {
		i -= len(m.DescriptionRegex)
		copy(dAtA[i:], m.DescriptionRegex)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DescriptionRegex)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.NameRegex) > 0 {
		i -= len(m.NameRegex)
		copy(dAtA[i:], m.NameRegex)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NameRegex)))
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}

func (m *NamespaceMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespaceMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NamespaceMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NamespaceMappingItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespaceMappingItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NamespaceMappingItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PartitionRegex) > 0 {
		i -= len(m.PartitionRegex)
		copy(dAtA[i:], m.PartitionRegex)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PartitionRegex)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *K8SNamespaceMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SNamespaceMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SNamespaceMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *K8SNamespaceMappingItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SNamespaceMappingItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SNamespaceMappingItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NamespaceRegex) > 0 {
		i -= len(m.NamespaceRegex)
		copy(dAtA[i:], m.NamespaceRegex)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NamespaceRegex)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsulNamespaceMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsulNamespaceMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsulNamespaceMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ConsulNamespaceMappingItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsulNamespaceMappingItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsulNamespaceMappingItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NamespaceRegex) > 0 {
		i -= len(m.NamespaceRegex)
		copy(dAtA[i:], m.NamespaceRegex)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NamespaceRegex)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ViewInternal != nil {
		{
			size, err := m.ViewInternal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xc2
	}
	if m.DiscoveryChoice != nil {
		{
			size := m.DiscoveryChoice.Size()
			i -= size
			if _, err := m.DiscoveryChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ClusterIdentifierChoice != nil {
		{
			size := m.ClusterIdentifierChoice.Size()
			i -= size
			if _, err := m.ClusterIdentifierChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.ClusterIdentifier) > 0 {
		i -= len(m.ClusterIdentifier)
		copy(dAtA[i:], m.ClusterIdentifier)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterIdentifier)))
		i--
		dAtA[i] = 0x52
	}
	if m.AccessInfo != nil {
		{
			size := m.AccessInfo.Size()
			i -= size
			if _, err := m.AccessInfo.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.PublishVip != nil {
		{
			size, err := m.PublishVip.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Where != nil {
		{
			size, err := m.Where.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_K8S) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_K8S) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.K8S != nil {
		{
			size, err := m.K8S.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_Consul) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_Consul) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Consul != nil {
		{
			size, err := m.Consul.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DiscoveryK8S) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DiscoveryK8S) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DiscoveryK8S != nil {
		{
			size, err := m.DiscoveryK8S.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DiscoveryConsul) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DiscoveryConsul) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DiscoveryConsul != nil {
		{
			size, err := m.DiscoveryConsul.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_NoClusterId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_NoClusterId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoClusterId != nil {
		{
			size, err := m.NoClusterId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_ClusterId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_ClusterId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ClusterId)
	copy(dAtA[i:], m.ClusterId)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterId)))
	i--
	dAtA[i] = 0x6a
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DiscoveryCbip) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DiscoveryCbip) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DiscoveryCbip != nil {
		{
			size, err := m.DiscoveryCbip.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DiscoveryThirdParty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DiscoveryThirdParty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DiscoveryThirdParty != nil {
		{
			size, err := m.DiscoveryThirdParty.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DiscoveryChoice != nil {
		{
			size := m.DiscoveryChoice.Size()
			i -= size
			if _, err := m.DiscoveryChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ClusterIdentifierChoice != nil {
		{
			size := m.ClusterIdentifierChoice.Size()
			i -= size
			if _, err := m.ClusterIdentifierChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Where != nil {
		{
			size, err := m.Where.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_DiscoveryK8S) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DiscoveryK8S) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DiscoveryK8S != nil {
		{
			size, err := m.DiscoveryK8S.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_DiscoveryConsul) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DiscoveryConsul) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DiscoveryConsul != nil {
		{
			size, err := m.DiscoveryConsul.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_NoClusterId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_NoClusterId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoClusterId != nil {
		{
			size, err := m.NoClusterId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_ClusterId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_ClusterId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ClusterId)
	copy(dAtA[i:], m.ClusterId)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterId)))
	i--
	dAtA[i] = 0x6a
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_DiscoveryCbip) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DiscoveryCbip) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DiscoveryCbip != nil {
		{
			size, err := m.DiscoveryCbip.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_DiscoveryThirdParty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DiscoveryThirdParty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DiscoveryThirdParty != nil {
		{
			size, err := m.DiscoveryThirdParty.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DiscoveryChoice != nil {
		{
			size := m.DiscoveryChoice.Size()
			i -= size
			if _, err := m.DiscoveryChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ClusterIdentifierChoice != nil {
		{
			size := m.ClusterIdentifierChoice.Size()
			i -= size
			if _, err := m.ClusterIdentifierChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Where != nil {
		{
			size, err := m.Where.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_DiscoveryK8S) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DiscoveryK8S) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DiscoveryK8S != nil {
		{
			size, err := m.DiscoveryK8S.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_DiscoveryConsul) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DiscoveryConsul) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DiscoveryConsul != nil {
		{
			size, err := m.DiscoveryConsul.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_NoClusterId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_NoClusterId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoClusterId != nil {
		{
			size, err := m.NoClusterId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_ClusterId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_ClusterId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ClusterId)
	copy(dAtA[i:], m.ClusterId)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterId)))
	i--
	dAtA[i] = 0x6a
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_DiscoveryCbip) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DiscoveryCbip) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DiscoveryCbip != nil {
		{
			size, err := m.DiscoveryCbip.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_DiscoveryThirdParty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DiscoveryThirdParty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DiscoveryThirdParty != nil {
		{
			size, err := m.DiscoveryThirdParty.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DiscoveryChoice != nil {
		{
			size := m.DiscoveryChoice.Size()
			i -= size
			if _, err := m.DiscoveryChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ClusterIdentifierChoice != nil {
		{
			size := m.ClusterIdentifierChoice.Size()
			i -= size
			if _, err := m.ClusterIdentifierChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.PublishVip != nil {
		{
			size, err := m.PublishVip.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Where != nil {
		{
			size, err := m.Where.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_DiscoveryK8S) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DiscoveryK8S) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DiscoveryK8S != nil {
		{
			size, err := m.DiscoveryK8S.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_DiscoveryConsul) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DiscoveryConsul) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DiscoveryConsul != nil {
		{
			size, err := m.DiscoveryConsul.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_NoClusterId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_NoClusterId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoClusterId != nil {
		{
			size, err := m.NoClusterId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_ClusterId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_ClusterId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ClusterId)
	copy(dAtA[i:], m.ClusterId)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterId)))
	i--
	dAtA[i] = 0x6a
	return len(dAtA) - i, nil
}
func (m *GetSpecType_DiscoveryCbip) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DiscoveryCbip) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DiscoveryCbip != nil {
		{
			size, err := m.DiscoveryCbip.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_DiscoveryThirdParty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DiscoveryThirdParty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DiscoveryThirdParty != nil {
		{
			size, err := m.DiscoveryThirdParty.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *VerStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Connected {
		n += 2
	}
	l = len(m.Site)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if len(m.Services) > 0 {
		for _, e := range m.Services {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *PodInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *PortInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Port != 0 {
		n += 1 + sovTypes(uint64(m.Port))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TargetPort != 0 {
		n += 1 + sovTypes(uint64(m.TargetPort))
	}
	return n
}

func (m *DiscoveredServiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ServiceType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClusterIp)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Pods) > 0 {
		for _, e := range m.Pods {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.PortMap) > 0 {
		for k, v := range m.PortMap {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTypes(uint64(k)) + 1 + sovTypes(uint64(v))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.ClusterIpv6)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *TLSClientConfigType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CertificateUrl != nil {
		l = m.CertificateUrl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.KeyUrl != nil {
		l = m.KeyUrl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CaCertificateUrl != nil {
		l = m.CaCertificateUrl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Certificate)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TrustedCaUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RestConfigType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ApiServer)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TlsInfo != nil {
		l = m.TlsInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *K8SAccessInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfigType != nil {
		n += m.ConfigType.Size()
	}
	if m.K8SPodNetworkChoice != nil {
		n += m.K8SPodNetworkChoice.Size()
	}
	return n
}

func (m *K8SAccessInfo_KubeconfigUrl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KubeconfigUrl != nil {
		l = m.KubeconfigUrl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *K8SAccessInfo_ConnectionInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectionInfo != nil {
		l = m.ConnectionInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *K8SAccessInfo_InCluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *K8SAccessInfo_Isolated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Isolated != nil {
		l = m.Isolated.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *K8SAccessInfo_Reachable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reachable != nil {
		l = m.Reachable.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ConsulHttpBasicAuthInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PasswdUrl != nil {
		l = m.PasswdUrl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ConsulAccessInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectionInfo != nil {
		l = m.ConnectionInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Scheme != 0 {
		n += 1 + sovTypes(uint64(m.Scheme))
	}
	if m.HttpBasicAuthInfo != nil {
		l = m.HttpBasicAuthInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *VipDiscoveryInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PublishVirtualIp {
		n += 2
	}
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	l = len(m.Subdomain)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DnsMode != 0 {
		n += 1 + sovTypes(uint64(m.DnsMode))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *K8SPublishType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *K8SDelegationType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Subdomain)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DnsMode != 0 {
		n += 1 + sovTypes(uint64(m.DnsMode))
	}
	return n
}

func (m *K8SVipDiscoveryInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PublishChoice != nil {
		n += m.PublishChoice.Size()
	}
	return n
}

func (m *K8SVipDiscoveryInfoType_Disable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Disable != nil {
		l = m.Disable.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *K8SVipDiscoveryInfoType_Publish) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Publish != nil {
		l = m.Publish.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *K8SVipDiscoveryInfoType_PublishFqdns) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PublishFqdns != nil {
		l = m.PublishFqdns.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *K8SVipDiscoveryInfoType_DnsDelegation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DnsDelegation != nil {
		l = m.DnsDelegation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ConsulVipDiscoveryInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PublishChoice != nil {
		n += m.PublishChoice.Size()
	}
	return n
}

func (m *ConsulVipDiscoveryInfoType_Disable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Disable != nil {
		l = m.Disable.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ConsulVipDiscoveryInfoType_Publish) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Publish != nil {
		l = m.Publish.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *K8SDiscoveryType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccessInfo != nil {
		l = m.AccessInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PublishInfo != nil {
		l = m.PublishInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NamespaceMappingChoice != nil {
		n += m.NamespaceMappingChoice.Size()
	}
	return n
}

func (m *K8SDiscoveryType_DefaultAll) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultAll != nil {
		l = m.DefaultAll.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *K8SDiscoveryType_NamespaceMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NamespaceMapping != nil {
		l = m.NamespaceMapping.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ConsulDiscoveryType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccessInfo != nil {
		l = m.AccessInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PublishInfo != nil {
		l = m.PublishInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NamespaceMappingChoice != nil {
		n += m.NamespaceMappingChoice.Size()
	}
	return n
}

func (m *ConsulDiscoveryType_DefaultAll) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultAll != nil {
		l = m.DefaultAll.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ConsulDiscoveryType_NamespaceMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NamespaceMapping != nil {
		l = m.NamespaceMapping.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CbipDiscoveryType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CbipClusters) > 0 {
		for _, e := range m.CbipClusters {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.InternalLbDomain)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.ServerCa) > 0 {
		for _, e := range m.ServerCa {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ThirdPartyDiscoveryType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Applications) > 0 {
		for _, s := range m.Applications {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.SourceCidr) > 0 {
		for _, s := range m.SourceCidr {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.ExpirationTimestamp != nil {
		l = m.ExpirationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CbipCluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.CbipDevices) > 0 {
		for _, e := range m.CbipDevices {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.CbipMgmtIps) > 0 {
		for _, s := range m.CbipMgmtIps {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.AdminCredentials != nil {
		l = m.AdminCredentials.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CbipCertificateAuthority != nil {
		l = m.CbipCertificateAuthority.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VirtualServerFilter != nil {
		l = m.VirtualServerFilter.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NamespaceMappingChoice != nil {
		n += m.NamespaceMappingChoice.Size()
	}
	if m.MgmtPort != nil {
		l = m.MgmtPort.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CbipCluster_DefaultAll) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultAll != nil {
		l = m.DefaultAll.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CbipCluster_NamespaceMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NamespaceMapping != nil {
		l = m.NamespaceMapping.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CbipDeviceConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CbipMgmtIp)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AdminCredentials != nil {
		l = m.AdminCredentials.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CbipCertificateAuthority != nil {
		l = m.CbipCertificateAuthority.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VirtualServerFilter != nil {
		l = m.VirtualServerFilter.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NamespaceMappingChoice != nil {
		n += m.NamespaceMappingChoice.Size()
	}
	return n
}

func (m *CbipDeviceConfig_DefaultAll) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultAll != nil {
		l = m.DefaultAll.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CbipDeviceConfig_NamespaceMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NamespaceMapping != nil {
		l = m.NamespaceMapping.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CbipAdminCredentials) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Password != nil {
		l = m.Password.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ManagementPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Port != 0 {
		n += 1 + sovTypes(uint64(m.Port))
	}
	return n
}

func (m *CbipCertificateAuthority) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerValidationChoice != nil {
		n += m.ServerValidationChoice.Size()
	}
	return n
}

func (m *CbipCertificateAuthority_TrustedCa) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TrustedCa != nil {
		l = m.TrustedCa.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CbipCertificateAuthority_SkipServerVerification) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SkipServerVerification != nil {
		l = m.SkipServerVerification.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VirtualServerFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NameRegex)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DescriptionRegex)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Protocols) > 0 {
		for _, s := range m.Protocols {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.PortRanges)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DiscoverDisabledVirtualServers {
		n += 2
	}
	return n
}

func (m *NamespaceMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *NamespaceMappingItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PartitionRegex)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *K8SNamespaceMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *K8SNamespaceMappingItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NamespaceRegex)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ConsulNamespaceMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ConsulNamespaceMappingItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NamespaceRegex)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.PublishVip != nil {
		l = m.PublishVip.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AccessInfo != nil {
		n += m.AccessInfo.Size()
	}
	if m.DiscoveryChoice != nil {
		n += m.DiscoveryChoice.Size()
	}
	l = len(m.ClusterIdentifier)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ClusterIdentifierChoice != nil {
		n += m.ClusterIdentifierChoice.Size()
	}
	if m.ViewInternal != nil {
		l = m.ViewInternal.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType_K8S) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.K8S != nil {
		l = m.K8S.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_Consul) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Consul != nil {
		l = m.Consul.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DiscoveryK8S) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscoveryK8S != nil {
		l = m.DiscoveryK8S.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DiscoveryConsul) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscoveryConsul != nil {
		l = m.DiscoveryConsul.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_NoClusterId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoClusterId != nil {
		l = m.NoClusterId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_ClusterId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GlobalSpecType_DiscoveryCbip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscoveryCbip != nil {
		l = m.DiscoveryCbip.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DiscoveryThirdParty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscoveryThirdParty != nil {
		l = m.DiscoveryThirdParty.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DiscoveryChoice != nil {
		n += m.DiscoveryChoice.Size()
	}
	if m.ClusterIdentifierChoice != nil {
		n += m.ClusterIdentifierChoice.Size()
	}
	return n
}

func (m *CreateSpecType_DiscoveryK8S) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscoveryK8S != nil {
		l = m.DiscoveryK8S.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DiscoveryConsul) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscoveryConsul != nil {
		l = m.DiscoveryConsul.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_NoClusterId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoClusterId != nil {
		l = m.NoClusterId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_ClusterId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CreateSpecType_DiscoveryCbip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscoveryCbip != nil {
		l = m.DiscoveryCbip.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DiscoveryThirdParty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscoveryThirdParty != nil {
		l = m.DiscoveryThirdParty.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DiscoveryChoice != nil {
		n += m.DiscoveryChoice.Size()
	}
	if m.ClusterIdentifierChoice != nil {
		n += m.ClusterIdentifierChoice.Size()
	}
	return n
}

func (m *ReplaceSpecType_DiscoveryK8S) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscoveryK8S != nil {
		l = m.DiscoveryK8S.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DiscoveryConsul) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscoveryConsul != nil {
		l = m.DiscoveryConsul.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_NoClusterId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoClusterId != nil {
		l = m.NoClusterId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_ClusterId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *ReplaceSpecType_DiscoveryCbip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscoveryCbip != nil {
		l = m.DiscoveryCbip.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DiscoveryThirdParty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscoveryThirdParty != nil {
		l = m.DiscoveryThirdParty.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.PublishVip != nil {
		l = m.PublishVip.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DiscoveryChoice != nil {
		n += m.DiscoveryChoice.Size()
	}
	if m.ClusterIdentifierChoice != nil {
		n += m.ClusterIdentifierChoice.Size()
	}
	return n
}

func (m *GetSpecType_DiscoveryK8S) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscoveryK8S != nil {
		l = m.DiscoveryK8S.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DiscoveryConsul) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscoveryConsul != nil {
		l = m.DiscoveryConsul.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_NoClusterId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoClusterId != nil {
		l = m.NoClusterId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_ClusterId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GetSpecType_DiscoveryCbip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscoveryCbip != nil {
		l = m.DiscoveryCbip.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DiscoveryThirdParty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscoveryThirdParty != nil {
		l = m.DiscoveryThirdParty.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *VerStatusType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForServices := "[]*DiscoveredServiceType{"
	for _, f := range this.Services {
		repeatedStringForServices += strings.Replace(f.String(), "DiscoveredServiceType", "DiscoveredServiceType", 1) + ","
	}
	repeatedStringForServices += "}"
	s := strings.Join([]string{`&VerStatusType{`,
		`Connected:` + fmt.Sprintf("%v", this.Connected) + `,`,
		`Site:` + fmt.Sprintf("%v", this.Site) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Services:` + repeatedStringForServices + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodInfoType{`,
		`PodName:` + fmt.Sprintf("%v", this.PodName) + `,`,
		`Ip:` + fmt.Sprintf("%v", this.Ip) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortInfoType{`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`TargetPort:` + fmt.Sprintf("%v", this.TargetPort) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DiscoveredServiceType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPods := "[]*PodInfoType{"
	for _, f := range this.Pods {
		repeatedStringForPods += strings.Replace(f.String(), "PodInfoType", "PodInfoType", 1) + ","
	}
	repeatedStringForPods += "}"
	repeatedStringForPorts := "[]*PortInfoType{"
	for _, f := range this.Ports {
		repeatedStringForPorts += strings.Replace(f.String(), "PortInfoType", "PortInfoType", 1) + ","
	}
	repeatedStringForPorts += "}"
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForPortMap := make([]uint32, 0, len(this.PortMap))
	for k, _ := range this.PortMap {
		keysForPortMap = append(keysForPortMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForPortMap)
	mapStringForPortMap := "map[uint32]uint32{"
	for _, k := range keysForPortMap {
		mapStringForPortMap += fmt.Sprintf("%v: %v,", k, this.PortMap[k])
	}
	mapStringForPortMap += "}"
	s := strings.Join([]string{`&DiscoveredServiceType{`,
		`ServiceName:` + fmt.Sprintf("%v", this.ServiceName) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`ServiceType:` + fmt.Sprintf("%v", this.ServiceType) + `,`,
		`ClusterIp:` + fmt.Sprintf("%v", this.ClusterIp) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Pods:` + repeatedStringForPods + `,`,
		`PortMap:` + mapStringForPortMap + `,`,
		`Ports:` + repeatedStringForPorts + `,`,
		`ClusterIpv6:` + fmt.Sprintf("%v", this.ClusterIpv6) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TLSClientConfigType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TLSClientConfigType{`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`CertificateUrl:` + strings.Replace(fmt.Sprintf("%v", this.CertificateUrl), "SecretType", "schema.SecretType", 1) + `,`,
		`KeyUrl:` + strings.Replace(fmt.Sprintf("%v", this.KeyUrl), "SecretType", "schema.SecretType", 1) + `,`,
		`CaCertificateUrl:` + strings.Replace(fmt.Sprintf("%v", this.CaCertificateUrl), "SecretType", "schema.SecretType", 1) + `,`,
		`Certificate:` + fmt.Sprintf("%v", this.Certificate) + `,`,
		`TrustedCaUrl:` + fmt.Sprintf("%v", this.TrustedCaUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RestConfigType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RestConfigType{`,
		`ApiServer:` + fmt.Sprintf("%v", this.ApiServer) + `,`,
		`TlsInfo:` + strings.Replace(this.TlsInfo.String(), "TLSClientConfigType", "TLSClientConfigType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SAccessInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SAccessInfo{`,
		`ConfigType:` + fmt.Sprintf("%v", this.ConfigType) + `,`,
		`K8SPodNetworkChoice:` + fmt.Sprintf("%v", this.K8SPodNetworkChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SAccessInfo_KubeconfigUrl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SAccessInfo_KubeconfigUrl{`,
		`KubeconfigUrl:` + strings.Replace(fmt.Sprintf("%v", this.KubeconfigUrl), "SecretType", "schema.SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SAccessInfo_ConnectionInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SAccessInfo_ConnectionInfo{`,
		`ConnectionInfo:` + strings.Replace(fmt.Sprintf("%v", this.ConnectionInfo), "RestConfigType", "RestConfigType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SAccessInfo_InCluster) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SAccessInfo_InCluster{`,
		`InCluster:` + fmt.Sprintf("%v", this.InCluster) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SAccessInfo_Isolated) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SAccessInfo_Isolated{`,
		`Isolated:` + strings.Replace(fmt.Sprintf("%v", this.Isolated), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SAccessInfo_Reachable) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SAccessInfo_Reachable{`,
		`Reachable:` + strings.Replace(fmt.Sprintf("%v", this.Reachable), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsulHttpBasicAuthInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConsulHttpBasicAuthInfoType{`,
		`UserName:` + fmt.Sprintf("%v", this.UserName) + `,`,
		`PasswdUrl:` + strings.Replace(fmt.Sprintf("%v", this.PasswdUrl), "SecretType", "schema.SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsulAccessInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConsulAccessInfo{`,
		`ConnectionInfo:` + strings.Replace(this.ConnectionInfo.String(), "RestConfigType", "RestConfigType", 1) + `,`,
		`Scheme:` + fmt.Sprintf("%v", this.Scheme) + `,`,
		`HttpBasicAuthInfo:` + strings.Replace(this.HttpBasicAuthInfo.String(), "ConsulHttpBasicAuthInfoType", "ConsulHttpBasicAuthInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VipDiscoveryInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VipDiscoveryInfoType{`,
		`PublishVirtualIp:` + fmt.Sprintf("%v", this.PublishVirtualIp) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Subdomain:` + fmt.Sprintf("%v", this.Subdomain) + `,`,
		`DnsMode:` + fmt.Sprintf("%v", this.DnsMode) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SPublishType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SPublishType{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SDelegationType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SDelegationType{`,
		`Subdomain:` + fmt.Sprintf("%v", this.Subdomain) + `,`,
		`DnsMode:` + fmt.Sprintf("%v", this.DnsMode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SVipDiscoveryInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SVipDiscoveryInfoType{`,
		`PublishChoice:` + fmt.Sprintf("%v", this.PublishChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SVipDiscoveryInfoType_Disable) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SVipDiscoveryInfoType_Disable{`,
		`Disable:` + strings.Replace(fmt.Sprintf("%v", this.Disable), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SVipDiscoveryInfoType_Publish) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SVipDiscoveryInfoType_Publish{`,
		`Publish:` + strings.Replace(fmt.Sprintf("%v", this.Publish), "K8SPublishType", "K8SPublishType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SVipDiscoveryInfoType_PublishFqdns) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SVipDiscoveryInfoType_PublishFqdns{`,
		`PublishFqdns:` + strings.Replace(fmt.Sprintf("%v", this.PublishFqdns), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SVipDiscoveryInfoType_DnsDelegation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SVipDiscoveryInfoType_DnsDelegation{`,
		`DnsDelegation:` + strings.Replace(fmt.Sprintf("%v", this.DnsDelegation), "K8SDelegationType", "K8SDelegationType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsulVipDiscoveryInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConsulVipDiscoveryInfoType{`,
		`PublishChoice:` + fmt.Sprintf("%v", this.PublishChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsulVipDiscoveryInfoType_Disable) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConsulVipDiscoveryInfoType_Disable{`,
		`Disable:` + strings.Replace(fmt.Sprintf("%v", this.Disable), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsulVipDiscoveryInfoType_Publish) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConsulVipDiscoveryInfoType_Publish{`,
		`Publish:` + strings.Replace(fmt.Sprintf("%v", this.Publish), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SDiscoveryType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SDiscoveryType{`,
		`AccessInfo:` + strings.Replace(this.AccessInfo.String(), "K8SAccessInfo", "K8SAccessInfo", 1) + `,`,
		`PublishInfo:` + strings.Replace(this.PublishInfo.String(), "K8SVipDiscoveryInfoType", "K8SVipDiscoveryInfoType", 1) + `,`,
		`NamespaceMappingChoice:` + fmt.Sprintf("%v", this.NamespaceMappingChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SDiscoveryType_DefaultAll) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SDiscoveryType_DefaultAll{`,
		`DefaultAll:` + strings.Replace(fmt.Sprintf("%v", this.DefaultAll), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SDiscoveryType_NamespaceMapping) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SDiscoveryType_NamespaceMapping{`,
		`NamespaceMapping:` + strings.Replace(fmt.Sprintf("%v", this.NamespaceMapping), "K8SNamespaceMapping", "K8SNamespaceMapping", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsulDiscoveryType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConsulDiscoveryType{`,
		`AccessInfo:` + strings.Replace(this.AccessInfo.String(), "ConsulAccessInfo", "ConsulAccessInfo", 1) + `,`,
		`PublishInfo:` + strings.Replace(this.PublishInfo.String(), "ConsulVipDiscoveryInfoType", "ConsulVipDiscoveryInfoType", 1) + `,`,
		`NamespaceMappingChoice:` + fmt.Sprintf("%v", this.NamespaceMappingChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsulDiscoveryType_DefaultAll) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConsulDiscoveryType_DefaultAll{`,
		`DefaultAll:` + strings.Replace(fmt.Sprintf("%v", this.DefaultAll), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsulDiscoveryType_NamespaceMapping) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConsulDiscoveryType_NamespaceMapping{`,
		`NamespaceMapping:` + strings.Replace(fmt.Sprintf("%v", this.NamespaceMapping), "ConsulNamespaceMapping", "ConsulNamespaceMapping", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CbipDiscoveryType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCbipClusters := "[]*CbipCluster{"
	for _, f := range this.CbipClusters {
		repeatedStringForCbipClusters += strings.Replace(f.String(), "CbipCluster", "CbipCluster", 1) + ","
	}
	repeatedStringForCbipClusters += "}"
	repeatedStringForServerCa := "[]*ObjectRefType{"
	for _, f := range this.ServerCa {
		repeatedStringForServerCa += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForServerCa += "}"
	s := strings.Join([]string{`&CbipDiscoveryType{`,
		`CbipClusters:` + repeatedStringForCbipClusters + `,`,
		`InternalLbDomain:` + fmt.Sprintf("%v", this.InternalLbDomain) + `,`,
		`ServerCa:` + repeatedStringForServerCa + `,`,
		`}`,
	}, "")
	return s
}
func (this *ThirdPartyDiscoveryType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ThirdPartyDiscoveryType{`,
		`Applications:` + fmt.Sprintf("%v", this.Applications) + `,`,
		`SourceCidr:` + fmt.Sprintf("%v", this.SourceCidr) + `,`,
		`ExpirationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CbipCluster) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCbipDevices := "[]*CbipDeviceConfig{"
	for _, f := range this.CbipDevices {
		repeatedStringForCbipDevices += strings.Replace(f.String(), "CbipDeviceConfig", "CbipDeviceConfig", 1) + ","
	}
	repeatedStringForCbipDevices += "}"
	s := strings.Join([]string{`&CbipCluster{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "MessageMetaType", "schema.MessageMetaType", 1) + `,`,
		`CbipDevices:` + repeatedStringForCbipDevices + `,`,
		`CbipMgmtIps:` + fmt.Sprintf("%v", this.CbipMgmtIps) + `,`,
		`AdminCredentials:` + strings.Replace(this.AdminCredentials.String(), "CbipAdminCredentials", "CbipAdminCredentials", 1) + `,`,
		`CbipCertificateAuthority:` + strings.Replace(this.CbipCertificateAuthority.String(), "CbipCertificateAuthority", "CbipCertificateAuthority", 1) + `,`,
		`VirtualServerFilter:` + strings.Replace(this.VirtualServerFilter.String(), "VirtualServerFilter", "VirtualServerFilter", 1) + `,`,
		`NamespaceMappingChoice:` + fmt.Sprintf("%v", this.NamespaceMappingChoice) + `,`,
		`MgmtPort:` + strings.Replace(this.MgmtPort.String(), "ManagementPort", "ManagementPort", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CbipCluster_DefaultAll) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CbipCluster_DefaultAll{`,
		`DefaultAll:` + strings.Replace(fmt.Sprintf("%v", this.DefaultAll), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CbipCluster_NamespaceMapping) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CbipCluster_NamespaceMapping{`,
		`NamespaceMapping:` + strings.Replace(fmt.Sprintf("%v", this.NamespaceMapping), "NamespaceMapping", "NamespaceMapping", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CbipDeviceConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CbipDeviceConfig{`,
		`CbipMgmtIp:` + fmt.Sprintf("%v", this.CbipMgmtIp) + `,`,
		`AdminCredentials:` + strings.Replace(this.AdminCredentials.String(), "CbipAdminCredentials", "CbipAdminCredentials", 1) + `,`,
		`CbipCertificateAuthority:` + strings.Replace(this.CbipCertificateAuthority.String(), "CbipCertificateAuthority", "CbipCertificateAuthority", 1) + `,`,
		`VirtualServerFilter:` + strings.Replace(this.VirtualServerFilter.String(), "VirtualServerFilter", "VirtualServerFilter", 1) + `,`,
		`NamespaceMappingChoice:` + fmt.Sprintf("%v", this.NamespaceMappingChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CbipDeviceConfig_DefaultAll) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CbipDeviceConfig_DefaultAll{`,
		`DefaultAll:` + strings.Replace(fmt.Sprintf("%v", this.DefaultAll), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CbipDeviceConfig_NamespaceMapping) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CbipDeviceConfig_NamespaceMapping{`,
		`NamespaceMapping:` + strings.Replace(fmt.Sprintf("%v", this.NamespaceMapping), "NamespaceMapping", "NamespaceMapping", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CbipAdminCredentials) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CbipAdminCredentials{`,
		`Username:` + fmt.Sprintf("%v", this.Username) + `,`,
		`Password:` + strings.Replace(fmt.Sprintf("%v", this.Password), "SecretType", "schema.SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ManagementPort) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ManagementPort{`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CbipCertificateAuthority) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CbipCertificateAuthority{`,
		`ServerValidationChoice:` + fmt.Sprintf("%v", this.ServerValidationChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CbipCertificateAuthority_TrustedCa) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CbipCertificateAuthority_TrustedCa{`,
		`TrustedCa:` + strings.Replace(fmt.Sprintf("%v", this.TrustedCa), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CbipCertificateAuthority_SkipServerVerification) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CbipCertificateAuthority_SkipServerVerification{`,
		`SkipServerVerification:` + strings.Replace(fmt.Sprintf("%v", this.SkipServerVerification), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VirtualServerFilter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VirtualServerFilter{`,
		`NameRegex:` + fmt.Sprintf("%v", this.NameRegex) + `,`,
		`DescriptionRegex:` + fmt.Sprintf("%v", this.DescriptionRegex) + `,`,
		`Protocols:` + fmt.Sprintf("%v", this.Protocols) + `,`,
		`PortRanges:` + fmt.Sprintf("%v", this.PortRanges) + `,`,
		`DiscoverDisabledVirtualServers:` + fmt.Sprintf("%v", this.DiscoverDisabledVirtualServers) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NamespaceMapping) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*NamespaceMappingItem{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "NamespaceMappingItem", "NamespaceMappingItem", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&NamespaceMapping{`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *NamespaceMappingItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NamespaceMappingItem{`,
		`PartitionRegex:` + fmt.Sprintf("%v", this.PartitionRegex) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SNamespaceMapping) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*K8SNamespaceMappingItem{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "K8SNamespaceMappingItem", "K8SNamespaceMappingItem", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&K8SNamespaceMapping{`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SNamespaceMappingItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SNamespaceMappingItem{`,
		`NamespaceRegex:` + fmt.Sprintf("%v", this.NamespaceRegex) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsulNamespaceMapping) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*ConsulNamespaceMappingItem{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "ConsulNamespaceMappingItem", "ConsulNamespaceMappingItem", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&ConsulNamespaceMapping{`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsulNamespaceMappingItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConsulNamespaceMappingItem{`,
		`NamespaceRegex:` + fmt.Sprintf("%v", this.NamespaceRegex) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Where:` + strings.Replace(fmt.Sprintf("%v", this.Where), "NetworkSiteRefSelector", "schema.NetworkSiteRefSelector", 1) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`PublishVip:` + strings.Replace(this.PublishVip.String(), "VipDiscoveryInfoType", "VipDiscoveryInfoType", 1) + `,`,
		`AccessInfo:` + fmt.Sprintf("%v", this.AccessInfo) + `,`,
		`DiscoveryChoice:` + fmt.Sprintf("%v", this.DiscoveryChoice) + `,`,
		`ClusterIdentifier:` + fmt.Sprintf("%v", this.ClusterIdentifier) + `,`,
		`ClusterIdentifierChoice:` + fmt.Sprintf("%v", this.ClusterIdentifierChoice) + `,`,
		`ViewInternal:` + strings.Replace(fmt.Sprintf("%v", this.ViewInternal), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_K8S) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_K8S{`,
		`K8S:` + strings.Replace(fmt.Sprintf("%v", this.K8S), "K8SAccessInfo", "K8SAccessInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Consul) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Consul{`,
		`Consul:` + strings.Replace(fmt.Sprintf("%v", this.Consul), "ConsulAccessInfo", "ConsulAccessInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DiscoveryK8S) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DiscoveryK8S{`,
		`DiscoveryK8S:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryK8S), "K8SDiscoveryType", "K8SDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DiscoveryConsul) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DiscoveryConsul{`,
		`DiscoveryConsul:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryConsul), "ConsulDiscoveryType", "ConsulDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_NoClusterId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_NoClusterId{`,
		`NoClusterId:` + strings.Replace(fmt.Sprintf("%v", this.NoClusterId), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ClusterId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ClusterId{`,
		`ClusterId:` + fmt.Sprintf("%v", this.ClusterId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DiscoveryCbip) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DiscoveryCbip{`,
		`DiscoveryCbip:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryCbip), "CbipDiscoveryType", "CbipDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DiscoveryThirdParty) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DiscoveryThirdParty{`,
		`DiscoveryThirdParty:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryThirdParty), "ThirdPartyDiscoveryType", "ThirdPartyDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Where:` + strings.Replace(fmt.Sprintf("%v", this.Where), "NetworkSiteRefSelector", "schema.NetworkSiteRefSelector", 1) + `,`,
		`DiscoveryChoice:` + fmt.Sprintf("%v", this.DiscoveryChoice) + `,`,
		`ClusterIdentifierChoice:` + fmt.Sprintf("%v", this.ClusterIdentifierChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DiscoveryK8S) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DiscoveryK8S{`,
		`DiscoveryK8S:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryK8S), "K8SDiscoveryType", "K8SDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DiscoveryConsul) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DiscoveryConsul{`,
		`DiscoveryConsul:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryConsul), "ConsulDiscoveryType", "ConsulDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_NoClusterId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_NoClusterId{`,
		`NoClusterId:` + strings.Replace(fmt.Sprintf("%v", this.NoClusterId), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ClusterId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ClusterId{`,
		`ClusterId:` + fmt.Sprintf("%v", this.ClusterId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DiscoveryCbip) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DiscoveryCbip{`,
		`DiscoveryCbip:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryCbip), "CbipDiscoveryType", "CbipDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DiscoveryThirdParty) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DiscoveryThirdParty{`,
		`DiscoveryThirdParty:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryThirdParty), "ThirdPartyDiscoveryType", "ThirdPartyDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Where:` + strings.Replace(fmt.Sprintf("%v", this.Where), "NetworkSiteRefSelector", "schema.NetworkSiteRefSelector", 1) + `,`,
		`DiscoveryChoice:` + fmt.Sprintf("%v", this.DiscoveryChoice) + `,`,
		`ClusterIdentifierChoice:` + fmt.Sprintf("%v", this.ClusterIdentifierChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DiscoveryK8S) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DiscoveryK8S{`,
		`DiscoveryK8S:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryK8S), "K8SDiscoveryType", "K8SDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DiscoveryConsul) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DiscoveryConsul{`,
		`DiscoveryConsul:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryConsul), "ConsulDiscoveryType", "ConsulDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_NoClusterId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_NoClusterId{`,
		`NoClusterId:` + strings.Replace(fmt.Sprintf("%v", this.NoClusterId), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ClusterId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ClusterId{`,
		`ClusterId:` + fmt.Sprintf("%v", this.ClusterId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DiscoveryCbip) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DiscoveryCbip{`,
		`DiscoveryCbip:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryCbip), "CbipDiscoveryType", "CbipDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DiscoveryThirdParty) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DiscoveryThirdParty{`,
		`DiscoveryThirdParty:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryThirdParty), "ThirdPartyDiscoveryType", "ThirdPartyDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`Where:` + strings.Replace(fmt.Sprintf("%v", this.Where), "NetworkSiteRefSelector", "schema.NetworkSiteRefSelector", 1) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`PublishVip:` + strings.Replace(this.PublishVip.String(), "VipDiscoveryInfoType", "VipDiscoveryInfoType", 1) + `,`,
		`DiscoveryChoice:` + fmt.Sprintf("%v", this.DiscoveryChoice) + `,`,
		`ClusterIdentifierChoice:` + fmt.Sprintf("%v", this.ClusterIdentifierChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DiscoveryK8S) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DiscoveryK8S{`,
		`DiscoveryK8S:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryK8S), "K8SDiscoveryType", "K8SDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DiscoveryConsul) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DiscoveryConsul{`,
		`DiscoveryConsul:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryConsul), "ConsulDiscoveryType", "ConsulDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_NoClusterId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_NoClusterId{`,
		`NoClusterId:` + strings.Replace(fmt.Sprintf("%v", this.NoClusterId), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ClusterId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ClusterId{`,
		`ClusterId:` + fmt.Sprintf("%v", this.ClusterId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DiscoveryCbip) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DiscoveryCbip{`,
		`DiscoveryCbip:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryCbip), "CbipDiscoveryType", "CbipDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DiscoveryThirdParty) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DiscoveryThirdParty{`,
		`DiscoveryThirdParty:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryThirdParty), "ThirdPartyDiscoveryType", "ThirdPartyDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *VerStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Connected = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= schema.DiscoveryType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Services = append(m.Services, &DiscoveredServiceType{})
			if err := m.Services[len(m.Services)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPort", wireType)
			}
			m.TargetPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscoveredServiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiscoveredServiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiscoveredServiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pods = append(m.Pods, &PodInfoType{})
			if err := m.Pods[len(m.Pods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMap == nil {
				m.PortMap = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PortMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &PortInfoType{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterIpv6", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterIpv6 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSClientConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TLSClientConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TLSClientConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateUrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CertificateUrl == nil {
				m.CertificateUrl = &schema.SecretType{}
			}
			if err := m.CertificateUrl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyUrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyUrl == nil {
				m.KeyUrl = &schema.SecretType{}
			}
			if err := m.KeyUrl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaCertificateUrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CaCertificateUrl == nil {
				m.CaCertificateUrl = &schema.SecretType{}
			}
			if err := m.CaCertificateUrl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certificate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Certificate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCaUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedCaUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiServer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiServer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsInfo == nil {
				m.TlsInfo = &TLSClientConfigType{}
			}
			if err := m.TlsInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SAccessInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8SAccessInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8SAccessInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubeconfigUrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.SecretType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConfigType = &K8SAccessInfo_KubeconfigUrl{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RestConfigType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConfigType = &K8SAccessInfo_ConnectionInfo{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InCluster", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ConfigType = &K8SAccessInfo_InCluster{b}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isolated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.K8SPodNetworkChoice = &K8SAccessInfo_Isolated{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reachable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.K8SPodNetworkChoice = &K8SAccessInfo_Reachable{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsulHttpBasicAuthInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsulHttpBasicAuthInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsulHttpBasicAuthInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PasswdUrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PasswdUrl == nil {
				m.PasswdUrl = &schema.SecretType{}
			}
			if err := m.PasswdUrl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsulAccessInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsulAccessInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsulAccessInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConnectionInfo == nil {
				m.ConnectionInfo = &RestConfigType{}
			}
			if err := m.ConnectionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			m.Scheme = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scheme |= SchemeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpBasicAuthInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpBasicAuthInfo == nil {
				m.HttpBasicAuthInfo = &ConsulHttpBasicAuthInfoType{}
			}
			if err := m.HttpBasicAuthInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VipDiscoveryInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VipDiscoveryInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VipDiscoveryInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishVirtualIp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PublishVirtualIp = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= VirtualIPDiscoveryType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subdomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subdomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsMode", wireType)
			}
			m.DnsMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DnsMode |= K8SDNSMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SPublishType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8SPublishType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8SPublishType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SDelegationType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8SDelegationType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8SDelegationType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subdomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subdomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsMode", wireType)
			}
			m.DnsMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DnsMode |= K8SDNSMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SVipDiscoveryInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8SVipDiscoveryInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8SVipDiscoveryInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PublishChoice = &K8SVipDiscoveryInfoType_Disable{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publish", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &K8SPublishType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PublishChoice = &K8SVipDiscoveryInfoType_Publish{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishFqdns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PublishChoice = &K8SVipDiscoveryInfoType_PublishFqdns{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsDelegation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &K8SDelegationType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PublishChoice = &K8SVipDiscoveryInfoType_DnsDelegation{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsulVipDiscoveryInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsulVipDiscoveryInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsulVipDiscoveryInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PublishChoice = &ConsulVipDiscoveryInfoType_Disable{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publish", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PublishChoice = &ConsulVipDiscoveryInfoType_Publish{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SDiscoveryType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8SDiscoveryType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8SDiscoveryType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessInfo == nil {
				m.AccessInfo = &K8SAccessInfo{}
			}
			if err := m.AccessInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublishInfo == nil {
				m.PublishInfo = &K8SVipDiscoveryInfoType{}
			}
			if err := m.PublishInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultAll", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NamespaceMappingChoice = &K8SDiscoveryType_DefaultAll{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &K8SNamespaceMapping{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NamespaceMappingChoice = &K8SDiscoveryType_NamespaceMapping{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsulDiscoveryType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsulDiscoveryType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsulDiscoveryType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessInfo == nil {
				m.AccessInfo = &ConsulAccessInfo{}
			}
			if err := m.AccessInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublishInfo == nil {
				m.PublishInfo = &ConsulVipDiscoveryInfoType{}
			}
			if err := m.PublishInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultAll", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NamespaceMappingChoice = &ConsulDiscoveryType_DefaultAll{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConsulNamespaceMapping{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NamespaceMappingChoice = &ConsulDiscoveryType_NamespaceMapping{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CbipDiscoveryType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CbipDiscoveryType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CbipDiscoveryType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CbipClusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CbipClusters = append(m.CbipClusters, &CbipCluster{})
			if err := m.CbipClusters[len(m.CbipClusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalLbDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InternalLbDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerCa", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerCa = append(m.ServerCa, &schema.ObjectRefType{})
			if err := m.ServerCa[len(m.ServerCa)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThirdPartyDiscoveryType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThirdPartyDiscoveryType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThirdPartyDiscoveryType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applications", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Applications = append(m.Applications, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceCidr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceCidr = append(m.SourceCidr, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpirationTimestamp == nil {
				m.ExpirationTimestamp = &types.Timestamp{}
			}
			if err := m.ExpirationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CbipCluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CbipCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CbipCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &schema.MessageMetaType{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CbipDevices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CbipDevices = append(m.CbipDevices, &CbipDeviceConfig{})
			if err := m.CbipDevices[len(m.CbipDevices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CbipMgmtIps", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CbipMgmtIps = append(m.CbipMgmtIps, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminCredentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdminCredentials == nil {
				m.AdminCredentials = &CbipAdminCredentials{}
			}
			if err := m.AdminCredentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CbipCertificateAuthority", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CbipCertificateAuthority == nil {
				m.CbipCertificateAuthority = &CbipCertificateAuthority{}
			}
			if err := m.CbipCertificateAuthority.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualServerFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualServerFilter == nil {
				m.VirtualServerFilter = &VirtualServerFilter{}
			}
			if err := m.VirtualServerFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultAll", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NamespaceMappingChoice = &CbipCluster_DefaultAll{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NamespaceMapping{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NamespaceMappingChoice = &CbipCluster_NamespaceMapping{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtPort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MgmtPort == nil {
				m.MgmtPort = &ManagementPort{}
			}
			if err := m.MgmtPort.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CbipDeviceConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CbipDeviceConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CbipDeviceConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CbipMgmtIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CbipMgmtIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminCredentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdminCredentials == nil {
				m.AdminCredentials = &CbipAdminCredentials{}
			}
			if err := m.AdminCredentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CbipCertificateAuthority", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CbipCertificateAuthority == nil {
				m.CbipCertificateAuthority = &CbipCertificateAuthority{}
			}
			if err := m.CbipCertificateAuthority.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualServerFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualServerFilter == nil {
				m.VirtualServerFilter = &VirtualServerFilter{}
			}
			if err := m.VirtualServerFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultAll", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NamespaceMappingChoice = &CbipDeviceConfig_DefaultAll{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NamespaceMapping{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NamespaceMappingChoice = &CbipDeviceConfig_NamespaceMapping{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CbipAdminCredentials) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CbipAdminCredentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CbipAdminCredentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Password == nil {
				m.Password = &schema.SecretType{}
			}
			if err := m.Password.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ManagementPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ManagementPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ManagementPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CbipCertificateAuthority) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CbipCertificateAuthority: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CbipCertificateAuthority: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCa", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerValidationChoice = &CbipCertificateAuthority_TrustedCa{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipServerVerification", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerValidationChoice = &CbipCertificateAuthority_SkipServerVerification{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualServerFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualServerFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualServerFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameRegex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameRegex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptionRegex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DescriptionRegex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocols", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocols = append(m.Protocols, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortRanges = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoverDisabledVirtualServers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DiscoverDisabledVirtualServers = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespaceMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespaceMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespaceMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &NamespaceMappingItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespaceMappingItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespaceMappingItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespaceMappingItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionRegex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionRegex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SNamespaceMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8SNamespaceMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8SNamespaceMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &K8SNamespaceMappingItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SNamespaceMappingItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8SNamespaceMappingItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8SNamespaceMappingItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceRegex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamespaceRegex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsulNamespaceMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsulNamespaceMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsulNamespaceMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ConsulNamespaceMappingItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsulNamespaceMappingItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsulNamespaceMappingItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsulNamespaceMappingItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceRegex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamespaceRegex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &schema.NetworkSiteRefSelector{}
			}
			if err := m.Where.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= schema.DiscoveryType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishVip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublishVip == nil {
				m.PublishVip = &VipDiscoveryInfoType{}
			}
			if err := m.PublishVip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8S", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &K8SAccessInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AccessInfo = &GlobalSpecType_K8S{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Consul", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConsulAccessInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AccessInfo = &GlobalSpecType_Consul{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryK8S", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &K8SDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &GlobalSpecType_DiscoveryK8S{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryConsul", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConsulDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &GlobalSpecType_DiscoveryConsul{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterIdentifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterIdentifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoClusterId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClusterIdentifierChoice = &GlobalSpecType_NoClusterId{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterIdentifierChoice = &GlobalSpecType_ClusterId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryCbip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CbipDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &GlobalSpecType_DiscoveryCbip{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryThirdParty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ThirdPartyDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &GlobalSpecType_DiscoveryThirdParty{v}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewInternal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ViewInternal == nil {
				m.ViewInternal = &views.ObjectRefType{}
			}
			if err := m.ViewInternal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &schema.NetworkSiteRefSelector{}
			}
			if err := m.Where.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryK8S", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &K8SDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &CreateSpecType_DiscoveryK8S{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryConsul", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConsulDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &CreateSpecType_DiscoveryConsul{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoClusterId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClusterIdentifierChoice = &CreateSpecType_NoClusterId{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterIdentifierChoice = &CreateSpecType_ClusterId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryCbip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CbipDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &CreateSpecType_DiscoveryCbip{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryThirdParty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ThirdPartyDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &CreateSpecType_DiscoveryThirdParty{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &schema.NetworkSiteRefSelector{}
			}
			if err := m.Where.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryK8S", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &K8SDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &ReplaceSpecType_DiscoveryK8S{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryConsul", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConsulDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &ReplaceSpecType_DiscoveryConsul{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoClusterId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClusterIdentifierChoice = &ReplaceSpecType_NoClusterId{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterIdentifierChoice = &ReplaceSpecType_ClusterId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryCbip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CbipDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &ReplaceSpecType_DiscoveryCbip{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryThirdParty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ThirdPartyDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &ReplaceSpecType_DiscoveryThirdParty{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &schema.NetworkSiteRefSelector{}
			}
			if err := m.Where.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= schema.DiscoveryType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishVip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublishVip == nil {
				m.PublishVip = &VipDiscoveryInfoType{}
			}
			if err := m.PublishVip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryK8S", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &K8SDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &GetSpecType_DiscoveryK8S{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryConsul", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConsulDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &GetSpecType_DiscoveryConsul{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoClusterId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClusterIdentifierChoice = &GetSpecType_NoClusterId{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterIdentifierChoice = &GetSpecType_ClusterId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryCbip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CbipDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &GetSpecType_DiscoveryCbip{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryThirdParty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ThirdPartyDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &GetSpecType_DiscoveryThirdParty{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
