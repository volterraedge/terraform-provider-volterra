// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/discovery/types.proto

package discovery

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// REST scheme
//
// x-displayName: "Scheme"
// Scheme to use when doing REST API to discovery server
type SchemeType int32

const (
	// x-displayName: "HTTP"
	// http:// Scheme
	HTTP SchemeType = 0
	// x-displayName: "HTTPS"
	// https:// Scheme
	HTTPS SchemeType = 1
)

var SchemeType_name = map[int32]string{
	0: "HTTP",
	1: "HTTPS",
}

var SchemeType_value = map[string]int32{
	"HTTP":  0,
	"HTTPS": 1,
}

func (SchemeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{0}
}

// VirtualIPDiscoveryType
//
// x-displayName: "Virtual IP Discovery"
// How is the Virtual IP discovery done
// Two modes are possible
//
//	DNS_DELEGATION: Program DNS delegation for a sub-domain in external K8s cluster
//	PUBLISH_SERVICE: Create/Register a service in external K8s/consul cluster
type VirtualIPDiscoveryType int32

const (
	// x-displayName: "DNS Delegation"
	// DNS sub domain is delegated to volterra site.
	DNS_DELEGATION VirtualIPDiscoveryType = 0
	// x-displayName: "Publish"
	// Name to VIP mapping is published in external discovery service
	PUBLISH_SERVICE VirtualIPDiscoveryType = 1
)

var VirtualIPDiscoveryType_name = map[int32]string{
	0: "DNS_DELEGATION",
	1: "PUBLISH_SERVICE",
}

var VirtualIPDiscoveryType_value = map[string]int32{
	"DNS_DELEGATION":  0,
	"PUBLISH_SERVICE": 1,
}

func (VirtualIPDiscoveryType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{1}
}

// K8SDNSMode
//
// x-displayName: "DNS Mode"
// Two modes are possible
type K8SDNSMode int32

const (
	// x-displayName: "Core DNS"
	// CoreDNS: Whether external K8s cluster is running core-dns
	CORE_DNS K8SDNSMode = 0
	// x-displayName: "K8s DNS"
	// KubeDNS: External K8s cluster is running kube-dns
	KUBE_DNS K8SDNSMode = 1
)

var K8SDNSMode_name = map[int32]string{
	0: "CORE_DNS",
	1: "KUBE_DNS",
}

var K8SDNSMode_value = map[string]int32{
	"CORE_DNS": 0,
	"KUBE_DNS": 1,
}

func (K8SDNSMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{2}
}

// VER status for Discovery
//
// x-displayName: "VER Status"
// This VER status is per site on which discovery is happening and it lists all services that site has discovered.
type VerStatusType struct {
	// Connection status
	//
	// x-displayName: "Connection Status"
	// Indicates connection status to external discovery service
	Connected bool `protobuf:"varint,1,opt,name=connected,proto3" json:"connected,omitempty"`
	// Origin site
	//
	// x-displayName: "Site"
	// Name of the site that reported this status
	Site string `protobuf:"bytes,2,opt,name=site,proto3" json:"site,omitempty"`
	// Type of discovery
	//
	// x-displayName: "External Discovery"
	// Service discovery type. Possible values are K8S and Consul
	Type schema.DiscoveryType `protobuf:"varint,3,opt,name=type,proto3,enum=ves.io.schema.DiscoveryType" json:"type,omitempty"`
	// Discovered Services
	//
	// x-displayName: "Discovered Services"
	// List of discovered services
	Services []*DiscoveredServiceType `protobuf:"bytes,4,rep,name=services,proto3" json:"services,omitempty"`
}

func (m *VerStatusType) Reset()      { *m = VerStatusType{} }
func (*VerStatusType) ProtoMessage() {}
func (*VerStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{0}
}
func (m *VerStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VerStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerStatusType.Merge(m, src)
}
func (m *VerStatusType) XXX_Size() int {
	return m.Size()
}
func (m *VerStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_VerStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_VerStatusType proto.InternalMessageInfo

func (m *VerStatusType) GetConnected() bool {
	if m != nil {
		return m.Connected
	}
	return false
}

func (m *VerStatusType) GetSite() string {
	if m != nil {
		return m.Site
	}
	return ""
}

func (m *VerStatusType) GetType() schema.DiscoveryType {
	if m != nil {
		return m.Type
	}
	return schema.INVALID_DISCOVERY
}

func (m *VerStatusType) GetServices() []*DiscoveredServiceType {
	if m != nil {
		return m.Services
	}
	return nil
}

// Pod info
//
// x-displayName: "POD"
// Information about POD providing the service
type PodInfoType struct {
	// POD name
	//
	// x-example: "mypod-nk8wr"
	// x-displayName: "Name"
	// Name of the Pod
	PodName string `protobuf:"bytes,1,opt,name=pod_name,json=podName,proto3" json:"pod_name,omitempty"`
	// IP Address
	//
	// x-displayName: "IP"
	// x-example: "192.1.2.3"
	// IP Address of the POD
	Ip string `protobuf:"bytes,2,opt,name=ip,proto3" json:"ip,omitempty"`
}

func (m *PodInfoType) Reset()      { *m = PodInfoType{} }
func (*PodInfoType) ProtoMessage() {}
func (*PodInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{1}
}
func (m *PodInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PodInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodInfoType.Merge(m, src)
}
func (m *PodInfoType) XXX_Size() int {
	return m.Size()
}
func (m *PodInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_PodInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_PodInfoType proto.InternalMessageInfo

func (m *PodInfoType) GetPodName() string {
	if m != nil {
		return m.PodName
	}
	return ""
}

func (m *PodInfoType) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

// Port information
//
// x-displayName: "Port details"
// Information about port and protocol on which the service is provided
type PortInfoType struct {
	// Port
	//
	// x-displayName: "Port number"
	// x-required
	// x-example: "8080"
	// Port number on which the service is exposed
	Port uint32 `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty"`
	// Protocol
	//
	// x-displayName: "Protocol"
	// x-required
	// x-example: "TCP"
	// Protocol on which the service is exposed
	Protocol string `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// Target Port
	//
	// x-displayName: "Target Port number"
	// x-required
	// x-example: "8081"
	// Port on which the pods targeted by the service can be reached.
	// TargetPort of Kubenetes service when its type is ClusterIP.
	// NodePort of Kubernetes service when its type is NodePort.
	TargetPort uint32 `protobuf:"varint,3,opt,name=target_port,json=targetPort,proto3" json:"target_port,omitempty"`
}

func (m *PortInfoType) Reset()      { *m = PortInfoType{} }
func (*PortInfoType) ProtoMessage() {}
func (*PortInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{2}
}
func (m *PortInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PortInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortInfoType.Merge(m, src)
}
func (m *PortInfoType) XXX_Size() int {
	return m.Size()
}
func (m *PortInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_PortInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_PortInfoType proto.InternalMessageInfo

func (m *PortInfoType) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *PortInfoType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *PortInfoType) GetTargetPort() uint32 {
	if m != nil {
		return m.TargetPort
	}
	return 0
}

// Discovered Service
//
// x-displayName: "Service"
// Details of each Discovered Service
type DiscoveredServiceType struct {
	// Service name
	//
	// x-displayName: "Service"
	// x-example: "myservice"
	// Name of the discovered service
	ServiceName string `protobuf:"bytes,1,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "mynamespace"
	// Namespace of the discovered service
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Service Type
	//
	// x-displayName: "Type"
	// x-example: "NodePort"
	// Type of discovered service. Examples include "ClusterIP", "NodePort" etc
	ServiceType string `protobuf:"bytes,3,opt,name=service_type,json=serviceType,proto3" json:"service_type,omitempty"`
	// Service IP
	//
	// x-displayName: "IP"
	// x-example: "192.1.2.3"
	// IP Address of the service
	ClusterIp string `protobuf:"bytes,4,opt,name=cluster_ip,json=clusterIp,proto3" json:"cluster_ip,omitempty"`
	// Service labels
	//
	// x-displayName: "Labels"
	// Key value pairs defined as labels for the service
	Labels map[string]string `protobuf:"bytes,5,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// POD list
	//
	// x-displayName: "PODs"
	// List of pod-name to IP address mappings for the service
	Pods []*PodInfoType `protobuf:"bytes,6,rep,name=pods,proto3" json:"pods,omitempty"`
	// Port mapping
	//
	// x-displayName: "Port Mapping"
	// port number to target port mapping for ClusterIP service
	// port number to node-port mapping for NodePort service
	PortMap map[uint32]uint32 `protobuf:"bytes,7,rep,name=port_map,json=portMap,proto3" json:"port_map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"` // Deprecated: Do not use.
	// Port list
	//
	// x-displayName: "Ports"
	// List of ports along with protocol on which the service is exposed.
	Ports []*PortInfoType `protobuf:"bytes,8,rep,name=ports,proto3" json:"ports,omitempty"`
}

func (m *DiscoveredServiceType) Reset()      { *m = DiscoveredServiceType{} }
func (*DiscoveredServiceType) ProtoMessage() {}
func (*DiscoveredServiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{3}
}
func (m *DiscoveredServiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiscoveredServiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DiscoveredServiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiscoveredServiceType.Merge(m, src)
}
func (m *DiscoveredServiceType) XXX_Size() int {
	return m.Size()
}
func (m *DiscoveredServiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_DiscoveredServiceType.DiscardUnknown(m)
}

var xxx_messageInfo_DiscoveredServiceType proto.InternalMessageInfo

func (m *DiscoveredServiceType) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *DiscoveredServiceType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *DiscoveredServiceType) GetServiceType() string {
	if m != nil {
		return m.ServiceType
	}
	return ""
}

func (m *DiscoveredServiceType) GetClusterIp() string {
	if m != nil {
		return m.ClusterIp
	}
	return ""
}

func (m *DiscoveredServiceType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *DiscoveredServiceType) GetPods() []*PodInfoType {
	if m != nil {
		return m.Pods
	}
	return nil
}

// Deprecated: Do not use.
func (m *DiscoveredServiceType) GetPortMap() map[uint32]uint32 {
	if m != nil {
		return m.PortMap
	}
	return nil
}

func (m *DiscoveredServiceType) GetPorts() []*PortInfoType {
	if m != nil {
		return m.Ports
	}
	return nil
}

// TLS config
//
// x-displayName: "Client TLS Config"
// TLS config for client of discovery service
type TLSClientConfigType struct {
	// Server Name
	//
	// x-displayName: "SNI name"
	// x-example: "k8s.acme.com"
	// ServerName is passed to the server for SNI and is used in the client to check server
	// ceritificates against. If ServerName is empty, the hostname used to contact the
	// server is used
	ServerName string `protobuf:"bytes,1,opt,name=server_name,json=serverName,proto3" json:"server_name,omitempty"`
	// Client credentials
	//
	// x-displayName: "Client Credentials"
	// F5XC Secret. URL to fetch the client certificate file
	CertificateUrl *schema.SecretType `protobuf:"bytes,2,opt,name=certificate_url,json=certificateUrl,proto3" json:"certificate_url,omitempty"` // Deprecated: Do not use.
	// The TLS certificate URL.
	//
	// x-displayName: "Client Certificate"
	// x-example: "value"
	// Client  certificate is PEM-encoded certificate or certificate-chain.
	Certificate string `protobuf:"bytes,5,opt,name=certificate,proto3" json:"certificate,omitempty"`
	// Private Key
	//
	// x-displayName: "Client Private Key"
	// Client private key file containing data in PEM format including the PEM headers.
	// The data in this key file has to match accompanying certificate.
	// The data may be optionally secured using BlindFold.
	KeyUrl *schema.SecretType `protobuf:"bytes,3,opt,name=key_url,json=keyUrl,proto3" json:"key_url,omitempty"`
	// Server CA certificates
	//
	// x-displayName: "Server CA Certificates"
	// F5XC Secret. URL to fetch the server CA certificate file
	CaCertificateUrl *schema.SecretType `protobuf:"bytes,4,opt,name=ca_certificate_url,json=caCertificateUrl,proto3" json:"ca_certificate_url,omitempty"` // Deprecated: Do not use.
	// Server CA certificates
	//
	// x-displayName: "Server CA Certificates"
	// x-example: "value"
	// The URL or value for trusted Server CA certificate or certificate chain
	// Certificates in PEM format including the PEM headers.
	TrustedCaUrl string `protobuf:"bytes,6,opt,name=trusted_ca_url,json=trustedCaUrl,proto3" json:"trusted_ca_url,omitempty"`
}

func (m *TLSClientConfigType) Reset()      { *m = TLSClientConfigType{} }
func (*TLSClientConfigType) ProtoMessage() {}
func (*TLSClientConfigType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{4}
}
func (m *TLSClientConfigType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLSClientConfigType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TLSClientConfigType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSClientConfigType.Merge(m, src)
}
func (m *TLSClientConfigType) XXX_Size() int {
	return m.Size()
}
func (m *TLSClientConfigType) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSClientConfigType.DiscardUnknown(m)
}

var xxx_messageInfo_TLSClientConfigType proto.InternalMessageInfo

func (m *TLSClientConfigType) GetServerName() string {
	if m != nil {
		return m.ServerName
	}
	return ""
}

// Deprecated: Do not use.
func (m *TLSClientConfigType) GetCertificateUrl() *schema.SecretType {
	if m != nil {
		return m.CertificateUrl
	}
	return nil
}

func (m *TLSClientConfigType) GetCertificate() string {
	if m != nil {
		return m.Certificate
	}
	return ""
}

func (m *TLSClientConfigType) GetKeyUrl() *schema.SecretType {
	if m != nil {
		return m.KeyUrl
	}
	return nil
}

// Deprecated: Do not use.
func (m *TLSClientConfigType) GetCaCertificateUrl() *schema.SecretType {
	if m != nil {
		return m.CaCertificateUrl
	}
	return nil
}

func (m *TLSClientConfigType) GetTrustedCaUrl() string {
	if m != nil {
		return m.TrustedCaUrl
	}
	return ""
}

// REST API config
//
// x-displayName: "REST API Config"
// Configuration details to access discovery service rest API.
type RestConfigType struct {
	// Discovery Service API server
	//
	// x-displayName: "API Server and Port"
	// x-required
	// x-example: "api.acme.com:4430"
	// API server must be a fully qualified domain string and port specified as host:port pair
	ApiServer string `protobuf:"bytes,1,opt,name=api_server,json=apiServer,proto3" json:"api_server,omitempty"`
	// TLS parameters
	//
	// x-displayName: "TLS Parameters"
	// TLS settings to enable transport layer security
	TlsInfo *TLSClientConfigType `protobuf:"bytes,2,opt,name=tls_info,json=tlsInfo,proto3" json:"tls_info,omitempty"`
}

func (m *RestConfigType) Reset()      { *m = RestConfigType{} }
func (*RestConfigType) ProtoMessage() {}
func (*RestConfigType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{5}
}
func (m *RestConfigType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestConfigType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RestConfigType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestConfigType.Merge(m, src)
}
func (m *RestConfigType) XXX_Size() int {
	return m.Size()
}
func (m *RestConfigType) XXX_DiscardUnknown() {
	xxx_messageInfo_RestConfigType.DiscardUnknown(m)
}

var xxx_messageInfo_RestConfigType proto.InternalMessageInfo

func (m *RestConfigType) GetApiServer() string {
	if m != nil {
		return m.ApiServer
	}
	return ""
}

func (m *RestConfigType) GetTlsInfo() *TLSClientConfigType {
	if m != nil {
		return m.TlsInfo
	}
	return nil
}

// K8S access info
//
// x-displayName: "K8s API Server"
// K8S API server access
type K8SAccessInfo struct {
	// Oneof for K8s config
	//
	// x-displayName: "Select Kubernetes Credentials"
	// x-required
	// Kubernetes credentials can be kubeconfig or TLS param
	//
	// Types that are valid to be assigned to ConfigType:
	//	*K8SAccessInfo_KubeconfigUrl
	//	*K8SAccessInfo_ConnectionInfo
	//	*K8SAccessInfo_InCluster
	ConfigType isK8SAccessInfo_ConfigType `protobuf_oneof:"config_type"`
	// Kubernetes Network reachability
	//
	// x-displayName: "Kubernetes POD network reachability"
	// x-required
	// Specify which IP addresses to discover from Kubernetes services based
	// on reachability of Kubernetes POD
	//
	// Types that are valid to be assigned to K8SPodNetworkChoice:
	//	*K8SAccessInfo_Isolated
	//	*K8SAccessInfo_Reachable
	K8SPodNetworkChoice isK8SAccessInfo_K8SPodNetworkChoice `protobuf_oneof:"k8s_pod_network_choice"`
}

func (m *K8SAccessInfo) Reset()      { *m = K8SAccessInfo{} }
func (*K8SAccessInfo) ProtoMessage() {}
func (*K8SAccessInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{6}
}
func (m *K8SAccessInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *K8SAccessInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *K8SAccessInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K8SAccessInfo.Merge(m, src)
}
func (m *K8SAccessInfo) XXX_Size() int {
	return m.Size()
}
func (m *K8SAccessInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_K8SAccessInfo.DiscardUnknown(m)
}

var xxx_messageInfo_K8SAccessInfo proto.InternalMessageInfo

type isK8SAccessInfo_ConfigType interface {
	isK8SAccessInfo_ConfigType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isK8SAccessInfo_K8SPodNetworkChoice interface {
	isK8SAccessInfo_K8SPodNetworkChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type K8SAccessInfo_KubeconfigUrl struct {
	KubeconfigUrl *schema.SecretType `protobuf:"bytes,1,opt,name=kubeconfig_url,json=kubeconfigUrl,proto3,oneof" json:"kubeconfig_url,omitempty"`
}
type K8SAccessInfo_ConnectionInfo struct {
	ConnectionInfo *RestConfigType `protobuf:"bytes,2,opt,name=connection_info,json=connectionInfo,proto3,oneof" json:"connection_info,omitempty"`
}
type K8SAccessInfo_InCluster struct {
	InCluster bool `protobuf:"varint,3,opt,name=in_cluster,json=inCluster,proto3,oneof" json:"in_cluster,omitempty"`
}
type K8SAccessInfo_Isolated struct {
	Isolated *schema.Empty `protobuf:"bytes,4,opt,name=isolated,proto3,oneof" json:"isolated,omitempty"`
}
type K8SAccessInfo_Reachable struct {
	Reachable *schema.Empty `protobuf:"bytes,5,opt,name=reachable,proto3,oneof" json:"reachable,omitempty"`
}

func (*K8SAccessInfo_KubeconfigUrl) isK8SAccessInfo_ConfigType()      {}
func (*K8SAccessInfo_ConnectionInfo) isK8SAccessInfo_ConfigType()     {}
func (*K8SAccessInfo_InCluster) isK8SAccessInfo_ConfigType()          {}
func (*K8SAccessInfo_Isolated) isK8SAccessInfo_K8SPodNetworkChoice()  {}
func (*K8SAccessInfo_Reachable) isK8SAccessInfo_K8SPodNetworkChoice() {}

func (m *K8SAccessInfo) GetConfigType() isK8SAccessInfo_ConfigType {
	if m != nil {
		return m.ConfigType
	}
	return nil
}
func (m *K8SAccessInfo) GetK8SPodNetworkChoice() isK8SAccessInfo_K8SPodNetworkChoice {
	if m != nil {
		return m.K8SPodNetworkChoice
	}
	return nil
}

func (m *K8SAccessInfo) GetKubeconfigUrl() *schema.SecretType {
	if x, ok := m.GetConfigType().(*K8SAccessInfo_KubeconfigUrl); ok {
		return x.KubeconfigUrl
	}
	return nil
}

func (m *K8SAccessInfo) GetConnectionInfo() *RestConfigType {
	if x, ok := m.GetConfigType().(*K8SAccessInfo_ConnectionInfo); ok {
		return x.ConnectionInfo
	}
	return nil
}

func (m *K8SAccessInfo) GetInCluster() bool {
	if x, ok := m.GetConfigType().(*K8SAccessInfo_InCluster); ok {
		return x.InCluster
	}
	return false
}

func (m *K8SAccessInfo) GetIsolated() *schema.Empty {
	if x, ok := m.GetK8SPodNetworkChoice().(*K8SAccessInfo_Isolated); ok {
		return x.Isolated
	}
	return nil
}

func (m *K8SAccessInfo) GetReachable() *schema.Empty {
	if x, ok := m.GetK8SPodNetworkChoice().(*K8SAccessInfo_Reachable); ok {
		return x.Reachable
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*K8SAccessInfo) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*K8SAccessInfo_KubeconfigUrl)(nil),
		(*K8SAccessInfo_ConnectionInfo)(nil),
		(*K8SAccessInfo_InCluster)(nil),
		(*K8SAccessInfo_Isolated)(nil),
		(*K8SAccessInfo_Reachable)(nil),
	}
}

// Hashicorp Consul Credentials
//
// x-displayName: "Hashicorp Consul Credentials"
// Authentication parameters to access Hashicorp Consul.
type ConsulHttpBasicAuthInfoType struct {
	// username
	//
	// x-displayName: "User Name"
	// x-example: "Joe"
	// username in consul
	UserName string `protobuf:"bytes,1,opt,name=user_name,json=userName,proto3" json:"user_name,omitempty"`
	// password
	//
	// x-displayName: "Password"
	// F5XC Secret. URL for password, needs to be fetched from this path
	PasswdUrl *schema.SecretType `protobuf:"bytes,2,opt,name=passwd_url,json=passwdUrl,proto3" json:"passwd_url,omitempty"`
}

func (m *ConsulHttpBasicAuthInfoType) Reset()      { *m = ConsulHttpBasicAuthInfoType{} }
func (*ConsulHttpBasicAuthInfoType) ProtoMessage() {}
func (*ConsulHttpBasicAuthInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{7}
}
func (m *ConsulHttpBasicAuthInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsulHttpBasicAuthInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConsulHttpBasicAuthInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsulHttpBasicAuthInfoType.Merge(m, src)
}
func (m *ConsulHttpBasicAuthInfoType) XXX_Size() int {
	return m.Size()
}
func (m *ConsulHttpBasicAuthInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsulHttpBasicAuthInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_ConsulHttpBasicAuthInfoType proto.InternalMessageInfo

func (m *ConsulHttpBasicAuthInfoType) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *ConsulHttpBasicAuthInfoType) GetPasswdUrl() *schema.SecretType {
	if m != nil {
		return m.PasswdUrl
	}
	return nil
}

// ConsulAccessInfo
//
// x-displayName: "Hashicorp Consul Parameters"
// Hashicorp Consul API server information
type ConsulAccessInfo struct {
	// Connection Parameters
	//
	// x-displayName: "Connection Parameters"
	// Configuration details to access Hashicorp Consul API service using REST.
	ConnectionInfo *RestConfigType `protobuf:"bytes,1,opt,name=connection_info,json=connectionInfo,proto3" json:"connection_info,omitempty"`
	// Scheme
	//
	// x-displayName: "Scheme"
	// scheme
	Scheme SchemeType `protobuf:"varint,2,opt,name=scheme,proto3,enum=ves.io.schema.discovery.SchemeType" json:"scheme,omitempty"` // Deprecated: Do not use.
	// Http authentication parameters
	//
	// x-displayName: "HTTP Authentication Parameters"
	// Username and password used for HTTP/HTTPS access
	HttpBasicAuthInfo *ConsulHttpBasicAuthInfoType `protobuf:"bytes,3,opt,name=http_basic_auth_info,json=httpBasicAuthInfo,proto3" json:"http_basic_auth_info,omitempty"`
}

func (m *ConsulAccessInfo) Reset()      { *m = ConsulAccessInfo{} }
func (*ConsulAccessInfo) ProtoMessage() {}
func (*ConsulAccessInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{8}
}
func (m *ConsulAccessInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsulAccessInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConsulAccessInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsulAccessInfo.Merge(m, src)
}
func (m *ConsulAccessInfo) XXX_Size() int {
	return m.Size()
}
func (m *ConsulAccessInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsulAccessInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ConsulAccessInfo proto.InternalMessageInfo

func (m *ConsulAccessInfo) GetConnectionInfo() *RestConfigType {
	if m != nil {
		return m.ConnectionInfo
	}
	return nil
}

// Deprecated: Do not use.
func (m *ConsulAccessInfo) GetScheme() SchemeType {
	if m != nil {
		return m.Scheme
	}
	return HTTP
}

func (m *ConsulAccessInfo) GetHttpBasicAuthInfo() *ConsulHttpBasicAuthInfoType {
	if m != nil {
		return m.HttpBasicAuthInfo
	}
	return nil
}

// VIP Discovery Info Type
//
// x-displayName: "VIP Publish Configuration"
// K8S Configuration to publish VIPs
type VipDiscoveryInfoType struct {
	// enable/disable publish VIP
	//
	// x-displayName: "VIP Publish Enable"
	// Are we publishing Virtual Host domains to Virtual IP mapping to external cluster
	PublishVirtualIp bool `protobuf:"varint,1,opt,name=publish_virtual_ip,json=publishVirtualIp,proto3" json:"publish_virtual_ip,omitempty"`
	// VIP publish method
	//
	// x-displayName: "VIP Publish Method"
	// How is Virtual IP discovery performed
	// Two modes are possible
	//   DNS_DELEGATION: Program DNS delegation for a sub-domain in external cluster
	//   PUBLISH_SERVICE: Create/Register a service in external K8s/consul cluster
	Type VirtualIPDiscoveryType `protobuf:"varint,2,opt,name=type,proto3,enum=ves.io.schema.discovery.VirtualIPDiscoveryType" json:"type,omitempty"`
	// DNS delegation sub-domain
	//
	// x-displayName: "Subdomain"
	// Subdomain for which DNS delegation is done
	// F5XC Edge Router will only respond for DNS queries on this sub-domain
	// While programming the DNS DELEGATE on external cluster, VER will take ownership of this
	// sub-domain
	Subdomain string `protobuf:"bytes,3,opt,name=subdomain,proto3" json:"subdomain,omitempty"`
	// DNS mode
	//
	// x-displayName: "DNS Mode"
	// When virtual IP is published with DNS delegation, this field indicates whether
	// external K8s is running core DNS or kube DNS
	DnsMode K8SDNSMode `protobuf:"varint,4,opt,name=dns_mode,json=dnsMode,proto3,enum=ves.io.schema.discovery.K8SDNSMode" json:"dns_mode,omitempty"`
	// default namespace
	//
	// x-displayName: "Default Namespace"
	// When virtual IP is published with "PUBLISH_SERVICE" mode, this field indicates the namespace
	// where the service/endpoints needs to be created if the domain name doesn't specify it
	// explicitly. K8S administrator of the external K8s should ensure this namespace is created
	Namespace string `protobuf:"bytes,5,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *VipDiscoveryInfoType) Reset()      { *m = VipDiscoveryInfoType{} }
func (*VipDiscoveryInfoType) ProtoMessage() {}
func (*VipDiscoveryInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{9}
}
func (m *VipDiscoveryInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VipDiscoveryInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VipDiscoveryInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VipDiscoveryInfoType.Merge(m, src)
}
func (m *VipDiscoveryInfoType) XXX_Size() int {
	return m.Size()
}
func (m *VipDiscoveryInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_VipDiscoveryInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_VipDiscoveryInfoType proto.InternalMessageInfo

func (m *VipDiscoveryInfoType) GetPublishVirtualIp() bool {
	if m != nil {
		return m.PublishVirtualIp
	}
	return false
}

func (m *VipDiscoveryInfoType) GetType() VirtualIPDiscoveryType {
	if m != nil {
		return m.Type
	}
	return DNS_DELEGATION
}

func (m *VipDiscoveryInfoType) GetSubdomain() string {
	if m != nil {
		return m.Subdomain
	}
	return ""
}

func (m *VipDiscoveryInfoType) GetDnsMode() K8SDNSMode {
	if m != nil {
		return m.DnsMode
	}
	return CORE_DNS
}

func (m *VipDiscoveryInfoType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// K8SPublishType
//
// x-displayName: "K8SPublishType"
type K8SPublishType struct {
	// namespace
	//
	// x-displayName: "Default Namespace"
	// x-required
	// x-example: "default"
	// The namespace where the service/endpoints need to be created if it's not included in the domain.
	// The external K8S administrator needs to ensure that the namespace exists.
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *K8SPublishType) Reset()      { *m = K8SPublishType{} }
func (*K8SPublishType) ProtoMessage() {}
func (*K8SPublishType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{10}
}
func (m *K8SPublishType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *K8SPublishType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *K8SPublishType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K8SPublishType.Merge(m, src)
}
func (m *K8SPublishType) XXX_Size() int {
	return m.Size()
}
func (m *K8SPublishType) XXX_DiscardUnknown() {
	xxx_messageInfo_K8SPublishType.DiscardUnknown(m)
}

var xxx_messageInfo_K8SPublishType proto.InternalMessageInfo

func (m *K8SPublishType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// K8SDelegationType
//
// x-displayName: "K8SDelegationType"
type K8SDelegationType struct {
	// subdomain
	//
	// x-displayName: "Subdomain"
	// x-example: "value"
	// x-required
	// The DNS subdomain for which F5XC will respond to DNS queries.
	Subdomain string `protobuf:"bytes,1,opt,name=subdomain,proto3" json:"subdomain,omitempty"`
	// DNS mode
	//
	// x-displayName: "DNS Mode"
	// x-required
	// Indicates whether external K8S is running core DNS or kube DNS
	DnsMode K8SDNSMode `protobuf:"varint,2,opt,name=dns_mode,json=dnsMode,proto3,enum=ves.io.schema.discovery.K8SDNSMode" json:"dns_mode,omitempty"`
}

func (m *K8SDelegationType) Reset()      { *m = K8SDelegationType{} }
func (*K8SDelegationType) ProtoMessage() {}
func (*K8SDelegationType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{11}
}
func (m *K8SDelegationType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *K8SDelegationType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *K8SDelegationType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K8SDelegationType.Merge(m, src)
}
func (m *K8SDelegationType) XXX_Size() int {
	return m.Size()
}
func (m *K8SDelegationType) XXX_DiscardUnknown() {
	xxx_messageInfo_K8SDelegationType.DiscardUnknown(m)
}

var xxx_messageInfo_K8SDelegationType proto.InternalMessageInfo

func (m *K8SDelegationType) GetSubdomain() string {
	if m != nil {
		return m.Subdomain
	}
	return ""
}

func (m *K8SDelegationType) GetDnsMode() K8SDNSMode {
	if m != nil {
		return m.DnsMode
	}
	return CORE_DNS
}

// K8S VIP Discovery Info Type
//
// x-displayName: "VIP Publish Configurations"
// K8S Configuration to publish VIPs
type K8SVipDiscoveryInfoType struct {
	// publish choice
	//
	// x-displayName: "Select VIP Publishing or DNS Delegation"
	// x-required
	// Select VIP Publishing or DNS Delegation
	//
	// Types that are valid to be assigned to PublishChoice:
	//	*K8SVipDiscoveryInfoType_Disable
	//	*K8SVipDiscoveryInfoType_Publish
	//	*K8SVipDiscoveryInfoType_PublishFqdns
	//	*K8SVipDiscoveryInfoType_DnsDelegation
	PublishChoice isK8SVipDiscoveryInfoType_PublishChoice `protobuf_oneof:"publish_choice"`
}

func (m *K8SVipDiscoveryInfoType) Reset()      { *m = K8SVipDiscoveryInfoType{} }
func (*K8SVipDiscoveryInfoType) ProtoMessage() {}
func (*K8SVipDiscoveryInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{12}
}
func (m *K8SVipDiscoveryInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *K8SVipDiscoveryInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *K8SVipDiscoveryInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K8SVipDiscoveryInfoType.Merge(m, src)
}
func (m *K8SVipDiscoveryInfoType) XXX_Size() int {
	return m.Size()
}
func (m *K8SVipDiscoveryInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_K8SVipDiscoveryInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_K8SVipDiscoveryInfoType proto.InternalMessageInfo

type isK8SVipDiscoveryInfoType_PublishChoice interface {
	isK8SVipDiscoveryInfoType_PublishChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type K8SVipDiscoveryInfoType_Disable struct {
	Disable *schema.Empty `protobuf:"bytes,2,opt,name=disable,proto3,oneof" json:"disable,omitempty"`
}
type K8SVipDiscoveryInfoType_Publish struct {
	Publish *K8SPublishType `protobuf:"bytes,3,opt,name=publish,proto3,oneof" json:"publish,omitempty"`
}
type K8SVipDiscoveryInfoType_PublishFqdns struct {
	PublishFqdns *schema.Empty `protobuf:"bytes,4,opt,name=publish_fqdns,json=publishFqdns,proto3,oneof" json:"publish_fqdns,omitempty"`
}
type K8SVipDiscoveryInfoType_DnsDelegation struct {
	DnsDelegation *K8SDelegationType `protobuf:"bytes,5,opt,name=dns_delegation,json=dnsDelegation,proto3,oneof" json:"dns_delegation,omitempty"`
}

func (*K8SVipDiscoveryInfoType_Disable) isK8SVipDiscoveryInfoType_PublishChoice()       {}
func (*K8SVipDiscoveryInfoType_Publish) isK8SVipDiscoveryInfoType_PublishChoice()       {}
func (*K8SVipDiscoveryInfoType_PublishFqdns) isK8SVipDiscoveryInfoType_PublishChoice()  {}
func (*K8SVipDiscoveryInfoType_DnsDelegation) isK8SVipDiscoveryInfoType_PublishChoice() {}

func (m *K8SVipDiscoveryInfoType) GetPublishChoice() isK8SVipDiscoveryInfoType_PublishChoice {
	if m != nil {
		return m.PublishChoice
	}
	return nil
}

func (m *K8SVipDiscoveryInfoType) GetDisable() *schema.Empty {
	if x, ok := m.GetPublishChoice().(*K8SVipDiscoveryInfoType_Disable); ok {
		return x.Disable
	}
	return nil
}

func (m *K8SVipDiscoveryInfoType) GetPublish() *K8SPublishType {
	if x, ok := m.GetPublishChoice().(*K8SVipDiscoveryInfoType_Publish); ok {
		return x.Publish
	}
	return nil
}

func (m *K8SVipDiscoveryInfoType) GetPublishFqdns() *schema.Empty {
	if x, ok := m.GetPublishChoice().(*K8SVipDiscoveryInfoType_PublishFqdns); ok {
		return x.PublishFqdns
	}
	return nil
}

func (m *K8SVipDiscoveryInfoType) GetDnsDelegation() *K8SDelegationType {
	if x, ok := m.GetPublishChoice().(*K8SVipDiscoveryInfoType_DnsDelegation); ok {
		return x.DnsDelegation
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*K8SVipDiscoveryInfoType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*K8SVipDiscoveryInfoType_Disable)(nil),
		(*K8SVipDiscoveryInfoType_Publish)(nil),
		(*K8SVipDiscoveryInfoType_PublishFqdns)(nil),
		(*K8SVipDiscoveryInfoType_DnsDelegation)(nil),
	}
}

// Consul VIP Discovery Info Type
//
// x-displayName: "VIP Publish Configuration"
// Consul Configuration to publish VIPs
type ConsulVipDiscoveryInfoType struct {
	// publish choice
	//
	// x-displayName: "Enable/Disable VIP Publishing"
	// x-required
	// Enable or disable VIP Publishing.
	//
	// Types that are valid to be assigned to PublishChoice:
	//	*ConsulVipDiscoveryInfoType_Disable
	//	*ConsulVipDiscoveryInfoType_Publish
	PublishChoice isConsulVipDiscoveryInfoType_PublishChoice `protobuf_oneof:"publish_choice"`
}

func (m *ConsulVipDiscoveryInfoType) Reset()      { *m = ConsulVipDiscoveryInfoType{} }
func (*ConsulVipDiscoveryInfoType) ProtoMessage() {}
func (*ConsulVipDiscoveryInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{13}
}
func (m *ConsulVipDiscoveryInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsulVipDiscoveryInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConsulVipDiscoveryInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsulVipDiscoveryInfoType.Merge(m, src)
}
func (m *ConsulVipDiscoveryInfoType) XXX_Size() int {
	return m.Size()
}
func (m *ConsulVipDiscoveryInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsulVipDiscoveryInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_ConsulVipDiscoveryInfoType proto.InternalMessageInfo

type isConsulVipDiscoveryInfoType_PublishChoice interface {
	isConsulVipDiscoveryInfoType_PublishChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ConsulVipDiscoveryInfoType_Disable struct {
	Disable *schema.Empty `protobuf:"bytes,2,opt,name=disable,proto3,oneof" json:"disable,omitempty"`
}
type ConsulVipDiscoveryInfoType_Publish struct {
	Publish *schema.Empty `protobuf:"bytes,3,opt,name=publish,proto3,oneof" json:"publish,omitempty"`
}

func (*ConsulVipDiscoveryInfoType_Disable) isConsulVipDiscoveryInfoType_PublishChoice() {}
func (*ConsulVipDiscoveryInfoType_Publish) isConsulVipDiscoveryInfoType_PublishChoice() {}

func (m *ConsulVipDiscoveryInfoType) GetPublishChoice() isConsulVipDiscoveryInfoType_PublishChoice {
	if m != nil {
		return m.PublishChoice
	}
	return nil
}

func (m *ConsulVipDiscoveryInfoType) GetDisable() *schema.Empty {
	if x, ok := m.GetPublishChoice().(*ConsulVipDiscoveryInfoType_Disable); ok {
		return x.Disable
	}
	return nil
}

func (m *ConsulVipDiscoveryInfoType) GetPublish() *schema.Empty {
	if x, ok := m.GetPublishChoice().(*ConsulVipDiscoveryInfoType_Publish); ok {
		return x.Publish
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ConsulVipDiscoveryInfoType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ConsulVipDiscoveryInfoType_Disable)(nil),
		(*ConsulVipDiscoveryInfoType_Publish)(nil),
	}
}

// K8s discovery type
//
// x-displayName: "K8S Discovery Configuration"
// Discovery configuration for K8s.
type K8SDiscoveryType struct {
	// Kubernetes Credentials
	//
	// x-displayName: "Access Credentials"
	// x-required
	// Credentials can be kubeconfig file or mTLS using PKI certificates
	AccessInfo *K8SAccessInfo `protobuf:"bytes,1,opt,name=access_info,json=accessInfo,proto3" json:"access_info,omitempty"`
	// publish info
	//
	// x-displayName: "VIP Publishing Configuration"
	// x-required
	// Configuration to publish VIPs
	PublishInfo *K8SVipDiscoveryInfoType `protobuf:"bytes,2,opt,name=publish_info,json=publishInfo,proto3" json:"publish_info,omitempty"`
}

func (m *K8SDiscoveryType) Reset()      { *m = K8SDiscoveryType{} }
func (*K8SDiscoveryType) ProtoMessage() {}
func (*K8SDiscoveryType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{14}
}
func (m *K8SDiscoveryType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *K8SDiscoveryType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *K8SDiscoveryType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K8SDiscoveryType.Merge(m, src)
}
func (m *K8SDiscoveryType) XXX_Size() int {
	return m.Size()
}
func (m *K8SDiscoveryType) XXX_DiscardUnknown() {
	xxx_messageInfo_K8SDiscoveryType.DiscardUnknown(m)
}

var xxx_messageInfo_K8SDiscoveryType proto.InternalMessageInfo

func (m *K8SDiscoveryType) GetAccessInfo() *K8SAccessInfo {
	if m != nil {
		return m.AccessInfo
	}
	return nil
}

func (m *K8SDiscoveryType) GetPublishInfo() *K8SVipDiscoveryInfoType {
	if m != nil {
		return m.PublishInfo
	}
	return nil
}

// consul discovery type
//
// x-displayName: "Consul Discovery Configuration"
// Discovery configuration for Hashicorp Consul
type ConsulDiscoveryType struct {
	// Hashicorp Consul Credentials
	//
	// x-displayName: "Access Credentials"
	// x-required
	// Credentials to access Hashicorp Consul service discovery
	AccessInfo *ConsulAccessInfo `protobuf:"bytes,1,opt,name=access_info,json=accessInfo,proto3" json:"access_info,omitempty"`
	// publish info
	//
	// x-displayName: "VIP Publishing Configuration"
	// x-required
	// Configuration to publish VIPs
	PublishInfo *ConsulVipDiscoveryInfoType `protobuf:"bytes,2,opt,name=publish_info,json=publishInfo,proto3" json:"publish_info,omitempty"`
}

func (m *ConsulDiscoveryType) Reset()      { *m = ConsulDiscoveryType{} }
func (*ConsulDiscoveryType) ProtoMessage() {}
func (*ConsulDiscoveryType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{15}
}
func (m *ConsulDiscoveryType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsulDiscoveryType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConsulDiscoveryType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsulDiscoveryType.Merge(m, src)
}
func (m *ConsulDiscoveryType) XXX_Size() int {
	return m.Size()
}
func (m *ConsulDiscoveryType) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsulDiscoveryType.DiscardUnknown(m)
}

var xxx_messageInfo_ConsulDiscoveryType proto.InternalMessageInfo

func (m *ConsulDiscoveryType) GetAccessInfo() *ConsulAccessInfo {
	if m != nil {
		return m.AccessInfo
	}
	return nil
}

func (m *ConsulDiscoveryType) GetPublishInfo() *ConsulVipDiscoveryInfoType {
	if m != nil {
		return m.PublishInfo
	}
	return nil
}

// Specification for discovery
//
// x-displayName: "Specification"
// Desired state of discovery
type GlobalSpecType struct {
	// Where
	//
	// x-displayName: "Select Site, Virtual Site or Network"
	// x-required
	// All the sites where this discovery config is valid.
	Where *schema.NetworkSiteRefSelector `protobuf:"bytes,1,opt,name=where,proto3" json:"where,omitempty"`
	// discovery choice
	//
	// x-displayName: "Select Discovery Method"
	// x-required
	// Select discovery method as K8S or Hashicorp Consul
	//
	// Types that are valid to be assigned to DiscoveryChoice:
	//	*GlobalSpecType_DiscoveryK8S
	//	*GlobalSpecType_DiscoveryConsul
	DiscoveryChoice isGlobalSpecType_DiscoveryChoice `protobuf_oneof:"discovery_choice"`
	// Discovery type
	//
	// x-displayName: "Type of Discovery"
	// x-required
	// Type of discovery K8s or consul
	Type schema.DiscoveryType `protobuf:"varint,2,opt,name=type,proto3,enum=ves.io.schema.DiscoveryType" json:"type,omitempty"`
	// VIP publish
	//
	// x-displayName: "VIP Publishing configuration"
	// Configuration to publish VIP(s) in to a discovery service.
	PublishVip *VipDiscoveryInfoType `protobuf:"bytes,3,opt,name=publish_vip,json=publishVip,proto3" json:"publish_vip,omitempty"`
	// Access Info
	//
	// x-displayName: "Select How Endpoints are Discovered"
	// Endpoints can be discovered from Kubernetes service configuration or Consul
	//
	// Types that are valid to be assigned to AccessInfo:
	//	*GlobalSpecType_K8S
	//	*GlobalSpecType_Consul
	AccessInfo isGlobalSpecType_AccessInfo `protobuf_oneof:"access_info"`
	// discovery cluster identifier
	//
	// x-displayName: "Select Discovery Cluster Identifier"
	// x-example: "debug-cluster"
	// Specify identifier for discovery cluster. This identifier can be
	// specified in endpoint object to discover only from this discovery object.
	// This is useful when a site has multiple discovery objects and endpoint wants
	// to discover from few of them. The default behaviour for endpoint is to
	// discover from all discovery objects of the site.
	ClusterIdentifier string `protobuf:"bytes,10,opt,name=cluster_identifier,json=clusterIdentifier,proto3" json:"cluster_identifier,omitempty"` // Deprecated: Do not use.
	// cluster identifier choice
	//
	// x-displayName: "Select Discovery Cluster Identifier"
	// x-required
	// Specify identifier for discovery cluster. This identifier can be
	// specified in endpoint object to discover only from this discovery object.
	// This is useful when a site has multiple discovery objects and endpoint wants
	// to discover from few of them. The default behaviour for endpoint is to
	// discover from all discovery objects of the site.
	//
	// Types that are valid to be assigned to ClusterIdentifierChoice:
	//	*GlobalSpecType_NoClusterId
	//	*GlobalSpecType_ClusterId
	ClusterIdentifierChoice isGlobalSpecType_ClusterIdentifierChoice `protobuf_oneof:"cluster_identifier_choice"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{16}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_DiscoveryChoice interface {
	isGlobalSpecType_DiscoveryChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_AccessInfo interface {
	isGlobalSpecType_AccessInfo()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_ClusterIdentifierChoice interface {
	isGlobalSpecType_ClusterIdentifierChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_DiscoveryK8S struct {
	DiscoveryK8S *K8SDiscoveryType `protobuf:"bytes,8,opt,name=discovery_k8s,json=discoveryK8s,proto3,oneof" json:"discovery_k8s,omitempty"`
}
type GlobalSpecType_DiscoveryConsul struct {
	DiscoveryConsul *ConsulDiscoveryType `protobuf:"bytes,9,opt,name=discovery_consul,json=discoveryConsul,proto3,oneof" json:"discovery_consul,omitempty"`
}
type GlobalSpecType_K8S struct {
	K8S *K8SAccessInfo `protobuf:"bytes,4,opt,name=k8s,proto3,oneof" json:"k8s,omitempty"`
}
type GlobalSpecType_Consul struct {
	Consul *ConsulAccessInfo `protobuf:"bytes,5,opt,name=consul,proto3,oneof" json:"consul,omitempty"`
}
type GlobalSpecType_NoClusterId struct {
	NoClusterId *schema.Empty `protobuf:"bytes,12,opt,name=no_cluster_id,json=noClusterId,proto3,oneof" json:"no_cluster_id,omitempty"`
}
type GlobalSpecType_ClusterId struct {
	ClusterId string `protobuf:"bytes,13,opt,name=cluster_id,json=clusterId,proto3,oneof" json:"cluster_id,omitempty"`
}

func (*GlobalSpecType_DiscoveryK8S) isGlobalSpecType_DiscoveryChoice()        {}
func (*GlobalSpecType_DiscoveryConsul) isGlobalSpecType_DiscoveryChoice()     {}
func (*GlobalSpecType_K8S) isGlobalSpecType_AccessInfo()                      {}
func (*GlobalSpecType_Consul) isGlobalSpecType_AccessInfo()                   {}
func (*GlobalSpecType_NoClusterId) isGlobalSpecType_ClusterIdentifierChoice() {}
func (*GlobalSpecType_ClusterId) isGlobalSpecType_ClusterIdentifierChoice()   {}

func (m *GlobalSpecType) GetDiscoveryChoice() isGlobalSpecType_DiscoveryChoice {
	if m != nil {
		return m.DiscoveryChoice
	}
	return nil
}
func (m *GlobalSpecType) GetAccessInfo() isGlobalSpecType_AccessInfo {
	if m != nil {
		return m.AccessInfo
	}
	return nil
}
func (m *GlobalSpecType) GetClusterIdentifierChoice() isGlobalSpecType_ClusterIdentifierChoice {
	if m != nil {
		return m.ClusterIdentifierChoice
	}
	return nil
}

func (m *GlobalSpecType) GetWhere() *schema.NetworkSiteRefSelector {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *GlobalSpecType) GetDiscoveryK8S() *K8SDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*GlobalSpecType_DiscoveryK8S); ok {
		return x.DiscoveryK8S
	}
	return nil
}

func (m *GlobalSpecType) GetDiscoveryConsul() *ConsulDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*GlobalSpecType_DiscoveryConsul); ok {
		return x.DiscoveryConsul
	}
	return nil
}

func (m *GlobalSpecType) GetType() schema.DiscoveryType {
	if m != nil {
		return m.Type
	}
	return schema.INVALID_DISCOVERY
}

func (m *GlobalSpecType) GetPublishVip() *VipDiscoveryInfoType {
	if m != nil {
		return m.PublishVip
	}
	return nil
}

func (m *GlobalSpecType) GetK8S() *K8SAccessInfo {
	if x, ok := m.GetAccessInfo().(*GlobalSpecType_K8S); ok {
		return x.K8S
	}
	return nil
}

func (m *GlobalSpecType) GetConsul() *ConsulAccessInfo {
	if x, ok := m.GetAccessInfo().(*GlobalSpecType_Consul); ok {
		return x.Consul
	}
	return nil
}

// Deprecated: Do not use.
func (m *GlobalSpecType) GetClusterIdentifier() string {
	if m != nil {
		return m.ClusterIdentifier
	}
	return ""
}

func (m *GlobalSpecType) GetNoClusterId() *schema.Empty {
	if x, ok := m.GetClusterIdentifierChoice().(*GlobalSpecType_NoClusterId); ok {
		return x.NoClusterId
	}
	return nil
}

func (m *GlobalSpecType) GetClusterId() string {
	if x, ok := m.GetClusterIdentifierChoice().(*GlobalSpecType_ClusterId); ok {
		return x.ClusterId
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_DiscoveryK8S)(nil),
		(*GlobalSpecType_DiscoveryConsul)(nil),
		(*GlobalSpecType_K8S)(nil),
		(*GlobalSpecType_Consul)(nil),
		(*GlobalSpecType_NoClusterId)(nil),
		(*GlobalSpecType_ClusterId)(nil),
	}
}

// Create discovery
//
// x-displayName: "Create Discovery"
// API to create discovery object for a site or virtual site in system namespace
type CreateSpecType struct {
	Where *schema.NetworkSiteRefSelector `protobuf:"bytes,1,opt,name=where,proto3" json:"where,omitempty"`
	// Types that are valid to be assigned to DiscoveryChoice:
	//	*CreateSpecType_DiscoveryK8S
	//	*CreateSpecType_DiscoveryConsul
	DiscoveryChoice isCreateSpecType_DiscoveryChoice `protobuf_oneof:"discovery_choice"`
	// Types that are valid to be assigned to ClusterIdentifierChoice:
	//	*CreateSpecType_NoClusterId
	//	*CreateSpecType_ClusterId
	ClusterIdentifierChoice isCreateSpecType_ClusterIdentifierChoice `protobuf_oneof:"cluster_identifier_choice"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{17}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_DiscoveryChoice interface {
	isCreateSpecType_DiscoveryChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_ClusterIdentifierChoice interface {
	isCreateSpecType_ClusterIdentifierChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_DiscoveryK8S struct {
	DiscoveryK8S *K8SDiscoveryType `protobuf:"bytes,8,opt,name=discovery_k8s,json=discoveryK8s,proto3,oneof" json:"discovery_k8s,omitempty"`
}
type CreateSpecType_DiscoveryConsul struct {
	DiscoveryConsul *ConsulDiscoveryType `protobuf:"bytes,9,opt,name=discovery_consul,json=discoveryConsul,proto3,oneof" json:"discovery_consul,omitempty"`
}
type CreateSpecType_NoClusterId struct {
	NoClusterId *schema.Empty `protobuf:"bytes,12,opt,name=no_cluster_id,json=noClusterId,proto3,oneof" json:"no_cluster_id,omitempty"`
}
type CreateSpecType_ClusterId struct {
	ClusterId string `protobuf:"bytes,13,opt,name=cluster_id,json=clusterId,proto3,oneof" json:"cluster_id,omitempty"`
}

func (*CreateSpecType_DiscoveryK8S) isCreateSpecType_DiscoveryChoice()        {}
func (*CreateSpecType_DiscoveryConsul) isCreateSpecType_DiscoveryChoice()     {}
func (*CreateSpecType_NoClusterId) isCreateSpecType_ClusterIdentifierChoice() {}
func (*CreateSpecType_ClusterId) isCreateSpecType_ClusterIdentifierChoice()   {}

func (m *CreateSpecType) GetDiscoveryChoice() isCreateSpecType_DiscoveryChoice {
	if m != nil {
		return m.DiscoveryChoice
	}
	return nil
}
func (m *CreateSpecType) GetClusterIdentifierChoice() isCreateSpecType_ClusterIdentifierChoice {
	if m != nil {
		return m.ClusterIdentifierChoice
	}
	return nil
}

func (m *CreateSpecType) GetWhere() *schema.NetworkSiteRefSelector {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *CreateSpecType) GetDiscoveryK8S() *K8SDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*CreateSpecType_DiscoveryK8S); ok {
		return x.DiscoveryK8S
	}
	return nil
}

func (m *CreateSpecType) GetDiscoveryConsul() *ConsulDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*CreateSpecType_DiscoveryConsul); ok {
		return x.DiscoveryConsul
	}
	return nil
}

func (m *CreateSpecType) GetNoClusterId() *schema.Empty {
	if x, ok := m.GetClusterIdentifierChoice().(*CreateSpecType_NoClusterId); ok {
		return x.NoClusterId
	}
	return nil
}

func (m *CreateSpecType) GetClusterId() string {
	if x, ok := m.GetClusterIdentifierChoice().(*CreateSpecType_ClusterId); ok {
		return x.ClusterId
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_DiscoveryK8S)(nil),
		(*CreateSpecType_DiscoveryConsul)(nil),
		(*CreateSpecType_NoClusterId)(nil),
		(*CreateSpecType_ClusterId)(nil),
	}
}

// Replace discovery
//
// x-displayName: "Replace Discovery"
// API to replace discovery object for a site or virtual site in system namespace
type ReplaceSpecType struct {
	Where *schema.NetworkSiteRefSelector `protobuf:"bytes,1,opt,name=where,proto3" json:"where,omitempty"`
	// Types that are valid to be assigned to DiscoveryChoice:
	//	*ReplaceSpecType_DiscoveryK8S
	//	*ReplaceSpecType_DiscoveryConsul
	DiscoveryChoice isReplaceSpecType_DiscoveryChoice `protobuf_oneof:"discovery_choice"`
	// Types that are valid to be assigned to ClusterIdentifierChoice:
	//	*ReplaceSpecType_NoClusterId
	//	*ReplaceSpecType_ClusterId
	ClusterIdentifierChoice isReplaceSpecType_ClusterIdentifierChoice `protobuf_oneof:"cluster_identifier_choice"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{18}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_DiscoveryChoice interface {
	isReplaceSpecType_DiscoveryChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_ClusterIdentifierChoice interface {
	isReplaceSpecType_ClusterIdentifierChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_DiscoveryK8S struct {
	DiscoveryK8S *K8SDiscoveryType `protobuf:"bytes,8,opt,name=discovery_k8s,json=discoveryK8s,proto3,oneof" json:"discovery_k8s,omitempty"`
}
type ReplaceSpecType_DiscoveryConsul struct {
	DiscoveryConsul *ConsulDiscoveryType `protobuf:"bytes,9,opt,name=discovery_consul,json=discoveryConsul,proto3,oneof" json:"discovery_consul,omitempty"`
}
type ReplaceSpecType_NoClusterId struct {
	NoClusterId *schema.Empty `protobuf:"bytes,12,opt,name=no_cluster_id,json=noClusterId,proto3,oneof" json:"no_cluster_id,omitempty"`
}
type ReplaceSpecType_ClusterId struct {
	ClusterId string `protobuf:"bytes,13,opt,name=cluster_id,json=clusterId,proto3,oneof" json:"cluster_id,omitempty"`
}

func (*ReplaceSpecType_DiscoveryK8S) isReplaceSpecType_DiscoveryChoice()        {}
func (*ReplaceSpecType_DiscoveryConsul) isReplaceSpecType_DiscoveryChoice()     {}
func (*ReplaceSpecType_NoClusterId) isReplaceSpecType_ClusterIdentifierChoice() {}
func (*ReplaceSpecType_ClusterId) isReplaceSpecType_ClusterIdentifierChoice()   {}

func (m *ReplaceSpecType) GetDiscoveryChoice() isReplaceSpecType_DiscoveryChoice {
	if m != nil {
		return m.DiscoveryChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetClusterIdentifierChoice() isReplaceSpecType_ClusterIdentifierChoice {
	if m != nil {
		return m.ClusterIdentifierChoice
	}
	return nil
}

func (m *ReplaceSpecType) GetWhere() *schema.NetworkSiteRefSelector {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *ReplaceSpecType) GetDiscoveryK8S() *K8SDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*ReplaceSpecType_DiscoveryK8S); ok {
		return x.DiscoveryK8S
	}
	return nil
}

func (m *ReplaceSpecType) GetDiscoveryConsul() *ConsulDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*ReplaceSpecType_DiscoveryConsul); ok {
		return x.DiscoveryConsul
	}
	return nil
}

func (m *ReplaceSpecType) GetNoClusterId() *schema.Empty {
	if x, ok := m.GetClusterIdentifierChoice().(*ReplaceSpecType_NoClusterId); ok {
		return x.NoClusterId
	}
	return nil
}

func (m *ReplaceSpecType) GetClusterId() string {
	if x, ok := m.GetClusterIdentifierChoice().(*ReplaceSpecType_ClusterId); ok {
		return x.ClusterId
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_DiscoveryK8S)(nil),
		(*ReplaceSpecType_DiscoveryConsul)(nil),
		(*ReplaceSpecType_NoClusterId)(nil),
		(*ReplaceSpecType_ClusterId)(nil),
	}
}

// Get discovery
//
// x-displayName: "Get Discovery"
// API to Get discovery object for a site or virtual site in system namespace
type GetSpecType struct {
	Where      *schema.NetworkSiteRefSelector `protobuf:"bytes,1,opt,name=where,proto3" json:"where,omitempty"`
	Type       schema.DiscoveryType           `protobuf:"varint,2,opt,name=type,proto3,enum=ves.io.schema.DiscoveryType" json:"type,omitempty"`
	PublishVip *VipDiscoveryInfoType          `protobuf:"bytes,3,opt,name=publish_vip,json=publishVip,proto3" json:"publish_vip,omitempty"`
	// Types that are valid to be assigned to DiscoveryChoice:
	//	*GetSpecType_DiscoveryK8S
	//	*GetSpecType_DiscoveryConsul
	DiscoveryChoice isGetSpecType_DiscoveryChoice `protobuf_oneof:"discovery_choice"`
	// Types that are valid to be assigned to ClusterIdentifierChoice:
	//	*GetSpecType_NoClusterId
	//	*GetSpecType_ClusterId
	ClusterIdentifierChoice isGetSpecType_ClusterIdentifierChoice `protobuf_oneof:"cluster_identifier_choice"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1beabb40327c3d92, []int{19}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_DiscoveryChoice interface {
	isGetSpecType_DiscoveryChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_ClusterIdentifierChoice interface {
	isGetSpecType_ClusterIdentifierChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_DiscoveryK8S struct {
	DiscoveryK8S *K8SDiscoveryType `protobuf:"bytes,8,opt,name=discovery_k8s,json=discoveryK8s,proto3,oneof" json:"discovery_k8s,omitempty"`
}
type GetSpecType_DiscoveryConsul struct {
	DiscoveryConsul *ConsulDiscoveryType `protobuf:"bytes,9,opt,name=discovery_consul,json=discoveryConsul,proto3,oneof" json:"discovery_consul,omitempty"`
}
type GetSpecType_NoClusterId struct {
	NoClusterId *schema.Empty `protobuf:"bytes,12,opt,name=no_cluster_id,json=noClusterId,proto3,oneof" json:"no_cluster_id,omitempty"`
}
type GetSpecType_ClusterId struct {
	ClusterId string `protobuf:"bytes,13,opt,name=cluster_id,json=clusterId,proto3,oneof" json:"cluster_id,omitempty"`
}

func (*GetSpecType_DiscoveryK8S) isGetSpecType_DiscoveryChoice()        {}
func (*GetSpecType_DiscoveryConsul) isGetSpecType_DiscoveryChoice()     {}
func (*GetSpecType_NoClusterId) isGetSpecType_ClusterIdentifierChoice() {}
func (*GetSpecType_ClusterId) isGetSpecType_ClusterIdentifierChoice()   {}

func (m *GetSpecType) GetDiscoveryChoice() isGetSpecType_DiscoveryChoice {
	if m != nil {
		return m.DiscoveryChoice
	}
	return nil
}
func (m *GetSpecType) GetClusterIdentifierChoice() isGetSpecType_ClusterIdentifierChoice {
	if m != nil {
		return m.ClusterIdentifierChoice
	}
	return nil
}

func (m *GetSpecType) GetWhere() *schema.NetworkSiteRefSelector {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *GetSpecType) GetType() schema.DiscoveryType {
	if m != nil {
		return m.Type
	}
	return schema.INVALID_DISCOVERY
}

func (m *GetSpecType) GetPublishVip() *VipDiscoveryInfoType {
	if m != nil {
		return m.PublishVip
	}
	return nil
}

func (m *GetSpecType) GetDiscoveryK8S() *K8SDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*GetSpecType_DiscoveryK8S); ok {
		return x.DiscoveryK8S
	}
	return nil
}

func (m *GetSpecType) GetDiscoveryConsul() *ConsulDiscoveryType {
	if x, ok := m.GetDiscoveryChoice().(*GetSpecType_DiscoveryConsul); ok {
		return x.DiscoveryConsul
	}
	return nil
}

func (m *GetSpecType) GetNoClusterId() *schema.Empty {
	if x, ok := m.GetClusterIdentifierChoice().(*GetSpecType_NoClusterId); ok {
		return x.NoClusterId
	}
	return nil
}

func (m *GetSpecType) GetClusterId() string {
	if x, ok := m.GetClusterIdentifierChoice().(*GetSpecType_ClusterId); ok {
		return x.ClusterId
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_DiscoveryK8S)(nil),
		(*GetSpecType_DiscoveryConsul)(nil),
		(*GetSpecType_NoClusterId)(nil),
		(*GetSpecType_ClusterId)(nil),
	}
}

func init() {
	proto.RegisterEnum("ves.io.schema.discovery.SchemeType", SchemeType_name, SchemeType_value)
	golang_proto.RegisterEnum("ves.io.schema.discovery.SchemeType", SchemeType_name, SchemeType_value)
	proto.RegisterEnum("ves.io.schema.discovery.VirtualIPDiscoveryType", VirtualIPDiscoveryType_name, VirtualIPDiscoveryType_value)
	golang_proto.RegisterEnum("ves.io.schema.discovery.VirtualIPDiscoveryType", VirtualIPDiscoveryType_name, VirtualIPDiscoveryType_value)
	proto.RegisterEnum("ves.io.schema.discovery.K8SDNSMode", K8SDNSMode_name, K8SDNSMode_value)
	golang_proto.RegisterEnum("ves.io.schema.discovery.K8SDNSMode", K8SDNSMode_name, K8SDNSMode_value)
	proto.RegisterType((*VerStatusType)(nil), "ves.io.schema.discovery.VerStatusType")
	golang_proto.RegisterType((*VerStatusType)(nil), "ves.io.schema.discovery.VerStatusType")
	proto.RegisterType((*PodInfoType)(nil), "ves.io.schema.discovery.PodInfoType")
	golang_proto.RegisterType((*PodInfoType)(nil), "ves.io.schema.discovery.PodInfoType")
	proto.RegisterType((*PortInfoType)(nil), "ves.io.schema.discovery.PortInfoType")
	golang_proto.RegisterType((*PortInfoType)(nil), "ves.io.schema.discovery.PortInfoType")
	proto.RegisterType((*DiscoveredServiceType)(nil), "ves.io.schema.discovery.DiscoveredServiceType")
	golang_proto.RegisterType((*DiscoveredServiceType)(nil), "ves.io.schema.discovery.DiscoveredServiceType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.discovery.DiscoveredServiceType.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.discovery.DiscoveredServiceType.LabelsEntry")
	proto.RegisterMapType((map[uint32]uint32)(nil), "ves.io.schema.discovery.DiscoveredServiceType.PortMapEntry")
	golang_proto.RegisterMapType((map[uint32]uint32)(nil), "ves.io.schema.discovery.DiscoveredServiceType.PortMapEntry")
	proto.RegisterType((*TLSClientConfigType)(nil), "ves.io.schema.discovery.TLSClientConfigType")
	golang_proto.RegisterType((*TLSClientConfigType)(nil), "ves.io.schema.discovery.TLSClientConfigType")
	proto.RegisterType((*RestConfigType)(nil), "ves.io.schema.discovery.RestConfigType")
	golang_proto.RegisterType((*RestConfigType)(nil), "ves.io.schema.discovery.RestConfigType")
	proto.RegisterType((*K8SAccessInfo)(nil), "ves.io.schema.discovery.K8SAccessInfo")
	golang_proto.RegisterType((*K8SAccessInfo)(nil), "ves.io.schema.discovery.K8SAccessInfo")
	proto.RegisterType((*ConsulHttpBasicAuthInfoType)(nil), "ves.io.schema.discovery.ConsulHttpBasicAuthInfoType")
	golang_proto.RegisterType((*ConsulHttpBasicAuthInfoType)(nil), "ves.io.schema.discovery.ConsulHttpBasicAuthInfoType")
	proto.RegisterType((*ConsulAccessInfo)(nil), "ves.io.schema.discovery.ConsulAccessInfo")
	golang_proto.RegisterType((*ConsulAccessInfo)(nil), "ves.io.schema.discovery.ConsulAccessInfo")
	proto.RegisterType((*VipDiscoveryInfoType)(nil), "ves.io.schema.discovery.VipDiscoveryInfoType")
	golang_proto.RegisterType((*VipDiscoveryInfoType)(nil), "ves.io.schema.discovery.VipDiscoveryInfoType")
	proto.RegisterType((*K8SPublishType)(nil), "ves.io.schema.discovery.K8SPublishType")
	golang_proto.RegisterType((*K8SPublishType)(nil), "ves.io.schema.discovery.K8SPublishType")
	proto.RegisterType((*K8SDelegationType)(nil), "ves.io.schema.discovery.K8SDelegationType")
	golang_proto.RegisterType((*K8SDelegationType)(nil), "ves.io.schema.discovery.K8SDelegationType")
	proto.RegisterType((*K8SVipDiscoveryInfoType)(nil), "ves.io.schema.discovery.K8SVipDiscoveryInfoType")
	golang_proto.RegisterType((*K8SVipDiscoveryInfoType)(nil), "ves.io.schema.discovery.K8SVipDiscoveryInfoType")
	proto.RegisterType((*ConsulVipDiscoveryInfoType)(nil), "ves.io.schema.discovery.ConsulVipDiscoveryInfoType")
	golang_proto.RegisterType((*ConsulVipDiscoveryInfoType)(nil), "ves.io.schema.discovery.ConsulVipDiscoveryInfoType")
	proto.RegisterType((*K8SDiscoveryType)(nil), "ves.io.schema.discovery.K8SDiscoveryType")
	golang_proto.RegisterType((*K8SDiscoveryType)(nil), "ves.io.schema.discovery.K8SDiscoveryType")
	proto.RegisterType((*ConsulDiscoveryType)(nil), "ves.io.schema.discovery.ConsulDiscoveryType")
	golang_proto.RegisterType((*ConsulDiscoveryType)(nil), "ves.io.schema.discovery.ConsulDiscoveryType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.discovery.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.discovery.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.discovery.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.discovery.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.discovery.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.discovery.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.discovery.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.discovery.GetSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/discovery/types.proto", fileDescriptor_1beabb40327c3d92)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/discovery/types.proto", fileDescriptor_1beabb40327c3d92)
}

var fileDescriptor_1beabb40327c3d92 = []byte{
	// 2506 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x59, 0x4d, 0x6c, 0x1b, 0xc7,
	0x15, 0xe6, 0xf0, 0x9f, 0x8f, 0x22, 0x45, 0x8f, 0x95, 0x78, 0xcd, 0xb8, 0xcc, 0x9a, 0x49, 0x1a,
	0x45, 0xa1, 0xa9, 0x1f, 0x3b, 0x09, 0x23, 0xb7, 0x41, 0x4c, 0x4a, 0xb1, 0x64, 0x59, 0x8a, 0xba,
	0xb4, 0x15, 0xb4, 0x17, 0x62, 0xb9, 0x3b, 0x12, 0x17, 0x5a, 0xee, 0x6e, 0x77, 0x97, 0x72, 0x74,
	0x08, 0x60, 0x04, 0x68, 0x8b, 0xba, 0x97, 0x00, 0xbd, 0x14, 0x39, 0xf6, 0xd4, 0x02, 0xed, 0xa5,
	0x87, 0x1e, 0x42, 0x1f, 0x0c, 0x03, 0x05, 0x82, 0x5c, 0xa2, 0xde, 0x7c, 0xe8, 0x21, 0x91, 0x2f,
	0x69, 0x4e, 0x41, 0x4e, 0x41, 0x7a, 0x48, 0x31, 0xb3, 0xc3, 0xe5, 0x92, 0xa2, 0xe8, 0xa8, 0x31,
	0x5a, 0xa0, 0xc8, 0x6d, 0x76, 0xe6, 0xfd, 0x7f, 0xef, 0xbd, 0x79, 0x43, 0xc2, 0x33, 0x7b, 0xc4,
	0x29, 0x6b, 0xe6, 0xac, 0xa3, 0xb4, 0x48, 0x5b, 0x9e, 0x55, 0x35, 0x47, 0x31, 0xf7, 0x88, 0xbd,
	0x3f, 0xeb, 0xee, 0x5b, 0xc4, 0x29, 0x5b, 0xb6, 0xe9, 0x9a, 0xf8, 0x8c, 0x47, 0x54, 0xf6, 0x88,
	0xca, 0x3e, 0x51, 0xfe, 0xc2, 0x8e, 0xe6, 0xb6, 0x3a, 0xcd, 0xb2, 0x62, 0xb6, 0x67, 0x77, 0xcc,
	0x1d, 0x73, 0x96, 0xd1, 0x37, 0x3b, 0xdb, 0xec, 0x8b, 0x7d, 0xb0, 0x95, 0x27, 0x27, 0xff, 0xd4,
	0xa0, 0x32, 0xd3, 0x72, 0x35, 0xd3, 0xe0, 0x4a, 0xf2, 0x67, 0x07, 0x0f, 0x03, 0xfa, 0xf3, 0xe7,
	0x06, 0x8f, 0xf6, 0x64, 0x5d, 0x53, 0x65, 0x97, 0xf0, 0x53, 0x71, 0xe8, 0x54, 0x23, 0xb7, 0x1a,
	0x03, 0xa2, 0x8b, 0xff, 0x40, 0x90, 0xd9, 0x22, 0x76, 0xdd, 0x95, 0xdd, 0x8e, 0x73, 0x63, 0xdf,
	0x22, 0xf8, 0x1c, 0xa4, 0x14, 0xd3, 0x30, 0x88, 0xe2, 0x12, 0x55, 0x40, 0x22, 0x9a, 0x4e, 0x4a,
	0xfd, 0x0d, 0x8c, 0x21, 0xea, 0x68, 0x2e, 0x11, 0xc2, 0x22, 0x9a, 0x4e, 0x49, 0x6c, 0x8d, 0xe7,
	0x20, 0x4a, 0x4d, 0x12, 0x22, 0x22, 0x9a, 0xce, 0x2e, 0x9c, 0x2b, 0x0f, 0x86, 0x64, 0xa9, 0x17,
	0x12, 0x2a, 0x5d, 0x62, 0x94, 0xf8, 0x1a, 0x24, 0x1d, 0x62, 0xef, 0x69, 0x0a, 0x71, 0x84, 0xa8,
	0x18, 0x99, 0x4e, 0x2f, 0x94, 0xcb, 0xc7, 0x04, 0xd2, 0xe7, 0x27, 0x6a, 0xdd, 0x63, 0x61, 0x72,
	0x7c, 0xfe, 0xc5, 0xa7, 0xee, 0x77, 0xd1, 0x19, 0x78, 0x02, 0x60, 0x6b, 0x59, 0x12, 0x3d, 0x3f,
	0x70, 0x62, 0xbe, 0xb4, 0x50, 0xba, 0x58, 0xba, 0x54, 0x5c, 0x82, 0xf4, 0xa6, 0xa9, 0xae, 0x1a,
	0xdb, 0x26, 0xf3, 0xed, 0x69, 0x48, 0x5a, 0xa6, 0xda, 0x30, 0xe4, 0x36, 0x61, 0xae, 0xa5, 0xaa,
	0xd1, 0xaf, 0xba, 0x28, 0x24, 0x25, 0x2c, 0x53, 0xdd, 0x90, 0xdb, 0x04, 0x4f, 0x41, 0x58, 0xb3,
	0x3c, 0xe7, 0xf8, 0x51, 0x58, 0xb3, 0x8a, 0xef, 0xc0, 0xc4, 0xa6, 0x69, 0xbb, 0xbe, 0x98, 0xf3,
	0x10, 0xb5, 0x4c, 0xdb, 0x65, 0x22, 0x32, 0xd5, 0xcc, 0x07, 0xff, 0xbc, 0x17, 0x49, 0xce, 0xc4,
	0x85, 0x6f, 0xbe, 0x89, 0x4c, 0x23, 0x89, 0x1d, 0xe1, 0x3c, 0x24, 0x59, 0x80, 0x15, 0x53, 0xe7,
	0xb1, 0xf2, 0xbf, 0x71, 0x19, 0xd2, 0xae, 0x6c, 0xef, 0x10, 0xb7, 0xc1, 0xa4, 0x44, 0x46, 0x49,
	0x01, 0x8f, 0x82, 0xaa, 0x2d, 0xfe, 0x39, 0x09, 0x4f, 0x8c, 0x8c, 0x02, 0x9e, 0x83, 0x09, 0x1e,
	0x87, 0xa0, 0x4f, 0x19, 0x6a, 0x38, 0x15, 0x17, 0xb5, 0xc3, 0xc2, 0xeb, 0x52, 0x9a, 0x93, 0x30,
	0x07, 0x5f, 0x84, 0x14, 0xa5, 0x74, 0x2c, 0x59, 0xe1, 0x20, 0x0e, 0x93, 0xf7, 0xcf, 0x83, 0xe2,
	0x7d, 0x80, 0x8f, 0x15, 0xcf, 0x0c, 0x2a, 0x01, 0x28, 0x7a, 0xc7, 0x71, 0x89, 0xdd, 0xd0, 0x2c,
	0x21, 0x7a, 0x84, 0xde, 0x42, 0x52, 0x8a, 0x13, 0xac, 0x5a, 0xf8, 0x6d, 0x88, 0xeb, 0x72, 0x93,
	0xe8, 0x8e, 0x10, 0x63, 0x49, 0xb0, 0x78, 0xb2, 0x24, 0x28, 0x5f, 0x67, 0xcc, 0xcb, 0x86, 0x6b,
	0xef, 0x57, 0x9f, 0xa5, 0x1a, 0x62, 0xef, 0xa3, 0x70, 0x2e, 0x47, 0x57, 0xf0, 0x3e, 0x4a, 0xcc,
	0xc4, 0xec, 0xc8, 0x01, 0x42, 0x87, 0x9f, 0xfc, 0x2d, 0x12, 0xbf, 0x73, 0x17, 0x85, 0x93, 0x21,
	0x89, 0xeb, 0xc3, 0x15, 0x8a, 0xa0, 0xea, 0x08, 0x71, 0xa6, 0xf7, 0xd9, 0x63, 0xf5, 0x06, 0x92,
	0x47, 0x62, 0x1c, 0xf8, 0x17, 0x11, 0x9a, 0x43, 0xb6, 0xdb, 0x68, 0xcb, 0x96, 0x90, 0x60, 0xec,
	0x97, 0x4f, 0x68, 0x36, 0x05, 0x75, 0x5d, 0xb6, 0x3c, 0xbb, 0xff, 0x14, 0x7e, 0xf0, 0x0e, 0xfa,
	0xac, 0x8b, 0x10, 0xb5, 0x3a, 0xf3, 0x3e, 0x82, 0xa2, 0x9f, 0x04, 0xbd, 0x9d, 0x19, 0x7f, 0x87,
	0xba, 0x32, 0x7b, 0xe7, 0x2e, 0x7a, 0x11, 0xbf, 0xf0, 0x79, 0x17, 0x3d, 0xb7, 0x6a, 0x28, 0x66,
	0x5b, 0x33, 0x76, 0x44, 0x6a, 0x90, 0x68, 0x74, 0xda, 0x4d, 0x62, 0x8b, 0x6e, 0x4b, 0x76, 0x45,
	0x83, 0x10, 0xd5, 0x11, 0x6d, 0xd2, 0x96, 0x2d, 0xca, 0x53, 0xb8, 0x73, 0x17, 0xe5, 0xb1, 0x70,
	0xd8, 0x45, 0x53, 0x3e, 0x0f, 0xb5, 0x42, 0xdc, 0x60, 0x3c, 0x94, 0x04, 0xee, 0xdc, 0x45, 0x71,
	0x1c, 0xfd, 0xb0, 0x8b, 0x42, 0xfd, 0x80, 0x31, 0x85, 0x6f, 0xdd, 0xb9, 0x8b, 0xea, 0xf9, 0x9f,
	0x7c, 0xde, 0x45, 0xeb, 0x6f, 0x76, 0xdc, 0x1d, 0x73, 0xa4, 0xc2, 0x5b, 0x9a, 0xae, 0x8b, 0x3b,
	0xa6, 0xe8, 0x9a, 0x62, 0x0f, 0xdf, 0x4d, 0xb1, 0x57, 0xa3, 0xa2, 0x69, 0x8b, 0x86, 0xa9, 0x92,
	0x0b, 0x8c, 0xad, 0xb7, 0xeb, 0x1b, 0x96, 0x67, 0x86, 0xf9, 0xb2, 0x47, 0x19, 0x96, 0x67, 0x86,
	0x09, 0x88, 0x56, 0x2a, 0x0b, 0x1e, 0xbe, 0x0c, 0x31, 0xba, 0x74, 0x84, 0x24, 0xc3, 0xe0, 0xb9,
	0x31, 0x10, 0xf6, 0x2b, 0x57, 0xf2, 0x78, 0xf2, 0xaf, 0x42, 0x3a, 0x90, 0x3b, 0x38, 0x07, 0x91,
	0x5d, 0xb2, 0xef, 0x55, 0x8f, 0x44, 0x97, 0x78, 0x0a, 0x62, 0x7b, 0xb2, 0xde, 0xe9, 0xf5, 0x39,
	0xef, 0x63, 0x31, 0x5c, 0x41, 0xf9, 0x45, 0xaf, 0x17, 0xf4, 0xf0, 0x0b, 0xf2, 0x66, 0x46, 0xf0,
	0x66, 0x02, 0xbc, 0x8b, 0xe4, 0xa3, 0x2e, 0x92, 0xe1, 0x2c, 0x24, 0x78, 0x36, 0xe4, 0xb3, 0x83,
	0xf5, 0x0b, 0x02, 0xa4, 0x36, 0x7a, 0xd5, 0x97, 0x4f, 0x07, 0x4a, 0x15, 0x9e, 0x84, 0x28, 0x75,
	0x20, 0xc8, 0x41, 0x4b, 0x12, 0x30, 0x84, 0x57, 0x37, 0xf3, 0x13, 0xc1, 0xb2, 0x2b, 0xbe, 0x1b,
	0x85, 0xd3, 0x37, 0xae, 0xd7, 0x6b, 0xba, 0x46, 0x0c, 0xb7, 0x66, 0x1a, 0xdb, 0xda, 0x0e, 0x2b,
	0xce, 0x0a, 0xb0, 0x5a, 0x25, 0x76, 0xb0, 0x59, 0x9c, 0xe9, 0x55, 0x67, 0xcc, 0x8e, 0x08, 0xb7,
	0xc3, 0xbc, 0x4e, 0x5b, 0x48, 0x02, 0x8f, 0x96, 0x75, 0x8d, 0x75, 0x98, 0x54, 0x88, 0xed, 0x6a,
	0xdb, 0x9a, 0x22, 0xbb, 0xa4, 0xd1, 0xb1, 0xbd, 0xa6, 0x96, 0x5e, 0x38, 0x3b, 0x14, 0xf6, 0x3a,
	0x51, 0x6c, 0xe2, 0x52, 0x6d, 0xd5, 0x14, 0xcf, 0x6b, 0x01, 0x49, 0xd9, 0x00, 0xf3, 0x4d, 0x5b,
	0xc7, 0xd7, 0x20, 0x1d, 0xd8, 0x11, 0x62, 0xcc, 0x90, 0xe9, 0xaf, 0xba, 0x28, 0xfa, 0xfb, 0xbb,
	0x28, 0x6d, 0x91, 0x76, 0x49, 0x6c, 0xca, 0x0e, 0x79, 0xf9, 0x12, 0xb5, 0x26, 0x6e, 0x47, 0xa7,
	0x6f, 0xdf, 0x4e, 0x72, 0x13, 0xdf, 0x43, 0x48, 0x0a, 0x32, 0xe3, 0x0a, 0x24, 0x76, 0xc9, 0x3e,
	0x33, 0x29, 0xf2, 0x28, 0x93, 0xa2, 0x07, 0x5d, 0x84, 0xa4, 0xf8, 0x2e, 0xd9, 0xa7, 0x56, 0x48,
	0x80, 0x15, 0xb9, 0x31, 0xec, 0x57, 0xf4, 0x04, 0x7e, 0xe5, 0x14, 0xb9, 0x36, 0xe8, 0xd9, 0x06,
	0x64, 0x5d, 0x9b, 0x02, 0xa1, 0x36, 0x14, 0x99, 0xc9, 0x8b, 0x9f, 0xd0, 0xb9, 0x09, 0xce, 0x5f,
	0x93, 0x6f, 0xda, 0xfa, 0x62, 0xe5, 0x7e, 0x17, 0x5d, 0x02, 0x01, 0x4e, 0xd5, 0x19, 0x18, 0xe2,
	0xa6, 0x6c, 0xcb, 0x6d, 0xe2, 0x12, 0xdb, 0xc1, 0x91, 0xf9, 0xd2, 0xcb, 0xf4, 0xc4, 0x83, 0x79,
	0xe0, 0xe4, 0xa5, 0xd2, 0xc5, 0xe2, 0xef, 0x10, 0x64, 0x25, 0xe2, 0x04, 0xf1, 0x7f, 0x05, 0x40,
	0xb6, 0xb4, 0x86, 0x87, 0x2b, 0x87, 0x5f, 0x08, 0xc2, 0xff, 0xcb, 0x30, 0x5f, 0x7d, 0x82, 0x90,
	0x94, 0x92, 0x2d, 0xcd, 0xd3, 0x8a, 0xd7, 0x21, 0xe9, 0xea, 0x4e, 0x43, 0x33, 0xb6, 0x4d, 0x8e,
	0x7b, 0xe9, 0xd8, 0x72, 0x1b, 0x91, 0x78, 0x3c, 0xee, 0x09, 0x57, 0x77, 0x68, 0x21, 0x16, 0xff,
	0x12, 0x81, 0xcc, 0x5a, 0xa5, 0x7e, 0x45, 0x51, 0x88, 0xc3, 0x76, 0xf0, 0x0a, 0x64, 0x77, 0x3b,
	0x4d, 0xa2, 0x30, 0x16, 0x16, 0x36, 0xf4, 0xad, 0xb0, 0x5c, 0x09, 0x49, 0x99, 0x3e, 0xa3, 0x07,
	0xea, 0x24, 0x1f, 0x56, 0x34, 0xd3, 0x08, 0x5a, 0xfc, 0xfc, 0xb1, 0x16, 0x0f, 0x46, 0x69, 0x25,
	0x24, 0x65, 0xfb, 0x12, 0x98, 0x75, 0xd3, 0x00, 0x9a, 0xd1, 0xe0, 0x05, 0xc6, 0xb2, 0x2c, 0x59,
	0x4d, 0xf0, 0x2c, 0x58, 0x09, 0x49, 0x29, 0xcd, 0xa8, 0x79, 0x67, 0xb8, 0x02, 0x49, 0xcd, 0x31,
	0x75, 0x99, 0x8e, 0x4e, 0x5e, 0x22, 0x4d, 0x0d, 0xa9, 0x5d, 0x6e, 0x5b, 0xee, 0x7e, 0x35, 0x7a,
	0x8f, 0xb2, 0x22, 0xc9, 0xa7, 0xc6, 0x8b, 0x90, 0xb2, 0x89, 0xac, 0xb4, 0xe4, 0xa6, 0xee, 0x15,
	0xc4, 0xa3, 0x58, 0xfb, 0xe4, 0x8b, 0xc9, 0x2f, 0x5f, 0x8b, 0xcd, 0xcf, 0x95, 0xe6, 0xe7, 0xab,
	0x05, 0x48, 0xf3, 0x18, 0xb2, 0x31, 0x6b, 0x92, 0xd2, 0x1e, 0x74, 0x11, 0x1c, 0x76, 0x51, 0x64,
	0xbe, 0xb4, 0x50, 0xbd, 0x00, 0x4f, 0xee, 0x56, 0x9c, 0x06, 0x9b, 0x81, 0x88, 0x7b, 0xcb, 0xb4,
	0x77, 0x1b, 0x4a, 0xcb, 0xd4, 0x14, 0x82, 0x4f, 0xdf, 0xeb, 0x22, 0xda, 0x63, 0x29, 0x79, 0x9a,
	0x92, 0x5f, 0x2a, 0xbd, 0x74, 0x2d, 0x9a, 0x84, 0x5c, 0xfa, 0x5a, 0x34, 0x99, 0xce, 0x4d, 0x14,
	0x7f, 0x8d, 0xe0, 0xa9, 0x9a, 0x69, 0x38, 0x1d, 0x7d, 0xc5, 0x75, 0xad, 0xaa, 0xec, 0x68, 0xca,
	0x95, 0x8e, 0xdb, 0xf2, 0x67, 0xa2, 0x19, 0x48, 0x75, 0x9c, 0xc1, 0xd6, 0x32, 0x34, 0x28, 0x24,
	0xe9, 0x39, 0x6b, 0x27, 0xaf, 0x01, 0x58, 0xb2, 0xe3, 0xdc, 0x52, 0xbf, 0x5d, 0x27, 0xf1, 0xd2,
	0x27, 0xe5, 0xb1, 0xdc, 0xb4, 0xf5, 0xe2, 0x6f, 0xc3, 0x90, 0xf3, 0x6c, 0x09, 0xe4, 0xd0, 0xe6,
	0x51, 0xe4, 0xd1, 0x89, 0x90, 0x3f, 0x82, 0xfb, 0x1b, 0x10, 0x67, 0x2c, 0x5e, 0x27, 0xcf, 0x2e,
	0x3c, 0x73, 0xac, 0xa0, 0x3a, 0x23, 0x1b, 0x6e, 0x0f, 0x9c, 0x1b, 0x13, 0x98, 0x6a, 0xb9, 0xae,
	0xd5, 0x68, 0xd2, 0xa0, 0x35, 0xe4, 0x8e, 0xdb, 0xf2, 0xcc, 0xf3, 0xfa, 0xd5, 0xa5, 0x63, 0xa5,
	0x8e, 0x09, 0xb7, 0x74, 0xaa, 0x35, 0xbc, 0x5d, 0xfc, 0x6b, 0x18, 0xa6, 0xb6, 0x34, 0xcb, 0x9f,
	0xb7, 0x7d, 0x68, 0x16, 0x00, 0x5b, 0x9d, 0xa6, 0xae, 0x39, 0xad, 0xc6, 0x9e, 0x66, 0xbb, 0x1d,
	0x59, 0xa7, 0xc3, 0x19, 0x1b, 0xed, 0xf9, 0x90, 0x9b, 0xe3, 0xe7, 0x5b, 0xde, 0xf1, 0xaa, 0x85,
	0x57, 0xf9, 0x4c, 0xef, 0x79, 0x3e, 0x7b, 0xac, 0x8d, 0x3d, 0x8e, 0xcd, 0x81, 0x31, 0x9f, 0x8b,
	0xf5, 0x86, 0xfd, 0x12, 0xa4, 0x9c, 0x4e, 0x53, 0x35, 0xdb, 0xb2, 0x66, 0xf0, 0x11, 0x32, 0x3b,
	0x78, 0xe9, 0x48, 0x7d, 0x02, 0xbc, 0x04, 0x49, 0xd5, 0x70, 0x1a, 0x6d, 0x53, 0x25, 0xac, 0x84,
	0xc6, 0x85, 0x7d, 0xad, 0x52, 0x5f, 0xda, 0xa8, 0xaf, 0x9b, 0x6a, 0x4f, 0x61, 0x42, 0x35, 0x1c,
	0xfa, 0x39, 0x38, 0xe6, 0xc6, 0xc6, 0x8f, 0xb9, 0xc5, 0x1f, 0x43, 0x76, 0xad, 0x52, 0xdf, 0xf4,
	0x42, 0xc0, 0x22, 0x36, 0xc0, 0x8e, 0x1e, 0xc1, 0xfe, 0x2b, 0x04, 0xa7, 0xa8, 0x25, 0x44, 0x27,
	0x3b, 0x32, 0x4d, 0x9e, 0x1b, 0x47, 0xbc, 0x46, 0x27, 0xf1, 0x3a, 0xfc, 0x9f, 0x7a, 0x5d, 0xfc,
	0x38, 0x0c, 0x67, 0xd6, 0x2a, 0xf5, 0x91, 0x49, 0x30, 0x07, 0x09, 0x55, 0x73, 0x58, 0x7b, 0x09,
	0x1f, 0xdf, 0x5e, 0x56, 0xa8, 0x34, 0x8f, 0x0c, 0xd7, 0x20, 0xc1, 0xd3, 0x82, 0x67, 0xea, 0xf3,
	0xe3, 0x4c, 0x0a, 0x84, 0x8f, 0x0a, 0xe1, 0x9c, 0xf8, 0x32, 0x64, 0x7a, 0xb9, 0xb7, 0xfd, 0x73,
	0xd5, 0x70, 0xc6, 0xb5, 0xc5, 0x95, 0x90, 0x34, 0xc1, 0x89, 0xdf, 0xa0, 0xb4, 0xb8, 0x0e, 0x59,
	0x1a, 0x15, 0xd5, 0x8f, 0x2c, 0xef, 0x8c, 0x33, 0x63, 0x63, 0x33, 0x80, 0x03, 0xbd, 0x21, 0x54,
	0xc3, 0xe9, 0x6f, 0x56, 0x9f, 0x83, 0x6c, 0xcf, 0xa2, 0x40, 0xef, 0x0b, 0xd3, 0x1e, 0x73, 0xd8,
	0x45, 0x09, 0xf6, 0x6e, 0x64, 0xbd, 0x0f, 0xe5, 0xc2, 0xc5, 0x3f, 0x22, 0xc8, 0x7b, 0x65, 0xf8,
	0x98, 0x82, 0x3a, 0x37, 0x1c, 0xd4, 0x63, 0x39, 0x38, 0x59, 0xf5, 0xfc, 0x11, 0x7b, 0x27, 0x03,
	0xf6, 0x46, 0x16, 0x4a, 0x17, 0xb9, 0xad, 0x5f, 0x22, 0xc8, 0x51, 0xff, 0x83, 0x85, 0x88, 0xaf,
	0x42, 0x5a, 0x66, 0x3d, 0x32, 0xd8, 0x11, 0x7f, 0x38, 0x2e, 0x7e, 0xfd, 0x96, 0x2a, 0x81, 0xdc,
	0x6f, 0xaf, 0x75, 0xe8, 0x61, 0x13, 0xbc, 0x55, 0xe7, 0xc6, 0x49, 0x1a, 0x15, 0x32, 0x29, 0xcd,
	0xa5, 0xd0, 0x8d, 0xc5, 0xd7, 0xef, 0x77, 0xd1, 0x8f, 0xe0, 0x0c, 0x60, 0x4f, 0xa9, 0x58, 0xb3,
	0x89, 0x4a, 0x0c, 0x57, 0x93, 0x75, 0x07, 0xa3, 0x79, 0x38, 0x0f, 0xe7, 0xb6, 0x56, 0x37, 0x45,
	0x9e, 0x5a, 0xf4, 0x6d, 0xe0, 0x75, 0xeb, 0x8e, 0xcd, 0xa0, 0xc4, 0x68, 0xa1, 0xf8, 0x2f, 0x04,
	0xa7, 0x3d, 0x80, 0x06, 0xfd, 0xbe, 0x36, 0xca, 0xef, 0x17, 0x1e, 0xd1, 0x6a, 0x8f, 0x71, 0x7d,
	0x6b, 0xa4, 0xeb, 0x17, 0x1f, 0x21, 0xec, 0xbf, 0xe1, 0xfd, 0x07, 0x09, 0xc8, 0x5e, 0xd5, 0xcd,
	0xa6, 0xac, 0xd7, 0x2d, 0xa2, 0x30, 0xc7, 0x2f, 0x43, 0xec, 0x56, 0x8b, 0xd8, 0x84, 0xbb, 0x3c,
	0xfc, 0x2e, 0xda, 0xf0, 0xae, 0xfd, 0xba, 0xe6, 0x12, 0x89, 0x6c, 0xd7, 0x89, 0x4e, 0x14, 0xd7,
	0xb4, 0x25, 0x8f, 0x07, 0x6f, 0x41, 0xc6, 0x77, 0xa3, 0xb1, 0x5b, 0xa1, 0x8f, 0xab, 0xf1, 0x71,
	0x1b, 0xce, 0x37, 0x7f, 0x2c, 0x9b, 0xf0, 0x69, 0xd6, 0x2a, 0x0e, 0x6e, 0x40, 0xae, 0x2f, 0x57,
	0x61, 0xe1, 0x11, 0x52, 0x8f, 0x18, 0x24, 0x47, 0xa0, 0xea, 0x4b, 0x9f, 0xf4, 0xc9, 0x3c, 0x2a,
	0xfc, 0xea, 0xc0, 0x75, 0x35, 0xf6, 0x27, 0x28, 0x7f, 0x74, 0xe3, 0xd7, 0xd3, 0x5b, 0x90, 0xee,
	0xdf, 0x8e, 0x16, 0xaf, 0xca, 0x0b, 0x63, 0x2e, 0xbc, 0xa3, 0xb0, 0xf6, 0x45, 0x82, 0x7f, 0x91,
	0x5a, 0xb8, 0x06, 0x11, 0x1a, 0xc2, 0xe8, 0x49, 0x4a, 0xae, 0x3f, 0x57, 0x22, 0x89, 0x72, 0xe3,
	0xeb, 0x10, 0xe7, 0xf1, 0x8a, 0x9d, 0x30, 0x85, 0x83, 0xa2, 0xb8, 0x0c, 0xfc, 0x06, 0x60, 0xff,
	0x9d, 0xc8, 0x52, 0x6d, 0x5b, 0x23, 0xb6, 0x00, 0xde, 0x43, 0x90, 0x93, 0x0f, 0x5e, 0x52, 0x02,
	0x92, 0x4e, 0xf5, 0x1e, 0xf4, 0x3e, 0x07, 0x5e, 0x84, 0x8c, 0x61, 0x36, 0xfa, 0xa2, 0x84, 0x89,
	0x31, 0xbd, 0x2c, 0x2c, 0xa5, 0x0d, 0xb3, 0xd6, 0x93, 0x81, 0x67, 0x03, 0x6f, 0x55, 0x55, 0xc8,
	0x8c, 0xba, 0x19, 0x57, 0xc2, 0xfd, 0x5f, 0x89, 0xd4, 0xc5, 0xb5, 0xfb, 0x5d, 0x74, 0x15, 0x00,
	0x62, 0x6f, 0xb1, 0x1c, 0x45, 0xf3, 0xf0, 0x04, 0xe4, 0x7c, 0x0c, 0xc4, 0x75, 0xe2, 0xb6, 0x4c,
	0x15, 0xa3, 0x57, 0xa0, 0x08, 0xe7, 0xfa, 0xdb, 0x5c, 0xa1, 0x18, 0xb0, 0x3a, 0x3c, 0x3f, 0x5f,
	0x7d, 0x66, 0x20, 0x13, 0xfb, 0xfd, 0x34, 0x79, 0xd0, 0x45, 0x09, 0xda, 0x4f, 0x2b, 0xa5, 0x57,
	0xab, 0xc5, 0x81, 0xe6, 0xe1, 0xcd, 0xc6, 0x07, 0x5d, 0x14, 0xe7, 0x73, 0xf1, 0x17, 0x5d, 0x84,
	0xaa, 0x65, 0x38, 0x7b, 0x34, 0x94, 0x3d, 0x89, 0xa7, 0xee, 0x75, 0xd1, 0x04, 0x9f, 0xa4, 0x63,
	0xf3, 0x0b, 0xa5, 0x79, 0xda, 0xa3, 0x13, 0xb9, 0xe4, 0xb5, 0x68, 0x32, 0x9e, 0x4b, 0xf0, 0x89,
	0xfa, 0x20, 0x02, 0xd9, 0x9a, 0x4d, 0x64, 0x97, 0x3c, 0x9e, 0xe2, 0xdd, 0xfc, 0xae, 0xc5, 0x7b,
	0xa4, 0x6c, 0x7f, 0xfa, 0x78, 0xca, 0x76, 0x54, 0xc1, 0x9e, 0x28, 0x83, 0xd0, 0x60, 0x06, 0x3d,
	0x7d, 0x34, 0x83, 0x56, 0x50, 0x30, 0x63, 0x4e, 0x7d, 0xf4, 0xda, 0x50, 0x5b, 0xac, 0x4e, 0x8f,
	0xc0, 0x7d, 0xea, 0xdd, 0xaf, 0xd1, 0x91, 0xdd, 0xea, 0xe2, 0x38, 0x60, 0x7f, 0xf0, 0xee, 0xd7,
	0xe8, 0xf8, 0xe3, 0xe2, 0xdf, 0x23, 0x30, 0x29, 0x11, 0x4b, 0x97, 0x95, 0xef, 0x31, 0xfd, 0x7f,
	0xc1, 0xf4, 0xe3, 0x28, 0xa4, 0xaf, 0x12, 0xf7, 0xf1, 0xe0, 0x39, 0xf7, 0xed, 0xef, 0x29, 0x7e,
	0x3d, 0x6d, 0x7c, 0xf7, 0xeb, 0x69, 0xe0, 0x56, 0xfa, 0x3e, 0xa3, 0xfe, 0xd7, 0x19, 0x35, 0x73,
	0x1e, 0xa0, 0xff, 0x83, 0x01, 0x4e, 0x42, 0x74, 0xe5, 0xc6, 0x8d, 0xcd, 0x5c, 0x08, 0xa7, 0x20,
	0x46, 0x57, 0xf5, 0x1c, 0x9a, 0xb9, 0x02, 0x4f, 0x8e, 0x7e, 0x59, 0x63, 0x0c, 0xd9, 0xa5, 0x8d,
	0x7a, 0x63, 0x69, 0xf9, 0xfa, 0xf2, 0xd5, 0x2b, 0x37, 0x56, 0xdf, 0xdc, 0xc8, 0x85, 0xf0, 0x69,
	0x98, 0xdc, 0xbc, 0x59, 0xbd, 0xbe, 0x5a, 0x5f, 0x69, 0xd4, 0x97, 0xa5, 0xad, 0xd5, 0xda, 0x72,
	0x0e, 0xcd, 0x4c, 0x03, 0xf4, 0x5f, 0x8a, 0x78, 0x02, 0x92, 0xb5, 0x37, 0xa5, 0xe5, 0xc6, 0xd2,
	0x46, 0x3d, 0x17, 0xa2, 0x5f, 0x6b, 0x37, 0xab, 0xde, 0x17, 0xaa, 0xfe, 0x06, 0x1d, 0x7c, 0x5a,
	0x08, 0x3d, 0xf8, 0xb4, 0x10, 0xfa, 0xe2, 0xd3, 0x02, 0xba, 0x7d, 0x58, 0x40, 0x7f, 0x38, 0x2c,
	0xa0, 0x0f, 0x0f, 0x0b, 0xe8, 0xe0, 0xb0, 0x80, 0x1e, 0x1c, 0x16, 0xd0, 0x27, 0x87, 0x05, 0xf4,
	0xd9, 0x61, 0x21, 0xf4, 0xc5, 0x61, 0x01, 0xbd, 0xf7, 0xb0, 0x10, 0xba, 0xf7, 0xb0, 0x80, 0x0e,
	0x1e, 0x16, 0x42, 0x0f, 0x1e, 0x16, 0x42, 0x3f, 0x5b, 0xdf, 0x31, 0xad, 0xdd, 0x9d, 0xf2, 0x9e,
	0xa9, 0xbb, 0xc4, 0xb6, 0xe5, 0x72, 0xc7, 0x99, 0x65, 0x8b, 0x6d, 0xd3, 0x6e, 0x5f, 0xb0, 0x6c,
	0x73, 0x4f, 0x53, 0x89, 0x7d, 0xa1, 0x77, 0x3c, 0x6b, 0x35, 0x77, 0xcc, 0x59, 0xf2, 0xb6, 0xcb,
	0xff, 0x93, 0x1c, 0xfe, 0x77, 0xb5, 0x19, 0x67, 0xff, 0x93, 0x5d, 0xfc, 0x77, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xa6, 0x31, 0x54, 0x0c, 0x7f, 0x1d, 0x00, 0x00,
}

func (x SchemeType) String() string {
	s, ok := SchemeType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x VirtualIPDiscoveryType) String() string {
	s, ok := VirtualIPDiscoveryType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x K8SDNSMode) String() string {
	s, ok := K8SDNSMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *VerStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VerStatusType)
	if !ok {
		that2, ok := that.(VerStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Connected != that1.Connected {
		return false
	}
	if this.Site != that1.Site {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.Services) != len(that1.Services) {
		return false
	}
	for i := range this.Services {
		if !this.Services[i].Equal(that1.Services[i]) {
			return false
		}
	}
	return true
}
func (this *PodInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodInfoType)
	if !ok {
		that2, ok := that.(PodInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PodName != that1.PodName {
		return false
	}
	if this.Ip != that1.Ip {
		return false
	}
	return true
}
func (this *PortInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortInfoType)
	if !ok {
		that2, ok := that.(PortInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if this.TargetPort != that1.TargetPort {
		return false
	}
	return true
}
func (this *DiscoveredServiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DiscoveredServiceType)
	if !ok {
		that2, ok := that.(DiscoveredServiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServiceName != that1.ServiceName {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.ServiceType != that1.ServiceType {
		return false
	}
	if this.ClusterIp != that1.ClusterIp {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Pods) != len(that1.Pods) {
		return false
	}
	for i := range this.Pods {
		if !this.Pods[i].Equal(that1.Pods[i]) {
			return false
		}
	}
	if len(this.PortMap) != len(that1.PortMap) {
		return false
	}
	for i := range this.PortMap {
		if this.PortMap[i] != that1.PortMap[i] {
			return false
		}
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if !this.Ports[i].Equal(that1.Ports[i]) {
			return false
		}
	}
	return true
}
func (this *TLSClientConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TLSClientConfigType)
	if !ok {
		that2, ok := that.(TLSClientConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	if !this.CertificateUrl.Equal(that1.CertificateUrl) {
		return false
	}
	if this.Certificate != that1.Certificate {
		return false
	}
	if !this.KeyUrl.Equal(that1.KeyUrl) {
		return false
	}
	if !this.CaCertificateUrl.Equal(that1.CaCertificateUrl) {
		return false
	}
	if this.TrustedCaUrl != that1.TrustedCaUrl {
		return false
	}
	return true
}
func (this *RestConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RestConfigType)
	if !ok {
		that2, ok := that.(RestConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ApiServer != that1.ApiServer {
		return false
	}
	if !this.TlsInfo.Equal(that1.TlsInfo) {
		return false
	}
	return true
}
func (this *K8SAccessInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SAccessInfo)
	if !ok {
		that2, ok := that.(K8SAccessInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ConfigType == nil {
		if this.ConfigType != nil {
			return false
		}
	} else if this.ConfigType == nil {
		return false
	} else if !this.ConfigType.Equal(that1.ConfigType) {
		return false
	}
	if that1.K8SPodNetworkChoice == nil {
		if this.K8SPodNetworkChoice != nil {
			return false
		}
	} else if this.K8SPodNetworkChoice == nil {
		return false
	} else if !this.K8SPodNetworkChoice.Equal(that1.K8SPodNetworkChoice) {
		return false
	}
	return true
}
func (this *K8SAccessInfo_KubeconfigUrl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SAccessInfo_KubeconfigUrl)
	if !ok {
		that2, ok := that.(K8SAccessInfo_KubeconfigUrl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.KubeconfigUrl.Equal(that1.KubeconfigUrl) {
		return false
	}
	return true
}
func (this *K8SAccessInfo_ConnectionInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SAccessInfo_ConnectionInfo)
	if !ok {
		that2, ok := that.(K8SAccessInfo_ConnectionInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ConnectionInfo.Equal(that1.ConnectionInfo) {
		return false
	}
	return true
}
func (this *K8SAccessInfo_InCluster) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SAccessInfo_InCluster)
	if !ok {
		that2, ok := that.(K8SAccessInfo_InCluster)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.InCluster != that1.InCluster {
		return false
	}
	return true
}
func (this *K8SAccessInfo_Isolated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SAccessInfo_Isolated)
	if !ok {
		that2, ok := that.(K8SAccessInfo_Isolated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Isolated.Equal(that1.Isolated) {
		return false
	}
	return true
}
func (this *K8SAccessInfo_Reachable) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SAccessInfo_Reachable)
	if !ok {
		that2, ok := that.(K8SAccessInfo_Reachable)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Reachable.Equal(that1.Reachable) {
		return false
	}
	return true
}
func (this *ConsulHttpBasicAuthInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsulHttpBasicAuthInfoType)
	if !ok {
		that2, ok := that.(ConsulHttpBasicAuthInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UserName != that1.UserName {
		return false
	}
	if !this.PasswdUrl.Equal(that1.PasswdUrl) {
		return false
	}
	return true
}
func (this *ConsulAccessInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsulAccessInfo)
	if !ok {
		that2, ok := that.(ConsulAccessInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ConnectionInfo.Equal(that1.ConnectionInfo) {
		return false
	}
	if this.Scheme != that1.Scheme {
		return false
	}
	if !this.HttpBasicAuthInfo.Equal(that1.HttpBasicAuthInfo) {
		return false
	}
	return true
}
func (this *VipDiscoveryInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VipDiscoveryInfoType)
	if !ok {
		that2, ok := that.(VipDiscoveryInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PublishVirtualIp != that1.PublishVirtualIp {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Subdomain != that1.Subdomain {
		return false
	}
	if this.DnsMode != that1.DnsMode {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	return true
}
func (this *K8SPublishType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SPublishType)
	if !ok {
		that2, ok := that.(K8SPublishType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	return true
}
func (this *K8SDelegationType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SDelegationType)
	if !ok {
		that2, ok := that.(K8SDelegationType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Subdomain != that1.Subdomain {
		return false
	}
	if this.DnsMode != that1.DnsMode {
		return false
	}
	return true
}
func (this *K8SVipDiscoveryInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SVipDiscoveryInfoType)
	if !ok {
		that2, ok := that.(K8SVipDiscoveryInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PublishChoice == nil {
		if this.PublishChoice != nil {
			return false
		}
	} else if this.PublishChoice == nil {
		return false
	} else if !this.PublishChoice.Equal(that1.PublishChoice) {
		return false
	}
	return true
}
func (this *K8SVipDiscoveryInfoType_Disable) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SVipDiscoveryInfoType_Disable)
	if !ok {
		that2, ok := that.(K8SVipDiscoveryInfoType_Disable)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Disable.Equal(that1.Disable) {
		return false
	}
	return true
}
func (this *K8SVipDiscoveryInfoType_Publish) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SVipDiscoveryInfoType_Publish)
	if !ok {
		that2, ok := that.(K8SVipDiscoveryInfoType_Publish)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Publish.Equal(that1.Publish) {
		return false
	}
	return true
}
func (this *K8SVipDiscoveryInfoType_PublishFqdns) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SVipDiscoveryInfoType_PublishFqdns)
	if !ok {
		that2, ok := that.(K8SVipDiscoveryInfoType_PublishFqdns)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PublishFqdns.Equal(that1.PublishFqdns) {
		return false
	}
	return true
}
func (this *K8SVipDiscoveryInfoType_DnsDelegation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SVipDiscoveryInfoType_DnsDelegation)
	if !ok {
		that2, ok := that.(K8SVipDiscoveryInfoType_DnsDelegation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DnsDelegation.Equal(that1.DnsDelegation) {
		return false
	}
	return true
}
func (this *ConsulVipDiscoveryInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsulVipDiscoveryInfoType)
	if !ok {
		that2, ok := that.(ConsulVipDiscoveryInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PublishChoice == nil {
		if this.PublishChoice != nil {
			return false
		}
	} else if this.PublishChoice == nil {
		return false
	} else if !this.PublishChoice.Equal(that1.PublishChoice) {
		return false
	}
	return true
}
func (this *ConsulVipDiscoveryInfoType_Disable) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsulVipDiscoveryInfoType_Disable)
	if !ok {
		that2, ok := that.(ConsulVipDiscoveryInfoType_Disable)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Disable.Equal(that1.Disable) {
		return false
	}
	return true
}
func (this *ConsulVipDiscoveryInfoType_Publish) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsulVipDiscoveryInfoType_Publish)
	if !ok {
		that2, ok := that.(ConsulVipDiscoveryInfoType_Publish)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Publish.Equal(that1.Publish) {
		return false
	}
	return true
}
func (this *K8SDiscoveryType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SDiscoveryType)
	if !ok {
		that2, ok := that.(K8SDiscoveryType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AccessInfo.Equal(that1.AccessInfo) {
		return false
	}
	if !this.PublishInfo.Equal(that1.PublishInfo) {
		return false
	}
	return true
}
func (this *ConsulDiscoveryType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsulDiscoveryType)
	if !ok {
		that2, ok := that.(ConsulDiscoveryType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AccessInfo.Equal(that1.AccessInfo) {
		return false
	}
	if !this.PublishInfo.Equal(that1.PublishInfo) {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Where.Equal(that1.Where) {
		return false
	}
	if that1.DiscoveryChoice == nil {
		if this.DiscoveryChoice != nil {
			return false
		}
	} else if this.DiscoveryChoice == nil {
		return false
	} else if !this.DiscoveryChoice.Equal(that1.DiscoveryChoice) {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.PublishVip.Equal(that1.PublishVip) {
		return false
	}
	if that1.AccessInfo == nil {
		if this.AccessInfo != nil {
			return false
		}
	} else if this.AccessInfo == nil {
		return false
	} else if !this.AccessInfo.Equal(that1.AccessInfo) {
		return false
	}
	if this.ClusterIdentifier != that1.ClusterIdentifier {
		return false
	}
	if that1.ClusterIdentifierChoice == nil {
		if this.ClusterIdentifierChoice != nil {
			return false
		}
	} else if this.ClusterIdentifierChoice == nil {
		return false
	} else if !this.ClusterIdentifierChoice.Equal(that1.ClusterIdentifierChoice) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DiscoveryK8S) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DiscoveryK8S)
	if !ok {
		that2, ok := that.(GlobalSpecType_DiscoveryK8S)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryK8S.Equal(that1.DiscoveryK8S) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DiscoveryConsul) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DiscoveryConsul)
	if !ok {
		that2, ok := that.(GlobalSpecType_DiscoveryConsul)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryConsul.Equal(that1.DiscoveryConsul) {
		return false
	}
	return true
}
func (this *GlobalSpecType_K8S) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_K8S)
	if !ok {
		that2, ok := that.(GlobalSpecType_K8S)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.K8S.Equal(that1.K8S) {
		return false
	}
	return true
}
func (this *GlobalSpecType_Consul) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Consul)
	if !ok {
		that2, ok := that.(GlobalSpecType_Consul)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Consul.Equal(that1.Consul) {
		return false
	}
	return true
}
func (this *GlobalSpecType_NoClusterId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_NoClusterId)
	if !ok {
		that2, ok := that.(GlobalSpecType_NoClusterId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoClusterId.Equal(that1.NoClusterId) {
		return false
	}
	return true
}
func (this *GlobalSpecType_ClusterId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ClusterId)
	if !ok {
		that2, ok := that.(GlobalSpecType_ClusterId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClusterId != that1.ClusterId {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Where.Equal(that1.Where) {
		return false
	}
	if that1.DiscoveryChoice == nil {
		if this.DiscoveryChoice != nil {
			return false
		}
	} else if this.DiscoveryChoice == nil {
		return false
	} else if !this.DiscoveryChoice.Equal(that1.DiscoveryChoice) {
		return false
	}
	if that1.ClusterIdentifierChoice == nil {
		if this.ClusterIdentifierChoice != nil {
			return false
		}
	} else if this.ClusterIdentifierChoice == nil {
		return false
	} else if !this.ClusterIdentifierChoice.Equal(that1.ClusterIdentifierChoice) {
		return false
	}
	return true
}
func (this *CreateSpecType_DiscoveryK8S) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DiscoveryK8S)
	if !ok {
		that2, ok := that.(CreateSpecType_DiscoveryK8S)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryK8S.Equal(that1.DiscoveryK8S) {
		return false
	}
	return true
}
func (this *CreateSpecType_DiscoveryConsul) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DiscoveryConsul)
	if !ok {
		that2, ok := that.(CreateSpecType_DiscoveryConsul)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryConsul.Equal(that1.DiscoveryConsul) {
		return false
	}
	return true
}
func (this *CreateSpecType_NoClusterId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_NoClusterId)
	if !ok {
		that2, ok := that.(CreateSpecType_NoClusterId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoClusterId.Equal(that1.NoClusterId) {
		return false
	}
	return true
}
func (this *CreateSpecType_ClusterId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ClusterId)
	if !ok {
		that2, ok := that.(CreateSpecType_ClusterId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClusterId != that1.ClusterId {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Where.Equal(that1.Where) {
		return false
	}
	if that1.DiscoveryChoice == nil {
		if this.DiscoveryChoice != nil {
			return false
		}
	} else if this.DiscoveryChoice == nil {
		return false
	} else if !this.DiscoveryChoice.Equal(that1.DiscoveryChoice) {
		return false
	}
	if that1.ClusterIdentifierChoice == nil {
		if this.ClusterIdentifierChoice != nil {
			return false
		}
	} else if this.ClusterIdentifierChoice == nil {
		return false
	} else if !this.ClusterIdentifierChoice.Equal(that1.ClusterIdentifierChoice) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DiscoveryK8S) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DiscoveryK8S)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DiscoveryK8S)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryK8S.Equal(that1.DiscoveryK8S) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DiscoveryConsul) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DiscoveryConsul)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DiscoveryConsul)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryConsul.Equal(that1.DiscoveryConsul) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_NoClusterId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_NoClusterId)
	if !ok {
		that2, ok := that.(ReplaceSpecType_NoClusterId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoClusterId.Equal(that1.NoClusterId) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ClusterId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ClusterId)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ClusterId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClusterId != that1.ClusterId {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Where.Equal(that1.Where) {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.PublishVip.Equal(that1.PublishVip) {
		return false
	}
	if that1.DiscoveryChoice == nil {
		if this.DiscoveryChoice != nil {
			return false
		}
	} else if this.DiscoveryChoice == nil {
		return false
	} else if !this.DiscoveryChoice.Equal(that1.DiscoveryChoice) {
		return false
	}
	if that1.ClusterIdentifierChoice == nil {
		if this.ClusterIdentifierChoice != nil {
			return false
		}
	} else if this.ClusterIdentifierChoice == nil {
		return false
	} else if !this.ClusterIdentifierChoice.Equal(that1.ClusterIdentifierChoice) {
		return false
	}
	return true
}
func (this *GetSpecType_DiscoveryK8S) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DiscoveryK8S)
	if !ok {
		that2, ok := that.(GetSpecType_DiscoveryK8S)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryK8S.Equal(that1.DiscoveryK8S) {
		return false
	}
	return true
}
func (this *GetSpecType_DiscoveryConsul) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DiscoveryConsul)
	if !ok {
		that2, ok := that.(GetSpecType_DiscoveryConsul)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DiscoveryConsul.Equal(that1.DiscoveryConsul) {
		return false
	}
	return true
}
func (this *GetSpecType_NoClusterId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_NoClusterId)
	if !ok {
		that2, ok := that.(GetSpecType_NoClusterId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoClusterId.Equal(that1.NoClusterId) {
		return false
	}
	return true
}
func (this *GetSpecType_ClusterId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ClusterId)
	if !ok {
		that2, ok := that.(GetSpecType_ClusterId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClusterId != that1.ClusterId {
		return false
	}
	return true
}
func (this *VerStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&discovery.VerStatusType{")
	s = append(s, "Connected: "+fmt.Sprintf("%#v", this.Connected)+",\n")
	s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.Services != nil {
		s = append(s, "Services: "+fmt.Sprintf("%#v", this.Services)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PodInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&discovery.PodInfoType{")
	s = append(s, "PodName: "+fmt.Sprintf("%#v", this.PodName)+",\n")
	s = append(s, "Ip: "+fmt.Sprintf("%#v", this.Ip)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PortInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&discovery.PortInfoType{")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	s = append(s, "TargetPort: "+fmt.Sprintf("%#v", this.TargetPort)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DiscoveredServiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&discovery.DiscoveredServiceType{")
	s = append(s, "ServiceName: "+fmt.Sprintf("%#v", this.ServiceName)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "ServiceType: "+fmt.Sprintf("%#v", this.ServiceType)+",\n")
	s = append(s, "ClusterIp: "+fmt.Sprintf("%#v", this.ClusterIp)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	if this.Pods != nil {
		s = append(s, "Pods: "+fmt.Sprintf("%#v", this.Pods)+",\n")
	}
	keysForPortMap := make([]uint32, 0, len(this.PortMap))
	for k, _ := range this.PortMap {
		keysForPortMap = append(keysForPortMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForPortMap)
	mapStringForPortMap := "map[uint32]uint32{"
	for _, k := range keysForPortMap {
		mapStringForPortMap += fmt.Sprintf("%#v: %#v,", k, this.PortMap[k])
	}
	mapStringForPortMap += "}"
	if this.PortMap != nil {
		s = append(s, "PortMap: "+mapStringForPortMap+",\n")
	}
	if this.Ports != nil {
		s = append(s, "Ports: "+fmt.Sprintf("%#v", this.Ports)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLSClientConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&discovery.TLSClientConfigType{")
	s = append(s, "ServerName: "+fmt.Sprintf("%#v", this.ServerName)+",\n")
	if this.CertificateUrl != nil {
		s = append(s, "CertificateUrl: "+fmt.Sprintf("%#v", this.CertificateUrl)+",\n")
	}
	s = append(s, "Certificate: "+fmt.Sprintf("%#v", this.Certificate)+",\n")
	if this.KeyUrl != nil {
		s = append(s, "KeyUrl: "+fmt.Sprintf("%#v", this.KeyUrl)+",\n")
	}
	if this.CaCertificateUrl != nil {
		s = append(s, "CaCertificateUrl: "+fmt.Sprintf("%#v", this.CaCertificateUrl)+",\n")
	}
	s = append(s, "TrustedCaUrl: "+fmt.Sprintf("%#v", this.TrustedCaUrl)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RestConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&discovery.RestConfigType{")
	s = append(s, "ApiServer: "+fmt.Sprintf("%#v", this.ApiServer)+",\n")
	if this.TlsInfo != nil {
		s = append(s, "TlsInfo: "+fmt.Sprintf("%#v", this.TlsInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SAccessInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&discovery.K8SAccessInfo{")
	if this.ConfigType != nil {
		s = append(s, "ConfigType: "+fmt.Sprintf("%#v", this.ConfigType)+",\n")
	}
	if this.K8SPodNetworkChoice != nil {
		s = append(s, "K8SPodNetworkChoice: "+fmt.Sprintf("%#v", this.K8SPodNetworkChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SAccessInfo_KubeconfigUrl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SAccessInfo_KubeconfigUrl{` +
		`KubeconfigUrl:` + fmt.Sprintf("%#v", this.KubeconfigUrl) + `}`}, ", ")
	return s
}
func (this *K8SAccessInfo_ConnectionInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SAccessInfo_ConnectionInfo{` +
		`ConnectionInfo:` + fmt.Sprintf("%#v", this.ConnectionInfo) + `}`}, ", ")
	return s
}
func (this *K8SAccessInfo_InCluster) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SAccessInfo_InCluster{` +
		`InCluster:` + fmt.Sprintf("%#v", this.InCluster) + `}`}, ", ")
	return s
}
func (this *K8SAccessInfo_Isolated) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SAccessInfo_Isolated{` +
		`Isolated:` + fmt.Sprintf("%#v", this.Isolated) + `}`}, ", ")
	return s
}
func (this *K8SAccessInfo_Reachable) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SAccessInfo_Reachable{` +
		`Reachable:` + fmt.Sprintf("%#v", this.Reachable) + `}`}, ", ")
	return s
}
func (this *ConsulHttpBasicAuthInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&discovery.ConsulHttpBasicAuthInfoType{")
	s = append(s, "UserName: "+fmt.Sprintf("%#v", this.UserName)+",\n")
	if this.PasswdUrl != nil {
		s = append(s, "PasswdUrl: "+fmt.Sprintf("%#v", this.PasswdUrl)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConsulAccessInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&discovery.ConsulAccessInfo{")
	if this.ConnectionInfo != nil {
		s = append(s, "ConnectionInfo: "+fmt.Sprintf("%#v", this.ConnectionInfo)+",\n")
	}
	s = append(s, "Scheme: "+fmt.Sprintf("%#v", this.Scheme)+",\n")
	if this.HttpBasicAuthInfo != nil {
		s = append(s, "HttpBasicAuthInfo: "+fmt.Sprintf("%#v", this.HttpBasicAuthInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VipDiscoveryInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&discovery.VipDiscoveryInfoType{")
	s = append(s, "PublishVirtualIp: "+fmt.Sprintf("%#v", this.PublishVirtualIp)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Subdomain: "+fmt.Sprintf("%#v", this.Subdomain)+",\n")
	s = append(s, "DnsMode: "+fmt.Sprintf("%#v", this.DnsMode)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SPublishType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&discovery.K8SPublishType{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SDelegationType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&discovery.K8SDelegationType{")
	s = append(s, "Subdomain: "+fmt.Sprintf("%#v", this.Subdomain)+",\n")
	s = append(s, "DnsMode: "+fmt.Sprintf("%#v", this.DnsMode)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SVipDiscoveryInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&discovery.K8SVipDiscoveryInfoType{")
	if this.PublishChoice != nil {
		s = append(s, "PublishChoice: "+fmt.Sprintf("%#v", this.PublishChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SVipDiscoveryInfoType_Disable) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SVipDiscoveryInfoType_Disable{` +
		`Disable:` + fmt.Sprintf("%#v", this.Disable) + `}`}, ", ")
	return s
}
func (this *K8SVipDiscoveryInfoType_Publish) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SVipDiscoveryInfoType_Publish{` +
		`Publish:` + fmt.Sprintf("%#v", this.Publish) + `}`}, ", ")
	return s
}
func (this *K8SVipDiscoveryInfoType_PublishFqdns) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SVipDiscoveryInfoType_PublishFqdns{` +
		`PublishFqdns:` + fmt.Sprintf("%#v", this.PublishFqdns) + `}`}, ", ")
	return s
}
func (this *K8SVipDiscoveryInfoType_DnsDelegation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.K8SVipDiscoveryInfoType_DnsDelegation{` +
		`DnsDelegation:` + fmt.Sprintf("%#v", this.DnsDelegation) + `}`}, ", ")
	return s
}
func (this *ConsulVipDiscoveryInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&discovery.ConsulVipDiscoveryInfoType{")
	if this.PublishChoice != nil {
		s = append(s, "PublishChoice: "+fmt.Sprintf("%#v", this.PublishChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConsulVipDiscoveryInfoType_Disable) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.ConsulVipDiscoveryInfoType_Disable{` +
		`Disable:` + fmt.Sprintf("%#v", this.Disable) + `}`}, ", ")
	return s
}
func (this *ConsulVipDiscoveryInfoType_Publish) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.ConsulVipDiscoveryInfoType_Publish{` +
		`Publish:` + fmt.Sprintf("%#v", this.Publish) + `}`}, ", ")
	return s
}
func (this *K8SDiscoveryType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&discovery.K8SDiscoveryType{")
	if this.AccessInfo != nil {
		s = append(s, "AccessInfo: "+fmt.Sprintf("%#v", this.AccessInfo)+",\n")
	}
	if this.PublishInfo != nil {
		s = append(s, "PublishInfo: "+fmt.Sprintf("%#v", this.PublishInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConsulDiscoveryType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&discovery.ConsulDiscoveryType{")
	if this.AccessInfo != nil {
		s = append(s, "AccessInfo: "+fmt.Sprintf("%#v", this.AccessInfo)+",\n")
	}
	if this.PublishInfo != nil {
		s = append(s, "PublishInfo: "+fmt.Sprintf("%#v", this.PublishInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&discovery.GlobalSpecType{")
	if this.Where != nil {
		s = append(s, "Where: "+fmt.Sprintf("%#v", this.Where)+",\n")
	}
	if this.DiscoveryChoice != nil {
		s = append(s, "DiscoveryChoice: "+fmt.Sprintf("%#v", this.DiscoveryChoice)+",\n")
	}
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.PublishVip != nil {
		s = append(s, "PublishVip: "+fmt.Sprintf("%#v", this.PublishVip)+",\n")
	}
	if this.AccessInfo != nil {
		s = append(s, "AccessInfo: "+fmt.Sprintf("%#v", this.AccessInfo)+",\n")
	}
	s = append(s, "ClusterIdentifier: "+fmt.Sprintf("%#v", this.ClusterIdentifier)+",\n")
	if this.ClusterIdentifierChoice != nil {
		s = append(s, "ClusterIdentifierChoice: "+fmt.Sprintf("%#v", this.ClusterIdentifierChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_DiscoveryK8S) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GlobalSpecType_DiscoveryK8S{` +
		`DiscoveryK8S:` + fmt.Sprintf("%#v", this.DiscoveryK8S) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DiscoveryConsul) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GlobalSpecType_DiscoveryConsul{` +
		`DiscoveryConsul:` + fmt.Sprintf("%#v", this.DiscoveryConsul) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_K8S) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GlobalSpecType_K8S{` +
		`K8S:` + fmt.Sprintf("%#v", this.K8S) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_Consul) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GlobalSpecType_Consul{` +
		`Consul:` + fmt.Sprintf("%#v", this.Consul) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_NoClusterId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GlobalSpecType_NoClusterId{` +
		`NoClusterId:` + fmt.Sprintf("%#v", this.NoClusterId) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ClusterId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GlobalSpecType_ClusterId{` +
		`ClusterId:` + fmt.Sprintf("%#v", this.ClusterId) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&discovery.CreateSpecType{")
	if this.Where != nil {
		s = append(s, "Where: "+fmt.Sprintf("%#v", this.Where)+",\n")
	}
	if this.DiscoveryChoice != nil {
		s = append(s, "DiscoveryChoice: "+fmt.Sprintf("%#v", this.DiscoveryChoice)+",\n")
	}
	if this.ClusterIdentifierChoice != nil {
		s = append(s, "ClusterIdentifierChoice: "+fmt.Sprintf("%#v", this.ClusterIdentifierChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_DiscoveryK8S) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.CreateSpecType_DiscoveryK8S{` +
		`DiscoveryK8S:` + fmt.Sprintf("%#v", this.DiscoveryK8S) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DiscoveryConsul) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.CreateSpecType_DiscoveryConsul{` +
		`DiscoveryConsul:` + fmt.Sprintf("%#v", this.DiscoveryConsul) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_NoClusterId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.CreateSpecType_NoClusterId{` +
		`NoClusterId:` + fmt.Sprintf("%#v", this.NoClusterId) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ClusterId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.CreateSpecType_ClusterId{` +
		`ClusterId:` + fmt.Sprintf("%#v", this.ClusterId) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&discovery.ReplaceSpecType{")
	if this.Where != nil {
		s = append(s, "Where: "+fmt.Sprintf("%#v", this.Where)+",\n")
	}
	if this.DiscoveryChoice != nil {
		s = append(s, "DiscoveryChoice: "+fmt.Sprintf("%#v", this.DiscoveryChoice)+",\n")
	}
	if this.ClusterIdentifierChoice != nil {
		s = append(s, "ClusterIdentifierChoice: "+fmt.Sprintf("%#v", this.ClusterIdentifierChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_DiscoveryK8S) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.ReplaceSpecType_DiscoveryK8S{` +
		`DiscoveryK8S:` + fmt.Sprintf("%#v", this.DiscoveryK8S) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DiscoveryConsul) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.ReplaceSpecType_DiscoveryConsul{` +
		`DiscoveryConsul:` + fmt.Sprintf("%#v", this.DiscoveryConsul) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_NoClusterId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.ReplaceSpecType_NoClusterId{` +
		`NoClusterId:` + fmt.Sprintf("%#v", this.NoClusterId) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ClusterId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.ReplaceSpecType_ClusterId{` +
		`ClusterId:` + fmt.Sprintf("%#v", this.ClusterId) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&discovery.GetSpecType{")
	if this.Where != nil {
		s = append(s, "Where: "+fmt.Sprintf("%#v", this.Where)+",\n")
	}
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.PublishVip != nil {
		s = append(s, "PublishVip: "+fmt.Sprintf("%#v", this.PublishVip)+",\n")
	}
	if this.DiscoveryChoice != nil {
		s = append(s, "DiscoveryChoice: "+fmt.Sprintf("%#v", this.DiscoveryChoice)+",\n")
	}
	if this.ClusterIdentifierChoice != nil {
		s = append(s, "ClusterIdentifierChoice: "+fmt.Sprintf("%#v", this.ClusterIdentifierChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_DiscoveryK8S) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GetSpecType_DiscoveryK8S{` +
		`DiscoveryK8S:` + fmt.Sprintf("%#v", this.DiscoveryK8S) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DiscoveryConsul) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GetSpecType_DiscoveryConsul{` +
		`DiscoveryConsul:` + fmt.Sprintf("%#v", this.DiscoveryConsul) + `}`}, ", ")
	return s
}
func (this *GetSpecType_NoClusterId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GetSpecType_NoClusterId{` +
		`NoClusterId:` + fmt.Sprintf("%#v", this.NoClusterId) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ClusterId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&discovery.GetSpecType_ClusterId{` +
		`ClusterId:` + fmt.Sprintf("%#v", this.ClusterId) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *VerStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Services) > 0 {
		for iNdEx := len(m.Services) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Services[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Site) > 0 {
		i -= len(m.Site)
		copy(dAtA[i:], m.Site)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Site)))
		i--
		dAtA[i] = 0x12
	}
	if m.Connected {
		i--
		if m.Connected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PodInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PodName) > 0 {
		i -= len(m.PodName)
		copy(dAtA[i:], m.PodName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PodName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PortInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TargetPort != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TargetPort))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0x12
	}
	if m.Port != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DiscoveredServiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscoveredServiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiscoveredServiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.PortMap) > 0 {
		keysForPortMap := make([]uint32, 0, len(m.PortMap))
		for k := range m.PortMap {
			keysForPortMap = append(keysForPortMap, uint32(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint32s(keysForPortMap)
		for iNdEx := len(keysForPortMap) - 1; iNdEx >= 0; iNdEx-- {
			v := m.PortMap[uint32(keysForPortMap[iNdEx])]
			baseI := i
			i = encodeVarintTypes(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintTypes(dAtA, i, uint64(keysForPortMap[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Pods) > 0 {
		for iNdEx := len(m.Pods) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ClusterIp) > 0 {
		i -= len(m.ClusterIp)
		copy(dAtA[i:], m.ClusterIp)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterIp)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ServiceType) > 0 {
		i -= len(m.ServiceType)
		copy(dAtA[i:], m.ServiceType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ServiceType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ServiceName) > 0 {
		i -= len(m.ServiceName)
		copy(dAtA[i:], m.ServiceName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ServiceName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLSClientConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSClientConfigType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLSClientConfigType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TrustedCaUrl) > 0 {
		i -= len(m.TrustedCaUrl)
		copy(dAtA[i:], m.TrustedCaUrl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TrustedCaUrl)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Certificate) > 0 {
		i -= len(m.Certificate)
		copy(dAtA[i:], m.Certificate)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Certificate)))
		i--
		dAtA[i] = 0x2a
	}
	if m.CaCertificateUrl != nil {
		{
			size, err := m.CaCertificateUrl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.KeyUrl != nil {
		{
			size, err := m.KeyUrl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.CertificateUrl != nil {
		{
			size, err := m.CertificateUrl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ServerName) > 0 {
		i -= len(m.ServerName)
		copy(dAtA[i:], m.ServerName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RestConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestConfigType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RestConfigType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TlsInfo != nil {
		{
			size, err := m.TlsInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ApiServer) > 0 {
		i -= len(m.ApiServer)
		copy(dAtA[i:], m.ApiServer)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ApiServer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *K8SAccessInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SAccessInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SAccessInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.K8SPodNetworkChoice != nil {
		{
			size := m.K8SPodNetworkChoice.Size()
			i -= size
			if _, err := m.K8SPodNetworkChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ConfigType != nil {
		{
			size := m.ConfigType.Size()
			i -= size
			if _, err := m.ConfigType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *K8SAccessInfo_KubeconfigUrl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SAccessInfo_KubeconfigUrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.KubeconfigUrl != nil {
		{
			size, err := m.KubeconfigUrl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *K8SAccessInfo_ConnectionInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SAccessInfo_ConnectionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConnectionInfo != nil {
		{
			size, err := m.ConnectionInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *K8SAccessInfo_InCluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SAccessInfo_InCluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.InCluster {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *K8SAccessInfo_Isolated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SAccessInfo_Isolated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Isolated != nil {
		{
			size, err := m.Isolated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *K8SAccessInfo_Reachable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SAccessInfo_Reachable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Reachable != nil {
		{
			size, err := m.Reachable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ConsulHttpBasicAuthInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsulHttpBasicAuthInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsulHttpBasicAuthInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PasswdUrl != nil {
		{
			size, err := m.PasswdUrl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsulAccessInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsulAccessInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsulAccessInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HttpBasicAuthInfo != nil {
		{
			size, err := m.HttpBasicAuthInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Scheme != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Scheme))
		i--
		dAtA[i] = 0x10
	}
	if m.ConnectionInfo != nil {
		{
			size, err := m.ConnectionInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VipDiscoveryInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VipDiscoveryInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VipDiscoveryInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x2a
	}
	if m.DnsMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DnsMode))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Subdomain) > 0 {
		i -= len(m.Subdomain)
		copy(dAtA[i:], m.Subdomain)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Subdomain)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.PublishVirtualIp {
		i--
		if m.PublishVirtualIp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *K8SPublishType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SPublishType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SPublishType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *K8SDelegationType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SDelegationType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SDelegationType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DnsMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DnsMode))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Subdomain) > 0 {
		i -= len(m.Subdomain)
		copy(dAtA[i:], m.Subdomain)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Subdomain)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *K8SVipDiscoveryInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SVipDiscoveryInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SVipDiscoveryInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PublishChoice != nil {
		{
			size := m.PublishChoice.Size()
			i -= size
			if _, err := m.PublishChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *K8SVipDiscoveryInfoType_Disable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SVipDiscoveryInfoType_Disable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Disable != nil {
		{
			size, err := m.Disable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *K8SVipDiscoveryInfoType_Publish) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SVipDiscoveryInfoType_Publish) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Publish != nil {
		{
			size, err := m.Publish.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *K8SVipDiscoveryInfoType_PublishFqdns) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SVipDiscoveryInfoType_PublishFqdns) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PublishFqdns != nil {
		{
			size, err := m.PublishFqdns.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *K8SVipDiscoveryInfoType_DnsDelegation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SVipDiscoveryInfoType_DnsDelegation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DnsDelegation != nil {
		{
			size, err := m.DnsDelegation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ConsulVipDiscoveryInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsulVipDiscoveryInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsulVipDiscoveryInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PublishChoice != nil {
		{
			size := m.PublishChoice.Size()
			i -= size
			if _, err := m.PublishChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ConsulVipDiscoveryInfoType_Disable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsulVipDiscoveryInfoType_Disable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Disable != nil {
		{
			size, err := m.Disable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ConsulVipDiscoveryInfoType_Publish) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsulVipDiscoveryInfoType_Publish) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Publish != nil {
		{
			size, err := m.Publish.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *K8SDiscoveryType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SDiscoveryType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SDiscoveryType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PublishInfo != nil {
		{
			size, err := m.PublishInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.AccessInfo != nil {
		{
			size, err := m.AccessInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsulDiscoveryType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsulDiscoveryType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsulDiscoveryType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PublishInfo != nil {
		{
			size, err := m.PublishInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.AccessInfo != nil {
		{
			size, err := m.AccessInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClusterIdentifierChoice != nil {
		{
			size := m.ClusterIdentifierChoice.Size()
			i -= size
			if _, err := m.ClusterIdentifierChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.ClusterIdentifier) > 0 {
		i -= len(m.ClusterIdentifier)
		copy(dAtA[i:], m.ClusterIdentifier)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterIdentifier)))
		i--
		dAtA[i] = 0x52
	}
	if m.DiscoveryChoice != nil {
		{
			size := m.DiscoveryChoice.Size()
			i -= size
			if _, err := m.DiscoveryChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AccessInfo != nil {
		{
			size := m.AccessInfo.Size()
			i -= size
			if _, err := m.AccessInfo.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.PublishVip != nil {
		{
			size, err := m.PublishVip.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Where != nil {
		{
			size, err := m.Where.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_K8S) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_K8S) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.K8S != nil {
		{
			size, err := m.K8S.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_Consul) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_Consul) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Consul != nil {
		{
			size, err := m.Consul.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DiscoveryK8S) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DiscoveryK8S) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DiscoveryK8S != nil {
		{
			size, err := m.DiscoveryK8S.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DiscoveryConsul) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DiscoveryConsul) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DiscoveryConsul != nil {
		{
			size, err := m.DiscoveryConsul.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_NoClusterId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_NoClusterId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoClusterId != nil {
		{
			size, err := m.NoClusterId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_ClusterId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_ClusterId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ClusterId)
	copy(dAtA[i:], m.ClusterId)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterId)))
	i--
	dAtA[i] = 0x6a
	return len(dAtA) - i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClusterIdentifierChoice != nil {
		{
			size := m.ClusterIdentifierChoice.Size()
			i -= size
			if _, err := m.ClusterIdentifierChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.DiscoveryChoice != nil {
		{
			size := m.DiscoveryChoice.Size()
			i -= size
			if _, err := m.DiscoveryChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Where != nil {
		{
			size, err := m.Where.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_DiscoveryK8S) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DiscoveryK8S) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DiscoveryK8S != nil {
		{
			size, err := m.DiscoveryK8S.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_DiscoveryConsul) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DiscoveryConsul) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DiscoveryConsul != nil {
		{
			size, err := m.DiscoveryConsul.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_NoClusterId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_NoClusterId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoClusterId != nil {
		{
			size, err := m.NoClusterId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_ClusterId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_ClusterId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ClusterId)
	copy(dAtA[i:], m.ClusterId)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterId)))
	i--
	dAtA[i] = 0x6a
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClusterIdentifierChoice != nil {
		{
			size := m.ClusterIdentifierChoice.Size()
			i -= size
			if _, err := m.ClusterIdentifierChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.DiscoveryChoice != nil {
		{
			size := m.DiscoveryChoice.Size()
			i -= size
			if _, err := m.DiscoveryChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Where != nil {
		{
			size, err := m.Where.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_DiscoveryK8S) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DiscoveryK8S) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DiscoveryK8S != nil {
		{
			size, err := m.DiscoveryK8S.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_DiscoveryConsul) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DiscoveryConsul) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DiscoveryConsul != nil {
		{
			size, err := m.DiscoveryConsul.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_NoClusterId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_NoClusterId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoClusterId != nil {
		{
			size, err := m.NoClusterId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_ClusterId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_ClusterId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ClusterId)
	copy(dAtA[i:], m.ClusterId)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterId)))
	i--
	dAtA[i] = 0x6a
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClusterIdentifierChoice != nil {
		{
			size := m.ClusterIdentifierChoice.Size()
			i -= size
			if _, err := m.ClusterIdentifierChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.DiscoveryChoice != nil {
		{
			size := m.DiscoveryChoice.Size()
			i -= size
			if _, err := m.DiscoveryChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.PublishVip != nil {
		{
			size, err := m.PublishVip.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Where != nil {
		{
			size, err := m.Where.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_DiscoveryK8S) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DiscoveryK8S) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DiscoveryK8S != nil {
		{
			size, err := m.DiscoveryK8S.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_DiscoveryConsul) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DiscoveryConsul) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DiscoveryConsul != nil {
		{
			size, err := m.DiscoveryConsul.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_NoClusterId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_NoClusterId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoClusterId != nil {
		{
			size, err := m.NoClusterId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_ClusterId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_ClusterId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ClusterId)
	copy(dAtA[i:], m.ClusterId)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterId)))
	i--
	dAtA[i] = 0x6a
	return len(dAtA) - i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *VerStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Connected {
		n += 2
	}
	l = len(m.Site)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if len(m.Services) > 0 {
		for _, e := range m.Services {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *PodInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *PortInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Port != 0 {
		n += 1 + sovTypes(uint64(m.Port))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TargetPort != 0 {
		n += 1 + sovTypes(uint64(m.TargetPort))
	}
	return n
}

func (m *DiscoveredServiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ServiceType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClusterIp)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Pods) > 0 {
		for _, e := range m.Pods {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.PortMap) > 0 {
		for k, v := range m.PortMap {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTypes(uint64(k)) + 1 + sovTypes(uint64(v))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *TLSClientConfigType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CertificateUrl != nil {
		l = m.CertificateUrl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.KeyUrl != nil {
		l = m.KeyUrl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CaCertificateUrl != nil {
		l = m.CaCertificateUrl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Certificate)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TrustedCaUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RestConfigType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ApiServer)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TlsInfo != nil {
		l = m.TlsInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *K8SAccessInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfigType != nil {
		n += m.ConfigType.Size()
	}
	if m.K8SPodNetworkChoice != nil {
		n += m.K8SPodNetworkChoice.Size()
	}
	return n
}

func (m *K8SAccessInfo_KubeconfigUrl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KubeconfigUrl != nil {
		l = m.KubeconfigUrl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *K8SAccessInfo_ConnectionInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectionInfo != nil {
		l = m.ConnectionInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *K8SAccessInfo_InCluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *K8SAccessInfo_Isolated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Isolated != nil {
		l = m.Isolated.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *K8SAccessInfo_Reachable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reachable != nil {
		l = m.Reachable.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ConsulHttpBasicAuthInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PasswdUrl != nil {
		l = m.PasswdUrl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ConsulAccessInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectionInfo != nil {
		l = m.ConnectionInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Scheme != 0 {
		n += 1 + sovTypes(uint64(m.Scheme))
	}
	if m.HttpBasicAuthInfo != nil {
		l = m.HttpBasicAuthInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *VipDiscoveryInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PublishVirtualIp {
		n += 2
	}
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	l = len(m.Subdomain)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DnsMode != 0 {
		n += 1 + sovTypes(uint64(m.DnsMode))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *K8SPublishType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *K8SDelegationType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Subdomain)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DnsMode != 0 {
		n += 1 + sovTypes(uint64(m.DnsMode))
	}
	return n
}

func (m *K8SVipDiscoveryInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PublishChoice != nil {
		n += m.PublishChoice.Size()
	}
	return n
}

func (m *K8SVipDiscoveryInfoType_Disable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Disable != nil {
		l = m.Disable.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *K8SVipDiscoveryInfoType_Publish) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Publish != nil {
		l = m.Publish.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *K8SVipDiscoveryInfoType_PublishFqdns) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PublishFqdns != nil {
		l = m.PublishFqdns.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *K8SVipDiscoveryInfoType_DnsDelegation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DnsDelegation != nil {
		l = m.DnsDelegation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ConsulVipDiscoveryInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PublishChoice != nil {
		n += m.PublishChoice.Size()
	}
	return n
}

func (m *ConsulVipDiscoveryInfoType_Disable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Disable != nil {
		l = m.Disable.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ConsulVipDiscoveryInfoType_Publish) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Publish != nil {
		l = m.Publish.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *K8SDiscoveryType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccessInfo != nil {
		l = m.AccessInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PublishInfo != nil {
		l = m.PublishInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ConsulDiscoveryType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccessInfo != nil {
		l = m.AccessInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PublishInfo != nil {
		l = m.PublishInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.PublishVip != nil {
		l = m.PublishVip.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AccessInfo != nil {
		n += m.AccessInfo.Size()
	}
	if m.DiscoveryChoice != nil {
		n += m.DiscoveryChoice.Size()
	}
	l = len(m.ClusterIdentifier)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ClusterIdentifierChoice != nil {
		n += m.ClusterIdentifierChoice.Size()
	}
	return n
}

func (m *GlobalSpecType_K8S) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.K8S != nil {
		l = m.K8S.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_Consul) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Consul != nil {
		l = m.Consul.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DiscoveryK8S) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscoveryK8S != nil {
		l = m.DiscoveryK8S.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DiscoveryConsul) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscoveryConsul != nil {
		l = m.DiscoveryConsul.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_NoClusterId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoClusterId != nil {
		l = m.NoClusterId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_ClusterId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DiscoveryChoice != nil {
		n += m.DiscoveryChoice.Size()
	}
	if m.ClusterIdentifierChoice != nil {
		n += m.ClusterIdentifierChoice.Size()
	}
	return n
}

func (m *CreateSpecType_DiscoveryK8S) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscoveryK8S != nil {
		l = m.DiscoveryK8S.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DiscoveryConsul) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscoveryConsul != nil {
		l = m.DiscoveryConsul.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_NoClusterId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoClusterId != nil {
		l = m.NoClusterId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_ClusterId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DiscoveryChoice != nil {
		n += m.DiscoveryChoice.Size()
	}
	if m.ClusterIdentifierChoice != nil {
		n += m.ClusterIdentifierChoice.Size()
	}
	return n
}

func (m *ReplaceSpecType_DiscoveryK8S) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscoveryK8S != nil {
		l = m.DiscoveryK8S.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DiscoveryConsul) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscoveryConsul != nil {
		l = m.DiscoveryConsul.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_NoClusterId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoClusterId != nil {
		l = m.NoClusterId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_ClusterId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Where != nil {
		l = m.Where.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.PublishVip != nil {
		l = m.PublishVip.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DiscoveryChoice != nil {
		n += m.DiscoveryChoice.Size()
	}
	if m.ClusterIdentifierChoice != nil {
		n += m.ClusterIdentifierChoice.Size()
	}
	return n
}

func (m *GetSpecType_DiscoveryK8S) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscoveryK8S != nil {
		l = m.DiscoveryK8S.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DiscoveryConsul) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscoveryConsul != nil {
		l = m.DiscoveryConsul.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_NoClusterId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoClusterId != nil {
		l = m.NoClusterId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_ClusterId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *VerStatusType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForServices := "[]*DiscoveredServiceType{"
	for _, f := range this.Services {
		repeatedStringForServices += strings.Replace(f.String(), "DiscoveredServiceType", "DiscoveredServiceType", 1) + ","
	}
	repeatedStringForServices += "}"
	s := strings.Join([]string{`&VerStatusType{`,
		`Connected:` + fmt.Sprintf("%v", this.Connected) + `,`,
		`Site:` + fmt.Sprintf("%v", this.Site) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Services:` + repeatedStringForServices + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodInfoType{`,
		`PodName:` + fmt.Sprintf("%v", this.PodName) + `,`,
		`Ip:` + fmt.Sprintf("%v", this.Ip) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortInfoType{`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`TargetPort:` + fmt.Sprintf("%v", this.TargetPort) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DiscoveredServiceType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPods := "[]*PodInfoType{"
	for _, f := range this.Pods {
		repeatedStringForPods += strings.Replace(f.String(), "PodInfoType", "PodInfoType", 1) + ","
	}
	repeatedStringForPods += "}"
	repeatedStringForPorts := "[]*PortInfoType{"
	for _, f := range this.Ports {
		repeatedStringForPorts += strings.Replace(f.String(), "PortInfoType", "PortInfoType", 1) + ","
	}
	repeatedStringForPorts += "}"
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForPortMap := make([]uint32, 0, len(this.PortMap))
	for k, _ := range this.PortMap {
		keysForPortMap = append(keysForPortMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForPortMap)
	mapStringForPortMap := "map[uint32]uint32{"
	for _, k := range keysForPortMap {
		mapStringForPortMap += fmt.Sprintf("%v: %v,", k, this.PortMap[k])
	}
	mapStringForPortMap += "}"
	s := strings.Join([]string{`&DiscoveredServiceType{`,
		`ServiceName:` + fmt.Sprintf("%v", this.ServiceName) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`ServiceType:` + fmt.Sprintf("%v", this.ServiceType) + `,`,
		`ClusterIp:` + fmt.Sprintf("%v", this.ClusterIp) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Pods:` + repeatedStringForPods + `,`,
		`PortMap:` + mapStringForPortMap + `,`,
		`Ports:` + repeatedStringForPorts + `,`,
		`}`,
	}, "")
	return s
}
func (this *TLSClientConfigType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TLSClientConfigType{`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`CertificateUrl:` + strings.Replace(fmt.Sprintf("%v", this.CertificateUrl), "SecretType", "schema.SecretType", 1) + `,`,
		`KeyUrl:` + strings.Replace(fmt.Sprintf("%v", this.KeyUrl), "SecretType", "schema.SecretType", 1) + `,`,
		`CaCertificateUrl:` + strings.Replace(fmt.Sprintf("%v", this.CaCertificateUrl), "SecretType", "schema.SecretType", 1) + `,`,
		`Certificate:` + fmt.Sprintf("%v", this.Certificate) + `,`,
		`TrustedCaUrl:` + fmt.Sprintf("%v", this.TrustedCaUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RestConfigType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RestConfigType{`,
		`ApiServer:` + fmt.Sprintf("%v", this.ApiServer) + `,`,
		`TlsInfo:` + strings.Replace(this.TlsInfo.String(), "TLSClientConfigType", "TLSClientConfigType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SAccessInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SAccessInfo{`,
		`ConfigType:` + fmt.Sprintf("%v", this.ConfigType) + `,`,
		`K8SPodNetworkChoice:` + fmt.Sprintf("%v", this.K8SPodNetworkChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SAccessInfo_KubeconfigUrl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SAccessInfo_KubeconfigUrl{`,
		`KubeconfigUrl:` + strings.Replace(fmt.Sprintf("%v", this.KubeconfigUrl), "SecretType", "schema.SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SAccessInfo_ConnectionInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SAccessInfo_ConnectionInfo{`,
		`ConnectionInfo:` + strings.Replace(fmt.Sprintf("%v", this.ConnectionInfo), "RestConfigType", "RestConfigType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SAccessInfo_InCluster) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SAccessInfo_InCluster{`,
		`InCluster:` + fmt.Sprintf("%v", this.InCluster) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SAccessInfo_Isolated) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SAccessInfo_Isolated{`,
		`Isolated:` + strings.Replace(fmt.Sprintf("%v", this.Isolated), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SAccessInfo_Reachable) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SAccessInfo_Reachable{`,
		`Reachable:` + strings.Replace(fmt.Sprintf("%v", this.Reachable), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsulHttpBasicAuthInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConsulHttpBasicAuthInfoType{`,
		`UserName:` + fmt.Sprintf("%v", this.UserName) + `,`,
		`PasswdUrl:` + strings.Replace(fmt.Sprintf("%v", this.PasswdUrl), "SecretType", "schema.SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsulAccessInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConsulAccessInfo{`,
		`ConnectionInfo:` + strings.Replace(this.ConnectionInfo.String(), "RestConfigType", "RestConfigType", 1) + `,`,
		`Scheme:` + fmt.Sprintf("%v", this.Scheme) + `,`,
		`HttpBasicAuthInfo:` + strings.Replace(this.HttpBasicAuthInfo.String(), "ConsulHttpBasicAuthInfoType", "ConsulHttpBasicAuthInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VipDiscoveryInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VipDiscoveryInfoType{`,
		`PublishVirtualIp:` + fmt.Sprintf("%v", this.PublishVirtualIp) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Subdomain:` + fmt.Sprintf("%v", this.Subdomain) + `,`,
		`DnsMode:` + fmt.Sprintf("%v", this.DnsMode) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SPublishType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SPublishType{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SDelegationType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SDelegationType{`,
		`Subdomain:` + fmt.Sprintf("%v", this.Subdomain) + `,`,
		`DnsMode:` + fmt.Sprintf("%v", this.DnsMode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SVipDiscoveryInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SVipDiscoveryInfoType{`,
		`PublishChoice:` + fmt.Sprintf("%v", this.PublishChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SVipDiscoveryInfoType_Disable) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SVipDiscoveryInfoType_Disable{`,
		`Disable:` + strings.Replace(fmt.Sprintf("%v", this.Disable), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SVipDiscoveryInfoType_Publish) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SVipDiscoveryInfoType_Publish{`,
		`Publish:` + strings.Replace(fmt.Sprintf("%v", this.Publish), "K8SPublishType", "K8SPublishType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SVipDiscoveryInfoType_PublishFqdns) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SVipDiscoveryInfoType_PublishFqdns{`,
		`PublishFqdns:` + strings.Replace(fmt.Sprintf("%v", this.PublishFqdns), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SVipDiscoveryInfoType_DnsDelegation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SVipDiscoveryInfoType_DnsDelegation{`,
		`DnsDelegation:` + strings.Replace(fmt.Sprintf("%v", this.DnsDelegation), "K8SDelegationType", "K8SDelegationType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsulVipDiscoveryInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConsulVipDiscoveryInfoType{`,
		`PublishChoice:` + fmt.Sprintf("%v", this.PublishChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsulVipDiscoveryInfoType_Disable) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConsulVipDiscoveryInfoType_Disable{`,
		`Disable:` + strings.Replace(fmt.Sprintf("%v", this.Disable), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsulVipDiscoveryInfoType_Publish) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConsulVipDiscoveryInfoType_Publish{`,
		`Publish:` + strings.Replace(fmt.Sprintf("%v", this.Publish), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SDiscoveryType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SDiscoveryType{`,
		`AccessInfo:` + strings.Replace(this.AccessInfo.String(), "K8SAccessInfo", "K8SAccessInfo", 1) + `,`,
		`PublishInfo:` + strings.Replace(this.PublishInfo.String(), "K8SVipDiscoveryInfoType", "K8SVipDiscoveryInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsulDiscoveryType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConsulDiscoveryType{`,
		`AccessInfo:` + strings.Replace(this.AccessInfo.String(), "ConsulAccessInfo", "ConsulAccessInfo", 1) + `,`,
		`PublishInfo:` + strings.Replace(this.PublishInfo.String(), "ConsulVipDiscoveryInfoType", "ConsulVipDiscoveryInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Where:` + strings.Replace(fmt.Sprintf("%v", this.Where), "NetworkSiteRefSelector", "schema.NetworkSiteRefSelector", 1) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`PublishVip:` + strings.Replace(this.PublishVip.String(), "VipDiscoveryInfoType", "VipDiscoveryInfoType", 1) + `,`,
		`AccessInfo:` + fmt.Sprintf("%v", this.AccessInfo) + `,`,
		`DiscoveryChoice:` + fmt.Sprintf("%v", this.DiscoveryChoice) + `,`,
		`ClusterIdentifier:` + fmt.Sprintf("%v", this.ClusterIdentifier) + `,`,
		`ClusterIdentifierChoice:` + fmt.Sprintf("%v", this.ClusterIdentifierChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_K8S) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_K8S{`,
		`K8S:` + strings.Replace(fmt.Sprintf("%v", this.K8S), "K8SAccessInfo", "K8SAccessInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Consul) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Consul{`,
		`Consul:` + strings.Replace(fmt.Sprintf("%v", this.Consul), "ConsulAccessInfo", "ConsulAccessInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DiscoveryK8S) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DiscoveryK8S{`,
		`DiscoveryK8S:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryK8S), "K8SDiscoveryType", "K8SDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DiscoveryConsul) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DiscoveryConsul{`,
		`DiscoveryConsul:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryConsul), "ConsulDiscoveryType", "ConsulDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_NoClusterId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_NoClusterId{`,
		`NoClusterId:` + strings.Replace(fmt.Sprintf("%v", this.NoClusterId), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ClusterId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ClusterId{`,
		`ClusterId:` + fmt.Sprintf("%v", this.ClusterId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Where:` + strings.Replace(fmt.Sprintf("%v", this.Where), "NetworkSiteRefSelector", "schema.NetworkSiteRefSelector", 1) + `,`,
		`DiscoveryChoice:` + fmt.Sprintf("%v", this.DiscoveryChoice) + `,`,
		`ClusterIdentifierChoice:` + fmt.Sprintf("%v", this.ClusterIdentifierChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DiscoveryK8S) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DiscoveryK8S{`,
		`DiscoveryK8S:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryK8S), "K8SDiscoveryType", "K8SDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DiscoveryConsul) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DiscoveryConsul{`,
		`DiscoveryConsul:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryConsul), "ConsulDiscoveryType", "ConsulDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_NoClusterId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_NoClusterId{`,
		`NoClusterId:` + strings.Replace(fmt.Sprintf("%v", this.NoClusterId), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ClusterId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ClusterId{`,
		`ClusterId:` + fmt.Sprintf("%v", this.ClusterId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Where:` + strings.Replace(fmt.Sprintf("%v", this.Where), "NetworkSiteRefSelector", "schema.NetworkSiteRefSelector", 1) + `,`,
		`DiscoveryChoice:` + fmt.Sprintf("%v", this.DiscoveryChoice) + `,`,
		`ClusterIdentifierChoice:` + fmt.Sprintf("%v", this.ClusterIdentifierChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DiscoveryK8S) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DiscoveryK8S{`,
		`DiscoveryK8S:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryK8S), "K8SDiscoveryType", "K8SDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DiscoveryConsul) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DiscoveryConsul{`,
		`DiscoveryConsul:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryConsul), "ConsulDiscoveryType", "ConsulDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_NoClusterId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_NoClusterId{`,
		`NoClusterId:` + strings.Replace(fmt.Sprintf("%v", this.NoClusterId), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ClusterId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ClusterId{`,
		`ClusterId:` + fmt.Sprintf("%v", this.ClusterId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`Where:` + strings.Replace(fmt.Sprintf("%v", this.Where), "NetworkSiteRefSelector", "schema.NetworkSiteRefSelector", 1) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`PublishVip:` + strings.Replace(this.PublishVip.String(), "VipDiscoveryInfoType", "VipDiscoveryInfoType", 1) + `,`,
		`DiscoveryChoice:` + fmt.Sprintf("%v", this.DiscoveryChoice) + `,`,
		`ClusterIdentifierChoice:` + fmt.Sprintf("%v", this.ClusterIdentifierChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DiscoveryK8S) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DiscoveryK8S{`,
		`DiscoveryK8S:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryK8S), "K8SDiscoveryType", "K8SDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DiscoveryConsul) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DiscoveryConsul{`,
		`DiscoveryConsul:` + strings.Replace(fmt.Sprintf("%v", this.DiscoveryConsul), "ConsulDiscoveryType", "ConsulDiscoveryType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_NoClusterId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_NoClusterId{`,
		`NoClusterId:` + strings.Replace(fmt.Sprintf("%v", this.NoClusterId), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ClusterId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ClusterId{`,
		`ClusterId:` + fmt.Sprintf("%v", this.ClusterId) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *VerStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Connected = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= schema.DiscoveryType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Services = append(m.Services, &DiscoveredServiceType{})
			if err := m.Services[len(m.Services)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPort", wireType)
			}
			m.TargetPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscoveredServiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiscoveredServiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiscoveredServiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pods = append(m.Pods, &PodInfoType{})
			if err := m.Pods[len(m.Pods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMap == nil {
				m.PortMap = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PortMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &PortInfoType{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSClientConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TLSClientConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TLSClientConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateUrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CertificateUrl == nil {
				m.CertificateUrl = &schema.SecretType{}
			}
			if err := m.CertificateUrl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyUrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyUrl == nil {
				m.KeyUrl = &schema.SecretType{}
			}
			if err := m.KeyUrl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaCertificateUrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CaCertificateUrl == nil {
				m.CaCertificateUrl = &schema.SecretType{}
			}
			if err := m.CaCertificateUrl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certificate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Certificate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCaUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedCaUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiServer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiServer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsInfo == nil {
				m.TlsInfo = &TLSClientConfigType{}
			}
			if err := m.TlsInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SAccessInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8SAccessInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8SAccessInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubeconfigUrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.SecretType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConfigType = &K8SAccessInfo_KubeconfigUrl{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RestConfigType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConfigType = &K8SAccessInfo_ConnectionInfo{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InCluster", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ConfigType = &K8SAccessInfo_InCluster{b}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isolated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.K8SPodNetworkChoice = &K8SAccessInfo_Isolated{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reachable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.K8SPodNetworkChoice = &K8SAccessInfo_Reachable{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsulHttpBasicAuthInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsulHttpBasicAuthInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsulHttpBasicAuthInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PasswdUrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PasswdUrl == nil {
				m.PasswdUrl = &schema.SecretType{}
			}
			if err := m.PasswdUrl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsulAccessInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsulAccessInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsulAccessInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConnectionInfo == nil {
				m.ConnectionInfo = &RestConfigType{}
			}
			if err := m.ConnectionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			m.Scheme = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scheme |= SchemeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpBasicAuthInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpBasicAuthInfo == nil {
				m.HttpBasicAuthInfo = &ConsulHttpBasicAuthInfoType{}
			}
			if err := m.HttpBasicAuthInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VipDiscoveryInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VipDiscoveryInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VipDiscoveryInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishVirtualIp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PublishVirtualIp = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= VirtualIPDiscoveryType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subdomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subdomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsMode", wireType)
			}
			m.DnsMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DnsMode |= K8SDNSMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SPublishType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8SPublishType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8SPublishType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SDelegationType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8SDelegationType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8SDelegationType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subdomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subdomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsMode", wireType)
			}
			m.DnsMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DnsMode |= K8SDNSMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SVipDiscoveryInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8SVipDiscoveryInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8SVipDiscoveryInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PublishChoice = &K8SVipDiscoveryInfoType_Disable{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publish", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &K8SPublishType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PublishChoice = &K8SVipDiscoveryInfoType_Publish{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishFqdns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PublishChoice = &K8SVipDiscoveryInfoType_PublishFqdns{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsDelegation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &K8SDelegationType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PublishChoice = &K8SVipDiscoveryInfoType_DnsDelegation{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsulVipDiscoveryInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsulVipDiscoveryInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsulVipDiscoveryInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PublishChoice = &ConsulVipDiscoveryInfoType_Disable{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publish", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PublishChoice = &ConsulVipDiscoveryInfoType_Publish{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SDiscoveryType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8SDiscoveryType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8SDiscoveryType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessInfo == nil {
				m.AccessInfo = &K8SAccessInfo{}
			}
			if err := m.AccessInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublishInfo == nil {
				m.PublishInfo = &K8SVipDiscoveryInfoType{}
			}
			if err := m.PublishInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsulDiscoveryType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsulDiscoveryType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsulDiscoveryType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessInfo == nil {
				m.AccessInfo = &ConsulAccessInfo{}
			}
			if err := m.AccessInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublishInfo == nil {
				m.PublishInfo = &ConsulVipDiscoveryInfoType{}
			}
			if err := m.PublishInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &schema.NetworkSiteRefSelector{}
			}
			if err := m.Where.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= schema.DiscoveryType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishVip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublishVip == nil {
				m.PublishVip = &VipDiscoveryInfoType{}
			}
			if err := m.PublishVip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8S", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &K8SAccessInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AccessInfo = &GlobalSpecType_K8S{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Consul", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConsulAccessInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AccessInfo = &GlobalSpecType_Consul{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryK8S", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &K8SDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &GlobalSpecType_DiscoveryK8S{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryConsul", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConsulDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &GlobalSpecType_DiscoveryConsul{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterIdentifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterIdentifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoClusterId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClusterIdentifierChoice = &GlobalSpecType_NoClusterId{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterIdentifierChoice = &GlobalSpecType_ClusterId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &schema.NetworkSiteRefSelector{}
			}
			if err := m.Where.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryK8S", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &K8SDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &CreateSpecType_DiscoveryK8S{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryConsul", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConsulDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &CreateSpecType_DiscoveryConsul{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoClusterId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClusterIdentifierChoice = &CreateSpecType_NoClusterId{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterIdentifierChoice = &CreateSpecType_ClusterId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &schema.NetworkSiteRefSelector{}
			}
			if err := m.Where.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryK8S", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &K8SDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &ReplaceSpecType_DiscoveryK8S{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryConsul", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConsulDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &ReplaceSpecType_DiscoveryConsul{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoClusterId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClusterIdentifierChoice = &ReplaceSpecType_NoClusterId{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterIdentifierChoice = &ReplaceSpecType_ClusterId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Where == nil {
				m.Where = &schema.NetworkSiteRefSelector{}
			}
			if err := m.Where.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= schema.DiscoveryType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishVip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublishVip == nil {
				m.PublishVip = &VipDiscoveryInfoType{}
			}
			if err := m.PublishVip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryK8S", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &K8SDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &GetSpecType_DiscoveryK8S{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoveryConsul", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConsulDiscoveryType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DiscoveryChoice = &GetSpecType_DiscoveryConsul{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoClusterId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClusterIdentifierChoice = &GetSpecType_NoClusterId{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterIdentifierChoice = &GetSpecType_ClusterId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
