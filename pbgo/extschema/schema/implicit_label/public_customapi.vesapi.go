// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package implicit_label

import (
	"bytes"
	"context"
	"fmt"
	io "io"
	"net/http"
	"strings"

	"github.com/gogo/protobuf/proto"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"google.golang.org/grpc"

	"gopkg.volterra.us/stdlib/client"
	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/errors"
	"gopkg.volterra.us/stdlib/server"
	"gopkg.volterra.us/stdlib/svcfw"
)

var (
	_ = fmt.Sprintf("dummy for fmt import use")
)

// Create CustomAPI GRPC Client satisfying server.CustomClient
type CustomAPIGrpcClient struct {
	conn       *grpc.ClientConn
	grpcClient CustomAPIClient
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error)
}

func (c *CustomAPIGrpcClient) doRPCGet(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.implicit_label.GetRequest", yamlReq)
	}
	rsp, err := c.grpcClient.Get(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	if cco.YAMLReq == "" {
		return nil, fmt.Errorf("Error, empty request body")
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := rpcFn(ctx, cco.YAMLReq, cco.GrpcCallOpts...)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using GRPC")
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func NewCustomAPIGrpcClient(cc *grpc.ClientConn) server.CustomClient {
	ccl := &CustomAPIGrpcClient{
		conn:       cc,
		grpcClient: NewCustomAPIClient(cc),
	}
	rpcFns := make(map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error))
	rpcFns["Get"] = ccl.doRPCGet

	ccl.rpcFns = rpcFns

	return ccl
}

// Create CustomAPI REST Client satisfying server.CustomClient
type CustomAPIRestClient struct {
	baseURL string
	client  http.Client
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error)
}

func (c *CustomAPIRestClient) doRPCGet(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.implicit_label.GetRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("key", fmt.Sprintf("%v", req.Key))
		for _, item := range req.KeyClasses {
			q.Add("key_classes", fmt.Sprintf("%v", item))
		}
		q.Add("query", fmt.Sprintf("%v", req.Query))
		q.Add("value", fmt.Sprintf("%v", req.Value))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &GetResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.implicit_label.GetResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	rsp, err := rpcFn(ctx, cco)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using Rest")
	}
	return rsp, nil
}

func NewCustomAPIRestClient(baseURL string, hc http.Client) server.CustomClient {
	ccl := &CustomAPIRestClient{
		baseURL: baseURL,
		client:  hc,
	}

	rpcFns := make(map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error))
	rpcFns["Get"] = ccl.doRPCGet

	ccl.rpcFns = rpcFns

	return ccl
}

// Create customAPIInprocClient

// INPROC Client (satisfying CustomAPIClient interface)
type customAPIInprocClient struct {
	CustomAPIServer
}

func (c *customAPIInprocClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.implicit_label.CustomAPI.Get")
	return c.CustomAPIServer.Get(ctx, in)
}

func NewCustomAPIInprocClient(svc svcfw.Service) CustomAPIClient {
	return &customAPIInprocClient{CustomAPIServer: NewCustomAPIServer(svc)}
}

// RegisterGwCustomAPIHandler registers with grpc-gw with an inproc-client backing so that
// rest to grpc happens without a grpc.Dial (thus avoiding additional certs for mTLS)
func RegisterGwCustomAPIHandler(ctx context.Context, mux *runtime.ServeMux, svc interface{}) error {
	s, ok := svc.(svcfw.Service)
	if !ok {
		return fmt.Errorf("svc is not svcfw.Service")
	}
	return RegisterCustomAPIHandlerClient(ctx, mux, NewCustomAPIInprocClient(s))
}

// Create customAPISrv

// SERVER (satisfying CustomAPIServer interface)
type customAPISrv struct {
	svc svcfw.Service
}

func (s *customAPISrv) Get(ctx context.Context, in *GetRequest) (*GetResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.implicit_label.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *GetResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.implicit_label.GetRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.Get' operation on 'implicit_label'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.implicit_label.CustomAPI.Get"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.Get(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.implicit_label.GetResponse", rsp)...)

	return rsp, nil
}

func NewCustomAPIServer(svc svcfw.Service) CustomAPIServer {
	return &customAPISrv{svc: svc}
}

var CustomAPISwaggerJSON string = `{
    "swagger": "2.0",
    "info": {
        "title": "Implicit Label",
        "description": "Implicit labels are attached to objects implicitly by the system. Users are not allowed to create/update/delete these labels\nThey are also not allowed to attach/detach these labels to objects. This API is provided to get the implicit labels available\nto be used in service-policies",
        "version": "version not set"
    },
    "schemes": [
        "http",
        "https"
    ],
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ],
    "tags": [],
    "paths": {
        "/public/namespaces/system/implicit_labels": {
            "get": {
                "summary": "Get Implicit Labels",
                "description": "Get is generic label query. Two types of queries are supported\n* Return label with exact matching entry label key = label value.\n* Return list of labels that have prefix of label key = label value.\nReturns list of labels. Query will look into current tenants shared namespace and ves-io shared.",
                "operationId": "ves.io.schema.implicit_label.CustomAPI.Get",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/implicit_labelGetResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "query",
                        "description": "Type of Query\n\nGet all available implicit labels\nGet exact match of label.key = label.value Or label.key(label.value)\nGet prefix match of label.key = label.value\nGet list of all keys\nGet list of all labels that exactly match the given key and substring match either 'value' or description provided in 'value' field\nGet list of all keys matching a substring",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "enum": [
                            "QUERY_ALL_LABELS",
                            "QUERY_EXACT_LABEL",
                            "QUERY_VALUE_PREFIX_LABELS",
                            "QUERY_KEYS_ONLY",
                            "QUERY_VALUE_OR_DESCRIPTION_SUBSTRING",
                            "QUERY_KEY_SUBSTRING"
                        ],
                        "default": "QUERY_ALL_LABELS",
                        "x-displayname": "Key Substring"
                    },
                    {
                        "name": "key",
                        "description": "x-example: \"value\"\nKey string in Query parameters",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "x-displayname": "Key"
                    },
                    {
                        "name": "value",
                        "description": "x-example: \"value\"\nValue string in Query parameters",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "x-displayname": "Value"
                    },
                    {
                        "name": "key_classes",
                        "description": "x-example: \"key classes\"\nKey classes\n\nIncludes label keys with generic names such as \"my-key\", \"foobar-key\" etc.\nKeys that are obtained using GET on /api/config/namespaces/shared/known_label_keys\nIncludes volterra-defined known label keys such as \"ves.io/app_type\", \"ves.io/app\" and \"ves.io/siteType\" as well as tenant-defined known keys such as\n\"my-key\", \"acme-key-foo\" and \"acme-key-bar\". Note that tenant-defined known keys don't have any standard name format - they are known keys because they\nhave been explicitly created as known keys by the tenant and are stored in the configuration as known_label_keys.\nIncludes implicit geoip label keys \"geoip.ves.io/city\", \"geoip.ves.io/region\" and \"geoip.ves.io/country\"\nIncludes implicit label keys associated with packets/requests by the infrastructure e.g. \"implicit.ves.io/namespace\"\nInclude ip reputation label keys \"ipreputation.ves.io/threattype\", \"ipreputation.ves.io/threatlevel\"\nInclude url reputation label keys \"urlreputation.ves.io/category\", \"urlreputation.ves.io/reputationlevel\"\nIncludes implicit geoip label keys \"geoip.ves.io/continent\"\nIncludes implicit geoip label keys  \"geoip.ves.io/region\", \"geoip.ves.io/country\" and \"geoip.ves.io/continent\"\nImplicit aws resource labels (dynamically queried). This may be vpc level tags and/or subnet level tags",
                        "in": "query",
                        "required": false,
                        "type": "array",
                        "items": {
                            "type": "string",
                            "enum": [
                                "KEY_CLASS_GENERIC",
                                "KEY_CLASS_KNOWN",
                                "KEY_CLASS_GEOIP",
                                "KEY_CLASS_IMPLICIT",
                                "KEY_CLASS_IP_REPUTATION",
                                "KEY_CLASS_URL_REPUTATION",
                                "KEY_CLASS_GEOIP_EXTENDED",
                                "KEY_CLASS_DNS_GEOIP",
                                "KEY_CLASS_AWS"
                            ]
                        },
                        "collectionFormat": "multi",
                        "x-displayname": "Key Class AWS"
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-implicit_label-customapi-get"
                },
                "x-ves-proto-rpc": "ves.io.schema.implicit_label.CustomAPI.Get"
            },
            "x-displayname": "Implicit Labels API",
            "x-ves-proto-service": "ves.io.schema.implicit_label.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        }
    },
    "definitions": {
        "implicit_labelGetResponse": {
            "type": "object",
            "description": "Get Label Response, list of labels",
            "title": "Get Label response",
            "x-displayname": "Get Label Response",
            "x-ves-proto-message": "ves.io.schema.implicit_label.GetResponse",
            "properties": {
                "label": {
                    "type": "array",
                    "description": " List of labels as Query response",
                    "title": "List of labels",
                    "items": {
                        "$ref": "#/definitions/implicit_labelLabelType"
                    },
                    "x-displayname": "Labels"
                }
            }
        },
        "implicit_labelLabelType": {
            "type": "object",
            "description": "Generic Label type label.key(label.value)",
            "title": "Label Type",
            "x-displayname": "Label",
            "x-ves-proto-message": "ves.io.schema.implicit_label.LabelType",
            "properties": {
                "description": {
                    "type": "string",
                    "description": " Label description\n\nExample: - \"description\"-",
                    "title": "description",
                    "x-displayname": "Description",
                    "x-ves-example": "description"
                },
                "key": {
                    "type": "string",
                    "description": " Label key\n\nExample: - \"key\"-",
                    "title": "key",
                    "x-displayname": "Key",
                    "x-ves-example": "key"
                },
                "value": {
                    "type": "string",
                    "description": " Label value\n\nExample: - \"value\"-",
                    "title": "value",
                    "x-displayname": "Value",
                    "x-ves-example": "value"
                }
            }
        },
        "implicit_labelQueryType": {
            "type": "string",
            "description": "x-displayName: \"Label Query\"\nType of query for implicit labels\n\n - QUERY_ALL_LABELS: x-displayName: \"All Labels\"\nGet all available implicit labels\n - QUERY_EXACT_LABEL: x-displayName: \"Exact Label\"\nGet exact match of label.key = label.value Or label.key(label.value)\n - QUERY_VALUE_PREFIX_LABELS: x-displayName: \"Label Prefix\"\nGet prefix match of label.key = label.value\n - QUERY_KEYS_ONLY: x-displayName: \"Keys Only\"\nGet list of all keys\n - QUERY_VALUE_OR_DESCRIPTION_SUBSTRING: x-displayName: \"Value or Description Substring\"\nGet list of all labels that exactly match the given key and substring match either 'value' or description provided in 'value' field\n - QUERY_KEY_SUBSTRING: x-displayName: \"Key Substring\"\nGet list of all keys matching a substring",
            "title": "Label Query type",
            "enum": [
                "QUERY_ALL_LABELS",
                "QUERY_EXACT_LABEL",
                "QUERY_VALUE_PREFIX_LABELS",
                "QUERY_KEYS_ONLY",
                "QUERY_VALUE_OR_DESCRIPTION_SUBSTRING",
                "QUERY_KEY_SUBSTRING"
            ],
            "default": "QUERY_ALL_LABELS"
        },
        "schemaLabelKeyClass": {
            "type": "string",
            "description": "x-displayName: \"LabelKeyClass\"\nLabelKeyClass is an enumeration of supported label key classes\n\n - KEY_CLASS_GENERIC: x-displayName: \"Key Class Generic\"\nIncludes label keys with generic names such as \"my-key\", \"foobar-key\" etc.\n - KEY_CLASS_KNOWN: x-displayName: \"Key Class Known\"\nKeys that are obtained using GET on /api/config/namespaces/shared/known_label_keys\nIncludes volterra-defined known label keys such as \"ves.io/app_type\", \"ves.io/app\" and \"ves.io/siteType\" as well as tenant-defined known keys such as\n\"my-key\", \"acme-key-foo\" and \"acme-key-bar\". Note that tenant-defined known keys don't have any standard name format - they are known keys because they\nhave been explicitly created as known keys by the tenant and are stored in the configuration as known_label_keys.\n - KEY_CLASS_GEOIP: x-displayName: \"Key Class GeoIp\"\nIncludes implicit geoip label keys \"geoip.ves.io/city\", \"geoip.ves.io/region\" and \"geoip.ves.io/country\"\n - KEY_CLASS_IMPLICIT: x-displayName: \"Key Class Implicit\"\nIncludes implicit label keys associated with packets/requests by the infrastructure e.g. \"implicit.ves.io/namespace\"\n - KEY_CLASS_IP_REPUTATION: x-displayName: \"Key Class Reputation\"\nInclude ip reputation label keys \"ipreputation.ves.io/threattype\", \"ipreputation.ves.io/threatlevel\"\n - KEY_CLASS_URL_REPUTATION: x-displayName: \"Key Class URL Reputation\"\nInclude url reputation label keys \"urlreputation.ves.io/category\", \"urlreputation.ves.io/reputationlevel\"\n - KEY_CLASS_GEOIP_EXTENDED: x-displayName: \"Key Class GeoIp Extended\"\nIncludes implicit geoip label keys \"geoip.ves.io/continent\"\n - KEY_CLASS_DNS_GEOIP: x-displayName: \"Key Class DNS GeoIp\"\nIncludes implicit geoip label keys  \"geoip.ves.io/region\", \"geoip.ves.io/country\" and \"geoip.ves.io/continent\"\n - KEY_CLASS_AWS: x-displayName: \"Key Class AWS\"\nImplicit aws resource labels (dynamically queried). This may be vpc level tags and/or subnet level tags",
            "title": "LabelKeyClass",
            "enum": [
                "KEY_CLASS_GENERIC",
                "KEY_CLASS_KNOWN",
                "KEY_CLASS_GEOIP",
                "KEY_CLASS_IMPLICIT",
                "KEY_CLASS_IP_REPUTATION",
                "KEY_CLASS_URL_REPUTATION",
                "KEY_CLASS_GEOIP_EXTENDED",
                "KEY_CLASS_DNS_GEOIP",
                "KEY_CLASS_AWS"
            ],
            "default": "KEY_CLASS_GENERIC"
        }
    },
    "x-displayname": "Implicit Label",
    "x-ves-proto-file": "ves.io/schema/implicit_label/public_customapi.proto"
}`
