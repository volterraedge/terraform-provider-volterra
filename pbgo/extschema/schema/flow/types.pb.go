// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/flow/types.proto

package flow

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// FieldSelector
//
// x-displayName: "Field selector"
// Field selector for flow data
type FieldSelector int32

const (
	// x-displayName: "Bytes"
	// x-unit: "bytes"
	BYTES FieldSelector = 0
	// x-displayName: "Packets"
	// x-unit: "packets"
	PACKETS FieldSelector = 1
	// x-displayName: "Dropped packets"
	// x-unit: "packets"
	DROPPED_PACKETS FieldSelector = 2
	// x-displayName: "Transmitted bytes"
	// x-unit: "bytes"
	TX_BYTES FieldSelector = 10
	// x-displayName: "Transmitted packets"
	// x-unit: "packets"
	TX_PACKETS FieldSelector = 11
	// x-displayName: "Transmitted dropped packets"
	// x-unit: "packets"
	TX_DROPPED_PACKETS FieldSelector = 12
	// x-displayName: "flow count"
	// x-unit: "count"
	FLOW_COUNT FieldSelector = 13
)

var FieldSelector_name = map[int32]string{
	0:  "BYTES",
	1:  "PACKETS",
	2:  "DROPPED_PACKETS",
	10: "TX_BYTES",
	11: "TX_PACKETS",
	12: "TX_DROPPED_PACKETS",
	13: "FLOW_COUNT",
}

var FieldSelector_value = map[string]int32{
	"BYTES":              0,
	"PACKETS":            1,
	"DROPPED_PACKETS":    2,
	"TX_BYTES":           10,
	"TX_PACKETS":         11,
	"TX_DROPPED_PACKETS": 12,
	"FLOW_COUNT":         13,
}

func (FieldSelector) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8197e92867a4bfea, []int{0}
}

// Labels
//
// x-displayName: "Labels"
// Labels is used to select one or more fields for the data
type Label int32

const (
	// x-displayName: "Site"
	// Identifies the site .
	SITE Label = 0
	// x-displayName: "Source IP address"
	// Identifies the source IP address.
	SRC_IP Label = 12
	// x-displayName: "Source port"
	// Identifies the source port.
	SRC_PORT Label = 13
	// x-displayName: "Destination IP address"
	// Identifies the destination IP address.
	DST_IP Label = 32
	// x-displayName: "Destination port"
	// Identifies the destination port.
	DST_PORT Label = 33
	// x-displayName: "Protocol"
	// Identifies the protocol.
	PROTOCOL Label = 50
	// x-displayName: "Application name"
	// Identifies the application by name.
	APP_NAME Label = 60
	// x-displayName: "NFV Service"
	// NFV Service
	NFV_SERVICE Label = 61
	// x-displayName: "NFV Service instance"
	// NFV Service instance
	NFV_SERVICE_INSTANCE Label = 62
	// x-displayName: "NFV Service instance hostname"
	// NFV Service instance hostname
	NFV_SERVICE_INSTANCE_HOSTNAME Label = 63
	// x-displayName: "Source Site"
	// Source Site
	SRC_SITE Label = 64
	// x-displayName: "Destination Site"
	// Destination Site
	DST_SITE Label = 65
	// x-displayName: "Source Provider Type"
	// Source Provider Type
	SRC_PROVIDER_TYPE Label = 66
	// x-displayName: "Destination Provider Type"
	// Destination Provider Type
	DST_PROVIDER_TYPE Label = 67
	// x-displayName: "Source Subnet"
	// Source Subnet
	SRC_SUBNET Label = 68
	// x-displayName: "Destination Subnet"
	// Destination Subnet
	DST_SUBNET Label = 69
	// x-displayName: "Source Network"
	// Source Newtork
	SRC_NETWORK Label = 70
	// x-displayName: "Destination Network"
	// Destination Network
	DST_NETWORK Label = 71
	// x-displayName: "Cloud Connect"
	// Cloud Connect
	CLOUD_CONNECT Label = 72
	// x-displayName: "Anomaly Level"
	// Anomaly Level
	ANOMALY_LEVEL Label = 73
)

var Label_name = map[int32]string{
	0:  "SITE",
	12: "SRC_IP",
	13: "SRC_PORT",
	32: "DST_IP",
	33: "DST_PORT",
	50: "PROTOCOL",
	60: "APP_NAME",
	61: "NFV_SERVICE",
	62: "NFV_SERVICE_INSTANCE",
	63: "NFV_SERVICE_INSTANCE_HOSTNAME",
	64: "SRC_SITE",
	65: "DST_SITE",
	66: "SRC_PROVIDER_TYPE",
	67: "DST_PROVIDER_TYPE",
	68: "SRC_SUBNET",
	69: "DST_SUBNET",
	70: "SRC_NETWORK",
	71: "DST_NETWORK",
	72: "CLOUD_CONNECT",
	73: "ANOMALY_LEVEL",
}

var Label_value = map[string]int32{
	"SITE":                          0,
	"SRC_IP":                        12,
	"SRC_PORT":                      13,
	"DST_IP":                        32,
	"DST_PORT":                      33,
	"PROTOCOL":                      50,
	"APP_NAME":                      60,
	"NFV_SERVICE":                   61,
	"NFV_SERVICE_INSTANCE":          62,
	"NFV_SERVICE_INSTANCE_HOSTNAME": 63,
	"SRC_SITE":                      64,
	"DST_SITE":                      65,
	"SRC_PROVIDER_TYPE":             66,
	"DST_PROVIDER_TYPE":             67,
	"SRC_SUBNET":                    68,
	"DST_SUBNET":                    69,
	"SRC_NETWORK":                   70,
	"DST_NETWORK":                   71,
	"CLOUD_CONNECT":                 72,
	"ANOMALY_LEVEL":                 73,
}

func (Label) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8197e92867a4bfea, []int{1}
}

type AnomalyLevel int32

const (
	// x-displayName: "Low"
	// Low anomaly level
	LOW_ANOMALY_LEVEL AnomalyLevel = 0
	// x-displayName: "Medium"
	// Medium anomaly level
	MEDIUM_ANOMALY_LEVEL AnomalyLevel = 1
	// x-displayName: "High"
	// High anomaly level
	HIGH_ANOMALY_LEVEL AnomalyLevel = 2
)

var AnomalyLevel_name = map[int32]string{
	0: "LOW_ANOMALY_LEVEL",
	1: "MEDIUM_ANOMALY_LEVEL",
	2: "HIGH_ANOMALY_LEVEL",
}

var AnomalyLevel_value = map[string]int32{
	"LOW_ANOMALY_LEVEL":    0,
	"MEDIUM_ANOMALY_LEVEL": 1,
	"HIGH_ANOMALY_LEVEL":   2,
}

func (AnomalyLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8197e92867a4bfea, []int{2}
}

// Service Type
//
// x-displayName: "Service Type"
// Service type for subscribing/unsubscribing flow-collection/flow-anomaly-detection
type ServiceType int32

const (
	// x-displayName: "Flow Collection"
	// by default flow collection is subscribed/unsubscribed
	FLOW_COLLECTION ServiceType = 0
	// x-displayName: "Flow Anomaly Detection"
	// Flow Anomaly Detection
	FLOW_ANOMALY_DETECTION ServiceType = 1
	// x-displayName: "Flow Collection And Anomaly Detection"
	// Subscribe/unsubscribe to both flow collection and anomaly detection
	FLOW_COLLECTION_AND_ANOMALY_DETECTION ServiceType = 2
)

var ServiceType_name = map[int32]string{
	0: "FLOW_COLLECTION",
	1: "FLOW_ANOMALY_DETECTION",
	2: "FLOW_COLLECTION_AND_ANOMALY_DETECTION",
}

var ServiceType_value = map[string]int32{
	"FLOW_COLLECTION":                       0,
	"FLOW_ANOMALY_DETECTION":                1,
	"FLOW_COLLECTION_AND_ANOMALY_DETECTION": 2,
}

func (ServiceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8197e92867a4bfea, []int{3}
}

// Sort Direction
//
// x-displayName: "Sort Direction"
// Sort Direction for sorting data
type SortDirection int32

const (
	// x-displayName: "Sort Direction Desc"
	// Sort Direction Desc
	// by default data is sorted in descending direction
	SORT_DIRECTION_DESC SortDirection = 0
	// x-displayName: "Sort Direction Asc"
	// Sort Direction Asc
	SORT_DIRECTION_ASC SortDirection = 1
)

var SortDirection_name = map[int32]string{
	0: "SORT_DIRECTION_DESC",
	1: "SORT_DIRECTION_ASC",
}

var SortDirection_value = map[string]int32{
	"SORT_DIRECTION_DESC": 0,
	"SORT_DIRECTION_ASC":  1,
}

func (SortDirection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8197e92867a4bfea, []int{4}
}

// Sort Label
//
// x-displayName: "Sort Label"
// Sort Labels for sorting data
type SortLabel int32

const (
	// x-displayName: "None"
	// Sort Label None
	SORT_LABEL_NONE SortLabel = 0
	// x-displayName: "Sort Label Bytes"
	// Sort Label Bytes
	SORT_LABEL_BYTES SortLabel = 1
	// x-displayName: "Sort Label Flow Count"
	// Sort Label Flow Count
	SORT_LABEL_FLOW_COUNT SortLabel = 2
	// x-displayName: "Sort Label Anomaly Level"
	// Sort Label Anomaly level
	SORT_LABEL_ANOMALY_LEVEL SortLabel = 3
	// x-displayName: "Sort Label Anomaly Duration"
	// Sort Label Anomaly Duration
	SORT_LABEL_ANOMALY_DURATION SortLabel = 4
)

var SortLabel_name = map[int32]string{
	0: "SORT_LABEL_NONE",
	1: "SORT_LABEL_BYTES",
	2: "SORT_LABEL_FLOW_COUNT",
	3: "SORT_LABEL_ANOMALY_LEVEL",
	4: "SORT_LABEL_ANOMALY_DURATION",
}

var SortLabel_value = map[string]int32{
	"SORT_LABEL_NONE":             0,
	"SORT_LABEL_BYTES":            1,
	"SORT_LABEL_FLOW_COUNT":       2,
	"SORT_LABEL_ANOMALY_LEVEL":    3,
	"SORT_LABEL_ANOMALY_DURATION": 4,
}

func (SortLabel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8197e92867a4bfea, []int{5}
}

// FlowData
//
// x-displayName: "FlowData"
// FlowData wraps all the response data
type FlowData struct {
	// Type
	//
	// x-displayName: "Type"
	// Type of data returned
	Type FieldSelector `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.flow.FieldSelector" json:"type,omitempty"`
	// Data
	//
	// x-displayName: "Data"
	// Flows data
	Data []*FieldData `protobuf:"bytes,2,rep,name=data,proto3" json:"data,omitempty"`
	// Unit
	//
	// x-displayName: "Unit"
	// Unit for the metric value
	Unit schema.UnitType `protobuf:"varint,3,opt,name=unit,proto3,enum=ves.io.schema.UnitType" json:"unit,omitempty"`
}

func (m *FlowData) Reset()      { *m = FlowData{} }
func (*FlowData) ProtoMessage() {}
func (*FlowData) Descriptor() ([]byte, []int) {
	return fileDescriptor_8197e92867a4bfea, []int{0}
}
func (m *FlowData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FlowData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowData.Merge(m, src)
}
func (m *FlowData) XXX_Size() int {
	return m.Size()
}
func (m *FlowData) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowData.DiscardUnknown(m)
}

var xxx_messageInfo_FlowData proto.InternalMessageInfo

func (m *FlowData) GetType() FieldSelector {
	if m != nil {
		return m.Type
	}
	return BYTES
}

func (m *FlowData) GetData() []*FieldData {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *FlowData) GetUnit() schema.UnitType {
	if m != nil {
		return m.Unit
	}
	return schema.UNIT_MILLISECONDS
}

// Field Data
//
// x-displayName: "Field Data"
// Field Data contains key/value pairs that uniquely identifies the group_by labels specified in the request.
type FieldData struct {
	// Labels
	//
	// x-displayName: "Labels"
	// Labels contains the name/value pair.
	// "name" is the label defined in Labels
	Labels map[string]string `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Value
	//
	// x-displayName: "Value"
	// List of metric values.
	Value []*schema.MetricValue `protobuf:"bytes,2,rep,name=value,proto3" json:"value,omitempty"`
}

func (m *FieldData) Reset()      { *m = FieldData{} }
func (*FieldData) ProtoMessage() {}
func (*FieldData) Descriptor() ([]byte, []int) {
	return fileDescriptor_8197e92867a4bfea, []int{1}
}
func (m *FieldData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FieldData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FieldData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FieldData.Merge(m, src)
}
func (m *FieldData) XXX_Size() int {
	return m.Size()
}
func (m *FieldData) XXX_DiscardUnknown() {
	xxx_messageInfo_FieldData.DiscardUnknown(m)
}

var xxx_messageInfo_FieldData proto.InternalMessageInfo

func (m *FieldData) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *FieldData) GetValue() []*schema.MetricValue {
	if m != nil {
		return m.Value
	}
	return nil
}

// FlowAnomalyData wraps the response data for top flow anomalies.
// x-displayName: "FlowAnomalyData"
type FlowAnomalyData struct {
	// x-displayName: "Type"
	// Type of data returned
	Type FieldSelector `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.flow.FieldSelector" json:"type,omitempty"`
	// x-displayName: "AnomalyData"
	// Anomaly Data
	AnomalyData []*AnomalyData `protobuf:"bytes,2,rep,name=anomaly_data,json=anomalyData,proto3" json:"anomaly_data,omitempty"`
}

func (m *FlowAnomalyData) Reset()      { *m = FlowAnomalyData{} }
func (*FlowAnomalyData) ProtoMessage() {}
func (*FlowAnomalyData) Descriptor() ([]byte, []int) {
	return fileDescriptor_8197e92867a4bfea, []int{2}
}
func (m *FlowAnomalyData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowAnomalyData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FlowAnomalyData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowAnomalyData.Merge(m, src)
}
func (m *FlowAnomalyData) XXX_Size() int {
	return m.Size()
}
func (m *FlowAnomalyData) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowAnomalyData.DiscardUnknown(m)
}

var xxx_messageInfo_FlowAnomalyData proto.InternalMessageInfo

func (m *FlowAnomalyData) GetType() FieldSelector {
	if m != nil {
		return m.Type
	}
	return BYTES
}

func (m *FlowAnomalyData) GetAnomalyData() []*AnomalyData {
	if m != nil {
		return m.AnomalyData
	}
	return nil
}

// x-displayName: "Anomaly Data"
// Anomaly Data contains key/value pairs that uniquely identifies the group_by labels specified in the request.
type AnomalyData struct {
	// Labels with metadata about the anomaly
	// Key is the label name defined in the Labels enum.
	// x-displayName: "Labels"
	Labels map[string]string `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Time when the anomaly began.
	// x-displayName: "Anomaly start time"
	// x-example: "2021-01-22 15:46:23.767649"
	AnomalyStartTime *types.Timestamp `protobuf:"bytes,2,opt,name=anomaly_start_time,json=anomalyStartTime,proto3" json:"anomaly_start_time,omitempty"`
	// Time between anomaly start and last seen time.
	// x-displayName: "Anomaly duration"
	// x-example: "300"
	AnomalyDurationSeconds int64 `protobuf:"varint,3,opt,name=anomaly_duration_seconds,json=anomalyDurationSeconds,proto3" json:"anomaly_duration_seconds,omitempty"`
	// Anomalous data transferred in bytes
	// x-displayName: "Anomalous Data Transferred"
	AnomalousDataTransferred int64 `protobuf:"varint,4,opt,name=anomalous_data_transferred,json=anomalousDataTransferred,proto3" json:"anomalous_data_transferred,omitempty"`
	// Anomaly level
	// x-displayName: "Anomaly level"
	AnomalyLevel AnomalyLevel `protobuf:"varint,5,opt,name=anomaly_level,json=anomalyLevel,proto3,enum=ves.io.schema.flow.AnomalyLevel" json:"anomaly_level,omitempty"`
	// Total data transferred in bytes
	// x-displayName: "Total Data Transferred"
	TotalDataTransferred int64 `protobuf:"varint,6,opt,name=total_data_transferred,json=totalDataTransferred,proto3" json:"total_data_transferred,omitempty"`
	// Time when the anomaly detection scan was last run.
	// x-displayName: "Scan time"
	// x-example: "2021-01-22 15:46:23.767649"
	ScanTime *types.Timestamp `protobuf:"bytes,7,opt,name=scan_time,json=scanTime,proto3" json:"scan_time,omitempty"`
	// Anomaly Score
	// Higher value indicates more a anomalous datapoint.
	// x-displayName: "Anomaly score"
	AnomalyScore float32 `protobuf:"fixed32,8,opt,name=anomaly_score,json=anomalyScore,proto3" json:"anomaly_score,omitempty"`
	// Count of anomalous flows
	// x-displayName: "Flow Count"
	// x-example: "100000"
	FlowCount int64 `protobuf:"varint,9,opt,name=flow_count,json=flowCount,proto3" json:"flow_count,omitempty"`
}

func (m *AnomalyData) Reset()      { *m = AnomalyData{} }
func (*AnomalyData) ProtoMessage() {}
func (*AnomalyData) Descriptor() ([]byte, []int) {
	return fileDescriptor_8197e92867a4bfea, []int{3}
}
func (m *AnomalyData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnomalyData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AnomalyData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnomalyData.Merge(m, src)
}
func (m *AnomalyData) XXX_Size() int {
	return m.Size()
}
func (m *AnomalyData) XXX_DiscardUnknown() {
	xxx_messageInfo_AnomalyData.DiscardUnknown(m)
}

var xxx_messageInfo_AnomalyData proto.InternalMessageInfo

func (m *AnomalyData) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *AnomalyData) GetAnomalyStartTime() *types.Timestamp {
	if m != nil {
		return m.AnomalyStartTime
	}
	return nil
}

func (m *AnomalyData) GetAnomalyDurationSeconds() int64 {
	if m != nil {
		return m.AnomalyDurationSeconds
	}
	return 0
}

func (m *AnomalyData) GetAnomalousDataTransferred() int64 {
	if m != nil {
		return m.AnomalousDataTransferred
	}
	return 0
}

func (m *AnomalyData) GetAnomalyLevel() AnomalyLevel {
	if m != nil {
		return m.AnomalyLevel
	}
	return LOW_ANOMALY_LEVEL
}

func (m *AnomalyData) GetTotalDataTransferred() int64 {
	if m != nil {
		return m.TotalDataTransferred
	}
	return 0
}

func (m *AnomalyData) GetScanTime() *types.Timestamp {
	if m != nil {
		return m.ScanTime
	}
	return nil
}

func (m *AnomalyData) GetAnomalyScore() float32 {
	if m != nil {
		return m.AnomalyScore
	}
	return 0
}

func (m *AnomalyData) GetFlowCount() int64 {
	if m != nil {
		return m.FlowCount
	}
	return 0
}

// SubscribeRequest
//
// x-displayName: "Subscribe Request"
// Request to subscribe to Flow Collection
type SubscribeRequest struct {
	// Service Type
	//
	// x-displayName: "Service Type"
	// x-example: "FLOW_COLLECTION"
	// Service type to be subscribed/unsubscribed
	ServiceType ServiceType `protobuf:"varint,1,opt,name=service_type,json=serviceType,proto3,enum=ves.io.schema.flow.ServiceType" json:"service_type,omitempty"`
}

func (m *SubscribeRequest) Reset()      { *m = SubscribeRequest{} }
func (*SubscribeRequest) ProtoMessage() {}
func (*SubscribeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8197e92867a4bfea, []int{4}
}
func (m *SubscribeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscribeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SubscribeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeRequest.Merge(m, src)
}
func (m *SubscribeRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubscribeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeRequest proto.InternalMessageInfo

func (m *SubscribeRequest) GetServiceType() ServiceType {
	if m != nil {
		return m.ServiceType
	}
	return FLOW_COLLECTION
}

// SubscribeResponse
//
// x-displayName: "Subscribe Response"
// Response of subscribe to Flow Collection
type SubscribeResponse struct {
	// Last Enabled Time
	//
	// x-displayName: "Last Enabled Time"
	// x-example: "2021-01-22 15:46:23.767649"
	// Last Enabled Time for flow collection subscription request.
	LastEnabledTime *types.Timestamp `protobuf:"bytes,1,opt,name=last_enabled_time,json=lastEnabledTime,proto3" json:"last_enabled_time,omitempty"`
	// Last Enabled Time
	//
	// x-displayName: "Last Enabled Time"
	// x-example: "2021-01-22 15:46:23.767649"
	// Last Enabled Time for flow anomaly detection subscription request.
	FlowAnomalyDetectionLastEnabledTime *types.Timestamp `protobuf:"bytes,2,opt,name=flow_anomaly_detection_last_enabled_time,json=flowAnomalyDetectionLastEnabledTime,proto3" json:"flow_anomaly_detection_last_enabled_time,omitempty"`
}

func (m *SubscribeResponse) Reset()      { *m = SubscribeResponse{} }
func (*SubscribeResponse) ProtoMessage() {}
func (*SubscribeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8197e92867a4bfea, []int{5}
}
func (m *SubscribeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscribeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SubscribeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeResponse.Merge(m, src)
}
func (m *SubscribeResponse) XXX_Size() int {
	return m.Size()
}
func (m *SubscribeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeResponse proto.InternalMessageInfo

func (m *SubscribeResponse) GetLastEnabledTime() *types.Timestamp {
	if m != nil {
		return m.LastEnabledTime
	}
	return nil
}

func (m *SubscribeResponse) GetFlowAnomalyDetectionLastEnabledTime() *types.Timestamp {
	if m != nil {
		return m.FlowAnomalyDetectionLastEnabledTime
	}
	return nil
}

// UnsubscribeRequest
//
// x-displayName: "Unsubscribe Request"
// Request to unsubscribe to Flow Collection
type UnsubscribeRequest struct {
	// Service Type
	//
	// x-displayName: "Service Type"
	// x-example: "FLOW_COLLECTION"
	// Service type to be subscribed/unsubscribed
	// for Unsubscribe flow_collection service_type will unsubscribe flow_anomaly_detection as well.
	ServiceType ServiceType `protobuf:"varint,1,opt,name=service_type,json=serviceType,proto3,enum=ves.io.schema.flow.ServiceType" json:"service_type,omitempty"`
}

func (m *UnsubscribeRequest) Reset()      { *m = UnsubscribeRequest{} }
func (*UnsubscribeRequest) ProtoMessage() {}
func (*UnsubscribeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8197e92867a4bfea, []int{6}
}
func (m *UnsubscribeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnsubscribeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UnsubscribeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnsubscribeRequest.Merge(m, src)
}
func (m *UnsubscribeRequest) XXX_Size() int {
	return m.Size()
}
func (m *UnsubscribeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnsubscribeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnsubscribeRequest proto.InternalMessageInfo

func (m *UnsubscribeRequest) GetServiceType() ServiceType {
	if m != nil {
		return m.ServiceType
	}
	return FLOW_COLLECTION
}

// UnsubscribeResponse
//
// x-displayName: "Unsubscribe Response"
// Response of unsubscribe to Flow Collection
type UnsubscribeResponse struct {
}

func (m *UnsubscribeResponse) Reset()      { *m = UnsubscribeResponse{} }
func (*UnsubscribeResponse) ProtoMessage() {}
func (*UnsubscribeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8197e92867a4bfea, []int{7}
}
func (m *UnsubscribeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnsubscribeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UnsubscribeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnsubscribeResponse.Merge(m, src)
}
func (m *UnsubscribeResponse) XXX_Size() int {
	return m.Size()
}
func (m *UnsubscribeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnsubscribeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnsubscribeResponse proto.InternalMessageInfo

// SubscriptionStatusRequest
//
// x-displayName: "Subscription status Request"
// Request to check subscription status for Flow Collection
type SubscriptionStatusRequest struct {
}

func (m *SubscriptionStatusRequest) Reset()      { *m = SubscriptionStatusRequest{} }
func (*SubscriptionStatusRequest) ProtoMessage() {}
func (*SubscriptionStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8197e92867a4bfea, []int{8}
}
func (m *SubscriptionStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscriptionStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SubscriptionStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscriptionStatusRequest.Merge(m, src)
}
func (m *SubscriptionStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubscriptionStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscriptionStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscriptionStatusRequest proto.InternalMessageInfo

// SubscriptionStatusResponse
//
// x-displayName: "Subscribe Response"
// Response of subscription status for Flow Collection
type SubscriptionStatusResponse struct {
	// Last Enabled Time
	//
	// x-displayName: "Last Enabled Time"
	// x-example: "2021-01-22 15:46:23.767649"
	// Last Enabled Time for flow collection subscription request.
	LastEnabledTime *types.Timestamp `protobuf:"bytes,1,opt,name=last_enabled_time,json=lastEnabledTime,proto3" json:"last_enabled_time,omitempty"`
	// Result
	//
	// x-displayName: "Result"
	// x-example: "AS_SUB_ALLOWED"
	// result of addon service subscription check
	Result schema.AddonServiceState `protobuf:"varint,2,opt,name=result,proto3,enum=ves.io.schema.AddonServiceState" json:"result,omitempty"`
	// Last Enabled Time
	//
	// x-displayName: "Last Enabled Time"
	// x-example: "2021-01-22 15:46:23.767649"
	// Last Enabled Time for flow anomaly detection subscription request.
	FlowAnomalyDetectionLastEnabledTime *types.Timestamp `protobuf:"bytes,3,opt,name=flow_anomaly_detection_last_enabled_time,json=flowAnomalyDetectionLastEnabledTime,proto3" json:"flow_anomaly_detection_last_enabled_time,omitempty"`
	// Result
	//
	// x-displayName: "Result"
	// x-example: "AS_SUB_ALLOWED"
	// result of addon service subscription check
	FlowAnomalyDetectionResult schema.AddonServiceState `protobuf:"varint,4,opt,name=flow_anomaly_detection_result,json=flowAnomalyDetectionResult,proto3,enum=ves.io.schema.AddonServiceState" json:"flow_anomaly_detection_result,omitempty"`
}

func (m *SubscriptionStatusResponse) Reset()      { *m = SubscriptionStatusResponse{} }
func (*SubscriptionStatusResponse) ProtoMessage() {}
func (*SubscriptionStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8197e92867a4bfea, []int{9}
}
func (m *SubscriptionStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscriptionStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SubscriptionStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscriptionStatusResponse.Merge(m, src)
}
func (m *SubscriptionStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *SubscriptionStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscriptionStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubscriptionStatusResponse proto.InternalMessageInfo

func (m *SubscriptionStatusResponse) GetLastEnabledTime() *types.Timestamp {
	if m != nil {
		return m.LastEnabledTime
	}
	return nil
}

func (m *SubscriptionStatusResponse) GetResult() schema.AddonServiceState {
	if m != nil {
		return m.Result
	}
	return schema.AS_NONE
}

func (m *SubscriptionStatusResponse) GetFlowAnomalyDetectionLastEnabledTime() *types.Timestamp {
	if m != nil {
		return m.FlowAnomalyDetectionLastEnabledTime
	}
	return nil
}

func (m *SubscriptionStatusResponse) GetFlowAnomalyDetectionResult() schema.AddonServiceState {
	if m != nil {
		return m.FlowAnomalyDetectionResult
	}
	return schema.AS_NONE
}

// SortBy
//
// x-displayName: "Sort By"
// Sorting for data by given fields
type SortBy struct {
	// Label
	//
	// x-displayName: "Label"
	// x-example: "BYTES"
	// label or field on which we need sorting
	SortLabel SortLabel `protobuf:"varint,1,opt,name=sort_label,json=sortLabel,proto3,enum=ves.io.schema.flow.SortLabel" json:"sort_label,omitempty"`
	// Sort Direction
	//
	// x-displayName: "Sort Direction"
	// x-example: "SORT_DIRECTION_DESC"
	// Direction of sorting
	SortDirection SortDirection `protobuf:"varint,2,opt,name=sort_direction,json=sortDirection,proto3,enum=ves.io.schema.flow.SortDirection" json:"sort_direction,omitempty"`
}

func (m *SortBy) Reset()      { *m = SortBy{} }
func (*SortBy) ProtoMessage() {}
func (*SortBy) Descriptor() ([]byte, []int) {
	return fileDescriptor_8197e92867a4bfea, []int{10}
}
func (m *SortBy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SortBy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SortBy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SortBy.Merge(m, src)
}
func (m *SortBy) XXX_Size() int {
	return m.Size()
}
func (m *SortBy) XXX_DiscardUnknown() {
	xxx_messageInfo_SortBy.DiscardUnknown(m)
}

var xxx_messageInfo_SortBy proto.InternalMessageInfo

func (m *SortBy) GetSortLabel() SortLabel {
	if m != nil {
		return m.SortLabel
	}
	return SORT_LABEL_NONE
}

func (m *SortBy) GetSortDirection() SortDirection {
	if m != nil {
		return m.SortDirection
	}
	return SORT_DIRECTION_DESC
}

func init() {
	proto.RegisterEnum("ves.io.schema.flow.FieldSelector", FieldSelector_name, FieldSelector_value)
	golang_proto.RegisterEnum("ves.io.schema.flow.FieldSelector", FieldSelector_name, FieldSelector_value)
	proto.RegisterEnum("ves.io.schema.flow.Label", Label_name, Label_value)
	golang_proto.RegisterEnum("ves.io.schema.flow.Label", Label_name, Label_value)
	proto.RegisterEnum("ves.io.schema.flow.AnomalyLevel", AnomalyLevel_name, AnomalyLevel_value)
	golang_proto.RegisterEnum("ves.io.schema.flow.AnomalyLevel", AnomalyLevel_name, AnomalyLevel_value)
	proto.RegisterEnum("ves.io.schema.flow.ServiceType", ServiceType_name, ServiceType_value)
	golang_proto.RegisterEnum("ves.io.schema.flow.ServiceType", ServiceType_name, ServiceType_value)
	proto.RegisterEnum("ves.io.schema.flow.SortDirection", SortDirection_name, SortDirection_value)
	golang_proto.RegisterEnum("ves.io.schema.flow.SortDirection", SortDirection_name, SortDirection_value)
	proto.RegisterEnum("ves.io.schema.flow.SortLabel", SortLabel_name, SortLabel_value)
	golang_proto.RegisterEnum("ves.io.schema.flow.SortLabel", SortLabel_name, SortLabel_value)
	proto.RegisterType((*FlowData)(nil), "ves.io.schema.flow.FlowData")
	golang_proto.RegisterType((*FlowData)(nil), "ves.io.schema.flow.FlowData")
	proto.RegisterType((*FieldData)(nil), "ves.io.schema.flow.FieldData")
	golang_proto.RegisterType((*FieldData)(nil), "ves.io.schema.flow.FieldData")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.flow.FieldData.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.flow.FieldData.LabelsEntry")
	proto.RegisterType((*FlowAnomalyData)(nil), "ves.io.schema.flow.FlowAnomalyData")
	golang_proto.RegisterType((*FlowAnomalyData)(nil), "ves.io.schema.flow.FlowAnomalyData")
	proto.RegisterType((*AnomalyData)(nil), "ves.io.schema.flow.AnomalyData")
	golang_proto.RegisterType((*AnomalyData)(nil), "ves.io.schema.flow.AnomalyData")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.flow.AnomalyData.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.flow.AnomalyData.LabelsEntry")
	proto.RegisterType((*SubscribeRequest)(nil), "ves.io.schema.flow.SubscribeRequest")
	golang_proto.RegisterType((*SubscribeRequest)(nil), "ves.io.schema.flow.SubscribeRequest")
	proto.RegisterType((*SubscribeResponse)(nil), "ves.io.schema.flow.SubscribeResponse")
	golang_proto.RegisterType((*SubscribeResponse)(nil), "ves.io.schema.flow.SubscribeResponse")
	proto.RegisterType((*UnsubscribeRequest)(nil), "ves.io.schema.flow.UnsubscribeRequest")
	golang_proto.RegisterType((*UnsubscribeRequest)(nil), "ves.io.schema.flow.UnsubscribeRequest")
	proto.RegisterType((*UnsubscribeResponse)(nil), "ves.io.schema.flow.UnsubscribeResponse")
	golang_proto.RegisterType((*UnsubscribeResponse)(nil), "ves.io.schema.flow.UnsubscribeResponse")
	proto.RegisterType((*SubscriptionStatusRequest)(nil), "ves.io.schema.flow.SubscriptionStatusRequest")
	golang_proto.RegisterType((*SubscriptionStatusRequest)(nil), "ves.io.schema.flow.SubscriptionStatusRequest")
	proto.RegisterType((*SubscriptionStatusResponse)(nil), "ves.io.schema.flow.SubscriptionStatusResponse")
	golang_proto.RegisterType((*SubscriptionStatusResponse)(nil), "ves.io.schema.flow.SubscriptionStatusResponse")
	proto.RegisterType((*SortBy)(nil), "ves.io.schema.flow.SortBy")
	golang_proto.RegisterType((*SortBy)(nil), "ves.io.schema.flow.SortBy")
}

func init() { proto.RegisterFile("ves.io/schema/flow/types.proto", fileDescriptor_8197e92867a4bfea) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/flow/types.proto", fileDescriptor_8197e92867a4bfea)
}

var fileDescriptor_8197e92867a4bfea = []byte{
	// 1396 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0x41, 0x73, 0xdb, 0x44,
	0x14, 0xf6, 0x3a, 0x4e, 0x1a, 0x3f, 0x27, 0x8d, 0xb2, 0x4d, 0x53, 0xd7, 0x6d, 0x94, 0xc4, 0x1d,
	0x66, 0xd2, 0x74, 0x6a, 0x43, 0x81, 0xa1, 0x30, 0x05, 0xea, 0x48, 0x4a, 0xe3, 0xa9, 0x23, 0x79,
	0x24, 0x25, 0x4d, 0xb9, 0x68, 0x64, 0x7b, 0xe3, 0x6a, 0xaa, 0x58, 0xae, 0xb4, 0x4e, 0xc9, 0x8d,
	0xe1, 0xc0, 0x89, 0x43, 0xff, 0x02, 0x37, 0xfe, 0x03, 0x17, 0x8e, 0x70, 0x61, 0x7a, 0xec, 0x91,
	0x38, 0x17, 0x8e, 0x3d, 0x71, 0x66, 0x76, 0x25, 0x39, 0xb2, 0xe3, 0x36, 0x30, 0x2d, 0xb7, 0xdd,
	0xf7, 0x7d, 0xef, 0xbd, 0x6f, 0xbf, 0x7d, 0x6b, 0x8d, 0x41, 0x3c, 0x24, 0x41, 0xc9, 0xf1, 0xca,
	0x41, 0xf3, 0x09, 0x39, 0xb0, 0xcb, 0xfb, 0xae, 0xf7, 0xbc, 0x4c, 0x8f, 0xba, 0x24, 0x28, 0x75,
	0x7d, 0x8f, 0x7a, 0x18, 0x87, 0x78, 0x29, 0xc4, 0x4b, 0x0c, 0x2f, 0xdc, 0x6e, 0x3b, 0xf4, 0x49,
	0xaf, 0x51, 0x6a, 0x7a, 0x07, 0xe5, 0xb6, 0xd7, 0xf6, 0xca, 0x9c, 0xda, 0xe8, 0xed, 0xf3, 0x1d,
	0xdf, 0xf0, 0x55, 0x58, 0xa2, 0xb0, 0xdc, 0xf6, 0xbc, 0xb6, 0x4b, 0x4e, 0x59, 0xd4, 0x39, 0x20,
	0x01, 0xb5, 0x0f, 0xba, 0x11, 0xe1, 0xca, 0xb0, 0x86, 0x0e, 0xa1, 0x11, 0x70, 0x6d, 0x18, 0xf0,
	0xba, 0xd4, 0xf1, 0x3a, 0x91, 0xb2, 0xc2, 0xd5, 0x61, 0x30, 0x21, 0xba, 0x70, 0x7d, 0x18, 0x3a,
	0xb4, 0x5d, 0xa7, 0x65, 0x53, 0x12, 0xa1, 0x2b, 0x23, 0xa8, 0x43, 0x9e, 0x5b, 0xc3, 0xa5, 0x97,
	0xcf, 0x32, 0x82, 0x64, 0x83, 0xe2, 0x4f, 0x08, 0xa6, 0x37, 0x5d, 0xef, 0xb9, 0x6c, 0x53, 0x1b,
	0x7f, 0x0a, 0x19, 0x86, 0xe5, 0xd1, 0x0a, 0x5a, 0xbb, 0x78, 0x67, 0xb5, 0x74, 0xd6, 0xb1, 0xd2,
	0xa6, 0x43, 0xdc, 0x96, 0x41, 0x5c, 0xd2, 0xa4, 0x9e, 0xaf, 0x73, 0x3a, 0xfe, 0x08, 0x32, 0x2d,
	0x9b, 0xda, 0xf9, 0xf4, 0xca, 0xc4, 0x5a, 0xee, 0xce, 0xd2, 0x1b, 0xd3, 0x58, 0x0f, 0x9d, 0x53,
	0xf1, 0x2d, 0xc8, 0xf4, 0x3a, 0x0e, 0xcd, 0x4f, 0xf0, 0x4e, 0x57, 0x46, 0x52, 0x76, 0x3a, 0x0e,
	0x35, 0x8f, 0xba, 0x44, 0xe7, 0xa4, 0xe2, 0x2f, 0x08, 0xb2, 0x83, 0x02, 0xb8, 0x02, 0x53, 0xae,
	0xdd, 0x20, 0x6e, 0x90, 0x47, 0xbc, 0xdf, 0xcd, 0xb7, 0xf6, 0x2b, 0xd5, 0x38, 0x57, 0xe9, 0x50,
	0xff, 0x48, 0x8f, 0x12, 0xf1, 0x87, 0x30, 0x79, 0x68, 0xbb, 0x3d, 0x12, 0x29, 0x2e, 0x8c, 0x54,
	0xd8, 0x26, 0xd4, 0x77, 0x9a, 0xbb, 0x8c, 0xa1, 0x87, 0xc4, 0xc2, 0xe7, 0x90, 0x4b, 0x14, 0xc2,
	0x02, 0x4c, 0x3c, 0x25, 0x47, 0xdc, 0xa7, 0xac, 0xce, 0x96, 0x78, 0xe1, 0xb4, 0x24, 0x8b, 0x85,
	0x9b, 0x2f, 0xd2, 0x77, 0x51, 0xf1, 0x47, 0x04, 0x73, 0xcc, 0xe1, 0x4a, 0xc7, 0x3b, 0xb0, 0xdd,
	0xa3, 0x77, 0x31, 0x7a, 0x03, 0x66, 0xec, 0xb0, 0x8a, 0x95, 0x30, 0x7c, 0x79, 0x5c, 0x7a, 0xa2,
	0x9b, 0x9e, 0xb3, 0x4f, 0x37, 0xc5, 0xdf, 0x33, 0x90, 0x4b, 0x4a, 0x91, 0x46, 0xec, 0xbc, 0x75,
	0x4e, 0xb5, 0xb1, 0x86, 0x6e, 0x01, 0x8e, 0x85, 0x05, 0xd4, 0xf6, 0xa9, 0xc5, 0x1e, 0x06, 0xb7,
	0x82, 0xb9, 0x1b, 0xbe, 0x9a, 0x52, 0xfc, 0x6a, 0x4a, 0x66, 0xfc, 0x6a, 0x74, 0x21, 0xca, 0x32,
	0x58, 0x12, 0x0b, 0xe3, 0xbb, 0x90, 0x1f, 0x1c, 0xb1, 0xe7, 0xdb, 0x6c, 0x96, 0xad, 0x80, 0x34,
	0xbd, 0x4e, 0x2b, 0xe0, 0xc3, 0x32, 0xa1, 0x2f, 0xc6, 0xa7, 0x89, 0x60, 0x23, 0x44, 0xf1, 0x3d,
	0x28, 0x84, 0x88, 0xd7, 0x0b, 0xb8, 0x3d, 0x16, 0xf5, 0xed, 0x4e, 0xb0, 0x4f, 0x7c, 0x9f, 0xb4,
	0xf2, 0x19, 0x9e, 0x9b, 0x1f, 0x30, 0xd8, 0x51, 0xcc, 0x53, 0x1c, 0x2b, 0x30, 0x1b, 0xf7, 0x75,
	0xc9, 0x21, 0x71, 0xf3, 0x93, 0xfc, 0x6a, 0x56, 0xde, 0xe2, 0x46, 0x8d, 0xf1, 0xf4, 0xf8, 0x46,
	0xf8, 0x0e, 0x7f, 0x02, 0x8b, 0xd4, 0xa3, 0xb6, 0x7b, 0x56, 0xc0, 0x14, 0x17, 0xb0, 0xc0, 0xd1,
	0xd1, 0xe6, 0x9f, 0x41, 0x36, 0x68, 0xda, 0x9d, 0xd0, 0xb5, 0x0b, 0xe7, 0xba, 0x36, 0xcd, 0xc8,
	0xdc, 0xad, 0x1b, 0xa7, 0xaa, 0x83, 0xa6, 0xe7, 0x93, 0xfc, 0xf4, 0x0a, 0x5a, 0x4b, 0x0f, 0x34,
	0x19, 0x2c, 0x86, 0x97, 0x00, 0x98, 0x6c, 0xab, 0xe9, 0xf5, 0x3a, 0x34, 0x9f, 0xe5, 0x3a, 0xb2,
	0x2c, 0x22, 0xb1, 0xc0, 0xbb, 0x8c, 0xf6, 0x2e, 0x08, 0x46, 0xaf, 0x11, 0x34, 0x7d, 0xa7, 0x41,
	0x74, 0xf2, 0xac, 0x47, 0x02, 0xca, 0x66, 0x34, 0x20, 0xfe, 0xa1, 0xd3, 0x24, 0x56, 0x62, 0xc4,
	0xc7, 0xce, 0xa8, 0x11, 0xf2, 0xf8, 0x4b, 0xcf, 0x05, 0xa7, 0x9b, 0xe2, 0x1f, 0x08, 0xe6, 0x13,
	0x85, 0x83, 0xae, 0xd7, 0x09, 0x08, 0xde, 0x84, 0x79, 0xd7, 0x0e, 0xa8, 0x45, 0x3a, 0x76, 0xc3,
	0x25, 0xad, 0xd0, 0x2d, 0x74, 0xae, 0x5b, 0x73, 0x2c, 0x49, 0x09, 0x73, 0xb8, 0x69, 0xcf, 0x60,
	0x8d, 0xfb, 0x31, 0x98, 0x33, 0x42, 0x49, 0x93, 0x0f, 0xda, 0xd9, 0xf2, 0xe7, 0x8f, 0xf0, 0x8d,
	0xfd, 0xc4, 0xdb, 0x8e, 0x2b, 0xd5, 0x86, 0x5b, 0x16, 0xf7, 0x00, 0xef, 0x74, 0x82, 0xff, 0xc3,
	0xaa, 0xcb, 0x70, 0x69, 0xa8, 0x72, 0xe8, 0x55, 0xf1, 0x1a, 0x5c, 0x8d, 0x0c, 0xe4, 0x9f, 0x03,
	0x83, 0xda, 0xb4, 0x17, 0x44, 0x7d, 0x8b, 0x7f, 0xa7, 0xa1, 0x30, 0x0e, 0x7d, 0xcf, 0x3e, 0xdf,
	0x85, 0x29, 0x9f, 0x04, 0x3d, 0x97, 0x72, 0x17, 0xcf, 0xbe, 0xa5, 0x4a, 0xab, 0xc5, 0x5e, 0x2f,
	0x3f, 0x0b, 0x93, 0x40, 0xf4, 0x88, 0xff, 0x9f, 0x6e, 0x68, 0xe2, 0xbd, 0xdc, 0x10, 0x6e, 0xc2,
	0xd2, 0x1b, 0x5a, 0x46, 0x67, 0xc8, 0xfc, 0xcb, 0x33, 0x14, 0xc6, 0x75, 0xd3, 0x79, 0x8d, 0xe2,
	0x0b, 0x04, 0x53, 0x86, 0xe7, 0xd3, 0x8d, 0x23, 0x7c, 0x0f, 0x20, 0xf0, 0x7c, 0x6a, 0xf1, 0x1f,
	0xd0, 0xe8, 0xe6, 0xc7, 0x7e, 0x39, 0x19, 0x9f, 0xbf, 0x4f, 0x3d, 0x1b, 0xc4, 0x4b, 0xbc, 0x05,
	0x17, 0x79, 0x76, 0xcb, 0xf1, 0xc3, 0x06, 0x91, 0xc5, 0xab, 0x6f, 0xaa, 0x20, 0xc7, 0x44, 0x7d,
	0x36, 0x48, 0x6e, 0xd7, 0xbf, 0x47, 0x30, 0x3b, 0xf4, 0xa9, 0xc1, 0x59, 0x98, 0xdc, 0x78, 0x6c,
	0x2a, 0x86, 0x90, 0xc2, 0x39, 0xb8, 0x50, 0xaf, 0x48, 0x0f, 0x15, 0xd3, 0x10, 0x10, 0xbe, 0x04,
	0x73, 0xb2, 0xae, 0xd5, 0xeb, 0x8a, 0x6c, 0xc5, 0xc1, 0x34, 0x9e, 0x81, 0x69, 0x73, 0xcf, 0x0a,
	0xf9, 0x80, 0x2f, 0x02, 0x98, 0x7b, 0x03, 0x34, 0x87, 0x17, 0x01, 0x9b, 0x7b, 0xd6, 0x68, 0xd6,
	0x0c, 0xe3, 0x6d, 0xd6, 0xb4, 0x47, 0x96, 0xa4, 0xed, 0xa8, 0xa6, 0x30, 0xbb, 0x7e, 0x9c, 0x86,
	0xc9, 0xf0, 0x60, 0xd3, 0x90, 0x31, 0xaa, 0xa6, 0x22, 0xa4, 0x30, 0xc0, 0x94, 0xa1, 0x4b, 0x56,
	0xb5, 0x2e, 0xcc, 0xb0, 0x2e, 0x6c, 0x5d, 0xd7, 0x74, 0x53, 0x98, 0x65, 0x88, 0x6c, 0x98, 0x0c,
	0x59, 0x61, 0x08, 0x5b, 0x73, 0x64, 0x95, 0xed, 0xea, 0xba, 0x66, 0x6a, 0x92, 0x56, 0x13, 0xee,
	0xb0, 0x5d, 0xa5, 0x5e, 0xb7, 0xd4, 0xca, 0xb6, 0x22, 0xdc, 0xc3, 0x73, 0x90, 0x53, 0x37, 0x77,
	0x2d, 0x43, 0xd1, 0x77, 0xab, 0x92, 0x22, 0x7c, 0x89, 0xf3, 0xb0, 0x90, 0x08, 0x58, 0x55, 0xd5,
	0x30, 0x2b, 0xaa, 0xa4, 0x08, 0x5f, 0xe1, 0x55, 0x58, 0x1a, 0x87, 0x58, 0x5b, 0x9a, 0x61, 0xf2,
	0x6a, 0x5f, 0xc7, 0x8a, 0xb8, 0xd6, 0xfb, 0xb1, 0x0a, 0xbe, 0xab, 0xe0, 0xcb, 0x30, 0xcf, 0xd5,
	0xea, 0xda, 0x6e, 0x55, 0x56, 0x74, 0xcb, 0x7c, 0x5c, 0x57, 0x84, 0x0d, 0x16, 0xe6, 0x52, 0x87,
	0xc2, 0x12, 0xf3, 0x82, 0x57, 0xda, 0xd9, 0x50, 0x15, 0x53, 0x90, 0xd9, 0x9e, 0xd7, 0x0a, 0xf7,
	0x0a, 0xd3, 0xcd, 0x70, 0x55, 0x31, 0x1f, 0x69, 0xfa, 0x43, 0x61, 0x93, 0x05, 0x18, 0x21, 0x0e,
	0x3c, 0xc0, 0xf3, 0x30, 0x2b, 0xd5, 0xb4, 0x1d, 0xd9, 0x92, 0x34, 0x55, 0x55, 0x24, 0x53, 0xd8,
	0x62, 0xa1, 0x8a, 0xaa, 0x6d, 0x57, 0x6a, 0x8f, 0xad, 0x9a, 0xb2, 0xab, 0xd4, 0x84, 0xea, 0xfa,
	0x23, 0x98, 0x49, 0x7e, 0xb7, 0x98, 0x1c, 0x76, 0x05, 0xc3, 0xb4, 0x14, 0x73, 0x65, 0x5b, 0x91,
	0xab, 0x3b, 0xdb, 0x23, 0x08, 0x62, 0x97, 0xb9, 0x55, 0x7d, 0xb0, 0x35, 0x12, 0x4f, 0xaf, 0x3b,
	0x90, 0x4b, 0xfc, 0x3a, 0xb1, 0x31, 0x89, 0xee, 0xb6, 0x56, 0x53, 0x24, 0xb3, 0xaa, 0xa9, 0x42,
	0x0a, 0x17, 0x60, 0x71, 0x33, 0xd9, 0x4d, 0x56, 0xcc, 0x08, 0x43, 0xf8, 0x26, 0x7c, 0x30, 0x92,
	0x60, 0x55, 0x54, 0x79, 0x0c, 0x35, 0xbd, 0x7e, 0x1f, 0x66, 0x87, 0x86, 0x19, 0x5f, 0x81, 0x4b,
	0x86, 0xa6, 0x9b, 0x96, 0x5c, 0xd5, 0xa3, 0x54, 0x59, 0x31, 0x24, 0x21, 0xc5, 0xc4, 0x8e, 0x00,
	0x15, 0x43, 0x12, 0xd0, 0xfa, 0x0b, 0x04, 0xd9, 0xc1, 0x8b, 0x62, 0x5a, 0x39, 0xab, 0x56, 0xd9,
	0x50, 0x6a, 0x96, 0xaa, 0xa9, 0x6c, 0xf0, 0x16, 0x40, 0x48, 0x04, 0xc3, 0xd1, 0x46, 0xf8, 0x2a,
	0x5c, 0x4e, 0x44, 0x13, 0xd3, 0x9b, 0xc6, 0xd7, 0x21, 0x9f, 0x80, 0x86, 0xed, 0x99, 0xc0, 0xcb,
	0x70, 0x6d, 0x0c, 0x2a, 0xef, 0xe8, 0x15, 0x7e, 0xa8, 0xcc, 0xc6, 0x0f, 0xe8, 0xe5, 0xb1, 0x98,
	0x7a, 0x75, 0x2c, 0xa6, 0x5e, 0x1f, 0x8b, 0xe8, 0xbb, 0xbe, 0x88, 0x7e, 0xee, 0x8b, 0xe8, 0xb7,
	0xbe, 0x88, 0x5e, 0xf6, 0x45, 0xf4, 0xaa, 0x2f, 0xa2, 0x3f, 0xfb, 0x22, 0xfa, 0xab, 0x2f, 0xa6,
	0x5e, 0xf7, 0x45, 0xf4, 0xe2, 0x44, 0x4c, 0xfd, 0x7a, 0x22, 0xa2, 0x97, 0x27, 0x62, 0xea, 0xd5,
	0x89, 0x98, 0xfa, 0x66, 0xab, 0xed, 0x75, 0x9f, 0xb6, 0x4b, 0x87, 0x9e, 0x4b, 0x89, 0xef, 0xdb,
	0xa5, 0x5e, 0x50, 0xe6, 0x8b, 0x7d, 0xcf, 0x3f, 0xb8, 0xdd, 0xf5, 0xbd, 0x43, 0xa7, 0x45, 0xfc,
	0xdb, 0x31, 0x5c, 0xee, 0x36, 0xda, 0x5e, 0x99, 0x7c, 0x4b, 0xa3, 0x3f, 0x04, 0x89, 0x3f, 0x4b,
	0x8d, 0x29, 0xfe, 0xdb, 0xf9, 0xf1, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x26, 0xb5, 0xee, 0xb4,
	0x49, 0x0d, 0x00, 0x00,
}

func (x FieldSelector) String() string {
	s, ok := FieldSelector_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Label) String() string {
	s, ok := Label_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x AnomalyLevel) String() string {
	s, ok := AnomalyLevel_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ServiceType) String() string {
	s, ok := ServiceType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SortDirection) String() string {
	s, ok := SortDirection_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SortLabel) String() string {
	s, ok := SortLabel_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *FlowData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlowData)
	if !ok {
		that2, ok := that.(FlowData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.Data) != len(that1.Data) {
		return false
	}
	for i := range this.Data {
		if !this.Data[i].Equal(that1.Data[i]) {
			return false
		}
	}
	if this.Unit != that1.Unit {
		return false
	}
	return true
}
func (this *FieldData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FieldData)
	if !ok {
		that2, ok := that.(FieldData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Value) != len(that1.Value) {
		return false
	}
	for i := range this.Value {
		if !this.Value[i].Equal(that1.Value[i]) {
			return false
		}
	}
	return true
}
func (this *FlowAnomalyData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlowAnomalyData)
	if !ok {
		that2, ok := that.(FlowAnomalyData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.AnomalyData) != len(that1.AnomalyData) {
		return false
	}
	for i := range this.AnomalyData {
		if !this.AnomalyData[i].Equal(that1.AnomalyData[i]) {
			return false
		}
	}
	return true
}
func (this *AnomalyData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AnomalyData)
	if !ok {
		that2, ok := that.(AnomalyData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if !this.AnomalyStartTime.Equal(that1.AnomalyStartTime) {
		return false
	}
	if this.AnomalyDurationSeconds != that1.AnomalyDurationSeconds {
		return false
	}
	if this.AnomalousDataTransferred != that1.AnomalousDataTransferred {
		return false
	}
	if this.AnomalyLevel != that1.AnomalyLevel {
		return false
	}
	if this.TotalDataTransferred != that1.TotalDataTransferred {
		return false
	}
	if !this.ScanTime.Equal(that1.ScanTime) {
		return false
	}
	if this.AnomalyScore != that1.AnomalyScore {
		return false
	}
	if this.FlowCount != that1.FlowCount {
		return false
	}
	return true
}
func (this *SubscribeRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubscribeRequest)
	if !ok {
		that2, ok := that.(SubscribeRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServiceType != that1.ServiceType {
		return false
	}
	return true
}
func (this *SubscribeResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubscribeResponse)
	if !ok {
		that2, ok := that.(SubscribeResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LastEnabledTime.Equal(that1.LastEnabledTime) {
		return false
	}
	if !this.FlowAnomalyDetectionLastEnabledTime.Equal(that1.FlowAnomalyDetectionLastEnabledTime) {
		return false
	}
	return true
}
func (this *UnsubscribeRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UnsubscribeRequest)
	if !ok {
		that2, ok := that.(UnsubscribeRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServiceType != that1.ServiceType {
		return false
	}
	return true
}
func (this *UnsubscribeResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UnsubscribeResponse)
	if !ok {
		that2, ok := that.(UnsubscribeResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *SubscriptionStatusRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubscriptionStatusRequest)
	if !ok {
		that2, ok := that.(SubscriptionStatusRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *SubscriptionStatusResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubscriptionStatusResponse)
	if !ok {
		that2, ok := that.(SubscriptionStatusResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LastEnabledTime.Equal(that1.LastEnabledTime) {
		return false
	}
	if this.Result != that1.Result {
		return false
	}
	if !this.FlowAnomalyDetectionLastEnabledTime.Equal(that1.FlowAnomalyDetectionLastEnabledTime) {
		return false
	}
	if this.FlowAnomalyDetectionResult != that1.FlowAnomalyDetectionResult {
		return false
	}
	return true
}
func (this *SortBy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SortBy)
	if !ok {
		that2, ok := that.(SortBy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SortLabel != that1.SortLabel {
		return false
	}
	if this.SortDirection != that1.SortDirection {
		return false
	}
	return true
}
func (this *FlowData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&flow.FlowData{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.Data != nil {
		s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	}
	s = append(s, "Unit: "+fmt.Sprintf("%#v", this.Unit)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FieldData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&flow.FieldData{")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FlowAnomalyData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&flow.FlowAnomalyData{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.AnomalyData != nil {
		s = append(s, "AnomalyData: "+fmt.Sprintf("%#v", this.AnomalyData)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AnomalyData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&flow.AnomalyData{")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	if this.AnomalyStartTime != nil {
		s = append(s, "AnomalyStartTime: "+fmt.Sprintf("%#v", this.AnomalyStartTime)+",\n")
	}
	s = append(s, "AnomalyDurationSeconds: "+fmt.Sprintf("%#v", this.AnomalyDurationSeconds)+",\n")
	s = append(s, "AnomalousDataTransferred: "+fmt.Sprintf("%#v", this.AnomalousDataTransferred)+",\n")
	s = append(s, "AnomalyLevel: "+fmt.Sprintf("%#v", this.AnomalyLevel)+",\n")
	s = append(s, "TotalDataTransferred: "+fmt.Sprintf("%#v", this.TotalDataTransferred)+",\n")
	if this.ScanTime != nil {
		s = append(s, "ScanTime: "+fmt.Sprintf("%#v", this.ScanTime)+",\n")
	}
	s = append(s, "AnomalyScore: "+fmt.Sprintf("%#v", this.AnomalyScore)+",\n")
	s = append(s, "FlowCount: "+fmt.Sprintf("%#v", this.FlowCount)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SubscribeRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&flow.SubscribeRequest{")
	s = append(s, "ServiceType: "+fmt.Sprintf("%#v", this.ServiceType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SubscribeResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&flow.SubscribeResponse{")
	if this.LastEnabledTime != nil {
		s = append(s, "LastEnabledTime: "+fmt.Sprintf("%#v", this.LastEnabledTime)+",\n")
	}
	if this.FlowAnomalyDetectionLastEnabledTime != nil {
		s = append(s, "FlowAnomalyDetectionLastEnabledTime: "+fmt.Sprintf("%#v", this.FlowAnomalyDetectionLastEnabledTime)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UnsubscribeRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&flow.UnsubscribeRequest{")
	s = append(s, "ServiceType: "+fmt.Sprintf("%#v", this.ServiceType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UnsubscribeResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&flow.UnsubscribeResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SubscriptionStatusRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&flow.SubscriptionStatusRequest{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SubscriptionStatusResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&flow.SubscriptionStatusResponse{")
	if this.LastEnabledTime != nil {
		s = append(s, "LastEnabledTime: "+fmt.Sprintf("%#v", this.LastEnabledTime)+",\n")
	}
	s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	if this.FlowAnomalyDetectionLastEnabledTime != nil {
		s = append(s, "FlowAnomalyDetectionLastEnabledTime: "+fmt.Sprintf("%#v", this.FlowAnomalyDetectionLastEnabledTime)+",\n")
	}
	s = append(s, "FlowAnomalyDetectionResult: "+fmt.Sprintf("%#v", this.FlowAnomalyDetectionResult)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SortBy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&flow.SortBy{")
	s = append(s, "SortLabel: "+fmt.Sprintf("%#v", this.SortLabel)+",\n")
	s = append(s, "SortDirection: "+fmt.Sprintf("%#v", this.SortDirection)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *FlowData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Unit != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Unit))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FieldData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FieldData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for iNdEx := len(m.Value) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Value[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FlowAnomalyData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowAnomalyData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowAnomalyData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AnomalyData) > 0 {
		for iNdEx := len(m.AnomalyData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AnomalyData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AnomalyData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnomalyData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnomalyData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FlowCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.FlowCount))
		i--
		dAtA[i] = 0x48
	}
	if m.AnomalyScore != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AnomalyScore))))
		i--
		dAtA[i] = 0x45
	}
	if m.ScanTime != nil {
		{
			size, err := m.ScanTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.TotalDataTransferred != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TotalDataTransferred))
		i--
		dAtA[i] = 0x30
	}
	if m.AnomalyLevel != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AnomalyLevel))
		i--
		dAtA[i] = 0x28
	}
	if m.AnomalousDataTransferred != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AnomalousDataTransferred))
		i--
		dAtA[i] = 0x20
	}
	if m.AnomalyDurationSeconds != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AnomalyDurationSeconds))
		i--
		dAtA[i] = 0x18
	}
	if m.AnomalyStartTime != nil {
		{
			size, err := m.AnomalyStartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SubscribeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ServiceType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ServiceType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubscribeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FlowAnomalyDetectionLastEnabledTime != nil {
		{
			size, err := m.FlowAnomalyDetectionLastEnabledTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LastEnabledTime != nil {
		{
			size, err := m.LastEnabledTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnsubscribeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnsubscribeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnsubscribeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ServiceType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ServiceType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnsubscribeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnsubscribeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnsubscribeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SubscriptionStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscriptionStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscriptionStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SubscriptionStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscriptionStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscriptionStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FlowAnomalyDetectionResult != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.FlowAnomalyDetectionResult))
		i--
		dAtA[i] = 0x20
	}
	if m.FlowAnomalyDetectionLastEnabledTime != nil {
		{
			size, err := m.FlowAnomalyDetectionLastEnabledTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Result != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x10
	}
	if m.LastEnabledTime != nil {
		{
			size, err := m.LastEnabledTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SortBy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SortBy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SortBy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SortDirection != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SortDirection))
		i--
		dAtA[i] = 0x10
	}
	if m.SortLabel != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SortLabel))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FlowData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Unit != 0 {
		n += 1 + sovTypes(uint64(m.Unit))
	}
	return n
}

func (m *FieldData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Value) > 0 {
		for _, e := range m.Value {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *FlowAnomalyData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if len(m.AnomalyData) > 0 {
		for _, e := range m.AnomalyData {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AnomalyData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.AnomalyStartTime != nil {
		l = m.AnomalyStartTime.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AnomalyDurationSeconds != 0 {
		n += 1 + sovTypes(uint64(m.AnomalyDurationSeconds))
	}
	if m.AnomalousDataTransferred != 0 {
		n += 1 + sovTypes(uint64(m.AnomalousDataTransferred))
	}
	if m.AnomalyLevel != 0 {
		n += 1 + sovTypes(uint64(m.AnomalyLevel))
	}
	if m.TotalDataTransferred != 0 {
		n += 1 + sovTypes(uint64(m.TotalDataTransferred))
	}
	if m.ScanTime != nil {
		l = m.ScanTime.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AnomalyScore != 0 {
		n += 5
	}
	if m.FlowCount != 0 {
		n += 1 + sovTypes(uint64(m.FlowCount))
	}
	return n
}

func (m *SubscribeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServiceType != 0 {
		n += 1 + sovTypes(uint64(m.ServiceType))
	}
	return n
}

func (m *SubscribeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LastEnabledTime != nil {
		l = m.LastEnabledTime.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.FlowAnomalyDetectionLastEnabledTime != nil {
		l = m.FlowAnomalyDetectionLastEnabledTime.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *UnsubscribeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServiceType != 0 {
		n += 1 + sovTypes(uint64(m.ServiceType))
	}
	return n
}

func (m *UnsubscribeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SubscriptionStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SubscriptionStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LastEnabledTime != nil {
		l = m.LastEnabledTime.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Result != 0 {
		n += 1 + sovTypes(uint64(m.Result))
	}
	if m.FlowAnomalyDetectionLastEnabledTime != nil {
		l = m.FlowAnomalyDetectionLastEnabledTime.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.FlowAnomalyDetectionResult != 0 {
		n += 1 + sovTypes(uint64(m.FlowAnomalyDetectionResult))
	}
	return n
}

func (m *SortBy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SortLabel != 0 {
		n += 1 + sovTypes(uint64(m.SortLabel))
	}
	if m.SortDirection != 0 {
		n += 1 + sovTypes(uint64(m.SortDirection))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *FlowData) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForData := "[]*FieldData{"
	for _, f := range this.Data {
		repeatedStringForData += strings.Replace(f.String(), "FieldData", "FieldData", 1) + ","
	}
	repeatedStringForData += "}"
	s := strings.Join([]string{`&FlowData{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Data:` + repeatedStringForData + `,`,
		`Unit:` + fmt.Sprintf("%v", this.Unit) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FieldData) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForValue := "[]*MetricValue{"
	for _, f := range this.Value {
		repeatedStringForValue += strings.Replace(fmt.Sprintf("%v", f), "MetricValue", "schema.MetricValue", 1) + ","
	}
	repeatedStringForValue += "}"
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&FieldData{`,
		`Labels:` + mapStringForLabels + `,`,
		`Value:` + repeatedStringForValue + `,`,
		`}`,
	}, "")
	return s
}
func (this *FlowAnomalyData) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAnomalyData := "[]*AnomalyData{"
	for _, f := range this.AnomalyData {
		repeatedStringForAnomalyData += strings.Replace(f.String(), "AnomalyData", "AnomalyData", 1) + ","
	}
	repeatedStringForAnomalyData += "}"
	s := strings.Join([]string{`&FlowAnomalyData{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`AnomalyData:` + repeatedStringForAnomalyData + `,`,
		`}`,
	}, "")
	return s
}
func (this *AnomalyData) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&AnomalyData{`,
		`Labels:` + mapStringForLabels + `,`,
		`AnomalyStartTime:` + strings.Replace(fmt.Sprintf("%v", this.AnomalyStartTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`AnomalyDurationSeconds:` + fmt.Sprintf("%v", this.AnomalyDurationSeconds) + `,`,
		`AnomalousDataTransferred:` + fmt.Sprintf("%v", this.AnomalousDataTransferred) + `,`,
		`AnomalyLevel:` + fmt.Sprintf("%v", this.AnomalyLevel) + `,`,
		`TotalDataTransferred:` + fmt.Sprintf("%v", this.TotalDataTransferred) + `,`,
		`ScanTime:` + strings.Replace(fmt.Sprintf("%v", this.ScanTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`AnomalyScore:` + fmt.Sprintf("%v", this.AnomalyScore) + `,`,
		`FlowCount:` + fmt.Sprintf("%v", this.FlowCount) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SubscribeRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SubscribeRequest{`,
		`ServiceType:` + fmt.Sprintf("%v", this.ServiceType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SubscribeResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SubscribeResponse{`,
		`LastEnabledTime:` + strings.Replace(fmt.Sprintf("%v", this.LastEnabledTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`FlowAnomalyDetectionLastEnabledTime:` + strings.Replace(fmt.Sprintf("%v", this.FlowAnomalyDetectionLastEnabledTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UnsubscribeRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UnsubscribeRequest{`,
		`ServiceType:` + fmt.Sprintf("%v", this.ServiceType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UnsubscribeResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UnsubscribeResponse{`,
		`}`,
	}, "")
	return s
}
func (this *SubscriptionStatusRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SubscriptionStatusRequest{`,
		`}`,
	}, "")
	return s
}
func (this *SubscriptionStatusResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SubscriptionStatusResponse{`,
		`LastEnabledTime:` + strings.Replace(fmt.Sprintf("%v", this.LastEnabledTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`Result:` + fmt.Sprintf("%v", this.Result) + `,`,
		`FlowAnomalyDetectionLastEnabledTime:` + strings.Replace(fmt.Sprintf("%v", this.FlowAnomalyDetectionLastEnabledTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`FlowAnomalyDetectionResult:` + fmt.Sprintf("%v", this.FlowAnomalyDetectionResult) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SortBy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SortBy{`,
		`SortLabel:` + fmt.Sprintf("%v", this.SortLabel) + `,`,
		`SortDirection:` + fmt.Sprintf("%v", this.SortDirection) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *FlowData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= FieldSelector(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &FieldData{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			m.Unit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unit |= schema.UnitType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, &schema.MetricValue{})
			if err := m.Value[len(m.Value)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowAnomalyData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowAnomalyData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowAnomalyData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= FieldSelector(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnomalyData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnomalyData = append(m.AnomalyData, &AnomalyData{})
			if err := m.AnomalyData[len(m.AnomalyData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnomalyData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnomalyData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnomalyData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnomalyStartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnomalyStartTime == nil {
				m.AnomalyStartTime = &types.Timestamp{}
			}
			if err := m.AnomalyStartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnomalyDurationSeconds", wireType)
			}
			m.AnomalyDurationSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnomalyDurationSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnomalousDataTransferred", wireType)
			}
			m.AnomalousDataTransferred = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnomalousDataTransferred |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnomalyLevel", wireType)
			}
			m.AnomalyLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnomalyLevel |= AnomalyLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDataTransferred", wireType)
			}
			m.TotalDataTransferred = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalDataTransferred |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScanTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScanTime == nil {
				m.ScanTime = &types.Timestamp{}
			}
			if err := m.ScanTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnomalyScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AnomalyScore = float32(math.Float32frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowCount", wireType)
			}
			m.FlowCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlowCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceType", wireType)
			}
			m.ServiceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServiceType |= ServiceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastEnabledTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastEnabledTime == nil {
				m.LastEnabledTime = &types.Timestamp{}
			}
			if err := m.LastEnabledTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowAnomalyDetectionLastEnabledTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlowAnomalyDetectionLastEnabledTime == nil {
				m.FlowAnomalyDetectionLastEnabledTime = &types.Timestamp{}
			}
			if err := m.FlowAnomalyDetectionLastEnabledTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnsubscribeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnsubscribeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnsubscribeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceType", wireType)
			}
			m.ServiceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServiceType |= ServiceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnsubscribeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnsubscribeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnsubscribeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscriptionStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscriptionStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscriptionStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscriptionStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscriptionStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscriptionStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastEnabledTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastEnabledTime == nil {
				m.LastEnabledTime = &types.Timestamp{}
			}
			if err := m.LastEnabledTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= schema.AddonServiceState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowAnomalyDetectionLastEnabledTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlowAnomalyDetectionLastEnabledTime == nil {
				m.FlowAnomalyDetectionLastEnabledTime = &types.Timestamp{}
			}
			if err := m.FlowAnomalyDetectionLastEnabledTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowAnomalyDetectionResult", wireType)
			}
			m.FlowAnomalyDetectionResult = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlowAnomalyDetectionResult |= schema.AddonServiceState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SortBy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SortBy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SortBy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortLabel", wireType)
			}
			m.SortLabel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SortLabel |= SortLabel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortDirection", wireType)
			}
			m.SortDirection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SortDirection |= SortDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
