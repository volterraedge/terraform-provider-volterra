// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package flow

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AnomalyData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AnomalyData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AnomalyData) DeepCopy() *AnomalyData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AnomalyData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AnomalyData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AnomalyData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AnomalyDataValidator().Validate(ctx, m, opts...)
}

type ValidateAnomalyData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAnomalyData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AnomalyData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AnomalyData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["anomalous_data_transferred"]; exists {

		vOpts := append(opts, db.WithValidateField("anomalous_data_transferred"))
		if err := fv(ctx, m.GetAnomalousDataTransferred(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["anomaly_duration_seconds"]; exists {

		vOpts := append(opts, db.WithValidateField("anomaly_duration_seconds"))
		if err := fv(ctx, m.GetAnomalyDurationSeconds(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["anomaly_level"]; exists {

		vOpts := append(opts, db.WithValidateField("anomaly_level"))
		if err := fv(ctx, m.GetAnomalyLevel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["anomaly_score"]; exists {

		vOpts := append(opts, db.WithValidateField("anomaly_score"))
		if err := fv(ctx, m.GetAnomalyScore(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["anomaly_start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("anomaly_start_time"))
		if err := fv(ctx, m.GetAnomalyStartTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["flow_count"]; exists {

		vOpts := append(opts, db.WithValidateField("flow_count"))
		if err := fv(ctx, m.GetFlowCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["labels"]; exists {

		vOpts := append(opts, db.WithValidateField("labels"))
		for key, value := range m.GetLabels() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["scan_time"]; exists {

		vOpts := append(opts, db.WithValidateField("scan_time"))
		if err := fv(ctx, m.GetScanTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["total_data_transferred"]; exists {

		vOpts := append(opts, db.WithValidateField("total_data_transferred"))
		if err := fv(ctx, m.GetTotalDataTransferred(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAnomalyDataValidator = func() *ValidateAnomalyData {
	v := &ValidateAnomalyData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func AnomalyDataValidator() db.Validator {
	return DefaultAnomalyDataValidator
}

// augmented methods on protoc/std generated struct

func (m *FieldData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FieldData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FieldData) DeepCopy() *FieldData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FieldData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FieldData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FieldData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FieldDataValidator().Validate(ctx, m, opts...)
}

type ValidateFieldData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFieldData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FieldData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FieldData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["labels"]; exists {

		vOpts := append(opts, db.WithValidateField("labels"))
		for key, value := range m.GetLabels() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		for idx, item := range m.GetValue() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFieldDataValidator = func() *ValidateFieldData {
	v := &ValidateFieldData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FieldDataValidator() db.Validator {
	return DefaultFieldDataValidator
}

// augmented methods on protoc/std generated struct

func (m *FlowAnomalyData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FlowAnomalyData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FlowAnomalyData) DeepCopy() *FlowAnomalyData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FlowAnomalyData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FlowAnomalyData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FlowAnomalyData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FlowAnomalyDataValidator().Validate(ctx, m, opts...)
}

type ValidateFlowAnomalyData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFlowAnomalyData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FlowAnomalyData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FlowAnomalyData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["anomaly_data"]; exists {

		vOpts := append(opts, db.WithValidateField("anomaly_data"))
		for idx, item := range m.GetAnomalyData() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFlowAnomalyDataValidator = func() *ValidateFlowAnomalyData {
	v := &ValidateFlowAnomalyData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FlowAnomalyDataValidator() db.Validator {
	return DefaultFlowAnomalyDataValidator
}

// augmented methods on protoc/std generated struct

func (m *FlowData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FlowData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FlowData) DeepCopy() *FlowData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FlowData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FlowData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FlowData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FlowDataValidator().Validate(ctx, m, opts...)
}

type ValidateFlowData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFlowData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FlowData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FlowData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["data"]; exists {

		vOpts := append(opts, db.WithValidateField("data"))
		for idx, item := range m.GetData() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["unit"]; exists {

		vOpts := append(opts, db.WithValidateField("unit"))
		if err := fv(ctx, m.GetUnit(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFlowDataValidator = func() *ValidateFlowData {
	v := &ValidateFlowData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FlowDataValidator() db.Validator {
	return DefaultFlowDataValidator
}

// augmented methods on protoc/std generated struct

func (m *SortBy) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SortBy) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SortBy) DeepCopy() *SortBy {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SortBy{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SortBy) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SortBy) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SortByValidator().Validate(ctx, m, opts...)
}

type ValidateSortBy struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSortBy) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SortBy)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SortBy got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["sort_direction"]; exists {

		vOpts := append(opts, db.WithValidateField("sort_direction"))
		if err := fv(ctx, m.GetSortDirection(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sort_label"]; exists {

		vOpts := append(opts, db.WithValidateField("sort_label"))
		if err := fv(ctx, m.GetSortLabel(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSortByValidator = func() *ValidateSortBy {
	v := &ValidateSortBy{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SortByValidator() db.Validator {
	return DefaultSortByValidator
}

// augmented methods on protoc/std generated struct

func (m *SubscribeRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SubscribeRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SubscribeRequest) DeepCopy() *SubscribeRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SubscribeRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SubscribeRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SubscribeRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SubscribeRequestValidator().Validate(ctx, m, opts...)
}

type ValidateSubscribeRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSubscribeRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SubscribeRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SubscribeRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["service_type"]; exists {

		vOpts := append(opts, db.WithValidateField("service_type"))
		if err := fv(ctx, m.GetServiceType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSubscribeRequestValidator = func() *ValidateSubscribeRequest {
	v := &ValidateSubscribeRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SubscribeRequestValidator() db.Validator {
	return DefaultSubscribeRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *SubscribeResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SubscribeResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SubscribeResponse) DeepCopy() *SubscribeResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SubscribeResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SubscribeResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SubscribeResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SubscribeResponseValidator().Validate(ctx, m, opts...)
}

type ValidateSubscribeResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSubscribeResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SubscribeResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SubscribeResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["flow_anomaly_detection_last_enabled_time"]; exists {

		vOpts := append(opts, db.WithValidateField("flow_anomaly_detection_last_enabled_time"))
		if err := fv(ctx, m.GetFlowAnomalyDetectionLastEnabledTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["last_enabled_time"]; exists {

		vOpts := append(opts, db.WithValidateField("last_enabled_time"))
		if err := fv(ctx, m.GetLastEnabledTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSubscribeResponseValidator = func() *ValidateSubscribeResponse {
	v := &ValidateSubscribeResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SubscribeResponseValidator() db.Validator {
	return DefaultSubscribeResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *SubscriptionStatusRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SubscriptionStatusRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SubscriptionStatusRequest) DeepCopy() *SubscriptionStatusRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SubscriptionStatusRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SubscriptionStatusRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SubscriptionStatusRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SubscriptionStatusRequestValidator().Validate(ctx, m, opts...)
}

type ValidateSubscriptionStatusRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSubscriptionStatusRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SubscriptionStatusRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SubscriptionStatusRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSubscriptionStatusRequestValidator = func() *ValidateSubscriptionStatusRequest {
	v := &ValidateSubscriptionStatusRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SubscriptionStatusRequestValidator() db.Validator {
	return DefaultSubscriptionStatusRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *SubscriptionStatusResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SubscriptionStatusResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SubscriptionStatusResponse) DeepCopy() *SubscriptionStatusResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SubscriptionStatusResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SubscriptionStatusResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SubscriptionStatusResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SubscriptionStatusResponseValidator().Validate(ctx, m, opts...)
}

type ValidateSubscriptionStatusResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSubscriptionStatusResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SubscriptionStatusResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SubscriptionStatusResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["flow_anomaly_detection_last_enabled_time"]; exists {

		vOpts := append(opts, db.WithValidateField("flow_anomaly_detection_last_enabled_time"))
		if err := fv(ctx, m.GetFlowAnomalyDetectionLastEnabledTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["flow_anomaly_detection_result"]; exists {

		vOpts := append(opts, db.WithValidateField("flow_anomaly_detection_result"))
		if err := fv(ctx, m.GetFlowAnomalyDetectionResult(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["last_enabled_time"]; exists {

		vOpts := append(opts, db.WithValidateField("last_enabled_time"))
		if err := fv(ctx, m.GetLastEnabledTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["result"]; exists {

		vOpts := append(opts, db.WithValidateField("result"))
		if err := fv(ctx, m.GetResult(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSubscriptionStatusResponseValidator = func() *ValidateSubscriptionStatusResponse {
	v := &ValidateSubscriptionStatusResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SubscriptionStatusResponseValidator() db.Validator {
	return DefaultSubscriptionStatusResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *UnsubscribeRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UnsubscribeRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UnsubscribeRequest) DeepCopy() *UnsubscribeRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UnsubscribeRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UnsubscribeRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UnsubscribeRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UnsubscribeRequestValidator().Validate(ctx, m, opts...)
}

type ValidateUnsubscribeRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUnsubscribeRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UnsubscribeRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UnsubscribeRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["service_type"]; exists {

		vOpts := append(opts, db.WithValidateField("service_type"))
		if err := fv(ctx, m.GetServiceType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUnsubscribeRequestValidator = func() *ValidateUnsubscribeRequest {
	v := &ValidateUnsubscribeRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UnsubscribeRequestValidator() db.Validator {
	return DefaultUnsubscribeRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *UnsubscribeResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UnsubscribeResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UnsubscribeResponse) DeepCopy() *UnsubscribeResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UnsubscribeResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UnsubscribeResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UnsubscribeResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UnsubscribeResponseValidator().Validate(ctx, m, opts...)
}

type ValidateUnsubscribeResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUnsubscribeResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UnsubscribeResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UnsubscribeResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUnsubscribeResponseValidator = func() *ValidateUnsubscribeResponse {
	v := &ValidateUnsubscribeResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UnsubscribeResponseValidator() db.Validator {
	return DefaultUnsubscribeResponseValidator
}
