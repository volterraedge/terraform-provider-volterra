// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package schema

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"
	google_protobuf "github.com/gogo/protobuf/types"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *Action) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Action) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Action) DeepCopy() *Action {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Action{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Action) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Action) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ActionValidator().Validate(ctx, m, opts...)
}

type ValidateAction struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAction) ActionChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for action_choice")
	}
	return validatorFn, nil
}

func (v *ValidateAction) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Action)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Action got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["action_choice"]; exists {
		val := m.GetActionChoice()
		vOpts := append(opts,
			db.WithValidateField("action_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetActionChoice().(type) {
	case *Action_Block:
		if fv, exists := v.FldValidators["action_choice.block"]; exists {
			val := m.GetActionChoice().(*Action_Block).Block
			vOpts := append(opts,
				db.WithValidateField("action_choice"),
				db.WithValidateField("block"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Action_Report:
		if fv, exists := v.FldValidators["action_choice.report"]; exists {
			val := m.GetActionChoice().(*Action_Report).Report
			vOpts := append(opts,
				db.WithValidateField("action_choice"),
				db.WithValidateField("report"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultActionValidator = func() *ValidateAction {
	v := &ValidateAction{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhActionChoice := v.ActionChoiceValidationRuleHandler
	rulesActionChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhActionChoice(rulesActionChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Action.action_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["action_choice"] = vFn

	return v
}()

func ActionValidator() db.Validator {
	return DefaultActionValidator
}

// augmented methods on protoc/std generated struct

func (m *AppFirewallRefType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AppFirewallRefType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AppFirewallRefType) DeepCopy() *AppFirewallRefType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AppFirewallRefType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AppFirewallRefType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AppFirewallRefType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AppFirewallRefTypeValidator().Validate(ctx, m, opts...)
}

func (m *AppFirewallRefType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetAppFirewallDRefInfo()

}

func (m *AppFirewallRefType) GetAppFirewallDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetAppFirewall()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("AppFirewallRefType.app_firewall[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "app_firewall.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "app_firewall",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetAppFirewallDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *AppFirewallRefType) GetAppFirewallDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "app_firewall.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: app_firewall")
	}
	for _, ref := range m.GetAppFirewall() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateAppFirewallRefType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAppFirewallRefType) AppFirewallValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for app_firewall")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for app_firewall")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated app_firewall")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items app_firewall")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAppFirewallRefType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AppFirewallRefType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AppFirewallRefType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["app_firewall"]; exists {
		vOpts := append(opts, db.WithValidateField("app_firewall"))
		if err := fv(ctx, m.GetAppFirewall(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAppFirewallRefTypeValidator = func() *ValidateAppFirewallRefType {
	v := &ValidateAppFirewallRefType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAppFirewall := v.AppFirewallValidationRuleHandler
	rulesAppFirewall := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.num_items": "1",
	}
	vFn, err = vrhAppFirewall(rulesAppFirewall)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppFirewallRefType.app_firewall: %s", err)
		panic(errMsg)
	}
	v.FldValidators["app_firewall"] = vFn

	return v
}()

func AppFirewallRefTypeValidator() db.Validator {
	return DefaultAppFirewallRefTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AppRoleAuthInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AppRoleAuthInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *AppRoleAuthInfoType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetSecretId().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting AppRoleAuthInfoType.secret_id")
	}

	return nil
}

func (m *AppRoleAuthInfoType) DeepCopy() *AppRoleAuthInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AppRoleAuthInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AppRoleAuthInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AppRoleAuthInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AppRoleAuthInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAppRoleAuthInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAppRoleAuthInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AppRoleAuthInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AppRoleAuthInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["role_id"]; exists {

		vOpts := append(opts, db.WithValidateField("role_id"))
		if err := fv(ctx, m.GetRoleId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["secret_id"]; exists {

		vOpts := append(opts, db.WithValidateField("secret_id"))
		if err := fv(ctx, m.GetSecretId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAppRoleAuthInfoTypeValidator = func() *ValidateAppRoleAuthInfoType {
	v := &ValidateAppRoleAuthInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["secret_id"] = SecretTypeValidator().Validate

	return v
}()

func AppRoleAuthInfoTypeValidator() db.Validator {
	return DefaultAppRoleAuthInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AuthnTypeBasicAuth) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AuthnTypeBasicAuth) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *AuthnTypeBasicAuth) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetPassword().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting AuthnTypeBasicAuth.password")
	}

	return nil
}

func (m *AuthnTypeBasicAuth) DeepCopy() *AuthnTypeBasicAuth {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AuthnTypeBasicAuth{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AuthnTypeBasicAuth) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AuthnTypeBasicAuth) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AuthnTypeBasicAuthValidator().Validate(ctx, m, opts...)
}

type ValidateAuthnTypeBasicAuth struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAuthnTypeBasicAuth) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AuthnTypeBasicAuth)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AuthnTypeBasicAuth got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["password"]; exists {

		vOpts := append(opts, db.WithValidateField("password"))
		if err := fv(ctx, m.GetPassword(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["username"]; exists {

		vOpts := append(opts, db.WithValidateField("username"))
		if err := fv(ctx, m.GetUsername(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAuthnTypeBasicAuthValidator = func() *ValidateAuthnTypeBasicAuth {
	v := &ValidateAuthnTypeBasicAuth{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["password"] = SecretTypeValidator().Validate

	return v
}()

func AuthnTypeBasicAuthValidator() db.Validator {
	return DefaultAuthnTypeBasicAuthValidator
}

// augmented methods on protoc/std generated struct

func (m *AuthnTypeHeaders) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AuthnTypeHeaders) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *AuthnTypeHeaders) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetHeaders() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting AuthnTypeHeaders.headers idx %v", idx)
		}
	}

	return nil
}

func (m *AuthnTypeHeaders) DeepCopy() *AuthnTypeHeaders {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AuthnTypeHeaders{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AuthnTypeHeaders) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AuthnTypeHeaders) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AuthnTypeHeadersValidator().Validate(ctx, m, opts...)
}

type ValidateAuthnTypeHeaders struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAuthnTypeHeaders) HeadersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for headers")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]*SecretType, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := SecretTypeValidator().Validate(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for headers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]*SecretType)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]*SecretType, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map headers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items headers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAuthnTypeHeaders) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AuthnTypeHeaders)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AuthnTypeHeaders got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["headers"]; exists {
		vOpts := append(opts, db.WithValidateField("headers"))
		if err := fv(ctx, m.GetHeaders(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAuthnTypeHeadersValidator = func() *ValidateAuthnTypeHeaders {
	v := &ValidateAuthnTypeHeaders{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHeaders := v.HeadersValidationRuleHandler
	rulesHeaders := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len": "256",
		"ves.io.schema.rules.map.keys.string.min_len": "1",
		"ves.io.schema.rules.map.max_pairs":           "16",
	}
	vFn, err = vrhHeaders(rulesHeaders)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AuthnTypeHeaders.headers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["headers"] = vFn

	return v
}()

func AuthnTypeHeadersValidator() db.Validator {
	return DefaultAuthnTypeHeadersValidator
}

// augmented methods on protoc/std generated struct

func (m *AuthnTypeQueryParams) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AuthnTypeQueryParams) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *AuthnTypeQueryParams) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetQueryParams() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting AuthnTypeQueryParams.query_params idx %v", idx)
		}
	}

	return nil
}

func (m *AuthnTypeQueryParams) DeepCopy() *AuthnTypeQueryParams {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AuthnTypeQueryParams{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AuthnTypeQueryParams) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AuthnTypeQueryParams) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AuthnTypeQueryParamsValidator().Validate(ctx, m, opts...)
}

type ValidateAuthnTypeQueryParams struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAuthnTypeQueryParams) QueryParamsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for query_params")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]*SecretType, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := SecretTypeValidator().Validate(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for query_params")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]*SecretType)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]*SecretType, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map query_params")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items query_params")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAuthnTypeQueryParams) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AuthnTypeQueryParams)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AuthnTypeQueryParams got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["query_params"]; exists {
		vOpts := append(opts, db.WithValidateField("query_params"))
		if err := fv(ctx, m.GetQueryParams(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAuthnTypeQueryParamsValidator = func() *ValidateAuthnTypeQueryParams {
	v := &ValidateAuthnTypeQueryParams{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhQueryParams := v.QueryParamsValidationRuleHandler
	rulesQueryParams := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len": "256",
		"ves.io.schema.rules.map.keys.string.min_len": "1",
		"ves.io.schema.rules.map.max_pairs":           "16",
	}
	vFn, err = vrhQueryParams(rulesQueryParams)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AuthnTypeQueryParams.query_params: %s", err)
		panic(errMsg)
	}
	v.FldValidators["query_params"] = vFn

	return v
}()

func AuthnTypeQueryParamsValidator() db.Validator {
	return DefaultAuthnTypeQueryParamsValidator
}

// augmented methods on protoc/std generated struct

func (m *BlindfoldSecretInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BlindfoldSecretInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BlindfoldSecretInfoType) DeepCopy() *BlindfoldSecretInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BlindfoldSecretInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BlindfoldSecretInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BlindfoldSecretInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BlindfoldSecretInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateBlindfoldSecretInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBlindfoldSecretInfoType) LocationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for location")
	}

	return validatorFn, nil
}

func (v *ValidateBlindfoldSecretInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BlindfoldSecretInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BlindfoldSecretInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["decryption_provider"]; exists {

		vOpts := append(opts, db.WithValidateField("decryption_provider"))
		if err := fv(ctx, m.GetDecryptionProvider(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["location"]; exists {

		vOpts := append(opts, db.WithValidateField("location"))
		if err := fv(ctx, m.GetLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["store_provider"]; exists {

		vOpts := append(opts, db.WithValidateField("store_provider"))
		if err := fv(ctx, m.GetStoreProvider(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBlindfoldSecretInfoTypeValidator = func() *ValidateBlindfoldSecretInfoType {
	v := &ValidateBlindfoldSecretInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhLocation := v.LocationValidationRuleHandler
	rulesLocation := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.uri_ref":   "true",
	}
	vFn, err = vrhLocation(rulesLocation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BlindfoldSecretInfoType.location: %s", err)
		panic(errMsg)
	}
	v.FldValidators["location"] = vFn

	return v
}()

func BlindfoldSecretInfoTypeValidator() db.Validator {
	return DefaultBlindfoldSecretInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *BotDefenseFlowLabelAccountManagementChoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BotDefenseFlowLabelAccountManagementChoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BotDefenseFlowLabelAccountManagementChoiceType) DeepCopy() *BotDefenseFlowLabelAccountManagementChoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BotDefenseFlowLabelAccountManagementChoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BotDefenseFlowLabelAccountManagementChoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BotDefenseFlowLabelAccountManagementChoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BotDefenseFlowLabelAccountManagementChoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateBotDefenseFlowLabelAccountManagementChoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBotDefenseFlowLabelAccountManagementChoiceType) LabelChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for label_choice")
	}
	return validatorFn, nil
}

func (v *ValidateBotDefenseFlowLabelAccountManagementChoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BotDefenseFlowLabelAccountManagementChoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BotDefenseFlowLabelAccountManagementChoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["label_choice"]; exists {
		val := m.GetLabelChoice()
		vOpts := append(opts,
			db.WithValidateField("label_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLabelChoice().(type) {
	case *BotDefenseFlowLabelAccountManagementChoiceType_Create:
		if fv, exists := v.FldValidators["label_choice.create"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelAccountManagementChoiceType_Create).Create
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("create"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelAccountManagementChoiceType_PasswordReset:
		if fv, exists := v.FldValidators["label_choice.password_reset"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelAccountManagementChoiceType_PasswordReset).PasswordReset
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("password_reset"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBotDefenseFlowLabelAccountManagementChoiceTypeValidator = func() *ValidateBotDefenseFlowLabelAccountManagementChoiceType {
	v := &ValidateBotDefenseFlowLabelAccountManagementChoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhLabelChoice := v.LabelChoiceValidationRuleHandler
	rulesLabelChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLabelChoice(rulesLabelChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BotDefenseFlowLabelAccountManagementChoiceType.label_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["label_choice"] = vFn

	return v
}()

func BotDefenseFlowLabelAccountManagementChoiceTypeValidator() db.Validator {
	return DefaultBotDefenseFlowLabelAccountManagementChoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *BotDefenseFlowLabelAuthenticationChoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BotDefenseFlowLabelAuthenticationChoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BotDefenseFlowLabelAuthenticationChoiceType) DeepCopy() *BotDefenseFlowLabelAuthenticationChoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BotDefenseFlowLabelAuthenticationChoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BotDefenseFlowLabelAuthenticationChoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BotDefenseFlowLabelAuthenticationChoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BotDefenseFlowLabelAuthenticationChoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateBotDefenseFlowLabelAuthenticationChoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBotDefenseFlowLabelAuthenticationChoiceType) LabelChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for label_choice")
	}
	return validatorFn, nil
}

func (v *ValidateBotDefenseFlowLabelAuthenticationChoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BotDefenseFlowLabelAuthenticationChoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BotDefenseFlowLabelAuthenticationChoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["label_choice"]; exists {
		val := m.GetLabelChoice()
		vOpts := append(opts,
			db.WithValidateField("label_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLabelChoice().(type) {
	case *BotDefenseFlowLabelAuthenticationChoiceType_Login:
		if fv, exists := v.FldValidators["label_choice.login"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelAuthenticationChoiceType_Login).Login
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("login"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelAuthenticationChoiceType_LoginMfa:
		if fv, exists := v.FldValidators["label_choice.login_mfa"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelAuthenticationChoiceType_LoginMfa).LoginMfa
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("login_mfa"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelAuthenticationChoiceType_LoginPartner:
		if fv, exists := v.FldValidators["label_choice.login_partner"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelAuthenticationChoiceType_LoginPartner).LoginPartner
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("login_partner"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelAuthenticationChoiceType_Logout:
		if fv, exists := v.FldValidators["label_choice.logout"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelAuthenticationChoiceType_Logout).Logout
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("logout"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelAuthenticationChoiceType_TokenRefresh:
		if fv, exists := v.FldValidators["label_choice.token_refresh"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelAuthenticationChoiceType_TokenRefresh).TokenRefresh
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("token_refresh"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBotDefenseFlowLabelAuthenticationChoiceTypeValidator = func() *ValidateBotDefenseFlowLabelAuthenticationChoiceType {
	v := &ValidateBotDefenseFlowLabelAuthenticationChoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhLabelChoice := v.LabelChoiceValidationRuleHandler
	rulesLabelChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLabelChoice(rulesLabelChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BotDefenseFlowLabelAuthenticationChoiceType.label_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["label_choice"] = vFn

	v.FldValidators["label_choice.login"] = BotDefenseTransactionResultValidator().Validate

	return v
}()

func BotDefenseFlowLabelAuthenticationChoiceTypeValidator() db.Validator {
	return DefaultBotDefenseFlowLabelAuthenticationChoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *BotDefenseFlowLabelCategoriesChoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BotDefenseFlowLabelCategoriesChoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BotDefenseFlowLabelCategoriesChoiceType) DeepCopy() *BotDefenseFlowLabelCategoriesChoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BotDefenseFlowLabelCategoriesChoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BotDefenseFlowLabelCategoriesChoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BotDefenseFlowLabelCategoriesChoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BotDefenseFlowLabelCategoriesChoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateBotDefenseFlowLabelCategoriesChoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBotDefenseFlowLabelCategoriesChoiceType) FlowLabelChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for flow_label_choice")
	}
	return validatorFn, nil
}

func (v *ValidateBotDefenseFlowLabelCategoriesChoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BotDefenseFlowLabelCategoriesChoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BotDefenseFlowLabelCategoriesChoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["flow_label_choice"]; exists {
		val := m.GetFlowLabelChoice()
		vOpts := append(opts,
			db.WithValidateField("flow_label_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetFlowLabelChoice().(type) {
	case *BotDefenseFlowLabelCategoriesChoiceType_Authentication:
		if fv, exists := v.FldValidators["flow_label_choice.authentication"]; exists {
			val := m.GetFlowLabelChoice().(*BotDefenseFlowLabelCategoriesChoiceType_Authentication).Authentication
			vOpts := append(opts,
				db.WithValidateField("flow_label_choice"),
				db.WithValidateField("authentication"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelCategoriesChoiceType_AccountManagement:
		if fv, exists := v.FldValidators["flow_label_choice.account_management"]; exists {
			val := m.GetFlowLabelChoice().(*BotDefenseFlowLabelCategoriesChoiceType_AccountManagement).AccountManagement
			vOpts := append(opts,
				db.WithValidateField("flow_label_choice"),
				db.WithValidateField("account_management"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelCategoriesChoiceType_ProfileManagement:
		if fv, exists := v.FldValidators["flow_label_choice.profile_management"]; exists {
			val := m.GetFlowLabelChoice().(*BotDefenseFlowLabelCategoriesChoiceType_ProfileManagement).ProfileManagement
			vOpts := append(opts,
				db.WithValidateField("flow_label_choice"),
				db.WithValidateField("profile_management"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelCategoriesChoiceType_ShoppingGiftCards:
		if fv, exists := v.FldValidators["flow_label_choice.shopping_gift_cards"]; exists {
			val := m.GetFlowLabelChoice().(*BotDefenseFlowLabelCategoriesChoiceType_ShoppingGiftCards).ShoppingGiftCards
			vOpts := append(opts,
				db.WithValidateField("flow_label_choice"),
				db.WithValidateField("shopping_gift_cards"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelCategoriesChoiceType_FinancialServices:
		if fv, exists := v.FldValidators["flow_label_choice.financial_services"]; exists {
			val := m.GetFlowLabelChoice().(*BotDefenseFlowLabelCategoriesChoiceType_FinancialServices).FinancialServices
			vOpts := append(opts,
				db.WithValidateField("flow_label_choice"),
				db.WithValidateField("financial_services"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelCategoriesChoiceType_Search:
		if fv, exists := v.FldValidators["flow_label_choice.search"]; exists {
			val := m.GetFlowLabelChoice().(*BotDefenseFlowLabelCategoriesChoiceType_Search).Search
			vOpts := append(opts,
				db.WithValidateField("flow_label_choice"),
				db.WithValidateField("search"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelCategoriesChoiceType_Flight:
		if fv, exists := v.FldValidators["flow_label_choice.flight"]; exists {
			val := m.GetFlowLabelChoice().(*BotDefenseFlowLabelCategoriesChoiceType_Flight).Flight
			vOpts := append(opts,
				db.WithValidateField("flow_label_choice"),
				db.WithValidateField("flight"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBotDefenseFlowLabelCategoriesChoiceTypeValidator = func() *ValidateBotDefenseFlowLabelCategoriesChoiceType {
	v := &ValidateBotDefenseFlowLabelCategoriesChoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhFlowLabelChoice := v.FlowLabelChoiceValidationRuleHandler
	rulesFlowLabelChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhFlowLabelChoice(rulesFlowLabelChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BotDefenseFlowLabelCategoriesChoiceType.flow_label_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["flow_label_choice"] = vFn

	v.FldValidators["flow_label_choice.authentication"] = BotDefenseFlowLabelAuthenticationChoiceTypeValidator().Validate
	v.FldValidators["flow_label_choice.account_management"] = BotDefenseFlowLabelAccountManagementChoiceTypeValidator().Validate
	v.FldValidators["flow_label_choice.profile_management"] = BotDefenseFlowLabelProfileManagementChoiceTypeValidator().Validate
	v.FldValidators["flow_label_choice.financial_services"] = BotDefenseFlowLabelFinancialServicesChoiceTypeValidator().Validate
	v.FldValidators["flow_label_choice.flight"] = BotDefenseFlowLabelFlightChoiceTypeValidator().Validate

	return v
}()

func BotDefenseFlowLabelCategoriesChoiceTypeValidator() db.Validator {
	return DefaultBotDefenseFlowLabelCategoriesChoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *BotDefenseFlowLabelFinancialServicesChoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BotDefenseFlowLabelFinancialServicesChoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BotDefenseFlowLabelFinancialServicesChoiceType) DeepCopy() *BotDefenseFlowLabelFinancialServicesChoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BotDefenseFlowLabelFinancialServicesChoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BotDefenseFlowLabelFinancialServicesChoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BotDefenseFlowLabelFinancialServicesChoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BotDefenseFlowLabelFinancialServicesChoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateBotDefenseFlowLabelFinancialServicesChoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBotDefenseFlowLabelFinancialServicesChoiceType) LabelChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for label_choice")
	}
	return validatorFn, nil
}

func (v *ValidateBotDefenseFlowLabelFinancialServicesChoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BotDefenseFlowLabelFinancialServicesChoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BotDefenseFlowLabelFinancialServicesChoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["label_choice"]; exists {
		val := m.GetLabelChoice()
		vOpts := append(opts,
			db.WithValidateField("label_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLabelChoice().(type) {
	case *BotDefenseFlowLabelFinancialServicesChoiceType_Apply:
		if fv, exists := v.FldValidators["label_choice.apply"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelFinancialServicesChoiceType_Apply).Apply
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("apply"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelFinancialServicesChoiceType_MoneyTransfer:
		if fv, exists := v.FldValidators["label_choice.money_transfer"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelFinancialServicesChoiceType_MoneyTransfer).MoneyTransfer
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("money_transfer"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBotDefenseFlowLabelFinancialServicesChoiceTypeValidator = func() *ValidateBotDefenseFlowLabelFinancialServicesChoiceType {
	v := &ValidateBotDefenseFlowLabelFinancialServicesChoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhLabelChoice := v.LabelChoiceValidationRuleHandler
	rulesLabelChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLabelChoice(rulesLabelChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BotDefenseFlowLabelFinancialServicesChoiceType.label_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["label_choice"] = vFn

	return v
}()

func BotDefenseFlowLabelFinancialServicesChoiceTypeValidator() db.Validator {
	return DefaultBotDefenseFlowLabelFinancialServicesChoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *BotDefenseFlowLabelFlightChoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BotDefenseFlowLabelFlightChoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BotDefenseFlowLabelFlightChoiceType) DeepCopy() *BotDefenseFlowLabelFlightChoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BotDefenseFlowLabelFlightChoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BotDefenseFlowLabelFlightChoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BotDefenseFlowLabelFlightChoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BotDefenseFlowLabelFlightChoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateBotDefenseFlowLabelFlightChoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBotDefenseFlowLabelFlightChoiceType) LabelChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for label_choice")
	}
	return validatorFn, nil
}

func (v *ValidateBotDefenseFlowLabelFlightChoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BotDefenseFlowLabelFlightChoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BotDefenseFlowLabelFlightChoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["label_choice"]; exists {
		val := m.GetLabelChoice()
		vOpts := append(opts,
			db.WithValidateField("label_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLabelChoice().(type) {
	case *BotDefenseFlowLabelFlightChoiceType_Checkin:
		if fv, exists := v.FldValidators["label_choice.checkin"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelFlightChoiceType_Checkin).Checkin
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("checkin"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBotDefenseFlowLabelFlightChoiceTypeValidator = func() *ValidateBotDefenseFlowLabelFlightChoiceType {
	v := &ValidateBotDefenseFlowLabelFlightChoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhLabelChoice := v.LabelChoiceValidationRuleHandler
	rulesLabelChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLabelChoice(rulesLabelChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BotDefenseFlowLabelFlightChoiceType.label_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["label_choice"] = vFn

	return v
}()

func BotDefenseFlowLabelFlightChoiceTypeValidator() db.Validator {
	return DefaultBotDefenseFlowLabelFlightChoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *BotDefenseFlowLabelProfileManagementChoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BotDefenseFlowLabelProfileManagementChoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BotDefenseFlowLabelProfileManagementChoiceType) DeepCopy() *BotDefenseFlowLabelProfileManagementChoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BotDefenseFlowLabelProfileManagementChoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BotDefenseFlowLabelProfileManagementChoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BotDefenseFlowLabelProfileManagementChoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BotDefenseFlowLabelProfileManagementChoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateBotDefenseFlowLabelProfileManagementChoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBotDefenseFlowLabelProfileManagementChoiceType) LabelChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for label_choice")
	}
	return validatorFn, nil
}

func (v *ValidateBotDefenseFlowLabelProfileManagementChoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BotDefenseFlowLabelProfileManagementChoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BotDefenseFlowLabelProfileManagementChoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["label_choice"]; exists {
		val := m.GetLabelChoice()
		vOpts := append(opts,
			db.WithValidateField("label_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLabelChoice().(type) {
	case *BotDefenseFlowLabelProfileManagementChoiceType_Create:
		if fv, exists := v.FldValidators["label_choice.create"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelProfileManagementChoiceType_Create).Create
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("create"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelProfileManagementChoiceType_Update:
		if fv, exists := v.FldValidators["label_choice.update"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelProfileManagementChoiceType_Update).Update
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("update"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelProfileManagementChoiceType_View:
		if fv, exists := v.FldValidators["label_choice.view"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelProfileManagementChoiceType_View).View
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("view"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBotDefenseFlowLabelProfileManagementChoiceTypeValidator = func() *ValidateBotDefenseFlowLabelProfileManagementChoiceType {
	v := &ValidateBotDefenseFlowLabelProfileManagementChoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhLabelChoice := v.LabelChoiceValidationRuleHandler
	rulesLabelChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLabelChoice(rulesLabelChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BotDefenseFlowLabelProfileManagementChoiceType.label_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["label_choice"] = vFn

	return v
}()

func BotDefenseFlowLabelProfileManagementChoiceTypeValidator() db.Validator {
	return DefaultBotDefenseFlowLabelProfileManagementChoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *BotDefenseFlowLabelSearchChoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BotDefenseFlowLabelSearchChoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BotDefenseFlowLabelSearchChoiceType) DeepCopy() *BotDefenseFlowLabelSearchChoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BotDefenseFlowLabelSearchChoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BotDefenseFlowLabelSearchChoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BotDefenseFlowLabelSearchChoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BotDefenseFlowLabelSearchChoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateBotDefenseFlowLabelSearchChoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBotDefenseFlowLabelSearchChoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BotDefenseFlowLabelSearchChoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BotDefenseFlowLabelSearchChoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetLabelChoice().(type) {
	case *BotDefenseFlowLabelSearchChoiceType_FlightSearch:
		if fv, exists := v.FldValidators["label_choice.flight_search"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelSearchChoiceType_FlightSearch).FlightSearch
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("flight_search"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelSearchChoiceType_ProductSearch:
		if fv, exists := v.FldValidators["label_choice.product_search"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelSearchChoiceType_ProductSearch).ProductSearch
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("product_search"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelSearchChoiceType_RoomSearch:
		if fv, exists := v.FldValidators["label_choice.room_search"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelSearchChoiceType_RoomSearch).RoomSearch
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("room_search"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelSearchChoiceType_ReservationSearch:
		if fv, exists := v.FldValidators["label_choice.reservation_search"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelSearchChoiceType_ReservationSearch).ReservationSearch
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("reservation_search"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBotDefenseFlowLabelSearchChoiceTypeValidator = func() *ValidateBotDefenseFlowLabelSearchChoiceType {
	v := &ValidateBotDefenseFlowLabelSearchChoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func BotDefenseFlowLabelSearchChoiceTypeValidator() db.Validator {
	return DefaultBotDefenseFlowLabelSearchChoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) DeepCopy() *BotDefenseFlowLabelShoppingGiftCardsChoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BotDefenseFlowLabelShoppingGiftCardsChoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BotDefenseFlowLabelShoppingGiftCardsChoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateBotDefenseFlowLabelShoppingGiftCardsChoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBotDefenseFlowLabelShoppingGiftCardsChoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BotDefenseFlowLabelShoppingGiftCardsChoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BotDefenseFlowLabelShoppingGiftCardsChoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetLabelChoice().(type) {
	case *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopAddToCart:
		if fv, exists := v.FldValidators["label_choice.shop_add_to_cart"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopAddToCart).ShopAddToCart
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("shop_add_to_cart"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPromoCodeValidation:
		if fv, exists := v.FldValidators["label_choice.shop_promo_code_validation"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPromoCodeValidation).ShopPromoCodeValidation
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("shop_promo_code_validation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopCheckout:
		if fv, exists := v.FldValidators["label_choice.shop_checkout"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopCheckout).ShopCheckout
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("shop_checkout"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopMakePayment:
		if fv, exists := v.FldValidators["label_choice.shop_make_payment"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopMakePayment).ShopMakePayment
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("shop_make_payment"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopOrder:
		if fv, exists := v.FldValidators["label_choice.shop_order"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopOrder).ShopOrder
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("shop_order"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPriceInquiry:
		if fv, exists := v.FldValidators["label_choice.shop_price_inquiry"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPriceInquiry).ShopPriceInquiry
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("shop_price_inquiry"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPurchaseGiftCard:
		if fv, exists := v.FldValidators["label_choice.shop_purchase_gift_card"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPurchaseGiftCard).ShopPurchaseGiftCard
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("shop_purchase_gift_card"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopUpdateQuantity:
		if fv, exists := v.FldValidators["label_choice.shop_update_quantity"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopUpdateQuantity).ShopUpdateQuantity
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("shop_update_quantity"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopChooseSeat:
		if fv, exists := v.FldValidators["label_choice.shop_choose_seat"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopChooseSeat).ShopChooseSeat
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("shop_choose_seat"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopEnterDrawingSubmission:
		if fv, exists := v.FldValidators["label_choice.shop_enter_drawing_submission"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopEnterDrawingSubmission).ShopEnterDrawingSubmission
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("shop_enter_drawing_submission"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardValidation:
		if fv, exists := v.FldValidators["label_choice.gift_card_validation"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardValidation).GiftCardValidation
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("gift_card_validation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardMakePurchaseWithGiftCard:
		if fv, exists := v.FldValidators["label_choice.gift_card_make_purchase_with_gift_card"]; exists {
			val := m.GetLabelChoice().(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardMakePurchaseWithGiftCard).GiftCardMakePurchaseWithGiftCard
			vOpts := append(opts,
				db.WithValidateField("label_choice"),
				db.WithValidateField("gift_card_make_purchase_with_gift_card"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBotDefenseFlowLabelShoppingGiftCardsChoiceTypeValidator = func() *ValidateBotDefenseFlowLabelShoppingGiftCardsChoiceType {
	v := &ValidateBotDefenseFlowLabelShoppingGiftCardsChoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func BotDefenseFlowLabelShoppingGiftCardsChoiceTypeValidator() db.Validator {
	return DefaultBotDefenseFlowLabelShoppingGiftCardsChoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *BotDefenseTransactionResult) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BotDefenseTransactionResult) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BotDefenseTransactionResult) DeepCopy() *BotDefenseTransactionResult {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BotDefenseTransactionResult{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BotDefenseTransactionResult) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BotDefenseTransactionResult) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BotDefenseTransactionResultValidator().Validate(ctx, m, opts...)
}

type ValidateBotDefenseTransactionResult struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBotDefenseTransactionResult) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BotDefenseTransactionResult)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BotDefenseTransactionResult got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetTransactionResultChoice().(type) {
	case *BotDefenseTransactionResult_DisableTransactionResult:
		if fv, exists := v.FldValidators["transaction_result_choice.disable_transaction_result"]; exists {
			val := m.GetTransactionResultChoice().(*BotDefenseTransactionResult_DisableTransactionResult).DisableTransactionResult
			vOpts := append(opts,
				db.WithValidateField("transaction_result_choice"),
				db.WithValidateField("disable_transaction_result"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseTransactionResult_TransactionResult:
		if fv, exists := v.FldValidators["transaction_result_choice.transaction_result"]; exists {
			val := m.GetTransactionResultChoice().(*BotDefenseTransactionResult_TransactionResult).TransactionResult
			vOpts := append(opts,
				db.WithValidateField("transaction_result_choice"),
				db.WithValidateField("transaction_result"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBotDefenseTransactionResultValidator = func() *ValidateBotDefenseTransactionResult {
	v := &ValidateBotDefenseTransactionResult{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["transaction_result_choice.transaction_result"] = BotDefenseTransactionResultTypeValidator().Validate

	return v
}()

func BotDefenseTransactionResultValidator() db.Validator {
	return DefaultBotDefenseTransactionResultValidator
}

// augmented methods on protoc/std generated struct

func (m *BotDefenseTransactionResultCondition) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BotDefenseTransactionResultCondition) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BotDefenseTransactionResultCondition) DeepCopy() *BotDefenseTransactionResultCondition {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BotDefenseTransactionResultCondition{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BotDefenseTransactionResultCondition) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BotDefenseTransactionResultCondition) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BotDefenseTransactionResultConditionValidator().Validate(ctx, m, opts...)
}

type ValidateBotDefenseTransactionResultCondition struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBotDefenseTransactionResultCondition) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateBotDefenseTransactionResultCondition) RegexValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for regex_values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for regex_values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated regex_values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items regex_values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateBotDefenseTransactionResultCondition) StatusValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(HttpStatusCode)
		return int32(i)
	}
	// HttpStatusCode_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, HttpStatusCode_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for status")
	}

	return validatorFn, nil
}

func (v *ValidateBotDefenseTransactionResultCondition) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BotDefenseTransactionResultCondition)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BotDefenseTransactionResultCondition got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["regex_values"]; exists {
		vOpts := append(opts, db.WithValidateField("regex_values"))
		if err := fv(ctx, m.GetRegexValues(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBotDefenseTransactionResultConditionValidator = func() *ValidateBotDefenseTransactionResultCondition {
	v := &ValidateBotDefenseTransactionResultCondition{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.string.http_header_field": "true",
		"ves.io.schema.rules.string.max_bytes":         "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BotDefenseTransactionResultCondition.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhRegexValues := v.RegexValuesValidationRuleHandler
	rulesRegexValues := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.not_empty": "true",
		"ves.io.schema.rules.repeated.items.string.regex":     "true",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhRegexValues(rulesRegexValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BotDefenseTransactionResultCondition.regex_values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["regex_values"] = vFn

	vrhStatus := v.StatusValidationRuleHandler
	rulesStatus := map[string]string{
		"ves.io.schema.rules.enum.defined_only": "true",
		"ves.io.schema.rules.message.required":  "true",
	}
	vFn, err = vrhStatus(rulesStatus)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BotDefenseTransactionResultCondition.status: %s", err)
		panic(errMsg)
	}
	v.FldValidators["status"] = vFn

	return v
}()

func BotDefenseTransactionResultConditionValidator() db.Validator {
	return DefaultBotDefenseTransactionResultConditionValidator
}

// augmented methods on protoc/std generated struct

func (m *BotDefenseTransactionResultType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BotDefenseTransactionResultType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BotDefenseTransactionResultType) DeepCopy() *BotDefenseTransactionResultType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BotDefenseTransactionResultType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BotDefenseTransactionResultType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BotDefenseTransactionResultType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BotDefenseTransactionResultTypeValidator().Validate(ctx, m, opts...)
}

type ValidateBotDefenseTransactionResultType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBotDefenseTransactionResultType) SuccessConditionsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for success_conditions")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*BotDefenseTransactionResultCondition, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := BotDefenseTransactionResultConditionValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for success_conditions")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*BotDefenseTransactionResultCondition)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*BotDefenseTransactionResultCondition, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated success_conditions")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items success_conditions")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateBotDefenseTransactionResultType) FailureConditionsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for failure_conditions")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*BotDefenseTransactionResultCondition, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := BotDefenseTransactionResultConditionValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for failure_conditions")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*BotDefenseTransactionResultCondition)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*BotDefenseTransactionResultCondition, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated failure_conditions")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items failure_conditions")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateBotDefenseTransactionResultType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BotDefenseTransactionResultType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BotDefenseTransactionResultType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["failure_conditions"]; exists {
		vOpts := append(opts, db.WithValidateField("failure_conditions"))
		if err := fv(ctx, m.GetFailureConditions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["success_conditions"]; exists {
		vOpts := append(opts, db.WithValidateField("success_conditions"))
		if err := fv(ctx, m.GetSuccessConditions(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBotDefenseTransactionResultTypeValidator = func() *ValidateBotDefenseTransactionResultType {
	v := &ValidateBotDefenseTransactionResultType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSuccessConditions := v.SuccessConditionsValidationRuleHandler
	rulesSuccessConditions := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "3",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhSuccessConditions(rulesSuccessConditions)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BotDefenseTransactionResultType.success_conditions: %s", err)
		panic(errMsg)
	}
	v.FldValidators["success_conditions"] = vFn

	vrhFailureConditions := v.FailureConditionsValidationRuleHandler
	rulesFailureConditions := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "3",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhFailureConditions(rulesFailureConditions)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BotDefenseTransactionResultType.failure_conditions: %s", err)
		panic(errMsg)
	}
	v.FldValidators["failure_conditions"] = vFn

	return v
}()

func BotDefenseTransactionResultTypeValidator() db.Validator {
	return DefaultBotDefenseTransactionResultTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *BufferConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BufferConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BufferConfigType) DeepCopy() *BufferConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BufferConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BufferConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BufferConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BufferConfigTypeValidator().Validate(ctx, m, opts...)
}

type ValidateBufferConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBufferConfigType) MaxRequestBytesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_request_bytes")
	}

	return validatorFn, nil
}

func (v *ValidateBufferConfigType) MaxRequestTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_request_time")
	}

	return validatorFn, nil
}

func (v *ValidateBufferConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BufferConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BufferConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["disabled"]; exists {

		vOpts := append(opts, db.WithValidateField("disabled"))
		if err := fv(ctx, m.GetDisabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_request_bytes"]; exists {

		vOpts := append(opts, db.WithValidateField("max_request_bytes"))
		if err := fv(ctx, m.GetMaxRequestBytes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_request_time"]; exists {

		vOpts := append(opts, db.WithValidateField("max_request_time"))
		if err := fv(ctx, m.GetMaxRequestTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBufferConfigTypeValidator = func() *ValidateBufferConfigType {
	v := &ValidateBufferConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMaxRequestBytes := v.MaxRequestBytesValidationRuleHandler
	rulesMaxRequestBytes := map[string]string{
		"ves.io.schema.rules.uint32.lte": "10485760",
	}
	vFn, err = vrhMaxRequestBytes(rulesMaxRequestBytes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BufferConfigType.max_request_bytes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_request_bytes"] = vFn

	vrhMaxRequestTime := v.MaxRequestTimeValidationRuleHandler
	rulesMaxRequestTime := map[string]string{
		"ves.io.schema.rules.uint32.lte": "600",
	}
	vFn, err = vrhMaxRequestTime(rulesMaxRequestTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BufferConfigType.max_request_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_request_time"] = vFn

	return v
}()

func BufferConfigTypeValidator() db.Validator {
	return DefaultBufferConfigTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CRMInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CRMInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CRMInfo) DeepCopy() *CRMInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CRMInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CRMInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CRMInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CRMInfoValidator().Validate(ctx, m, opts...)
}

type ValidateCRMInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCRMInfo) AccountIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for account_id")
	}

	return validatorFn, nil
}

func (v *ValidateCRMInfo) EntitlementIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for entitlement_id")
	}

	return validatorFn, nil
}

func (v *ValidateCRMInfo) SubscriptionIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for subscription_id")
	}

	return validatorFn, nil
}

func (v *ValidateCRMInfo) OrderTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for order_type")
	}

	return validatorFn, nil
}

func (v *ValidateCRMInfo) CustomerIdentifierValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for customer_identifier")
	}

	return validatorFn, nil
}

func (v *ValidateCRMInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CRMInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CRMInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["account_id"]; exists {

		vOpts := append(opts, db.WithValidateField("account_id"))
		if err := fv(ctx, m.GetAccountId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["customer_identifier"]; exists {

		vOpts := append(opts, db.WithValidateField("customer_identifier"))
		if err := fv(ctx, m.GetCustomerIdentifier(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["entitled_skus"]; exists {

		vOpts := append(opts, db.WithValidateField("entitled_skus"))
		for idx, item := range m.GetEntitledSkus() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["entitlement_id"]; exists {

		vOpts := append(opts, db.WithValidateField("entitlement_id"))
		if err := fv(ctx, m.GetEntitlementId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["order_type"]; exists {

		vOpts := append(opts, db.WithValidateField("order_type"))
		if err := fv(ctx, m.GetOrderType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["subscription_id"]; exists {

		vOpts := append(opts, db.WithValidateField("subscription_id"))
		if err := fv(ctx, m.GetSubscriptionId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCRMInfoValidator = func() *ValidateCRMInfo {
	v := &ValidateCRMInfo{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAccountId := v.AccountIdValidationRuleHandler
	rulesAccountId := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhAccountId(rulesAccountId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CRMInfo.account_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["account_id"] = vFn

	vrhEntitlementId := v.EntitlementIdValidationRuleHandler
	rulesEntitlementId := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhEntitlementId(rulesEntitlementId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CRMInfo.entitlement_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["entitlement_id"] = vFn

	vrhSubscriptionId := v.SubscriptionIdValidationRuleHandler
	rulesSubscriptionId := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhSubscriptionId(rulesSubscriptionId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CRMInfo.subscription_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["subscription_id"] = vFn

	vrhOrderType := v.OrderTypeValidationRuleHandler
	rulesOrderType := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhOrderType(rulesOrderType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CRMInfo.order_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["order_type"] = vFn

	vrhCustomerIdentifier := v.CustomerIdentifierValidationRuleHandler
	rulesCustomerIdentifier := map[string]string{
		"ves.io.schema.rules.string.max_len": "255",
	}
	vFn, err = vrhCustomerIdentifier(rulesCustomerIdentifier)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CRMInfo.customer_identifier: %s", err)
		panic(errMsg)
	}
	v.FldValidators["customer_identifier"] = vFn

	return v
}()

func CRMInfoValidator() db.Validator {
	return DefaultCRMInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *ClearSecretInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ClearSecretInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ClearSecretInfoType) DeepCopy() *ClearSecretInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ClearSecretInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ClearSecretInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ClearSecretInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ClearSecretInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateClearSecretInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateClearSecretInfoType) UrlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for url")
	}

	return validatorFn, nil
}

func (v *ValidateClearSecretInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ClearSecretInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ClearSecretInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["provider"]; exists {

		vOpts := append(opts, db.WithValidateField("provider"))
		if err := fv(ctx, m.GetProvider(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["url"]; exists {

		vOpts := append(opts, db.WithValidateField("url"))
		if err := fv(ctx, m.GetUrl(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultClearSecretInfoTypeValidator = func() *ValidateClearSecretInfoType {
	v := &ValidateClearSecretInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhUrl := v.UrlValidationRuleHandler
	rulesUrl := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "131072",
		"ves.io.schema.rules.string.uri_ref":   "true",
	}
	vFn, err = vrhUrl(rulesUrl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ClearSecretInfoType.url: %s", err)
		panic(errMsg)
	}
	v.FldValidators["url"] = vFn

	return v
}()

func ClearSecretInfoTypeValidator() db.Validator {
	return DefaultClearSecretInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ConditionType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ConditionType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ConditionType) DeepCopy() *ConditionType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ConditionType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ConditionType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ConditionType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ConditionTypeValidator().Validate(ctx, m, opts...)
}

type ValidateConditionType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateConditionType) TypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for type")
	}

	return validatorFn, nil
}

func (v *ValidateConditionType) StatusValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for status")
	}

	return validatorFn, nil
}

func (v *ValidateConditionType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ConditionType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ConditionType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["hostname"]; exists {

		vOpts := append(opts, db.WithValidateField("hostname"))
		if err := fv(ctx, m.GetHostname(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["last_update_time"]; exists {

		vOpts := append(opts, db.WithValidateField("last_update_time"))
		if err := fv(ctx, m.GetLastUpdateTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["reason"]; exists {

		vOpts := append(opts, db.WithValidateField("reason"))
		if err := fv(ctx, m.GetReason(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_name"]; exists {

		vOpts := append(opts, db.WithValidateField("service_name"))
		if err := fv(ctx, m.GetServiceName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultConditionTypeValidator = func() *ValidateConditionType {
	v := &ValidateConditionType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhType := v.TypeValidationRuleHandler
	rulesType := map[string]string{
		"ves.io.schema.rules.string.in": "[\"Validation\",\"Operational\"]",
	}
	vFn, err = vrhType(rulesType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ConditionType.type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["type"] = vFn

	vrhStatus := v.StatusValidationRuleHandler
	rulesStatus := map[string]string{
		"ves.io.schema.rules.string.in": "[\"Success\",\"Failed\",\"Incomplete\",\"Installed\",\"Down\",\"Disabled\",\"NotApplicable\"]",
	}
	vFn, err = vrhStatus(rulesStatus)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ConditionType.status: %s", err)
		panic(errMsg)
	}
	v.FldValidators["status"] = vFn

	return v
}()

func ConditionTypeValidator() db.Validator {
	return DefaultConditionTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CookieManipulationOptionType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CookieManipulationOptionType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CookieManipulationOptionType) DeepCopy() *CookieManipulationOptionType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CookieManipulationOptionType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CookieManipulationOptionType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CookieManipulationOptionType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CookieManipulationOptionTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCookieManipulationOptionType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCookieManipulationOptionType) CookieTamperingValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cookie_tampering")
	}
	return validatorFn, nil
}

func (v *ValidateCookieManipulationOptionType) MaxAgeMaxAgeValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_MaxAgeValue, err := db.NewInt32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_age_value")
	}
	return oValidatorFn_MaxAgeValue, nil
}

func (v *ValidateCookieManipulationOptionType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateCookieManipulationOptionType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CookieManipulationOptionType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CookieManipulationOptionType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cookie_tampering"]; exists {
		val := m.GetCookieTampering()
		vOpts := append(opts,
			db.WithValidateField("cookie_tampering"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetCookieTampering().(type) {
	case *CookieManipulationOptionType_DisableTamperingProtection:
		if fv, exists := v.FldValidators["cookie_tampering.disable_tampering_protection"]; exists {
			val := m.GetCookieTampering().(*CookieManipulationOptionType_DisableTamperingProtection).DisableTamperingProtection
			vOpts := append(opts,
				db.WithValidateField("cookie_tampering"),
				db.WithValidateField("disable_tampering_protection"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CookieManipulationOptionType_EnableTamperingProtection:
		if fv, exists := v.FldValidators["cookie_tampering.enable_tampering_protection"]; exists {
			val := m.GetCookieTampering().(*CookieManipulationOptionType_EnableTamperingProtection).EnableTamperingProtection
			vOpts := append(opts,
				db.WithValidateField("cookie_tampering"),
				db.WithValidateField("enable_tampering_protection"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetHttponly().(type) {
	case *CookieManipulationOptionType_IgnoreHttponly:
		if fv, exists := v.FldValidators["httponly.ignore_httponly"]; exists {
			val := m.GetHttponly().(*CookieManipulationOptionType_IgnoreHttponly).IgnoreHttponly
			vOpts := append(opts,
				db.WithValidateField("httponly"),
				db.WithValidateField("ignore_httponly"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CookieManipulationOptionType_AddHttponly:
		if fv, exists := v.FldValidators["httponly.add_httponly"]; exists {
			val := m.GetHttponly().(*CookieManipulationOptionType_AddHttponly).AddHttponly
			vOpts := append(opts,
				db.WithValidateField("httponly"),
				db.WithValidateField("add_httponly"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetMaxAge().(type) {
	case *CookieManipulationOptionType_IgnoreMaxAge:
		if fv, exists := v.FldValidators["max_age.ignore_max_age"]; exists {
			val := m.GetMaxAge().(*CookieManipulationOptionType_IgnoreMaxAge).IgnoreMaxAge
			vOpts := append(opts,
				db.WithValidateField("max_age"),
				db.WithValidateField("ignore_max_age"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CookieManipulationOptionType_MaxAgeValue:
		if fv, exists := v.FldValidators["max_age.max_age_value"]; exists {
			val := m.GetMaxAge().(*CookieManipulationOptionType_MaxAgeValue).MaxAgeValue
			vOpts := append(opts,
				db.WithValidateField("max_age"),
				db.WithValidateField("max_age_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetSamesite().(type) {
	case *CookieManipulationOptionType_SamesiteStrict:
		if fv, exists := v.FldValidators["samesite.samesite_strict"]; exists {
			val := m.GetSamesite().(*CookieManipulationOptionType_SamesiteStrict).SamesiteStrict
			vOpts := append(opts,
				db.WithValidateField("samesite"),
				db.WithValidateField("samesite_strict"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CookieManipulationOptionType_SamesiteLax:
		if fv, exists := v.FldValidators["samesite.samesite_lax"]; exists {
			val := m.GetSamesite().(*CookieManipulationOptionType_SamesiteLax).SamesiteLax
			vOpts := append(opts,
				db.WithValidateField("samesite"),
				db.WithValidateField("samesite_lax"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CookieManipulationOptionType_SamesiteNone:
		if fv, exists := v.FldValidators["samesite.samesite_none"]; exists {
			val := m.GetSamesite().(*CookieManipulationOptionType_SamesiteNone).SamesiteNone
			vOpts := append(opts,
				db.WithValidateField("samesite"),
				db.WithValidateField("samesite_none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CookieManipulationOptionType_IgnoreSamesite:
		if fv, exists := v.FldValidators["samesite.ignore_samesite"]; exists {
			val := m.GetSamesite().(*CookieManipulationOptionType_IgnoreSamesite).IgnoreSamesite
			vOpts := append(opts,
				db.WithValidateField("samesite"),
				db.WithValidateField("ignore_samesite"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetSecure().(type) {
	case *CookieManipulationOptionType_IgnoreSecure:
		if fv, exists := v.FldValidators["secure.ignore_secure"]; exists {
			val := m.GetSecure().(*CookieManipulationOptionType_IgnoreSecure).IgnoreSecure
			vOpts := append(opts,
				db.WithValidateField("secure"),
				db.WithValidateField("ignore_secure"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CookieManipulationOptionType_AddSecure:
		if fv, exists := v.FldValidators["secure.add_secure"]; exists {
			val := m.GetSecure().(*CookieManipulationOptionType_AddSecure).AddSecure
			vOpts := append(opts,
				db.WithValidateField("secure"),
				db.WithValidateField("add_secure"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCookieManipulationOptionTypeValidator = func() *ValidateCookieManipulationOptionType {
	v := &ValidateCookieManipulationOptionType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCookieTampering := v.CookieTamperingValidationRuleHandler
	rulesCookieTampering := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhCookieTampering(rulesCookieTampering)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CookieManipulationOptionType.cookie_tampering: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cookie_tampering"] = vFn

	vrhMaxAgeMaxAgeValue := v.MaxAgeMaxAgeValueValidationRuleHandler
	rulesMaxAgeMaxAgeValue := map[string]string{
		"ves.io.schema.rules.uint32.lte": "34560000",
	}
	vFnMap["max_age.max_age_value"], err = vrhMaxAgeMaxAgeValue(rulesMaxAgeMaxAgeValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field CookieManipulationOptionType.max_age_max_age_value: %s", err)
		panic(errMsg)
	}

	v.FldValidators["max_age.max_age_value"] = vFnMap["max_age.max_age_value"]

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.string.cookie_name": "true",
		"ves.io.schema.rules.string.max_len":     "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CookieManipulationOptionType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func CookieManipulationOptionTypeValidator() db.Validator {
	return DefaultCookieManipulationOptionTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CorsPolicy) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CorsPolicy) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CorsPolicy) DeepCopy() *CorsPolicy {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CorsPolicy{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CorsPolicy) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CorsPolicy) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CorsPolicyValidator().Validate(ctx, m, opts...)
}

type ValidateCorsPolicy struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCorsPolicy) AllowOriginValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for allow_origin")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for allow_origin")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated allow_origin")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items allow_origin")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCorsPolicy) AllowOriginRegexValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for allow_origin_regex")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for allow_origin_regex")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated allow_origin_regex")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items allow_origin_regex")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCorsPolicy) AllowMethodsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for allow_methods")
	}

	return validatorFn, nil
}

func (v *ValidateCorsPolicy) MaximumAgeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewInt32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for maximum_age")
	}

	return validatorFn, nil
}

func (v *ValidateCorsPolicy) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CorsPolicy)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CorsPolicy got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["allow_credentials"]; exists {

		vOpts := append(opts, db.WithValidateField("allow_credentials"))
		if err := fv(ctx, m.GetAllowCredentials(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["allow_headers"]; exists {

		vOpts := append(opts, db.WithValidateField("allow_headers"))
		if err := fv(ctx, m.GetAllowHeaders(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["allow_methods"]; exists {

		vOpts := append(opts, db.WithValidateField("allow_methods"))
		if err := fv(ctx, m.GetAllowMethods(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["allow_origin"]; exists {
		vOpts := append(opts, db.WithValidateField("allow_origin"))
		if err := fv(ctx, m.GetAllowOrigin(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["allow_origin_regex"]; exists {
		vOpts := append(opts, db.WithValidateField("allow_origin_regex"))
		if err := fv(ctx, m.GetAllowOriginRegex(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disabled"]; exists {

		vOpts := append(opts, db.WithValidateField("disabled"))
		if err := fv(ctx, m.GetDisabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["expose_headers"]; exists {

		vOpts := append(opts, db.WithValidateField("expose_headers"))
		if err := fv(ctx, m.GetExposeHeaders(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_age"]; exists {

		vOpts := append(opts, db.WithValidateField("max_age"))
		if err := fv(ctx, m.GetMaxAge(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["maximum_age"]; exists {

		vOpts := append(opts, db.WithValidateField("maximum_age"))
		if err := fv(ctx, m.GetMaximumAge(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCorsPolicyValidator = func() *ValidateCorsPolicy {
	v := &ValidateCorsPolicy{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAllowOrigin := v.AllowOriginValidationRuleHandler
	rulesAllowOrigin := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_len": "256",
		"ves.io.schema.rules.repeated.items.string.min_len": "1",
		"ves.io.schema.rules.repeated.max_items":            "128",
		"ves.io.schema.rules.repeated.unique":               "true",
	}
	vFn, err = vrhAllowOrigin(rulesAllowOrigin)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CorsPolicy.allow_origin: %s", err)
		panic(errMsg)
	}
	v.FldValidators["allow_origin"] = vFn

	vrhAllowOriginRegex := v.AllowOriginRegexValidationRuleHandler
	rulesAllowOriginRegex := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.items.string.regex":     "true",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhAllowOriginRegex(rulesAllowOriginRegex)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CorsPolicy.allow_origin_regex: %s", err)
		panic(errMsg)
	}
	v.FldValidators["allow_origin_regex"] = vFn

	vrhAllowMethods := v.AllowMethodsValidationRuleHandler
	rulesAllowMethods := map[string]string{
		"ves.io.schema.rules.string.http_valid_methods": "true",
	}
	vFn, err = vrhAllowMethods(rulesAllowMethods)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CorsPolicy.allow_methods: %s", err)
		panic(errMsg)
	}
	v.FldValidators["allow_methods"] = vFn

	vrhMaximumAge := v.MaximumAgeValidationRuleHandler
	rulesMaximumAge := map[string]string{
		"ves.io.schema.rules.int32.gte": "-1",
		"ves.io.schema.rules.int32.lte": "86400",
	}
	vFn, err = vrhMaximumAge(rulesMaximumAge)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CorsPolicy.maximum_age: %s", err)
		panic(errMsg)
	}
	v.FldValidators["maximum_age"] = vFn

	return v
}()

func CorsPolicyValidator() db.Validator {
	return DefaultCorsPolicyValidator
}

// augmented methods on protoc/std generated struct

func (m *CsrfPolicy) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CsrfPolicy) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CsrfPolicy) DeepCopy() *CsrfPolicy {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CsrfPolicy{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CsrfPolicy) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CsrfPolicy) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CsrfPolicyValidator().Validate(ctx, m, opts...)
}

type ValidateCsrfPolicy struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCsrfPolicy) AllowedDomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for allowed_domains")
	}
	return validatorFn, nil
}

func (v *ValidateCsrfPolicy) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CsrfPolicy)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CsrfPolicy got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["allowed_domains"]; exists {
		val := m.GetAllowedDomains()
		vOpts := append(opts,
			db.WithValidateField("allowed_domains"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAllowedDomains().(type) {
	case *CsrfPolicy_AllLoadBalancerDomains:
		if fv, exists := v.FldValidators["allowed_domains.all_load_balancer_domains"]; exists {
			val := m.GetAllowedDomains().(*CsrfPolicy_AllLoadBalancerDomains).AllLoadBalancerDomains
			vOpts := append(opts,
				db.WithValidateField("allowed_domains"),
				db.WithValidateField("all_load_balancer_domains"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CsrfPolicy_CustomDomainList:
		if fv, exists := v.FldValidators["allowed_domains.custom_domain_list"]; exists {
			val := m.GetAllowedDomains().(*CsrfPolicy_CustomDomainList).CustomDomainList
			vOpts := append(opts,
				db.WithValidateField("allowed_domains"),
				db.WithValidateField("custom_domain_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CsrfPolicy_Disabled:
		if fv, exists := v.FldValidators["allowed_domains.disabled"]; exists {
			val := m.GetAllowedDomains().(*CsrfPolicy_Disabled).Disabled
			vOpts := append(opts,
				db.WithValidateField("allowed_domains"),
				db.WithValidateField("disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCsrfPolicyValidator = func() *ValidateCsrfPolicy {
	v := &ValidateCsrfPolicy{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAllowedDomains := v.AllowedDomainsValidationRuleHandler
	rulesAllowedDomains := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAllowedDomains(rulesAllowedDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CsrfPolicy.allowed_domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["allowed_domains"] = vFn

	v.FldValidators["allowed_domains.custom_domain_list"] = DomainNameListValidator().Validate

	return v
}()

func CsrfPolicyValidator() db.Validator {
	return DefaultCsrfPolicyValidator
}

// augmented methods on protoc/std generated struct

func (m *DateRange) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DateRange) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DateRange) DeepCopy() *DateRange {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DateRange{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DateRange) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DateRange) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DateRangeValidator().Validate(ctx, m, opts...)
}

type ValidateDateRange struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDateRange) StartDateValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var (
		reqdValidatorFn db.ValidatorFunc
		err             error
	)

	reqdValidatorFn, err = db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for start_date")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if reqdValidatorFn != nil {
			if err = reqdValidatorFn(ctx, val, opts...); err != nil {
				return err
			}
		}
		// TODO: lookup configured third-party type validators
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDateRange) EndDateValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var (
		reqdValidatorFn db.ValidatorFunc
		err             error
	)

	reqdValidatorFn, err = db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for end_date")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if reqdValidatorFn != nil {
			if err = reqdValidatorFn(ctx, val, opts...); err != nil {
				return err
			}
		}
		// TODO: lookup configured third-party type validators
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDateRange) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DateRange)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DateRange got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["end_date"]; exists {

		vOpts := append(opts, db.WithValidateField("end_date"))
		if err := fv(ctx, m.GetEndDate(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_date"]; exists {

		vOpts := append(opts, db.WithValidateField("start_date"))
		if err := fv(ctx, m.GetStartDate(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDateRangeValidator = func() *ValidateDateRange {
	v := &ValidateDateRange{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStartDate := v.StartDateValidationRuleHandler
	rulesStartDate := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhStartDate(rulesStartDate)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DateRange.start_date: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_date"] = vFn

	vrhEndDate := v.EndDateValidationRuleHandler
	rulesEndDate := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhEndDate(rulesEndDate)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DateRange.end_date: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_date"] = vFn

	return v
}()

func DateRangeValidator() db.Validator {
	return DefaultDateRangeValidator
}

// augmented methods on protoc/std generated struct

func (m *DomainNameList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DomainNameList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DomainNameList) DeepCopy() *DomainNameList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DomainNameList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DomainNameList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DomainNameList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DomainNameListValidator().Validate(ctx, m, opts...)
}

type ValidateDomainNameList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDomainNameList) DomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDomainNameList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DomainNameList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DomainNameList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domains"]; exists {
		vOpts := append(opts, db.WithValidateField("domains"))
		if err := fv(ctx, m.GetDomains(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDomainNameListValidator = func() *ValidateDomainNameList {
	v := &ValidateDomainNameList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomains := v.DomainsValidationRuleHandler
	rulesDomains := map[string]string{
		"ves.io.schema.rules.message.required":                "true",
		"ves.io.schema.rules.repeated.items.string.max_len":   "256",
		"ves.io.schema.rules.repeated.items.string.min_len":   "1",
		"ves.io.schema.rules.repeated.items.string.vh_domain": "true",
		"ves.io.schema.rules.repeated.max_items":              "32",
		"ves.io.schema.rules.repeated.min_items":              "1",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhDomains(rulesDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DomainNameList.domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domains"] = vFn

	return v
}()

func DomainNameListValidator() db.Validator {
	return DefaultDomainNameListValidator
}

// augmented methods on protoc/std generated struct

func (m *DomainType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DomainType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DomainType) DeepCopy() *DomainType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DomainType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DomainType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DomainType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DomainTypeValidator().Validate(ctx, m, opts...)
}

type ValidateDomainType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDomainType) DomainChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDomainType) DomainChoiceExactValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ExactValue, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for exact_value")
	}
	return oValidatorFn_ExactValue, nil
}
func (v *ValidateDomainType) DomainChoiceSuffixValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SuffixValue, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for suffix_value")
	}
	return oValidatorFn_SuffixValue, nil
}
func (v *ValidateDomainType) DomainChoiceRegexValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_RegexValue, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for regex_value")
	}
	return oValidatorFn_RegexValue, nil
}

func (v *ValidateDomainType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DomainType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DomainType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domain_choice"]; exists {
		val := m.GetDomainChoice()
		vOpts := append(opts,
			db.WithValidateField("domain_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDomainChoice().(type) {
	case *DomainType_ExactValue:
		if fv, exists := v.FldValidators["domain_choice.exact_value"]; exists {
			val := m.GetDomainChoice().(*DomainType_ExactValue).ExactValue
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("exact_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DomainType_SuffixValue:
		if fv, exists := v.FldValidators["domain_choice.suffix_value"]; exists {
			val := m.GetDomainChoice().(*DomainType_SuffixValue).SuffixValue
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("suffix_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DomainType_RegexValue:
		if fv, exists := v.FldValidators["domain_choice.regex_value"]; exists {
			val := m.GetDomainChoice().(*DomainType_RegexValue).RegexValue
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("regex_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDomainTypeValidator = func() *ValidateDomainType {
	v := &ValidateDomainType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomainChoice := v.DomainChoiceValidationRuleHandler
	rulesDomainChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDomainChoice(rulesDomainChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DomainType.domain_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_choice"] = vFn

	vrhDomainChoiceExactValue := v.DomainChoiceExactValueValidationRuleHandler
	rulesDomainChoiceExactValue := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
		"ves.io.schema.rules.string.max_len":  "256",
		"ves.io.schema.rules.string.min_len":  "1",
	}
	vFnMap["domain_choice.exact_value"], err = vrhDomainChoiceExactValue(rulesDomainChoiceExactValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field DomainType.domain_choice_exact_value: %s", err)
		panic(errMsg)
	}
	vrhDomainChoiceSuffixValue := v.DomainChoiceSuffixValueValidationRuleHandler
	rulesDomainChoiceSuffixValue := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
		"ves.io.schema.rules.string.max_len":  "256",
		"ves.io.schema.rules.string.min_len":  "1",
	}
	vFnMap["domain_choice.suffix_value"], err = vrhDomainChoiceSuffixValue(rulesDomainChoiceSuffixValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field DomainType.domain_choice_suffix_value: %s", err)
		panic(errMsg)
	}
	vrhDomainChoiceRegexValue := v.DomainChoiceRegexValueValidationRuleHandler
	rulesDomainChoiceRegexValue := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.min_len": "1",
		"ves.io.schema.rules.string.regex":   "true",
	}
	vFnMap["domain_choice.regex_value"], err = vrhDomainChoiceRegexValue(rulesDomainChoiceRegexValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field DomainType.domain_choice_regex_value: %s", err)
		panic(errMsg)
	}

	v.FldValidators["domain_choice.exact_value"] = vFnMap["domain_choice.exact_value"]
	v.FldValidators["domain_choice.suffix_value"] = vFnMap["domain_choice.suffix_value"]
	v.FldValidators["domain_choice.regex_value"] = vFnMap["domain_choice.regex_value"]

	return v
}()

func DomainTypeValidator() db.Validator {
	return DefaultDomainTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *Empty) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Empty) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Empty) DeepCopy() *Empty {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Empty{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Empty) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Empty) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EmptyValidator().Validate(ctx, m, opts...)
}

type ValidateEmpty struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEmpty) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Empty)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Empty got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEmptyValidator = func() *ValidateEmpty {
	v := &ValidateEmpty{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func EmptyValidator() db.Validator {
	return DefaultEmptyValidator
}

// augmented methods on protoc/std generated struct

func (m *File) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *File) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *File) DeepCopy() *File {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &File{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *File) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *File) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FileValidator().Validate(ctx, m, opts...)
}

type ValidateFile struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFile) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*File)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *File got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["content"]; exists {

		vOpts := append(opts, db.WithValidateField("content"))
		if err := fv(ctx, m.GetContent(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["content_type"]; exists {

		vOpts := append(opts, db.WithValidateField("content_type"))
		if err := fv(ctx, m.GetContentType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["file_id"]; exists {

		vOpts := append(opts, db.WithValidateField("file_id"))
		if err := fv(ctx, m.GetFileId(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetStorageProvider().(type) {
	case *File_AwsS3:
		if fv, exists := v.FldValidators["storage_provider.aws_s3"]; exists {
			val := m.GetStorageProvider().(*File_AwsS3).AwsS3
			vOpts := append(opts,
				db.WithValidateField("storage_provider"),
				db.WithValidateField("aws_s3"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFileValidator = func() *ValidateFile {
	v := &ValidateFile{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FileValidator() db.Validator {
	return DefaultFileValidator
}

// augmented methods on protoc/std generated struct

func (m *ForwardProxyConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ForwardProxyConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ForwardProxyConfigType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetTlsIntercept().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ForwardProxyConfigType.tls_intercept")
	}

	return nil
}

func (m *ForwardProxyConfigType) DeepCopy() *ForwardProxyConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ForwardProxyConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ForwardProxyConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ForwardProxyConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ForwardProxyConfigTypeValidator().Validate(ctx, m, opts...)
}

type ValidateForwardProxyConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateForwardProxyConfigType) WhiteListedPrefixesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for white_listed_prefixes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for white_listed_prefixes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated white_listed_prefixes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items white_listed_prefixes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateForwardProxyConfigType) WhiteListedPortsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepUint32ItemRules(rules)
	itemValFn, err := db.NewUint32ValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for white_listed_ports")
	}
	itemsValidatorFn := func(ctx context.Context, elems []uint32, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for white_listed_ports")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]uint32)
		if !ok {
			return fmt.Errorf("Repeated validation expected []uint32, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated white_listed_ports")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items white_listed_ports")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateForwardProxyConfigType) MaxConnectAttemptsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_connect_attempts")
	}

	return validatorFn, nil
}

func (v *ValidateForwardProxyConfigType) ConnectionTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for connection_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateForwardProxyConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ForwardProxyConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ForwardProxyConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["connection_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("connection_timeout"))
		if err := fv(ctx, m.GetConnectionTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_connect_attempts"]; exists {

		vOpts := append(opts, db.WithValidateField("max_connect_attempts"))
		if err := fv(ctx, m.GetMaxConnectAttempts(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetTlsInterceptionChoice().(type) {
	case *ForwardProxyConfigType_NoInterception:
		if fv, exists := v.FldValidators["tls_interception_choice.no_interception"]; exists {
			val := m.GetTlsInterceptionChoice().(*ForwardProxyConfigType_NoInterception).NoInterception
			vOpts := append(opts,
				db.WithValidateField("tls_interception_choice"),
				db.WithValidateField("no_interception"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ForwardProxyConfigType_TlsIntercept:
		if fv, exists := v.FldValidators["tls_interception_choice.tls_intercept"]; exists {
			val := m.GetTlsInterceptionChoice().(*ForwardProxyConfigType_TlsIntercept).TlsIntercept
			vOpts := append(opts,
				db.WithValidateField("tls_interception_choice"),
				db.WithValidateField("tls_intercept"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["white_listed_ports"]; exists {
		vOpts := append(opts, db.WithValidateField("white_listed_ports"))
		if err := fv(ctx, m.GetWhiteListedPorts(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["white_listed_prefixes"]; exists {
		vOpts := append(opts, db.WithValidateField("white_listed_prefixes"))
		if err := fv(ctx, m.GetWhiteListedPrefixes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultForwardProxyConfigTypeValidator = func() *ValidateForwardProxyConfigType {
	v := &ValidateForwardProxyConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhWhiteListedPrefixes := v.WhiteListedPrefixesValidationRuleHandler
	rulesWhiteListedPrefixes := map[string]string{
		"ves.io.schema.rules.repeated.items.string.ipv4_prefix": "true",
		"ves.io.schema.rules.repeated.max_items":                "64",
		"ves.io.schema.rules.repeated.unique":                   "true",
	}
	vFn, err = vrhWhiteListedPrefixes(rulesWhiteListedPrefixes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ForwardProxyConfigType.white_listed_prefixes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["white_listed_prefixes"] = vFn

	vrhWhiteListedPorts := v.WhiteListedPortsValidationRuleHandler
	rulesWhiteListedPorts := map[string]string{
		"ves.io.schema.rules.repeated.items.uint32.lte": "65535",
		"ves.io.schema.rules.repeated.max_items":        "64",
	}
	vFn, err = vrhWhiteListedPorts(rulesWhiteListedPorts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ForwardProxyConfigType.white_listed_ports: %s", err)
		panic(errMsg)
	}
	v.FldValidators["white_listed_ports"] = vFn

	vrhMaxConnectAttempts := v.MaxConnectAttemptsValidationRuleHandler
	rulesMaxConnectAttempts := map[string]string{
		"ves.io.schema.rules.uint32.lte": "8",
	}
	vFn, err = vrhMaxConnectAttempts(rulesMaxConnectAttempts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ForwardProxyConfigType.max_connect_attempts: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_connect_attempts"] = vFn

	vrhConnectionTimeout := v.ConnectionTimeoutValidationRuleHandler
	rulesConnectionTimeout := map[string]string{
		"ves.io.schema.rules.uint32.lte": "600000",
	}
	vFn, err = vrhConnectionTimeout(rulesConnectionTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ForwardProxyConfigType.connection_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connection_timeout"] = vFn

	v.FldValidators["tls_interception_choice.tls_intercept"] = TlsInterceptionTypeValidator().Validate

	return v
}()

func ForwardProxyConfigTypeValidator() db.Validator {
	return DefaultForwardProxyConfigTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *FractionalPercent) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FractionalPercent) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FractionalPercent) DeepCopy() *FractionalPercent {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FractionalPercent{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FractionalPercent) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FractionalPercent) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FractionalPercentValidator().Validate(ctx, m, opts...)
}

type ValidateFractionalPercent struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFractionalPercent) NumeratorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for numerator")
	}

	return validatorFn, nil
}

func (v *ValidateFractionalPercent) DenominatorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(DenominatorType)
		return int32(i)
	}
	// DenominatorType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, DenominatorType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for denominator")
	}

	return validatorFn, nil
}

func (v *ValidateFractionalPercent) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FractionalPercent)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FractionalPercent got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["denominator"]; exists {

		vOpts := append(opts, db.WithValidateField("denominator"))
		if err := fv(ctx, m.GetDenominator(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["numerator"]; exists {

		vOpts := append(opts, db.WithValidateField("numerator"))
		if err := fv(ctx, m.GetNumerator(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFractionalPercentValidator = func() *ValidateFractionalPercent {
	v := &ValidateFractionalPercent{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNumerator := v.NumeratorValidationRuleHandler
	rulesNumerator := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNumerator(rulesNumerator)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FractionalPercent.numerator: %s", err)
		panic(errMsg)
	}
	v.FldValidators["numerator"] = vFn

	vrhDenominator := v.DenominatorValidationRuleHandler
	rulesDenominator := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDenominator(rulesDenominator)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FractionalPercent.denominator: %s", err)
		panic(errMsg)
	}
	v.FldValidators["denominator"] = vFn

	return v
}()

func FractionalPercentValidator() db.Validator {
	return DefaultFractionalPercentValidator
}

// augmented methods on protoc/std generated struct

func (m *HashAlgorithms) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HashAlgorithms) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HashAlgorithms) DeepCopy() *HashAlgorithms {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HashAlgorithms{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HashAlgorithms) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HashAlgorithms) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HashAlgorithmsValidator().Validate(ctx, m, opts...)
}

type ValidateHashAlgorithms struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHashAlgorithms) HashAlgorithmsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(HashAlgorithm)
		return int32(i)
	}
	// HashAlgorithm_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, HashAlgorithm_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for hash_algorithms")
	}
	itemsValidatorFn := func(ctx context.Context, elems []HashAlgorithm, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for hash_algorithms")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]HashAlgorithm)
		if !ok {
			return fmt.Errorf("Repeated validation expected []HashAlgorithm, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated hash_algorithms")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items hash_algorithms")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateHashAlgorithms) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HashAlgorithms)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HashAlgorithms got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["hash_algorithms"]; exists {
		vOpts := append(opts, db.WithValidateField("hash_algorithms"))
		if err := fv(ctx, m.GetHashAlgorithms(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHashAlgorithmsValidator = func() *ValidateHashAlgorithms {
	v := &ValidateHashAlgorithms{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHashAlgorithms := v.HashAlgorithmsValidationRuleHandler
	rulesHashAlgorithms := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "4",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhHashAlgorithms(rulesHashAlgorithms)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HashAlgorithms.hash_algorithms: %s", err)
		panic(errMsg)
	}
	v.FldValidators["hash_algorithms"] = vFn

	return v
}()

func HashAlgorithmsValidator() db.Validator {
	return DefaultHashAlgorithmsValidator
}

// augmented methods on protoc/std generated struct

func (m *HeaderManipulationOptionType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HeaderManipulationOptionType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *HeaderManipulationOptionType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetSecretValue().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting HeaderManipulationOptionType.secret_value")
	}

	return nil
}

func (m *HeaderManipulationOptionType) DeepCopy() *HeaderManipulationOptionType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HeaderManipulationOptionType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HeaderManipulationOptionType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HeaderManipulationOptionType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HeaderManipulationOptionTypeValidator().Validate(ctx, m, opts...)
}

type ValidateHeaderManipulationOptionType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHeaderManipulationOptionType) ValueChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for value_choice")
	}
	return validatorFn, nil
}

func (v *ValidateHeaderManipulationOptionType) ValueChoiceValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Value, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for value")
	}
	return oValidatorFn_Value, nil
}

func (v *ValidateHeaderManipulationOptionType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateHeaderManipulationOptionType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HeaderManipulationOptionType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HeaderManipulationOptionType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["append"]; exists {

		vOpts := append(opts, db.WithValidateField("append"))
		if err := fv(ctx, m.GetAppend(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value_choice"]; exists {
		val := m.GetValueChoice()
		vOpts := append(opts,
			db.WithValidateField("value_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetValueChoice().(type) {
	case *HeaderManipulationOptionType_Value:
		if fv, exists := v.FldValidators["value_choice.value"]; exists {
			val := m.GetValueChoice().(*HeaderManipulationOptionType_Value).Value
			vOpts := append(opts,
				db.WithValidateField("value_choice"),
				db.WithValidateField("value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HeaderManipulationOptionType_SecretValue:
		if fv, exists := v.FldValidators["value_choice.secret_value"]; exists {
			val := m.GetValueChoice().(*HeaderManipulationOptionType_SecretValue).SecretValue
			vOpts := append(opts,
				db.WithValidateField("value_choice"),
				db.WithValidateField("secret_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHeaderManipulationOptionTypeValidator = func() *ValidateHeaderManipulationOptionType {
	v := &ValidateHeaderManipulationOptionType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhValueChoice := v.ValueChoiceValidationRuleHandler
	rulesValueChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhValueChoice(rulesValueChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderManipulationOptionType.value_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["value_choice"] = vFn

	vrhValueChoiceValue := v.ValueChoiceValueValidationRuleHandler
	rulesValueChoiceValue := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFnMap["value_choice.value"], err = vrhValueChoiceValue(rulesValueChoiceValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field HeaderManipulationOptionType.value_choice_value: %s", err)
		panic(errMsg)
	}

	v.FldValidators["value_choice.value"] = vFnMap["value_choice.value"]

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderManipulationOptionType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	v.FldValidators["value_choice.secret_value"] = SecretTypeValidator().Validate

	return v
}()

func HeaderManipulationOptionTypeValidator() db.Validator {
	return DefaultHeaderManipulationOptionTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *HeaderMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HeaderMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HeaderMatcherType) DeepCopy() *HeaderMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HeaderMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HeaderMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HeaderMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HeaderMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateHeaderMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHeaderMatcherType) ValueMatchExactValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Exact, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for exact")
	}
	return oValidatorFn_Exact, nil
}
func (v *ValidateHeaderMatcherType) ValueMatchRegexValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Regex, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for regex")
	}
	return oValidatorFn_Regex, nil
}

func (v *ValidateHeaderMatcherType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateHeaderMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HeaderMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HeaderMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invert_match"]; exists {

		vOpts := append(opts, db.WithValidateField("invert_match"))
		if err := fv(ctx, m.GetInvertMatch(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetValueMatch().(type) {
	case *HeaderMatcherType_Exact:
		if fv, exists := v.FldValidators["value_match.exact"]; exists {
			val := m.GetValueMatch().(*HeaderMatcherType_Exact).Exact
			vOpts := append(opts,
				db.WithValidateField("value_match"),
				db.WithValidateField("exact"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HeaderMatcherType_Regex:
		if fv, exists := v.FldValidators["value_match.regex"]; exists {
			val := m.GetValueMatch().(*HeaderMatcherType_Regex).Regex
			vOpts := append(opts,
				db.WithValidateField("value_match"),
				db.WithValidateField("regex"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HeaderMatcherType_Presence:
		if fv, exists := v.FldValidators["value_match.presence"]; exists {
			val := m.GetValueMatch().(*HeaderMatcherType_Presence).Presence
			vOpts := append(opts,
				db.WithValidateField("value_match"),
				db.WithValidateField("presence"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHeaderMatcherTypeValidator = func() *ValidateHeaderMatcherType {
	v := &ValidateHeaderMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhValueMatchExact := v.ValueMatchExactValidationRuleHandler
	rulesValueMatchExact := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "256",
		"ves.io.schema.rules.string.not_empty": "true",
	}
	vFnMap["value_match.exact"], err = vrhValueMatchExact(rulesValueMatchExact)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field HeaderMatcherType.value_match_exact: %s", err)
		panic(errMsg)
	}
	vrhValueMatchRegex := v.ValueMatchRegexValidationRuleHandler
	rulesValueMatchRegex := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "256",
		"ves.io.schema.rules.string.not_empty": "true",
		"ves.io.schema.rules.string.regex":     "true",
	}
	vFnMap["value_match.regex"], err = vrhValueMatchRegex(rulesValueMatchRegex)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field HeaderMatcherType.value_match_regex: %s", err)
		panic(errMsg)
	}

	v.FldValidators["value_match.exact"] = vFnMap["value_match.exact"]
	v.FldValidators["value_match.regex"] = vFnMap["value_match.regex"]

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required":         "true",
		"ves.io.schema.rules.string.http_header_field": "true",
		"ves.io.schema.rules.string.max_bytes":         "256",
		"ves.io.schema.rules.string.min_bytes":         "1",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderMatcherType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func HeaderMatcherTypeValidator() db.Validator {
	return DefaultHeaderMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *HeaderTransformationType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HeaderTransformationType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HeaderTransformationType) DeepCopy() *HeaderTransformationType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HeaderTransformationType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HeaderTransformationType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HeaderTransformationType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HeaderTransformationTypeValidator().Validate(ctx, m, opts...)
}

type ValidateHeaderTransformationType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHeaderTransformationType) HeaderTransformationChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for header_transformation_choice")
	}
	return validatorFn, nil
}

func (v *ValidateHeaderTransformationType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HeaderTransformationType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HeaderTransformationType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["header_transformation_choice"]; exists {
		val := m.GetHeaderTransformationChoice()
		vOpts := append(opts,
			db.WithValidateField("header_transformation_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetHeaderTransformationChoice().(type) {
	case *HeaderTransformationType_DefaultHeaderTransformation:
		if fv, exists := v.FldValidators["header_transformation_choice.default_header_transformation"]; exists {
			val := m.GetHeaderTransformationChoice().(*HeaderTransformationType_DefaultHeaderTransformation).DefaultHeaderTransformation
			vOpts := append(opts,
				db.WithValidateField("header_transformation_choice"),
				db.WithValidateField("default_header_transformation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HeaderTransformationType_ProperCaseHeaderTransformation:
		if fv, exists := v.FldValidators["header_transformation_choice.proper_case_header_transformation"]; exists {
			val := m.GetHeaderTransformationChoice().(*HeaderTransformationType_ProperCaseHeaderTransformation).ProperCaseHeaderTransformation
			vOpts := append(opts,
				db.WithValidateField("header_transformation_choice"),
				db.WithValidateField("proper_case_header_transformation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HeaderTransformationType_PreserveCaseHeaderTransformation:
		if fv, exists := v.FldValidators["header_transformation_choice.preserve_case_header_transformation"]; exists {
			val := m.GetHeaderTransformationChoice().(*HeaderTransformationType_PreserveCaseHeaderTransformation).PreserveCaseHeaderTransformation
			vOpts := append(opts,
				db.WithValidateField("header_transformation_choice"),
				db.WithValidateField("preserve_case_header_transformation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HeaderTransformationType_LegacyHeaderTransformation:
		if fv, exists := v.FldValidators["header_transformation_choice.legacy_header_transformation"]; exists {
			val := m.GetHeaderTransformationChoice().(*HeaderTransformationType_LegacyHeaderTransformation).LegacyHeaderTransformation
			vOpts := append(opts,
				db.WithValidateField("header_transformation_choice"),
				db.WithValidateField("legacy_header_transformation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHeaderTransformationTypeValidator = func() *ValidateHeaderTransformationType {
	v := &ValidateHeaderTransformationType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHeaderTransformationChoice := v.HeaderTransformationChoiceValidationRuleHandler
	rulesHeaderTransformationChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhHeaderTransformationChoice(rulesHeaderTransformationChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderTransformationType.header_transformation_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["header_transformation_choice"] = vFn

	return v
}()

func HeaderTransformationTypeValidator() db.Validator {
	return DefaultHeaderTransformationTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *HostIdentifier) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HostIdentifier) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HostIdentifier) DeepCopy() *HostIdentifier {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HostIdentifier{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HostIdentifier) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HostIdentifier) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HostIdentifierValidator().Validate(ctx, m, opts...)
}

type ValidateHostIdentifier struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHostIdentifier) HostnameOrIpIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Ip, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip")
	}
	return oValidatorFn_Ip, nil
}
func (v *ValidateHostIdentifier) HostnameOrIpHostnameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Hostname, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for hostname")
	}
	return oValidatorFn_Hostname, nil
}

func (v *ValidateHostIdentifier) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HostIdentifier)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HostIdentifier got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetHostnameOrIp().(type) {
	case *HostIdentifier_Ip:
		if fv, exists := v.FldValidators["hostname_or_ip.ip"]; exists {
			val := m.GetHostnameOrIp().(*HostIdentifier_Ip).Ip
			vOpts := append(opts,
				db.WithValidateField("hostname_or_ip"),
				db.WithValidateField("ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HostIdentifier_Hostname:
		if fv, exists := v.FldValidators["hostname_or_ip.hostname"]; exists {
			val := m.GetHostnameOrIp().(*HostIdentifier_Hostname).Hostname
			vOpts := append(opts,
				db.WithValidateField("hostname_or_ip"),
				db.WithValidateField("hostname"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHostIdentifierValidator = func() *ValidateHostIdentifier {
	v := &ValidateHostIdentifier{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHostnameOrIpIp := v.HostnameOrIpIpValidationRuleHandler
	rulesHostnameOrIpIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFnMap["hostname_or_ip.ip"], err = vrhHostnameOrIpIp(rulesHostnameOrIpIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field HostIdentifier.hostname_or_ip_ip: %s", err)
		panic(errMsg)
	}
	vrhHostnameOrIpHostname := v.HostnameOrIpHostnameValidationRuleHandler
	rulesHostnameOrIpHostname := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
		"ves.io.schema.rules.string.max_len":  "256",
	}
	vFnMap["hostname_or_ip.hostname"], err = vrhHostnameOrIpHostname(rulesHostnameOrIpHostname)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field HostIdentifier.hostname_or_ip_hostname: %s", err)
		panic(errMsg)
	}

	v.FldValidators["hostname_or_ip.ip"] = vFnMap["hostname_or_ip.ip"]
	v.FldValidators["hostname_or_ip.hostname"] = vFnMap["hostname_or_ip.hostname"]

	return v
}()

func HostIdentifierValidator() db.Validator {
	return DefaultHostIdentifierValidator
}

// augmented methods on protoc/std generated struct

func (m *InitializerType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *InitializerType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *InitializerType) DeepCopy() *InitializerType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &InitializerType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *InitializerType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *InitializerType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return InitializerTypeValidator().Validate(ctx, m, opts...)
}

type ValidateInitializerType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInitializerType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*InitializerType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *InitializerType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInitializerTypeValidator = func() *ValidateInitializerType {
	v := &ValidateInitializerType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func InitializerTypeValidator() db.Validator {
	return DefaultInitializerTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *InitializersType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *InitializersType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *InitializersType) DeepCopy() *InitializersType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &InitializersType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *InitializersType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *InitializersType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return InitializersTypeValidator().Validate(ctx, m, opts...)
}

type ValidateInitializersType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInitializersType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*InitializersType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *InitializersType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["pending"]; exists {

		vOpts := append(opts, db.WithValidateField("pending"))
		for idx, item := range m.GetPending() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["result"]; exists {

		vOpts := append(opts, db.WithValidateField("result"))
		if err := fv(ctx, m.GetResult(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInitializersTypeValidator = func() *ValidateInitializersType {
	v := &ValidateInitializersType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func InitializersTypeValidator() db.Validator {
	return DefaultInitializersTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *InterfaceIdentifier) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *InterfaceIdentifier) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *InterfaceIdentifier) DeepCopy() *InterfaceIdentifier {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &InterfaceIdentifier{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *InterfaceIdentifier) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *InterfaceIdentifier) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return InterfaceIdentifierValidator().Validate(ctx, m, opts...)
}

type ValidateInterfaceIdentifier struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInterfaceIdentifier) InterfaceChoiceIntfValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Intf, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for intf")
	}
	return oValidatorFn_Intf, nil
}

func (v *ValidateInterfaceIdentifier) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*InterfaceIdentifier)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *InterfaceIdentifier got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetInterfaceChoice().(type) {
	case *InterfaceIdentifier_AnyIntf:
		if fv, exists := v.FldValidators["interface_choice.any_intf"]; exists {
			val := m.GetInterfaceChoice().(*InterfaceIdentifier_AnyIntf).AnyIntf
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("any_intf"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *InterfaceIdentifier_Intf:
		if fv, exists := v.FldValidators["interface_choice.intf"]; exists {
			val := m.GetInterfaceChoice().(*InterfaceIdentifier_Intf).Intf
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("intf"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInterfaceIdentifierValidator = func() *ValidateInterfaceIdentifier {
	v := &ValidateInterfaceIdentifier{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInterfaceChoiceIntf := v.InterfaceChoiceIntfValidationRuleHandler
	rulesInterfaceChoiceIntf := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFnMap["interface_choice.intf"], err = vrhInterfaceChoiceIntf(rulesInterfaceChoiceIntf)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field InterfaceIdentifier.interface_choice_intf: %s", err)
		panic(errMsg)
	}

	v.FldValidators["interface_choice.intf"] = vFnMap["interface_choice.intf"]

	return v
}()

func InterfaceIdentifierValidator() db.Validator {
	return DefaultInterfaceIdentifierValidator
}

// augmented methods on protoc/std generated struct

func (m *InterfaceOrNetwork) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *InterfaceOrNetwork) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *InterfaceOrNetwork) DeepCopy() *InterfaceOrNetwork {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &InterfaceOrNetwork{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *InterfaceOrNetwork) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *InterfaceOrNetwork) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return InterfaceOrNetworkValidator().Validate(ctx, m, opts...)
}

type ValidateInterfaceOrNetwork struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInterfaceOrNetwork) InterfaceChoiceIntfValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Intf, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for intf")
	}
	return oValidatorFn_Intf, nil
}
func (v *ValidateInterfaceOrNetwork) InterfaceChoicePodValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Pod, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for pod")
	}
	return oValidatorFn_Pod, nil
}
func (v *ValidateInterfaceOrNetwork) InterfaceChoiceVnValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Vn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vn")
	}
	return oValidatorFn_Vn, nil
}

func (v *ValidateInterfaceOrNetwork) InterfaceChoiceVnTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	conv_VnType := func(v interface{}) int32 {
		i := v.(VirtualNetworkType)
		return int32(i)
	}
	// VirtualNetworkType_name is generated in .pb.go
	oValidatorFn_VnType, err := db.NewEnumValidationRuleHandler(rules, VirtualNetworkType_name, conv_VnType)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for oneof sub-field vn_type")
	}
	return oValidatorFn_VnType, nil
}

func (v *ValidateInterfaceOrNetwork) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*InterfaceOrNetwork)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *InterfaceOrNetwork got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetInterfaceChoice().(type) {
	case *InterfaceOrNetwork_Intf:
		if fv, exists := v.FldValidators["interface_choice.intf"]; exists {
			val := m.GetInterfaceChoice().(*InterfaceOrNetwork_Intf).Intf
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("intf"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *InterfaceOrNetwork_Pod:
		if fv, exists := v.FldValidators["interface_choice.pod"]; exists {
			val := m.GetInterfaceChoice().(*InterfaceOrNetwork_Pod).Pod
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("pod"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *InterfaceOrNetwork_VnType:
		if fv, exists := v.FldValidators["interface_choice.vn_type"]; exists {
			val := m.GetInterfaceChoice().(*InterfaceOrNetwork_VnType).VnType
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("vn_type"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *InterfaceOrNetwork_Vn:
		if fv, exists := v.FldValidators["interface_choice.vn"]; exists {
			val := m.GetInterfaceChoice().(*InterfaceOrNetwork_Vn).Vn
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("vn"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInterfaceOrNetworkValidator = func() *ValidateInterfaceOrNetwork {
	v := &ValidateInterfaceOrNetwork{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInterfaceChoiceIntf := v.InterfaceChoiceIntfValidationRuleHandler
	rulesInterfaceChoiceIntf := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFnMap["interface_choice.intf"], err = vrhInterfaceChoiceIntf(rulesInterfaceChoiceIntf)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field InterfaceOrNetwork.interface_choice_intf: %s", err)
		panic(errMsg)
	}
	vrhInterfaceChoicePod := v.InterfaceChoicePodValidationRuleHandler
	rulesInterfaceChoicePod := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFnMap["interface_choice.pod"], err = vrhInterfaceChoicePod(rulesInterfaceChoicePod)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field InterfaceOrNetwork.interface_choice_pod: %s", err)
		panic(errMsg)
	}
	vrhInterfaceChoiceVnType := v.InterfaceChoiceVnTypeValidationRuleHandler
	rulesInterfaceChoiceVnType := map[string]string{
		"ves.io.schema.rules.enum.in": "[0,1,3]",
	}
	vFnMap["interface_choice.vn_type"], err = vrhInterfaceChoiceVnType(rulesInterfaceChoiceVnType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field InterfaceOrNetwork.interface_choice_vn_type: %s", err)
		panic(errMsg)
	}
	vrhInterfaceChoiceVn := v.InterfaceChoiceVnValidationRuleHandler
	rulesInterfaceChoiceVn := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFnMap["interface_choice.vn"], err = vrhInterfaceChoiceVn(rulesInterfaceChoiceVn)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field InterfaceOrNetwork.interface_choice_vn: %s", err)
		panic(errMsg)
	}

	v.FldValidators["interface_choice.intf"] = vFnMap["interface_choice.intf"]
	v.FldValidators["interface_choice.pod"] = vFnMap["interface_choice.pod"]
	v.FldValidators["interface_choice.vn_type"] = vFnMap["interface_choice.vn_type"]
	v.FldValidators["interface_choice.vn"] = vFnMap["interface_choice.vn"]

	return v
}()

func InterfaceOrNetworkValidator() db.Validator {
	return DefaultInterfaceOrNetworkValidator
}

// augmented methods on protoc/std generated struct

func (m *IpPrefixSetRefType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IpPrefixSetRefType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IpPrefixSetRefType) DeepCopy() *IpPrefixSetRefType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IpPrefixSetRefType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IpPrefixSetRefType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IpPrefixSetRefType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IpPrefixSetRefTypeValidator().Validate(ctx, m, opts...)
}

func (m *IpPrefixSetRefType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetRefDRefInfo()

}

func (m *IpPrefixSetRefType) GetRefDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRef()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("IpPrefixSetRefType.ref[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "ip_prefix_set.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "ref",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRefDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *IpPrefixSetRefType) GetRefDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "ip_prefix_set.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: ip_prefix_set")
	}
	for _, ref := range m.GetRef() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateIpPrefixSetRefType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIpPrefixSetRefType) RefValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for ref")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ref")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ref")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ref")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateIpPrefixSetRefType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IpPrefixSetRefType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IpPrefixSetRefType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ref"]; exists {
		vOpts := append(opts, db.WithValidateField("ref"))
		if err := fv(ctx, m.GetRef(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIpPrefixSetRefTypeValidator = func() *ValidateIpPrefixSetRefType {
	v := &ValidateIpPrefixSetRefType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRef := v.RefValidationRuleHandler
	rulesRef := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhRef(rulesRef)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IpPrefixSetRefType.ref: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ref"] = vFn

	return v
}()

func IpPrefixSetRefTypeValidator() db.Validator {
	return DefaultIpPrefixSetRefTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *KubeRefType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *KubeRefType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *KubeRefType) DeepCopy() *KubeRefType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &KubeRefType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *KubeRefType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *KubeRefType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return KubeRefTypeValidator().Validate(ctx, m, opts...)
}

type ValidateKubeRefType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateKubeRefType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*KubeRefType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *KubeRefType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["kind"]; exists {

		vOpts := append(opts, db.WithValidateField("kind"))
		if err := fv(ctx, m.GetKind(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultKubeRefTypeValidator = func() *ValidateKubeRefType {
	v := &ValidateKubeRefType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func KubeRefTypeValidator() db.Validator {
	return DefaultKubeRefTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *L4DestType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *L4DestType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *L4DestType) DeepCopy() *L4DestType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &L4DestType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *L4DestType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *L4DestType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return L4DestTypeValidator().Validate(ctx, m, opts...)
}

type ValidateL4DestType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateL4DestType) PrefixesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for prefixes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for prefixes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated prefixes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items prefixes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateL4DestType) PortRangesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port_ranges")
	}

	return validatorFn, nil
}

func (v *ValidateL4DestType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*L4DestType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *L4DestType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["port_ranges"]; exists {

		vOpts := append(opts, db.WithValidateField("port_ranges"))
		if err := fv(ctx, m.GetPortRanges(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["prefixes"]; exists {
		vOpts := append(opts, db.WithValidateField("prefixes"))
		if err := fv(ctx, m.GetPrefixes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultL4DestTypeValidator = func() *ValidateL4DestType {
	v := &ValidateL4DestType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPrefixes := v.PrefixesValidationRuleHandler
	rulesPrefixes := map[string]string{
		"ves.io.schema.rules.message.required":                  "true",
		"ves.io.schema.rules.repeated.items.string.ipv4_prefix": "true",
		"ves.io.schema.rules.repeated.max_items":                "32",
		"ves.io.schema.rules.repeated.min_items":                "1",
		"ves.io.schema.rules.repeated.unique":                   "true",
	}
	vFn, err = vrhPrefixes(rulesPrefixes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for L4DestType.prefixes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["prefixes"] = vFn

	vrhPortRanges := v.PortRangesValidationRuleHandler
	rulesPortRanges := map[string]string{
		"ves.io.schema.rules.message.required":       "true",
		"ves.io.schema.rules.string.max_len":         "512",
		"ves.io.schema.rules.string.min_len":         "1",
		"ves.io.schema.rules.string.port_range_list": "true",
	}
	vFn, err = vrhPortRanges(rulesPortRanges)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for L4DestType.port_ranges: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port_ranges"] = vFn

	return v
}()

func L4DestTypeValidator() db.Validator {
	return DefaultL4DestTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *LabelMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LabelMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LabelMatcherType) DeepCopy() *LabelMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LabelMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LabelMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LabelMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LabelMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateLabelMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLabelMatcherType) KeysValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for keys")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for keys")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated keys")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items keys")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateLabelMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LabelMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LabelMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["keys"]; exists {
		vOpts := append(opts, db.WithValidateField("keys"))
		if err := fv(ctx, m.GetKeys(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLabelMatcherTypeValidator = func() *ValidateLabelMatcherType {
	v := &ValidateLabelMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhKeys := v.KeysValidationRuleHandler
	rulesKeys := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_len": "64",
		"ves.io.schema.rules.repeated.items.string.min_len": "1",
		"ves.io.schema.rules.repeated.max_items":            "16",
		"ves.io.schema.rules.repeated.unique":               "true",
	}
	vFn, err = vrhKeys(rulesKeys)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LabelMatcherType.keys: %s", err)
		panic(errMsg)
	}
	v.FldValidators["keys"] = vFn

	return v
}()

func LabelMatcherTypeValidator() db.Validator {
	return DefaultLabelMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *LabelSelectorType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LabelSelectorType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LabelSelectorType) DeepCopy() *LabelSelectorType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LabelSelectorType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LabelSelectorType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LabelSelectorType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LabelSelectorTypeValidator().Validate(ctx, m, opts...)
}

type ValidateLabelSelectorType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLabelSelectorType) ExpressionsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for expressions")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for expressions")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated expressions")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items expressions")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateLabelSelectorType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LabelSelectorType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LabelSelectorType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["expressions"]; exists {
		vOpts := append(opts, db.WithValidateField("expressions"))
		if err := fv(ctx, m.GetExpressions(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLabelSelectorTypeValidator = func() *ValidateLabelSelectorType {
	v := &ValidateLabelSelectorType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhExpressions := v.ExpressionsValidationRuleHandler
	rulesExpressions := map[string]string{
		"ves.io.schema.rules.message.required":                         "true",
		"ves.io.schema.rules.repeated.items.string.k8s_label_selector": "true",
		"ves.io.schema.rules.repeated.items.string.max_len":            "4096",
		"ves.io.schema.rules.repeated.items.string.min_len":            "1",
		"ves.io.schema.rules.repeated.max_items":                       "1",
	}
	vFn, err = vrhExpressions(rulesExpressions)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LabelSelectorType.expressions: %s", err)
		panic(errMsg)
	}
	v.FldValidators["expressions"] = vFn

	return v
}()

func LabelSelectorTypeValidator() db.Validator {
	return DefaultLabelSelectorTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ListMetaType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListMetaType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListMetaType) DeepCopy() *ListMetaType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListMetaType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListMetaType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListMetaType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListMetaTypeValidator().Validate(ctx, m, opts...)
}

type ValidateListMetaType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListMetaType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListMetaType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListMetaType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["next_page"]; exists {

		vOpts := append(opts, db.WithValidateField("next_page"))
		if err := fv(ctx, m.GetNextPage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["resource_version"]; exists {

		vOpts := append(opts, db.WithValidateField("resource_version"))
		if err := fv(ctx, m.GetResourceVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListMetaTypeValidator = func() *ValidateListMetaType {
	v := &ValidateListMetaType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ListMetaTypeValidator() db.Validator {
	return DefaultListMetaTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *MessageMetaType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MessageMetaType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MessageMetaType) DeepCopy() *MessageMetaType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MessageMetaType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MessageMetaType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MessageMetaType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MessageMetaTypeValidator().Validate(ctx, m, opts...)
}

type ValidateMessageMetaType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMessageMetaType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateMessageMetaType) DescriptionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for description")
	}

	return validatorFn, nil
}

func (v *ValidateMessageMetaType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MessageMetaType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MessageMetaType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable"]; exists {

		vOpts := append(opts, db.WithValidateField("disable"))
		if err := fv(ctx, m.GetDisable(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMessageMetaTypeValidator = func() *ValidateMessageMetaType {
	v := &ValidateMessageMetaType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required":       "true",
		"ves.io.schema.rules.string.min_len":         "1",
		"ves.io.schema.rules.string.ves_object_name": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MessageMetaType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhDescription := v.DescriptionValidationRuleHandler
	rulesDescription := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhDescription(rulesDescription)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MessageMetaType.description: %s", err)
		panic(errMsg)
	}
	v.FldValidators["description"] = vFn

	return v
}()

func MessageMetaTypeValidator() db.Validator {
	return DefaultMessageMetaTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *MetricTypeData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MetricTypeData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MetricTypeData) DeepCopy() *MetricTypeData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MetricTypeData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MetricTypeData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MetricTypeData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MetricTypeDataValidator().Validate(ctx, m, opts...)
}

type ValidateMetricTypeData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMetricTypeData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MetricTypeData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MetricTypeData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["labels"]; exists {

		vOpts := append(opts, db.WithValidateField("labels"))
		for key, value := range m.GetLabels() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["values"]; exists {

		vOpts := append(opts, db.WithValidateField("values"))
		for idx, item := range m.GetValues() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMetricTypeDataValidator = func() *ValidateMetricTypeData {
	v := &ValidateMetricTypeData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func MetricTypeDataValidator() db.Validator {
	return DefaultMetricTypeDataValidator
}

// augmented methods on protoc/std generated struct

func (m *MetricValue) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MetricValue) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MetricValue) DeepCopy() *MetricValue {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MetricValue{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MetricValue) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MetricValue) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MetricValueValidator().Validate(ctx, m, opts...)
}

type ValidateMetricValue struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMetricValue) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MetricValue)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MetricValue got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("timestamp"))
		if err := fv(ctx, m.GetTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["trend_value"]; exists {

		vOpts := append(opts, db.WithValidateField("trend_value"))
		if err := fv(ctx, m.GetTrendValue(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMetricValueValidator = func() *ValidateMetricValue {
	v := &ValidateMetricValue{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func MetricValueValidator() db.Validator {
	return DefaultMetricValueValidator
}

// augmented methods on protoc/std generated struct

func (m *NamespaceAccessType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NamespaceAccessType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NamespaceAccessType) DeepCopy() *NamespaceAccessType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NamespaceAccessType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NamespaceAccessType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NamespaceAccessType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NamespaceAccessTypeValidator().Validate(ctx, m, opts...)
}

type ValidateNamespaceAccessType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNamespaceAccessType) NamespaceRoleMapValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for namespace_role_map")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]*RoleListType, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := RoleListTypeValidator().Validate(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for namespace_role_map")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]*RoleListType)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]*RoleListType, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map namespace_role_map")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items namespace_role_map")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateNamespaceAccessType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NamespaceAccessType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NamespaceAccessType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace_role_map"]; exists {
		vOpts := append(opts, db.WithValidateField("namespace_role_map"))
		if err := fv(ctx, m.GetNamespaceRoleMap(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNamespaceAccessTypeValidator = func() *ValidateNamespaceAccessType {
	v := &ValidateNamespaceAccessType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespaceRoleMap := v.NamespaceRoleMapValidationRuleHandler
	rulesNamespaceRoleMap := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len": "256",
		"ves.io.schema.rules.message.required":        "true",
	}
	vFn, err = vrhNamespaceRoleMap(rulesNamespaceRoleMap)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for NamespaceAccessType.namespace_role_map: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace_role_map"] = vFn

	return v
}()

func NamespaceAccessTypeValidator() db.Validator {
	return DefaultNamespaceAccessTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *NamespaceRoleType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NamespaceRoleType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NamespaceRoleType) DeepCopy() *NamespaceRoleType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NamespaceRoleType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NamespaceRoleType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NamespaceRoleType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NamespaceRoleTypeValidator().Validate(ctx, m, opts...)
}

type ValidateNamespaceRoleType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNamespaceRoleType) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateNamespaceRoleType) RoleValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for role")
	}

	return validatorFn, nil
}

func (v *ValidateNamespaceRoleType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NamespaceRoleType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NamespaceRoleType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["role"]; exists {

		vOpts := append(opts, db.WithValidateField("role"))
		if err := fv(ctx, m.GetRole(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNamespaceRoleTypeValidator = func() *ValidateNamespaceRoleType {
	v := &ValidateNamespaceRoleType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for NamespaceRoleType.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhRole := v.RoleValidationRuleHandler
	rulesRole := map[string]string{
		"ves.io.schema.rules.message.required":       "true",
		"ves.io.schema.rules.string.max_len":         "256",
		"ves.io.schema.rules.string.ves_object_name": "true",
	}
	vFn, err = vrhRole(rulesRole)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for NamespaceRoleType.role: %s", err)
		panic(errMsg)
	}
	v.FldValidators["role"] = vFn

	return v
}()

func NamespaceRoleTypeValidator() db.Validator {
	return DefaultNamespaceRoleTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *NetworkRefType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NetworkRefType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NetworkRefType) DeepCopy() *NetworkRefType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NetworkRefType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NetworkRefType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NetworkRefType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NetworkRefTypeValidator().Validate(ctx, m, opts...)
}

func (m *NetworkRefType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetRefDRefInfo()

}

func (m *NetworkRefType) GetRefDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRef()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("NetworkRefType.ref[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_network.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "ref",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRefDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *NetworkRefType) GetRefDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
	}
	for _, ref := range m.GetRef() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateNetworkRefType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNetworkRefType) RefValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for ref")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ref")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ref")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ref")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateNetworkRefType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NetworkRefType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NetworkRefType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ref"]; exists {
		vOpts := append(opts, db.WithValidateField("ref"))
		if err := fv(ctx, m.GetRef(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNetworkRefTypeValidator = func() *ValidateNetworkRefType {
	v := &ValidateNetworkRefType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRef := v.RefValidationRuleHandler
	rulesRef := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhRef(rulesRef)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for NetworkRefType.ref: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ref"] = vFn

	return v
}()

func NetworkRefTypeValidator() db.Validator {
	return DefaultNetworkRefTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *NetworkSiteRefSelector) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NetworkSiteRefSelector) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NetworkSiteRefSelector) DeepCopy() *NetworkSiteRefSelector {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NetworkSiteRefSelector{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NetworkSiteRefSelector) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NetworkSiteRefSelector) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NetworkSiteRefSelectorValidator().Validate(ctx, m, opts...)
}

func (m *NetworkSiteRefSelector) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetRefOrSelectorDRefInfo()

}

// GetDRefInfo for the field's type
func (m *NetworkSiteRefSelector) GetRefOrSelectorDRefInfo() ([]db.DRefInfo, error) {
	if m.GetRefOrSelector() == nil {
		return nil, nil
	}
	switch m.GetRefOrSelector().(type) {
	case *NetworkSiteRefSelector_VirtualNetwork:

		drInfos, err := m.GetVirtualNetwork().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetVirtualNetwork().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "virtual_network." + dri.DRField
		}
		return drInfos, err

	case *NetworkSiteRefSelector_Site:

		drInfos, err := m.GetSite().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSite().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "site." + dri.DRField
		}
		return drInfos, err

	case *NetworkSiteRefSelector_VirtualSite:

		drInfos, err := m.GetVirtualSite().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetVirtualSite().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "virtual_site." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateNetworkSiteRefSelector struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNetworkSiteRefSelector) RefOrSelectorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ref_or_selector")
	}
	return validatorFn, nil
}

func (v *ValidateNetworkSiteRefSelector) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NetworkSiteRefSelector)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NetworkSiteRefSelector got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ref_or_selector"]; exists {
		val := m.GetRefOrSelector()
		vOpts := append(opts,
			db.WithValidateField("ref_or_selector"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetRefOrSelector().(type) {
	case *NetworkSiteRefSelector_VirtualNetwork:
		if fv, exists := v.FldValidators["ref_or_selector.virtual_network"]; exists {
			val := m.GetRefOrSelector().(*NetworkSiteRefSelector_VirtualNetwork).VirtualNetwork
			vOpts := append(opts,
				db.WithValidateField("ref_or_selector"),
				db.WithValidateField("virtual_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *NetworkSiteRefSelector_Site:
		if fv, exists := v.FldValidators["ref_or_selector.site"]; exists {
			val := m.GetRefOrSelector().(*NetworkSiteRefSelector_Site).Site
			vOpts := append(opts,
				db.WithValidateField("ref_or_selector"),
				db.WithValidateField("site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *NetworkSiteRefSelector_VirtualSite:
		if fv, exists := v.FldValidators["ref_or_selector.virtual_site"]; exists {
			val := m.GetRefOrSelector().(*NetworkSiteRefSelector_VirtualSite).VirtualSite
			vOpts := append(opts,
				db.WithValidateField("ref_or_selector"),
				db.WithValidateField("virtual_site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNetworkSiteRefSelectorValidator = func() *ValidateNetworkSiteRefSelector {
	v := &ValidateNetworkSiteRefSelector{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRefOrSelector := v.RefOrSelectorValidationRuleHandler
	rulesRefOrSelector := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhRefOrSelector(rulesRefOrSelector)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for NetworkSiteRefSelector.ref_or_selector: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ref_or_selector"] = vFn

	v.FldValidators["ref_or_selector.virtual_network"] = NetworkRefTypeValidator().Validate
	v.FldValidators["ref_or_selector.site"] = SiteRefTypeValidator().Validate
	v.FldValidators["ref_or_selector.virtual_site"] = VSiteRefTypeValidator().Validate

	return v
}()

func NetworkSiteRefSelectorValidator() db.Validator {
	return DefaultNetworkSiteRefSelectorValidator
}

// augmented methods on protoc/std generated struct

func (m *NetworkingStackType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NetworkingStackType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NetworkingStackType) DeepCopy() *NetworkingStackType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NetworkingStackType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NetworkingStackType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NetworkingStackType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NetworkingStackTypeValidator().Validate(ctx, m, opts...)
}

type ValidateNetworkingStackType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNetworkingStackType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NetworkingStackType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NetworkingStackType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetChoice().(type) {
	case *NetworkingStackType_Ipv4:
		if fv, exists := v.FldValidators["choice.ipv4"]; exists {
			val := m.GetChoice().(*NetworkingStackType_Ipv4).Ipv4
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("ipv4"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *NetworkingStackType_Ipv6:
		if fv, exists := v.FldValidators["choice.ipv6"]; exists {
			val := m.GetChoice().(*NetworkingStackType_Ipv6).Ipv6
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("ipv6"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *NetworkingStackType_Dual:
		if fv, exists := v.FldValidators["choice.dual"]; exists {
			val := m.GetChoice().(*NetworkingStackType_Dual).Dual
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("dual"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNetworkingStackTypeValidator = func() *ValidateNetworkingStackType {
	v := &ValidateNetworkingStackType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func NetworkingStackTypeValidator() db.Validator {
	return DefaultNetworkingStackTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *NextHopType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NextHopType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NextHopType) DeepCopy() *NextHopType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NextHopType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NextHopType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NextHopType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NextHopTypeValidator().Validate(ctx, m, opts...)
}

func (m *NextHopType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetInterfaceDRefInfo()

}

func (m *NextHopType) GetInterfaceDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetInterface()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("NextHopType.interface[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "network_interface.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "interface",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetInterfaceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *NextHopType) GetInterfaceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "network_interface.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: network_interface")
	}
	for _, ref := range m.GetInterface() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateNextHopType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNextHopType) InterfaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for interface")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for interface")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated interface")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items interface")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateNextHopType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NextHopType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NextHopType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["interface"]; exists {
		vOpts := append(opts, db.WithValidateField("interface"))
		if err := fv(ctx, m.GetInterface(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["nexthop_address"]; exists {

		vOpts := append(opts, db.WithValidateField("nexthop_address"))
		if err := fv(ctx, m.GetNexthopAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNextHopTypeValidator = func() *ValidateNextHopType {
	v := &ValidateNextHopType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInterface := v.InterfaceValidationRuleHandler
	rulesInterface := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhInterface(rulesInterface)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for NextHopType.interface: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interface"] = vFn

	v.FldValidators["nexthop_address"] = IpAddressTypeValidator().Validate

	return v
}()

func NextHopTypeValidator() db.Validator {
	return DefaultNextHopTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ObjectCreateMetaType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ObjectCreateMetaType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ObjectCreateMetaType) DeepCopy() *ObjectCreateMetaType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ObjectCreateMetaType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ObjectCreateMetaType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ObjectCreateMetaType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ObjectCreateMetaTypeValidator().Validate(ctx, m, opts...)
}

type ValidateObjectCreateMetaType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateObjectCreateMetaType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateObjectCreateMetaType) AnnotationsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for annotations")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for annotations")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for annotations")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map annotations")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items annotations")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateObjectCreateMetaType) DescriptionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for description")
	}

	return validatorFn, nil
}

func (v *ValidateObjectCreateMetaType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ObjectCreateMetaType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ObjectCreateMetaType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["annotations"]; exists {
		vOpts := append(opts, db.WithValidateField("annotations"))
		if err := fv(ctx, m.GetAnnotations(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable"]; exists {

		vOpts := append(opts, db.WithValidateField("disable"))
		if err := fv(ctx, m.GetDisable(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["labels"]; exists {

		vOpts := append(opts, db.WithValidateField("labels"))
		for key, value := range m.GetLabels() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultObjectCreateMetaTypeValidator = func() *ValidateObjectCreateMetaType {
	v := &ValidateObjectCreateMetaType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ObjectCreateMetaType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhAnnotations := v.AnnotationsValidationRuleHandler
	rulesAnnotations := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len":   "64",
		"ves.io.schema.rules.map.keys.string.min_len":   "1",
		"ves.io.schema.rules.map.values.string.max_len": "1024",
		"ves.io.schema.rules.map.values.string.min_len": "1",
	}
	vFn, err = vrhAnnotations(rulesAnnotations)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ObjectCreateMetaType.annotations: %s", err)
		panic(errMsg)
	}
	v.FldValidators["annotations"] = vFn

	vrhDescription := v.DescriptionValidationRuleHandler
	rulesDescription := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "1200",
	}
	vFn, err = vrhDescription(rulesDescription)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ObjectCreateMetaType.description: %s", err)
		panic(errMsg)
	}
	v.FldValidators["description"] = vFn

	return v
}()

func ObjectCreateMetaTypeValidator() db.Validator {
	return DefaultObjectCreateMetaTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ObjectGetMetaType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ObjectGetMetaType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ObjectGetMetaType) DeepCopy() *ObjectGetMetaType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ObjectGetMetaType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ObjectGetMetaType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ObjectGetMetaType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ObjectGetMetaTypeValidator().Validate(ctx, m, opts...)
}

type ValidateObjectGetMetaType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateObjectGetMetaType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateObjectGetMetaType) AnnotationsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for annotations")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for annotations")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for annotations")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map annotations")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items annotations")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateObjectGetMetaType) DescriptionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for description")
	}

	return validatorFn, nil
}

func (v *ValidateObjectGetMetaType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ObjectGetMetaType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ObjectGetMetaType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["annotations"]; exists {
		vOpts := append(opts, db.WithValidateField("annotations"))
		if err := fv(ctx, m.GetAnnotations(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable"]; exists {

		vOpts := append(opts, db.WithValidateField("disable"))
		if err := fv(ctx, m.GetDisable(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["labels"]; exists {

		vOpts := append(opts, db.WithValidateField("labels"))
		for key, value := range m.GetLabels() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultObjectGetMetaTypeValidator = func() *ValidateObjectGetMetaType {
	v := &ValidateObjectGetMetaType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ObjectGetMetaType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhAnnotations := v.AnnotationsValidationRuleHandler
	rulesAnnotations := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len":   "64",
		"ves.io.schema.rules.map.keys.string.min_len":   "1",
		"ves.io.schema.rules.map.values.string.max_len": "1024",
		"ves.io.schema.rules.map.values.string.min_len": "1",
	}
	vFn, err = vrhAnnotations(rulesAnnotations)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ObjectGetMetaType.annotations: %s", err)
		panic(errMsg)
	}
	v.FldValidators["annotations"] = vFn

	vrhDescription := v.DescriptionValidationRuleHandler
	rulesDescription := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "1200",
	}
	vFn, err = vrhDescription(rulesDescription)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ObjectGetMetaType.description: %s", err)
		panic(errMsg)
	}
	v.FldValidators["description"] = vFn

	return v
}()

func ObjectGetMetaTypeValidator() db.Validator {
	return DefaultObjectGetMetaTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ObjectMetaType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ObjectMetaType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ObjectMetaType) DeepCopy() *ObjectMetaType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ObjectMetaType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ObjectMetaType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ObjectMetaType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ObjectMetaTypeValidator().Validate(ctx, m, opts...)
}

// SetName sets the field
func (m *ObjectMetaType) SetName(in string) {
	m.Name = in
}

// SetUid sets the field
func (m *ObjectMetaType) SetUid(in string) {
	m.Uid = in
}

type ValidateObjectMetaType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateObjectMetaType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateObjectMetaType) AnnotationsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for annotations")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for annotations")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for annotations")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map annotations")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items annotations")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateObjectMetaType) DescriptionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for description")
	}

	return validatorFn, nil
}

func (v *ValidateObjectMetaType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ObjectMetaType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ObjectMetaType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["annotations"]; exists {
		vOpts := append(opts, db.WithValidateField("annotations"))
		if err := fv(ctx, m.GetAnnotations(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable"]; exists {

		vOpts := append(opts, db.WithValidateField("disable"))
		if err := fv(ctx, m.GetDisable(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["labels"]; exists {

		vOpts := append(opts, db.WithValidateField("labels"))
		for key, value := range m.GetLabels() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["uid"]; exists {

		vOpts := append(opts, db.WithValidateField("uid"))
		if err := fv(ctx, m.GetUid(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultObjectMetaTypeValidator = func() *ValidateObjectMetaType {
	v := &ValidateObjectMetaType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ObjectMetaType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhAnnotations := v.AnnotationsValidationRuleHandler
	rulesAnnotations := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len":   "64",
		"ves.io.schema.rules.map.keys.string.min_len":   "1",
		"ves.io.schema.rules.map.values.string.max_len": "1024",
		"ves.io.schema.rules.map.values.string.min_len": "1",
	}
	vFn, err = vrhAnnotations(rulesAnnotations)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ObjectMetaType.annotations: %s", err)
		panic(errMsg)
	}
	v.FldValidators["annotations"] = vFn

	vrhDescription := v.DescriptionValidationRuleHandler
	rulesDescription := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "1200",
	}
	vFn, err = vrhDescription(rulesDescription)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ObjectMetaType.description: %s", err)
		panic(errMsg)
	}
	v.FldValidators["description"] = vFn

	return v
}()

func ObjectMetaTypeValidator() db.Validator {
	return DefaultObjectMetaTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ObjectRefType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ObjectRefType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ObjectRefType) DeepCopy() *ObjectRefType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ObjectRefType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ObjectRefType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ObjectRefType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ObjectRefTypeValidator().Validate(ctx, m, opts...)
}

// SetKind sets the field
func (m *ObjectRefType) SetKind(in string) {
	m.Kind = in
}

// SetName sets the field
func (m *ObjectRefType) SetName(in string) {
	m.Name = in
}

// SetNamespace sets the field
func (m *ObjectRefType) SetNamespace(in string) {
	m.Namespace = in
}

// SetTenant sets the field
func (m *ObjectRefType) SetTenant(in string) {
	m.Tenant = in
}

// SetUid sets the field
func (m *ObjectRefType) SetUid(in string) {
	m.Uid = in
}

type ValidateObjectRefType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateObjectRefType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ObjectRefType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ObjectRefType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["kind"]; exists {

		vOpts := append(opts, db.WithValidateField("kind"))
		if err := fv(ctx, m.GetKind(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tenant"]; exists {

		vOpts := append(opts, db.WithValidateField("tenant"))
		if err := fv(ctx, m.GetTenant(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["uid"]; exists {

		vOpts := append(opts, db.WithValidateField("uid"))
		if err := fv(ctx, m.GetUid(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultObjectRefTypeValidator = func() *ValidateObjectRefType {
	v := &ValidateObjectRefType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ObjectRefTypeValidator() db.Validator {
	return DefaultObjectRefTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ObjectReplaceMetaType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ObjectReplaceMetaType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ObjectReplaceMetaType) DeepCopy() *ObjectReplaceMetaType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ObjectReplaceMetaType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ObjectReplaceMetaType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ObjectReplaceMetaType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ObjectReplaceMetaTypeValidator().Validate(ctx, m, opts...)
}

type ValidateObjectReplaceMetaType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateObjectReplaceMetaType) AnnotationsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for annotations")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for annotations")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for annotations")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map annotations")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items annotations")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateObjectReplaceMetaType) DescriptionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for description")
	}

	return validatorFn, nil
}

func (v *ValidateObjectReplaceMetaType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ObjectReplaceMetaType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ObjectReplaceMetaType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["annotations"]; exists {
		vOpts := append(opts, db.WithValidateField("annotations"))
		if err := fv(ctx, m.GetAnnotations(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable"]; exists {

		vOpts := append(opts, db.WithValidateField("disable"))
		if err := fv(ctx, m.GetDisable(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["labels"]; exists {

		vOpts := append(opts, db.WithValidateField("labels"))
		for key, value := range m.GetLabels() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultObjectReplaceMetaTypeValidator = func() *ValidateObjectReplaceMetaType {
	v := &ValidateObjectReplaceMetaType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAnnotations := v.AnnotationsValidationRuleHandler
	rulesAnnotations := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len":   "64",
		"ves.io.schema.rules.map.keys.string.min_len":   "1",
		"ves.io.schema.rules.map.values.string.max_len": "1024",
		"ves.io.schema.rules.map.values.string.min_len": "1",
	}
	vFn, err = vrhAnnotations(rulesAnnotations)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ObjectReplaceMetaType.annotations: %s", err)
		panic(errMsg)
	}
	v.FldValidators["annotations"] = vFn

	vrhDescription := v.DescriptionValidationRuleHandler
	rulesDescription := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "1200",
	}
	vFn, err = vrhDescription(rulesDescription)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ObjectReplaceMetaType.description: %s", err)
		panic(errMsg)
	}
	v.FldValidators["description"] = vFn

	return v
}()

func ObjectReplaceMetaTypeValidator() db.Validator {
	return DefaultObjectReplaceMetaTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PathMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PathMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PathMatcherType) DeepCopy() *PathMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PathMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PathMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PathMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PathMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePathMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePathMatcherType) PathMatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for path_match")
	}
	return validatorFn, nil
}

func (v *ValidatePathMatcherType) PathMatchPrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Prefix, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for prefix")
	}
	return oValidatorFn_Prefix, nil
}
func (v *ValidatePathMatcherType) PathMatchPathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Path, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for path")
	}
	return oValidatorFn_Path, nil
}
func (v *ValidatePathMatcherType) PathMatchRegexValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Regex, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for regex")
	}
	return oValidatorFn_Regex, nil
}

func (v *ValidatePathMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PathMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PathMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["path_match"]; exists {
		val := m.GetPathMatch()
		vOpts := append(opts,
			db.WithValidateField("path_match"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPathMatch().(type) {
	case *PathMatcherType_Prefix:
		if fv, exists := v.FldValidators["path_match.prefix"]; exists {
			val := m.GetPathMatch().(*PathMatcherType_Prefix).Prefix
			vOpts := append(opts,
				db.WithValidateField("path_match"),
				db.WithValidateField("prefix"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PathMatcherType_Path:
		if fv, exists := v.FldValidators["path_match.path"]; exists {
			val := m.GetPathMatch().(*PathMatcherType_Path).Path
			vOpts := append(opts,
				db.WithValidateField("path_match"),
				db.WithValidateField("path"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PathMatcherType_Regex:
		if fv, exists := v.FldValidators["path_match.regex"]; exists {
			val := m.GetPathMatch().(*PathMatcherType_Regex).Regex
			vOpts := append(opts,
				db.WithValidateField("path_match"),
				db.WithValidateField("regex"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPathMatcherTypeValidator = func() *ValidatePathMatcherType {
	v := &ValidatePathMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPathMatch := v.PathMatchValidationRuleHandler
	rulesPathMatch := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPathMatch(rulesPathMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PathMatcherType.path_match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["path_match"] = vFn

	vrhPathMatchPrefix := v.PathMatchPrefixValidationRuleHandler
	rulesPathMatchPrefix := map[string]string{
		"ves.io.schema.rules.string.http_path": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFnMap["path_match.prefix"], err = vrhPathMatchPrefix(rulesPathMatchPrefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field PathMatcherType.path_match_prefix: %s", err)
		panic(errMsg)
	}
	vrhPathMatchPath := v.PathMatchPathValidationRuleHandler
	rulesPathMatchPath := map[string]string{
		"ves.io.schema.rules.string.http_path": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFnMap["path_match.path"], err = vrhPathMatchPath(rulesPathMatchPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field PathMatcherType.path_match_path: %s", err)
		panic(errMsg)
	}
	vrhPathMatchRegex := v.PathMatchRegexValidationRuleHandler
	rulesPathMatchRegex := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "256",
		"ves.io.schema.rules.string.min_bytes": "1",
		"ves.io.schema.rules.string.regex":     "true",
	}
	vFnMap["path_match.regex"], err = vrhPathMatchRegex(rulesPathMatchRegex)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field PathMatcherType.path_match_regex: %s", err)
		panic(errMsg)
	}

	v.FldValidators["path_match.prefix"] = vFnMap["path_match.prefix"]
	v.FldValidators["path_match.path"] = vFnMap["path_match.path"]
	v.FldValidators["path_match.regex"] = vFnMap["path_match.regex"]

	return v
}()

func PathMatcherTypeValidator() db.Validator {
	return DefaultPathMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PolicerRefType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PolicerRefType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PolicerRefType) DeepCopy() *PolicerRefType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PolicerRefType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PolicerRefType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PolicerRefType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PolicerRefTypeValidator().Validate(ctx, m, opts...)
}

func (m *PolicerRefType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetRefDRefInfo()

}

func (m *PolicerRefType) GetRefDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRef()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("PolicerRefType.ref[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "policer.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "ref",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRefDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *PolicerRefType) GetRefDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "policer.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: policer")
	}
	for _, ref := range m.GetRef() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidatePolicerRefType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePolicerRefType) RefValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for ref")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ref")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ref")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ref")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePolicerRefType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PolicerRefType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PolicerRefType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ref"]; exists {
		vOpts := append(opts, db.WithValidateField("ref"))
		if err := fv(ctx, m.GetRef(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPolicerRefTypeValidator = func() *ValidatePolicerRefType {
	v := &ValidatePolicerRefType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRef := v.RefValidationRuleHandler
	rulesRef := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhRef(rulesRef)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PolicerRefType.ref: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ref"] = vFn

	return v
}()

func PolicerRefTypeValidator() db.Validator {
	return DefaultPolicerRefTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PortMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PortMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PortMatcherType) DeepCopy() *PortMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PortMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PortMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PortMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PortMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePortMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePortMatcherType) PortMatchPortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Port, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port")
	}
	return oValidatorFn_Port, nil
}
func (v *ValidatePortMatcherType) PortMatchPortRangesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_PortRanges, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port_ranges")
	}
	return oValidatorFn_PortRanges, nil
}

func (v *ValidatePortMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PortMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PortMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetPortMatch().(type) {
	case *PortMatcherType_Port:
		if fv, exists := v.FldValidators["port_match.port"]; exists {
			val := m.GetPortMatch().(*PortMatcherType_Port).Port
			vOpts := append(opts,
				db.WithValidateField("port_match"),
				db.WithValidateField("port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PortMatcherType_PortRanges:
		if fv, exists := v.FldValidators["port_match.port_ranges"]; exists {
			val := m.GetPortMatch().(*PortMatcherType_PortRanges).PortRanges
			vOpts := append(opts,
				db.WithValidateField("port_match"),
				db.WithValidateField("port_ranges"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PortMatcherType_NoPortMatch:
		if fv, exists := v.FldValidators["port_match.no_port_match"]; exists {
			val := m.GetPortMatch().(*PortMatcherType_NoPortMatch).NoPortMatch
			vOpts := append(opts,
				db.WithValidateField("port_match"),
				db.WithValidateField("no_port_match"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPortMatcherTypeValidator = func() *ValidatePortMatcherType {
	v := &ValidatePortMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPortMatchPort := v.PortMatchPortValidationRuleHandler
	rulesPortMatchPort := map[string]string{
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFnMap["port_match.port"], err = vrhPortMatchPort(rulesPortMatchPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field PortMatcherType.port_match_port: %s", err)
		panic(errMsg)
	}
	vrhPortMatchPortRanges := v.PortMatchPortRangesValidationRuleHandler
	rulesPortMatchPortRanges := map[string]string{
		"ves.io.schema.rules.string.max_len":    "32",
		"ves.io.schema.rules.string.min_len":    "1",
		"ves.io.schema.rules.string.port_range": "true",
	}
	vFnMap["port_match.port_ranges"], err = vrhPortMatchPortRanges(rulesPortMatchPortRanges)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field PortMatcherType.port_match_port_ranges: %s", err)
		panic(errMsg)
	}

	v.FldValidators["port_match.port"] = vFnMap["port_match.port"]
	v.FldValidators["port_match.port_ranges"] = vFnMap["port_match.port_ranges"]

	return v
}()

func PortMatcherTypeValidator() db.Validator {
	return DefaultPortMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PortRangesType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PortRangesType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PortRangesType) DeepCopy() *PortRangesType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PortRangesType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PortRangesType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PortRangesType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PortRangesTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePortRangesType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePortRangesType) PortsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for ports")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ports")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ports")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ports")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePortRangesType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PortRangesType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PortRangesType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ports"]; exists {
		vOpts := append(opts, db.WithValidateField("ports"))
		if err := fv(ctx, m.GetPorts(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPortRangesTypeValidator = func() *ValidatePortRangesType {
	v := &ValidatePortRangesType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPorts := v.PortsValidationRuleHandler
	rulesPorts := map[string]string{
		"ves.io.schema.rules.message.required":                 "true",
		"ves.io.schema.rules.repeated.items.string.port_range": "true",
		"ves.io.schema.rules.repeated.max_items":               "128",
	}
	vFn, err = vrhPorts(rulesPorts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PortRangesType.ports: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ports"] = vFn

	return v
}()

func PortRangesTypeValidator() db.Validator {
	return DefaultPortRangesTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PortValueType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PortValueType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PortValueType) DeepCopy() *PortValueType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PortValueType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PortValueType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PortValueType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PortValueTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePortValueType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePortValueType) PortValueTypeChoiceUserDefinedValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_UserDefined, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for user_defined")
	}
	return oValidatorFn_UserDefined, nil
}

func (v *ValidatePortValueType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PortValueType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PortValueType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetPortValueTypeChoice().(type) {
	case *PortValueType_All:
		if fv, exists := v.FldValidators["port_value_type_choice.all"]; exists {
			val := m.GetPortValueTypeChoice().(*PortValueType_All).All
			vOpts := append(opts,
				db.WithValidateField("port_value_type_choice"),
				db.WithValidateField("all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PortValueType_UserDefined:
		if fv, exists := v.FldValidators["port_value_type_choice.user_defined"]; exists {
			val := m.GetPortValueTypeChoice().(*PortValueType_UserDefined).UserDefined
			vOpts := append(opts,
				db.WithValidateField("port_value_type_choice"),
				db.WithValidateField("user_defined"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PortValueType_Dns:
		if fv, exists := v.FldValidators["port_value_type_choice.dns"]; exists {
			val := m.GetPortValueTypeChoice().(*PortValueType_Dns).Dns
			vOpts := append(opts,
				db.WithValidateField("port_value_type_choice"),
				db.WithValidateField("dns"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPortValueTypeValidator = func() *ValidatePortValueType {
	v := &ValidatePortValueType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPortValueTypeChoiceUserDefined := v.PortValueTypeChoiceUserDefinedValidationRuleHandler
	rulesPortValueTypeChoiceUserDefined := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFnMap["port_value_type_choice.user_defined"], err = vrhPortValueTypeChoiceUserDefined(rulesPortValueTypeChoiceUserDefined)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field PortValueType.port_value_type_choice_user_defined: %s", err)
		panic(errMsg)
	}

	v.FldValidators["port_value_type_choice.user_defined"] = vFnMap["port_value_type_choice.user_defined"]

	return v
}()

func PortValueTypeValidator() db.Validator {
	return DefaultPortValueTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ProtocolPolicerRefType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ProtocolPolicerRefType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ProtocolPolicerRefType) DeepCopy() *ProtocolPolicerRefType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ProtocolPolicerRefType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ProtocolPolicerRefType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ProtocolPolicerRefType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ProtocolPolicerRefTypeValidator().Validate(ctx, m, opts...)
}

func (m *ProtocolPolicerRefType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetRefDRefInfo()

}

func (m *ProtocolPolicerRefType) GetRefDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRef()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("ProtocolPolicerRefType.ref[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "protocol_policer.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "ref",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRefDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ProtocolPolicerRefType) GetRefDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "protocol_policer.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: protocol_policer")
	}
	for _, ref := range m.GetRef() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateProtocolPolicerRefType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateProtocolPolicerRefType) RefValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for ref")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ref")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ref")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ref")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateProtocolPolicerRefType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ProtocolPolicerRefType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ProtocolPolicerRefType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ref"]; exists {
		vOpts := append(opts, db.WithValidateField("ref"))
		if err := fv(ctx, m.GetRef(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultProtocolPolicerRefTypeValidator = func() *ValidateProtocolPolicerRefType {
	v := &ValidateProtocolPolicerRefType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRef := v.RefValidationRuleHandler
	rulesRef := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhRef(rulesRef)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProtocolPolicerRefType.ref: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ref"] = vFn

	return v
}()

func ProtocolPolicerRefTypeValidator() db.Validator {
	return DefaultProtocolPolicerRefTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *QueryParameterMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *QueryParameterMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *QueryParameterMatcherType) DeepCopy() *QueryParameterMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &QueryParameterMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *QueryParameterMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *QueryParameterMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return QueryParameterMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateQueryParameterMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateQueryParameterMatcherType) ValueMatchRegexValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Regex, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for regex")
	}
	return oValidatorFn_Regex, nil
}

func (v *ValidateQueryParameterMatcherType) KeyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for key")
	}

	return validatorFn, nil
}

func (v *ValidateQueryParameterMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*QueryParameterMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *QueryParameterMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["key"]; exists {

		vOpts := append(opts, db.WithValidateField("key"))
		if err := fv(ctx, m.GetKey(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetValueMatch().(type) {
	case *QueryParameterMatcherType_Exact:
		if fv, exists := v.FldValidators["value_match.exact"]; exists {
			val := m.GetValueMatch().(*QueryParameterMatcherType_Exact).Exact
			vOpts := append(opts,
				db.WithValidateField("value_match"),
				db.WithValidateField("exact"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *QueryParameterMatcherType_Regex:
		if fv, exists := v.FldValidators["value_match.regex"]; exists {
			val := m.GetValueMatch().(*QueryParameterMatcherType_Regex).Regex
			vOpts := append(opts,
				db.WithValidateField("value_match"),
				db.WithValidateField("regex"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultQueryParameterMatcherTypeValidator = func() *ValidateQueryParameterMatcherType {
	v := &ValidateQueryParameterMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhValueMatchRegex := v.ValueMatchRegexValidationRuleHandler
	rulesValueMatchRegex := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "256",
		"ves.io.schema.rules.string.min_bytes": "1",
		"ves.io.schema.rules.string.regex":     "true",
	}
	vFnMap["value_match.regex"], err = vrhValueMatchRegex(rulesValueMatchRegex)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field QueryParameterMatcherType.value_match_regex: %s", err)
		panic(errMsg)
	}

	v.FldValidators["value_match.regex"] = vFnMap["value_match.regex"]

	vrhKey := v.KeyValidationRuleHandler
	rulesKey := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "256",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhKey(rulesKey)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for QueryParameterMatcherType.key: %s", err)
		panic(errMsg)
	}
	v.FldValidators["key"] = vFn

	return v
}()

func QueryParameterMatcherTypeValidator() db.Validator {
	return DefaultQueryParameterMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *RegexMatchRewrite) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RegexMatchRewrite) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RegexMatchRewrite) DeepCopy() *RegexMatchRewrite {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RegexMatchRewrite{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RegexMatchRewrite) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RegexMatchRewrite) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RegexMatchRewriteValidator().Validate(ctx, m, opts...)
}

type ValidateRegexMatchRewrite struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRegexMatchRewrite) PatternValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for pattern")
	}

	return validatorFn, nil
}

func (v *ValidateRegexMatchRewrite) SubstitutionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for substitution")
	}

	return validatorFn, nil
}

func (v *ValidateRegexMatchRewrite) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RegexMatchRewrite)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RegexMatchRewrite got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["pattern"]; exists {

		vOpts := append(opts, db.WithValidateField("pattern"))
		if err := fv(ctx, m.GetPattern(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["substitution"]; exists {

		vOpts := append(opts, db.WithValidateField("substitution"))
		if err := fv(ctx, m.GetSubstitution(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRegexMatchRewriteValidator = func() *ValidateRegexMatchRewrite {
	v := &ValidateRegexMatchRewrite{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPattern := v.PatternValidationRuleHandler
	rulesPattern := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.min_len": "1",
		"ves.io.schema.rules.string.regex":   "true",
	}
	vFn, err = vrhPattern(rulesPattern)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RegexMatchRewrite.pattern: %s", err)
		panic(errMsg)
	}
	v.FldValidators["pattern"] = vFn

	vrhSubstitution := v.SubstitutionValidationRuleHandler
	rulesSubstitution := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhSubstitution(rulesSubstitution)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RegexMatchRewrite.substitution: %s", err)
		panic(errMsg)
	}
	v.FldValidators["substitution"] = vFn

	return v
}()

func RegexMatchRewriteValidator() db.Validator {
	return DefaultRegexMatchRewriteValidator
}

// augmented methods on protoc/std generated struct

func (m *ResponseMeta) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ResponseMeta) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ResponseMeta) DeepCopy() *ResponseMeta {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ResponseMeta{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ResponseMeta) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ResponseMeta) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ResponseMetaValidator().Validate(ctx, m, opts...)
}

type ValidateResponseMeta struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateResponseMeta) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ResponseMeta)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ResponseMeta got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["display_message"]; exists {

		vOpts := append(opts, db.WithValidateField("display_message"))
		if err := fv(ctx, m.GetDisplayMessage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["error_code"]; exists {

		vOpts := append(opts, db.WithValidateField("error_code"))
		if err := fv(ctx, m.GetErrorCode(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultResponseMetaValidator = func() *ValidateResponseMeta {
	v := &ValidateResponseMeta{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ResponseMetaValidator() db.Validator {
	return DefaultResponseMetaValidator
}

// augmented methods on protoc/std generated struct

func (m *RestAuthInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RestAuthInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *RestAuthInfoType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetBasicAuth().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting RestAuthInfoType.basic_auth")
	}

	if err := m.GetHeadersAuth().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting RestAuthInfoType.headers_auth")
	}

	if err := m.GetQueryParamsAuth().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting RestAuthInfoType.query_params_auth")
	}

	return nil
}

func (m *RestAuthInfoType) DeepCopy() *RestAuthInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RestAuthInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RestAuthInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RestAuthInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RestAuthInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateRestAuthInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRestAuthInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RestAuthInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RestAuthInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetAuthParams().(type) {
	case *RestAuthInfoType_BasicAuth:
		if fv, exists := v.FldValidators["auth_params.basic_auth"]; exists {
			val := m.GetAuthParams().(*RestAuthInfoType_BasicAuth).BasicAuth
			vOpts := append(opts,
				db.WithValidateField("auth_params"),
				db.WithValidateField("basic_auth"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RestAuthInfoType_HeadersAuth:
		if fv, exists := v.FldValidators["auth_params.headers_auth"]; exists {
			val := m.GetAuthParams().(*RestAuthInfoType_HeadersAuth).HeadersAuth
			vOpts := append(opts,
				db.WithValidateField("auth_params"),
				db.WithValidateField("headers_auth"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RestAuthInfoType_QueryParamsAuth:
		if fv, exists := v.FldValidators["auth_params.query_params_auth"]; exists {
			val := m.GetAuthParams().(*RestAuthInfoType_QueryParamsAuth).QueryParamsAuth
			vOpts := append(opts,
				db.WithValidateField("auth_params"),
				db.WithValidateField("query_params_auth"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRestAuthInfoTypeValidator = func() *ValidateRestAuthInfoType {
	v := &ValidateRestAuthInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["auth_params.basic_auth"] = AuthnTypeBasicAuthValidator().Validate
	v.FldValidators["auth_params.headers_auth"] = AuthnTypeHeadersValidator().Validate
	v.FldValidators["auth_params.query_params_auth"] = AuthnTypeQueryParamsValidator().Validate

	return v
}()

func RestAuthInfoTypeValidator() db.Validator {
	return DefaultRestAuthInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *RetryBackOff) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RetryBackOff) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RetryBackOff) DeepCopy() *RetryBackOff {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RetryBackOff{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RetryBackOff) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RetryBackOff) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RetryBackOffValidator().Validate(ctx, m, opts...)
}

type ValidateRetryBackOff struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRetryBackOff) BaseIntervalValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for base_interval")
	}

	return validatorFn, nil
}

func (v *ValidateRetryBackOff) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RetryBackOff)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RetryBackOff got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["base_interval"]; exists {

		vOpts := append(opts, db.WithValidateField("base_interval"))
		if err := fv(ctx, m.GetBaseInterval(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_interval"]; exists {

		vOpts := append(opts, db.WithValidateField("max_interval"))
		if err := fv(ctx, m.GetMaxInterval(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRetryBackOffValidator = func() *ValidateRetryBackOff {
	v := &ValidateRetryBackOff{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhBaseInterval := v.BaseIntervalValidationRuleHandler
	rulesBaseInterval := map[string]string{
		"ves.io.schema.rules.uint32.gt": "0",
	}
	vFn, err = vrhBaseInterval(rulesBaseInterval)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RetryBackOff.base_interval: %s", err)
		panic(errMsg)
	}
	v.FldValidators["base_interval"] = vFn

	return v
}()

func RetryBackOffValidator() db.Validator {
	return DefaultRetryBackOffValidator
}

// augmented methods on protoc/std generated struct

func (m *RetryPolicyType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RetryPolicyType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RetryPolicyType) DeepCopy() *RetryPolicyType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RetryPolicyType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RetryPolicyType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RetryPolicyType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RetryPolicyTypeValidator().Validate(ctx, m, opts...)
}

type ValidateRetryPolicyType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRetryPolicyType) RetryOnValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for retry_on")
	}

	return validatorFn, nil
}

func (v *ValidateRetryPolicyType) NumRetriesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for num_retries")
	}

	return validatorFn, nil
}

func (v *ValidateRetryPolicyType) PerTryTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for per_try_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateRetryPolicyType) RetriableStatusCodesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepUint32ItemRules(rules)
	itemValFn, err := db.NewUint32ValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for retriable_status_codes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []uint32, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for retriable_status_codes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]uint32)
		if !ok {
			return fmt.Errorf("Repeated validation expected []uint32, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated retriable_status_codes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items retriable_status_codes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRetryPolicyType) RetryConditionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for retry_condition")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for retry_condition")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated retry_condition")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items retry_condition")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRetryPolicyType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RetryPolicyType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RetryPolicyType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["back_off"]; exists {

		vOpts := append(opts, db.WithValidateField("back_off"))
		if err := fv(ctx, m.GetBackOff(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["num_retries"]; exists {

		vOpts := append(opts, db.WithValidateField("num_retries"))
		if err := fv(ctx, m.GetNumRetries(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["per_try_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("per_try_timeout"))
		if err := fv(ctx, m.GetPerTryTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["retriable_status_codes"]; exists {
		vOpts := append(opts, db.WithValidateField("retriable_status_codes"))
		if err := fv(ctx, m.GetRetriableStatusCodes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["retry_condition"]; exists {
		vOpts := append(opts, db.WithValidateField("retry_condition"))
		if err := fv(ctx, m.GetRetryCondition(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["retry_on"]; exists {

		vOpts := append(opts, db.WithValidateField("retry_on"))
		if err := fv(ctx, m.GetRetryOn(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRetryPolicyTypeValidator = func() *ValidateRetryPolicyType {
	v := &ValidateRetryPolicyType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRetryOn := v.RetryOnValidationRuleHandler
	rulesRetryOn := map[string]string{
		"ves.io.schema.rules.string.in": "[\"\",\"5xx\",\"gateway-error\",\"connect-failure\",\"refused-stream\",\"retriable-4xx\",\"retriable-status-codes\"]",
	}
	vFn, err = vrhRetryOn(rulesRetryOn)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RetryPolicyType.retry_on: %s", err)
		panic(errMsg)
	}
	v.FldValidators["retry_on"] = vFn

	vrhNumRetries := v.NumRetriesValidationRuleHandler
	rulesNumRetries := map[string]string{
		"ves.io.schema.rules.uint32.lte": "8",
	}
	vFn, err = vrhNumRetries(rulesNumRetries)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RetryPolicyType.num_retries: %s", err)
		panic(errMsg)
	}
	v.FldValidators["num_retries"] = vFn

	vrhPerTryTimeout := v.PerTryTimeoutValidationRuleHandler
	rulesPerTryTimeout := map[string]string{
		"ves.io.schema.rules.uint32.lte": "600000",
	}
	vFn, err = vrhPerTryTimeout(rulesPerTryTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RetryPolicyType.per_try_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["per_try_timeout"] = vFn

	vrhRetriableStatusCodes := v.RetriableStatusCodesValidationRuleHandler
	rulesRetriableStatusCodes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRetriableStatusCodes(rulesRetriableStatusCodes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RetryPolicyType.retriable_status_codes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["retriable_status_codes"] = vFn

	vrhRetryCondition := v.RetryConditionValidationRuleHandler
	rulesRetryCondition := map[string]string{
		"ves.io.schema.rules.message.required":         "true",
		"ves.io.schema.rules.repeated.items.string.in": "[\"5xx\",\"gateway-error\",\"connect-failure\",\"refused-stream\",\"retriable-4xx\",\"retriable-status-codes\",\"reset\"]",
		"ves.io.schema.rules.repeated.max_items":       "7",
		"ves.io.schema.rules.repeated.min_items":       "1",
		"ves.io.schema.rules.repeated.unique":          "true",
	}
	vFn, err = vrhRetryCondition(rulesRetryCondition)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RetryPolicyType.retry_condition: %s", err)
		panic(errMsg)
	}
	v.FldValidators["retry_condition"] = vFn

	v.FldValidators["back_off"] = RetryBackOffValidator().Validate

	return v
}()

func RetryPolicyTypeValidator() db.Validator {
	return DefaultRetryPolicyTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *RoleListType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RoleListType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RoleListType) DeepCopy() *RoleListType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RoleListType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RoleListType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RoleListType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RoleListTypeValidator().Validate(ctx, m, opts...)
}

type ValidateRoleListType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRoleListType) NamesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for names")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for names")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated names")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items names")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRoleListType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RoleListType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RoleListType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["names"]; exists {
		vOpts := append(opts, db.WithValidateField("names"))
		if err := fv(ctx, m.GetNames(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRoleListTypeValidator = func() *ValidateRoleListType {
	v := &ValidateRoleListType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNames := v.NamesValidationRuleHandler
	rulesNames := map[string]string{
		"ves.io.schema.rules.message.required":                      "true",
		"ves.io.schema.rules.repeated.items.string.max_len":         "256",
		"ves.io.schema.rules.repeated.items.string.ves_object_name": "true",
		"ves.io.schema.rules.repeated.unique":                       "true",
	}
	vFn, err = vrhNames(rulesNames)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RoleListType.names: %s", err)
		panic(errMsg)
	}
	v.FldValidators["names"] = vFn

	return v
}()

func RoleListTypeValidator() db.Validator {
	return DefaultRoleListTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *RouteMatch) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RouteMatch) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RouteMatch) DeepCopy() *RouteMatch {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RouteMatch{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RouteMatch) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RouteMatch) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RouteMatchValidator().Validate(ctx, m, opts...)
}

type ValidateRouteMatch struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRouteMatch) HeadersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for headers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*HeaderMatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := HeaderMatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for headers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*HeaderMatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*HeaderMatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated headers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items headers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteMatch) QueryParamsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for query_params")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*QueryParameterMatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := QueryParameterMatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for query_params")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*QueryParameterMatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*QueryParameterMatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated query_params")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items query_params")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteMatch) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RouteMatch)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RouteMatch got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["headers"]; exists {
		vOpts := append(opts, db.WithValidateField("headers"))
		if err := fv(ctx, m.GetHeaders(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["http_method"]; exists {

		vOpts := append(opts, db.WithValidateField("http_method"))
		if err := fv(ctx, m.GetHttpMethod(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["incoming_port"]; exists {

		vOpts := append(opts, db.WithValidateField("incoming_port"))
		if err := fv(ctx, m.GetIncomingPort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query_params"]; exists {
		vOpts := append(opts, db.WithValidateField("query_params"))
		if err := fv(ctx, m.GetQueryParams(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRouteMatchValidator = func() *ValidateRouteMatch {
	v := &ValidateRouteMatch{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHeaders := v.HeadersValidationRuleHandler
	rulesHeaders := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhHeaders(rulesHeaders)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteMatch.headers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["headers"] = vFn

	vrhQueryParams := v.QueryParamsValidationRuleHandler
	rulesQueryParams := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhQueryParams(rulesQueryParams)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteMatch.query_params: %s", err)
		panic(errMsg)
	}
	v.FldValidators["query_params"] = vFn

	v.FldValidators["path"] = PathMatcherTypeValidator().Validate

	v.FldValidators["incoming_port"] = PortMatcherTypeValidator().Validate

	return v
}()

func RouteMatchValidator() db.Validator {
	return DefaultRouteMatchValidator
}

// augmented methods on protoc/std generated struct

func (m *RouteTarget) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RouteTarget) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RouteTarget) DeepCopy() *RouteTarget {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RouteTarget{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RouteTarget) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RouteTarget) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RouteTargetValidator().Validate(ctx, m, opts...)
}

type ValidateRouteTarget struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRouteTarget) RtargetChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for rtarget_choice")
	}
	return validatorFn, nil
}

func (v *ValidateRouteTarget) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RouteTarget)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RouteTarget got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["rtarget_choice"]; exists {
		val := m.GetRtargetChoice()
		vOpts := append(opts,
			db.WithValidateField("rtarget_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetRtargetChoice().(type) {
	case *RouteTarget_Asn2ByteRtarget:
		if fv, exists := v.FldValidators["rtarget_choice.asn2byte_rtarget"]; exists {
			val := m.GetRtargetChoice().(*RouteTarget_Asn2ByteRtarget).Asn2ByteRtarget
			vOpts := append(opts,
				db.WithValidateField("rtarget_choice"),
				db.WithValidateField("asn2byte_rtarget"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RouteTarget_Ipv4AddrRtarget:
		if fv, exists := v.FldValidators["rtarget_choice.ipv4_addr_rtarget"]; exists {
			val := m.GetRtargetChoice().(*RouteTarget_Ipv4AddrRtarget).Ipv4AddrRtarget
			vOpts := append(opts,
				db.WithValidateField("rtarget_choice"),
				db.WithValidateField("ipv4_addr_rtarget"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RouteTarget_Asn4ByteRtarget:
		if fv, exists := v.FldValidators["rtarget_choice.asn4byte_rtarget"]; exists {
			val := m.GetRtargetChoice().(*RouteTarget_Asn4ByteRtarget).Asn4ByteRtarget
			vOpts := append(opts,
				db.WithValidateField("rtarget_choice"),
				db.WithValidateField("asn4byte_rtarget"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRouteTargetValidator = func() *ValidateRouteTarget {
	v := &ValidateRouteTarget{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRtargetChoice := v.RtargetChoiceValidationRuleHandler
	rulesRtargetChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhRtargetChoice(rulesRtargetChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteTarget.rtarget_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rtarget_choice"] = vFn

	v.FldValidators["rtarget_choice.asn2byte_rtarget"] = RouteTarget2ByteAsnValidator().Validate
	v.FldValidators["rtarget_choice.ipv4_addr_rtarget"] = RouteTargetIPv4AddrValidator().Validate
	v.FldValidators["rtarget_choice.asn4byte_rtarget"] = RouteTarget4ByteAsnValidator().Validate

	return v
}()

func RouteTargetValidator() db.Validator {
	return DefaultRouteTargetValidator
}

// augmented methods on protoc/std generated struct

func (m *RouteTarget2ByteAsn) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RouteTarget2ByteAsn) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RouteTarget2ByteAsn) DeepCopy() *RouteTarget2ByteAsn {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RouteTarget2ByteAsn{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RouteTarget2ByteAsn) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RouteTarget2ByteAsn) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RouteTarget2ByteAsnValidator().Validate(ctx, m, opts...)
}

type ValidateRouteTarget2ByteAsn struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRouteTarget2ByteAsn) AsNumberValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for as_number")
	}

	return validatorFn, nil
}

func (v *ValidateRouteTarget2ByteAsn) ValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for value")
	}

	return validatorFn, nil
}

func (v *ValidateRouteTarget2ByteAsn) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RouteTarget2ByteAsn)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RouteTarget2ByteAsn got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["as_number"]; exists {

		vOpts := append(opts, db.WithValidateField("as_number"))
		if err := fv(ctx, m.GetAsNumber(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRouteTarget2ByteAsnValidator = func() *ValidateRouteTarget2ByteAsn {
	v := &ValidateRouteTarget2ByteAsn{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAsNumber := v.AsNumberValidationRuleHandler
	rulesAsNumber := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "1",
		"ves.io.schema.rules.uint32.lte":       "65535",
	}
	vFn, err = vrhAsNumber(rulesAsNumber)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteTarget2ByteAsn.as_number: %s", err)
		panic(errMsg)
	}
	v.FldValidators["as_number"] = vFn

	vrhValue := v.ValueValidationRuleHandler
	rulesValue := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "0",
		"ves.io.schema.rules.uint32.lte":       "4294967295",
	}
	vFn, err = vrhValue(rulesValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteTarget2ByteAsn.value: %s", err)
		panic(errMsg)
	}
	v.FldValidators["value"] = vFn

	return v
}()

func RouteTarget2ByteAsnValidator() db.Validator {
	return DefaultRouteTarget2ByteAsnValidator
}

// augmented methods on protoc/std generated struct

func (m *RouteTarget4ByteAsn) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RouteTarget4ByteAsn) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RouteTarget4ByteAsn) DeepCopy() *RouteTarget4ByteAsn {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RouteTarget4ByteAsn{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RouteTarget4ByteAsn) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RouteTarget4ByteAsn) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RouteTarget4ByteAsnValidator().Validate(ctx, m, opts...)
}

type ValidateRouteTarget4ByteAsn struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRouteTarget4ByteAsn) AsNumberValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for as_number")
	}

	return validatorFn, nil
}

func (v *ValidateRouteTarget4ByteAsn) ValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for value")
	}

	return validatorFn, nil
}

func (v *ValidateRouteTarget4ByteAsn) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RouteTarget4ByteAsn)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RouteTarget4ByteAsn got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["as_number"]; exists {

		vOpts := append(opts, db.WithValidateField("as_number"))
		if err := fv(ctx, m.GetAsNumber(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRouteTarget4ByteAsnValidator = func() *ValidateRouteTarget4ByteAsn {
	v := &ValidateRouteTarget4ByteAsn{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAsNumber := v.AsNumberValidationRuleHandler
	rulesAsNumber := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "65536",
		"ves.io.schema.rules.uint32.lte":       "4294967295",
	}
	vFn, err = vrhAsNumber(rulesAsNumber)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteTarget4ByteAsn.as_number: %s", err)
		panic(errMsg)
	}
	v.FldValidators["as_number"] = vFn

	vrhValue := v.ValueValidationRuleHandler
	rulesValue := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "0",
		"ves.io.schema.rules.uint32.lte":       "65535",
	}
	vFn, err = vrhValue(rulesValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteTarget4ByteAsn.value: %s", err)
		panic(errMsg)
	}
	v.FldValidators["value"] = vFn

	return v
}()

func RouteTarget4ByteAsnValidator() db.Validator {
	return DefaultRouteTarget4ByteAsnValidator
}

// augmented methods on protoc/std generated struct

func (m *RouteTargetIPv4Addr) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RouteTargetIPv4Addr) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RouteTargetIPv4Addr) DeepCopy() *RouteTargetIPv4Addr {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RouteTargetIPv4Addr{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RouteTargetIPv4Addr) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RouteTargetIPv4Addr) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RouteTargetIPv4AddrValidator().Validate(ctx, m, opts...)
}

type ValidateRouteTargetIPv4Addr struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRouteTargetIPv4Addr) AddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address")
	}

	return validatorFn, nil
}

func (v *ValidateRouteTargetIPv4Addr) ValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for value")
	}

	return validatorFn, nil
}

func (v *ValidateRouteTargetIPv4Addr) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RouteTargetIPv4Addr)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RouteTargetIPv4Addr got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address"]; exists {

		vOpts := append(opts, db.WithValidateField("address"))
		if err := fv(ctx, m.GetAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRouteTargetIPv4AddrValidator = func() *ValidateRouteTargetIPv4Addr {
	v := &ValidateRouteTargetIPv4Addr{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAddress := v.AddressValidationRuleHandler
	rulesAddress := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.ipv4":      "true",
	}
	vFn, err = vrhAddress(rulesAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteTargetIPv4Addr.address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address"] = vFn

	vrhValue := v.ValueValidationRuleHandler
	rulesValue := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "0",
		"ves.io.schema.rules.uint32.lte":       "65535",
	}
	vFn, err = vrhValue(rulesValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteTargetIPv4Addr.value: %s", err)
		panic(errMsg)
	}
	v.FldValidators["value"] = vFn

	return v
}()

func RouteTargetIPv4AddrValidator() db.Validator {
	return DefaultRouteTargetIPv4AddrValidator
}

// augmented methods on protoc/std generated struct

func (m *SecretType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SecretType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SecretType) String() string {
	return "REDACTED"
}

func (m *SecretType) GoString() string {
	return "REDACTED"
}

// Redact squashes sensitive info in m (in-place)
func (m *SecretType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	m.SecretInfoOneof = nil

	m.SecretEncodingType = 0

	m.BlindfoldSecretInfoInternal = nil

	return nil
}

func (m *SecretType) DeepCopy() *SecretType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SecretType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SecretType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SecretType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SecretTypeValidator().Validate(ctx, m, opts...)
}

type ValidateSecretType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSecretType) SecretInfoOneofValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for secret_info_oneof")
	}
	return validatorFn, nil
}

func (v *ValidateSecretType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SecretType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SecretType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["blindfold_secret_info_internal"]; exists {

		vOpts := append(opts, db.WithValidateField("blindfold_secret_info_internal"))
		if err := fv(ctx, m.GetBlindfoldSecretInfoInternal(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["secret_encoding_type"]; exists {

		vOpts := append(opts, db.WithValidateField("secret_encoding_type"))
		if err := fv(ctx, m.GetSecretEncodingType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["secret_info_oneof"]; exists {
		val := m.GetSecretInfoOneof()
		vOpts := append(opts,
			db.WithValidateField("secret_info_oneof"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSecretInfoOneof().(type) {
	case *SecretType_BlindfoldSecretInfo:
		if fv, exists := v.FldValidators["secret_info_oneof.blindfold_secret_info"]; exists {
			val := m.GetSecretInfoOneof().(*SecretType_BlindfoldSecretInfo).BlindfoldSecretInfo
			vOpts := append(opts,
				db.WithValidateField("secret_info_oneof"),
				db.WithValidateField("blindfold_secret_info"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SecretType_VaultSecretInfo:
		if fv, exists := v.FldValidators["secret_info_oneof.vault_secret_info"]; exists {
			val := m.GetSecretInfoOneof().(*SecretType_VaultSecretInfo).VaultSecretInfo
			vOpts := append(opts,
				db.WithValidateField("secret_info_oneof"),
				db.WithValidateField("vault_secret_info"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SecretType_ClearSecretInfo:
		if fv, exists := v.FldValidators["secret_info_oneof.clear_secret_info"]; exists {
			val := m.GetSecretInfoOneof().(*SecretType_ClearSecretInfo).ClearSecretInfo
			vOpts := append(opts,
				db.WithValidateField("secret_info_oneof"),
				db.WithValidateField("clear_secret_info"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SecretType_WingmanSecretInfo:
		if fv, exists := v.FldValidators["secret_info_oneof.wingman_secret_info"]; exists {
			val := m.GetSecretInfoOneof().(*SecretType_WingmanSecretInfo).WingmanSecretInfo
			vOpts := append(opts,
				db.WithValidateField("secret_info_oneof"),
				db.WithValidateField("wingman_secret_info"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSecretTypeValidator = func() *ValidateSecretType {
	v := &ValidateSecretType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSecretInfoOneof := v.SecretInfoOneofValidationRuleHandler
	rulesSecretInfoOneof := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSecretInfoOneof(rulesSecretInfoOneof)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SecretType.secret_info_oneof: %s", err)
		panic(errMsg)
	}
	v.FldValidators["secret_info_oneof"] = vFn

	v.FldValidators["secret_info_oneof.blindfold_secret_info"] = BlindfoldSecretInfoTypeValidator().Validate
	v.FldValidators["secret_info_oneof.vault_secret_info"] = VaultSecretInfoTypeValidator().Validate
	v.FldValidators["secret_info_oneof.clear_secret_info"] = ClearSecretInfoTypeValidator().Validate
	v.FldValidators["secret_info_oneof.wingman_secret_info"] = WingmanSecretInfoTypeValidator().Validate

	v.FldValidators["blindfold_secret_info_internal"] = BlindfoldSecretInfoTypeValidator().Validate

	return v
}()

func SecretTypeValidator() db.Validator {
	return DefaultSecretTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteInfo) DeepCopy() *SiteInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteInfoValidator().Validate(ctx, m, opts...)
}

func (m *SiteInfo) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetSiteDRefInfo()

}

func (m *SiteInfo) GetSiteDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetSite()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("SiteInfo.site[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "site.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "site",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetSiteDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *SiteInfo) GetSiteDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: site")
	}
	for _, ref := range m.GetSite() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateSiteInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteInfo) SiteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for site")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for site")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated site")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items site")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSiteInfo) AnnotationsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for annotations")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for annotations")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated annotations")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items annotations")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSiteInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["annotations"]; exists {
		vOpts := append(opts, db.WithValidateField("annotations"))
		if err := fv(ctx, m.GetAnnotations(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {
		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteInfoValidator = func() *ValidateSiteInfo {
	v := &ValidateSiteInfo{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSite := v.SiteValidationRuleHandler
	rulesSite := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhSite(rulesSite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SiteInfo.site: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site"] = vFn

	vrhAnnotations := v.AnnotationsValidationRuleHandler
	rulesAnnotations := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAnnotations(rulesAnnotations)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SiteInfo.annotations: %s", err)
		panic(errMsg)
	}
	v.FldValidators["annotations"] = vFn

	return v
}()

func SiteInfoValidator() db.Validator {
	return DefaultSiteInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteRefType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteRefType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteRefType) DeepCopy() *SiteRefType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteRefType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteRefType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteRefType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteRefTypeValidator().Validate(ctx, m, opts...)
}

func (m *SiteRefType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetRefDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRefDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRefsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRefsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *SiteRefType) GetRefDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRef()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("SiteRefType.ref[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "site.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "ref",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRefDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *SiteRefType) GetRefDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: site")
	}
	for _, ref := range m.GetRef() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *SiteRefType) GetRefsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRefs()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("SiteRefType.refs[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_network.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "refs",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRefsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *SiteRefType) GetRefsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
	}
	for _, ref := range m.GetRefs() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateSiteRefType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteRefType) InternetVipChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for internet_vip_choice")
	}
	return validatorFn, nil
}

func (v *ValidateSiteRefType) RefValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for ref")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ref")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ref")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ref")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSiteRefType) RefsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for refs")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for refs")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated refs")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items refs")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSiteRefType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteRefType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteRefType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["internet_vip_choice"]; exists {
		val := m.GetInternetVipChoice()
		vOpts := append(opts,
			db.WithValidateField("internet_vip_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetInternetVipChoice().(type) {
	case *SiteRefType_EnableInternetVip:
		if fv, exists := v.FldValidators["internet_vip_choice.enable_internet_vip"]; exists {
			val := m.GetInternetVipChoice().(*SiteRefType_EnableInternetVip).EnableInternetVip
			vOpts := append(opts,
				db.WithValidateField("internet_vip_choice"),
				db.WithValidateField("enable_internet_vip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SiteRefType_DisableInternetVip:
		if fv, exists := v.FldValidators["internet_vip_choice.disable_internet_vip"]; exists {
			val := m.GetInternetVipChoice().(*SiteRefType_DisableInternetVip).DisableInternetVip
			vOpts := append(opts,
				db.WithValidateField("internet_vip_choice"),
				db.WithValidateField("disable_internet_vip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["network_type"]; exists {

		vOpts := append(opts, db.WithValidateField("network_type"))
		if err := fv(ctx, m.GetNetworkType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ref"]; exists {
		vOpts := append(opts, db.WithValidateField("ref"))
		if err := fv(ctx, m.GetRef(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["refs"]; exists {
		vOpts := append(opts, db.WithValidateField("refs"))
		if err := fv(ctx, m.GetRefs(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteRefTypeValidator = func() *ValidateSiteRefType {
	v := &ValidateSiteRefType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInternetVipChoice := v.InternetVipChoiceValidationRuleHandler
	rulesInternetVipChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhInternetVipChoice(rulesInternetVipChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SiteRefType.internet_vip_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["internet_vip_choice"] = vFn

	vrhRef := v.RefValidationRuleHandler
	rulesRef := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhRef(rulesRef)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SiteRefType.ref: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ref"] = vFn

	vrhRefs := v.RefsValidationRuleHandler
	rulesRefs := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhRefs(rulesRefs)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SiteRefType.refs: %s", err)
		panic(errMsg)
	}
	v.FldValidators["refs"] = vFn

	return v
}()

func SiteRefTypeValidator() db.Validator {
	return DefaultSiteRefTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteReferenceListType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteReferenceListType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteReferenceListType) DeepCopy() *SiteReferenceListType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteReferenceListType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteReferenceListType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteReferenceListType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteReferenceListTypeValidator().Validate(ctx, m, opts...)
}

func (m *SiteReferenceListType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetRefsDRefInfo()

}

func (m *SiteReferenceListType) GetRefsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRefs()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("SiteReferenceListType.refs[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "site.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "refs",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRefsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *SiteReferenceListType) GetRefsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: site")
	}
	for _, ref := range m.GetRefs() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateSiteReferenceListType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteReferenceListType) RefsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for refs")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for refs")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated refs")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items refs")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSiteReferenceListType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteReferenceListType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteReferenceListType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["refs"]; exists {
		vOpts := append(opts, db.WithValidateField("refs"))
		if err := fv(ctx, m.GetRefs(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteReferenceListTypeValidator = func() *ValidateSiteReferenceListType {
	v := &ValidateSiteReferenceListType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRefs := v.RefsValidationRuleHandler
	rulesRefs := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "64",
	}
	vFn, err = vrhRefs(rulesRefs)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SiteReferenceListType.refs: %s", err)
		panic(errMsg)
	}
	v.FldValidators["refs"] = vFn

	return v
}()

func SiteReferenceListTypeValidator() db.Validator {
	return DefaultSiteReferenceListTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteVirtualSiteRefSelector) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteVirtualSiteRefSelector) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteVirtualSiteRefSelector) DeepCopy() *SiteVirtualSiteRefSelector {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteVirtualSiteRefSelector{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteVirtualSiteRefSelector) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteVirtualSiteRefSelector) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteVirtualSiteRefSelectorValidator().Validate(ctx, m, opts...)
}

func (m *SiteVirtualSiteRefSelector) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetRefOrSelectorDRefInfo()

}

// GetDRefInfo for the field's type
func (m *SiteVirtualSiteRefSelector) GetRefOrSelectorDRefInfo() ([]db.DRefInfo, error) {
	if m.GetRefOrSelector() == nil {
		return nil, nil
	}
	switch m.GetRefOrSelector().(type) {
	case *SiteVirtualSiteRefSelector_Site:

		drInfos, err := m.GetSite().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSite().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "site." + dri.DRField
		}
		return drInfos, err

	case *SiteVirtualSiteRefSelector_VirtualSite:

		drInfos, err := m.GetVirtualSite().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetVirtualSite().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "virtual_site." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateSiteVirtualSiteRefSelector struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteVirtualSiteRefSelector) RefOrSelectorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ref_or_selector")
	}
	return validatorFn, nil
}

func (v *ValidateSiteVirtualSiteRefSelector) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteVirtualSiteRefSelector)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteVirtualSiteRefSelector got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ref_or_selector"]; exists {
		val := m.GetRefOrSelector()
		vOpts := append(opts,
			db.WithValidateField("ref_or_selector"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetRefOrSelector().(type) {
	case *SiteVirtualSiteRefSelector_Site:
		if fv, exists := v.FldValidators["ref_or_selector.site"]; exists {
			val := m.GetRefOrSelector().(*SiteVirtualSiteRefSelector_Site).Site
			vOpts := append(opts,
				db.WithValidateField("ref_or_selector"),
				db.WithValidateField("site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SiteVirtualSiteRefSelector_VirtualSite:
		if fv, exists := v.FldValidators["ref_or_selector.virtual_site"]; exists {
			val := m.GetRefOrSelector().(*SiteVirtualSiteRefSelector_VirtualSite).VirtualSite
			vOpts := append(opts,
				db.WithValidateField("ref_or_selector"),
				db.WithValidateField("virtual_site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteVirtualSiteRefSelectorValidator = func() *ValidateSiteVirtualSiteRefSelector {
	v := &ValidateSiteVirtualSiteRefSelector{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRefOrSelector := v.RefOrSelectorValidationRuleHandler
	rulesRefOrSelector := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhRefOrSelector(rulesRefOrSelector)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SiteVirtualSiteRefSelector.ref_or_selector: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ref_or_selector"] = vFn

	v.FldValidators["ref_or_selector.site"] = SiteRefTypeValidator().Validate
	v.FldValidators["ref_or_selector.virtual_site"] = VSiteRefTypeValidator().Validate

	return v
}()

func SiteVirtualSiteRefSelectorValidator() db.Validator {
	return DefaultSiteVirtualSiteRefSelectorValidator
}

// augmented methods on protoc/std generated struct

func (m *StaticRouteType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StaticRouteType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StaticRouteType) DeepCopy() *StaticRouteType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StaticRouteType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StaticRouteType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StaticRouteType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StaticRouteTypeValidator().Validate(ctx, m, opts...)
}

func (m *StaticRouteType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetNexthopDRefInfo()

}

// GetDRefInfo for the field's type
func (m *StaticRouteType) GetNexthopDRefInfo() ([]db.DRefInfo, error) {
	if m.GetNexthop() == nil {
		return nil, nil
	}

	drInfos, err := m.GetNexthop().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetNexthop().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "nexthop." + dri.DRField
	}
	return drInfos, err

}

type ValidateStaticRouteType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStaticRouteType) AttrsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(RouteAttrType)
		return int32(i)
	}
	// RouteAttrType_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, RouteAttrType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for attrs")
	}
	itemsValidatorFn := func(ctx context.Context, elems []RouteAttrType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for attrs")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]RouteAttrType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []RouteAttrType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated attrs")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items attrs")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateStaticRouteType) SubnetsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for subnets")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*IpSubnetType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := IpSubnetTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for subnets")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*IpSubnetType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*IpSubnetType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated subnets")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items subnets")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateStaticRouteType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StaticRouteType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StaticRouteType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["attrs"]; exists {
		vOpts := append(opts, db.WithValidateField("attrs"))
		if err := fv(ctx, m.GetAttrs(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["labels"]; exists {

		vOpts := append(opts, db.WithValidateField("labels"))
		for key, value := range m.GetLabels() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["nexthop"]; exists {

		vOpts := append(opts, db.WithValidateField("nexthop"))
		if err := fv(ctx, m.GetNexthop(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["subnets"]; exists {
		vOpts := append(opts, db.WithValidateField("subnets"))
		if err := fv(ctx, m.GetSubnets(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStaticRouteTypeValidator = func() *ValidateStaticRouteType {
	v := &ValidateStaticRouteType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAttrs := v.AttrsValidationRuleHandler
	rulesAttrs := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhAttrs(rulesAttrs)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StaticRouteType.attrs: %s", err)
		panic(errMsg)
	}
	v.FldValidators["attrs"] = vFn

	vrhSubnets := v.SubnetsValidationRuleHandler
	rulesSubnets := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "256",
	}
	vFn, err = vrhSubnets(rulesSubnets)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StaticRouteType.subnets: %s", err)
		panic(errMsg)
	}
	v.FldValidators["subnets"] = vFn

	v.FldValidators["nexthop"] = NextHopTypeValidator().Validate

	return v
}()

func StaticRouteTypeValidator() db.Validator {
	return DefaultStaticRouteTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *StatusMetaType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StatusMetaType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StatusMetaType) DeepCopy() *StatusMetaType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StatusMetaType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StatusMetaType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StatusMetaType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StatusMetaTypeValidator().Validate(ctx, m, opts...)
}

// SetCreationTimestamp sets the field
func (m *StatusMetaType) SetCreationTimestamp(in *google_protobuf.Timestamp) {
	m.CreationTimestamp = in
}

// SetCreatorClass sets the field
func (m *StatusMetaType) SetCreatorClass(in string) {
	m.CreatorClass = in
}

// SetCreatorId sets the field
func (m *StatusMetaType) SetCreatorId(in string) {
	m.CreatorId = in
}

// SetStatusId sets the field
func (m *StatusMetaType) SetStatusId(in string) {
	m.StatusId = in
}

// SetUid sets the field
func (m *StatusMetaType) SetUid(in string) {
	m.Uid = in
}

// SetVtrpId sets the field
func (m *StatusMetaType) SetVtrpId(in string) {
	m.VtrpId = in
}

// SetVtrpStale sets the field
func (m *StatusMetaType) SetVtrpStale(in bool) {
	m.VtrpStale = in
}

type ValidateStatusMetaType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStatusMetaType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StatusMetaType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StatusMetaType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["creation_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("creation_timestamp"))
		if err := fv(ctx, m.GetCreationTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["creator_class"]; exists {

		vOpts := append(opts, db.WithValidateField("creator_class"))
		if err := fv(ctx, m.GetCreatorClass(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["creator_id"]; exists {

		vOpts := append(opts, db.WithValidateField("creator_id"))
		if err := fv(ctx, m.GetCreatorId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["publish"]; exists {

		vOpts := append(opts, db.WithValidateField("publish"))
		if err := fv(ctx, m.GetPublish(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status_id"]; exists {

		vOpts := append(opts, db.WithValidateField("status_id"))
		if err := fv(ctx, m.GetStatusId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["uid"]; exists {

		vOpts := append(opts, db.WithValidateField("uid"))
		if err := fv(ctx, m.GetUid(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vtrp_id"]; exists {

		vOpts := append(opts, db.WithValidateField("vtrp_id"))
		if err := fv(ctx, m.GetVtrpId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vtrp_stale"]; exists {

		vOpts := append(opts, db.WithValidateField("vtrp_stale"))
		if err := fv(ctx, m.GetVtrpStale(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStatusMetaTypeValidator = func() *ValidateStatusMetaType {
	v := &ValidateStatusMetaType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func StatusMetaTypeValidator() db.Validator {
	return DefaultStatusMetaTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *StatusType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StatusType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StatusType) DeepCopy() *StatusType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StatusType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StatusType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StatusType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StatusTypeValidator().Validate(ctx, m, opts...)
}

type ValidateStatusType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStatusType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StatusType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StatusType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["code"]; exists {

		vOpts := append(opts, db.WithValidateField("code"))
		if err := fv(ctx, m.GetCode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["reason"]; exists {

		vOpts := append(opts, db.WithValidateField("reason"))
		if err := fv(ctx, m.GetReason(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStatusTypeValidator = func() *ValidateStatusType {
	v := &ValidateStatusType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func StatusTypeValidator() db.Validator {
	return DefaultStatusTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SystemObjectGetMetaType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SystemObjectGetMetaType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SystemObjectGetMetaType) DeepCopy() *SystemObjectGetMetaType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SystemObjectGetMetaType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SystemObjectGetMetaType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SystemObjectGetMetaType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SystemObjectGetMetaTypeValidator().Validate(ctx, m, opts...)
}

// SetLabels sets the field
func (m *SystemObjectGetMetaType) SetLabels(in map[string]string) {
	m.Labels = in
}

type ValidateSystemObjectGetMetaType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSystemObjectGetMetaType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SystemObjectGetMetaType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SystemObjectGetMetaType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["creation_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("creation_timestamp"))
		if err := fv(ctx, m.GetCreationTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["creator_class"]; exists {

		vOpts := append(opts, db.WithValidateField("creator_class"))
		if err := fv(ctx, m.GetCreatorClass(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["creator_id"]; exists {

		vOpts := append(opts, db.WithValidateField("creator_id"))
		if err := fv(ctx, m.GetCreatorId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["deletion_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("deletion_timestamp"))
		if err := fv(ctx, m.GetDeletionTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["finalizers"]; exists {

		vOpts := append(opts, db.WithValidateField("finalizers"))
		for idx, item := range m.GetFinalizers() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["initializers"]; exists {

		vOpts := append(opts, db.WithValidateField("initializers"))
		if err := fv(ctx, m.GetInitializers(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["labels"]; exists {

		vOpts := append(opts, db.WithValidateField("labels"))
		for key, value := range m.GetLabels() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["modification_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("modification_timestamp"))
		if err := fv(ctx, m.GetModificationTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["object_index"]; exists {

		vOpts := append(opts, db.WithValidateField("object_index"))
		if err := fv(ctx, m.GetObjectIndex(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["owner_view"]; exists {

		vOpts := append(opts, db.WithValidateField("owner_view"))
		if err := fv(ctx, m.GetOwnerView(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tenant"]; exists {

		vOpts := append(opts, db.WithValidateField("tenant"))
		if err := fv(ctx, m.GetTenant(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["uid"]; exists {

		vOpts := append(opts, db.WithValidateField("uid"))
		if err := fv(ctx, m.GetUid(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSystemObjectGetMetaTypeValidator = func() *ValidateSystemObjectGetMetaType {
	v := &ValidateSystemObjectGetMetaType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SystemObjectGetMetaTypeValidator() db.Validator {
	return DefaultSystemObjectGetMetaTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SystemObjectMetaType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SystemObjectMetaType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SystemObjectMetaType) DeepCopy() *SystemObjectMetaType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SystemObjectMetaType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SystemObjectMetaType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SystemObjectMetaType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SystemObjectMetaTypeValidator().Validate(ctx, m, opts...)
}

func (m *SystemObjectMetaType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetNamespaceDRefInfo()

}

// SetCreationTimestamp sets the field
func (m *SystemObjectMetaType) SetCreationTimestamp(in *google_protobuf.Timestamp) {
	m.CreationTimestamp = in
}

// SetCreatorClass sets the field
func (m *SystemObjectMetaType) SetCreatorClass(in string) {
	m.CreatorClass = in
}

// SetCreatorCookie sets the field
func (m *SystemObjectMetaType) SetCreatorCookie(in string) {
	m.CreatorCookie = in
}

// SetCreatorId sets the field
func (m *SystemObjectMetaType) SetCreatorId(in string) {
	m.CreatorId = in
}

// SetLabels sets the field
func (m *SystemObjectMetaType) SetLabels(in map[string]string) {
	m.Labels = in
}

// SetModificationTimestamp sets the field
func (m *SystemObjectMetaType) SetModificationTimestamp(in *google_protobuf.Timestamp) {
	m.ModificationTimestamp = in
}

// SetObjectIndex sets the field
func (m *SystemObjectMetaType) SetObjectIndex(in uint32) {
	m.ObjectIndex = in
}

// SetSreDisable sets the field
func (m *SystemObjectMetaType) SetSreDisable(in bool) {
	m.SreDisable = in
}

// SetTenant sets the field
func (m *SystemObjectMetaType) SetTenant(in string) {
	m.Tenant = in
}

// SetTraceInfo sets the field
func (m *SystemObjectMetaType) SetTraceInfo(in string) {
	m.TraceInfo = in
}

// SetUid sets the field
func (m *SystemObjectMetaType) SetUid(in string) {
	m.Uid = in
}

// SetVtrpId sets the field
func (m *SystemObjectMetaType) SetVtrpId(in string) {
	m.VtrpId = in
}

// SetVtrpStale sets the field
func (m *SystemObjectMetaType) SetVtrpStale(in bool) {
	m.VtrpStale = in
}

func (m *SystemObjectMetaType) GetNamespaceDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetNamespace()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("SystemObjectMetaType.namespace[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "namespace.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "namespace",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetNamespaceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *SystemObjectMetaType) GetNamespaceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "namespace.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: namespace")
	}
	for _, ref := range m.GetNamespace() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateSystemObjectMetaType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSystemObjectMetaType) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for namespace")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for namespace")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated namespace")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items namespace")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSystemObjectMetaType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SystemObjectMetaType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SystemObjectMetaType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["creation_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("creation_timestamp"))
		if err := fv(ctx, m.GetCreationTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["creator_class"]; exists {

		vOpts := append(opts, db.WithValidateField("creator_class"))
		if err := fv(ctx, m.GetCreatorClass(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["creator_cookie"]; exists {

		vOpts := append(opts, db.WithValidateField("creator_cookie"))
		if err := fv(ctx, m.GetCreatorCookie(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["creator_id"]; exists {

		vOpts := append(opts, db.WithValidateField("creator_id"))
		if err := fv(ctx, m.GetCreatorId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["deletion_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("deletion_timestamp"))
		if err := fv(ctx, m.GetDeletionTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["finalizers"]; exists {

		vOpts := append(opts, db.WithValidateField("finalizers"))
		for idx, item := range m.GetFinalizers() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["initializers"]; exists {

		vOpts := append(opts, db.WithValidateField("initializers"))
		if err := fv(ctx, m.GetInitializers(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["labels"]; exists {

		vOpts := append(opts, db.WithValidateField("labels"))
		for key, value := range m.GetLabels() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["modification_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("modification_timestamp"))
		if err := fv(ctx, m.GetModificationTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {
		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["object_index"]; exists {

		vOpts := append(opts, db.WithValidateField("object_index"))
		if err := fv(ctx, m.GetObjectIndex(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["owner_view"]; exists {

		vOpts := append(opts, db.WithValidateField("owner_view"))
		if err := fv(ctx, m.GetOwnerView(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sre_disable"]; exists {

		vOpts := append(opts, db.WithValidateField("sre_disable"))
		if err := fv(ctx, m.GetSreDisable(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tenant"]; exists {

		vOpts := append(opts, db.WithValidateField("tenant"))
		if err := fv(ctx, m.GetTenant(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["trace_info"]; exists {

		vOpts := append(opts, db.WithValidateField("trace_info"))
		if err := fv(ctx, m.GetTraceInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["uid"]; exists {

		vOpts := append(opts, db.WithValidateField("uid"))
		if err := fv(ctx, m.GetUid(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vtrp_id"]; exists {

		vOpts := append(opts, db.WithValidateField("vtrp_id"))
		if err := fv(ctx, m.GetVtrpId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vtrp_stale"]; exists {

		vOpts := append(opts, db.WithValidateField("vtrp_stale"))
		if err := fv(ctx, m.GetVtrpStale(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSystemObjectMetaTypeValidator = func() *ValidateSystemObjectMetaType {
	v := &ValidateSystemObjectMetaType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SystemObjectMetaType.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	return v
}()

func SystemObjectMetaTypeValidator() db.Validator {
	return DefaultSystemObjectMetaTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TlsCertificateType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TlsCertificateType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *TlsCertificateType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetPrivateKey().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting TlsCertificateType.private_key")
	}

	return nil
}

func (m *TlsCertificateType) DeepCopy() *TlsCertificateType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TlsCertificateType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TlsCertificateType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TlsCertificateType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TlsCertificateTypeValidator().Validate(ctx, m, opts...)
}

type ValidateTlsCertificateType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTlsCertificateType) CertificateUrlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for certificate_url")
	}

	return validatorFn, nil
}

func (v *ValidateTlsCertificateType) PrivateKeyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for private_key")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := SecretTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateTlsCertificateType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TlsCertificateType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TlsCertificateType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["certificate_url"]; exists {

		vOpts := append(opts, db.WithValidateField("certificate_url"))
		if err := fv(ctx, m.GetCertificateUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetOcspStaplingChoice().(type) {
	case *TlsCertificateType_UseSystemDefaults:
		if fv, exists := v.FldValidators["ocsp_stapling_choice.use_system_defaults"]; exists {
			val := m.GetOcspStaplingChoice().(*TlsCertificateType_UseSystemDefaults).UseSystemDefaults
			vOpts := append(opts,
				db.WithValidateField("ocsp_stapling_choice"),
				db.WithValidateField("use_system_defaults"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TlsCertificateType_DisableOcspStapling:
		if fv, exists := v.FldValidators["ocsp_stapling_choice.disable_ocsp_stapling"]; exists {
			val := m.GetOcspStaplingChoice().(*TlsCertificateType_DisableOcspStapling).DisableOcspStapling
			vOpts := append(opts,
				db.WithValidateField("ocsp_stapling_choice"),
				db.WithValidateField("disable_ocsp_stapling"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TlsCertificateType_CustomHashAlgorithms:
		if fv, exists := v.FldValidators["ocsp_stapling_choice.custom_hash_algorithms"]; exists {
			val := m.GetOcspStaplingChoice().(*TlsCertificateType_CustomHashAlgorithms).CustomHashAlgorithms
			vOpts := append(opts,
				db.WithValidateField("ocsp_stapling_choice"),
				db.WithValidateField("custom_hash_algorithms"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["private_key"]; exists {

		vOpts := append(opts, db.WithValidateField("private_key"))
		if err := fv(ctx, m.GetPrivateKey(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTlsCertificateTypeValidator = func() *ValidateTlsCertificateType {
	v := &ValidateTlsCertificateType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCertificateUrl := v.CertificateUrlValidationRuleHandler
	rulesCertificateUrl := map[string]string{
		"ves.io.schema.rules.message.required":       "true",
		"ves.io.schema.rules.string.certificate_url": "true",
		"ves.io.schema.rules.string.max_bytes":       "131072",
		"ves.io.schema.rules.string.min_bytes":       "1",
	}
	vFn, err = vrhCertificateUrl(rulesCertificateUrl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TlsCertificateType.certificate_url: %s", err)
		panic(errMsg)
	}
	v.FldValidators["certificate_url"] = vFn

	vrhPrivateKey := v.PrivateKeyValidationRuleHandler
	rulesPrivateKey := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPrivateKey(rulesPrivateKey)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TlsCertificateType.private_key: %s", err)
		panic(errMsg)
	}
	v.FldValidators["private_key"] = vFn

	v.FldValidators["ocsp_stapling_choice.custom_hash_algorithms"] = HashAlgorithmsValidator().Validate

	return v
}()

func TlsCertificateTypeValidator() db.Validator {
	return DefaultTlsCertificateTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TlsInterceptionPolicy) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TlsInterceptionPolicy) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TlsInterceptionPolicy) DeepCopy() *TlsInterceptionPolicy {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TlsInterceptionPolicy{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TlsInterceptionPolicy) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TlsInterceptionPolicy) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TlsInterceptionPolicyValidator().Validate(ctx, m, opts...)
}

type ValidateTlsInterceptionPolicy struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTlsInterceptionPolicy) InterceptionRulesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for interception_rules")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*TlsInterceptionRule, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := TlsInterceptionRuleValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for interception_rules")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*TlsInterceptionRule)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*TlsInterceptionRule, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated interception_rules")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items interception_rules")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateTlsInterceptionPolicy) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TlsInterceptionPolicy)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TlsInterceptionPolicy got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["interception_rules"]; exists {
		vOpts := append(opts, db.WithValidateField("interception_rules"))
		if err := fv(ctx, m.GetInterceptionRules(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTlsInterceptionPolicyValidator = func() *ValidateTlsInterceptionPolicy {
	v := &ValidateTlsInterceptionPolicy{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInterceptionRules := v.InterceptionRulesValidationRuleHandler
	rulesInterceptionRules := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhInterceptionRules(rulesInterceptionRules)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TlsInterceptionPolicy.interception_rules: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interception_rules"] = vFn

	return v
}()

func TlsInterceptionPolicyValidator() db.Validator {
	return DefaultTlsInterceptionPolicyValidator
}

// augmented methods on protoc/std generated struct

func (m *TlsInterceptionRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TlsInterceptionRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TlsInterceptionRule) DeepCopy() *TlsInterceptionRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TlsInterceptionRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TlsInterceptionRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TlsInterceptionRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TlsInterceptionRuleValidator().Validate(ctx, m, opts...)
}

type ValidateTlsInterceptionRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTlsInterceptionRule) EnableDisableChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for enable_disable_choice")
	}
	return validatorFn, nil
}

func (v *ValidateTlsInterceptionRule) DomainMatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for domain_match")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := DomainTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateTlsInterceptionRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TlsInterceptionRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TlsInterceptionRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domain_match"]; exists {

		vOpts := append(opts, db.WithValidateField("domain_match"))
		if err := fv(ctx, m.GetDomainMatch(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["enable_disable_choice"]; exists {
		val := m.GetEnableDisableChoice()
		vOpts := append(opts,
			db.WithValidateField("enable_disable_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetEnableDisableChoice().(type) {
	case *TlsInterceptionRule_DisableInterception:
		if fv, exists := v.FldValidators["enable_disable_choice.disable_interception"]; exists {
			val := m.GetEnableDisableChoice().(*TlsInterceptionRule_DisableInterception).DisableInterception
			vOpts := append(opts,
				db.WithValidateField("enable_disable_choice"),
				db.WithValidateField("disable_interception"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TlsInterceptionRule_EnableInterception:
		if fv, exists := v.FldValidators["enable_disable_choice.enable_interception"]; exists {
			val := m.GetEnableDisableChoice().(*TlsInterceptionRule_EnableInterception).EnableInterception
			vOpts := append(opts,
				db.WithValidateField("enable_disable_choice"),
				db.WithValidateField("enable_interception"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTlsInterceptionRuleValidator = func() *ValidateTlsInterceptionRule {
	v := &ValidateTlsInterceptionRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhEnableDisableChoice := v.EnableDisableChoiceValidationRuleHandler
	rulesEnableDisableChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhEnableDisableChoice(rulesEnableDisableChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TlsInterceptionRule.enable_disable_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["enable_disable_choice"] = vFn

	vrhDomainMatch := v.DomainMatchValidationRuleHandler
	rulesDomainMatch := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDomainMatch(rulesDomainMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TlsInterceptionRule.domain_match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_match"] = vFn

	return v
}()

func TlsInterceptionRuleValidator() db.Validator {
	return DefaultTlsInterceptionRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *TlsInterceptionType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TlsInterceptionType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *TlsInterceptionType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetCustomCertificate().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting TlsInterceptionType.custom_certificate")
	}

	return nil
}

func (m *TlsInterceptionType) DeepCopy() *TlsInterceptionType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TlsInterceptionType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TlsInterceptionType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TlsInterceptionType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TlsInterceptionTypeValidator().Validate(ctx, m, opts...)
}

type ValidateTlsInterceptionType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTlsInterceptionType) InterceptionPolicyChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for interception_policy_choice")
	}
	return validatorFn, nil
}

func (v *ValidateTlsInterceptionType) SigningCertChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for signing_cert_choice")
	}
	return validatorFn, nil
}

func (v *ValidateTlsInterceptionType) TrustedCaChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for trusted_ca_choice")
	}
	return validatorFn, nil
}

func (v *ValidateTlsInterceptionType) TrustedCaChoiceTrustedCaUrlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_TrustedCaUrl, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for trusted_ca_url")
	}
	return oValidatorFn_TrustedCaUrl, nil
}

func (v *ValidateTlsInterceptionType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TlsInterceptionType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TlsInterceptionType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["interception_policy_choice"]; exists {
		val := m.GetInterceptionPolicyChoice()
		vOpts := append(opts,
			db.WithValidateField("interception_policy_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetInterceptionPolicyChoice().(type) {
	case *TlsInterceptionType_Policy:
		if fv, exists := v.FldValidators["interception_policy_choice.policy"]; exists {
			val := m.GetInterceptionPolicyChoice().(*TlsInterceptionType_Policy).Policy
			vOpts := append(opts,
				db.WithValidateField("interception_policy_choice"),
				db.WithValidateField("policy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TlsInterceptionType_EnableForAllDomains:
		if fv, exists := v.FldValidators["interception_policy_choice.enable_for_all_domains"]; exists {
			val := m.GetInterceptionPolicyChoice().(*TlsInterceptionType_EnableForAllDomains).EnableForAllDomains
			vOpts := append(opts,
				db.WithValidateField("interception_policy_choice"),
				db.WithValidateField("enable_for_all_domains"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["signing_cert_choice"]; exists {
		val := m.GetSigningCertChoice()
		vOpts := append(opts,
			db.WithValidateField("signing_cert_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSigningCertChoice().(type) {
	case *TlsInterceptionType_CustomCertificate:
		if fv, exists := v.FldValidators["signing_cert_choice.custom_certificate"]; exists {
			val := m.GetSigningCertChoice().(*TlsInterceptionType_CustomCertificate).CustomCertificate
			vOpts := append(opts,
				db.WithValidateField("signing_cert_choice"),
				db.WithValidateField("custom_certificate"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TlsInterceptionType_VolterraCertificate:
		if fv, exists := v.FldValidators["signing_cert_choice.volterra_certificate"]; exists {
			val := m.GetSigningCertChoice().(*TlsInterceptionType_VolterraCertificate).VolterraCertificate
			vOpts := append(opts,
				db.WithValidateField("signing_cert_choice"),
				db.WithValidateField("volterra_certificate"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["trusted_ca_choice"]; exists {
		val := m.GetTrustedCaChoice()
		vOpts := append(opts,
			db.WithValidateField("trusted_ca_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetTrustedCaChoice().(type) {
	case *TlsInterceptionType_TrustedCaUrl:
		if fv, exists := v.FldValidators["trusted_ca_choice.trusted_ca_url"]; exists {
			val := m.GetTrustedCaChoice().(*TlsInterceptionType_TrustedCaUrl).TrustedCaUrl
			vOpts := append(opts,
				db.WithValidateField("trusted_ca_choice"),
				db.WithValidateField("trusted_ca_url"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TlsInterceptionType_VolterraTrustedCa:
		if fv, exists := v.FldValidators["trusted_ca_choice.volterra_trusted_ca"]; exists {
			val := m.GetTrustedCaChoice().(*TlsInterceptionType_VolterraTrustedCa).VolterraTrustedCa
			vOpts := append(opts,
				db.WithValidateField("trusted_ca_choice"),
				db.WithValidateField("volterra_trusted_ca"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTlsInterceptionTypeValidator = func() *ValidateTlsInterceptionType {
	v := &ValidateTlsInterceptionType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInterceptionPolicyChoice := v.InterceptionPolicyChoiceValidationRuleHandler
	rulesInterceptionPolicyChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhInterceptionPolicyChoice(rulesInterceptionPolicyChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TlsInterceptionType.interception_policy_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interception_policy_choice"] = vFn

	vrhSigningCertChoice := v.SigningCertChoiceValidationRuleHandler
	rulesSigningCertChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSigningCertChoice(rulesSigningCertChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TlsInterceptionType.signing_cert_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["signing_cert_choice"] = vFn

	vrhTrustedCaChoice := v.TrustedCaChoiceValidationRuleHandler
	rulesTrustedCaChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhTrustedCaChoice(rulesTrustedCaChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TlsInterceptionType.trusted_ca_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["trusted_ca_choice"] = vFn

	vrhTrustedCaChoiceTrustedCaUrl := v.TrustedCaChoiceTrustedCaUrlValidationRuleHandler
	rulesTrustedCaChoiceTrustedCaUrl := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "131072",
		"ves.io.schema.rules.string.uri_ref":   "true",
	}
	vFnMap["trusted_ca_choice.trusted_ca_url"], err = vrhTrustedCaChoiceTrustedCaUrl(rulesTrustedCaChoiceTrustedCaUrl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field TlsInterceptionType.trusted_ca_choice_trusted_ca_url: %s", err)
		panic(errMsg)
	}

	v.FldValidators["trusted_ca_choice.trusted_ca_url"] = vFnMap["trusted_ca_choice.trusted_ca_url"]

	v.FldValidators["interception_policy_choice.policy"] = TlsInterceptionPolicyValidator().Validate

	v.FldValidators["signing_cert_choice.custom_certificate"] = TlsCertificateTypeValidator().Validate

	return v
}()

func TlsInterceptionTypeValidator() db.Validator {
	return DefaultTlsInterceptionTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TlsValidationParamsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TlsValidationParamsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TlsValidationParamsType) DeepCopy() *TlsValidationParamsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TlsValidationParamsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TlsValidationParamsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TlsValidationParamsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TlsValidationParamsTypeValidator().Validate(ctx, m, opts...)
}

func (m *TlsValidationParamsType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetTrustedCaChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *TlsValidationParamsType) GetTrustedCaChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTrustedCaChoice() == nil {
		return nil, nil
	}
	switch m.GetTrustedCaChoice().(type) {
	case *TlsValidationParamsType_TrustedCa:

		drInfos, err := m.GetTrustedCa().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetTrustedCa().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "trusted_ca." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateTlsValidationParamsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTlsValidationParamsType) TrustedCaChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for trusted_ca_choice")
	}
	return validatorFn, nil
}

func (v *ValidateTlsValidationParamsType) TrustedCaChoiceTrustedCaUrlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_TrustedCaUrl, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for trusted_ca_url")
	}
	return oValidatorFn_TrustedCaUrl, nil
}

func (v *ValidateTlsValidationParamsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TlsValidationParamsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TlsValidationParamsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["skip_hostname_verification"]; exists {

		vOpts := append(opts, db.WithValidateField("skip_hostname_verification"))
		if err := fv(ctx, m.GetSkipHostnameVerification(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["trusted_ca_choice"]; exists {
		val := m.GetTrustedCaChoice()
		vOpts := append(opts,
			db.WithValidateField("trusted_ca_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetTrustedCaChoice().(type) {
	case *TlsValidationParamsType_TrustedCaUrl:
		if fv, exists := v.FldValidators["trusted_ca_choice.trusted_ca_url"]; exists {
			val := m.GetTrustedCaChoice().(*TlsValidationParamsType_TrustedCaUrl).TrustedCaUrl
			vOpts := append(opts,
				db.WithValidateField("trusted_ca_choice"),
				db.WithValidateField("trusted_ca_url"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TlsValidationParamsType_TrustedCa:
		if fv, exists := v.FldValidators["trusted_ca_choice.trusted_ca"]; exists {
			val := m.GetTrustedCaChoice().(*TlsValidationParamsType_TrustedCa).TrustedCa
			vOpts := append(opts,
				db.WithValidateField("trusted_ca_choice"),
				db.WithValidateField("trusted_ca"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["use_volterra_trusted_ca_url"]; exists {

		vOpts := append(opts, db.WithValidateField("use_volterra_trusted_ca_url"))
		if err := fv(ctx, m.GetUseVolterraTrustedCaUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["verify_subject_alt_names"]; exists {

		vOpts := append(opts, db.WithValidateField("verify_subject_alt_names"))
		for idx, item := range m.GetVerifySubjectAltNames() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTlsValidationParamsTypeValidator = func() *ValidateTlsValidationParamsType {
	v := &ValidateTlsValidationParamsType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTrustedCaChoice := v.TrustedCaChoiceValidationRuleHandler
	rulesTrustedCaChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhTrustedCaChoice(rulesTrustedCaChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TlsValidationParamsType.trusted_ca_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["trusted_ca_choice"] = vFn

	vrhTrustedCaChoiceTrustedCaUrl := v.TrustedCaChoiceTrustedCaUrlValidationRuleHandler
	rulesTrustedCaChoiceTrustedCaUrl := map[string]string{
		"ves.io.schema.rules.string.max_bytes":      "131072",
		"ves.io.schema.rules.string.truststore_url": "true",
	}
	vFnMap["trusted_ca_choice.trusted_ca_url"], err = vrhTrustedCaChoiceTrustedCaUrl(rulesTrustedCaChoiceTrustedCaUrl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field TlsValidationParamsType.trusted_ca_choice_trusted_ca_url: %s", err)
		panic(errMsg)
	}

	v.FldValidators["trusted_ca_choice.trusted_ca_url"] = vFnMap["trusted_ca_choice.trusted_ca_url"]

	v.FldValidators["trusted_ca_choice.trusted_ca"] = TrustedCAListValidator().Validate

	return v
}()

func TlsValidationParamsTypeValidator() db.Validator {
	return DefaultTlsValidationParamsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TrendValue) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TrendValue) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TrendValue) DeepCopy() *TrendValue {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TrendValue{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TrendValue) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TrendValue) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TrendValueValidator().Validate(ctx, m, opts...)
}

type ValidateTrendValue struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTrendValue) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TrendValue)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TrendValue got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["previous_value"]; exists {

		vOpts := append(opts, db.WithValidateField("previous_value"))
		if err := fv(ctx, m.GetPreviousValue(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sentiment"]; exists {

		vOpts := append(opts, db.WithValidateField("sentiment"))
		if err := fv(ctx, m.GetSentiment(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTrendValueValidator = func() *ValidateTrendValue {
	v := &ValidateTrendValue{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func TrendValueValidator() db.Validator {
	return DefaultTrendValueValidator
}

// augmented methods on protoc/std generated struct

func (m *TrustedCAList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TrustedCAList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TrustedCAList) DeepCopy() *TrustedCAList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TrustedCAList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TrustedCAList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TrustedCAList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TrustedCAListValidator().Validate(ctx, m, opts...)
}

func (m *TrustedCAList) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetTrustedCaListDRefInfo()

}

func (m *TrustedCAList) GetTrustedCaListDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetTrustedCaList()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("TrustedCAList.trusted_ca_list[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "trusted_ca_list.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "trusted_ca_list",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetTrustedCaListDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *TrustedCAList) GetTrustedCaListDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "trusted_ca_list.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: trusted_ca_list")
	}
	for _, ref := range m.GetTrustedCaList() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateTrustedCAList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTrustedCAList) TrustedCaListValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for trusted_ca_list")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for trusted_ca_list")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated trusted_ca_list")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items trusted_ca_list")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateTrustedCAList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TrustedCAList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TrustedCAList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["trusted_ca_list"]; exists {
		vOpts := append(opts, db.WithValidateField("trusted_ca_list"))
		if err := fv(ctx, m.GetTrustedCaList(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTrustedCAListValidator = func() *ValidateTrustedCAList {
	v := &ValidateTrustedCAList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTrustedCaList := v.TrustedCaListValidationRuleHandler
	rulesTrustedCaList := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhTrustedCaList(rulesTrustedCaList)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TrustedCAList.trusted_ca_list: %s", err)
		panic(errMsg)
	}
	v.FldValidators["trusted_ca_list"] = vFn

	return v
}()

func TrustedCAListValidator() db.Validator {
	return DefaultTrustedCAListValidator
}

// augmented methods on protoc/std generated struct

func (m *VSiteRefType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VSiteRefType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VSiteRefType) DeepCopy() *VSiteRefType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VSiteRefType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VSiteRefType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VSiteRefType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VSiteRefTypeValidator().Validate(ctx, m, opts...)
}

func (m *VSiteRefType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetRefDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRefDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRefsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRefsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *VSiteRefType) GetRefDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRef()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("VSiteRefType.ref[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_site.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "ref",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRefDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *VSiteRefType) GetRefDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_site")
	}
	for _, ref := range m.GetRef() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *VSiteRefType) GetRefsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRefs()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("VSiteRefType.refs[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_network.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "refs",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRefsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *VSiteRefType) GetRefsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
	}
	for _, ref := range m.GetRefs() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateVSiteRefType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVSiteRefType) InternetVipChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for internet_vip_choice")
	}
	return validatorFn, nil
}

func (v *ValidateVSiteRefType) RefValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for ref")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ref")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ref")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ref")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateVSiteRefType) RefsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for refs")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for refs")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated refs")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items refs")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateVSiteRefType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VSiteRefType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VSiteRefType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["internet_vip_choice"]; exists {
		val := m.GetInternetVipChoice()
		vOpts := append(opts,
			db.WithValidateField("internet_vip_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetInternetVipChoice().(type) {
	case *VSiteRefType_EnableInternetVip:
		if fv, exists := v.FldValidators["internet_vip_choice.enable_internet_vip"]; exists {
			val := m.GetInternetVipChoice().(*VSiteRefType_EnableInternetVip).EnableInternetVip
			vOpts := append(opts,
				db.WithValidateField("internet_vip_choice"),
				db.WithValidateField("enable_internet_vip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *VSiteRefType_DisableInternetVip:
		if fv, exists := v.FldValidators["internet_vip_choice.disable_internet_vip"]; exists {
			val := m.GetInternetVipChoice().(*VSiteRefType_DisableInternetVip).DisableInternetVip
			vOpts := append(opts,
				db.WithValidateField("internet_vip_choice"),
				db.WithValidateField("disable_internet_vip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["network_type"]; exists {

		vOpts := append(opts, db.WithValidateField("network_type"))
		if err := fv(ctx, m.GetNetworkType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ref"]; exists {
		vOpts := append(opts, db.WithValidateField("ref"))
		if err := fv(ctx, m.GetRef(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["refs"]; exists {
		vOpts := append(opts, db.WithValidateField("refs"))
		if err := fv(ctx, m.GetRefs(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVSiteRefTypeValidator = func() *ValidateVSiteRefType {
	v := &ValidateVSiteRefType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInternetVipChoice := v.InternetVipChoiceValidationRuleHandler
	rulesInternetVipChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhInternetVipChoice(rulesInternetVipChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VSiteRefType.internet_vip_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["internet_vip_choice"] = vFn

	vrhRef := v.RefValidationRuleHandler
	rulesRef := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhRef(rulesRef)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VSiteRefType.ref: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ref"] = vFn

	vrhRefs := v.RefsValidationRuleHandler
	rulesRefs := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhRefs(rulesRefs)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VSiteRefType.refs: %s", err)
		panic(errMsg)
	}
	v.FldValidators["refs"] = vFn

	return v
}()

func VSiteRefTypeValidator() db.Validator {
	return DefaultVSiteRefTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VaultAccessInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VaultAccessInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *VaultAccessInfoType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetAppRoleAuth().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting VaultAccessInfoType.app_role_auth")
	}

	if err := m.GetToken().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting VaultAccessInfoType.token")
	}

	return nil
}

func (m *VaultAccessInfoType) DeepCopy() *VaultAccessInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VaultAccessInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VaultAccessInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VaultAccessInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VaultAccessInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVaultAccessInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVaultAccessInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VaultAccessInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VaultAccessInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetAuthnChoice().(type) {
	case *VaultAccessInfoType_AppRoleAuth:
		if fv, exists := v.FldValidators["authn_choice.app_role_auth"]; exists {
			val := m.GetAuthnChoice().(*VaultAccessInfoType_AppRoleAuth).AppRoleAuth
			vOpts := append(opts,
				db.WithValidateField("authn_choice"),
				db.WithValidateField("app_role_auth"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *VaultAccessInfoType_Token:
		if fv, exists := v.FldValidators["authn_choice.token"]; exists {
			val := m.GetAuthnChoice().(*VaultAccessInfoType_Token).Token
			vOpts := append(opts,
				db.WithValidateField("authn_choice"),
				db.WithValidateField("token"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["vault_addr"]; exists {

		vOpts := append(opts, db.WithValidateField("vault_addr"))
		if err := fv(ctx, m.GetVaultAddr(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vault_ca_url"]; exists {

		vOpts := append(opts, db.WithValidateField("vault_ca_url"))
		if err := fv(ctx, m.GetVaultCaUrl(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVaultAccessInfoTypeValidator = func() *ValidateVaultAccessInfoType {
	v := &ValidateVaultAccessInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["authn_choice.app_role_auth"] = AppRoleAuthInfoTypeValidator().Validate
	v.FldValidators["authn_choice.token"] = SecretTypeValidator().Validate

	return v
}()

func VaultAccessInfoTypeValidator() db.Validator {
	return DefaultVaultAccessInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VaultAuthInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VaultAuthInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *VaultAuthInfoType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetAppRoleAuth().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting VaultAuthInfoType.app_role_auth")
	}

	if err := m.GetToken().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting VaultAuthInfoType.token")
	}

	return nil
}

func (m *VaultAuthInfoType) DeepCopy() *VaultAuthInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VaultAuthInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VaultAuthInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VaultAuthInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VaultAuthInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVaultAuthInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVaultAuthInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VaultAuthInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VaultAuthInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetAuthParams().(type) {
	case *VaultAuthInfoType_AppRoleAuth:
		if fv, exists := v.FldValidators["auth_params.app_role_auth"]; exists {
			val := m.GetAuthParams().(*VaultAuthInfoType_AppRoleAuth).AppRoleAuth
			vOpts := append(opts,
				db.WithValidateField("auth_params"),
				db.WithValidateField("app_role_auth"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *VaultAuthInfoType_Token:
		if fv, exists := v.FldValidators["auth_params.token"]; exists {
			val := m.GetAuthParams().(*VaultAuthInfoType_Token).Token
			vOpts := append(opts,
				db.WithValidateField("auth_params"),
				db.WithValidateField("token"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVaultAuthInfoTypeValidator = func() *ValidateVaultAuthInfoType {
	v := &ValidateVaultAuthInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["auth_params.app_role_auth"] = AppRoleAuthInfoTypeValidator().Validate
	v.FldValidators["auth_params.token"] = SecretTypeValidator().Validate

	return v
}()

func VaultAuthInfoTypeValidator() db.Validator {
	return DefaultVaultAuthInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VaultSecretInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VaultSecretInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VaultSecretInfoType) DeepCopy() *VaultSecretInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VaultSecretInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VaultSecretInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VaultSecretInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VaultSecretInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVaultSecretInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVaultSecretInfoType) ProviderValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for provider")
	}

	return validatorFn, nil
}

func (v *ValidateVaultSecretInfoType) LocationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for location")
	}

	return validatorFn, nil
}

func (v *ValidateVaultSecretInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VaultSecretInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VaultSecretInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["key"]; exists {

		vOpts := append(opts, db.WithValidateField("key"))
		if err := fv(ctx, m.GetKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["location"]; exists {

		vOpts := append(opts, db.WithValidateField("location"))
		if err := fv(ctx, m.GetLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["provider"]; exists {

		vOpts := append(opts, db.WithValidateField("provider"))
		if err := fv(ctx, m.GetProvider(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["secret_encoding"]; exists {

		vOpts := append(opts, db.WithValidateField("secret_encoding"))
		if err := fv(ctx, m.GetSecretEncoding(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVaultSecretInfoTypeValidator = func() *ValidateVaultSecretInfoType {
	v := &ValidateVaultSecretInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhProvider := v.ProviderValidationRuleHandler
	rulesProvider := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhProvider(rulesProvider)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VaultSecretInfoType.provider: %s", err)
		panic(errMsg)
	}
	v.FldValidators["provider"] = vFn

	vrhLocation := v.LocationValidationRuleHandler
	rulesLocation := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhLocation(rulesLocation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VaultSecretInfoType.location: %s", err)
		panic(errMsg)
	}
	v.FldValidators["location"] = vFn

	return v
}()

func VaultSecretInfoTypeValidator() db.Validator {
	return DefaultVaultSecretInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VaultSecretType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VaultSecretType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *VaultSecretType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetVaultAccessInfo().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting VaultSecretType.vault_access_info")
	}

	return nil
}

func (m *VaultSecretType) DeepCopy() *VaultSecretType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VaultSecretType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VaultSecretType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VaultSecretType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VaultSecretTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVaultSecretType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVaultSecretType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VaultSecretType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VaultSecretType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetAccessChoice().(type) {
	case *VaultSecretType_VaultAccessInfo:
		if fv, exists := v.FldValidators["access_choice.vault_access_info"]; exists {
			val := m.GetAccessChoice().(*VaultSecretType_VaultAccessInfo).VaultAccessInfo
			vOpts := append(opts,
				db.WithValidateField("access_choice"),
				db.WithValidateField("vault_access_info"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *VaultSecretType_ProviderName:
		if fv, exists := v.FldValidators["access_choice.provider_name"]; exists {
			val := m.GetAccessChoice().(*VaultSecretType_ProviderName).ProviderName
			vOpts := append(opts,
				db.WithValidateField("access_choice"),
				db.WithValidateField("provider_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["secret_path"]; exists {

		vOpts := append(opts, db.WithValidateField("secret_path"))
		if err := fv(ctx, m.GetSecretPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["secret_sub_path"]; exists {

		vOpts := append(opts, db.WithValidateField("secret_sub_path"))
		if err := fv(ctx, m.GetSecretSubPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["secret_version"]; exists {

		vOpts := append(opts, db.WithValidateField("secret_version"))
		if err := fv(ctx, m.GetSecretVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVaultSecretTypeValidator = func() *ValidateVaultSecretType {
	v := &ValidateVaultSecretType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["access_choice.vault_access_info"] = VaultAccessInfoTypeValidator().Validate

	return v
}()

func VaultSecretTypeValidator() db.Validator {
	return DefaultVaultSecretTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ViewRefType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ViewRefType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ViewRefType) DeepCopy() *ViewRefType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ViewRefType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ViewRefType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ViewRefType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ViewRefTypeValidator().Validate(ctx, m, opts...)
}

type ValidateViewRefType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateViewRefType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ViewRefType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ViewRefType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["kind"]; exists {

		vOpts := append(opts, db.WithValidateField("kind"))
		if err := fv(ctx, m.GetKind(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["uid"]; exists {

		vOpts := append(opts, db.WithValidateField("uid"))
		if err := fv(ctx, m.GetUid(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultViewRefTypeValidator = func() *ValidateViewRefType {
	v := &ValidateViewRefType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ViewRefTypeValidator() db.Validator {
	return DefaultViewRefTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VirtualNetworkReferenceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VirtualNetworkReferenceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VirtualNetworkReferenceType) DeepCopy() *VirtualNetworkReferenceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VirtualNetworkReferenceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VirtualNetworkReferenceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VirtualNetworkReferenceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VirtualNetworkReferenceTypeValidator().Validate(ctx, m, opts...)
}

func (m *VirtualNetworkReferenceType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetRefsDRefInfo()

}

func (m *VirtualNetworkReferenceType) GetRefsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetRefs()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("VirtualNetworkReferenceType.refs[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_network.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "refs",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetRefsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *VirtualNetworkReferenceType) GetRefsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
	}
	for _, ref := range m.GetRefs() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateVirtualNetworkReferenceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVirtualNetworkReferenceType) RefsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for refs")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for refs")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated refs")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items refs")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateVirtualNetworkReferenceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VirtualNetworkReferenceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VirtualNetworkReferenceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["refs"]; exists {
		vOpts := append(opts, db.WithValidateField("refs"))
		if err := fv(ctx, m.GetRefs(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVirtualNetworkReferenceTypeValidator = func() *ValidateVirtualNetworkReferenceType {
	v := &ValidateVirtualNetworkReferenceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRefs := v.RefsValidationRuleHandler
	rulesRefs := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhRefs(rulesRefs)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VirtualNetworkReferenceType.refs: %s", err)
		panic(errMsg)
	}
	v.FldValidators["refs"] = vFn

	return v
}()

func VirtualNetworkReferenceTypeValidator() db.Validator {
	return DefaultVirtualNetworkReferenceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VirtualNetworkSelectorType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VirtualNetworkSelectorType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VirtualNetworkSelectorType) DeepCopy() *VirtualNetworkSelectorType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VirtualNetworkSelectorType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VirtualNetworkSelectorType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VirtualNetworkSelectorType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VirtualNetworkSelectorTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVirtualNetworkSelectorType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVirtualNetworkSelectorType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VirtualNetworkSelectorType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VirtualNetworkSelectorType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetVnTypeChoice().(type) {
	case *VirtualNetworkSelectorType_SiteLocal:
		if fv, exists := v.FldValidators["vn_type_choice.site_local"]; exists {
			val := m.GetVnTypeChoice().(*VirtualNetworkSelectorType_SiteLocal).SiteLocal
			vOpts := append(opts,
				db.WithValidateField("vn_type_choice"),
				db.WithValidateField("site_local"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *VirtualNetworkSelectorType_SiteLocalInside:
		if fv, exists := v.FldValidators["vn_type_choice.site_local_inside"]; exists {
			val := m.GetVnTypeChoice().(*VirtualNetworkSelectorType_SiteLocalInside).SiteLocalInside
			vOpts := append(opts,
				db.WithValidateField("vn_type_choice"),
				db.WithValidateField("site_local_inside"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *VirtualNetworkSelectorType_Public:
		if fv, exists := v.FldValidators["vn_type_choice.public"]; exists {
			val := m.GetVnTypeChoice().(*VirtualNetworkSelectorType_Public).Public
			vOpts := append(opts,
				db.WithValidateField("vn_type_choice"),
				db.WithValidateField("public"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVirtualNetworkSelectorTypeValidator = func() *ValidateVirtualNetworkSelectorType {
	v := &ValidateVirtualNetworkSelectorType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func VirtualNetworkSelectorTypeValidator() db.Validator {
	return DefaultVirtualNetworkSelectorTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VolterraSecretType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VolterraSecretType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *VolterraSecretType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetVaultSecretInfo().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting VolterraSecretType.vault_secret_info")
	}

	return nil
}

func (m *VolterraSecretType) DeepCopy() *VolterraSecretType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VolterraSecretType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VolterraSecretType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VolterraSecretType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VolterraSecretTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVolterraSecretType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVolterraSecretType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VolterraSecretType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VolterraSecretType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetSecretTypeChoice().(type) {
	case *VolterraSecretType_BlindfoldSecretInfo:
		if fv, exists := v.FldValidators["secret_type_choice.blindfold_secret_info"]; exists {
			val := m.GetSecretTypeChoice().(*VolterraSecretType_BlindfoldSecretInfo).BlindfoldSecretInfo
			vOpts := append(opts,
				db.WithValidateField("secret_type_choice"),
				db.WithValidateField("blindfold_secret_info"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *VolterraSecretType_VaultSecretInfo:
		if fv, exists := v.FldValidators["secret_type_choice.vault_secret_info"]; exists {
			val := m.GetSecretTypeChoice().(*VolterraSecretType_VaultSecretInfo).VaultSecretInfo
			vOpts := append(opts,
				db.WithValidateField("secret_type_choice"),
				db.WithValidateField("vault_secret_info"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVolterraSecretTypeValidator = func() *ValidateVolterraSecretType {
	v := &ValidateVolterraSecretType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["secret_type_choice.blindfold_secret_info"] = BlindfoldSecretInfoTypeValidator().Validate
	v.FldValidators["secret_type_choice.vault_secret_info"] = VaultAccessInfoTypeValidator().Validate

	return v
}()

func VolterraSecretTypeValidator() db.Validator {
	return DefaultVolterraSecretTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *WafType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WafType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WafType) DeepCopy() *WafType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WafType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WafType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WafType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WafTypeValidator().Validate(ctx, m, opts...)
}

func (m *WafType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetRefTypeDRefInfo()

}

// GetDRefInfo for the field's type
func (m *WafType) GetRefTypeDRefInfo() ([]db.DRefInfo, error) {
	if m.GetRefType() == nil {
		return nil, nil
	}
	switch m.GetRefType().(type) {
	case *WafType_AppFirewall:

		drInfos, err := m.GetAppFirewall().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAppFirewall().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "app_firewall." + dri.DRField
		}
		return drInfos, err

	case *WafType_DisableWaf:

		return nil, nil

	case *WafType_InheritWaf:

		return nil, nil

	default:
		return nil, nil
	}

}

type ValidateWafType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWafType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WafType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WafType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetRefType().(type) {
	case *WafType_AppFirewall:
		if fv, exists := v.FldValidators["ref_type.app_firewall"]; exists {
			val := m.GetRefType().(*WafType_AppFirewall).AppFirewall
			vOpts := append(opts,
				db.WithValidateField("ref_type"),
				db.WithValidateField("app_firewall"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WafType_DisableWaf:
		if fv, exists := v.FldValidators["ref_type.disable_waf"]; exists {
			val := m.GetRefType().(*WafType_DisableWaf).DisableWaf
			vOpts := append(opts,
				db.WithValidateField("ref_type"),
				db.WithValidateField("disable_waf"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WafType_InheritWaf:
		if fv, exists := v.FldValidators["ref_type.inherit_waf"]; exists {
			val := m.GetRefType().(*WafType_InheritWaf).InheritWaf
			vOpts := append(opts,
				db.WithValidateField("ref_type"),
				db.WithValidateField("inherit_waf"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWafTypeValidator = func() *ValidateWafType {
	v := &ValidateWafType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["ref_type.app_firewall"] = AppFirewallRefTypeValidator().Validate

	return v
}()

func WafTypeValidator() db.Validator {
	return DefaultWafTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *WingmanSecretInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WingmanSecretInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WingmanSecretInfoType) DeepCopy() *WingmanSecretInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WingmanSecretInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WingmanSecretInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WingmanSecretInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WingmanSecretInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateWingmanSecretInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWingmanSecretInfoType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateWingmanSecretInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WingmanSecretInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WingmanSecretInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWingmanSecretInfoTypeValidator = func() *ValidateWingmanSecretInfoType {
	v := &ValidateWingmanSecretInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WingmanSecretInfoType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func WingmanSecretInfoTypeValidator() db.Validator {
	return DefaultWingmanSecretInfoTypeValidator
}

func (m *ObjectCreateMetaType) fromObjectMetaType(f *ObjectMetaType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.Annotations = f.GetAnnotations()
	m.Description = f.GetDescription()
	m.Disable = f.GetDisable()
	m.Labels = f.GetLabels()
	m.Name = f.GetName()
	m.Namespace = f.GetNamespace()
}

func (m *ObjectCreateMetaType) FromObjectMetaType(f *ObjectMetaType) {
	m.fromObjectMetaType(f, true)
}

func (m *ObjectCreateMetaType) FromObjectMetaTypeWithoutDeepCopy(f *ObjectMetaType) {
	m.fromObjectMetaType(f, false)
}

func (m *ObjectCreateMetaType) toObjectMetaType(f *ObjectMetaType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.Annotations = m1.Annotations
	f.Description = m1.Description
	f.Disable = m1.Disable
	f.Labels = m1.Labels
	f.Name = m1.Name
	f.Namespace = m1.Namespace
}

func (m *ObjectCreateMetaType) ToObjectMetaType(f *ObjectMetaType) {
	m.toObjectMetaType(f, true)
}

func (m *ObjectCreateMetaType) ToObjectMetaTypeWithoutDeepCopy(f *ObjectMetaType) {
	m.toObjectMetaType(f, false)
}

func (m *ObjectGetMetaType) fromObjectMetaType(f *ObjectMetaType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.Annotations = f.GetAnnotations()
	m.Description = f.GetDescription()
	m.Disable = f.GetDisable()
	m.Labels = f.GetLabels()
	m.Name = f.GetName()
	m.Namespace = f.GetNamespace()
}

func (m *ObjectGetMetaType) FromObjectMetaType(f *ObjectMetaType) {
	m.fromObjectMetaType(f, true)
}

func (m *ObjectGetMetaType) FromObjectMetaTypeWithoutDeepCopy(f *ObjectMetaType) {
	m.fromObjectMetaType(f, false)
}

func (m *ObjectGetMetaType) toObjectMetaType(f *ObjectMetaType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.Annotations = m1.Annotations
	f.Description = m1.Description
	f.Disable = m1.Disable
	f.Labels = m1.Labels
	f.Name = m1.Name
	f.Namespace = m1.Namespace
}

func (m *ObjectGetMetaType) ToObjectMetaType(f *ObjectMetaType) {
	m.toObjectMetaType(f, true)
}

func (m *ObjectGetMetaType) ToObjectMetaTypeWithoutDeepCopy(f *ObjectMetaType) {
	m.toObjectMetaType(f, false)
}

func (m *ObjectReplaceMetaType) fromObjectMetaType(f *ObjectMetaType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.Annotations = f.GetAnnotations()
	m.Description = f.GetDescription()
	m.Disable = f.GetDisable()
	m.Labels = f.GetLabels()
	m.Name = f.GetName()
	m.Namespace = f.GetNamespace()
}

func (m *ObjectReplaceMetaType) FromObjectMetaType(f *ObjectMetaType) {
	m.fromObjectMetaType(f, true)
}

func (m *ObjectReplaceMetaType) FromObjectMetaTypeWithoutDeepCopy(f *ObjectMetaType) {
	m.fromObjectMetaType(f, false)
}

func (m *ObjectReplaceMetaType) toObjectMetaType(f *ObjectMetaType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.Annotations = m1.Annotations
	f.Description = m1.Description
	f.Disable = m1.Disable
	f.Labels = m1.Labels
	f.Name = m1.Name
	f.Namespace = m1.Namespace
}

func (m *ObjectReplaceMetaType) ToObjectMetaType(f *ObjectMetaType) {
	m.toObjectMetaType(f, true)
}

func (m *ObjectReplaceMetaType) ToObjectMetaTypeWithoutDeepCopy(f *ObjectMetaType) {
	m.toObjectMetaType(f, false)
}

func (m *SystemObjectGetMetaType) fromSystemObjectMetaType(f *SystemObjectMetaType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.CreationTimestamp = f.GetCreationTimestamp()
	m.CreatorClass = f.GetCreatorClass()
	m.CreatorId = f.GetCreatorId()
	m.DeletionTimestamp = f.GetDeletionTimestamp()
	m.Finalizers = f.GetFinalizers()
	m.Initializers = f.GetInitializers()
	m.Labels = f.GetLabels()
	m.ModificationTimestamp = f.GetModificationTimestamp()
	m.ObjectIndex = f.GetObjectIndex()
	m.OwnerView = f.GetOwnerView()
	m.Tenant = f.GetTenant()
	m.Uid = f.GetUid()
}

func (m *SystemObjectGetMetaType) FromSystemObjectMetaType(f *SystemObjectMetaType) {
	m.fromSystemObjectMetaType(f, true)
}

func (m *SystemObjectGetMetaType) FromSystemObjectMetaTypeWithoutDeepCopy(f *SystemObjectMetaType) {
	m.fromSystemObjectMetaType(f, false)
}

func (m *SystemObjectGetMetaType) toSystemObjectMetaType(f *SystemObjectMetaType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.CreationTimestamp = m1.CreationTimestamp
	f.CreatorClass = m1.CreatorClass
	f.CreatorId = m1.CreatorId
	f.DeletionTimestamp = m1.DeletionTimestamp
	f.Finalizers = m1.Finalizers
	f.Initializers = m1.Initializers
	f.Labels = m1.Labels
	f.ModificationTimestamp = m1.ModificationTimestamp
	f.ObjectIndex = m1.ObjectIndex
	f.OwnerView = m1.OwnerView
	f.Tenant = m1.Tenant
	f.Uid = m1.Uid
}

func (m *SystemObjectGetMetaType) ToSystemObjectMetaType(f *SystemObjectMetaType) {
	m.toSystemObjectMetaType(f, true)
}

func (m *SystemObjectGetMetaType) ToSystemObjectMetaTypeWithoutDeepCopy(f *SystemObjectMetaType) {
	m.toSystemObjectMetaType(f, false)
}
