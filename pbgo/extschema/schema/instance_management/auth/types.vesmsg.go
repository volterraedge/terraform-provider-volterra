// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package auth

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *Auth) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Auth) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Auth) String() string {
	if m == nil {
		return ""
	}
	copy := m.DeepCopy()
	copy.ClientSecret = ""

	return copy.string()
}

func (m *Auth) GoString() string {
	copy := m.DeepCopy()
	copy.ClientSecret = ""

	return copy.goString()
}

// Redact squashes sensitive info in m (in-place)
func (m *Auth) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	m.ClientSecret = ""

	return nil
}

func (m *Auth) DeepCopy() *Auth {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Auth{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Auth) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Auth) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AuthValidator().Validate(ctx, m, opts...)
}

type ValidateAuth struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAuth) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Auth)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Auth got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["allowed_redirect_urls"]; exists {

		vOpts := append(opts, db.WithValidateField("allowed_redirect_urls"))
		for idx, item := range m.GetAllowedRedirectUrls() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["authentication_flow"]; exists {

		vOpts := append(opts, db.WithValidateField("authentication_flow"))
		if err := fv(ctx, m.GetAuthenticationFlow(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["authorization_endpoint"]; exists {

		vOpts := append(opts, db.WithValidateField("authorization_endpoint"))
		if err := fv(ctx, m.GetAuthorizationEndpoint(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["client_id"]; exists {

		vOpts := append(opts, db.WithValidateField("client_id"))
		if err := fv(ctx, m.GetClientId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["client_secret"]; exists {

		vOpts := append(opts, db.WithValidateField("client_secret"))
		if err := fv(ctx, m.GetClientSecret(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_post_logout_redirect_uri"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_post_logout_redirect_uri"))
		if err := fv(ctx, m.GetDisablePostLogoutRedirectUri(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["end_session_endpoint"]; exists {

		vOpts := append(opts, db.WithValidateField("end_session_endpoint"))
		if err := fv(ctx, m.GetEndSessionEndpoint(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["jwks_uri"]; exists {

		vOpts := append(opts, db.WithValidateField("jwks_uri"))
		if err := fv(ctx, m.GetJwksUri(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["oidc_provider_name"]; exists {

		vOpts := append(opts, db.WithValidateField("oidc_provider_name"))
		if err := fv(ctx, m.GetOidcProviderName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["redirect_uri"]; exists {

		vOpts := append(opts, db.WithValidateField("redirect_uri"))
		if err := fv(ctx, m.GetRedirectUri(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["token_endpoint"]; exists {

		vOpts := append(opts, db.WithValidateField("token_endpoint"))
		if err := fv(ctx, m.GetTokenEndpoint(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAuthValidator = func() *ValidateAuth {
	v := &ValidateAuth{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func AuthValidator() db.Validator {
	return DefaultAuthValidator
}

// augmented methods on protoc/std generated struct

func (m *Session) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Session) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Session) String() string {
	if m == nil {
		return ""
	}
	copy := m.DeepCopy()
	copy.HmacKey = ""
	copy.HmacKeySecondary = ""

	return copy.string()
}

func (m *Session) GoString() string {
	copy := m.DeepCopy()
	copy.HmacKey = ""
	copy.HmacKeySecondary = ""

	return copy.goString()
}

// Redact squashes sensitive info in m (in-place)
func (m *Session) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	m.HmacKey = ""
	m.HmacKeySecondary = ""

	return nil
}

func (m *Session) DeepCopy() *Session {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Session{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Session) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Session) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SessionValidator().Validate(ctx, m, opts...)
}

type ValidateSession struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSession) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Session)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Session got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cookie_expiry"]; exists {

		vOpts := append(opts, db.WithValidateField("cookie_expiry"))
		if err := fv(ctx, m.GetCookieExpiry(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cookie_refresh_interval"]; exists {

		vOpts := append(opts, db.WithValidateField("cookie_refresh_interval"))
		if err := fv(ctx, m.GetCookieRefreshInterval(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["csrf_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("csrf_enabled"))
		if err := fv(ctx, m.GetCsrfEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["csrf_token_uri"]; exists {

		vOpts := append(opts, db.WithValidateField("csrf_token_uri"))
		if err := fv(ctx, m.GetCsrfTokenUri(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["hmac_key"]; exists {

		vOpts := append(opts, db.WithValidateField("hmac_key"))
		if err := fv(ctx, m.GetHmacKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["hmac_key_secondary"]; exists {

		vOpts := append(opts, db.WithValidateField("hmac_key_secondary"))
		if err := fv(ctx, m.GetHmacKeySecondary(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["logout_uri"]; exists {

		vOpts := append(opts, db.WithValidateField("logout_uri"))
		if err := fv(ctx, m.GetLogoutUri(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["redirect_origin_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("redirect_origin_enabled"))
		if err := fv(ctx, m.GetRedirectOriginEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["session_expiry"]; exists {

		vOpts := append(opts, db.WithValidateField("session_expiry"))
		if err := fv(ctx, m.GetSessionExpiry(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSessionValidator = func() *ValidateSession {
	v := &ValidateSession{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SessionValidator() db.Validator {
	return DefaultSessionValidator
}
