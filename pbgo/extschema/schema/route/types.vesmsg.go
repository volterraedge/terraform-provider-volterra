// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package route

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *BotDefenseJavascriptInjectionType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BotDefenseJavascriptInjectionType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BotDefenseJavascriptInjectionType) DeepCopy() *BotDefenseJavascriptInjectionType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BotDefenseJavascriptInjectionType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BotDefenseJavascriptInjectionType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BotDefenseJavascriptInjectionType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BotDefenseJavascriptInjectionTypeValidator().Validate(ctx, m, opts...)
}

type ValidateBotDefenseJavascriptInjectionType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBotDefenseJavascriptInjectionType) JavascriptTagsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for javascript_tags")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*JavaScriptTag, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := JavaScriptTagValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for javascript_tags")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*JavaScriptTag)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*JavaScriptTag, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated javascript_tags")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items javascript_tags")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateBotDefenseJavascriptInjectionType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BotDefenseJavascriptInjectionType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BotDefenseJavascriptInjectionType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["javascript_location"]; exists {

		vOpts := append(opts, db.WithValidateField("javascript_location"))
		if err := fv(ctx, m.GetJavascriptLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["javascript_tags"]; exists {
		vOpts := append(opts, db.WithValidateField("javascript_tags"))
		if err := fv(ctx, m.GetJavascriptTags(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBotDefenseJavascriptInjectionTypeValidator = func() *ValidateBotDefenseJavascriptInjectionType {
	v := &ValidateBotDefenseJavascriptInjectionType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhJavascriptTags := v.JavascriptTagsValidationRuleHandler
	rulesJavascriptTags := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "5",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhJavascriptTags(rulesJavascriptTags)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BotDefenseJavascriptInjectionType.javascript_tags: %s", err)
		panic(errMsg)
	}
	v.FldValidators["javascript_tags"] = vFn

	return v
}()

func BotDefenseJavascriptInjectionTypeValidator() db.Validator {
	return DefaultBotDefenseJavascriptInjectionTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ContentRewriteType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ContentRewriteType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ContentRewriteType) DeepCopy() *ContentRewriteType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ContentRewriteType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ContentRewriteType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ContentRewriteType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ContentRewriteTypeValidator().Validate(ctx, m, opts...)
}

type ValidateContentRewriteType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateContentRewriteType) InsertContentValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for insert_content")
	}

	return validatorFn, nil
}

func (v *ValidateContentRewriteType) ElementSelectorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for element_selector")
	}

	return validatorFn, nil
}

func (v *ValidateContentRewriteType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ContentRewriteType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ContentRewriteType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["element_selector"]; exists {

		vOpts := append(opts, db.WithValidateField("element_selector"))
		if err := fv(ctx, m.GetElementSelector(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["insert_content"]; exists {

		vOpts := append(opts, db.WithValidateField("insert_content"))
		if err := fv(ctx, m.GetInsertContent(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["position"]; exists {

		vOpts := append(opts, db.WithValidateField("position"))
		if err := fv(ctx, m.GetPosition(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultContentRewriteTypeValidator = func() *ValidateContentRewriteType {
	v := &ValidateContentRewriteType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInsertContent := v.InsertContentValidationRuleHandler
	rulesInsertContent := map[string]string{
		"ves.io.schema.rules.string.max_len": "8096",
	}
	vFn, err = vrhInsertContent(rulesInsertContent)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ContentRewriteType.insert_content: %s", err)
		panic(errMsg)
	}
	v.FldValidators["insert_content"] = vFn

	vrhElementSelector := v.ElementSelectorValidationRuleHandler
	rulesElementSelector := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhElementSelector(rulesElementSelector)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ContentRewriteType.element_selector: %s", err)
		panic(errMsg)
	}
	v.FldValidators["element_selector"] = vFn

	return v
}()

func ContentRewriteTypeValidator() db.Validator {
	return DefaultContentRewriteTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ContextExtensionInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ContextExtensionInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ContextExtensionInfo) DeepCopy() *ContextExtensionInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ContextExtensionInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ContextExtensionInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ContextExtensionInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ContextExtensionInfoValidator().Validate(ctx, m, opts...)
}

type ValidateContextExtensionInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateContextExtensionInfo) ContextExtensionsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for context_extensions")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for context_extensions")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for context_extensions")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map context_extensions")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items context_extensions")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateContextExtensionInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ContextExtensionInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ContextExtensionInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["context_extensions"]; exists {
		vOpts := append(opts, db.WithValidateField("context_extensions"))
		if err := fv(ctx, m.GetContextExtensions(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultContextExtensionInfoValidator = func() *ValidateContextExtensionInfo {
	v := &ValidateContextExtensionInfo{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhContextExtensions := v.ContextExtensionsValidationRuleHandler
	rulesContextExtensions := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len":   "64",
		"ves.io.schema.rules.map.keys.string.min_len":   "1",
		"ves.io.schema.rules.map.max_pairs":             "16",
		"ves.io.schema.rules.map.values.string.max_len": "256",
		"ves.io.schema.rules.map.values.string.min_len": "1",
	}
	vFn, err = vrhContextExtensions(rulesContextExtensions)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ContextExtensionInfo.context_extensions: %s", err)
		panic(errMsg)
	}
	v.FldValidators["context_extensions"] = vFn

	return v
}()

func ContextExtensionInfoValidator() db.Validator {
	return DefaultContextExtensionInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *CookieForHashing) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CookieForHashing) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CookieForHashing) DeepCopy() *CookieForHashing {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CookieForHashing{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CookieForHashing) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CookieForHashing) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CookieForHashingValidator().Validate(ctx, m, opts...)
}

type ValidateCookieForHashing struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCookieForHashing) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateCookieForHashing) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CookieForHashing)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CookieForHashing got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetHttponly().(type) {
	case *CookieForHashing_IgnoreHttponly:
		if fv, exists := v.FldValidators["httponly.ignore_httponly"]; exists {
			val := m.GetHttponly().(*CookieForHashing_IgnoreHttponly).IgnoreHttponly
			vOpts := append(opts,
				db.WithValidateField("httponly"),
				db.WithValidateField("ignore_httponly"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CookieForHashing_AddHttponly:
		if fv, exists := v.FldValidators["httponly.add_httponly"]; exists {
			val := m.GetHttponly().(*CookieForHashing_AddHttponly).AddHttponly
			vOpts := append(opts,
				db.WithValidateField("httponly"),
				db.WithValidateField("add_httponly"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetSamesite().(type) {
	case *CookieForHashing_IgnoreSamesite:
		if fv, exists := v.FldValidators["samesite.ignore_samesite"]; exists {
			val := m.GetSamesite().(*CookieForHashing_IgnoreSamesite).IgnoreSamesite
			vOpts := append(opts,
				db.WithValidateField("samesite"),
				db.WithValidateField("ignore_samesite"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CookieForHashing_SamesiteStrict:
		if fv, exists := v.FldValidators["samesite.samesite_strict"]; exists {
			val := m.GetSamesite().(*CookieForHashing_SamesiteStrict).SamesiteStrict
			vOpts := append(opts,
				db.WithValidateField("samesite"),
				db.WithValidateField("samesite_strict"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CookieForHashing_SamesiteLax:
		if fv, exists := v.FldValidators["samesite.samesite_lax"]; exists {
			val := m.GetSamesite().(*CookieForHashing_SamesiteLax).SamesiteLax
			vOpts := append(opts,
				db.WithValidateField("samesite"),
				db.WithValidateField("samesite_lax"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CookieForHashing_SamesiteNone:
		if fv, exists := v.FldValidators["samesite.samesite_none"]; exists {
			val := m.GetSamesite().(*CookieForHashing_SamesiteNone).SamesiteNone
			vOpts := append(opts,
				db.WithValidateField("samesite"),
				db.WithValidateField("samesite_none"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetSecure().(type) {
	case *CookieForHashing_IgnoreSecure:
		if fv, exists := v.FldValidators["secure.ignore_secure"]; exists {
			val := m.GetSecure().(*CookieForHashing_IgnoreSecure).IgnoreSecure
			vOpts := append(opts,
				db.WithValidateField("secure"),
				db.WithValidateField("ignore_secure"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CookieForHashing_AddSecure:
		if fv, exists := v.FldValidators["secure.add_secure"]; exists {
			val := m.GetSecure().(*CookieForHashing_AddSecure).AddSecure
			vOpts := append(opts,
				db.WithValidateField("secure"),
				db.WithValidateField("add_secure"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["ttl"]; exists {

		vOpts := append(opts, db.WithValidateField("ttl"))
		if err := fv(ctx, m.GetTtl(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCookieForHashingValidator = func() *ValidateCookieForHashing {
	v := &ValidateCookieForHashing{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CookieForHashing.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func CookieForHashingValidator() db.Validator {
	return DefaultCookieForHashingValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *CreateSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetRoutes() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting CreateSpecType.routes idx %v", idx)
		}
	}

	return nil
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *CreateSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetRoutesDRefInfo()

}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetRoutesDRefInfo() ([]db.DRefInfo, error) {
	if m.GetRoutes() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetRoutes() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetRoutes() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("routes[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) RoutesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for routes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*RouteType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := RouteTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for routes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*RouteType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*RouteType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated routes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items routes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["routes"]; exists {
		vOpts := append(opts, db.WithValidateField("routes"))
		if err := fv(ctx, m.GetRoutes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRoutes := v.RoutesValidationRuleHandler
	rulesRoutes := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "257",
	}
	vFn, err = vrhRoutes(rulesRoutes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.routes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["routes"] = vFn

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GetSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetRoutes() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting GetSpecType.routes idx %v", idx)
		}
	}

	return nil
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GetSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetRoutesDRefInfo()

}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetRoutesDRefInfo() ([]db.DRefInfo, error) {
	if m.GetRoutes() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetRoutes() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetRoutes() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("routes[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) RoutesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for routes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*RouteType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := RouteTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for routes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*RouteType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*RouteType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated routes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items routes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["routes"]; exists {
		vOpts := append(opts, db.WithValidateField("routes"))
		if err := fv(ctx, m.GetRoutes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRoutes := v.RoutesValidationRuleHandler
	rulesRoutes := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "257",
	}
	vFn, err = vrhRoutes(rulesRoutes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.routes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["routes"] = vFn

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GlobalSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetRoutes() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting GlobalSpecType.routes idx %v", idx)
		}
	}

	return nil
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetRoutesDRefInfo()

}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetRoutesDRefInfo() ([]db.DRefInfo, error) {
	if m.GetRoutes() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetRoutes() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetRoutes() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("routes[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) RoutesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for routes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*RouteType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := RouteTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for routes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*RouteType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*RouteType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated routes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items routes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["routes"]; exists {
		vOpts := append(opts, db.WithValidateField("routes"))
		if err := fv(ctx, m.GetRoutes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRoutes := v.RoutesValidationRuleHandler
	rulesRoutes := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "257",
	}
	vFn, err = vrhRoutes(rulesRoutes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.routes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["routes"] = vFn

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *HashPolicyType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HashPolicyType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HashPolicyType) DeepCopy() *HashPolicyType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HashPolicyType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HashPolicyType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HashPolicyType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HashPolicyTypeValidator().Validate(ctx, m, opts...)
}

type ValidateHashPolicyType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHashPolicyType) PolicySpecifierValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for policy_specifier")
	}
	return validatorFn, nil
}

func (v *ValidateHashPolicyType) PolicySpecifierHeaderNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_HeaderName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for header_name")
	}
	return oValidatorFn_HeaderName, nil
}

func (v *ValidateHashPolicyType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HashPolicyType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HashPolicyType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["policy_specifier"]; exists {
		val := m.GetPolicySpecifier()
		vOpts := append(opts,
			db.WithValidateField("policy_specifier"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPolicySpecifier().(type) {
	case *HashPolicyType_HeaderName:
		if fv, exists := v.FldValidators["policy_specifier.header_name"]; exists {
			val := m.GetPolicySpecifier().(*HashPolicyType_HeaderName).HeaderName
			vOpts := append(opts,
				db.WithValidateField("policy_specifier"),
				db.WithValidateField("header_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HashPolicyType_Cookie:
		if fv, exists := v.FldValidators["policy_specifier.cookie"]; exists {
			val := m.GetPolicySpecifier().(*HashPolicyType_Cookie).Cookie
			vOpts := append(opts,
				db.WithValidateField("policy_specifier"),
				db.WithValidateField("cookie"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HashPolicyType_SourceIp:
		if fv, exists := v.FldValidators["policy_specifier.source_ip"]; exists {
			val := m.GetPolicySpecifier().(*HashPolicyType_SourceIp).SourceIp
			vOpts := append(opts,
				db.WithValidateField("policy_specifier"),
				db.WithValidateField("source_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["terminal"]; exists {

		vOpts := append(opts, db.WithValidateField("terminal"))
		if err := fv(ctx, m.GetTerminal(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHashPolicyTypeValidator = func() *ValidateHashPolicyType {
	v := &ValidateHashPolicyType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPolicySpecifier := v.PolicySpecifierValidationRuleHandler
	rulesPolicySpecifier := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPolicySpecifier(rulesPolicySpecifier)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HashPolicyType.policy_specifier: %s", err)
		panic(errMsg)
	}
	v.FldValidators["policy_specifier"] = vFn

	vrhPolicySpecifierHeaderName := v.PolicySpecifierHeaderNameValidationRuleHandler
	rulesPolicySpecifierHeaderName := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFnMap["policy_specifier.header_name"], err = vrhPolicySpecifierHeaderName(rulesPolicySpecifierHeaderName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field HashPolicyType.policy_specifier_header_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["policy_specifier.header_name"] = vFnMap["policy_specifier.header_name"]

	v.FldValidators["policy_specifier.cookie"] = CookieForHashingValidator().Validate

	return v
}()

func HashPolicyTypeValidator() db.Validator {
	return DefaultHashPolicyTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *JavaScriptTag) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JavaScriptTag) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *JavaScriptTag) DeepCopy() *JavaScriptTag {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JavaScriptTag{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JavaScriptTag) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JavaScriptTag) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JavaScriptTagValidator().Validate(ctx, m, opts...)
}

type ValidateJavaScriptTag struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJavaScriptTag) JavascriptUrlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for javascript_url")
	}

	return validatorFn, nil
}

func (v *ValidateJavaScriptTag) TagAttributesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for tag_attributes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*TagAttribute, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := TagAttributeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for tag_attributes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*TagAttribute)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*TagAttribute, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated tag_attributes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items tag_attributes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateJavaScriptTag) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JavaScriptTag)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JavaScriptTag got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["javascript_url"]; exists {

		vOpts := append(opts, db.WithValidateField("javascript_url"))
		if err := fv(ctx, m.GetJavascriptUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tag_attributes"]; exists {
		vOpts := append(opts, db.WithValidateField("tag_attributes"))
		if err := fv(ctx, m.GetTagAttributes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJavaScriptTagValidator = func() *ValidateJavaScriptTag {
	v := &ValidateJavaScriptTag{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhJavascriptUrl := v.JavascriptUrlValidationRuleHandler
	rulesJavascriptUrl := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "2048",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhJavascriptUrl(rulesJavascriptUrl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavaScriptTag.javascript_url: %s", err)
		panic(errMsg)
	}
	v.FldValidators["javascript_url"] = vFn

	vrhTagAttributes := v.TagAttributesValidationRuleHandler
	rulesTagAttributes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "9",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhTagAttributes(rulesTagAttributes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JavaScriptTag.tag_attributes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tag_attributes"] = vFn

	return v
}()

func JavaScriptTagValidator() db.Validator {
	return DefaultJavaScriptTagValidator
}

// augmented methods on protoc/std generated struct

func (m *MirrorPolicyType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MirrorPolicyType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MirrorPolicyType) DeepCopy() *MirrorPolicyType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MirrorPolicyType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MirrorPolicyType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MirrorPolicyType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MirrorPolicyTypeValidator().Validate(ctx, m, opts...)
}

func (m *MirrorPolicyType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetClusterDRefInfo()

}

func (m *MirrorPolicyType) GetClusterDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetCluster()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("MirrorPolicyType.cluster[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "cluster.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "cluster",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetClusterDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *MirrorPolicyType) GetClusterDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "cluster.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: cluster")
	}
	for _, ref := range m.GetCluster() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateMirrorPolicyType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMirrorPolicyType) ClusterValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for cluster")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cluster")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cluster")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cluster")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateMirrorPolicyType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MirrorPolicyType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MirrorPolicyType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cluster"]; exists {
		vOpts := append(opts, db.WithValidateField("cluster"))
		if err := fv(ctx, m.GetCluster(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["percent"]; exists {

		vOpts := append(opts, db.WithValidateField("percent"))
		if err := fv(ctx, m.GetPercent(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMirrorPolicyTypeValidator = func() *ValidateMirrorPolicyType {
	v := &ValidateMirrorPolicyType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCluster := v.ClusterValidationRuleHandler
	rulesCluster := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhCluster(rulesCluster)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MirrorPolicyType.cluster: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cluster"] = vFn

	v.FldValidators["percent"] = ves_io_schema.FractionalPercentValidator().Validate

	return v
}()

func MirrorPolicyTypeValidator() db.Validator {
	return DefaultMirrorPolicyTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *QueryParamsSimpleRoute) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *QueryParamsSimpleRoute) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *QueryParamsSimpleRoute) DeepCopy() *QueryParamsSimpleRoute {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &QueryParamsSimpleRoute{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *QueryParamsSimpleRoute) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *QueryParamsSimpleRoute) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return QueryParamsSimpleRouteValidator().Validate(ctx, m, opts...)
}

type ValidateQueryParamsSimpleRoute struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateQueryParamsSimpleRoute) QueryParamsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for query_params")
	}
	return validatorFn, nil
}

func (v *ValidateQueryParamsSimpleRoute) QueryParamsReplaceParamsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ReplaceParams, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for replace_params")
	}
	return oValidatorFn_ReplaceParams, nil
}

func (v *ValidateQueryParamsSimpleRoute) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*QueryParamsSimpleRoute)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *QueryParamsSimpleRoute got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["query_params"]; exists {
		val := m.GetQueryParams()
		vOpts := append(opts,
			db.WithValidateField("query_params"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetQueryParams().(type) {
	case *QueryParamsSimpleRoute_RetainAllParams:
		if fv, exists := v.FldValidators["query_params.retain_all_params"]; exists {
			val := m.GetQueryParams().(*QueryParamsSimpleRoute_RetainAllParams).RetainAllParams
			vOpts := append(opts,
				db.WithValidateField("query_params"),
				db.WithValidateField("retain_all_params"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *QueryParamsSimpleRoute_RemoveAllParams:
		if fv, exists := v.FldValidators["query_params.remove_all_params"]; exists {
			val := m.GetQueryParams().(*QueryParamsSimpleRoute_RemoveAllParams).RemoveAllParams
			vOpts := append(opts,
				db.WithValidateField("query_params"),
				db.WithValidateField("remove_all_params"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *QueryParamsSimpleRoute_ReplaceParams:
		if fv, exists := v.FldValidators["query_params.replace_params"]; exists {
			val := m.GetQueryParams().(*QueryParamsSimpleRoute_ReplaceParams).ReplaceParams
			vOpts := append(opts,
				db.WithValidateField("query_params"),
				db.WithValidateField("replace_params"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultQueryParamsSimpleRouteValidator = func() *ValidateQueryParamsSimpleRoute {
	v := &ValidateQueryParamsSimpleRoute{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhQueryParams := v.QueryParamsValidationRuleHandler
	rulesQueryParams := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhQueryParams(rulesQueryParams)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for QueryParamsSimpleRoute.query_params: %s", err)
		panic(errMsg)
	}
	v.FldValidators["query_params"] = vFn

	vrhQueryParamsReplaceParams := v.QueryParamsReplaceParamsValidationRuleHandler
	rulesQueryParamsReplaceParams := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFnMap["query_params.replace_params"], err = vrhQueryParamsReplaceParams(rulesQueryParamsReplaceParams)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field QueryParamsSimpleRoute.query_params_replace_params: %s", err)
		panic(errMsg)
	}

	v.FldValidators["query_params.replace_params"] = vFnMap["query_params.replace_params"]

	return v
}()

func QueryParamsSimpleRouteValidator() db.Validator {
	return DefaultQueryParamsSimpleRouteValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ReplaceSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetRoutes() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting ReplaceSpecType.routes idx %v", idx)
		}
	}

	return nil
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *ReplaceSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetRoutesDRefInfo()

}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetRoutesDRefInfo() ([]db.DRefInfo, error) {
	if m.GetRoutes() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetRoutes() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetRoutes() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("routes[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) RoutesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for routes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*RouteType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := RouteTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for routes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*RouteType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*RouteType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated routes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items routes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["routes"]; exists {
		vOpts := append(opts, db.WithValidateField("routes"))
		if err := fv(ctx, m.GetRoutes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRoutes := v.RoutesValidationRuleHandler
	rulesRoutes := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "257",
	}
	vFn, err = vrhRoutes(rulesRoutes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.routes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["routes"] = vFn

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *RouteDestination) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RouteDestination) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RouteDestination) DeepCopy() *RouteDestination {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RouteDestination{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RouteDestination) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RouteDestination) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RouteDestinationValidator().Validate(ctx, m, opts...)
}

func (m *RouteDestination) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetClusterDRefInfo()

}

func (m *RouteDestination) GetClusterDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetCluster()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("RouteDestination.cluster[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "cluster.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "cluster",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetClusterDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *RouteDestination) GetClusterDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "cluster.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: cluster")
	}
	for _, ref := range m.GetCluster() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateRouteDestination struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRouteDestination) ClusterValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for cluster")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cluster")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cluster")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cluster")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteDestination) WeightValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for weight")
	}

	return validatorFn, nil
}

func (v *ValidateRouteDestination) EndpointSubsetsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for endpoint_subsets")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for endpoint_subsets")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for endpoint_subsets")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map endpoint_subsets")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items endpoint_subsets")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteDestination) PriorityValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for priority")
	}

	return validatorFn, nil
}

func (v *ValidateRouteDestination) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RouteDestination)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RouteDestination got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cluster"]; exists {
		vOpts := append(opts, db.WithValidateField("cluster"))
		if err := fv(ctx, m.GetCluster(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["endpoint_subsets"]; exists {
		vOpts := append(opts, db.WithValidateField("endpoint_subsets"))
		if err := fv(ctx, m.GetEndpointSubsets(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["priority"]; exists {

		vOpts := append(opts, db.WithValidateField("priority"))
		if err := fv(ctx, m.GetPriority(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["weight"]; exists {

		vOpts := append(opts, db.WithValidateField("weight"))
		if err := fv(ctx, m.GetWeight(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRouteDestinationValidator = func() *ValidateRouteDestination {
	v := &ValidateRouteDestination{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCluster := v.ClusterValidationRuleHandler
	rulesCluster := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhCluster(rulesCluster)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteDestination.cluster: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cluster"] = vFn

	vrhWeight := v.WeightValidationRuleHandler
	rulesWeight := map[string]string{
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFn, err = vrhWeight(rulesWeight)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteDestination.weight: %s", err)
		panic(errMsg)
	}
	v.FldValidators["weight"] = vFn

	vrhEndpointSubsets := v.EndpointSubsetsValidationRuleHandler
	rulesEndpointSubsets := map[string]string{
		"ves.io.schema.rules.map.max_pairs": "16",
	}
	vFn, err = vrhEndpointSubsets(rulesEndpointSubsets)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteDestination.endpoint_subsets: %s", err)
		panic(errMsg)
	}
	v.FldValidators["endpoint_subsets"] = vFn

	vrhPriority := v.PriorityValidationRuleHandler
	rulesPriority := map[string]string{
		"ves.io.schema.rules.uint32.lte": "32",
	}
	vFn, err = vrhPriority(rulesPriority)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteDestination.priority: %s", err)
		panic(errMsg)
	}
	v.FldValidators["priority"] = vFn

	return v
}()

func RouteDestinationValidator() db.Validator {
	return DefaultRouteDestinationValidator
}

// augmented methods on protoc/std generated struct

func (m *RouteDestinationList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RouteDestinationList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RouteDestinationList) DeepCopy() *RouteDestinationList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RouteDestinationList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RouteDestinationList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RouteDestinationList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RouteDestinationListValidator().Validate(ctx, m, opts...)
}

func (m *RouteDestinationList) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetDestinationsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDestinationsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetMirrorPolicyDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetMirrorPolicyDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *RouteDestinationList) GetDestinationsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDestinations() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetDestinations() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetDestinations() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("destinations[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *RouteDestinationList) GetMirrorPolicyDRefInfo() ([]db.DRefInfo, error) {
	if m.GetMirrorPolicy() == nil {
		return nil, nil
	}

	drInfos, err := m.GetMirrorPolicy().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetMirrorPolicy().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "mirror_policy." + dri.DRField
	}
	return drInfos, err

}

type ValidateRouteDestinationList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRouteDestinationList) HostRewriteParamsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for host_rewrite_params")
	}
	return validatorFn, nil
}

func (v *ValidateRouteDestinationList) HostRewriteParamsHostRewriteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_HostRewrite, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for host_rewrite")
	}
	return oValidatorFn_HostRewrite, nil
}

func (v *ValidateRouteDestinationList) RouteDestinationRewritePrefixRewriteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_PrefixRewrite, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for prefix_rewrite")
	}
	return oValidatorFn_PrefixRewrite, nil
}

func (v *ValidateRouteDestinationList) DestinationsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for destinations")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*RouteDestination, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := RouteDestinationValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for destinations")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*RouteDestination)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*RouteDestination, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated destinations")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items destinations")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteDestinationList) TimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for timeout")
	}

	return validatorFn, nil
}

func (v *ValidateRouteDestinationList) EndpointSubsetsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for endpoint_subsets")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for endpoint_subsets")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for endpoint_subsets")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map endpoint_subsets")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items endpoint_subsets")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteDestinationList) HashPolicyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for hash_policy")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*HashPolicyType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := HashPolicyTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for hash_policy")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*HashPolicyType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*HashPolicyType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated hash_policy")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items hash_policy")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteDestinationList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RouteDestinationList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RouteDestinationList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["buffer_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("buffer_policy"))
		if err := fv(ctx, m.GetBufferPolicy(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetClusterRetractChoice().(type) {
	case *RouteDestinationList_RetractCluster:
		if fv, exists := v.FldValidators["cluster_retract_choice.retract_cluster"]; exists {
			val := m.GetClusterRetractChoice().(*RouteDestinationList_RetractCluster).RetractCluster
			vOpts := append(opts,
				db.WithValidateField("cluster_retract_choice"),
				db.WithValidateField("retract_cluster"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RouteDestinationList_DoNotRetractCluster:
		if fv, exists := v.FldValidators["cluster_retract_choice.do_not_retract_cluster"]; exists {
			val := m.GetClusterRetractChoice().(*RouteDestinationList_DoNotRetractCluster).DoNotRetractCluster
			vOpts := append(opts,
				db.WithValidateField("cluster_retract_choice"),
				db.WithValidateField("do_not_retract_cluster"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["cors_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("cors_policy"))
		if err := fv(ctx, m.GetCorsPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["csrf_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("csrf_policy"))
		if err := fv(ctx, m.GetCsrfPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["destinations"]; exists {
		vOpts := append(opts, db.WithValidateField("destinations"))
		if err := fv(ctx, m.GetDestinations(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["endpoint_subsets"]; exists {
		vOpts := append(opts, db.WithValidateField("endpoint_subsets"))
		if err := fv(ctx, m.GetEndpointSubsets(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["hash_policy"]; exists {
		vOpts := append(opts, db.WithValidateField("hash_policy"))
		if err := fv(ctx, m.GetHashPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["host_rewrite_params"]; exists {
		val := m.GetHostRewriteParams()
		vOpts := append(opts,
			db.WithValidateField("host_rewrite_params"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetHostRewriteParams().(type) {
	case *RouteDestinationList_HostRewrite:
		if fv, exists := v.FldValidators["host_rewrite_params.host_rewrite"]; exists {
			val := m.GetHostRewriteParams().(*RouteDestinationList_HostRewrite).HostRewrite
			vOpts := append(opts,
				db.WithValidateField("host_rewrite_params"),
				db.WithValidateField("host_rewrite"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RouteDestinationList_AutoHostRewrite:
		if fv, exists := v.FldValidators["host_rewrite_params.auto_host_rewrite"]; exists {
			val := m.GetHostRewriteParams().(*RouteDestinationList_AutoHostRewrite).AutoHostRewrite
			vOpts := append(opts,
				db.WithValidateField("host_rewrite_params"),
				db.WithValidateField("auto_host_rewrite"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["mirror_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("mirror_policy"))
		if err := fv(ctx, m.GetMirrorPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["priority"]; exists {

		vOpts := append(opts, db.WithValidateField("priority"))
		if err := fv(ctx, m.GetPriority(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query_params"]; exists {

		vOpts := append(opts, db.WithValidateField("query_params"))
		if err := fv(ctx, m.GetQueryParams(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["retry_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("retry_policy"))
		if err := fv(ctx, m.GetRetryPolicy(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetRouteDestinationRewrite().(type) {
	case *RouteDestinationList_PrefixRewrite:
		if fv, exists := v.FldValidators["route_destination_rewrite.prefix_rewrite"]; exists {
			val := m.GetRouteDestinationRewrite().(*RouteDestinationList_PrefixRewrite).PrefixRewrite
			vOpts := append(opts,
				db.WithValidateField("route_destination_rewrite"),
				db.WithValidateField("prefix_rewrite"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RouteDestinationList_RegexRewrite:
		if fv, exists := v.FldValidators["route_destination_rewrite.regex_rewrite"]; exists {
			val := m.GetRouteDestinationRewrite().(*RouteDestinationList_RegexRewrite).RegexRewrite
			vOpts := append(opts,
				db.WithValidateField("route_destination_rewrite"),
				db.WithValidateField("regex_rewrite"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["spdy_config"]; exists {

		vOpts := append(opts, db.WithValidateField("spdy_config"))
		if err := fv(ctx, m.GetSpdyConfig(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("timeout"))
		if err := fv(ctx, m.GetTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["web_socket_config"]; exists {

		vOpts := append(opts, db.WithValidateField("web_socket_config"))
		if err := fv(ctx, m.GetWebSocketConfig(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRouteDestinationListValidator = func() *ValidateRouteDestinationList {
	v := &ValidateRouteDestinationList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHostRewriteParams := v.HostRewriteParamsValidationRuleHandler
	rulesHostRewriteParams := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhHostRewriteParams(rulesHostRewriteParams)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteDestinationList.host_rewrite_params: %s", err)
		panic(errMsg)
	}
	v.FldValidators["host_rewrite_params"] = vFn

	vrhHostRewriteParamsHostRewrite := v.HostRewriteParamsHostRewriteValidationRuleHandler
	rulesHostRewriteParamsHostRewrite := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFnMap["host_rewrite_params.host_rewrite"], err = vrhHostRewriteParamsHostRewrite(rulesHostRewriteParamsHostRewrite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field RouteDestinationList.host_rewrite_params_host_rewrite: %s", err)
		panic(errMsg)
	}

	v.FldValidators["host_rewrite_params.host_rewrite"] = vFnMap["host_rewrite_params.host_rewrite"]

	vrhRouteDestinationRewritePrefixRewrite := v.RouteDestinationRewritePrefixRewriteValidationRuleHandler
	rulesRouteDestinationRewritePrefixRewrite := map[string]string{
		"ves.io.schema.rules.string.http_path": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFnMap["route_destination_rewrite.prefix_rewrite"], err = vrhRouteDestinationRewritePrefixRewrite(rulesRouteDestinationRewritePrefixRewrite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field RouteDestinationList.route_destination_rewrite_prefix_rewrite: %s", err)
		panic(errMsg)
	}

	v.FldValidators["route_destination_rewrite.prefix_rewrite"] = vFnMap["route_destination_rewrite.prefix_rewrite"]

	vrhDestinations := v.DestinationsValidationRuleHandler
	rulesDestinations := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhDestinations(rulesDestinations)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteDestinationList.destinations: %s", err)
		panic(errMsg)
	}
	v.FldValidators["destinations"] = vFn

	vrhTimeout := v.TimeoutValidationRuleHandler
	rulesTimeout := map[string]string{
		"ves.io.schema.rules.uint32.lte": "1800000",
	}
	vFn, err = vrhTimeout(rulesTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteDestinationList.timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["timeout"] = vFn

	vrhEndpointSubsets := v.EndpointSubsetsValidationRuleHandler
	rulesEndpointSubsets := map[string]string{
		"ves.io.schema.rules.map.max_pairs": "16",
	}
	vFn, err = vrhEndpointSubsets(rulesEndpointSubsets)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteDestinationList.endpoint_subsets: %s", err)
		panic(errMsg)
	}
	v.FldValidators["endpoint_subsets"] = vFn

	vrhHashPolicy := v.HashPolicyValidationRuleHandler
	rulesHashPolicy := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
	}
	vFn, err = vrhHashPolicy(rulesHashPolicy)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteDestinationList.hash_policy: %s", err)
		panic(errMsg)
	}
	v.FldValidators["hash_policy"] = vFn

	v.FldValidators["route_destination_rewrite.regex_rewrite"] = ves_io_schema.RegexMatchRewriteValidator().Validate

	v.FldValidators["retry_policy"] = ves_io_schema.RetryPolicyTypeValidator().Validate

	v.FldValidators["mirror_policy"] = MirrorPolicyTypeValidator().Validate

	v.FldValidators["buffer_policy"] = ves_io_schema.BufferConfigTypeValidator().Validate

	v.FldValidators["cors_policy"] = ves_io_schema.CorsPolicyValidator().Validate

	v.FldValidators["csrf_policy"] = ves_io_schema.CsrfPolicyValidator().Validate

	v.FldValidators["query_params"] = QueryParamsSimpleRouteValidator().Validate

	return v
}()

func RouteDestinationListValidator() db.Validator {
	return DefaultRouteDestinationListValidator
}

// augmented methods on protoc/std generated struct

func (m *RouteDirectResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RouteDirectResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RouteDirectResponse) DeepCopy() *RouteDirectResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RouteDirectResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RouteDirectResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RouteDirectResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RouteDirectResponseValidator().Validate(ctx, m, opts...)
}

type ValidateRouteDirectResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRouteDirectResponse) ResponseCodeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for response_code")
	}

	return validatorFn, nil
}

func (v *ValidateRouteDirectResponse) ResponseBodyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for response_body")
	}

	return validatorFn, nil
}

func (v *ValidateRouteDirectResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RouteDirectResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RouteDirectResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["response_body"]; exists {

		vOpts := append(opts, db.WithValidateField("response_body"))
		if err := fv(ctx, m.GetResponseBody(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_code"]; exists {

		vOpts := append(opts, db.WithValidateField("response_code"))
		if err := fv(ctx, m.GetResponseCode(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRouteDirectResponseValidator = func() *ValidateRouteDirectResponse {
	v := &ValidateRouteDirectResponse{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhResponseCode := v.ResponseCodeValidationRuleHandler
	rulesResponseCode := map[string]string{
		"ves.io.schema.rules.uint32.gte": "100",
		"ves.io.schema.rules.uint32.lte": "599",
	}
	vFn, err = vrhResponseCode(rulesResponseCode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteDirectResponse.response_code: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_code"] = vFn

	vrhResponseBody := v.ResponseBodyValidationRuleHandler
	rulesResponseBody := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "65536",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhResponseBody(rulesResponseBody)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteDirectResponse.response_body: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_body"] = vFn

	return v
}()

func RouteDirectResponseValidator() db.Validator {
	return DefaultRouteDirectResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *RouteQueryParams) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RouteQueryParams) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RouteQueryParams) DeepCopy() *RouteQueryParams {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RouteQueryParams{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RouteQueryParams) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RouteQueryParams) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RouteQueryParamsValidator().Validate(ctx, m, opts...)
}

type ValidateRouteQueryParams struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRouteQueryParams) QueryParamsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for query_params")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for query_params")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated query_params")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items query_params")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteQueryParams) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RouteQueryParams)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RouteQueryParams got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["query_params"]; exists {
		vOpts := append(opts, db.WithValidateField("query_params"))
		if err := fv(ctx, m.GetQueryParams(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRouteQueryParamsValidator = func() *ValidateRouteQueryParams {
	v := &ValidateRouteQueryParams{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhQueryParams := v.QueryParamsValidationRuleHandler
	rulesQueryParams := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
	}
	vFn, err = vrhQueryParams(rulesQueryParams)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteQueryParams.query_params: %s", err)
		panic(errMsg)
	}
	v.FldValidators["query_params"] = vFn

	return v
}()

func RouteQueryParamsValidator() db.Validator {
	return DefaultRouteQueryParamsValidator
}

// augmented methods on protoc/std generated struct

func (m *RouteRedirect) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RouteRedirect) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RouteRedirect) DeepCopy() *RouteRedirect {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RouteRedirect{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RouteRedirect) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RouteRedirect) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RouteRedirectValidator().Validate(ctx, m, opts...)
}

type ValidateRouteRedirect struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRouteRedirect) QueryParamsReplaceParamsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ReplaceParams, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for replace_params")
	}
	return oValidatorFn_ReplaceParams, nil
}

func (v *ValidateRouteRedirect) RedirectPathChoicePathRedirectValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_PathRedirect, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for path_redirect")
	}
	return oValidatorFn_PathRedirect, nil
}
func (v *ValidateRouteRedirect) RedirectPathChoicePrefixRewriteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_PrefixRewrite, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for prefix_rewrite")
	}
	return oValidatorFn_PrefixRewrite, nil
}

func (v *ValidateRouteRedirect) ProtoRedirectValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for proto_redirect")
	}

	return validatorFn, nil
}

func (v *ValidateRouteRedirect) ResponseCodeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for response_code")
	}

	return validatorFn, nil
}

func (v *ValidateRouteRedirect) PortRedirectValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port_redirect")
	}

	return validatorFn, nil
}

func (v *ValidateRouteRedirect) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RouteRedirect)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RouteRedirect got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["host_redirect"]; exists {

		vOpts := append(opts, db.WithValidateField("host_redirect"))
		if err := fv(ctx, m.GetHostRedirect(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["port_redirect"]; exists {

		vOpts := append(opts, db.WithValidateField("port_redirect"))
		if err := fv(ctx, m.GetPortRedirect(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["proto_redirect"]; exists {

		vOpts := append(opts, db.WithValidateField("proto_redirect"))
		if err := fv(ctx, m.GetProtoRedirect(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetQueryParams().(type) {
	case *RouteRedirect_StripQueryParams:
		if fv, exists := v.FldValidators["query_params.strip_query_params"]; exists {
			val := m.GetQueryParams().(*RouteRedirect_StripQueryParams).StripQueryParams
			vOpts := append(opts,
				db.WithValidateField("query_params"),
				db.WithValidateField("strip_query_params"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RouteRedirect_AllParams:
		if fv, exists := v.FldValidators["query_params.all_params"]; exists {
			val := m.GetQueryParams().(*RouteRedirect_AllParams).AllParams
			vOpts := append(opts,
				db.WithValidateField("query_params"),
				db.WithValidateField("all_params"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RouteRedirect_RetainAllParams:
		if fv, exists := v.FldValidators["query_params.retain_all_params"]; exists {
			val := m.GetQueryParams().(*RouteRedirect_RetainAllParams).RetainAllParams
			vOpts := append(opts,
				db.WithValidateField("query_params"),
				db.WithValidateField("retain_all_params"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RouteRedirect_RemoveAllParams:
		if fv, exists := v.FldValidators["query_params.remove_all_params"]; exists {
			val := m.GetQueryParams().(*RouteRedirect_RemoveAllParams).RemoveAllParams
			vOpts := append(opts,
				db.WithValidateField("query_params"),
				db.WithValidateField("remove_all_params"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RouteRedirect_ReplaceParams:
		if fv, exists := v.FldValidators["query_params.replace_params"]; exists {
			val := m.GetQueryParams().(*RouteRedirect_ReplaceParams).ReplaceParams
			vOpts := append(opts,
				db.WithValidateField("query_params"),
				db.WithValidateField("replace_params"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetRedirectPathChoice().(type) {
	case *RouteRedirect_PathRedirect:
		if fv, exists := v.FldValidators["redirect_path_choice.path_redirect"]; exists {
			val := m.GetRedirectPathChoice().(*RouteRedirect_PathRedirect).PathRedirect
			vOpts := append(opts,
				db.WithValidateField("redirect_path_choice"),
				db.WithValidateField("path_redirect"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RouteRedirect_PrefixRewrite:
		if fv, exists := v.FldValidators["redirect_path_choice.prefix_rewrite"]; exists {
			val := m.GetRedirectPathChoice().(*RouteRedirect_PrefixRewrite).PrefixRewrite
			vOpts := append(opts,
				db.WithValidateField("redirect_path_choice"),
				db.WithValidateField("prefix_rewrite"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["response_code"]; exists {

		vOpts := append(opts, db.WithValidateField("response_code"))
		if err := fv(ctx, m.GetResponseCode(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRouteRedirectValidator = func() *ValidateRouteRedirect {
	v := &ValidateRouteRedirect{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhQueryParamsReplaceParams := v.QueryParamsReplaceParamsValidationRuleHandler
	rulesQueryParamsReplaceParams := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFnMap["query_params.replace_params"], err = vrhQueryParamsReplaceParams(rulesQueryParamsReplaceParams)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field RouteRedirect.query_params_replace_params: %s", err)
		panic(errMsg)
	}

	v.FldValidators["query_params.replace_params"] = vFnMap["query_params.replace_params"]

	vrhRedirectPathChoicePathRedirect := v.RedirectPathChoicePathRedirectValidationRuleHandler
	rulesRedirectPathChoicePathRedirect := map[string]string{
		"ves.io.schema.rules.string.http_path": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFnMap["redirect_path_choice.path_redirect"], err = vrhRedirectPathChoicePathRedirect(rulesRedirectPathChoicePathRedirect)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field RouteRedirect.redirect_path_choice_path_redirect: %s", err)
		panic(errMsg)
	}
	vrhRedirectPathChoicePrefixRewrite := v.RedirectPathChoicePrefixRewriteValidationRuleHandler
	rulesRedirectPathChoicePrefixRewrite := map[string]string{
		"ves.io.schema.rules.string.http_path": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFnMap["redirect_path_choice.prefix_rewrite"], err = vrhRedirectPathChoicePrefixRewrite(rulesRedirectPathChoicePrefixRewrite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field RouteRedirect.redirect_path_choice_prefix_rewrite: %s", err)
		panic(errMsg)
	}

	v.FldValidators["redirect_path_choice.path_redirect"] = vFnMap["redirect_path_choice.path_redirect"]
	v.FldValidators["redirect_path_choice.prefix_rewrite"] = vFnMap["redirect_path_choice.prefix_rewrite"]

	vrhProtoRedirect := v.ProtoRedirectValidationRuleHandler
	rulesProtoRedirect := map[string]string{
		"ves.io.schema.rules.string.in": "[\"incoming-proto\",\"http\",\"https\"]",
	}
	vFn, err = vrhProtoRedirect(rulesProtoRedirect)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteRedirect.proto_redirect: %s", err)
		panic(errMsg)
	}
	v.FldValidators["proto_redirect"] = vFn

	vrhResponseCode := v.ResponseCodeValidationRuleHandler
	rulesResponseCode := map[string]string{
		"ves.io.schema.rules.uint32.lte": "599",
	}
	vFn, err = vrhResponseCode(rulesResponseCode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteRedirect.response_code: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_code"] = vFn

	vrhPortRedirect := v.PortRedirectValidationRuleHandler
	rulesPortRedirect := map[string]string{
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFn, err = vrhPortRedirect(rulesPortRedirect)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteRedirect.port_redirect: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port_redirect"] = vFn

	v.FldValidators["query_params.strip_query_params"] = RouteQueryParamsValidator().Validate

	return v
}()

func RouteRedirectValidator() db.Validator {
	return DefaultRouteRedirectValidator
}

// augmented methods on protoc/std generated struct

func (m *RouteType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RouteType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *RouteType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetRequestHeadersToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting RouteType.request_headers_to_add idx %v", idx)
		}
	}

	for idx, e := range m.GetResponseHeadersToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting RouteType.response_headers_to_add idx %v", idx)
		}
	}

	for idx, e := range m.GetRequestCookiesToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting RouteType.request_cookies_to_add idx %v", idx)
		}
	}

	for idx, e := range m.GetResponseCookiesToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting RouteType.response_cookies_to_add idx %v", idx)
		}
	}

	return nil
}

func (m *RouteType) DeepCopy() *RouteType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RouteType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RouteType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RouteType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RouteTypeValidator().Validate(ctx, m, opts...)
}

func (m *RouteType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetRouteActionDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRouteActionDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetWafExclusionChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetWafExclusionChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetWafTypeDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetWafTypeDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *RouteType) GetRouteActionDRefInfo() ([]db.DRefInfo, error) {
	if m.GetRouteAction() == nil {
		return nil, nil
	}
	switch m.GetRouteAction().(type) {
	case *RouteType_RouteDestination:

		drInfos, err := m.GetRouteDestination().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetRouteDestination().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "route_destination." + dri.DRField
		}
		return drInfos, err

	case *RouteType_RouteRedirect:

		return nil, nil

	case *RouteType_RouteDirectResponse:

		return nil, nil

	default:
		return nil, nil
	}

}

func (m *RouteType) GetWafExclusionChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetWafExclusionChoice().(type) {
	case *RouteType_InheritedWafExclusion:

		return nil, nil

	case *RouteType_WafExclusionPolicy:

		vref := m.GetWafExclusionPolicy()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("waf_exclusion_policy.Object")
		dri := db.DRefInfo{
			RefdType:   "waf_exclusion_policy.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "waf_exclusion_policy",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetWafExclusionChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *RouteType) GetWafExclusionChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetWafExclusionChoice().(type) {
	case *RouteType_InheritedWafExclusion:

	case *RouteType_WafExclusionPolicy:
		refdType, err := d.TypeForEntryKind("", "", "waf_exclusion_policy.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: waf_exclusion_policy")
		}

		vref := m.GetWafExclusionPolicy()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "waf_exclusion_policy.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *RouteType) GetWafTypeDRefInfo() ([]db.DRefInfo, error) {
	if m.GetWafType() == nil {
		return nil, nil
	}

	drInfos, err := m.GetWafType().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetWafType().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "waf_type." + dri.DRField
	}
	return drInfos, err

}

type ValidateRouteType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRouteType) RouteActionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for route_action")
	}
	return validatorFn, nil
}

func (v *ValidateRouteType) MatchValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for match")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.RouteMatch, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.RouteMatchValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for match")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.RouteMatch)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.RouteMatch, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated match")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items match")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteType) RequestHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for request_headers_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteType) ResponseHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for response_headers_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteType) RequestHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for request_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteType) ResponseHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for response_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteType) RequestCookiesToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for request_cookies_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.CookieValueOption, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.CookieValueOptionValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_cookies_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.CookieValueOption)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.CookieValueOption, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_cookies_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_cookies_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteType) RequestCookiesToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for request_cookies_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_cookies_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_cookies_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_cookies_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteType) ResponseCookiesToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for response_cookies_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.SetCookieValueOption, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.SetCookieValueOptionValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_cookies_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.SetCookieValueOption)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.SetCookieValueOption, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_cookies_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_cookies_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteType) ResponseCookiesToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for response_cookies_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_cookies_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_cookies_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_cookies_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RouteType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RouteType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetBotDefenseJavascriptInjectionChoice().(type) {
	case *RouteType_InheritedBotDefenseJavascriptInjection:
		if fv, exists := v.FldValidators["bot_defense_javascript_injection_choice.inherited_bot_defense_javascript_injection"]; exists {
			val := m.GetBotDefenseJavascriptInjectionChoice().(*RouteType_InheritedBotDefenseJavascriptInjection).InheritedBotDefenseJavascriptInjection
			vOpts := append(opts,
				db.WithValidateField("bot_defense_javascript_injection_choice"),
				db.WithValidateField("inherited_bot_defense_javascript_injection"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RouteType_BotDefenseJavascriptInjection:
		if fv, exists := v.FldValidators["bot_defense_javascript_injection_choice.bot_defense_javascript_injection"]; exists {
			val := m.GetBotDefenseJavascriptInjectionChoice().(*RouteType_BotDefenseJavascriptInjection).BotDefenseJavascriptInjection
			vOpts := append(opts,
				db.WithValidateField("bot_defense_javascript_injection_choice"),
				db.WithValidateField("bot_defense_javascript_injection"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["bot_defense_javascript_injection_inline_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("bot_defense_javascript_injection_inline_mode"))
		if err := fv(ctx, m.GetBotDefenseJavascriptInjectionInlineMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_custom_script"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_custom_script"))
		if err := fv(ctx, m.GetDisableCustomScript(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_location_add"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_location_add"))
		if err := fv(ctx, m.GetDisableLocationAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["match"]; exists {
		vOpts := append(opts, db.WithValidateField("match"))
		if err := fv(ctx, m.GetMatch(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_cookies_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("request_cookies_to_add"))
		if err := fv(ctx, m.GetRequestCookiesToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_cookies_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("request_cookies_to_remove"))
		if err := fv(ctx, m.GetRequestCookiesToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_add"))
		if err := fv(ctx, m.GetRequestHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_remove"))
		if err := fv(ctx, m.GetRequestHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_cookies_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("response_cookies_to_add"))
		if err := fv(ctx, m.GetResponseCookiesToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_cookies_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("response_cookies_to_remove"))
		if err := fv(ctx, m.GetResponseCookiesToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_add"))
		if err := fv(ctx, m.GetResponseHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_remove"))
		if err := fv(ctx, m.GetResponseHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["route_action"]; exists {
		val := m.GetRouteAction()
		vOpts := append(opts,
			db.WithValidateField("route_action"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetRouteAction().(type) {
	case *RouteType_RouteDestination:
		if fv, exists := v.FldValidators["route_action.route_destination"]; exists {
			val := m.GetRouteAction().(*RouteType_RouteDestination).RouteDestination
			vOpts := append(opts,
				db.WithValidateField("route_action"),
				db.WithValidateField("route_destination"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RouteType_RouteRedirect:
		if fv, exists := v.FldValidators["route_action.route_redirect"]; exists {
			val := m.GetRouteAction().(*RouteType_RouteRedirect).RouteRedirect
			vOpts := append(opts,
				db.WithValidateField("route_action"),
				db.WithValidateField("route_redirect"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RouteType_RouteDirectResponse:
		if fv, exists := v.FldValidators["route_action.route_direct_response"]; exists {
			val := m.GetRouteAction().(*RouteType_RouteDirectResponse).RouteDirectResponse
			vOpts := append(opts,
				db.WithValidateField("route_action"),
				db.WithValidateField("route_direct_response"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["service_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("service_policy"))
		if err := fv(ctx, m.GetServicePolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["skip_lb_override"]; exists {

		vOpts := append(opts, db.WithValidateField("skip_lb_override"))
		if err := fv(ctx, m.GetSkipLbOverride(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetWafExclusionChoice().(type) {
	case *RouteType_InheritedWafExclusion:
		if fv, exists := v.FldValidators["waf_exclusion_choice.inherited_waf_exclusion"]; exists {
			val := m.GetWafExclusionChoice().(*RouteType_InheritedWafExclusion).InheritedWafExclusion
			vOpts := append(opts,
				db.WithValidateField("waf_exclusion_choice"),
				db.WithValidateField("inherited_waf_exclusion"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RouteType_WafExclusionPolicy:
		if fv, exists := v.FldValidators["waf_exclusion_choice.waf_exclusion_policy"]; exists {
			val := m.GetWafExclusionChoice().(*RouteType_WafExclusionPolicy).WafExclusionPolicy
			vOpts := append(opts,
				db.WithValidateField("waf_exclusion_choice"),
				db.WithValidateField("waf_exclusion_policy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["waf_type"]; exists {

		vOpts := append(opts, db.WithValidateField("waf_type"))
		if err := fv(ctx, m.GetWafType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRouteTypeValidator = func() *ValidateRouteType {
	v := &ValidateRouteType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRouteAction := v.RouteActionValidationRuleHandler
	rulesRouteAction := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhRouteAction(rulesRouteAction)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteType.route_action: %s", err)
		panic(errMsg)
	}
	v.FldValidators["route_action"] = vFn

	vrhMatch := v.MatchValidationRuleHandler
	rulesMatch := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhMatch(rulesMatch)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteType.match: %s", err)
		panic(errMsg)
	}
	v.FldValidators["match"] = vFn

	vrhRequestHeadersToAdd := v.RequestHeadersToAddValidationRuleHandler
	rulesRequestHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
	}
	vFn, err = vrhRequestHeadersToAdd(rulesRequestHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteType.request_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_add"] = vFn

	vrhResponseHeadersToAdd := v.ResponseHeadersToAddValidationRuleHandler
	rulesResponseHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
	}
	vFn, err = vrhResponseHeadersToAdd(rulesResponseHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteType.response_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_add"] = vFn

	vrhRequestHeadersToRemove := v.RequestHeadersToRemoveValidationRuleHandler
	rulesRequestHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "32",
	}
	vFn, err = vrhRequestHeadersToRemove(rulesRequestHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteType.request_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_remove"] = vFn

	vrhResponseHeadersToRemove := v.ResponseHeadersToRemoveValidationRuleHandler
	rulesResponseHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "32",
	}
	vFn, err = vrhResponseHeadersToRemove(rulesResponseHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteType.response_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_remove"] = vFn

	vrhRequestCookiesToAdd := v.RequestCookiesToAddValidationRuleHandler
	rulesRequestCookiesToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestCookiesToAdd(rulesRequestCookiesToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteType.request_cookies_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_cookies_to_add"] = vFn

	vrhRequestCookiesToRemove := v.RequestCookiesToRemoveValidationRuleHandler
	rulesRequestCookiesToRemove := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "32",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhRequestCookiesToRemove(rulesRequestCookiesToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteType.request_cookies_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_cookies_to_remove"] = vFn

	vrhResponseCookiesToAdd := v.ResponseCookiesToAddValidationRuleHandler
	rulesResponseCookiesToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseCookiesToAdd(rulesResponseCookiesToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteType.response_cookies_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_cookies_to_add"] = vFn

	vrhResponseCookiesToRemove := v.ResponseCookiesToRemoveValidationRuleHandler
	rulesResponseCookiesToRemove := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "32",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhResponseCookiesToRemove(rulesResponseCookiesToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteType.response_cookies_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_cookies_to_remove"] = vFn

	v.FldValidators["bot_defense_javascript_injection_choice.bot_defense_javascript_injection"] = BotDefenseJavascriptInjectionTypeValidator().Validate

	v.FldValidators["route_action.route_destination"] = RouteDestinationListValidator().Validate
	v.FldValidators["route_action.route_redirect"] = RouteRedirectValidator().Validate
	v.FldValidators["route_action.route_direct_response"] = RouteDirectResponseValidator().Validate

	v.FldValidators["waf_exclusion_choice.waf_exclusion_policy"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["waf_type"] = ves_io_schema.WafTypeValidator().Validate

	v.FldValidators["service_policy"] = ServicePolicyInfoValidator().Validate

	v.FldValidators["bot_defense_javascript_injection_inline_mode"] = ContentRewriteTypeValidator().Validate

	return v
}()

func RouteTypeValidator() db.Validator {
	return DefaultRouteTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ServicePolicyInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ServicePolicyInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ServicePolicyInfo) DeepCopy() *ServicePolicyInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ServicePolicyInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ServicePolicyInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ServicePolicyInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ServicePolicyInfoValidator().Validate(ctx, m, opts...)
}

type ValidateServicePolicyInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateServicePolicyInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ServicePolicyInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ServicePolicyInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetServicePolicyChoice().(type) {
	case *ServicePolicyInfo_Disable:
		if fv, exists := v.FldValidators["service_policy_choice.disable"]; exists {
			val := m.GetServicePolicyChoice().(*ServicePolicyInfo_Disable).Disable
			vOpts := append(opts,
				db.WithValidateField("service_policy_choice"),
				db.WithValidateField("disable"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ServicePolicyInfo_ContextExtensions:
		if fv, exists := v.FldValidators["service_policy_choice.context_extensions"]; exists {
			val := m.GetServicePolicyChoice().(*ServicePolicyInfo_ContextExtensions).ContextExtensions
			vOpts := append(opts,
				db.WithValidateField("service_policy_choice"),
				db.WithValidateField("context_extensions"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultServicePolicyInfoValidator = func() *ValidateServicePolicyInfo {
	v := &ValidateServicePolicyInfo{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["service_policy_choice.context_extensions"] = ContextExtensionInfoValidator().Validate

	return v
}()

func ServicePolicyInfoValidator() db.Validator {
	return DefaultServicePolicyInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *SpdyConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SpdyConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SpdyConfigType) DeepCopy() *SpdyConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SpdyConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SpdyConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SpdyConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SpdyConfigTypeValidator().Validate(ctx, m, opts...)
}

type ValidateSpdyConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSpdyConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SpdyConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SpdyConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["use_spdy"]; exists {

		vOpts := append(opts, db.WithValidateField("use_spdy"))
		if err := fv(ctx, m.GetUseSpdy(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSpdyConfigTypeValidator = func() *ValidateSpdyConfigType {
	v := &ValidateSpdyConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SpdyConfigTypeValidator() db.Validator {
	return DefaultSpdyConfigTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TagAttribute) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TagAttribute) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TagAttribute) DeepCopy() *TagAttribute {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TagAttribute{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TagAttribute) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TagAttribute) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TagAttributeValidator().Validate(ctx, m, opts...)
}

type ValidateTagAttribute struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTagAttribute) TagValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tag_value")
	}

	return validatorFn, nil
}

func (v *ValidateTagAttribute) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TagAttribute)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TagAttribute got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["javascript_tag"]; exists {

		vOpts := append(opts, db.WithValidateField("javascript_tag"))
		if err := fv(ctx, m.GetJavascriptTag(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tag_value"]; exists {

		vOpts := append(opts, db.WithValidateField("tag_value"))
		if err := fv(ctx, m.GetTagValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTagAttributeValidator = func() *ValidateTagAttribute {
	v := &ValidateTagAttribute{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTagValue := v.TagValueValidationRuleHandler
	rulesTagValue := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "1024",
	}
	vFn, err = vrhTagValue(rulesTagValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TagAttribute.tag_value: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tag_value"] = vFn

	return v
}()

func TagAttributeValidator() db.Validator {
	return DefaultTagAttributeValidator
}

// augmented methods on protoc/std generated struct

func (m *VerStatusType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VerStatusType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VerStatusType) DeepCopy() *VerStatusType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VerStatusType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VerStatusType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VerStatusType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VerStatusTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVerStatusType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVerStatusType) StatusValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for status")
	}

	return validatorFn, nil
}

func (v *ValidateVerStatusType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VerStatusType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VerStatusType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["reason"]; exists {

		vOpts := append(opts, db.WithValidateField("reason"))
		if err := fv(ctx, m.GetReason(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVerStatusTypeValidator = func() *ValidateVerStatusType {
	v := &ValidateVerStatusType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStatus := v.StatusValidationRuleHandler
	rulesStatus := map[string]string{
		"ves.io.schema.rules.string.in": "[\"Incomplete\",\"Installed\"]",
	}
	vFn, err = vrhStatus(rulesStatus)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VerStatusType.status: %s", err)
		panic(errMsg)
	}
	v.FldValidators["status"] = vFn

	return v
}()

func VerStatusTypeValidator() db.Validator {
	return DefaultVerStatusTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *WebsocketConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WebsocketConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WebsocketConfigType) DeepCopy() *WebsocketConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WebsocketConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WebsocketConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WebsocketConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WebsocketConfigTypeValidator().Validate(ctx, m, opts...)
}

type ValidateWebsocketConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWebsocketConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WebsocketConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WebsocketConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["use_websocket"]; exists {

		vOpts := append(opts, db.WithValidateField("use_websocket"))
		if err := fv(ctx, m.GetUseWebsocket(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWebsocketConfigTypeValidator = func() *ValidateWebsocketConfigType {
	v := &ValidateWebsocketConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func WebsocketConfigTypeValidator() db.Validator {
	return DefaultWebsocketConfigTypeValidator
}

func (m *CreateSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.Routes = f.GetRoutes()
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *CreateSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *CreateSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.Routes = m1.Routes
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *CreateSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

func (m *GetSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.Routes = f.GetRoutes()
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *GetSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *GetSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.Routes = m1.Routes
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *GetSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.Routes = f.GetRoutes()
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.Routes = m1.Routes
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}
