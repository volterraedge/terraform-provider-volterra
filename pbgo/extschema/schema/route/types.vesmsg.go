//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//
package route

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *CookieForHashing) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CookieForHashing) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CookieForHashing) DeepCopy() *CookieForHashing {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CookieForHashing{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CookieForHashing) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CookieForHashing) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CookieForHashingValidator().Validate(ctx, m, opts...)
}

type ValidateCookieForHashing struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCookieForHashing) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateCookieForHashing) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CookieForHashing)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CookieForHashing got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ttl"]; exists {

		vOpts := append(opts, db.WithValidateField("ttl"))
		if err := fv(ctx, m.GetTtl(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCookieForHashingValidator = func() *ValidateCookieForHashing {
	v := &ValidateCookieForHashing{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CookieForHashing.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func CookieForHashingValidator() db.Validator {
	return DefaultCookieForHashingValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *CreateSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetRoutesDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetRoutesDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.Routes == nil {
		return []db.DRefInfo{}, nil
	}

	for idx, e := range m.Routes {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, dri := range driSet {
			dri.DRField = fmt.Sprintf("routes[%v].%s", idx, dri.DRField)
			drInfos = append(drInfos, dri)
		}
	}

	return drInfos, err
}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) RoutesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*RouteType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := RouteTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for routes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*RouteType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*RouteType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated routes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items routes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["routes"]; exists {
		vOpts := append(opts, db.WithValidateField("routes"))
		if err := fv(ctx, m.GetRoutes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRoutes := v.RoutesValidationRuleHandler
	rulesRoutes := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhRoutes(rulesRoutes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.routes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["routes"] = vFn

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GetSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetRoutesDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetRoutesDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.Routes == nil {
		return []db.DRefInfo{}, nil
	}

	for idx, e := range m.Routes {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, dri := range driSet {
			dri.DRField = fmt.Sprintf("routes[%v].%s", idx, dri.DRField)
			drInfos = append(drInfos, dri)
		}
	}

	return drInfos, err
}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) RoutesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*RouteType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := RouteTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for routes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*RouteType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*RouteType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated routes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items routes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["routes"]; exists {
		vOpts := append(opts, db.WithValidateField("routes"))
		if err := fv(ctx, m.GetRoutes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRoutes := v.RoutesValidationRuleHandler
	rulesRoutes := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhRoutes(rulesRoutes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.routes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["routes"] = vFn

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetRoutesDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetRoutesDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.Routes == nil {
		return []db.DRefInfo{}, nil
	}

	for idx, e := range m.Routes {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, dri := range driSet {
			dri.DRField = fmt.Sprintf("routes[%v].%s", idx, dri.DRField)
			drInfos = append(drInfos, dri)
		}
	}

	return drInfos, err
}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) RoutesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*RouteType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := RouteTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for routes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*RouteType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*RouteType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated routes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items routes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["routes"]; exists {
		vOpts := append(opts, db.WithValidateField("routes"))
		if err := fv(ctx, m.GetRoutes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRoutes := v.RoutesValidationRuleHandler
	rulesRoutes := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhRoutes(rulesRoutes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.routes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["routes"] = vFn

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *HashPolicyType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HashPolicyType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HashPolicyType) DeepCopy() *HashPolicyType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HashPolicyType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HashPolicyType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HashPolicyType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HashPolicyTypeValidator().Validate(ctx, m, opts...)
}

type ValidateHashPolicyType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHashPolicyType) PolicySpecifierValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for policy_specifier")
	}
	return validatorFn, nil
}

func (v *ValidateHashPolicyType) PolicySpecifierHeaderNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_HeaderName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for header_name")
	}
	return oValidatorFn_HeaderName, nil
}

func (v *ValidateHashPolicyType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HashPolicyType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HashPolicyType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["policy_specifier"]; exists {
		val := m.GetPolicySpecifier()
		vOpts := append(opts,
			db.WithValidateField("policy_specifier"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPolicySpecifier().(type) {
	case *HashPolicyType_HeaderName:
		if fv, exists := v.FldValidators["policy_specifier.header_name"]; exists {
			val := m.GetPolicySpecifier().(*HashPolicyType_HeaderName).HeaderName
			vOpts := append(opts,
				db.WithValidateField("policy_specifier"),
				db.WithValidateField("header_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HashPolicyType_Cookie:
		if fv, exists := v.FldValidators["policy_specifier.cookie"]; exists {
			val := m.GetPolicySpecifier().(*HashPolicyType_Cookie).Cookie
			vOpts := append(opts,
				db.WithValidateField("policy_specifier"),
				db.WithValidateField("cookie"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HashPolicyType_SourceIp:
		if fv, exists := v.FldValidators["policy_specifier.source_ip"]; exists {
			val := m.GetPolicySpecifier().(*HashPolicyType_SourceIp).SourceIp
			vOpts := append(opts,
				db.WithValidateField("policy_specifier"),
				db.WithValidateField("source_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["terminal"]; exists {

		vOpts := append(opts, db.WithValidateField("terminal"))
		if err := fv(ctx, m.GetTerminal(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHashPolicyTypeValidator = func() *ValidateHashPolicyType {
	v := &ValidateHashPolicyType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPolicySpecifier := v.PolicySpecifierValidationRuleHandler
	rulesPolicySpecifier := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPolicySpecifier(rulesPolicySpecifier)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HashPolicyType.policy_specifier: %s", err)
		panic(errMsg)
	}
	v.FldValidators["policy_specifier"] = vFn

	vrhPolicySpecifierHeaderName := v.PolicySpecifierHeaderNameValidationRuleHandler
	rulesPolicySpecifierHeaderName := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFnMap["policy_specifier.header_name"], err = vrhPolicySpecifierHeaderName(rulesPolicySpecifierHeaderName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field HashPolicyType.policy_specifier_header_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["policy_specifier.header_name"] = vFnMap["policy_specifier.header_name"]

	v.FldValidators["policy_specifier.cookie"] = CookieForHashingValidator().Validate

	return v
}()

func HashPolicyTypeValidator() db.Validator {
	return DefaultHashPolicyTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *MirrorPolicyType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MirrorPolicyType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MirrorPolicyType) DeepCopy() *MirrorPolicyType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MirrorPolicyType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MirrorPolicyType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MirrorPolicyType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MirrorPolicyTypeValidator().Validate(ctx, m, opts...)
}

func (m *MirrorPolicyType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetClusterDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *MirrorPolicyType) GetClusterDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetCluster() {
		if ref == nil {
			return nil, fmt.Errorf("MirrorPolicyType.cluster[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "cluster.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "cluster",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetClusterDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *MirrorPolicyType) GetClusterDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "cluster.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: cluster")
	}
	for _, ref := range m.GetCluster() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateMirrorPolicyType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMirrorPolicyType) ClusterValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cluster")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cluster")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cluster")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateMirrorPolicyType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MirrorPolicyType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MirrorPolicyType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cluster"]; exists {
		vOpts := append(opts, db.WithValidateField("cluster"))
		if err := fv(ctx, m.GetCluster(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["percent"]; exists {

		vOpts := append(opts, db.WithValidateField("percent"))
		if err := fv(ctx, m.GetPercent(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMirrorPolicyTypeValidator = func() *ValidateMirrorPolicyType {
	v := &ValidateMirrorPolicyType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCluster := v.ClusterValidationRuleHandler
	rulesCluster := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhCluster(rulesCluster)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MirrorPolicyType.cluster: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cluster"] = vFn

	v.FldValidators["percent"] = ves_io_schema.FractionalPercentValidator().Validate

	return v
}()

func MirrorPolicyTypeValidator() db.Validator {
	return DefaultMirrorPolicyTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *ReplaceSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetRoutesDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetRoutesDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.Routes == nil {
		return []db.DRefInfo{}, nil
	}

	for idx, e := range m.Routes {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, dri := range driSet {
			dri.DRField = fmt.Sprintf("routes[%v].%s", idx, dri.DRField)
			drInfos = append(drInfos, dri)
		}
	}

	return drInfos, err
}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) RoutesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*RouteType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := RouteTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for routes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*RouteType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*RouteType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated routes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items routes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["routes"]; exists {
		vOpts := append(opts, db.WithValidateField("routes"))
		if err := fv(ctx, m.GetRoutes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRoutes := v.RoutesValidationRuleHandler
	rulesRoutes := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhRoutes(rulesRoutes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.routes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["routes"] = vFn

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *RouteDestination) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RouteDestination) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RouteDestination) DeepCopy() *RouteDestination {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RouteDestination{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RouteDestination) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RouteDestination) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RouteDestinationValidator().Validate(ctx, m, opts...)
}

func (m *RouteDestination) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetClusterDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *RouteDestination) GetClusterDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetCluster() {
		if ref == nil {
			return nil, fmt.Errorf("RouteDestination.cluster[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "cluster.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "cluster",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetClusterDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *RouteDestination) GetClusterDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "cluster.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: cluster")
	}
	for _, ref := range m.GetCluster() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateRouteDestination struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRouteDestination) ClusterValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cluster")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cluster")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cluster")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteDestination) EndpointSubsetsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for endpoint_subsets")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for endpoint_subsets")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for endpoint_subsets")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map endpoint_subsets")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items endpoint_subsets")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteDestination) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RouteDestination)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RouteDestination got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cluster"]; exists {
		vOpts := append(opts, db.WithValidateField("cluster"))
		if err := fv(ctx, m.GetCluster(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["endpoint_subsets"]; exists {
		vOpts := append(opts, db.WithValidateField("endpoint_subsets"))
		if err := fv(ctx, m.GetEndpointSubsets(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["weight"]; exists {

		vOpts := append(opts, db.WithValidateField("weight"))
		if err := fv(ctx, m.GetWeight(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRouteDestinationValidator = func() *ValidateRouteDestination {
	v := &ValidateRouteDestination{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCluster := v.ClusterValidationRuleHandler
	rulesCluster := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhCluster(rulesCluster)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteDestination.cluster: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cluster"] = vFn

	vrhEndpointSubsets := v.EndpointSubsetsValidationRuleHandler
	rulesEndpointSubsets := map[string]string{
		"ves.io.schema.rules.map.max_pairs": "16",
	}
	vFn, err = vrhEndpointSubsets(rulesEndpointSubsets)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteDestination.endpoint_subsets: %s", err)
		panic(errMsg)
	}
	v.FldValidators["endpoint_subsets"] = vFn

	return v
}()

func RouteDestinationValidator() db.Validator {
	return DefaultRouteDestinationValidator
}

// augmented methods on protoc/std generated struct

func (m *RouteDestinationList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RouteDestinationList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RouteDestinationList) DeepCopy() *RouteDestinationList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RouteDestinationList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RouteDestinationList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RouteDestinationList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RouteDestinationListValidator().Validate(ctx, m, opts...)
}

func (m *RouteDestinationList) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetDestinationsDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetMirrorPolicyDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *RouteDestinationList) GetDestinationsDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.Destinations == nil {
		return []db.DRefInfo{}, nil
	}

	for idx, e := range m.Destinations {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, dri := range driSet {
			dri.DRField = fmt.Sprintf("destinations[%v].%s", idx, dri.DRField)
			drInfos = append(drInfos, dri)
		}
	}

	return drInfos, err
}

// GetDRefInfo for the field's type
func (m *RouteDestinationList) GetMirrorPolicyDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.MirrorPolicy == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.MirrorPolicy.GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "mirror_policy." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

type ValidateRouteDestinationList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRouteDestinationList) HostRewriteParamsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for HostRewriteParams")
	}
	return validatorFn, nil
}

func (v *ValidateRouteDestinationList) DestinationsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*RouteDestination, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := RouteDestinationValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for destinations")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*RouteDestination)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*RouteDestination, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated destinations")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items destinations")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteDestinationList) EndpointSubsetsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for endpoint_subsets")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for endpoint_subsets")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for endpoint_subsets")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map endpoint_subsets")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items endpoint_subsets")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteDestinationList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RouteDestinationList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RouteDestinationList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["HostRewriteParams"]; exists {
		val := m.GetHostRewriteParams()
		vOpts := append(opts,
			db.WithValidateField("HostRewriteParams"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetHostRewriteParams().(type) {
	case *RouteDestinationList_HostRewrite:
		if fv, exists := v.FldValidators["HostRewriteParams.host_rewrite"]; exists {
			val := m.GetHostRewriteParams().(*RouteDestinationList_HostRewrite).HostRewrite
			vOpts := append(opts,
				db.WithValidateField("HostRewriteParams"),
				db.WithValidateField("host_rewrite"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RouteDestinationList_AutoHostRewrite:
		if fv, exists := v.FldValidators["HostRewriteParams.auto_host_rewrite"]; exists {
			val := m.GetHostRewriteParams().(*RouteDestinationList_AutoHostRewrite).AutoHostRewrite
			vOpts := append(opts,
				db.WithValidateField("HostRewriteParams"),
				db.WithValidateField("auto_host_rewrite"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["buffer_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("buffer_policy"))
		if err := fv(ctx, m.GetBufferPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cors_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("cors_policy"))
		if err := fv(ctx, m.GetCorsPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["destinations"]; exists {
		vOpts := append(opts, db.WithValidateField("destinations"))
		if err := fv(ctx, m.GetDestinations(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["endpoint_subsets"]; exists {
		vOpts := append(opts, db.WithValidateField("endpoint_subsets"))
		if err := fv(ctx, m.GetEndpointSubsets(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["hash_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("hash_policy"))
		for idx, item := range m.GetHashPolicy() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["mirror_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("mirror_policy"))
		if err := fv(ctx, m.GetMirrorPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["prefix_rewrite"]; exists {

		vOpts := append(opts, db.WithValidateField("prefix_rewrite"))
		if err := fv(ctx, m.GetPrefixRewrite(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["priority"]; exists {

		vOpts := append(opts, db.WithValidateField("priority"))
		if err := fv(ctx, m.GetPriority(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["retry_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("retry_policy"))
		if err := fv(ctx, m.GetRetryPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["spdy_config"]; exists {

		vOpts := append(opts, db.WithValidateField("spdy_config"))
		if err := fv(ctx, m.GetSpdyConfig(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("timeout"))
		if err := fv(ctx, m.GetTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["web_socket_config"]; exists {

		vOpts := append(opts, db.WithValidateField("web_socket_config"))
		if err := fv(ctx, m.GetWebSocketConfig(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRouteDestinationListValidator = func() *ValidateRouteDestinationList {
	v := &ValidateRouteDestinationList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHostRewriteParams := v.HostRewriteParamsValidationRuleHandler
	rulesHostRewriteParams := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhHostRewriteParams(rulesHostRewriteParams)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteDestinationList.HostRewriteParams: %s", err)
		panic(errMsg)
	}
	v.FldValidators["HostRewriteParams"] = vFn

	vrhDestinations := v.DestinationsValidationRuleHandler
	rulesDestinations := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhDestinations(rulesDestinations)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteDestinationList.destinations: %s", err)
		panic(errMsg)
	}
	v.FldValidators["destinations"] = vFn

	vrhEndpointSubsets := v.EndpointSubsetsValidationRuleHandler
	rulesEndpointSubsets := map[string]string{
		"ves.io.schema.rules.map.max_pairs": "16",
	}
	vFn, err = vrhEndpointSubsets(rulesEndpointSubsets)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteDestinationList.endpoint_subsets: %s", err)
		panic(errMsg)
	}
	v.FldValidators["endpoint_subsets"] = vFn

	v.FldValidators["retry_policy"] = ves_io_schema.RetryPolicyTypeValidator().Validate

	v.FldValidators["mirror_policy"] = MirrorPolicyTypeValidator().Validate

	v.FldValidators["buffer_policy"] = ves_io_schema.BufferConfigTypeValidator().Validate

	v.FldValidators["cors_policy"] = ves_io_schema.CorsPolicyValidator().Validate

	v.FldValidators["hash_policy"] = HashPolicyTypeValidator().Validate

	return v
}()

func RouteDestinationListValidator() db.Validator {
	return DefaultRouteDestinationListValidator
}

// augmented methods on protoc/std generated struct

func (m *RouteDirectResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RouteDirectResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RouteDirectResponse) DeepCopy() *RouteDirectResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RouteDirectResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RouteDirectResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RouteDirectResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RouteDirectResponseValidator().Validate(ctx, m, opts...)
}

type ValidateRouteDirectResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRouteDirectResponse) ResponseCodeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for response_code")
	}

	return validatorFn, nil
}

func (v *ValidateRouteDirectResponse) ResponseBodyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for response_body")
	}

	return validatorFn, nil
}

func (v *ValidateRouteDirectResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RouteDirectResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RouteDirectResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["response_body"]; exists {

		vOpts := append(opts, db.WithValidateField("response_body"))
		if err := fv(ctx, m.GetResponseBody(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_code"]; exists {

		vOpts := append(opts, db.WithValidateField("response_code"))
		if err := fv(ctx, m.GetResponseCode(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRouteDirectResponseValidator = func() *ValidateRouteDirectResponse {
	v := &ValidateRouteDirectResponse{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhResponseCode := v.ResponseCodeValidationRuleHandler
	rulesResponseCode := map[string]string{
		"ves.io.schema.rules.uint32.gte": "100",
		"ves.io.schema.rules.uint32.lte": "599",
	}
	vFn, err = vrhResponseCode(rulesResponseCode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteDirectResponse.response_code: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_code"] = vFn

	vrhResponseBody := v.ResponseBodyValidationRuleHandler
	rulesResponseBody := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "8192",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhResponseBody(rulesResponseBody)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteDirectResponse.response_body: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_body"] = vFn

	return v
}()

func RouteDirectResponseValidator() db.Validator {
	return DefaultRouteDirectResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *RouteQueryParams) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RouteQueryParams) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RouteQueryParams) DeepCopy() *RouteQueryParams {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RouteQueryParams{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RouteQueryParams) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RouteQueryParams) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RouteQueryParamsValidator().Validate(ctx, m, opts...)
}

type ValidateRouteQueryParams struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRouteQueryParams) QueryParamsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for query_params")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for query_params")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated query_params")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items query_params")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteQueryParams) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RouteQueryParams)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RouteQueryParams got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["query_params"]; exists {
		vOpts := append(opts, db.WithValidateField("query_params"))
		if err := fv(ctx, m.GetQueryParams(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRouteQueryParamsValidator = func() *ValidateRouteQueryParams {
	v := &ValidateRouteQueryParams{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhQueryParams := v.QueryParamsValidationRuleHandler
	rulesQueryParams := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
	}
	vFn, err = vrhQueryParams(rulesQueryParams)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteQueryParams.query_params: %s", err)
		panic(errMsg)
	}
	v.FldValidators["query_params"] = vFn

	return v
}()

func RouteQueryParamsValidator() db.Validator {
	return DefaultRouteQueryParamsValidator
}

// augmented methods on protoc/std generated struct

func (m *RouteRedirect) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RouteRedirect) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RouteRedirect) DeepCopy() *RouteRedirect {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RouteRedirect{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RouteRedirect) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RouteRedirect) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RouteRedirectValidator().Validate(ctx, m, opts...)
}

type ValidateRouteRedirect struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRouteRedirect) ProtoRedirectValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for proto_redirect")
	}

	return validatorFn, nil
}

func (v *ValidateRouteRedirect) ResponseCodeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for response_code")
	}

	return validatorFn, nil
}

func (v *ValidateRouteRedirect) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RouteRedirect)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RouteRedirect got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetQueryParams().(type) {
	case *RouteRedirect_StripQueryParams:
		if fv, exists := v.FldValidators["QueryParams.strip_query_params"]; exists {
			val := m.GetQueryParams().(*RouteRedirect_StripQueryParams).StripQueryParams
			vOpts := append(opts,
				db.WithValidateField("QueryParams"),
				db.WithValidateField("strip_query_params"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RouteRedirect_AllParams:
		if fv, exists := v.FldValidators["QueryParams.all_params"]; exists {
			val := m.GetQueryParams().(*RouteRedirect_AllParams).AllParams
			vOpts := append(opts,
				db.WithValidateField("QueryParams"),
				db.WithValidateField("all_params"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RouteRedirect_RetainAllParams:
		if fv, exists := v.FldValidators["QueryParams.retain_all_params"]; exists {
			val := m.GetQueryParams().(*RouteRedirect_RetainAllParams).RetainAllParams
			vOpts := append(opts,
				db.WithValidateField("QueryParams"),
				db.WithValidateField("retain_all_params"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RouteRedirect_RemoveAllParams:
		if fv, exists := v.FldValidators["QueryParams.remove_all_params"]; exists {
			val := m.GetQueryParams().(*RouteRedirect_RemoveAllParams).RemoveAllParams
			vOpts := append(opts,
				db.WithValidateField("QueryParams"),
				db.WithValidateField("remove_all_params"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["host_redirect"]; exists {

		vOpts := append(opts, db.WithValidateField("host_redirect"))
		if err := fv(ctx, m.GetHostRedirect(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path_redirect"]; exists {

		vOpts := append(opts, db.WithValidateField("path_redirect"))
		if err := fv(ctx, m.GetPathRedirect(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["proto_redirect"]; exists {

		vOpts := append(opts, db.WithValidateField("proto_redirect"))
		if err := fv(ctx, m.GetProtoRedirect(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_code"]; exists {

		vOpts := append(opts, db.WithValidateField("response_code"))
		if err := fv(ctx, m.GetResponseCode(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRouteRedirectValidator = func() *ValidateRouteRedirect {
	v := &ValidateRouteRedirect{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhProtoRedirect := v.ProtoRedirectValidationRuleHandler
	rulesProtoRedirect := map[string]string{
		"ves.io.schema.rules.string.in": "[\"\",\"http\",\"https\"]",
	}
	vFn, err = vrhProtoRedirect(rulesProtoRedirect)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteRedirect.proto_redirect: %s", err)
		panic(errMsg)
	}
	v.FldValidators["proto_redirect"] = vFn

	vrhResponseCode := v.ResponseCodeValidationRuleHandler
	rulesResponseCode := map[string]string{
		"ves.io.schema.rules.uint32.lte": "599",
	}
	vFn, err = vrhResponseCode(rulesResponseCode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteRedirect.response_code: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_code"] = vFn

	v.FldValidators["QueryParams.strip_query_params"] = RouteQueryParamsValidator().Validate

	return v
}()

func RouteRedirectValidator() db.Validator {
	return DefaultRouteRedirectValidator
}

// augmented methods on protoc/std generated struct

func (m *RouteType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RouteType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RouteType) DeepCopy() *RouteType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RouteType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RouteType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RouteType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RouteTypeValidator().Validate(ctx, m, opts...)
}

func (m *RouteType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetRouteActionDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetWafTypeDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *RouteType) GetRouteActionDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.RouteAction == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetRouteAction().(type) {
	case *RouteType_RouteDestination:
		odrInfos, err = m.GetRouteDestination().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "route_destination." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	case *RouteType_RouteRedirect:

	case *RouteType_RouteDirectResponse:

	}

	return drInfos, err
}

// GetDRefInfo for the field's type
func (m *RouteType) GetWafTypeDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.WafType == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.WafType.GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "waf_type." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

type ValidateRouteType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRouteType) RouteActionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for RouteAction")
	}
	return validatorFn, nil
}

func (v *ValidateRouteType) RequestHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteType) ResponseHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteType) RequestHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for request_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteType) ResponseHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for response_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RouteType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RouteType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["RouteAction"]; exists {
		val := m.GetRouteAction()
		vOpts := append(opts,
			db.WithValidateField("RouteAction"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetRouteAction().(type) {
	case *RouteType_RouteDestination:
		if fv, exists := v.FldValidators["RouteAction.route_destination"]; exists {
			val := m.GetRouteAction().(*RouteType_RouteDestination).RouteDestination
			vOpts := append(opts,
				db.WithValidateField("RouteAction"),
				db.WithValidateField("route_destination"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RouteType_RouteRedirect:
		if fv, exists := v.FldValidators["RouteAction.route_redirect"]; exists {
			val := m.GetRouteAction().(*RouteType_RouteRedirect).RouteRedirect
			vOpts := append(opts,
				db.WithValidateField("RouteAction"),
				db.WithValidateField("route_redirect"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RouteType_RouteDirectResponse:
		if fv, exists := v.FldValidators["RouteAction.route_direct_response"]; exists {
			val := m.GetRouteAction().(*RouteType_RouteDirectResponse).RouteDirectResponse
			vOpts := append(opts,
				db.WithValidateField("RouteAction"),
				db.WithValidateField("route_direct_response"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["disable_custom_script"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_custom_script"))
		if err := fv(ctx, m.GetDisableCustomScript(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_location_add"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_location_add"))
		if err := fv(ctx, m.GetDisableLocationAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["match"]; exists {

		vOpts := append(opts, db.WithValidateField("match"))
		for idx, item := range m.GetMatch() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_add"))
		if err := fv(ctx, m.GetRequestHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_remove"))
		if err := fv(ctx, m.GetRequestHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_add"))
		if err := fv(ctx, m.GetResponseHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_remove"))
		if err := fv(ctx, m.GetResponseHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("service_policy"))
		if err := fv(ctx, m.GetServicePolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["waf_type"]; exists {

		vOpts := append(opts, db.WithValidateField("waf_type"))
		if err := fv(ctx, m.GetWafType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRouteTypeValidator = func() *ValidateRouteType {
	v := &ValidateRouteType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRouteAction := v.RouteActionValidationRuleHandler
	rulesRouteAction := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhRouteAction(rulesRouteAction)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteType.RouteAction: %s", err)
		panic(errMsg)
	}
	v.FldValidators["RouteAction"] = vFn

	vrhRequestHeadersToAdd := v.RequestHeadersToAddValidationRuleHandler
	rulesRequestHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
	}
	vFn, err = vrhRequestHeadersToAdd(rulesRequestHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteType.request_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_add"] = vFn

	vrhResponseHeadersToAdd := v.ResponseHeadersToAddValidationRuleHandler
	rulesResponseHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
	}
	vFn, err = vrhResponseHeadersToAdd(rulesResponseHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteType.response_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_add"] = vFn

	vrhRequestHeadersToRemove := v.RequestHeadersToRemoveValidationRuleHandler
	rulesRequestHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "32",
	}
	vFn, err = vrhRequestHeadersToRemove(rulesRequestHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteType.request_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_remove"] = vFn

	vrhResponseHeadersToRemove := v.ResponseHeadersToRemoveValidationRuleHandler
	rulesResponseHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "32",
	}
	vFn, err = vrhResponseHeadersToRemove(rulesResponseHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteType.response_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_remove"] = vFn

	v.FldValidators["RouteAction.route_destination"] = RouteDestinationListValidator().Validate
	v.FldValidators["RouteAction.route_redirect"] = RouteRedirectValidator().Validate
	v.FldValidators["RouteAction.route_direct_response"] = RouteDirectResponseValidator().Validate

	v.FldValidators["match"] = ves_io_schema.RouteMatchValidator().Validate

	v.FldValidators["waf_type"] = ves_io_schema.WafTypeValidator().Validate

	return v
}()

func RouteTypeValidator() db.Validator {
	return DefaultRouteTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ServicePolicyInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ServicePolicyInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ServicePolicyInfo) DeepCopy() *ServicePolicyInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ServicePolicyInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ServicePolicyInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ServicePolicyInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ServicePolicyInfoValidator().Validate(ctx, m, opts...)
}

type ValidateServicePolicyInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateServicePolicyInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ServicePolicyInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ServicePolicyInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["disable"]; exists {

		vOpts := append(opts, db.WithValidateField("disable"))
		if err := fv(ctx, m.GetDisable(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultServicePolicyInfoValidator = func() *ValidateServicePolicyInfo {
	v := &ValidateServicePolicyInfo{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ServicePolicyInfoValidator() db.Validator {
	return DefaultServicePolicyInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *SpdyConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SpdyConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SpdyConfigType) DeepCopy() *SpdyConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SpdyConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SpdyConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SpdyConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SpdyConfigTypeValidator().Validate(ctx, m, opts...)
}

type ValidateSpdyConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSpdyConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SpdyConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SpdyConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["use_spdy"]; exists {

		vOpts := append(opts, db.WithValidateField("use_spdy"))
		if err := fv(ctx, m.GetUseSpdy(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSpdyConfigTypeValidator = func() *ValidateSpdyConfigType {
	v := &ValidateSpdyConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SpdyConfigTypeValidator() db.Validator {
	return DefaultSpdyConfigTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *WebsocketConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WebsocketConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WebsocketConfigType) DeepCopy() *WebsocketConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WebsocketConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WebsocketConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WebsocketConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WebsocketConfigTypeValidator().Validate(ctx, m, opts...)
}

type ValidateWebsocketConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWebsocketConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WebsocketConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WebsocketConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["idle_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("idle_timeout"))
		if err := fv(ctx, m.GetIdleTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_connect_attempts"]; exists {

		vOpts := append(opts, db.WithValidateField("max_connect_attempts"))
		if err := fv(ctx, m.GetMaxConnectAttempts(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["use_websocket"]; exists {

		vOpts := append(opts, db.WithValidateField("use_websocket"))
		if err := fv(ctx, m.GetUseWebsocket(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWebsocketConfigTypeValidator = func() *ValidateWebsocketConfigType {
	v := &ValidateWebsocketConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func WebsocketConfigTypeValidator() db.Validator {
	return DefaultWebsocketConfigTypeValidator
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.Routes = f.GetRoutes()
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	f.Routes = m1.Routes
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.Routes = f.GetRoutes()
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	f.Routes = m1.Routes
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.Routes = f.GetRoutes()
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	f.Routes = m1.Routes
}
