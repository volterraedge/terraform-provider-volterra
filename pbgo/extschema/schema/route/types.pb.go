// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/route/types.proto

package route

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	policy "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/policy"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// JavaScriptLocation
//
// x-displayName: "JavaScript Location"
// All inside networks.
type JavaScriptLocation int32

const (
	// x-displayName: "After <head> tag"
	// Insert JavaScript after <head> tag
	AFTER_HEAD JavaScriptLocation = 0
	// x-displayName: "After </title> tag"
	// Insert JavaScript after </title> tag.
	AFTER_TITLE_END JavaScriptLocation = 1
	// x-displayName: "Before <script> tag"
	// Insert JavaScript before first <script> tag
	BEFORE_SCRIPT JavaScriptLocation = 2
)

var JavaScriptLocation_name = map[int32]string{
	0: "AFTER_HEAD",
	1: "AFTER_TITLE_END",
	2: "BEFORE_SCRIPT",
}

var JavaScriptLocation_value = map[string]int32{
	"AFTER_HEAD":      0,
	"AFTER_TITLE_END": 1,
	"BEFORE_SCRIPT":   2,
}

func (JavaScriptLocation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{0}
}

// TagAttributeName
//
// x-displayName: "Tag Attribute Name"
// Select from one of the predefined tag attributes.
type TagAttributeName int32

const (
	// x-displayName: "ID"
	JS_ATTR_ID TagAttributeName = 0
	// x-displayName: "CID"
	JS_ATTR_CID TagAttributeName = 1
	// x-displayName: "CN"
	JS_ATTR_CN TagAttributeName = 2
	// x-displayName: "Fraud & Risk - API Domain"
	JS_ATTR_API_DOMAIN TagAttributeName = 3
	// x-displayName: "Fraud & Risk - API URL"
	JS_ATTR_API_URL TagAttributeName = 4
	// x-displayName: "Fraud & Risk - API Path"
	JS_ATTR_API_PATH TagAttributeName = 5
	// x-displayName: "Async"
	JS_ATTR_ASYNC TagAttributeName = 6
	// x-displayName: "DEFER"
	JS_ATTR_DEFER TagAttributeName = 7
)

var TagAttributeName_name = map[int32]string{
	0: "JS_ATTR_ID",
	1: "JS_ATTR_CID",
	2: "JS_ATTR_CN",
	3: "JS_ATTR_API_DOMAIN",
	4: "JS_ATTR_API_URL",
	5: "JS_ATTR_API_PATH",
	6: "JS_ATTR_ASYNC",
	7: "JS_ATTR_DEFER",
}

var TagAttributeName_value = map[string]int32{
	"JS_ATTR_ID":         0,
	"JS_ATTR_CID":        1,
	"JS_ATTR_CN":         2,
	"JS_ATTR_API_DOMAIN": 3,
	"JS_ATTR_API_URL":    4,
	"JS_ATTR_API_PATH":   5,
	"JS_ATTR_ASYNC":      6,
	"JS_ATTR_DEFER":      7,
}

func (TagAttributeName) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{1}
}

// VerStatusType
//
// x-displayName: "VER Status Type"
// Status information sent for each route entry within route
type VerStatusType struct {
	// status
	//
	// x-displayName: "Status"
	// x-example: "Failed"
	// Status of the condition
	// "Incomplete" Validation of configuration has failed due to missing configuration.
	// "Installed" Validation has passed and configuration has been installed in data path or K8s
	Status string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// reason
	//
	// x-displayName: "Reason"
	// x-example: "Insufficient memory in data plane"
	// A human readable string explaining the reason for reaching this condition
	Reason string `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *VerStatusType) Reset()      { *m = VerStatusType{} }
func (*VerStatusType) ProtoMessage() {}
func (*VerStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{0}
}
func (m *VerStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VerStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerStatusType.Merge(m, src)
}
func (m *VerStatusType) XXX_Size() int {
	return m.Size()
}
func (m *VerStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_VerStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_VerStatusType proto.InternalMessageInfo

func (m *VerStatusType) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *VerStatusType) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// RouteDestination
//
// x-displayName: "Destination"
// Each destination is a reference to cluster, it's priority, weight and subset criteria.
type RouteDestination struct {
	// cluster
	//
	// x-displayName: "Cluster"
	// x-required
	// Indicates the upstream cluster to which the request should be sent. If the cluster
	// does not exist ServiceUnavailable response will be sent
	Cluster []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=cluster,proto3" json:"cluster,omitempty"`
	// weight
	//
	// x-displayName: "Weight"
	// x-example: "10"
	// When requests have to distributed among multiple upstream clusters,
	// multiple destinations are configured, each having its own cluster and weight.
	// Traffic is distributed among clusters based on the weight configured.
	//
	// Example:
	//    destinations:
	//    - cluster:
	//      - kind: ves.io.vega.cfg.adc.cluster.Object
	//        uid: cluster-1
	//     weight: 20
	//   - cluster:
	//     - kind: ves.io.vega.cfg.adc.cluster.Object
	//       uid: cluster-2
	//     weight: 30
	//   - cluster:
	//     - kind: ves.io.vega.cfg.adc.cluster.Object
	//       uid: cluster-3
	//     weight: 10
	//
	// This indicates that out of every 60 requests, 10 goes to cluster-3, 30 to
	// cluster-2 and 20 to cluster-1
	//
	// When single destination is configured, weight is ignored. All the requests are
	// sent to the cluster specified in the destination
	Weight uint32 `protobuf:"varint,3,opt,name=weight,proto3" json:"weight,omitempty"`
	// Priority
	//
	// x-displayName: "Priority"
	// x-example: "1"
	// Priority of this cluster, valid only with multiple destinations are configured.
	// Value of 0 will make the cluster as lowest priority upstream cluster
	// Priority of 1 means highest priority and is considered active.
	// When active cluster is not available, lower priority clusters are
	// made active as per the increasing priority.
	Priority uint32 `protobuf:"varint,5,opt,name=priority,proto3" json:"priority,omitempty"`
	// endpoint_subsets
	//
	// x-displayName: "Endpoint Subsets"
	// x-example: "value"
	// Upstream cluster may be configured to divide its endpoints into subsets based on metadata
	// attached to the endpoints. Routes may then specify the metadata that a endpoint must match in
	// order to be selected by the load balancer
	//
	// Labels field of endpoint object's metadata is used for subset matching.
	// For endpoints which are discovered in K8S or Consul cluster, the label of the service is merged with
	// endpoint's labels. In case of Consul, the label is derived from the "Tag" field.
	// For labels that are common between configured endpoint and discovered service, labels from discovered service
	// takes precedence.
	//
	// List of key-value pairs that will be used as matching metadata. Only those endpoints of
	// upstream cluster which match this metadata will be selected for load balancing
	EndpointSubsets map[string]string `protobuf:"bytes,4,rep,name=endpoint_subsets,json=endpointSubsets,proto3" json:"endpoint_subsets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *RouteDestination) Reset()      { *m = RouteDestination{} }
func (*RouteDestination) ProtoMessage() {}
func (*RouteDestination) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{1}
}
func (m *RouteDestination) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteDestination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteDestination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteDestination.Merge(m, src)
}
func (m *RouteDestination) XXX_Size() int {
	return m.Size()
}
func (m *RouteDestination) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteDestination.DiscardUnknown(m)
}

var xxx_messageInfo_RouteDestination proto.InternalMessageInfo

func (m *RouteDestination) GetCluster() []*schema.ObjectRefType {
	if m != nil {
		return m.Cluster
	}
	return nil
}

func (m *RouteDestination) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *RouteDestination) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *RouteDestination) GetEndpointSubsets() map[string]string {
	if m != nil {
		return m.EndpointSubsets
	}
	return nil
}

// MirrorPolicyType
//
// x-displayName: "Mirror Policy"
// MirrorPolicy is used for shadowing traffic from one cluster to another. The approach used
// is "fire and forget", meaning it will not wait for the shadow cluster to
// respond before returning the response from the primary cluster. All normal statistics are
// collected for the shadow cluster making this feature useful for testing and troubleshooting.
type MirrorPolicyType struct {
	// cluster
	//
	// x-displayName: "Mirror Destination Cluster"
	// x-required
	// Specifies the cluster to which the requests will be mirrored. The cluster object
	// referred here must be present.
	Cluster []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=cluster,proto3" json:"cluster,omitempty"`
	// percent
	//
	// x-displayName: "Mirror Percentage"
	// Percentage of requests to be mirrored
	Percent *schema.FractionalPercent `protobuf:"bytes,2,opt,name=percent,proto3" json:"percent,omitempty"`
}

func (m *MirrorPolicyType) Reset()      { *m = MirrorPolicyType{} }
func (*MirrorPolicyType) ProtoMessage() {}
func (*MirrorPolicyType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{2}
}
func (m *MirrorPolicyType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorPolicyType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MirrorPolicyType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorPolicyType.Merge(m, src)
}
func (m *MirrorPolicyType) XXX_Size() int {
	return m.Size()
}
func (m *MirrorPolicyType) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorPolicyType.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorPolicyType proto.InternalMessageInfo

func (m *MirrorPolicyType) GetCluster() []*schema.ObjectRefType {
	if m != nil {
		return m.Cluster
	}
	return nil
}

func (m *MirrorPolicyType) GetPercent() *schema.FractionalPercent {
	if m != nil {
		return m.Percent
	}
	return nil
}

// SpdyConfigType
//
// x-displayName: "SPDY Configuration"
// Request headers of such upgrade looks like below
//
//	'connection', 'Upgrade'
//	'upgrade', 'SPDY/3.1'
//
// Configuration to allow UPGRADE of connection to SPDY and any additional tuning
// With configuration to allow SPDY upgrade, ADC will produce following response
//
//	'HTTP/1.1 101 Switching Protocols
//	'Upgrade': 'SPDY/3.1'
//	'Connection': 'Upgrade'
type SpdyConfigType struct {
	// use_spdy
	//
	// x-displayName: "Use SPDY"
	// x-example: true
	// Specifies that the HTTP client connection to this route is allowed to upgrade to
	// a SPDY connection
	UseSpdy bool `protobuf:"varint,1,opt,name=use_spdy,json=useSpdy,proto3" json:"use_spdy,omitempty"`
}

func (m *SpdyConfigType) Reset()      { *m = SpdyConfigType{} }
func (*SpdyConfigType) ProtoMessage() {}
func (*SpdyConfigType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{3}
}
func (m *SpdyConfigType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpdyConfigType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SpdyConfigType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpdyConfigType.Merge(m, src)
}
func (m *SpdyConfigType) XXX_Size() int {
	return m.Size()
}
func (m *SpdyConfigType) XXX_DiscardUnknown() {
	xxx_messageInfo_SpdyConfigType.DiscardUnknown(m)
}

var xxx_messageInfo_SpdyConfigType proto.InternalMessageInfo

func (m *SpdyConfigType) GetUseSpdy() bool {
	if m != nil {
		return m.UseSpdy
	}
	return false
}

// WebsocketConfigType
//
// x-displayName: "Websocket Configuration"
// Configuration to allow Websocket
//
// Request headers of such upgrade looks like below
//
//	'connection', 'Upgrade'
//	'upgrade', 'websocket'
//
// With configuration to allow websocket upgrade, ADC will produce following response
//
//	'HTTP/1.1 101 Switching Protocols
//	'Upgrade': 'websocket'
//	'Connection': 'Upgrade'
type WebsocketConfigType struct {
	// use_websocket
	//
	// x-displayName: "Use Websocket"
	// x-example: true
	// Specifies that the HTTP client connection to this route is allowed to upgrade to
	// a WebSocket connection
	UseWebsocket bool `protobuf:"varint,1,opt,name=use_websocket,json=useWebsocket,proto3" json:"use_websocket,omitempty"`
}

func (m *WebsocketConfigType) Reset()      { *m = WebsocketConfigType{} }
func (*WebsocketConfigType) ProtoMessage() {}
func (*WebsocketConfigType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{4}
}
func (m *WebsocketConfigType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebsocketConfigType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WebsocketConfigType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebsocketConfigType.Merge(m, src)
}
func (m *WebsocketConfigType) XXX_Size() int {
	return m.Size()
}
func (m *WebsocketConfigType) XXX_DiscardUnknown() {
	xxx_messageInfo_WebsocketConfigType.DiscardUnknown(m)
}

var xxx_messageInfo_WebsocketConfigType proto.InternalMessageInfo

func (m *WebsocketConfigType) GetUseWebsocket() bool {
	if m != nil {
		return m.UseWebsocket
	}
	return false
}

// Cookie for hashing
//
// x-displayName: "Hashing using Cookie"
// Two types of cookie affinity:
//
//  1. Passive. Takes a cookie that's present in the cookies header and
//     hashes on its value.
//
//  2. Generated. Generates and sets a cookie with an expiration (TTL)
//     on the first request from the client in its response to the client,
//     based on the endpoint the request gets sent to. The client then
//     presents this on the next and all subsequent requests. The hash of
//     this is sufficient to ensure these requests get sent to the same
//     endpoint. The cookie is generated by hashing the source and
//     destination ports and addresses so that multiple independent HTTP2
//     streams on the same connection will independently receive the same
//     cookie, even if they arrive simultaneously.
type CookieForHashing struct {
	// name
	//
	// x-displayName: "Name"
	// x-required
	// x-example: "userid"
	// The name of the cookie that will be used to obtain the hash key. If the
	// cookie is not present and TTL below is not set, no hash will be
	// produced
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// ttl
	//
	// x-displayName: "TTL"
	// x-example: "5000"
	// If specified, a cookie with the TTL will be generated if the cookie is
	// not present. If the TTL is present and zero, the generated cookie will
	// be a session cookie. TTL value is in milliseconds
	Ttl uint32 `protobuf:"varint,2,opt,name=ttl,proto3" json:"ttl,omitempty"`
	// path
	//
	// x-displayName: "Path"
	// x-example: "/Users/userid/browser/cookies"
	// The name of the path for the cookie. If no path is specified here, no path
	// will be set for the cookie
	Path string `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
	// samesite
	//
	// x-displayName: "SameSite"
	// Controls whether or not a cookie is sent with cross-site requests
	//
	// Types that are valid to be assigned to Samesite:
	//	*CookieForHashing_IgnoreSamesite
	//	*CookieForHashing_SamesiteStrict
	//	*CookieForHashing_SamesiteLax
	//	*CookieForHashing_SamesiteNone
	Samesite isCookieForHashing_Samesite `protobuf_oneof:"samesite"`
	// secure
	//
	// x-displayName: "Secure"
	// A cookie with the Secure attribute is only sent to the server with an
	// encrypted request over the HTTPS protocol and therefore, is more
	// resistant to man-in-the-middle attacks.
	//
	// Types that are valid to be assigned to Secure:
	//	*CookieForHashing_IgnoreSecure
	//	*CookieForHashing_AddSecure
	Secure isCookieForHashing_Secure `protobuf_oneof:"secure"`
	// httponly
	//
	// x-displayName: "HttpOnly"
	// A cookie with the HttpOnly attribute is inaccessible to the JavaScript.
	//
	// Types that are valid to be assigned to Httponly:
	//	*CookieForHashing_IgnoreHttponly
	//	*CookieForHashing_AddHttponly
	Httponly isCookieForHashing_Httponly `protobuf_oneof:"httponly"`
}

func (m *CookieForHashing) Reset()      { *m = CookieForHashing{} }
func (*CookieForHashing) ProtoMessage() {}
func (*CookieForHashing) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{5}
}
func (m *CookieForHashing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CookieForHashing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CookieForHashing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CookieForHashing.Merge(m, src)
}
func (m *CookieForHashing) XXX_Size() int {
	return m.Size()
}
func (m *CookieForHashing) XXX_DiscardUnknown() {
	xxx_messageInfo_CookieForHashing.DiscardUnknown(m)
}

var xxx_messageInfo_CookieForHashing proto.InternalMessageInfo

type isCookieForHashing_Samesite interface {
	isCookieForHashing_Samesite()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCookieForHashing_Secure interface {
	isCookieForHashing_Secure()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCookieForHashing_Httponly interface {
	isCookieForHashing_Httponly()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CookieForHashing_IgnoreSamesite struct {
	IgnoreSamesite *schema.Empty `protobuf:"bytes,5,opt,name=ignore_samesite,json=ignoreSamesite,proto3,oneof" json:"ignore_samesite,omitempty"`
}
type CookieForHashing_SamesiteStrict struct {
	SamesiteStrict *schema.Empty `protobuf:"bytes,6,opt,name=samesite_strict,json=samesiteStrict,proto3,oneof" json:"samesite_strict,omitempty"`
}
type CookieForHashing_SamesiteLax struct {
	SamesiteLax *schema.Empty `protobuf:"bytes,7,opt,name=samesite_lax,json=samesiteLax,proto3,oneof" json:"samesite_lax,omitempty"`
}
type CookieForHashing_SamesiteNone struct {
	SamesiteNone *schema.Empty `protobuf:"bytes,8,opt,name=samesite_none,json=samesiteNone,proto3,oneof" json:"samesite_none,omitempty"`
}
type CookieForHashing_IgnoreSecure struct {
	IgnoreSecure *schema.Empty `protobuf:"bytes,10,opt,name=ignore_secure,json=ignoreSecure,proto3,oneof" json:"ignore_secure,omitempty"`
}
type CookieForHashing_AddSecure struct {
	AddSecure *schema.Empty `protobuf:"bytes,11,opt,name=add_secure,json=addSecure,proto3,oneof" json:"add_secure,omitempty"`
}
type CookieForHashing_IgnoreHttponly struct {
	IgnoreHttponly *schema.Empty `protobuf:"bytes,13,opt,name=ignore_httponly,json=ignoreHttponly,proto3,oneof" json:"ignore_httponly,omitempty"`
}
type CookieForHashing_AddHttponly struct {
	AddHttponly *schema.Empty `protobuf:"bytes,14,opt,name=add_httponly,json=addHttponly,proto3,oneof" json:"add_httponly,omitempty"`
}

func (*CookieForHashing_IgnoreSamesite) isCookieForHashing_Samesite() {}
func (*CookieForHashing_SamesiteStrict) isCookieForHashing_Samesite() {}
func (*CookieForHashing_SamesiteLax) isCookieForHashing_Samesite()    {}
func (*CookieForHashing_SamesiteNone) isCookieForHashing_Samesite()   {}
func (*CookieForHashing_IgnoreSecure) isCookieForHashing_Secure()     {}
func (*CookieForHashing_AddSecure) isCookieForHashing_Secure()        {}
func (*CookieForHashing_IgnoreHttponly) isCookieForHashing_Httponly() {}
func (*CookieForHashing_AddHttponly) isCookieForHashing_Httponly()    {}

func (m *CookieForHashing) GetSamesite() isCookieForHashing_Samesite {
	if m != nil {
		return m.Samesite
	}
	return nil
}
func (m *CookieForHashing) GetSecure() isCookieForHashing_Secure {
	if m != nil {
		return m.Secure
	}
	return nil
}
func (m *CookieForHashing) GetHttponly() isCookieForHashing_Httponly {
	if m != nil {
		return m.Httponly
	}
	return nil
}

func (m *CookieForHashing) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CookieForHashing) GetTtl() uint32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *CookieForHashing) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *CookieForHashing) GetIgnoreSamesite() *schema.Empty {
	if x, ok := m.GetSamesite().(*CookieForHashing_IgnoreSamesite); ok {
		return x.IgnoreSamesite
	}
	return nil
}

func (m *CookieForHashing) GetSamesiteStrict() *schema.Empty {
	if x, ok := m.GetSamesite().(*CookieForHashing_SamesiteStrict); ok {
		return x.SamesiteStrict
	}
	return nil
}

func (m *CookieForHashing) GetSamesiteLax() *schema.Empty {
	if x, ok := m.GetSamesite().(*CookieForHashing_SamesiteLax); ok {
		return x.SamesiteLax
	}
	return nil
}

func (m *CookieForHashing) GetSamesiteNone() *schema.Empty {
	if x, ok := m.GetSamesite().(*CookieForHashing_SamesiteNone); ok {
		return x.SamesiteNone
	}
	return nil
}

func (m *CookieForHashing) GetIgnoreSecure() *schema.Empty {
	if x, ok := m.GetSecure().(*CookieForHashing_IgnoreSecure); ok {
		return x.IgnoreSecure
	}
	return nil
}

func (m *CookieForHashing) GetAddSecure() *schema.Empty {
	if x, ok := m.GetSecure().(*CookieForHashing_AddSecure); ok {
		return x.AddSecure
	}
	return nil
}

func (m *CookieForHashing) GetIgnoreHttponly() *schema.Empty {
	if x, ok := m.GetHttponly().(*CookieForHashing_IgnoreHttponly); ok {
		return x.IgnoreHttponly
	}
	return nil
}

func (m *CookieForHashing) GetAddHttponly() *schema.Empty {
	if x, ok := m.GetHttponly().(*CookieForHashing_AddHttponly); ok {
		return x.AddHttponly
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CookieForHashing) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CookieForHashing_IgnoreSamesite)(nil),
		(*CookieForHashing_SamesiteStrict)(nil),
		(*CookieForHashing_SamesiteLax)(nil),
		(*CookieForHashing_SamesiteNone)(nil),
		(*CookieForHashing_IgnoreSecure)(nil),
		(*CookieForHashing_AddSecure)(nil),
		(*CookieForHashing_IgnoreHttponly)(nil),
		(*CookieForHashing_AddHttponly)(nil),
	}
}

// HashPolicyType
//
// x-displayName: "Hash Policy"
// HashPolicyType specifies the field of the incoming request that will be used for
// generating hash key. When multiple hash policies are configured, this can also specify
// if the current hash policy is terminal policy or not.
type HashPolicyType struct {
	// PolicySpecifier
	//
	// x-displayName: "Hash Policy Specifier"
	// x-required
	// Specifies whether hashing is done on incoming request header, cookie or source IP
	//
	// Types that are valid to be assigned to PolicySpecifier:
	//	*HashPolicyType_HeaderName
	//	*HashPolicyType_Cookie
	//	*HashPolicyType_SourceIp
	PolicySpecifier isHashPolicyType_PolicySpecifier `protobuf_oneof:"policy_specifier"`
	// terminal
	//
	// x-displayName: "Terminal"
	// x-example: true
	// Specify if its a terminal policy
	Terminal bool `protobuf:"varint,4,opt,name=terminal,proto3" json:"terminal,omitempty"`
}

func (m *HashPolicyType) Reset()      { *m = HashPolicyType{} }
func (*HashPolicyType) ProtoMessage() {}
func (*HashPolicyType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{6}
}
func (m *HashPolicyType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HashPolicyType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HashPolicyType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HashPolicyType.Merge(m, src)
}
func (m *HashPolicyType) XXX_Size() int {
	return m.Size()
}
func (m *HashPolicyType) XXX_DiscardUnknown() {
	xxx_messageInfo_HashPolicyType.DiscardUnknown(m)
}

var xxx_messageInfo_HashPolicyType proto.InternalMessageInfo

type isHashPolicyType_PolicySpecifier interface {
	isHashPolicyType_PolicySpecifier()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type HashPolicyType_HeaderName struct {
	HeaderName string `protobuf:"bytes,1,opt,name=header_name,json=headerName,proto3,oneof" json:"header_name,omitempty"`
}
type HashPolicyType_Cookie struct {
	Cookie *CookieForHashing `protobuf:"bytes,2,opt,name=cookie,proto3,oneof" json:"cookie,omitempty"`
}
type HashPolicyType_SourceIp struct {
	SourceIp bool `protobuf:"varint,3,opt,name=source_ip,json=sourceIp,proto3,oneof" json:"source_ip,omitempty"`
}

func (*HashPolicyType_HeaderName) isHashPolicyType_PolicySpecifier() {}
func (*HashPolicyType_Cookie) isHashPolicyType_PolicySpecifier()     {}
func (*HashPolicyType_SourceIp) isHashPolicyType_PolicySpecifier()   {}

func (m *HashPolicyType) GetPolicySpecifier() isHashPolicyType_PolicySpecifier {
	if m != nil {
		return m.PolicySpecifier
	}
	return nil
}

func (m *HashPolicyType) GetHeaderName() string {
	if x, ok := m.GetPolicySpecifier().(*HashPolicyType_HeaderName); ok {
		return x.HeaderName
	}
	return ""
}

func (m *HashPolicyType) GetCookie() *CookieForHashing {
	if x, ok := m.GetPolicySpecifier().(*HashPolicyType_Cookie); ok {
		return x.Cookie
	}
	return nil
}

func (m *HashPolicyType) GetSourceIp() bool {
	if x, ok := m.GetPolicySpecifier().(*HashPolicyType_SourceIp); ok {
		return x.SourceIp
	}
	return false
}

func (m *HashPolicyType) GetTerminal() bool {
	if m != nil {
		return m.Terminal
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*HashPolicyType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*HashPolicyType_HeaderName)(nil),
		(*HashPolicyType_Cookie)(nil),
		(*HashPolicyType_SourceIp)(nil),
	}
}

// RouteDestinationList
//
// x-displayName: "Destination List"
// List of destination to choose if the route is match.
type RouteDestinationList struct {
	// destinations
	//
	// x-displayName: "Destination Origin pools (clusters)"
	// x-required
	// When requests have to distributed among multiple upstream clusters,
	// multiple destinations are configured, each having its own cluster and weight.
	// Traffic is distributed among clusters based on the weight configured.
	//
	// Example:
	//    destinations:
	//    - cluster:
	//      - kind: ves.io.vega.cfg.adc.cluster.Object
	//        uid: cluster-1
	//     weight: 20
	//   - cluster:
	//     - kind: ves.io.vega.cfg.adc.cluster.Object
	//       uid: cluster-2
	//     weight: 30
	//   - cluster:
	//     - kind: ves.io.vega.cfg.adc.cluster.Object
	//       uid: cluster-3
	//     weight: 50
	//
	// This indicates that out of every 100 requests, 50 goes to cluster-3, 30 to
	// cluster-2 and 20 to cluster-1
	//
	// When single destination is configured, weight is ignored. All the requests are
	// sent to the cluster specified in the destination
	Destinations []*RouteDestination `protobuf:"bytes,1,rep,name=destinations,proto3" json:"destinations,omitempty"`
	// RouteDestinationRewrite
	//
	// x-displayName: "Route Destination Rewrite"
	// Specifies how the path can be modified during forwarding
	//
	// Types that are valid to be assigned to RouteDestinationRewrite:
	//	*RouteDestinationList_PrefixRewrite
	//	*RouteDestinationList_RegexRewrite
	RouteDestinationRewrite isRouteDestinationList_RouteDestinationRewrite `protobuf_oneof:"route_destination_rewrite"`
	// HostRewriteParams
	//
	// x-displayName: "Host Rewrite"
	// x-required
	// Specifies how the host header can be modified during forwarding
	//
	// Types that are valid to be assigned to HostRewriteParams:
	//	*RouteDestinationList_HostRewrite
	//	*RouteDestinationList_AutoHostRewrite
	HostRewriteParams isRouteDestinationList_HostRewriteParams `protobuf_oneof:"host_rewrite_params"`
	// timeout
	//
	// x-displayName: "Timeout"
	// x-example: "2000"
	// Specifies the timeout for the route in milliseconds.
	// This timeout includes all retries.
	// For server side streaming, configure this field with higher value or leave it un-configured
	// for infinite timeout
	Timeout uint32 `protobuf:"varint,8,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// retry_policy
	//
	// x-displayName: "Retry Policy"
	// Indicates that the route has a retry policy.
	RetryPolicy *schema.RetryPolicyType `protobuf:"bytes,9,opt,name=retry_policy,json=retryPolicy,proto3" json:"retry_policy,omitempty"`
	// endpoint_subsets
	//
	// x-displayName: "Endpoint Subsets"
	// x-example: "value"
	// Upstream cluster may be configured to divide its endpoints into subsets based on metadata
	// attached to the endpoints. Routes may then specify the metadata that a endpoint must match in
	// order to be selected by the load balancer
	//
	// Labels field of endpoint object's metadata is used for subset matching.
	// For endpoint's which are discovered in K8S or Consul cluster, the label of the service is merged with
	// endpoint's labels. In case of Consul, the label is derived from the "Tag" field.
	// For labels that are common between configured endpoint and discovered service, labels from discovered service
	// takes precedence.
	//
	// List of key-value pairs that will be used as matching metadata. Only those endpoints of
	// upstream cluster which match this metadata will be selected for load balancing
	EndpointSubsets map[string]string `protobuf:"bytes,10,rep,name=endpoint_subsets,json=endpointSubsets,proto3" json:"endpoint_subsets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// mirror_policy
	//
	// x-displayName: "Mirror Policy"
	// MirrorPolicy is used for shadowing traffic from one cluster to another. The current
	// implementation is "fire and forget," meaning it will not wait for the shadow cluster to
	// respond before returning the response from the primary cluster. All normal statistics are
	// collected for the shadow cluster making this feature useful for testing.
	//
	// During shadowing, the host/authority header is altered such that *-shadow* is appended. This is
	// useful for logging. For example, *cluster1* becomes *cluster1-shadow*.
	MirrorPolicy *MirrorPolicyType `protobuf:"bytes,11,opt,name=mirror_policy,json=mirrorPolicy,proto3" json:"mirror_policy,omitempty"`
	// web_socket_config
	//
	// x-displayName: "Websocket Configuration"
	// Websocket configuration for each route
	WebSocketConfig *WebsocketConfigType `protobuf:"bytes,13,opt,name=web_socket_config,json=webSocketConfig,proto3" json:"web_socket_config,omitempty"`
	// buffer_policy
	//
	// x-displayName: "Buffer Policy"
	// Buffering configuration for requests
	// Some upstream applications are not capable of handling streamed data. This config
	// enables buffering the entire request before sending to upstream application. We can
	// specify the maximum buffer size and buffer interval with this config.
	// Route level buffer configuration overrides any configuration at VirtualHost level.
	BufferPolicy *schema.BufferConfigType `protobuf:"bytes,14,opt,name=buffer_policy,json=bufferPolicy,proto3" json:"buffer_policy,omitempty"`
	// cors_policy
	//
	// x-displayName: "CORS Policy"
	// Cross-Origin Resource Sharing requests configuration
	//
	// CORS is a mechanism that uses additional HTTP headers to tell a browser to let
	// a web application running at one origin (domain) have permission to access selected
	// resources from a server at a different origin
	CorsPolicy *schema.CorsPolicy `protobuf:"bytes,15,opt,name=cors_policy,json=corsPolicy,proto3" json:"cors_policy,omitempty"`
	// csrf_policy
	//
	// x-displayName: "Cross-Site Request Forgery Protection"
	// Cross-Site Request Forgery (CSRF) is an attack that occurs when a malicious third-party website exploits a vulnerability thats allows them to submit an undesired request on user's behalf.
	//
	// The policy checks where a request is coming from to determine if the request's origin is the same as its destination. The policy relies on two pieces of information used in determining if a request originated from the same host.
	//
	// 1. The origin that caused the user agent to issue the request (source origin).
	// 2. The origin that the request is going to (target origin).
	// When the policy evaluating a request, it ensures both pieces of information are present and compare their values. If the source origin is missing or origins do not match the request is rejected. The exception to this being the source-origin has been added to the policy as valid.
	// Because CSRF attacks specifically target state-changing requests, the policy only acts on the HTTP requests that have state-changing method (PUT,POST, etc.).
	CsrfPolicy *schema.CsrfPolicy `protobuf:"bytes,24,opt,name=csrf_policy,json=csrfPolicy,proto3" json:"csrf_policy,omitempty"`
	// hash_policy
	//
	// x-displayName: "Hash Policy"
	// Specifies a list of hash policies to use for ring hash load balancing. Each
	// hash policy is evaluated individually and the combined result is used to
	// route the request
	HashPolicy []*HashPolicyType `protobuf:"bytes,16,rep,name=hash_policy,json=hashPolicy,proto3" json:"hash_policy,omitempty"`
	// priority
	//
	// x-displayName: "Priority"
	// Priority routing for each route. Different connection pools are used based on the priority of the route.
	// Also, circuit-breaker configuration at destination cluster is chosen based on the route priority.
	Priority schema.RoutingPriority `protobuf:"varint,18,opt,name=priority,proto3,enum=ves.io.schema.RoutingPriority" json:"priority,omitempty"`
	// spdy_config
	//
	// x-displayName: "SPDY Configuration"
	// SPDY configuration for each route
	SpdyConfig *SpdyConfigType `protobuf:"bytes,19,opt,name=spdy_config,json=spdyConfig,proto3" json:"spdy_config,omitempty"`
	// Oneof for Cluster retraction
	//
	// x-displayName: "Select Cluster retract option"
	// Specifies whether retraction of cluster has to be enabled or
	// disabled
	//
	// Types that are valid to be assigned to ClusterRetractChoice:
	//	*RouteDestinationList_RetractCluster
	//	*RouteDestinationList_DoNotRetractCluster
	ClusterRetractChoice isRouteDestinationList_ClusterRetractChoice `protobuf_oneof:"cluster_retract_choice"`
}

func (m *RouteDestinationList) Reset()      { *m = RouteDestinationList{} }
func (*RouteDestinationList) ProtoMessage() {}
func (*RouteDestinationList) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{7}
}
func (m *RouteDestinationList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteDestinationList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteDestinationList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteDestinationList.Merge(m, src)
}
func (m *RouteDestinationList) XXX_Size() int {
	return m.Size()
}
func (m *RouteDestinationList) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteDestinationList.DiscardUnknown(m)
}

var xxx_messageInfo_RouteDestinationList proto.InternalMessageInfo

type isRouteDestinationList_RouteDestinationRewrite interface {
	isRouteDestinationList_RouteDestinationRewrite()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isRouteDestinationList_HostRewriteParams interface {
	isRouteDestinationList_HostRewriteParams()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isRouteDestinationList_ClusterRetractChoice interface {
	isRouteDestinationList_ClusterRetractChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type RouteDestinationList_PrefixRewrite struct {
	PrefixRewrite string `protobuf:"bytes,5,opt,name=prefix_rewrite,json=prefixRewrite,proto3,oneof" json:"prefix_rewrite,omitempty"`
}
type RouteDestinationList_RegexRewrite struct {
	RegexRewrite *schema.RegexMatchRewrite `protobuf:"bytes,26,opt,name=regex_rewrite,json=regexRewrite,proto3,oneof" json:"regex_rewrite,omitempty"`
}
type RouteDestinationList_HostRewrite struct {
	HostRewrite string `protobuf:"bytes,6,opt,name=host_rewrite,json=hostRewrite,proto3,oneof" json:"host_rewrite,omitempty"`
}
type RouteDestinationList_AutoHostRewrite struct {
	AutoHostRewrite bool `protobuf:"varint,7,opt,name=auto_host_rewrite,json=autoHostRewrite,proto3,oneof" json:"auto_host_rewrite,omitempty"`
}
type RouteDestinationList_RetractCluster struct {
	RetractCluster *schema.Empty `protobuf:"bytes,21,opt,name=retract_cluster,json=retractCluster,proto3,oneof" json:"retract_cluster,omitempty"`
}
type RouteDestinationList_DoNotRetractCluster struct {
	DoNotRetractCluster *schema.Empty `protobuf:"bytes,22,opt,name=do_not_retract_cluster,json=doNotRetractCluster,proto3,oneof" json:"do_not_retract_cluster,omitempty"`
}

func (*RouteDestinationList_PrefixRewrite) isRouteDestinationList_RouteDestinationRewrite()    {}
func (*RouteDestinationList_RegexRewrite) isRouteDestinationList_RouteDestinationRewrite()     {}
func (*RouteDestinationList_HostRewrite) isRouteDestinationList_HostRewriteParams()            {}
func (*RouteDestinationList_AutoHostRewrite) isRouteDestinationList_HostRewriteParams()        {}
func (*RouteDestinationList_RetractCluster) isRouteDestinationList_ClusterRetractChoice()      {}
func (*RouteDestinationList_DoNotRetractCluster) isRouteDestinationList_ClusterRetractChoice() {}

func (m *RouteDestinationList) GetRouteDestinationRewrite() isRouteDestinationList_RouteDestinationRewrite {
	if m != nil {
		return m.RouteDestinationRewrite
	}
	return nil
}
func (m *RouteDestinationList) GetHostRewriteParams() isRouteDestinationList_HostRewriteParams {
	if m != nil {
		return m.HostRewriteParams
	}
	return nil
}
func (m *RouteDestinationList) GetClusterRetractChoice() isRouteDestinationList_ClusterRetractChoice {
	if m != nil {
		return m.ClusterRetractChoice
	}
	return nil
}

func (m *RouteDestinationList) GetDestinations() []*RouteDestination {
	if m != nil {
		return m.Destinations
	}
	return nil
}

func (m *RouteDestinationList) GetPrefixRewrite() string {
	if x, ok := m.GetRouteDestinationRewrite().(*RouteDestinationList_PrefixRewrite); ok {
		return x.PrefixRewrite
	}
	return ""
}

func (m *RouteDestinationList) GetRegexRewrite() *schema.RegexMatchRewrite {
	if x, ok := m.GetRouteDestinationRewrite().(*RouteDestinationList_RegexRewrite); ok {
		return x.RegexRewrite
	}
	return nil
}

func (m *RouteDestinationList) GetHostRewrite() string {
	if x, ok := m.GetHostRewriteParams().(*RouteDestinationList_HostRewrite); ok {
		return x.HostRewrite
	}
	return ""
}

func (m *RouteDestinationList) GetAutoHostRewrite() bool {
	if x, ok := m.GetHostRewriteParams().(*RouteDestinationList_AutoHostRewrite); ok {
		return x.AutoHostRewrite
	}
	return false
}

func (m *RouteDestinationList) GetTimeout() uint32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *RouteDestinationList) GetRetryPolicy() *schema.RetryPolicyType {
	if m != nil {
		return m.RetryPolicy
	}
	return nil
}

func (m *RouteDestinationList) GetEndpointSubsets() map[string]string {
	if m != nil {
		return m.EndpointSubsets
	}
	return nil
}

func (m *RouteDestinationList) GetMirrorPolicy() *MirrorPolicyType {
	if m != nil {
		return m.MirrorPolicy
	}
	return nil
}

func (m *RouteDestinationList) GetWebSocketConfig() *WebsocketConfigType {
	if m != nil {
		return m.WebSocketConfig
	}
	return nil
}

func (m *RouteDestinationList) GetBufferPolicy() *schema.BufferConfigType {
	if m != nil {
		return m.BufferPolicy
	}
	return nil
}

func (m *RouteDestinationList) GetCorsPolicy() *schema.CorsPolicy {
	if m != nil {
		return m.CorsPolicy
	}
	return nil
}

func (m *RouteDestinationList) GetCsrfPolicy() *schema.CsrfPolicy {
	if m != nil {
		return m.CsrfPolicy
	}
	return nil
}

func (m *RouteDestinationList) GetHashPolicy() []*HashPolicyType {
	if m != nil {
		return m.HashPolicy
	}
	return nil
}

func (m *RouteDestinationList) GetPriority() schema.RoutingPriority {
	if m != nil {
		return m.Priority
	}
	return schema.DEFAULT
}

func (m *RouteDestinationList) GetSpdyConfig() *SpdyConfigType {
	if m != nil {
		return m.SpdyConfig
	}
	return nil
}

func (m *RouteDestinationList) GetRetractCluster() *schema.Empty {
	if x, ok := m.GetClusterRetractChoice().(*RouteDestinationList_RetractCluster); ok {
		return x.RetractCluster
	}
	return nil
}

func (m *RouteDestinationList) GetDoNotRetractCluster() *schema.Empty {
	if x, ok := m.GetClusterRetractChoice().(*RouteDestinationList_DoNotRetractCluster); ok {
		return x.DoNotRetractCluster
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RouteDestinationList) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RouteDestinationList_PrefixRewrite)(nil),
		(*RouteDestinationList_RegexRewrite)(nil),
		(*RouteDestinationList_HostRewrite)(nil),
		(*RouteDestinationList_AutoHostRewrite)(nil),
		(*RouteDestinationList_RetractCluster)(nil),
		(*RouteDestinationList_DoNotRetractCluster)(nil),
	}
}

// RouteQueryParams
//
// x-displayName: "Query Parameters"
// Query params keys to strip while manipulating the HTTP request
type RouteQueryParams struct {
	// query_params
	//
	// x-displayName: "Query Parameters"
	// x-example: "userid"
	// Query params keys to strip while manipulating the HTTP request
	QueryParams []string `protobuf:"bytes,1,rep,name=query_params,json=queryParams,proto3" json:"query_params,omitempty"`
}

func (m *RouteQueryParams) Reset()      { *m = RouteQueryParams{} }
func (*RouteQueryParams) ProtoMessage() {}
func (*RouteQueryParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{8}
}
func (m *RouteQueryParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteQueryParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteQueryParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteQueryParams.Merge(m, src)
}
func (m *RouteQueryParams) XXX_Size() int {
	return m.Size()
}
func (m *RouteQueryParams) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteQueryParams.DiscardUnknown(m)
}

var xxx_messageInfo_RouteQueryParams proto.InternalMessageInfo

func (m *RouteQueryParams) GetQueryParams() []string {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

// RouteRedirect
//
// x-displayName: "Redirect"
// route redirect parameters when match action is redirect.
type RouteRedirect struct {
	// host_redirect
	//
	// x-displayName: "Host"
	// x-example: "one.ves.io"
	// swap host part of incoming URL in redirect URL
	HostRedirect string `protobuf:"bytes,1,opt,name=host_redirect,json=hostRedirect,proto3" json:"host_redirect,omitempty"`
	// Redirect Path
	//
	// x-displayName: "Redirect Path"
	// Path in the redirect response
	//
	// Types that are valid to be assigned to RedirectPathChoice:
	//	*RouteRedirect_PathRedirect
	//	*RouteRedirect_PrefixRewrite
	RedirectPathChoice isRouteRedirect_RedirectPathChoice `protobuf_oneof:"redirect_path_choice"`
	// proto_redirect
	//
	// x-displayName: "Protocol"
	// x-example: "https"
	// swap protocol part of incoming URL in redirect URL
	// The protocol can be swapped with either http or https
	// When incoming-proto option is specified, swapping of protocol is not done.
	ProtoRedirect string `protobuf:"bytes,3,opt,name=proto_redirect,json=protoRedirect,proto3" json:"proto_redirect,omitempty"`
	// port_redirect
	//
	// x-displayName: "Port"
	// x-example: "8443"
	// Specify the port value to redirect to a URL with non default port(443)
	PortRedirect uint32 `protobuf:"varint,13,opt,name=port_redirect,json=portRedirect,proto3" json:"port_redirect,omitempty"`
	// query_params
	//
	// x-displayName: "Query Parameters"
	// handling of incoming query parameters in redirect request.
	//
	// Types that are valid to be assigned to QueryParams:
	//	*RouteRedirect_StripQueryParams
	//	*RouteRedirect_AllParams
	//	*RouteRedirect_RetainAllParams
	//	*RouteRedirect_RemoveAllParams
	//	*RouteRedirect_ReplaceParams
	QueryParams isRouteRedirect_QueryParams `protobuf_oneof:"query_params"`
	// response_code
	//
	// x-displayName: "Response Code"
	// x-example: "303"
	// The HTTP status code to use in the redirect response.
	ResponseCode uint32 `protobuf:"varint,6,opt,name=response_code,json=responseCode,proto3" json:"response_code,omitempty"`
}

func (m *RouteRedirect) Reset()      { *m = RouteRedirect{} }
func (*RouteRedirect) ProtoMessage() {}
func (*RouteRedirect) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{9}
}
func (m *RouteRedirect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteRedirect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteRedirect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteRedirect.Merge(m, src)
}
func (m *RouteRedirect) XXX_Size() int {
	return m.Size()
}
func (m *RouteRedirect) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteRedirect.DiscardUnknown(m)
}

var xxx_messageInfo_RouteRedirect proto.InternalMessageInfo

type isRouteRedirect_RedirectPathChoice interface {
	isRouteRedirect_RedirectPathChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isRouteRedirect_QueryParams interface {
	isRouteRedirect_QueryParams()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type RouteRedirect_PathRedirect struct {
	PathRedirect string `protobuf:"bytes,2,opt,name=path_redirect,json=pathRedirect,proto3,oneof" json:"path_redirect,omitempty"`
}
type RouteRedirect_PrefixRewrite struct {
	PrefixRewrite string `protobuf:"bytes,11,opt,name=prefix_rewrite,json=prefixRewrite,proto3,oneof" json:"prefix_rewrite,omitempty"`
}
type RouteRedirect_StripQueryParams struct {
	StripQueryParams *RouteQueryParams `protobuf:"bytes,4,opt,name=strip_query_params,json=stripQueryParams,proto3,oneof" json:"strip_query_params,omitempty"`
}
type RouteRedirect_AllParams struct {
	AllParams bool `protobuf:"varint,5,opt,name=all_params,json=allParams,proto3,oneof" json:"all_params,omitempty"`
}
type RouteRedirect_RetainAllParams struct {
	RetainAllParams *schema.Empty `protobuf:"bytes,8,opt,name=retain_all_params,json=retainAllParams,proto3,oneof" json:"retain_all_params,omitempty"`
}
type RouteRedirect_RemoveAllParams struct {
	RemoveAllParams *schema.Empty `protobuf:"bytes,9,opt,name=remove_all_params,json=removeAllParams,proto3,oneof" json:"remove_all_params,omitempty"`
}
type RouteRedirect_ReplaceParams struct {
	ReplaceParams string `protobuf:"bytes,12,opt,name=replace_params,json=replaceParams,proto3,oneof" json:"replace_params,omitempty"`
}

func (*RouteRedirect_PathRedirect) isRouteRedirect_RedirectPathChoice()  {}
func (*RouteRedirect_PrefixRewrite) isRouteRedirect_RedirectPathChoice() {}
func (*RouteRedirect_StripQueryParams) isRouteRedirect_QueryParams()     {}
func (*RouteRedirect_AllParams) isRouteRedirect_QueryParams()            {}
func (*RouteRedirect_RetainAllParams) isRouteRedirect_QueryParams()      {}
func (*RouteRedirect_RemoveAllParams) isRouteRedirect_QueryParams()      {}
func (*RouteRedirect_ReplaceParams) isRouteRedirect_QueryParams()        {}

func (m *RouteRedirect) GetRedirectPathChoice() isRouteRedirect_RedirectPathChoice {
	if m != nil {
		return m.RedirectPathChoice
	}
	return nil
}
func (m *RouteRedirect) GetQueryParams() isRouteRedirect_QueryParams {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

func (m *RouteRedirect) GetHostRedirect() string {
	if m != nil {
		return m.HostRedirect
	}
	return ""
}

func (m *RouteRedirect) GetPathRedirect() string {
	if x, ok := m.GetRedirectPathChoice().(*RouteRedirect_PathRedirect); ok {
		return x.PathRedirect
	}
	return ""
}

func (m *RouteRedirect) GetPrefixRewrite() string {
	if x, ok := m.GetRedirectPathChoice().(*RouteRedirect_PrefixRewrite); ok {
		return x.PrefixRewrite
	}
	return ""
}

func (m *RouteRedirect) GetProtoRedirect() string {
	if m != nil {
		return m.ProtoRedirect
	}
	return ""
}

func (m *RouteRedirect) GetPortRedirect() uint32 {
	if m != nil {
		return m.PortRedirect
	}
	return 0
}

func (m *RouteRedirect) GetStripQueryParams() *RouteQueryParams {
	if x, ok := m.GetQueryParams().(*RouteRedirect_StripQueryParams); ok {
		return x.StripQueryParams
	}
	return nil
}

func (m *RouteRedirect) GetAllParams() bool {
	if x, ok := m.GetQueryParams().(*RouteRedirect_AllParams); ok {
		return x.AllParams
	}
	return false
}

func (m *RouteRedirect) GetRetainAllParams() *schema.Empty {
	if x, ok := m.GetQueryParams().(*RouteRedirect_RetainAllParams); ok {
		return x.RetainAllParams
	}
	return nil
}

func (m *RouteRedirect) GetRemoveAllParams() *schema.Empty {
	if x, ok := m.GetQueryParams().(*RouteRedirect_RemoveAllParams); ok {
		return x.RemoveAllParams
	}
	return nil
}

func (m *RouteRedirect) GetReplaceParams() string {
	if x, ok := m.GetQueryParams().(*RouteRedirect_ReplaceParams); ok {
		return x.ReplaceParams
	}
	return ""
}

func (m *RouteRedirect) GetResponseCode() uint32 {
	if m != nil {
		return m.ResponseCode
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RouteRedirect) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RouteRedirect_PathRedirect)(nil),
		(*RouteRedirect_PrefixRewrite)(nil),
		(*RouteRedirect_StripQueryParams)(nil),
		(*RouteRedirect_AllParams)(nil),
		(*RouteRedirect_RetainAllParams)(nil),
		(*RouteRedirect_RemoveAllParams)(nil),
		(*RouteRedirect_ReplaceParams)(nil),
	}
}

// RouteDirectResponse
//
// x-displayName: "Direct Response"
// Send this direct response in case of route match action is direct response
type RouteDirectResponse struct {
	// response_code
	//
	// x-displayName: "Response Code"
	// x-example: "200"
	// response code to send
	ResponseCode uint32 `protobuf:"varint,1,opt,name=response_code,json=responseCode,proto3" json:"response_code,omitempty"`
	// response_body
	//
	// x-displayName: "Response Body"
	// x-example: "OK"
	// response body to send
	ResponseBody string `protobuf:"bytes,2,opt,name=response_body,json=responseBody,proto3" json:"response_body,omitempty"`
}

func (m *RouteDirectResponse) Reset()      { *m = RouteDirectResponse{} }
func (*RouteDirectResponse) ProtoMessage() {}
func (*RouteDirectResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{10}
}
func (m *RouteDirectResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteDirectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteDirectResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteDirectResponse.Merge(m, src)
}
func (m *RouteDirectResponse) XXX_Size() int {
	return m.Size()
}
func (m *RouteDirectResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteDirectResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RouteDirectResponse proto.InternalMessageInfo

func (m *RouteDirectResponse) GetResponseCode() uint32 {
	if m != nil {
		return m.ResponseCode
	}
	return 0
}

func (m *RouteDirectResponse) GetResponseBody() string {
	if m != nil {
		return m.ResponseBody
	}
	return ""
}

// ContextExtensionInfo
//
// x-displayName: "Context Extension Configuration"
// Context Extension Configuration details
type ContextExtensionInfo struct {
	// context_extensions
	//
	// x-displayName: "Context Extensions"
	// x-example: "value"
	// provide extra context for the external authorization server on specific virtual hosts or routes.
	ContextExtensions map[string]string `protobuf:"bytes,1,rep,name=context_extensions,json=contextExtensions,proto3" json:"context_extensions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ContextExtensionInfo) Reset()      { *m = ContextExtensionInfo{} }
func (*ContextExtensionInfo) ProtoMessage() {}
func (*ContextExtensionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{11}
}
func (m *ContextExtensionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContextExtensionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ContextExtensionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContextExtensionInfo.Merge(m, src)
}
func (m *ContextExtensionInfo) XXX_Size() int {
	return m.Size()
}
func (m *ContextExtensionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ContextExtensionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ContextExtensionInfo proto.InternalMessageInfo

func (m *ContextExtensionInfo) GetContextExtensions() map[string]string {
	if m != nil {
		return m.ContextExtensions
	}
	return nil
}

// BotDefenseJavascriptInjectionType
//
// x-displayName: "Bot Defense Javascript Injection Configuration for inline deployments"
// Bot Defense Javascript Injection Configuration for inline bot defense deployments
type BotDefenseJavascriptInjectionType struct {
	// javascript_location
	//
	// x-displayName: "JavaScript Tag Location"
	// Select the location where you would like to insert the Javascript tag(s).
	JavascriptLocation JavaScriptLocation `protobuf:"varint,2,opt,name=javascript_location,json=javascriptLocation,proto3,enum=ves.io.schema.route.JavaScriptLocation" json:"javascript_location,omitempty"`
	// javascript_tags
	//
	// x-displayName: "JavaScript Tags"
	// x-required
	// Select Add item to configure your javascript tag. If adding both Bot Adv and Fraud, the Bot Javascript should be added first.
	JavascriptTags []*JavaScriptTag `protobuf:"bytes,3,rep,name=javascript_tags,json=javascriptTags,proto3" json:"javascript_tags,omitempty"`
}

func (m *BotDefenseJavascriptInjectionType) Reset()      { *m = BotDefenseJavascriptInjectionType{} }
func (*BotDefenseJavascriptInjectionType) ProtoMessage() {}
func (*BotDefenseJavascriptInjectionType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{12}
}
func (m *BotDefenseJavascriptInjectionType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BotDefenseJavascriptInjectionType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BotDefenseJavascriptInjectionType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BotDefenseJavascriptInjectionType.Merge(m, src)
}
func (m *BotDefenseJavascriptInjectionType) XXX_Size() int {
	return m.Size()
}
func (m *BotDefenseJavascriptInjectionType) XXX_DiscardUnknown() {
	xxx_messageInfo_BotDefenseJavascriptInjectionType.DiscardUnknown(m)
}

var xxx_messageInfo_BotDefenseJavascriptInjectionType proto.InternalMessageInfo

func (m *BotDefenseJavascriptInjectionType) GetJavascriptLocation() JavaScriptLocation {
	if m != nil {
		return m.JavascriptLocation
	}
	return AFTER_HEAD
}

func (m *BotDefenseJavascriptInjectionType) GetJavascriptTags() []*JavaScriptTag {
	if m != nil {
		return m.JavascriptTags
	}
	return nil
}

// JavaScriptTag
//
// x-displayName: "JavaScript Tag"
// JavaScript URL and attributes
type JavaScriptTag struct {
	// JavaScriptURL
	//
	// x-displayName: "URL"
	// x-example: "https://www.example.com/login/common.js?single"
	// x-required
	// Please enter the full URL (include domain and path), or relative path.
	JavascriptUrl string `protobuf:"bytes,1,opt,name=javascript_url,json=javascriptUrl,proto3" json:"javascript_url,omitempty"`
	// TagAttributes
	//
	// x-displayName: "Tag Attributes"
	// Add the tag attributes you want to include in your Javascript tag.
	TagAttributes []*TagAttribute `protobuf:"bytes,2,rep,name=tag_attributes,json=tagAttributes,proto3" json:"tag_attributes,omitempty"`
}

func (m *JavaScriptTag) Reset()      { *m = JavaScriptTag{} }
func (*JavaScriptTag) ProtoMessage() {}
func (*JavaScriptTag) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{13}
}
func (m *JavaScriptTag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JavaScriptTag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JavaScriptTag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JavaScriptTag.Merge(m, src)
}
func (m *JavaScriptTag) XXX_Size() int {
	return m.Size()
}
func (m *JavaScriptTag) XXX_DiscardUnknown() {
	xxx_messageInfo_JavaScriptTag.DiscardUnknown(m)
}

var xxx_messageInfo_JavaScriptTag proto.InternalMessageInfo

func (m *JavaScriptTag) GetJavascriptUrl() string {
	if m != nil {
		return m.JavascriptUrl
	}
	return ""
}

func (m *JavaScriptTag) GetTagAttributes() []*TagAttribute {
	if m != nil {
		return m.TagAttributes
	}
	return nil
}

// TagAttribute
//
// x-displayName: "Tag Attribute"
// Attribute for JavaScript tag
type TagAttribute struct {
	// JavaScriptTags
	//
	// x-displayName: "Name"
	// x-example: "ID"
	// Select from one of the predefined tag attibutes.
	JavascriptTag TagAttributeName `protobuf:"varint,1,opt,name=javascript_tag,json=javascriptTag,proto3,enum=ves.io.schema.route.TagAttributeName" json:"javascript_tag,omitempty"`
	// TagValue
	//
	// x-displayName: "Value"
	// x-example: "_imp_apg_dip_"
	// Add the tag attribute value.
	TagValue string `protobuf:"bytes,2,opt,name=tag_value,json=tagValue,proto3" json:"tag_value,omitempty"`
}

func (m *TagAttribute) Reset()      { *m = TagAttribute{} }
func (*TagAttribute) ProtoMessage() {}
func (*TagAttribute) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{14}
}
func (m *TagAttribute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagAttribute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TagAttribute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagAttribute.Merge(m, src)
}
func (m *TagAttribute) XXX_Size() int {
	return m.Size()
}
func (m *TagAttribute) XXX_DiscardUnknown() {
	xxx_messageInfo_TagAttribute.DiscardUnknown(m)
}

var xxx_messageInfo_TagAttribute proto.InternalMessageInfo

func (m *TagAttribute) GetJavascriptTag() TagAttributeName {
	if m != nil {
		return m.JavascriptTag
	}
	return JS_ATTR_ID
}

func (m *TagAttribute) GetTagValue() string {
	if m != nil {
		return m.TagValue
	}
	return ""
}

// ContentRewriteType
//
// x-displayName: "Content Rewrite Type"
// Rewrite HTML response to insert HTML content such as Javascript <script> tags into the HTML document
type ContentRewriteType struct {
	// Insert Content
	//
	// x-displayName: "HTML Content to insert"
	// x-example: "value"
	// HTML content to insert.
	InsertContent string `protobuf:"bytes,1,opt,name=insert_content,json=insertContent,proto3" json:"insert_content,omitempty"`
	// Element selector
	//
	// x-displayName: "Element selector to rewrite"
	// x-example: "value"
	// x-required
	// Element selector to insert into.
	ElementSelector string `protobuf:"bytes,2,opt,name=element_selector,json=elementSelector,proto3" json:"element_selector,omitempty"`
	// Position
	//
	// x-displayName: "HTML position"
	// Position of HTML content to be inserted within HTML tag.
	Position policy.HTMLPosition `protobuf:"varint,3,opt,name=position,proto3,enum=ves.io.schema.policy.HTMLPosition" json:"position,omitempty"`
}

func (m *ContentRewriteType) Reset()      { *m = ContentRewriteType{} }
func (*ContentRewriteType) ProtoMessage() {}
func (*ContentRewriteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{15}
}
func (m *ContentRewriteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContentRewriteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ContentRewriteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContentRewriteType.Merge(m, src)
}
func (m *ContentRewriteType) XXX_Size() int {
	return m.Size()
}
func (m *ContentRewriteType) XXX_DiscardUnknown() {
	xxx_messageInfo_ContentRewriteType.DiscardUnknown(m)
}

var xxx_messageInfo_ContentRewriteType proto.InternalMessageInfo

func (m *ContentRewriteType) GetInsertContent() string {
	if m != nil {
		return m.InsertContent
	}
	return ""
}

func (m *ContentRewriteType) GetElementSelector() string {
	if m != nil {
		return m.ElementSelector
	}
	return ""
}

func (m *ContentRewriteType) GetPosition() policy.HTMLPosition {
	if m != nil {
		return m.Position
	}
	return policy.BEGINNING
}

// ServicePolicyInfo
//
// x-displayName: "Service Policy Configuration"
// ServicePolicy configuration details at route level
type ServicePolicyInfo struct {
	// service_policy_choice
	//
	// x-displayName: "Service Policy Configuration"
	// Service Policy configuration details at route level
	//
	// Types that are valid to be assigned to ServicePolicyChoice:
	//	*ServicePolicyInfo_Disable
	//	*ServicePolicyInfo_ContextExtensions
	ServicePolicyChoice isServicePolicyInfo_ServicePolicyChoice `protobuf_oneof:"service_policy_choice"`
}

func (m *ServicePolicyInfo) Reset()      { *m = ServicePolicyInfo{} }
func (*ServicePolicyInfo) ProtoMessage() {}
func (*ServicePolicyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{16}
}
func (m *ServicePolicyInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServicePolicyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ServicePolicyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServicePolicyInfo.Merge(m, src)
}
func (m *ServicePolicyInfo) XXX_Size() int {
	return m.Size()
}
func (m *ServicePolicyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ServicePolicyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ServicePolicyInfo proto.InternalMessageInfo

type isServicePolicyInfo_ServicePolicyChoice interface {
	isServicePolicyInfo_ServicePolicyChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ServicePolicyInfo_Disable struct {
	Disable bool `protobuf:"varint,1,opt,name=disable,proto3,oneof" json:"disable,omitempty"`
}
type ServicePolicyInfo_ContextExtensions struct {
	ContextExtensions *ContextExtensionInfo `protobuf:"bytes,3,opt,name=context_extensions,json=contextExtensions,proto3,oneof" json:"context_extensions,omitempty"`
}

func (*ServicePolicyInfo_Disable) isServicePolicyInfo_ServicePolicyChoice()           {}
func (*ServicePolicyInfo_ContextExtensions) isServicePolicyInfo_ServicePolicyChoice() {}

func (m *ServicePolicyInfo) GetServicePolicyChoice() isServicePolicyInfo_ServicePolicyChoice {
	if m != nil {
		return m.ServicePolicyChoice
	}
	return nil
}

func (m *ServicePolicyInfo) GetDisable() bool {
	if x, ok := m.GetServicePolicyChoice().(*ServicePolicyInfo_Disable); ok {
		return x.Disable
	}
	return false
}

func (m *ServicePolicyInfo) GetContextExtensions() *ContextExtensionInfo {
	if x, ok := m.GetServicePolicyChoice().(*ServicePolicyInfo_ContextExtensions); ok {
		return x.ContextExtensions
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ServicePolicyInfo) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ServicePolicyInfo_Disable)(nil),
		(*ServicePolicyInfo_ContextExtensions)(nil),
	}
}

// RouteType
//
// x-displayName: "Route"
// Each RouteType is a rule which has match condition and action. When the condition is
// matched for incoming request, the specified action is taken.
type RouteType struct {
	// match
	//
	// x-displayName: "Match"
	// route match condition
	Match []*schema.RouteMatch `protobuf:"bytes,1,rep,name=match,proto3" json:"match,omitempty"`
	// route_action
	//
	// x-displayName: "Action"
	// x-required
	// one of action to take when match is successful
	//
	// Types that are valid to be assigned to RouteAction:
	//	*RouteType_RouteDestination
	//	*RouteType_RouteRedirect
	//	*RouteType_RouteDirectResponse
	RouteAction isRouteType_RouteAction `protobuf_oneof:"route_action"`
	// disable_custom_script
	//
	// x-displayName: "Disable Custom Script"
	// x-example: true
	// disable execution of Javascript at route level, if it is configured at virtual-host level
	DisableCustomScript bool `protobuf:"varint,5,opt,name=disable_custom_script,json=disableCustomScript,proto3" json:"disable_custom_script,omitempty"`
	// service_policy
	//
	// x-displayName: "Service Policy"
	// service policy configuration at route level which overrides configuration at virtual-host level
	ServicePolicy *ServicePolicyInfo `protobuf:"bytes,12,opt,name=service_policy,json=servicePolicy,proto3" json:"service_policy,omitempty"`
	// Headers to add in request
	//
	// x-displayName: "Request Headers to Add"
	// Headers are key-value pairs to be added to HTTP requests being sent towards upstream.
	// Headers specified at this level are applied before headers from the
	// enclosing VirtualHost object level
	RequestHeadersToAdd []*schema.HeaderManipulationOptionType `protobuf:"bytes,7,rep,name=request_headers_to_add,json=requestHeadersToAdd,proto3" json:"request_headers_to_add,omitempty"`
	// Headers to add in response
	//
	// x-displayName: "Response Headers to Add"
	// Headers are key-value pairs to be added to HTTP response being sent towards downstream.
	// Headers specified at this level are applied before headers from the
	// enclosing VirtualHost object level
	ResponseHeadersToAdd []*schema.HeaderManipulationOptionType `protobuf:"bytes,8,rep,name=response_headers_to_add,json=responseHeadersToAdd,proto3" json:"response_headers_to_add,omitempty"`
	// Header to be removed from request
	//
	// x-displayName: "Request Headers to Remove"
	// x-example: "host"
	// List of keys of Headers to be removed from the HTTP request being sent towards upstream.
	RequestHeadersToRemove []string `protobuf:"bytes,9,rep,name=request_headers_to_remove,json=requestHeadersToRemove,proto3" json:"request_headers_to_remove,omitempty"`
	// Header to be removed from response
	//
	// x-displayName: "Response Headers to Remove"
	// x-example: "host"
	// List of keys of Headers to be removed from the HTTP response being sent towards downstream.
	ResponseHeadersToRemove []string `protobuf:"bytes,10,rep,name=response_headers_to_remove,json=responseHeadersToRemove,proto3" json:"response_headers_to_remove,omitempty"`
	// Enable the WAF (Web Application Firewall) functionality for Route
	//
	// x-displayName: "WAF"
	// WAF can be used to analyze inbound and outbound HTTP/HTTPS traffic.
	// WAF can be configured either in BLOCKing Mode or ALERTing Mode.
	// In BLOCKing mode if WAF detects suspicious inbound/outbound traffic it blocks the request or response.
	// In ALERTing mode if suspicious traffic is detected, WAF generates ALERTs with details on the
	// suspicious traffic (instead of blocking traffic).
	//
	// waf_type is the App Firewall profile to use.
	//
	// waf_type specified at route level overrides waf configuration at VirtualHost level
	WafType *schema.WafType `protobuf:"bytes,11,opt,name=waf_type,json=wafType,proto3" json:"waf_type,omitempty"`
	// disable_location_add
	//
	// x-displayName: "Disable Location Addition"
	// x-example: true
	// disables append of x-volterra-location = <re-site-name> at route level, if it is configured at
	// virtual-host level. This configuration is ignored on CE sites.
	DisableLocationAdd bool `protobuf:"varint,13,opt,name=disable_location_add,json=disableLocationAdd,proto3" json:"disable_location_add,omitempty"`
	// skip_lb_override
	//
	// x-displayName: "Skip Loadbalancer Override"
	// x-example: true
	// Skips override of loadbalancer algorithm from VirtualHost. When this is skipped,
	// loadbalancer algorithm present in the cluster will be used. This is useful when
	// VirtualHost has many routes and we need to skip loadbalancer override on subset of
	// these routes.
	SkipLbOverride bool `protobuf:"varint,15,opt,name=skip_lb_override,json=skipLbOverride,proto3" json:"skip_lb_override,omitempty"`
	// Oneof Bot Defense Javascript Injection
	//
	// x-displayName: "Insert JavaScript Tag"
	// Insert JavaScript Tags for Bot Defense Advance and Fraud Services
	//
	// Types that are valid to be assigned to BotDefenseJavascriptInjectionChoice:
	//	*RouteType_InheritedBotDefenseJavascriptInjection
	//	*RouteType_BotDefenseJavascriptInjection
	BotDefenseJavascriptInjectionChoice isRouteType_BotDefenseJavascriptInjectionChoice `protobuf_oneof:"bot_defense_javascript_injection_choice"`
	// bot_defense_javascript_injection_inline_mode
	//
	// x-displayName: "Bot Defense Javascript Injection Inline Mode"
	// Specifies whether bot defense js injection inline mode will be enabled
	BotDefenseJavascriptInjectionInlineMode *ContentRewriteType `protobuf:"bytes,19,opt,name=bot_defense_javascript_injection_inline_mode,json=botDefenseJavascriptInjectionInlineMode,proto3" json:"bot_defense_javascript_injection_inline_mode,omitempty"`
}

func (m *RouteType) Reset()      { *m = RouteType{} }
func (*RouteType) ProtoMessage() {}
func (*RouteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{17}
}
func (m *RouteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteType.Merge(m, src)
}
func (m *RouteType) XXX_Size() int {
	return m.Size()
}
func (m *RouteType) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteType.DiscardUnknown(m)
}

var xxx_messageInfo_RouteType proto.InternalMessageInfo

type isRouteType_RouteAction interface {
	isRouteType_RouteAction()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isRouteType_BotDefenseJavascriptInjectionChoice interface {
	isRouteType_BotDefenseJavascriptInjectionChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type RouteType_RouteDestination struct {
	RouteDestination *RouteDestinationList `protobuf:"bytes,2,opt,name=route_destination,json=routeDestination,proto3,oneof" json:"route_destination,omitempty"`
}
type RouteType_RouteRedirect struct {
	RouteRedirect *RouteRedirect `protobuf:"bytes,3,opt,name=route_redirect,json=routeRedirect,proto3,oneof" json:"route_redirect,omitempty"`
}
type RouteType_RouteDirectResponse struct {
	RouteDirectResponse *RouteDirectResponse `protobuf:"bytes,4,opt,name=route_direct_response,json=routeDirectResponse,proto3,oneof" json:"route_direct_response,omitempty"`
}
type RouteType_InheritedBotDefenseJavascriptInjection struct {
	InheritedBotDefenseJavascriptInjection *schema.Empty `protobuf:"bytes,17,opt,name=inherited_bot_defense_javascript_injection,json=inheritedBotDefenseJavascriptInjection,proto3,oneof" json:"inherited_bot_defense_javascript_injection,omitempty"`
}
type RouteType_BotDefenseJavascriptInjection struct {
	BotDefenseJavascriptInjection *BotDefenseJavascriptInjectionType `protobuf:"bytes,18,opt,name=bot_defense_javascript_injection,json=botDefenseJavascriptInjection,proto3,oneof" json:"bot_defense_javascript_injection,omitempty"`
}

func (*RouteType_RouteDestination) isRouteType_RouteAction()    {}
func (*RouteType_RouteRedirect) isRouteType_RouteAction()       {}
func (*RouteType_RouteDirectResponse) isRouteType_RouteAction() {}
func (*RouteType_InheritedBotDefenseJavascriptInjection) isRouteType_BotDefenseJavascriptInjectionChoice() {
}
func (*RouteType_BotDefenseJavascriptInjection) isRouteType_BotDefenseJavascriptInjectionChoice() {}

func (m *RouteType) GetRouteAction() isRouteType_RouteAction {
	if m != nil {
		return m.RouteAction
	}
	return nil
}
func (m *RouteType) GetBotDefenseJavascriptInjectionChoice() isRouteType_BotDefenseJavascriptInjectionChoice {
	if m != nil {
		return m.BotDefenseJavascriptInjectionChoice
	}
	return nil
}

func (m *RouteType) GetMatch() []*schema.RouteMatch {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *RouteType) GetRouteDestination() *RouteDestinationList {
	if x, ok := m.GetRouteAction().(*RouteType_RouteDestination); ok {
		return x.RouteDestination
	}
	return nil
}

func (m *RouteType) GetRouteRedirect() *RouteRedirect {
	if x, ok := m.GetRouteAction().(*RouteType_RouteRedirect); ok {
		return x.RouteRedirect
	}
	return nil
}

func (m *RouteType) GetRouteDirectResponse() *RouteDirectResponse {
	if x, ok := m.GetRouteAction().(*RouteType_RouteDirectResponse); ok {
		return x.RouteDirectResponse
	}
	return nil
}

func (m *RouteType) GetDisableCustomScript() bool {
	if m != nil {
		return m.DisableCustomScript
	}
	return false
}

func (m *RouteType) GetServicePolicy() *ServicePolicyInfo {
	if m != nil {
		return m.ServicePolicy
	}
	return nil
}

func (m *RouteType) GetRequestHeadersToAdd() []*schema.HeaderManipulationOptionType {
	if m != nil {
		return m.RequestHeadersToAdd
	}
	return nil
}

func (m *RouteType) GetResponseHeadersToAdd() []*schema.HeaderManipulationOptionType {
	if m != nil {
		return m.ResponseHeadersToAdd
	}
	return nil
}

func (m *RouteType) GetRequestHeadersToRemove() []string {
	if m != nil {
		return m.RequestHeadersToRemove
	}
	return nil
}

func (m *RouteType) GetResponseHeadersToRemove() []string {
	if m != nil {
		return m.ResponseHeadersToRemove
	}
	return nil
}

func (m *RouteType) GetWafType() *schema.WafType {
	if m != nil {
		return m.WafType
	}
	return nil
}

func (m *RouteType) GetDisableLocationAdd() bool {
	if m != nil {
		return m.DisableLocationAdd
	}
	return false
}

func (m *RouteType) GetSkipLbOverride() bool {
	if m != nil {
		return m.SkipLbOverride
	}
	return false
}

func (m *RouteType) GetInheritedBotDefenseJavascriptInjection() *schema.Empty {
	if x, ok := m.GetBotDefenseJavascriptInjectionChoice().(*RouteType_InheritedBotDefenseJavascriptInjection); ok {
		return x.InheritedBotDefenseJavascriptInjection
	}
	return nil
}

func (m *RouteType) GetBotDefenseJavascriptInjection() *BotDefenseJavascriptInjectionType {
	if x, ok := m.GetBotDefenseJavascriptInjectionChoice().(*RouteType_BotDefenseJavascriptInjection); ok {
		return x.BotDefenseJavascriptInjection
	}
	return nil
}

func (m *RouteType) GetBotDefenseJavascriptInjectionInlineMode() *ContentRewriteType {
	if m != nil {
		return m.BotDefenseJavascriptInjectionInlineMode
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RouteType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RouteType_RouteDestination)(nil),
		(*RouteType_RouteRedirect)(nil),
		(*RouteType_RouteDirectResponse)(nil),
		(*RouteType_InheritedBotDefenseJavascriptInjection)(nil),
		(*RouteType_BotDefenseJavascriptInjection)(nil),
	}
}

// GlobalSpecType
//
// x-displayName: "Global Configuration Specification"
// Route object configuration
type GlobalSpecType struct {
	// routes
	//
	// x-displayName: "Routes"
	// x-required
	// List of routes to match for incoming request
	Routes []*RouteType `protobuf:"bytes,1,rep,name=routes,proto3" json:"routes,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{18}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

func (m *GlobalSpecType) GetRoutes() []*RouteType {
	if m != nil {
		return m.Routes
	}
	return nil
}

// CreateSpecType
//
// x-displayName: "Create Route"
// Create route object in a given namespace. Route object is list of route rules.
// Each rule has match condition to match incoming requests and actions to take on matching requests.
// Virtual host object has reference to route object
type CreateSpecType struct {
	Routes []*RouteType `protobuf:"bytes,1,rep,name=routes,proto3" json:"routes,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{19}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

func (m *CreateSpecType) GetRoutes() []*RouteType {
	if m != nil {
		return m.Routes
	}
	return nil
}

// ReplaceSpecType
//
// x-displayName: "Replace Route"
// Replace route object in a given namespace. Route object is list of route rules.
// Each rule has match condition to match incoming requests and actions to take on matching requests.
// Virtual host object has reference to route object
type ReplaceSpecType struct {
	Routes []*RouteType `protobuf:"bytes,1,rep,name=routes,proto3" json:"routes,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{20}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

func (m *ReplaceSpecType) GetRoutes() []*RouteType {
	if m != nil {
		return m.Routes
	}
	return nil
}

// GetSpecType
//
// x-displayName: "Get Route"
// Get route object in a given namespace. Route object is list of route rules.
// Each rule has match condition to match incoming requests and actions to take on matching requests.
// Virtual host object has reference to route object
type GetSpecType struct {
	Routes []*RouteType `protobuf:"bytes,1,rep,name=routes,proto3" json:"routes,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{21}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

func (m *GetSpecType) GetRoutes() []*RouteType {
	if m != nil {
		return m.Routes
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.route.JavaScriptLocation", JavaScriptLocation_name, JavaScriptLocation_value)
	golang_proto.RegisterEnum("ves.io.schema.route.JavaScriptLocation", JavaScriptLocation_name, JavaScriptLocation_value)
	proto.RegisterEnum("ves.io.schema.route.TagAttributeName", TagAttributeName_name, TagAttributeName_value)
	golang_proto.RegisterEnum("ves.io.schema.route.TagAttributeName", TagAttributeName_name, TagAttributeName_value)
	proto.RegisterType((*VerStatusType)(nil), "ves.io.schema.route.VerStatusType")
	golang_proto.RegisterType((*VerStatusType)(nil), "ves.io.schema.route.VerStatusType")
	proto.RegisterType((*RouteDestination)(nil), "ves.io.schema.route.RouteDestination")
	golang_proto.RegisterType((*RouteDestination)(nil), "ves.io.schema.route.RouteDestination")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.route.RouteDestination.EndpointSubsetsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.route.RouteDestination.EndpointSubsetsEntry")
	proto.RegisterType((*MirrorPolicyType)(nil), "ves.io.schema.route.MirrorPolicyType")
	golang_proto.RegisterType((*MirrorPolicyType)(nil), "ves.io.schema.route.MirrorPolicyType")
	proto.RegisterType((*SpdyConfigType)(nil), "ves.io.schema.route.SpdyConfigType")
	golang_proto.RegisterType((*SpdyConfigType)(nil), "ves.io.schema.route.SpdyConfigType")
	proto.RegisterType((*WebsocketConfigType)(nil), "ves.io.schema.route.WebsocketConfigType")
	golang_proto.RegisterType((*WebsocketConfigType)(nil), "ves.io.schema.route.WebsocketConfigType")
	proto.RegisterType((*CookieForHashing)(nil), "ves.io.schema.route.CookieForHashing")
	golang_proto.RegisterType((*CookieForHashing)(nil), "ves.io.schema.route.CookieForHashing")
	proto.RegisterType((*HashPolicyType)(nil), "ves.io.schema.route.HashPolicyType")
	golang_proto.RegisterType((*HashPolicyType)(nil), "ves.io.schema.route.HashPolicyType")
	proto.RegisterType((*RouteDestinationList)(nil), "ves.io.schema.route.RouteDestinationList")
	golang_proto.RegisterType((*RouteDestinationList)(nil), "ves.io.schema.route.RouteDestinationList")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.route.RouteDestinationList.EndpointSubsetsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.route.RouteDestinationList.EndpointSubsetsEntry")
	proto.RegisterType((*RouteQueryParams)(nil), "ves.io.schema.route.RouteQueryParams")
	golang_proto.RegisterType((*RouteQueryParams)(nil), "ves.io.schema.route.RouteQueryParams")
	proto.RegisterType((*RouteRedirect)(nil), "ves.io.schema.route.RouteRedirect")
	golang_proto.RegisterType((*RouteRedirect)(nil), "ves.io.schema.route.RouteRedirect")
	proto.RegisterType((*RouteDirectResponse)(nil), "ves.io.schema.route.RouteDirectResponse")
	golang_proto.RegisterType((*RouteDirectResponse)(nil), "ves.io.schema.route.RouteDirectResponse")
	proto.RegisterType((*ContextExtensionInfo)(nil), "ves.io.schema.route.ContextExtensionInfo")
	golang_proto.RegisterType((*ContextExtensionInfo)(nil), "ves.io.schema.route.ContextExtensionInfo")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.route.ContextExtensionInfo.ContextExtensionsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.route.ContextExtensionInfo.ContextExtensionsEntry")
	proto.RegisterType((*BotDefenseJavascriptInjectionType)(nil), "ves.io.schema.route.BotDefenseJavascriptInjectionType")
	golang_proto.RegisterType((*BotDefenseJavascriptInjectionType)(nil), "ves.io.schema.route.BotDefenseJavascriptInjectionType")
	proto.RegisterType((*JavaScriptTag)(nil), "ves.io.schema.route.JavaScriptTag")
	golang_proto.RegisterType((*JavaScriptTag)(nil), "ves.io.schema.route.JavaScriptTag")
	proto.RegisterType((*TagAttribute)(nil), "ves.io.schema.route.TagAttribute")
	golang_proto.RegisterType((*TagAttribute)(nil), "ves.io.schema.route.TagAttribute")
	proto.RegisterType((*ContentRewriteType)(nil), "ves.io.schema.route.ContentRewriteType")
	golang_proto.RegisterType((*ContentRewriteType)(nil), "ves.io.schema.route.ContentRewriteType")
	proto.RegisterType((*ServicePolicyInfo)(nil), "ves.io.schema.route.ServicePolicyInfo")
	golang_proto.RegisterType((*ServicePolicyInfo)(nil), "ves.io.schema.route.ServicePolicyInfo")
	proto.RegisterType((*RouteType)(nil), "ves.io.schema.route.RouteType")
	golang_proto.RegisterType((*RouteType)(nil), "ves.io.schema.route.RouteType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.route.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.route.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.route.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.route.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.route.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.route.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.route.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.route.GetSpecType")
}

func init() { proto.RegisterFile("ves.io/schema/route/types.proto", fileDescriptor_d8d3aa2b5dcc5c84) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/route/types.proto", fileDescriptor_d8d3aa2b5dcc5c84)
}

var fileDescriptor_d8d3aa2b5dcc5c84 = []byte{
	// 4077 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x7a, 0x5d, 0x6c, 0x1b, 0x57,
	0x76, 0xbf, 0x2e, 0x39, 0x22, 0x87, 0x87, 0x1f, 0x1a, 0x5d, 0x7d, 0x98, 0xe2, 0xc6, 0x0a, 0xc3,
	0xfc, 0x1d, 0x2b, 0xca, 0x98, 0x36, 0x29, 0x4b, 0x76, 0x14, 0xfc, 0x9d, 0x68, 0x64, 0x39, 0x92,
	0x22, 0xdb, 0xea, 0x48, 0x49, 0xda, 0x4d, 0x37, 0xd3, 0x21, 0x79, 0x45, 0x4d, 0x4c, 0xce, 0x30,
	0x33, 0x43, 0xd9, 0x7a, 0x08, 0xd6, 0xfb, 0x50, 0x74, 0xb1, 0x2d, 0xd0, 0x45, 0x1e, 0x83, 0xa0,
	0x28, 0xda, 0x97, 0xa2, 0xe8, 0x53, 0xd1, 0xa7, 0xd2, 0x40, 0x55, 0x03, 0x45, 0x17, 0x7e, 0xd2,
	0x4b, 0xb1, 0xc1, 0xa2, 0x0f, 0x1b, 0xa5, 0x0f, 0xe9, 0x4b, 0x11, 0xe4, 0xa9, 0x40, 0x1f, 0xb6,
	0xb8, 0xf7, 0xce, 0x0c, 0x67, 0x28, 0x5a, 0xb6, 0xd1, 0xdd, 0x17, 0x81, 0x33, 0xf7, 0x77, 0x7e,
	0xf7, 0x9c, 0xfb, 0x71, 0xce, 0xef, 0xde, 0x11, 0xbc, 0x7c, 0x40, 0x9c, 0xb2, 0x61, 0x5d, 0x76,
	0xea, 0xfb, 0xa4, 0xad, 0x5f, 0xb6, 0xad, 0xae, 0x4b, 0x2e, 0xbb, 0x87, 0x1d, 0xe2, 0x94, 0x3b,
	0xb6, 0xe5, 0x5a, 0x78, 0x82, 0x03, 0xca, 0x1c, 0x50, 0x66, 0x80, 0xc2, 0xa5, 0xa6, 0xe1, 0xee,
	0x77, 0x6b, 0xe5, 0xba, 0xd5, 0xbe, 0xdc, 0xb4, 0x9a, 0xd6, 0x65, 0x86, 0xad, 0x75, 0xf7, 0xd8,
	0x13, 0x7b, 0x60, 0xbf, 0x38, 0x47, 0xe1, 0x07, 0xd1, 0x4e, 0xac, 0x8e, 0x6b, 0x58, 0xa6, 0xd7,
	0x41, 0xa1, 0x18, 0x6d, 0xec, 0x58, 0x2d, 0xa3, 0x7e, 0x18, 0x76, 0xa1, 0x30, 0x13, 0x45, 0x84,
	0x9b, 0x5e, 0x8a, 0x36, 0x1d, 0xe8, 0x2d, 0xa3, 0xa1, 0xbb, 0x64, 0x38, 0xf5, 0x81, 0x41, 0xee,
	0x6b, 0x91, 0xce, 0x4b, 0x1a, 0x64, 0x3f, 0x20, 0xf6, 0x8e, 0xab, 0xbb, 0x5d, 0x67, 0xf7, 0xb0,
	0x43, 0xf0, 0x12, 0x24, 0x1c, 0xf6, 0x94, 0x47, 0x45, 0x34, 0x97, 0x52, 0x66, 0xff, 0xf1, 0x3f,
	0x8f, 0xe2, 0x33, 0xf6, 0x39, 0x15, 0x36, 0xcc, 0xba, 0xd5, 0xee, 0xb4, 0x88, 0x4b, 0xd4, 0xd4,
	0x86, 0xe9, 0xb8, 0x7a, 0xab, 0x45, 0x1a, 0xaa, 0x87, 0xc6, 0xd3, 0x90, 0xb0, 0x89, 0xee, 0x58,
	0x66, 0x3e, 0x46, 0xed, 0x54, 0xef, 0xa9, 0xf4, 0x0f, 0x02, 0x48, 0x2a, 0x1d, 0xb3, 0x9b, 0xc4,
	0x71, 0x0d, 0x53, 0xa7, 0x9d, 0xe3, 0x2d, 0x48, 0xd6, 0x5b, 0x5d, 0xc7, 0x25, 0x76, 0x1e, 0x15,
	0xe3, 0x73, 0xe9, 0xea, 0x4b, 0xe5, 0xe8, 0x28, 0xdf, 0xad, 0x7d, 0x42, 0xea, 0xae, 0x4a, 0xf6,
	0xa8, 0x4f, 0xca, 0xe4, 0xdf, 0x7e, 0xe6, 0xe3, 0xa9, 0x37, 0xa3, 0x9f, 0xa3, 0x98, 0x84, 0x54,
	0xff, 0x15, 0xbe, 0x08, 0x89, 0xfb, 0xc4, 0x68, 0xee, 0xbb, 0xf9, 0x78, 0x11, 0xcd, 0x65, 0x95,
	0xb1, 0xff, 0xee, 0xa1, 0x11, 0x0a, 0x4c, 0xcc, 0x0b, 0xf9, 0xdf, 0xfc, 0x26, 0xae, 0x7a, 0xcd,
	0xb8, 0x0c, 0x62, 0xc7, 0x36, 0x2c, 0xdb, 0x70, 0x0f, 0xf3, 0xa3, 0x0c, 0x8a, 0x8f, 0x7a, 0x08,
	0xfd, 0xaa, 0x87, 0x50, 0x85, 0xe2, 0x85, 0xf9, 0x58, 0xbe, 0xa8, 0x06, 0x18, 0xfc, 0x53, 0x04,
	0x12, 0x31, 0x1b, 0x1d, 0xcb, 0x30, 0x5d, 0xcd, 0xe9, 0xd6, 0x1c, 0xe2, 0x3a, 0x79, 0x81, 0x39,
	0xbc, 0x5c, 0x1e, 0xb2, 0x2c, 0xca, 0x83, 0x81, 0x96, 0xd7, 0x3c, 0xeb, 0x1d, 0x6e, 0xbc, 0x66,
	0xba, 0xf6, 0xa1, 0xf2, 0x0a, 0xed, 0xf4, 0x8b, 0x47, 0x48, 0x80, 0xd8, 0x08, 0x62, 0x01, 0x7d,
	0x81, 0x62, 0x92, 0x74, 0xf2, 0xeb, 0x7f, 0x89, 0x27, 0x7e, 0xf6, 0x08, 0xc5, 0xc4, 0x11, 0x75,
	0x8c, 0x44, 0x0d, 0x0b, 0x0a, 0x4c, 0x0e, 0xe3, 0xc2, 0x12, 0xc4, 0xef, 0x91, 0x43, 0x3e, 0x57,
	0x2a, 0xfd, 0x89, 0x27, 0x61, 0xf4, 0x40, 0x6f, 0x75, 0x89, 0x37, 0x0f, 0xfc, 0x61, 0x39, 0x76,
	0x1d, 0x2d, 0xff, 0x35, 0x7a, 0xdc, 0x43, 0x97, 0xe0, 0x0d, 0x28, 0xae, 0xf2, 0x91, 0x2b, 0xde,
	0x37, 0xdc, 0xfd, 0xe2, 0x87, 0x6c, 0x70, 0x8a, 0xba, 0xd9, 0x28, 0x6e, 0xfb, 0x91, 0x27, 0x2b,
	0xf2, 0x82, 0xbc, 0x28, 0x5f, 0x7d, 0xd2, 0x43, 0x26, 0x4c, 0x43, 0xd2, 0x33, 0x50, 0xd2, 0xc1,
	0xc4, 0x49, 0x08, 0x30, 0x24, 0xb8, 0x6d, 0x41, 0xf4, 0x67, 0x00, 0xa6, 0x41, 0xf4, 0x49, 0x0a,
	0xd0, 0x1f, 0x6e, 0x98, 0x03, 0xc9, 0xf7, 0xbf, 0xe8, 0x05, 0xb0, 0x39, 0x79, 0x7a, 0x74, 0x25,
	0x61, 0x53, 0x10, 0x63, 0x52, 0xbc, 0xf4, 0x25, 0x02, 0xe9, 0xb6, 0x61, 0xdb, 0x96, 0xbd, 0xcd,
	0xf6, 0x03, 0x5b, 0x9b, 0xbf, 0xdd, 0x65, 0xb3, 0x0c, 0xc9, 0x0e, 0xb1, 0xeb, 0xc4, 0x74, 0xd9,
	0x50, 0xa5, 0xab, 0xc5, 0x01, 0xb6, 0x5b, 0xb6, 0x5e, 0xa7, 0xb3, 0xa8, 0xb7, 0xb6, 0x39, 0x4e,
	0xf5, 0x0d, 0x4a, 0x6f, 0x40, 0x6e, 0xa7, 0xd3, 0x38, 0x5c, 0xb5, 0xcc, 0x3d, 0xa3, 0xc9, 0x7c,
	0x9b, 0x01, 0xb1, 0xeb, 0x10, 0xcd, 0xe9, 0x34, 0xf8, 0x6c, 0x88, 0x6a, 0xb2, 0xeb, 0x10, 0x0a,
	0x2a, 0xdd, 0x82, 0x89, 0x0f, 0x49, 0xcd, 0xb1, 0xea, 0xf7, 0x88, 0x1b, 0xb2, 0x78, 0x15, 0xb2,
	0xd4, 0xe2, 0xbe, 0xdf, 0xe4, 0x99, 0x65, 0xba, 0x0e, 0x09, 0xe0, 0x7c, 0x34, 0x36, 0x05, 0x31,
	0x2e, 0x09, 0xa5, 0x7f, 0x4d, 0x80, 0xb4, 0x6a, 0x59, 0xf7, 0x0c, 0x72, 0xcb, 0xb2, 0xd7, 0x75,
	0x67, 0xdf, 0x30, 0x9b, 0xf8, 0xff, 0x81, 0x60, 0xea, 0x6d, 0xe2, 0xed, 0x56, 0xc9, 0x5f, 0xfa,
	0x49, 0x7b, 0x54, 0x42, 0xf9, 0x87, 0x31, 0x95, 0xb5, 0xd2, 0x65, 0xe2, 0xba, 0x2d, 0x16, 0x67,
	0x56, 0xa5, 0x3f, 0x31, 0x06, 0xa1, 0xa3, 0xbb, 0xfb, 0x6c, 0xcb, 0xa4, 0x54, 0xf6, 0x1b, 0xbf,
	0x0d, 0x63, 0x46, 0xd3, 0xb4, 0x6c, 0xa2, 0x39, 0x7a, 0x9b, 0x38, 0x86, 0x4b, 0xd8, 0x36, 0x49,
	0x57, 0x27, 0x07, 0x46, 0x66, 0xad, 0xdd, 0x71, 0x0f, 0xd7, 0x47, 0xd4, 0x1c, 0x87, 0xef, 0x78,
	0x68, 0x4a, 0xe0, 0x5b, 0x6a, 0x8e, 0x6b, 0x1b, 0x75, 0x37, 0x9f, 0x38, 0x9b, 0xc0, 0x87, 0xef,
	0x30, 0x34, 0x7e, 0x13, 0x32, 0x01, 0x41, 0x4b, 0x7f, 0x90, 0x4f, 0x9e, 0x69, 0x9d, 0xf6, 0xb1,
	0x5b, 0xfa, 0x03, 0xfc, 0x16, 0x64, 0x03, 0x53, 0xd3, 0x32, 0x49, 0x5e, 0x3c, 0xd3, 0x36, 0xe8,
	0xe7, 0x8e, 0x65, 0x12, 0x6a, 0xec, 0x47, 0x4e, 0xea, 0x5d, 0x9b, 0xe4, 0xe1, 0x0c, 0x63, 0xa4,
	0x66, 0xbc, 0xb8, 0x19, 0x16, 0x2f, 0x02, 0xe8, 0x8d, 0x86, 0x6f, 0x99, 0x3e, 0xd3, 0x32, 0xa5,
	0x37, 0x1a, 0x9e, 0x59, 0x7f, 0xb4, 0xf7, 0x5d, 0xb7, 0x63, 0x99, 0xad, 0xc3, 0x7c, 0xf6, 0x0c,
	0xdb, 0x98, 0x3f, 0xda, 0xeb, 0x1e, 0x9a, 0x0e, 0x16, 0xed, 0x37, 0xb0, 0xce, 0x9d, 0x69, 0x9d,
	0xd6, 0x1b, 0x0d, 0xdf, 0x54, 0xb9, 0x0b, 0xa2, 0x1f, 0x3f, 0x5e, 0x3d, 0xea, 0xa1, 0xd1, 0xe3,
	0x1e, 0x12, 0x4e, 0x7a, 0x28, 0xb9, 0x28, 0x2f, 0xc9, 0xd7, 0xe4, 0xeb, 0x3f, 0x7b, 0x84, 0xe4,
	0xc2, 0x1c, 0x65, 0xd6, 0x5a, 0x96, 0xde, 0xa8, 0xe9, 0x2d, 0xdd, 0xac, 0x13, 0xbb, 0xec, 0x74,
	0x48, 0xbd, 0x5c, 0x67, 0x6b, 0x50, 0x73, 0x5c, 0xa3, 0x7e, 0xcf, 0x30, 0x89, 0xe3, 0x14, 0x91,
	0xf2, 0x1e, 0x24, 0x78, 0xfc, 0x78, 0xe5, 0xa8, 0x87, 0xe0, 0xb8, 0x87, 0x52, 0x27, 0x3d, 0x34,
	0x5a, 0xb9, 0x22, 0x57, 0x2a, 0x2f, 0x4c, 0x76, 0x1b, 0x44, 0x3f, 0x28, 0x46, 0x97, 0x3d, 0xee,
	0xa1, 0x0c, 0xa3, 0x5b, 0x90, 0x2b, 0x57, 0x5f, 0x94, 0x6e, 0x53, 0x10, 0x05, 0x69, 0x74, 0x53,
	0x10, 0x53, 0x12, 0x6c, 0x0a, 0x62, 0x46, 0xca, 0x96, 0x1e, 0xc5, 0x21, 0x47, 0x37, 0x50, 0x28,
	0xb7, 0x2c, 0x40, 0x7a, 0x9f, 0xe8, 0x0d, 0x62, 0x6b, 0x67, 0x6d, 0xa7, 0xf5, 0x11, 0x15, 0x38,
	0xec, 0x0e, 0xdd, 0x56, 0x6f, 0x43, 0x82, 0x77, 0xe8, 0x65, 0x90, 0x0b, 0x43, 0xab, 0xc2, 0xe0,
	0x9e, 0x5d, 0x1f, 0x51, 0x3d, 0x33, 0xfc, 0x2a, 0xa4, 0x1c, 0xab, 0x6b, 0xd7, 0x89, 0x66, 0x74,
	0xd8, 0x56, 0x14, 0x15, 0x81, 0xf6, 0xb9, 0x3e, 0xa2, 0x8a, 0xbc, 0x61, 0xa3, 0x83, 0x8b, 0x20,
	0xba, 0xc4, 0x6e, 0x1b, 0xa6, 0xde, 0xca, 0x0b, 0x7d, 0x8c, 0x1a, 0xbc, 0x5d, 0xfe, 0x27, 0x9a,
	0xd9, 0x0b, 0x90, 0x87, 0x71, 0xda, 0x45, 0x91, 0x87, 0x55, 0x54, 0xbb, 0x2d, 0xe2, 0xe0, 0x38,
	0x4f, 0xe3, 0x5f, 0x22, 0x50, 0x21, 0xed, 0xb5, 0xd0, 0x88, 0xe7, 0x57, 0x61, 0x05, 0xa6, 0x22,
	0x51, 0x57, 0x13, 0xeb, 0xec, 0x01, 0x24, 0x3f, 0xae, 0x6a, 0x82, 0x3b, 0x0f, 0xd3, 0x21, 0x47,
	0xab, 0xa9, 0x1d, 0xf6, 0xb3, 0xb8, 0xb1, 0x0d, 0x65, 0x18, 0xfd, 0x80, 0x16, 0x98, 0xea, 0x85,
	0x08, 0x13, 0xa4, 0xb9, 0x7d, 0x99, 0x3d, 0xf4, 0x4d, 0x69, 0x7d, 0xd8, 0xf5, 0xbc, 0xa6, 0xf5,
	0xc1, 0x8f, 0x40, 0xb9, 0x00, 0x12, 0x17, 0x3e, 0x1a, 0x9d, 0x46, 0x63, 0xcf, 0x20, 0x36, 0x1e,
	0x3f, 0xea, 0xa1, 0xd8, 0x71, 0x0f, 0x8d, 0xd2, 0xa9, 0xaf, 0xca, 0x15, 0x79, 0x61, 0x53, 0x10,
	0x47, 0xa5, 0x44, 0xe9, 0x4f, 0x73, 0x30, 0x39, 0x58, 0x6a, 0xb7, 0x0c, 0xc7, 0xc5, 0xef, 0x43,
	0xa6, 0xd1, 0x7f, 0xe5, 0x78, 0x55, 0xe2, 0xc2, 0x73, 0xd5, 0x6a, 0x05, 0x82, 0x22, 0x21, 0xa9,
	0x11, 0x1a, 0xbc, 0x0c, 0xb9, 0x8e, 0x4d, 0xf6, 0x8c, 0x07, 0x9a, 0x4d, 0xee, 0xdb, 0x7e, 0x5a,
	0x4c, 0x29, 0xe3, 0xfe, 0xf2, 0x10, 0xed, 0x44, 0xfe, 0x61, 0xec, 0xdb, 0x18, 0x5a, 0x1f, 0x51,
	0xb3, 0x1c, 0xaa, 0x72, 0x24, 0x7e, 0x17, 0xb2, 0x36, 0x69, 0x92, 0xbe, 0x69, 0x61, 0x68, 0xad,
	0x51, 0x29, 0xe6, 0xb6, 0xee, 0xd6, 0xf7, 0x3d, 0x43, 0x9a, 0xa2, 0x98, 0xa1, 0x4f, 0xb4, 0x08,
	0x99, 0x7d, 0xcb, 0x71, 0x03, 0x9e, 0xc4, 0x53, 0x56, 0x28, 0x52, 0xd3, 0x14, 0xe7, 0x9b, 0x55,
	0x61, 0x5c, 0xef, 0xba, 0x96, 0x16, 0xb1, 0x4d, 0x86, 0x56, 0x1a, 0x52, 0xc7, 0x28, 0x60, 0x3d,
	0x64, 0x73, 0x09, 0x92, 0xae, 0xd1, 0x26, 0x56, 0xd7, 0x65, 0x49, 0x34, 0xab, 0x4c, 0x50, 0xe4,
	0x4f, 0x1f, 0xf5, 0x55, 0xd5, 0xd1, 0x7f, 0xb5, 0x55, 0x1f, 0x83, 0xdf, 0x85, 0x8c, 0x4d, 0x5c,
	0xfb, 0x50, 0xe3, 0x33, 0x98, 0x4f, 0xb1, 0x08, 0x67, 0x4f, 0x45, 0xe8, 0xda, 0x87, 0xfd, 0x0d,
	0xa7, 0x08, 0xc7, 0x3d, 0x84, 0xd4, 0xb4, 0xdd, 0x7f, 0x8d, 0x7f, 0x3e, 0x4c, 0x6f, 0x01, 0x9b,
	0xc3, 0x1b, 0xcf, 0x35, 0x87, 0x74, 0x11, 0x0c, 0xd7, 0x5c, 0x17, 0xa8, 0xe6, 0x3a, 0x7e, 0x61,
	0xdd, 0x85, 0x77, 0x21, 0xdb, 0x66, 0x32, 0xc4, 0x0f, 0x2e, 0x7d, 0xc6, 0x46, 0x1f, 0x14, 0x2c,
	0x8a, 0xe8, 0xf7, 0xaa, 0x66, 0xda, 0xa1, 0x36, 0xfc, 0x31, 0x8c, 0xdf, 0x27, 0x35, 0x8d, 0xd7,
	0x78, 0xad, 0xce, 0x34, 0x81, 0x97, 0xfc, 0xe7, 0x86, 0x32, 0x0f, 0xd1, 0x0f, 0x21, 0xf2, 0xb1,
	0xfb, 0xa4, 0xb6, 0x13, 0x6a, 0xc6, 0x77, 0x20, 0x5b, 0xeb, 0xee, 0xed, 0x91, 0xc0, 0x6b, 0x5e,
	0x1a, 0x5e, 0x1e, 0xe0, 0x56, 0x18, 0x66, 0x28, 0x65, 0x86, 0xdb, 0x7b, 0xfe, 0xde, 0xa4, 0xfb,
	0xd9, 0x76, 0x7c, 0xb6, 0x31, 0xc6, 0x36, 0x33, 0xc0, 0xb6, 0x6a, 0xd9, 0x0e, 0xc7, 0x87, 0x78,
	0xa0, 0x1e, 0xbc, 0x65, 0x2c, 0x8e, 0xbd, 0xe7, 0xb3, 0xe4, 0x87, 0xb3, 0x38, 0xf6, 0xde, 0x10,
	0x96, 0xe0, 0x2d, 0xae, 0x43, 0x7a, 0x5f, 0x77, 0xf6, 0x7d, 0x16, 0x89, 0x2d, 0x8f, 0x57, 0x87,
	0x8e, 0x5a, 0x34, 0xc5, 0x2b, 0xe7, 0x7d, 0xbe, 0x60, 0xa3, 0x8b, 0x6c, 0xee, 0x3f, 0x7f, 0xc4,
	0x84, 0x21, 0xec, 0x07, 0x70, 0xfc, 0x4e, 0xe8, 0xa4, 0x80, 0x8b, 0x68, 0x2e, 0x77, 0x7a, 0x39,
	0x5b, 0x5d, 0xd7, 0x30, 0x9b, 0xbe, 0xd8, 0x55, 0x04, 0x4a, 0x1e, 0x3a, 0x3b, 0xdc, 0x81, 0x34,
	0xd5, 0x82, 0xfe, 0xe4, 0x4e, 0xb0, 0x60, 0x87, 0xbb, 0x19, 0x55, 0x92, 0x3c, 0xec, 0xef, 0x58,
	0xd8, 0x4e, 0xd0, 0x42, 0xd5, 0x02, 0xdd, 0x2a, 0x7a, 0xdd, 0xd5, 0x7c, 0x0d, 0x3c, 0x75, 0xb6,
	0x5a, 0xf0, 0xe0, 0x9e, 0x74, 0xc7, 0xef, 0xc1, 0x74, 0xc3, 0xd2, 0x4c, 0x8b, 0x66, 0x81, 0x28,
	0xcf, 0xf4, 0x99, 0x3c, 0x13, 0x0d, 0xeb, 0x8e, 0xe5, 0xaa, 0x11, 0xb2, 0xdf, 0xca, 0x71, 0xe4,
	0xcf, 0xd0, 0xf7, 0x37, 0x5e, 0xab, 0xc8, 0xd7, 0xe5, 0x37, 0xe5, 0xea, 0xa2, 0x5c, 0xbd, 0x22,
	0x33, 0xb1, 0x20, 0xb3, 0x1a, 0x2f, 0x57, 0x16, 0xe5, 0xca, 0x92, 0x5c, 0xb9, 0x2e, 0x57, 0xde,
	0x94, 0xab, 0x0b, 0x8f, 0x7b, 0x48, 0x83, 0xf3, 0x90, 0xbf, 0x6b, 0x1b, 0x4d, 0xc3, 0x2c, 0x6e,
	0x5b, 0x56, 0xcb, 0x61, 0x07, 0x16, 0x7e, 0xfe, 0x70, 0x30, 0xaa, 0xc0, 0x0d, 0x98, 0x08, 0x65,
	0x82, 0xe2, 0x4a, 0x9d, 0xe7, 0xee, 0x8b, 0xcf, 0xc3, 0x2f, 0x57, 0xaf, 0x2a, 0x97, 0x60, 0x86,
	0x4d, 0x87, 0x16, 0x4a, 0xfd, 0x7e, 0xc2, 0xc4, 0x92, 0xa7, 0x91, 0x66, 0x4e, 0x7a, 0x48, 0x58,
	0x94, 0xab, 0x4b, 0xca, 0x6b, 0x30, 0x11, 0x4e, 0xa9, 0x5a, 0x47, 0xb7, 0xf5, 0xb6, 0x83, 0xc7,
	0x8e, 0x7a, 0x28, 0x79, 0xdc, 0x43, 0x93, 0x27, 0x3d, 0x14, 0xbf, 0x26, 0x2f, 0x29, 0x57, 0x60,
	0xda, 0x1b, 0xe7, 0xfe, 0xb8, 0xef, 0x5b, 0x46, 0x9d, 0xe0, 0xe9, 0xa3, 0x1e, 0x9a, 0xfe, 0x05,
	0x5f, 0x92, 0xe7, 0x4e, 0x7a, 0x28, 0x51, 0xad, 0xca, 0xc5, 0x6a, 0x25, 0x2c, 0xf9, 0x03, 0xe9,
	0x32, 0x2e, 0xe1, 0x4d, 0x41, 0x9c, 0x91, 0x0a, 0x9b, 0x82, 0x38, 0x29, 0x4d, 0x71, 0x19, 0xb3,
	0x29, 0x88, 0xe7, 0xa4, 0x7c, 0x69, 0xcd, 0x3b, 0x60, 0xff, 0x5e, 0x97, 0xd8, 0x87, 0xdb, 0xdc,
	0x8d, 0x0a, 0x64, 0x3e, 0xa5, 0x8f, 0x9e, 0x5b, 0xac, 0x10, 0xa6, 0x94, 0x9c, 0x5f, 0x2c, 0xd8,
	0xe2, 0x2f, 0xaa, 0xe9, 0x4f, 0xfb, 0x26, 0xa5, 0xbf, 0x4b, 0x40, 0x96, 0xf1, 0xa8, 0xa4, 0x61,
	0xd8, 0xa4, 0xee, 0xe2, 0xd7, 0x21, 0xeb, 0x85, 0xc8, 0x5f, 0x78, 0xa2, 0x88, 0x8b, 0x8f, 0x0c,
	0x2f, 0x32, 0x1e, 0xf4, 0x3a, 0x64, 0xe9, 0x09, 0xa2, 0x0f, 0x8d, 0x05, 0x05, 0x12, 0x0d, 0x16,
	0xc8, 0x0c, 0x45, 0x06, 0x96, 0xa7, 0x6b, 0x6b, 0xfa, 0xe9, 0xa6, 0x03, 0xb5, 0xf5, 0x2e, 0xb5,
	0xb5, 0x5c, 0xab, 0xdf, 0x2d, 0x3b, 0xcd, 0x28, 0x73, 0x7e, 0x9c, 0x2f, 0xdb, 0xe7, 0xd5, 0x9c,
	0x61, 0xd6, 0xad, 0xb6, 0x61, 0x36, 0x2f, 0x31, 0xac, 0x2a, 0x50, 0xe5, 0xa8, 0x8e, 0xd2, 0xbf,
	0x0e, 0x25, 0xa4, 0xef, 0x7c, 0x67, 0xde, 0x82, 0x6c, 0xc7, 0xb2, 0x43, 0x11, 0x67, 0x59, 0xf9,
	0x9b, 0xfe, 0xea, 0x33, 0xf4, 0x6d, 0x0f, 0xa1, 0xc1, 0x7b, 0x85, 0x0c, 0x05, 0x07, 0xc6, 0x1f,
	0x03, 0xa6, 0x67, 0x9e, 0x8e, 0x16, 0x19, 0x79, 0xe1, 0x8c, 0x7a, 0x31, 0x38, 0x6d, 0x4a, 0xd2,
	0xeb, 0x68, 0x1d, 0xa9, 0x12, 0xe3, 0x0a, 0xcf, 0xe9, 0x1c, 0x80, 0xde, 0x6a, 0xf9, 0xbc, 0xa3,
	0xac, 0x84, 0x87, 0x0c, 0x52, 0x7a, 0xab, 0xe5, 0x21, 0x15, 0x18, 0xb7, 0x89, 0xab, 0x1b, 0xa6,
	0x16, 0x32, 0x10, 0xcf, 0x3c, 0x97, 0x8c, 0x71, 0x83, 0x95, 0x28, 0x47, 0xdb, 0x3a, 0x20, 0x61,
	0x8e, 0xd4, 0xb3, 0x38, 0xa8, 0x41, 0x9f, 0x63, 0x11, 0x72, 0x36, 0xe9, 0xb4, 0xf4, 0xba, 0xbf,
	0x3d, 0xf2, 0x19, 0x36, 0x3f, 0x99, 0x01, 0xc1, 0x92, 0xf5, 0x50, 0x9e, 0xd9, 0x32, 0x95, 0x4c,
	0x4e, 0xc7, 0x32, 0x1d, 0xa2, 0xd5, 0xad, 0x06, 0x97, 0x3a, 0x59, 0x65, 0xea, 0x57, 0x3d, 0x14,
	0x5f, 0xb8, 0x52, 0x09, 0x16, 0xf1, 0x7c, 0x3c, 0xff, 0x4b, 0x81, 0xaa, 0x24, 0x8e, 0x5d, 0xb5,
	0x1a, 0x64, 0x39, 0xfb, 0xfd, 0x0d, 0x58, 0x90, 0x2b, 0x74, 0xaf, 0x2f, 0xc9, 0xd7, 0x94, 0x39,
	0x98, 0xf4, 0xe7, 0x52, 0x63, 0x0b, 0xd4, 0xdb, 0x7b, 0x92, 0x27, 0x2d, 0x81, 0xee, 0xe7, 0xaa,
	0x5c, 0xa9, 0x28, 0xa5, 0xe8, 0x8e, 0xc1, 0xf8, 0xa8, 0x87, 0xc4, 0xe3, 0x1e, 0x4a, 0xd2, 0x9d,
	0x49, 0x73, 0x48, 0xa5, 0xba, 0x29, 0x88, 0x20, 0xa5, 0x37, 0x05, 0x31, 0x29, 0x89, 0xa5, 0xbf,
	0x42, 0x30, 0xc1, 0xe5, 0x07, 0x63, 0x57, 0x3d, 0x27, 0xf0, 0xe2, 0xa0, 0xf3, 0x88, 0x39, 0xdf,
	0xd7, 0x69, 0xf3, 0xa3, 0xf9, 0x5f, 0x0a, 0x73, 0x8d, 0xa8, 0xdf, 0x78, 0x29, 0x64, 0x56, 0xb3,
	0x1a, 0x87, 0xa1, 0x0d, 0x14, 0xf7, 0x76, 0x41, 0x11, 0xcd, 0x3d, 0x7c, 0x18, 0x8a, 0x57, 0xb1,
	0x1a, 0x87, 0xcb, 0x2f, 0x3d, 0xee, 0xa1, 0x3c, 0x4c, 0xc3, 0x18, 0x77, 0xa3, 0x18, 0xf8, 0x11,
	0xaf, 0xc8, 0xd5, 0xd2, 0xff, 0x20, 0x98, 0x5c, 0xb5, 0x4c, 0x97, 0x3c, 0x70, 0xd7, 0x1e, 0xb8,
	0xc4, 0x74, 0x0c, 0xcb, 0xdc, 0x30, 0xf7, 0x2c, 0xfc, 0x25, 0x02, 0x5c, 0xe7, 0x0d, 0x1a, 0xf1,
	0x5b, 0x7c, 0xbd, 0xfc, 0xce, 0x53, 0x4e, 0x31, 0xa7, 0x79, 0x4e, 0xbd, 0xf4, 0xd4, 0xd6, 0x1b,
	0xd4, 0xe5, 0xf4, 0x17, 0x48, 0x2c, 0x25, 0x6c, 0x41, 0x42, 0xf9, 0x77, 0xfa, 0x6a, 0x8b, 0xfe,
	0xca, 0x7c, 0x81, 0x52, 0xf3, 0xc1, 0x0d, 0xc5, 0x78, 0x7d, 0x90, 0xa4, 0x70, 0x13, 0xa6, 0x87,
	0x33, 0xbf, 0x48, 0x81, 0xa1, 0xd1, 0xbf, 0xa2, 0x58, 0xee, 0x4d, 0xb2, 0x47, 0x4c, 0x87, 0x6c,
	0xea, 0x07, 0xba, 0x53, 0xb7, 0x8d, 0x8e, 0xbb, 0x61, 0x7e, 0x42, 0x58, 0x75, 0x60, 0x07, 0xbf,
	0xdf, 0x87, 0x89, 0x4f, 0x82, 0x26, 0xad, 0x65, 0xd5, 0x59, 0xe6, 0x67, 0x6c, 0xb9, 0xea, 0xc5,
	0xa1, 0x43, 0x41, 0xa9, 0x76, 0x18, 0x7e, 0xcb, 0x83, 0xab, 0xb8, 0xcf, 0xe1, 0xbf, 0xc3, 0x07,
	0x30, 0x16, 0x62, 0x76, 0xf5, 0xa6, 0x93, 0x8f, 0xb3, 0x01, 0x2e, 0x3d, 0x83, 0x75, 0x57, 0x6f,
	0x2a, 0xaf, 0x07, 0x79, 0x7a, 0xd4, 0xff, 0x25, 0x06, 0xc2, 0x25, 0x8f, 0xc2, 0xc2, 0x25, 0xd7,
	0xef, 0x65, 0x57, 0x6f, 0x3a, 0x9b, 0x82, 0x88, 0xa4, 0x58, 0xe9, 0x09, 0x82, 0x6c, 0x84, 0x92,
	0xa6, 0xda, 0x90, 0x3f, 0x5d, 0xbb, 0xe5, 0x25, 0xf4, 0x09, 0x46, 0x6b, 0xc7, 0xe7, 0x1e, 0xb2,
	0xd9, 0x11, 0xec, 0x58, 0x11, 0xa9, 0xd9, 0x3e, 0xf4, 0x7d, 0xbb, 0x85, 0x3f, 0x86, 0x9c, 0xab,
	0x37, 0x35, 0xdd, 0x75, 0x6d, 0xa3, 0xd6, 0x75, 0x89, 0x93, 0x8f, 0xb1, 0x50, 0x5e, 0x19, 0x1a,
	0xca, 0xae, 0xde, 0x5c, 0xf1, 0x91, 0xca, 0x64, 0x10, 0x49, 0xaa, 0xef, 0xbf, 0x9a, 0x75, 0x43,
	0x18, 0x67, 0xf9, 0xfc, 0x93, 0x1e, 0x9a, 0x81, 0x73, 0x10, 0x7f, 0x5f, 0xdd, 0x2a, 0x48, 0x83,
	0x8e, 0x96, 0xfe, 0x18, 0x41, 0x26, 0x4c, 0x8a, 0xb7, 0x22, 0x10, 0x57, 0x6f, 0xb2, 0x58, 0x72,
	0x4f, 0x49, 0xb4, 0x61, 0x53, 0x7a, 0x70, 0x0f, 0x47, 0x47, 0x47, 0xe6, 0x22, 0xa4, 0x68, 0x74,
	0xa1, 0x75, 0xe4, 0x9d, 0x06, 0xe9, 0xa0, 0x88, 0xaa, 0xe8, 0xea, 0x4d, 0x76, 0xca, 0xa5, 0x83,
	0x8a, 0xd9, 0xca, 0x34, 0xfd, 0xc3, 0x12, 0x5b, 0x43, 0x8b, 0x90, 0x33, 0x4c, 0x87, 0xd8, 0x4c,
	0xcb, 0xd3, 0x46, 0x6f, 0x64, 0x73, 0xfe, 0xf6, 0x1d, 0xb5, 0xe3, 0xf9, 0xbf, 0x7c, 0x5b, 0xcd,
	0x72, 0x94, 0xc7, 0x80, 0xff, 0x3f, 0x48, 0xa4, 0x45, 0xda, 0x84, 0x9e, 0x76, 0x48, 0x8b, 0xd4,
	0x5d, 0xcb, 0xf6, 0x7a, 0xc7, 0xde, 0x44, 0xf0, 0x9d, 0x23, 0xd8, 0x74, 0x9a, 0xc7, 0x3c, 0xec,
	0x8e, 0x07, 0xc5, 0x37, 0x40, 0xec, 0x58, 0x8e, 0xc1, 0x96, 0x6b, 0x9c, 0x45, 0x3f, 0xb8, 0xb0,
	0xb8, 0x46, 0x2e, 0xaf, 0xef, 0xde, 0xde, 0xda, 0xf6, 0x90, 0x6a, 0x60, 0x53, 0xfa, 0x67, 0x04,
	0xe3, 0x3b, 0xc4, 0x3e, 0x30, 0xea, 0x84, 0xcb, 0x5e, 0x96, 0x1a, 0x0a, 0x90, 0x6c, 0x18, 0x8e,
	0x5e, 0x6b, 0xf1, 0xd4, 0x25, 0xae, 0x8f, 0xa8, 0xfe, 0x0b, 0xfc, 0x47, 0x43, 0xb3, 0x46, 0x9c,
	0x55, 0x85, 0xd7, 0x9f, 0x3b, 0x6b, 0x28, 0x02, 0x2b, 0x59, 0x23, 0x43, 0x76, 0xbe, 0x32, 0x07,
	0x53, 0x0e, 0x77, 0xc9, 0x13, 0xf8, 0x7e, 0xc6, 0x1e, 0xf3, 0xc4, 0x7b, 0x8c, 0x0a, 0x2b, 0x7e,
	0x15, 0x10, 0x93, 0xe2, 0xa5, 0xbf, 0x38, 0x07, 0x29, 0x96, 0x86, 0xd9, 0x3c, 0x6c, 0xc2, 0x68,
	0x9b, 0x9e, 0xa1, 0xbd, 0x44, 0x36, 0x33, 0x44, 0xb3, 0x13, 0x76, 0xc8, 0x56, 0x66, 0x22, 0xe7,
	0x00, 0x29, 0xbc, 0x9d, 0x38, 0x05, 0x3d, 0xa3, 0x9d, 0xd2, 0x83, 0xde, 0x35, 0xcf, 0xeb, 0xcf,
	0x7d, 0x18, 0xe5, 0xa7, 0xdc, 0xf5, 0x11, 0x55, 0xb2, 0x07, 0xbf, 0x81, 0xbc, 0x07, 0x39, 0xce,
	0x1f, 0x11, 0x2f, 0x4f, 0x4b, 0x0e, 0x11, 0x65, 0x46, 0x95, 0x90, 0x1d, 0x91, 0x6a, 0x0d, 0x98,
	0xf2, 0x9c, 0xe5, 0xb5, 0xce, 0xaf, 0x11, 0x9e, 0xfc, 0x98, 0x3b, 0xc3, 0xe1, 0x48, 0xf9, 0x0a,
	0xfc, 0x9d, 0xb0, 0x87, 0xd4, 0xb6, 0xb7, 0x60, 0xca, 0x5b, 0x09, 0x5a, 0xbd, 0xeb, 0xb8, 0x56,
	0x5b, 0xe3, 0x5b, 0x68, 0x40, 0x8c, 0xa8, 0x13, 0x1e, 0x6a, 0x95, 0x81, 0x78, 0x02, 0xc2, 0x1f,
	0x42, 0x2e, 0x3a, 0xb3, 0x4c, 0x0c, 0xa4, 0xab, 0xaf, 0x0d, 0x3f, 0x13, 0x0d, 0xae, 0xcb, 0xd0,
	0xb1, 0x28, 0xeb, 0x84, 0x1b, 0x71, 0x07, 0xa6, 0x6d, 0xf2, 0x69, 0x97, 0x38, 0xae, 0xc6, 0x6f,
	0xa0, 0x1c, 0xcd, 0xb5, 0x34, 0xbd, 0xd1, 0xc8, 0x27, 0xd9, 0x2a, 0x78, 0x63, 0xa0, 0x03, 0x7e,
	0xc7, 0x75, 0x5b, 0x37, 0x8d, 0x4e, 0xb7, 0xc5, 0xe6, 0xe2, 0x6e, 0xc7, 0xaf, 0x06, 0x4a, 0xee,
	0x28, 0xbc, 0x2e, 0x8a, 0xea, 0x84, 0x47, 0xcd, 0x8d, 0x9c, 0x5d, 0x6b, 0xa5, 0xd1, 0xc0, 0x36,
	0x9c, 0x0b, 0x8a, 0xf5, 0x40, 0x97, 0xe2, 0xff, 0xbd, 0xcb, 0x49, 0x9f, 0x3b, 0xd2, 0xe7, 0x0f,
	0x61, 0x66, 0x48, 0x94, 0x5c, 0x71, 0xe5, 0x53, 0x4c, 0xde, 0xbf, 0xec, 0x13, 0x65, 0x3e, 0x47,
	0xa9, 0x52, 0xd2, 0xa6, 0xb3, 0xf2, 0x30, 0x16, 0x62, 0x9e, 0x1e, 0x0c, 0x46, 0x65, 0xe6, 0xf8,
	0x0f, 0xa1, 0x30, 0x2c, 0x1e, 0x8f, 0x1c, 0x9e, 0x8f, 0xfc, 0xdc, 0x29, 0xb7, 0x3d, 0xf6, 0x6b,
	0x20, 0xde, 0xd7, 0xf7, 0x34, 0xf7, 0xb0, 0xe3, 0x5f, 0x8e, 0x4f, 0x0f, 0x0c, 0xcf, 0x87, 0x3a,
	0xff, 0x60, 0xc3, 0xcf, 0xd0, 0xc9, 0xfb, 0xfc, 0x11, 0x2f, 0xc1, 0xa4, 0xbf, 0xdc, 0xfc, 0xb2,
	0xcc, 0xc6, 0x38, 0xcb, 0x6f, 0xaf, 0x18, 0x18, 0x7b, 0x08, 0xbf, 0xe8, 0xd2, 0xa1, 0xaa, 0x80,
	0xe4, 0xdc, 0x33, 0x3a, 0x5a, 0xab, 0xa6, 0x59, 0x07, 0xc4, 0xb6, 0x8d, 0x06, 0x61, 0x57, 0x16,
	0xa1, 0x15, 0x9a, 0xa3, 0x80, 0xad, 0xda, 0x5d, 0xaf, 0x19, 0xdb, 0x30, 0x6f, 0x98, 0xfb, 0x84,
	0x26, 0xf4, 0x86, 0x56, 0xb3, 0x5c, 0xad, 0xc1, 0x45, 0x83, 0x16, 0x2a, 0x32, 0x86, 0x2f, 0x1b,
	0xf2, 0xe3, 0x67, 0xca, 0xe0, 0xd7, 0x02, 0xa6, 0x33, 0xc5, 0x07, 0xfe, 0x09, 0x82, 0xe2, 0x33,
	0xbb, 0xc2, 0xac, 0xab, 0xa5, 0xa1, 0x7b, 0xe4, 0x99, 0xda, 0x66, 0x1d, 0xa9, 0xe7, 0x6b, 0x67,
	0xfa, 0xf0, 0xe7, 0x08, 0xe4, 0x67, 0xf9, 0xa0, 0x19, 0x66, 0xcb, 0x30, 0x89, 0xd6, 0xa6, 0x6a,
	0x96, 0xdf, 0x63, 0x5c, 0x7c, 0x7a, 0xae, 0x8f, 0x14, 0xc6, 0xfe, 0x80, 0x5f, 0x3c, 0xd3, 0x8f,
	0x0d, 0xd6, 0xc3, 0x6d, 0x2a, 0xe0, 0xff, 0x1d, 0xbe, 0xbf, 0xf1, 0x83, 0x0a, 0x3b, 0xa2, 0x2f,
	0xc8, 0x15, 0x2a, 0xcd, 0xe5, 0x6b, 0xf2, 0x9b, 0xf2, 0x75, 0xaa, 0xe8, 0xe9, 0x99, 0xfd, 0x71,
	0x0f, 0xdd, 0x06, 0x0c, 0x59, 0x95, 0x2f, 0xe5, 0x22, 0x4b, 0xe7, 0xf4, 0xfc, 0x3f, 0x0d, 0x49,
	0xff, 0xcc, 0x9f, 0xae, 0x5c, 0x0d, 0x8c, 0xe0, 0x65, 0x90, 0x56, 0x1a, 0x07, 0xba, 0x59, 0x27,
	0x8d, 0x62, 0x1f, 0x50, 0x61, 0xdc, 0x4b, 0x72, 0x65, 0xe1, 0x49, 0x0f, 0x7d, 0x9b, 0x82, 0x1f,
	0x43, 0x86, 0xa5, 0x43, 0x0f, 0x32, 0x6f, 0x41, 0x1b, 0x2e, 0x0c, 0xa9, 0x00, 0x55, 0x29, 0x7c,
	0xc9, 0x40, 0x53, 0x3c, 0x14, 0x06, 0x13, 0x79, 0x55, 0xf4, 0xf3, 0x32, 0xcc, 0x3d, 0x25, 0x2f,
	0x57, 0x07, 0xf5, 0x3a, 0xfc, 0x87, 0x08, 0xc0, 0xce, 0x3f, 0xc4, 0x25, 0xb6, 0xa3, 0xfe, 0x9b,
	0x08, 0x17, 0x20, 0xe5, 0x95, 0x33, 0x09, 0x61, 0xcc, 0x7e, 0x7c, 0x74, 0xe5, 0x47, 0x65, 0x7a,
	0x8c, 0x61, 0x7f, 0x0a, 0xc2, 0xb6, 0xee, 0xee, 0x43, 0x39, 0x0c, 0x9b, 0x1c, 0x80, 0xb1, 0xe3,
	0x72, 0x21, 0x4d, 0x81, 0xc5, 0x6d, 0xf6, 0x00, 0x72, 0x18, 0x3f, 0x11, 0xc5, 0xb3, 0x0b, 0xe7,
	0x02, 0x30, 0x38, 0xbb, 0x91, 0x86, 0xb7, 0xc2, 0xe8, 0xa9, 0x00, 0x1d, 0x3e, 0x2a, 0x15, 0x26,
	0xd8, 0x29, 0xb5, 0xc8, 0xbc, 0xe7, 0xf3, 0x41, 0x9c, 0x52, 0x2c, 0x8f, 0xa0, 0x12, 0x36, 0x96,
	0x02, 0x63, 0x2f, 0xc5, 0x14, 0x72, 0x3c, 0x53, 0x44, 0x4c, 0x5e, 0x0d, 0x4c, 0xf2, 0x08, 0xf3,
	0x1f, 0x85, 0x34, 0x03, 0x14, 0x57, 0xad, 0xae, 0xe9, 0x32, 0xd0, 0x47, 0x50, 0x82, 0xd9, 0x53,
	0x53, 0x53, 0x0e, 0xdf, 0xd9, 0x4b, 0x08, 0xcb, 0x67, 0x23, 0xa8, 0x27, 0xde, 0xcd, 0xcc, 0x47,
	0x57, 0x7e, 0x54, 0xf0, 0x3f, 0x71, 0xc3, 0x07, 0xcf, 0x45, 0x3e, 0xf7, 0x6c, 0x72, 0xfe, 0x45,
	0xbc, 0xe0, 0x7d, 0x23, 0x7f, 0x1e, 0xde, 0x3c, 0xc2, 0xcf, 0x40, 0x14, 0x32, 0xa1, 0xe5, 0xc7,
	0x47, 0xac, 0x3c, 0xcc, 0x26, 0x7c, 0x35, 0x55, 0xc8, 0xac, 0x5b, 0x0e, 0x5d, 0x69, 0xec, 0x09,
	0xae, 0xe3, 0x57, 0x4f, 0xe3, 0x4f, 0x7d, 0x22, 0x28, 0x8c, 0xaf, 0x74, 0x5d, 0xab, 0x18, 0xb1,
	0xac, 0xe2, 0xe2, 0x69, 0xcb, 0xe8, 0xe5, 0x4d, 0x21, 0xc7, 0x57, 0x59, 0x60, 0xf3, 0x0e, 0xbe,
	0x78, 0xda, 0x26, 0xf2, 0x41, 0x84, 0xae, 0x3c, 0x97, 0xd8, 0x66, 0x61, 0x8a, 0xad, 0x38, 0xdf,
	0xb2, 0xb8, 0xcd, 0x5f, 0xc3, 0xe6, 0xb0, 0x89, 0x8c, 0x32, 0x38, 0xdd, 0x9a, 0xe3, 0x1a, 0x6e,
	0x97, 0x36, 0x15, 0x0a, 0x51, 0x9a, 0x9d, 0x50, 0x1b, 0x5c, 0xc2, 0x2f, 0x45, 0xb7, 0x6a, 0x39,
	0x72, 0xc1, 0x55, 0xc8, 0xfa, 0x1b, 0x97, 0x05, 0x3e, 0x04, 0x1e, 0xb9, 0xe4, 0x0a, 0xc1, 0xd9,
	0x4e, 0xbc, 0x8e, 0xcf, 0x0f, 0xc2, 0xa3, 0x83, 0x73, 0xae, 0x8f, 0x8f, 0x8e, 0x52, 0x75, 0x88,
	0x65, 0xf8, 0x5e, 0xab, 0x30, 0x1e, 0xb2, 0xb4, 0x5c, 0xab, 0x6e, 0xb5, 0xe0, 0x6a, 0x30, 0x8f,
	0xd1, 0xd4, 0x52, 0x8e, 0x5c, 0x3f, 0x50, 0x1f, 0xf9, 0x63, 0x71, 0xd5, 0x6a, 0x10, 0xe5, 0x15,
	0xc8, 0x70, 0x2b, 0xfe, 0xaf, 0x0d, 0xc1, 0x37, 0xb6, 0x1c, 0xff, 0xc6, 0xb6, 0x20, 0x5f, 0x55,
	0xde, 0x81, 0x8b, 0xcf, 0x2c, 0x09, 0x9e, 0x28, 0x9f, 0x3a, 0xea, 0xa1, 0x71, 0xef, 0x0a, 0x53,
	0x62, 0x1f, 0x68, 0xaf, 0xc9, 0x95, 0xeb, 0x9b, 0x82, 0x98, 0x93, 0xc6, 0x36, 0x05, 0x51, 0x92,
	0xc6, 0x4b, 0x3f, 0x86, 0xdc, 0xbb, 0x2d, 0xab, 0xa6, 0xb7, 0x76, 0x3a, 0xa4, 0xce, 0xca, 0xba,
	0x0a, 0x09, 0xe6, 0x82, 0x7f, 0xdd, 0x30, 0xfb, 0x74, 0x71, 0xca, 0x6a, 0x48, 0xc1, 0x97, 0xea,
	0x89, 0xcf, 0x51, 0x5c, 0xfa, 0x49, 0x2c, 0xac, 0xd5, 0x3d, 0xa6, 0xe5, 0x99, 0xc7, 0x3d, 0x34,
	0x05, 0x13, 0x90, 0xa3, 0x19, 0xb9, 0x68, 0xed, 0xf1, 0x85, 0xea, 0x60, 0x54, 0x29, 0xed, 0x41,
	0x6e, 0xd5, 0x26, 0xba, 0x4b, 0x02, 0x07, 0x56, 0x5e, 0xd0, 0x81, 0xd4, 0x17, 0x9f, 0x79, 0x06,
	0x41, 0x7f, 0xe3, 0x4f, 0x6e, 0x0c, 0x84, 0x55, 0x6a, 0xc2, 0x98, 0xca, 0xaf, 0xb1, 0x7e, 0xc7,
	0x1d, 0xd5, 0x21, 0xfd, 0x2e, 0x71, 0x7f, 0xb7, 0x9d, 0xcc, 0xab, 0x80, 0x4f, 0xdf, 0x72, 0xe0,
	0x1c, 0xc0, 0xca, 0xad, 0xdd, 0x35, 0x55, 0x5b, 0x5f, 0x5b, 0xb9, 0x29, 0x8d, 0xe0, 0x09, 0x18,
	0xe3, 0xcf, 0xbb, 0x1b, 0xbb, 0x5b, 0x6b, 0xda, 0xda, 0x9d, 0x9b, 0x12, 0xc2, 0xe3, 0x90, 0x55,
	0xd6, 0x6e, 0xdd, 0x55, 0xd7, 0xb4, 0x9d, 0x55, 0x75, 0x63, 0x7b, 0x57, 0x8a, 0x15, 0xa8, 0x56,
	0x1b, 0x99, 0xff, 0x7b, 0x04, 0xd2, 0xe0, 0x49, 0x9c, 0x52, 0x6e, 0xee, 0x68, 0x2b, 0xbb, 0xbb,
	0xaa, 0xb6, 0x41, 0x29, 0xc7, 0x20, 0xed, 0x3f, 0xaf, 0x6e, 0x50, 0xba, 0x10, 0x60, 0xf5, 0x8e,
	0x14, 0xc3, 0xd3, 0x80, 0xfd, 0xe7, 0x95, 0xed, 0x0d, 0xed, 0xe6, 0xdd, 0xdb, 0x2b, 0x1b, 0x77,
	0xa4, 0x38, 0xf5, 0x25, 0xfc, 0xfe, 0x7d, 0x75, 0x4b, 0x12, 0xf0, 0x24, 0x48, 0xe1, 0x97, 0xdb,
	0x2b, 0xbb, 0xeb, 0xd2, 0x28, 0xf5, 0x30, 0x78, 0xbb, 0xf3, 0x07, 0x77, 0x56, 0xa5, 0x44, 0xf8,
	0xd5, 0xcd, 0xb5, 0x5b, 0x6b, 0xaa, 0x94, 0xe4, 0x4e, 0x2b, 0x7f, 0x82, 0x8e, 0xbf, 0x9e, 0x1d,
	0xf9, 0xea, 0xeb, 0xd9, 0x91, 0xef, 0xbe, 0x9e, 0x45, 0x0f, 0x4f, 0x66, 0xd1, 0xdf, 0x9c, 0xcc,
	0xa2, 0x5f, 0x9c, 0xcc, 0xa2, 0xe3, 0x93, 0x59, 0xf4, 0xd5, 0xc9, 0x2c, 0xfa, 0xf5, 0xc9, 0x2c,
	0xfa, 0xf6, 0x64, 0x76, 0xe4, 0xbb, 0x93, 0x59, 0xf4, 0xf3, 0x6f, 0x66, 0x47, 0x8e, 0xbe, 0x99,
	0x45, 0xc7, 0xdf, 0xcc, 0x8e, 0x7c, 0xf5, 0xcd, 0xec, 0xc8, 0x0f, 0x37, 0x9a, 0x56, 0xe7, 0x5e,
	0xb3, 0x7c, 0x60, 0xb5, 0x5c, 0x62, 0xdb, 0x7a, 0xb9, 0xeb, 0x5c, 0x66, 0x3f, 0xf6, 0x2c, 0xbb,
	0x7d, 0xa9, 0x63, 0x5b, 0x07, 0x46, 0x83, 0xd8, 0x97, 0xfc, 0xe6, 0xcb, 0x9d, 0x5a, 0xd3, 0xba,
	0x4c, 0x1e, 0xb8, 0xde, 0x3f, 0xec, 0x85, 0xff, 0x29, 0xb1, 0x96, 0x60, 0x39, 0x61, 0xe1, 0x7f,
	0x03, 0x00, 0x00, 0xff, 0xff, 0x40, 0xc5, 0xbb, 0x3f, 0xb2, 0x28, 0x00, 0x00,
}

func (x JavaScriptLocation) String() string {
	s, ok := JavaScriptLocation_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TagAttributeName) String() string {
	s, ok := TagAttributeName_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *VerStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VerStatusType)
	if !ok {
		that2, ok := that.(VerStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	return true
}
func (this *RouteDestination) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteDestination)
	if !ok {
		that2, ok := that.(RouteDestination)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Cluster) != len(that1.Cluster) {
		return false
	}
	for i := range this.Cluster {
		if !this.Cluster[i].Equal(that1.Cluster[i]) {
			return false
		}
	}
	if this.Weight != that1.Weight {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	if len(this.EndpointSubsets) != len(that1.EndpointSubsets) {
		return false
	}
	for i := range this.EndpointSubsets {
		if this.EndpointSubsets[i] != that1.EndpointSubsets[i] {
			return false
		}
	}
	return true
}
func (this *MirrorPolicyType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MirrorPolicyType)
	if !ok {
		that2, ok := that.(MirrorPolicyType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Cluster) != len(that1.Cluster) {
		return false
	}
	for i := range this.Cluster {
		if !this.Cluster[i].Equal(that1.Cluster[i]) {
			return false
		}
	}
	if !this.Percent.Equal(that1.Percent) {
		return false
	}
	return true
}
func (this *SpdyConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SpdyConfigType)
	if !ok {
		that2, ok := that.(SpdyConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UseSpdy != that1.UseSpdy {
		return false
	}
	return true
}
func (this *WebsocketConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WebsocketConfigType)
	if !ok {
		that2, ok := that.(WebsocketConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UseWebsocket != that1.UseWebsocket {
		return false
	}
	return true
}
func (this *CookieForHashing) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieForHashing)
	if !ok {
		that2, ok := that.(CookieForHashing)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Ttl != that1.Ttl {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if that1.Samesite == nil {
		if this.Samesite != nil {
			return false
		}
	} else if this.Samesite == nil {
		return false
	} else if !this.Samesite.Equal(that1.Samesite) {
		return false
	}
	if that1.Secure == nil {
		if this.Secure != nil {
			return false
		}
	} else if this.Secure == nil {
		return false
	} else if !this.Secure.Equal(that1.Secure) {
		return false
	}
	if that1.Httponly == nil {
		if this.Httponly != nil {
			return false
		}
	} else if this.Httponly == nil {
		return false
	} else if !this.Httponly.Equal(that1.Httponly) {
		return false
	}
	return true
}
func (this *CookieForHashing_IgnoreSamesite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieForHashing_IgnoreSamesite)
	if !ok {
		that2, ok := that.(CookieForHashing_IgnoreSamesite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IgnoreSamesite.Equal(that1.IgnoreSamesite) {
		return false
	}
	return true
}
func (this *CookieForHashing_SamesiteStrict) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieForHashing_SamesiteStrict)
	if !ok {
		that2, ok := that.(CookieForHashing_SamesiteStrict)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SamesiteStrict.Equal(that1.SamesiteStrict) {
		return false
	}
	return true
}
func (this *CookieForHashing_SamesiteLax) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieForHashing_SamesiteLax)
	if !ok {
		that2, ok := that.(CookieForHashing_SamesiteLax)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SamesiteLax.Equal(that1.SamesiteLax) {
		return false
	}
	return true
}
func (this *CookieForHashing_SamesiteNone) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieForHashing_SamesiteNone)
	if !ok {
		that2, ok := that.(CookieForHashing_SamesiteNone)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SamesiteNone.Equal(that1.SamesiteNone) {
		return false
	}
	return true
}
func (this *CookieForHashing_IgnoreSecure) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieForHashing_IgnoreSecure)
	if !ok {
		that2, ok := that.(CookieForHashing_IgnoreSecure)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IgnoreSecure.Equal(that1.IgnoreSecure) {
		return false
	}
	return true
}
func (this *CookieForHashing_AddSecure) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieForHashing_AddSecure)
	if !ok {
		that2, ok := that.(CookieForHashing_AddSecure)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AddSecure.Equal(that1.AddSecure) {
		return false
	}
	return true
}
func (this *CookieForHashing_IgnoreHttponly) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieForHashing_IgnoreHttponly)
	if !ok {
		that2, ok := that.(CookieForHashing_IgnoreHttponly)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IgnoreHttponly.Equal(that1.IgnoreHttponly) {
		return false
	}
	return true
}
func (this *CookieForHashing_AddHttponly) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieForHashing_AddHttponly)
	if !ok {
		that2, ok := that.(CookieForHashing_AddHttponly)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AddHttponly.Equal(that1.AddHttponly) {
		return false
	}
	return true
}
func (this *HashPolicyType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HashPolicyType)
	if !ok {
		that2, ok := that.(HashPolicyType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PolicySpecifier == nil {
		if this.PolicySpecifier != nil {
			return false
		}
	} else if this.PolicySpecifier == nil {
		return false
	} else if !this.PolicySpecifier.Equal(that1.PolicySpecifier) {
		return false
	}
	if this.Terminal != that1.Terminal {
		return false
	}
	return true
}
func (this *HashPolicyType_HeaderName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HashPolicyType_HeaderName)
	if !ok {
		that2, ok := that.(HashPolicyType_HeaderName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HeaderName != that1.HeaderName {
		return false
	}
	return true
}
func (this *HashPolicyType_Cookie) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HashPolicyType_Cookie)
	if !ok {
		that2, ok := that.(HashPolicyType_Cookie)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Cookie.Equal(that1.Cookie) {
		return false
	}
	return true
}
func (this *HashPolicyType_SourceIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HashPolicyType_SourceIp)
	if !ok {
		that2, ok := that.(HashPolicyType_SourceIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SourceIp != that1.SourceIp {
		return false
	}
	return true
}
func (this *RouteDestinationList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteDestinationList)
	if !ok {
		that2, ok := that.(RouteDestinationList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Destinations) != len(that1.Destinations) {
		return false
	}
	for i := range this.Destinations {
		if !this.Destinations[i].Equal(that1.Destinations[i]) {
			return false
		}
	}
	if that1.RouteDestinationRewrite == nil {
		if this.RouteDestinationRewrite != nil {
			return false
		}
	} else if this.RouteDestinationRewrite == nil {
		return false
	} else if !this.RouteDestinationRewrite.Equal(that1.RouteDestinationRewrite) {
		return false
	}
	if that1.HostRewriteParams == nil {
		if this.HostRewriteParams != nil {
			return false
		}
	} else if this.HostRewriteParams == nil {
		return false
	} else if !this.HostRewriteParams.Equal(that1.HostRewriteParams) {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	if !this.RetryPolicy.Equal(that1.RetryPolicy) {
		return false
	}
	if len(this.EndpointSubsets) != len(that1.EndpointSubsets) {
		return false
	}
	for i := range this.EndpointSubsets {
		if this.EndpointSubsets[i] != that1.EndpointSubsets[i] {
			return false
		}
	}
	if !this.MirrorPolicy.Equal(that1.MirrorPolicy) {
		return false
	}
	if !this.WebSocketConfig.Equal(that1.WebSocketConfig) {
		return false
	}
	if !this.BufferPolicy.Equal(that1.BufferPolicy) {
		return false
	}
	if !this.CorsPolicy.Equal(that1.CorsPolicy) {
		return false
	}
	if !this.CsrfPolicy.Equal(that1.CsrfPolicy) {
		return false
	}
	if len(this.HashPolicy) != len(that1.HashPolicy) {
		return false
	}
	for i := range this.HashPolicy {
		if !this.HashPolicy[i].Equal(that1.HashPolicy[i]) {
			return false
		}
	}
	if this.Priority != that1.Priority {
		return false
	}
	if !this.SpdyConfig.Equal(that1.SpdyConfig) {
		return false
	}
	if that1.ClusterRetractChoice == nil {
		if this.ClusterRetractChoice != nil {
			return false
		}
	} else if this.ClusterRetractChoice == nil {
		return false
	} else if !this.ClusterRetractChoice.Equal(that1.ClusterRetractChoice) {
		return false
	}
	return true
}
func (this *RouteDestinationList_PrefixRewrite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteDestinationList_PrefixRewrite)
	if !ok {
		that2, ok := that.(RouteDestinationList_PrefixRewrite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PrefixRewrite != that1.PrefixRewrite {
		return false
	}
	return true
}
func (this *RouteDestinationList_RegexRewrite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteDestinationList_RegexRewrite)
	if !ok {
		that2, ok := that.(RouteDestinationList_RegexRewrite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RegexRewrite.Equal(that1.RegexRewrite) {
		return false
	}
	return true
}
func (this *RouteDestinationList_HostRewrite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteDestinationList_HostRewrite)
	if !ok {
		that2, ok := that.(RouteDestinationList_HostRewrite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HostRewrite != that1.HostRewrite {
		return false
	}
	return true
}
func (this *RouteDestinationList_AutoHostRewrite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteDestinationList_AutoHostRewrite)
	if !ok {
		that2, ok := that.(RouteDestinationList_AutoHostRewrite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AutoHostRewrite != that1.AutoHostRewrite {
		return false
	}
	return true
}
func (this *RouteDestinationList_RetractCluster) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteDestinationList_RetractCluster)
	if !ok {
		that2, ok := that.(RouteDestinationList_RetractCluster)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RetractCluster.Equal(that1.RetractCluster) {
		return false
	}
	return true
}
func (this *RouteDestinationList_DoNotRetractCluster) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteDestinationList_DoNotRetractCluster)
	if !ok {
		that2, ok := that.(RouteDestinationList_DoNotRetractCluster)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DoNotRetractCluster.Equal(that1.DoNotRetractCluster) {
		return false
	}
	return true
}
func (this *RouteQueryParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteQueryParams)
	if !ok {
		that2, ok := that.(RouteQueryParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.QueryParams) != len(that1.QueryParams) {
		return false
	}
	for i := range this.QueryParams {
		if this.QueryParams[i] != that1.QueryParams[i] {
			return false
		}
	}
	return true
}
func (this *RouteRedirect) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteRedirect)
	if !ok {
		that2, ok := that.(RouteRedirect)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HostRedirect != that1.HostRedirect {
		return false
	}
	if that1.RedirectPathChoice == nil {
		if this.RedirectPathChoice != nil {
			return false
		}
	} else if this.RedirectPathChoice == nil {
		return false
	} else if !this.RedirectPathChoice.Equal(that1.RedirectPathChoice) {
		return false
	}
	if this.ProtoRedirect != that1.ProtoRedirect {
		return false
	}
	if this.PortRedirect != that1.PortRedirect {
		return false
	}
	if that1.QueryParams == nil {
		if this.QueryParams != nil {
			return false
		}
	} else if this.QueryParams == nil {
		return false
	} else if !this.QueryParams.Equal(that1.QueryParams) {
		return false
	}
	if this.ResponseCode != that1.ResponseCode {
		return false
	}
	return true
}
func (this *RouteRedirect_PathRedirect) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteRedirect_PathRedirect)
	if !ok {
		that2, ok := that.(RouteRedirect_PathRedirect)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PathRedirect != that1.PathRedirect {
		return false
	}
	return true
}
func (this *RouteRedirect_PrefixRewrite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteRedirect_PrefixRewrite)
	if !ok {
		that2, ok := that.(RouteRedirect_PrefixRewrite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PrefixRewrite != that1.PrefixRewrite {
		return false
	}
	return true
}
func (this *RouteRedirect_StripQueryParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteRedirect_StripQueryParams)
	if !ok {
		that2, ok := that.(RouteRedirect_StripQueryParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StripQueryParams.Equal(that1.StripQueryParams) {
		return false
	}
	return true
}
func (this *RouteRedirect_AllParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteRedirect_AllParams)
	if !ok {
		that2, ok := that.(RouteRedirect_AllParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AllParams != that1.AllParams {
		return false
	}
	return true
}
func (this *RouteRedirect_RetainAllParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteRedirect_RetainAllParams)
	if !ok {
		that2, ok := that.(RouteRedirect_RetainAllParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RetainAllParams.Equal(that1.RetainAllParams) {
		return false
	}
	return true
}
func (this *RouteRedirect_RemoveAllParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteRedirect_RemoveAllParams)
	if !ok {
		that2, ok := that.(RouteRedirect_RemoveAllParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RemoveAllParams.Equal(that1.RemoveAllParams) {
		return false
	}
	return true
}
func (this *RouteRedirect_ReplaceParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteRedirect_ReplaceParams)
	if !ok {
		that2, ok := that.(RouteRedirect_ReplaceParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ReplaceParams != that1.ReplaceParams {
		return false
	}
	return true
}
func (this *RouteDirectResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteDirectResponse)
	if !ok {
		that2, ok := that.(RouteDirectResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ResponseCode != that1.ResponseCode {
		return false
	}
	if this.ResponseBody != that1.ResponseBody {
		return false
	}
	return true
}
func (this *ContextExtensionInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContextExtensionInfo)
	if !ok {
		that2, ok := that.(ContextExtensionInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ContextExtensions) != len(that1.ContextExtensions) {
		return false
	}
	for i := range this.ContextExtensions {
		if this.ContextExtensions[i] != that1.ContextExtensions[i] {
			return false
		}
	}
	return true
}
func (this *BotDefenseJavascriptInjectionType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseJavascriptInjectionType)
	if !ok {
		that2, ok := that.(BotDefenseJavascriptInjectionType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.JavascriptLocation != that1.JavascriptLocation {
		return false
	}
	if len(this.JavascriptTags) != len(that1.JavascriptTags) {
		return false
	}
	for i := range this.JavascriptTags {
		if !this.JavascriptTags[i].Equal(that1.JavascriptTags[i]) {
			return false
		}
	}
	return true
}
func (this *JavaScriptTag) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JavaScriptTag)
	if !ok {
		that2, ok := that.(JavaScriptTag)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.JavascriptUrl != that1.JavascriptUrl {
		return false
	}
	if len(this.TagAttributes) != len(that1.TagAttributes) {
		return false
	}
	for i := range this.TagAttributes {
		if !this.TagAttributes[i].Equal(that1.TagAttributes[i]) {
			return false
		}
	}
	return true
}
func (this *TagAttribute) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TagAttribute)
	if !ok {
		that2, ok := that.(TagAttribute)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.JavascriptTag != that1.JavascriptTag {
		return false
	}
	if this.TagValue != that1.TagValue {
		return false
	}
	return true
}
func (this *ContentRewriteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContentRewriteType)
	if !ok {
		that2, ok := that.(ContentRewriteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.InsertContent != that1.InsertContent {
		return false
	}
	if this.ElementSelector != that1.ElementSelector {
		return false
	}
	if this.Position != that1.Position {
		return false
	}
	return true
}
func (this *ServicePolicyInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServicePolicyInfo)
	if !ok {
		that2, ok := that.(ServicePolicyInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ServicePolicyChoice == nil {
		if this.ServicePolicyChoice != nil {
			return false
		}
	} else if this.ServicePolicyChoice == nil {
		return false
	} else if !this.ServicePolicyChoice.Equal(that1.ServicePolicyChoice) {
		return false
	}
	return true
}
func (this *ServicePolicyInfo_Disable) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServicePolicyInfo_Disable)
	if !ok {
		that2, ok := that.(ServicePolicyInfo_Disable)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Disable != that1.Disable {
		return false
	}
	return true
}
func (this *ServicePolicyInfo_ContextExtensions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServicePolicyInfo_ContextExtensions)
	if !ok {
		that2, ok := that.(ServicePolicyInfo_ContextExtensions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ContextExtensions.Equal(that1.ContextExtensions) {
		return false
	}
	return true
}
func (this *RouteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteType)
	if !ok {
		that2, ok := that.(RouteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Match) != len(that1.Match) {
		return false
	}
	for i := range this.Match {
		if !this.Match[i].Equal(that1.Match[i]) {
			return false
		}
	}
	if that1.RouteAction == nil {
		if this.RouteAction != nil {
			return false
		}
	} else if this.RouteAction == nil {
		return false
	} else if !this.RouteAction.Equal(that1.RouteAction) {
		return false
	}
	if this.DisableCustomScript != that1.DisableCustomScript {
		return false
	}
	if !this.ServicePolicy.Equal(that1.ServicePolicy) {
		return false
	}
	if len(this.RequestHeadersToAdd) != len(that1.RequestHeadersToAdd) {
		return false
	}
	for i := range this.RequestHeadersToAdd {
		if !this.RequestHeadersToAdd[i].Equal(that1.RequestHeadersToAdd[i]) {
			return false
		}
	}
	if len(this.ResponseHeadersToAdd) != len(that1.ResponseHeadersToAdd) {
		return false
	}
	for i := range this.ResponseHeadersToAdd {
		if !this.ResponseHeadersToAdd[i].Equal(that1.ResponseHeadersToAdd[i]) {
			return false
		}
	}
	if len(this.RequestHeadersToRemove) != len(that1.RequestHeadersToRemove) {
		return false
	}
	for i := range this.RequestHeadersToRemove {
		if this.RequestHeadersToRemove[i] != that1.RequestHeadersToRemove[i] {
			return false
		}
	}
	if len(this.ResponseHeadersToRemove) != len(that1.ResponseHeadersToRemove) {
		return false
	}
	for i := range this.ResponseHeadersToRemove {
		if this.ResponseHeadersToRemove[i] != that1.ResponseHeadersToRemove[i] {
			return false
		}
	}
	if !this.WafType.Equal(that1.WafType) {
		return false
	}
	if this.DisableLocationAdd != that1.DisableLocationAdd {
		return false
	}
	if this.SkipLbOverride != that1.SkipLbOverride {
		return false
	}
	if that1.BotDefenseJavascriptInjectionChoice == nil {
		if this.BotDefenseJavascriptInjectionChoice != nil {
			return false
		}
	} else if this.BotDefenseJavascriptInjectionChoice == nil {
		return false
	} else if !this.BotDefenseJavascriptInjectionChoice.Equal(that1.BotDefenseJavascriptInjectionChoice) {
		return false
	}
	if !this.BotDefenseJavascriptInjectionInlineMode.Equal(that1.BotDefenseJavascriptInjectionInlineMode) {
		return false
	}
	return true
}
func (this *RouteType_RouteDestination) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteType_RouteDestination)
	if !ok {
		that2, ok := that.(RouteType_RouteDestination)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RouteDestination.Equal(that1.RouteDestination) {
		return false
	}
	return true
}
func (this *RouteType_RouteRedirect) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteType_RouteRedirect)
	if !ok {
		that2, ok := that.(RouteType_RouteRedirect)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RouteRedirect.Equal(that1.RouteRedirect) {
		return false
	}
	return true
}
func (this *RouteType_RouteDirectResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteType_RouteDirectResponse)
	if !ok {
		that2, ok := that.(RouteType_RouteDirectResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RouteDirectResponse.Equal(that1.RouteDirectResponse) {
		return false
	}
	return true
}
func (this *RouteType_InheritedBotDefenseJavascriptInjection) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteType_InheritedBotDefenseJavascriptInjection)
	if !ok {
		that2, ok := that.(RouteType_InheritedBotDefenseJavascriptInjection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InheritedBotDefenseJavascriptInjection.Equal(that1.InheritedBotDefenseJavascriptInjection) {
		return false
	}
	return true
}
func (this *RouteType_BotDefenseJavascriptInjection) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteType_BotDefenseJavascriptInjection)
	if !ok {
		that2, ok := that.(RouteType_BotDefenseJavascriptInjection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BotDefenseJavascriptInjection.Equal(that1.BotDefenseJavascriptInjection) {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	return true
}
func (this *VerStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&route.VerStatusType{")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Reason: "+fmt.Sprintf("%#v", this.Reason)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteDestination) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&route.RouteDestination{")
	if this.Cluster != nil {
		s = append(s, "Cluster: "+fmt.Sprintf("%#v", this.Cluster)+",\n")
	}
	s = append(s, "Weight: "+fmt.Sprintf("%#v", this.Weight)+",\n")
	s = append(s, "Priority: "+fmt.Sprintf("%#v", this.Priority)+",\n")
	keysForEndpointSubsets := make([]string, 0, len(this.EndpointSubsets))
	for k, _ := range this.EndpointSubsets {
		keysForEndpointSubsets = append(keysForEndpointSubsets, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEndpointSubsets)
	mapStringForEndpointSubsets := "map[string]string{"
	for _, k := range keysForEndpointSubsets {
		mapStringForEndpointSubsets += fmt.Sprintf("%#v: %#v,", k, this.EndpointSubsets[k])
	}
	mapStringForEndpointSubsets += "}"
	if this.EndpointSubsets != nil {
		s = append(s, "EndpointSubsets: "+mapStringForEndpointSubsets+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MirrorPolicyType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&route.MirrorPolicyType{")
	if this.Cluster != nil {
		s = append(s, "Cluster: "+fmt.Sprintf("%#v", this.Cluster)+",\n")
	}
	if this.Percent != nil {
		s = append(s, "Percent: "+fmt.Sprintf("%#v", this.Percent)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SpdyConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&route.SpdyConfigType{")
	s = append(s, "UseSpdy: "+fmt.Sprintf("%#v", this.UseSpdy)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WebsocketConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&route.WebsocketConfigType{")
	s = append(s, "UseWebsocket: "+fmt.Sprintf("%#v", this.UseWebsocket)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CookieForHashing) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&route.CookieForHashing{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Ttl: "+fmt.Sprintf("%#v", this.Ttl)+",\n")
	s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	if this.Samesite != nil {
		s = append(s, "Samesite: "+fmt.Sprintf("%#v", this.Samesite)+",\n")
	}
	if this.Secure != nil {
		s = append(s, "Secure: "+fmt.Sprintf("%#v", this.Secure)+",\n")
	}
	if this.Httponly != nil {
		s = append(s, "Httponly: "+fmt.Sprintf("%#v", this.Httponly)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CookieForHashing_IgnoreSamesite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.CookieForHashing_IgnoreSamesite{` +
		`IgnoreSamesite:` + fmt.Sprintf("%#v", this.IgnoreSamesite) + `}`}, ", ")
	return s
}
func (this *CookieForHashing_SamesiteStrict) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.CookieForHashing_SamesiteStrict{` +
		`SamesiteStrict:` + fmt.Sprintf("%#v", this.SamesiteStrict) + `}`}, ", ")
	return s
}
func (this *CookieForHashing_SamesiteLax) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.CookieForHashing_SamesiteLax{` +
		`SamesiteLax:` + fmt.Sprintf("%#v", this.SamesiteLax) + `}`}, ", ")
	return s
}
func (this *CookieForHashing_SamesiteNone) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.CookieForHashing_SamesiteNone{` +
		`SamesiteNone:` + fmt.Sprintf("%#v", this.SamesiteNone) + `}`}, ", ")
	return s
}
func (this *CookieForHashing_IgnoreSecure) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.CookieForHashing_IgnoreSecure{` +
		`IgnoreSecure:` + fmt.Sprintf("%#v", this.IgnoreSecure) + `}`}, ", ")
	return s
}
func (this *CookieForHashing_AddSecure) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.CookieForHashing_AddSecure{` +
		`AddSecure:` + fmt.Sprintf("%#v", this.AddSecure) + `}`}, ", ")
	return s
}
func (this *CookieForHashing_IgnoreHttponly) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.CookieForHashing_IgnoreHttponly{` +
		`IgnoreHttponly:` + fmt.Sprintf("%#v", this.IgnoreHttponly) + `}`}, ", ")
	return s
}
func (this *CookieForHashing_AddHttponly) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.CookieForHashing_AddHttponly{` +
		`AddHttponly:` + fmt.Sprintf("%#v", this.AddHttponly) + `}`}, ", ")
	return s
}
func (this *HashPolicyType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&route.HashPolicyType{")
	if this.PolicySpecifier != nil {
		s = append(s, "PolicySpecifier: "+fmt.Sprintf("%#v", this.PolicySpecifier)+",\n")
	}
	s = append(s, "Terminal: "+fmt.Sprintf("%#v", this.Terminal)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HashPolicyType_HeaderName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.HashPolicyType_HeaderName{` +
		`HeaderName:` + fmt.Sprintf("%#v", this.HeaderName) + `}`}, ", ")
	return s
}
func (this *HashPolicyType_Cookie) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.HashPolicyType_Cookie{` +
		`Cookie:` + fmt.Sprintf("%#v", this.Cookie) + `}`}, ", ")
	return s
}
func (this *HashPolicyType_SourceIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.HashPolicyType_SourceIp{` +
		`SourceIp:` + fmt.Sprintf("%#v", this.SourceIp) + `}`}, ", ")
	return s
}
func (this *RouteDestinationList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 22)
	s = append(s, "&route.RouteDestinationList{")
	if this.Destinations != nil {
		s = append(s, "Destinations: "+fmt.Sprintf("%#v", this.Destinations)+",\n")
	}
	if this.RouteDestinationRewrite != nil {
		s = append(s, "RouteDestinationRewrite: "+fmt.Sprintf("%#v", this.RouteDestinationRewrite)+",\n")
	}
	if this.HostRewriteParams != nil {
		s = append(s, "HostRewriteParams: "+fmt.Sprintf("%#v", this.HostRewriteParams)+",\n")
	}
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	if this.RetryPolicy != nil {
		s = append(s, "RetryPolicy: "+fmt.Sprintf("%#v", this.RetryPolicy)+",\n")
	}
	keysForEndpointSubsets := make([]string, 0, len(this.EndpointSubsets))
	for k, _ := range this.EndpointSubsets {
		keysForEndpointSubsets = append(keysForEndpointSubsets, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEndpointSubsets)
	mapStringForEndpointSubsets := "map[string]string{"
	for _, k := range keysForEndpointSubsets {
		mapStringForEndpointSubsets += fmt.Sprintf("%#v: %#v,", k, this.EndpointSubsets[k])
	}
	mapStringForEndpointSubsets += "}"
	if this.EndpointSubsets != nil {
		s = append(s, "EndpointSubsets: "+mapStringForEndpointSubsets+",\n")
	}
	if this.MirrorPolicy != nil {
		s = append(s, "MirrorPolicy: "+fmt.Sprintf("%#v", this.MirrorPolicy)+",\n")
	}
	if this.WebSocketConfig != nil {
		s = append(s, "WebSocketConfig: "+fmt.Sprintf("%#v", this.WebSocketConfig)+",\n")
	}
	if this.BufferPolicy != nil {
		s = append(s, "BufferPolicy: "+fmt.Sprintf("%#v", this.BufferPolicy)+",\n")
	}
	if this.CorsPolicy != nil {
		s = append(s, "CorsPolicy: "+fmt.Sprintf("%#v", this.CorsPolicy)+",\n")
	}
	if this.CsrfPolicy != nil {
		s = append(s, "CsrfPolicy: "+fmt.Sprintf("%#v", this.CsrfPolicy)+",\n")
	}
	if this.HashPolicy != nil {
		s = append(s, "HashPolicy: "+fmt.Sprintf("%#v", this.HashPolicy)+",\n")
	}
	s = append(s, "Priority: "+fmt.Sprintf("%#v", this.Priority)+",\n")
	if this.SpdyConfig != nil {
		s = append(s, "SpdyConfig: "+fmt.Sprintf("%#v", this.SpdyConfig)+",\n")
	}
	if this.ClusterRetractChoice != nil {
		s = append(s, "ClusterRetractChoice: "+fmt.Sprintf("%#v", this.ClusterRetractChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteDestinationList_PrefixRewrite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteDestinationList_PrefixRewrite{` +
		`PrefixRewrite:` + fmt.Sprintf("%#v", this.PrefixRewrite) + `}`}, ", ")
	return s
}
func (this *RouteDestinationList_RegexRewrite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteDestinationList_RegexRewrite{` +
		`RegexRewrite:` + fmt.Sprintf("%#v", this.RegexRewrite) + `}`}, ", ")
	return s
}
func (this *RouteDestinationList_HostRewrite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteDestinationList_HostRewrite{` +
		`HostRewrite:` + fmt.Sprintf("%#v", this.HostRewrite) + `}`}, ", ")
	return s
}
func (this *RouteDestinationList_AutoHostRewrite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteDestinationList_AutoHostRewrite{` +
		`AutoHostRewrite:` + fmt.Sprintf("%#v", this.AutoHostRewrite) + `}`}, ", ")
	return s
}
func (this *RouteDestinationList_RetractCluster) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteDestinationList_RetractCluster{` +
		`RetractCluster:` + fmt.Sprintf("%#v", this.RetractCluster) + `}`}, ", ")
	return s
}
func (this *RouteDestinationList_DoNotRetractCluster) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteDestinationList_DoNotRetractCluster{` +
		`DoNotRetractCluster:` + fmt.Sprintf("%#v", this.DoNotRetractCluster) + `}`}, ", ")
	return s
}
func (this *RouteQueryParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&route.RouteQueryParams{")
	s = append(s, "QueryParams: "+fmt.Sprintf("%#v", this.QueryParams)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteRedirect) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&route.RouteRedirect{")
	s = append(s, "HostRedirect: "+fmt.Sprintf("%#v", this.HostRedirect)+",\n")
	if this.RedirectPathChoice != nil {
		s = append(s, "RedirectPathChoice: "+fmt.Sprintf("%#v", this.RedirectPathChoice)+",\n")
	}
	s = append(s, "ProtoRedirect: "+fmt.Sprintf("%#v", this.ProtoRedirect)+",\n")
	s = append(s, "PortRedirect: "+fmt.Sprintf("%#v", this.PortRedirect)+",\n")
	if this.QueryParams != nil {
		s = append(s, "QueryParams: "+fmt.Sprintf("%#v", this.QueryParams)+",\n")
	}
	s = append(s, "ResponseCode: "+fmt.Sprintf("%#v", this.ResponseCode)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteRedirect_PathRedirect) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteRedirect_PathRedirect{` +
		`PathRedirect:` + fmt.Sprintf("%#v", this.PathRedirect) + `}`}, ", ")
	return s
}
func (this *RouteRedirect_PrefixRewrite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteRedirect_PrefixRewrite{` +
		`PrefixRewrite:` + fmt.Sprintf("%#v", this.PrefixRewrite) + `}`}, ", ")
	return s
}
func (this *RouteRedirect_StripQueryParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteRedirect_StripQueryParams{` +
		`StripQueryParams:` + fmt.Sprintf("%#v", this.StripQueryParams) + `}`}, ", ")
	return s
}
func (this *RouteRedirect_AllParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteRedirect_AllParams{` +
		`AllParams:` + fmt.Sprintf("%#v", this.AllParams) + `}`}, ", ")
	return s
}
func (this *RouteRedirect_RetainAllParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteRedirect_RetainAllParams{` +
		`RetainAllParams:` + fmt.Sprintf("%#v", this.RetainAllParams) + `}`}, ", ")
	return s
}
func (this *RouteRedirect_RemoveAllParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteRedirect_RemoveAllParams{` +
		`RemoveAllParams:` + fmt.Sprintf("%#v", this.RemoveAllParams) + `}`}, ", ")
	return s
}
func (this *RouteRedirect_ReplaceParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteRedirect_ReplaceParams{` +
		`ReplaceParams:` + fmt.Sprintf("%#v", this.ReplaceParams) + `}`}, ", ")
	return s
}
func (this *RouteDirectResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&route.RouteDirectResponse{")
	s = append(s, "ResponseCode: "+fmt.Sprintf("%#v", this.ResponseCode)+",\n")
	s = append(s, "ResponseBody: "+fmt.Sprintf("%#v", this.ResponseBody)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContextExtensionInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&route.ContextExtensionInfo{")
	keysForContextExtensions := make([]string, 0, len(this.ContextExtensions))
	for k, _ := range this.ContextExtensions {
		keysForContextExtensions = append(keysForContextExtensions, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForContextExtensions)
	mapStringForContextExtensions := "map[string]string{"
	for _, k := range keysForContextExtensions {
		mapStringForContextExtensions += fmt.Sprintf("%#v: %#v,", k, this.ContextExtensions[k])
	}
	mapStringForContextExtensions += "}"
	if this.ContextExtensions != nil {
		s = append(s, "ContextExtensions: "+mapStringForContextExtensions+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BotDefenseJavascriptInjectionType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&route.BotDefenseJavascriptInjectionType{")
	s = append(s, "JavascriptLocation: "+fmt.Sprintf("%#v", this.JavascriptLocation)+",\n")
	if this.JavascriptTags != nil {
		s = append(s, "JavascriptTags: "+fmt.Sprintf("%#v", this.JavascriptTags)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *JavaScriptTag) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&route.JavaScriptTag{")
	s = append(s, "JavascriptUrl: "+fmt.Sprintf("%#v", this.JavascriptUrl)+",\n")
	if this.TagAttributes != nil {
		s = append(s, "TagAttributes: "+fmt.Sprintf("%#v", this.TagAttributes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TagAttribute) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&route.TagAttribute{")
	s = append(s, "JavascriptTag: "+fmt.Sprintf("%#v", this.JavascriptTag)+",\n")
	s = append(s, "TagValue: "+fmt.Sprintf("%#v", this.TagValue)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContentRewriteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&route.ContentRewriteType{")
	s = append(s, "InsertContent: "+fmt.Sprintf("%#v", this.InsertContent)+",\n")
	s = append(s, "ElementSelector: "+fmt.Sprintf("%#v", this.ElementSelector)+",\n")
	s = append(s, "Position: "+fmt.Sprintf("%#v", this.Position)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ServicePolicyInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&route.ServicePolicyInfo{")
	if this.ServicePolicyChoice != nil {
		s = append(s, "ServicePolicyChoice: "+fmt.Sprintf("%#v", this.ServicePolicyChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ServicePolicyInfo_Disable) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.ServicePolicyInfo_Disable{` +
		`Disable:` + fmt.Sprintf("%#v", this.Disable) + `}`}, ", ")
	return s
}
func (this *ServicePolicyInfo_ContextExtensions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.ServicePolicyInfo_ContextExtensions{` +
		`ContextExtensions:` + fmt.Sprintf("%#v", this.ContextExtensions) + `}`}, ", ")
	return s
}
func (this *RouteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 20)
	s = append(s, "&route.RouteType{")
	if this.Match != nil {
		s = append(s, "Match: "+fmt.Sprintf("%#v", this.Match)+",\n")
	}
	if this.RouteAction != nil {
		s = append(s, "RouteAction: "+fmt.Sprintf("%#v", this.RouteAction)+",\n")
	}
	s = append(s, "DisableCustomScript: "+fmt.Sprintf("%#v", this.DisableCustomScript)+",\n")
	if this.ServicePolicy != nil {
		s = append(s, "ServicePolicy: "+fmt.Sprintf("%#v", this.ServicePolicy)+",\n")
	}
	if this.RequestHeadersToAdd != nil {
		s = append(s, "RequestHeadersToAdd: "+fmt.Sprintf("%#v", this.RequestHeadersToAdd)+",\n")
	}
	if this.ResponseHeadersToAdd != nil {
		s = append(s, "ResponseHeadersToAdd: "+fmt.Sprintf("%#v", this.ResponseHeadersToAdd)+",\n")
	}
	s = append(s, "RequestHeadersToRemove: "+fmt.Sprintf("%#v", this.RequestHeadersToRemove)+",\n")
	s = append(s, "ResponseHeadersToRemove: "+fmt.Sprintf("%#v", this.ResponseHeadersToRemove)+",\n")
	if this.WafType != nil {
		s = append(s, "WafType: "+fmt.Sprintf("%#v", this.WafType)+",\n")
	}
	s = append(s, "DisableLocationAdd: "+fmt.Sprintf("%#v", this.DisableLocationAdd)+",\n")
	s = append(s, "SkipLbOverride: "+fmt.Sprintf("%#v", this.SkipLbOverride)+",\n")
	if this.BotDefenseJavascriptInjectionChoice != nil {
		s = append(s, "BotDefenseJavascriptInjectionChoice: "+fmt.Sprintf("%#v", this.BotDefenseJavascriptInjectionChoice)+",\n")
	}
	if this.BotDefenseJavascriptInjectionInlineMode != nil {
		s = append(s, "BotDefenseJavascriptInjectionInlineMode: "+fmt.Sprintf("%#v", this.BotDefenseJavascriptInjectionInlineMode)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteType_RouteDestination) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteType_RouteDestination{` +
		`RouteDestination:` + fmt.Sprintf("%#v", this.RouteDestination) + `}`}, ", ")
	return s
}
func (this *RouteType_RouteRedirect) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteType_RouteRedirect{` +
		`RouteRedirect:` + fmt.Sprintf("%#v", this.RouteRedirect) + `}`}, ", ")
	return s
}
func (this *RouteType_RouteDirectResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteType_RouteDirectResponse{` +
		`RouteDirectResponse:` + fmt.Sprintf("%#v", this.RouteDirectResponse) + `}`}, ", ")
	return s
}
func (this *RouteType_InheritedBotDefenseJavascriptInjection) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteType_InheritedBotDefenseJavascriptInjection{` +
		`InheritedBotDefenseJavascriptInjection:` + fmt.Sprintf("%#v", this.InheritedBotDefenseJavascriptInjection) + `}`}, ", ")
	return s
}
func (this *RouteType_BotDefenseJavascriptInjection) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteType_BotDefenseJavascriptInjection{` +
		`BotDefenseJavascriptInjection:` + fmt.Sprintf("%#v", this.BotDefenseJavascriptInjection) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&route.GlobalSpecType{")
	if this.Routes != nil {
		s = append(s, "Routes: "+fmt.Sprintf("%#v", this.Routes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&route.CreateSpecType{")
	if this.Routes != nil {
		s = append(s, "Routes: "+fmt.Sprintf("%#v", this.Routes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&route.ReplaceSpecType{")
	if this.Routes != nil {
		s = append(s, "Routes: "+fmt.Sprintf("%#v", this.Routes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&route.GetSpecType{")
	if this.Routes != nil {
		s = append(s, "Routes: "+fmt.Sprintf("%#v", this.Routes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *VerStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteDestination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteDestination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteDestination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Priority != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x28
	}
	if len(m.EndpointSubsets) > 0 {
		keysForEndpointSubsets := make([]string, 0, len(m.EndpointSubsets))
		for k := range m.EndpointSubsets {
			keysForEndpointSubsets = append(keysForEndpointSubsets, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForEndpointSubsets)
		for iNdEx := len(keysForEndpointSubsets) - 1; iNdEx >= 0; iNdEx-- {
			v := m.EndpointSubsets[string(keysForEndpointSubsets[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForEndpointSubsets[iNdEx])
			copy(dAtA[i:], keysForEndpointSubsets[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForEndpointSubsets[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Weight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Weight))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Cluster) > 0 {
		for iNdEx := len(m.Cluster) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cluster[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MirrorPolicyType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorPolicyType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorPolicyType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Percent != nil {
		{
			size, err := m.Percent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Cluster) > 0 {
		for iNdEx := len(m.Cluster) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cluster[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SpdyConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpdyConfigType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpdyConfigType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UseSpdy {
		i--
		if m.UseSpdy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WebsocketConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebsocketConfigType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WebsocketConfigType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UseWebsocket {
		i--
		if m.UseWebsocket {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CookieForHashing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CookieForHashing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieForHashing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Httponly != nil {
		{
			size := m.Httponly.Size()
			i -= size
			if _, err := m.Httponly.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Secure != nil {
		{
			size := m.Secure.Size()
			i -= size
			if _, err := m.Secure.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Samesite != nil {
		{
			size := m.Samesite.Size()
			i -= size
			if _, err := m.Samesite.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Ttl != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Ttl))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CookieForHashing_IgnoreSamesite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieForHashing_IgnoreSamesite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IgnoreSamesite != nil {
		{
			size, err := m.IgnoreSamesite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *CookieForHashing_SamesiteStrict) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieForHashing_SamesiteStrict) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SamesiteStrict != nil {
		{
			size, err := m.SamesiteStrict.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *CookieForHashing_SamesiteLax) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieForHashing_SamesiteLax) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SamesiteLax != nil {
		{
			size, err := m.SamesiteLax.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *CookieForHashing_SamesiteNone) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieForHashing_SamesiteNone) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SamesiteNone != nil {
		{
			size, err := m.SamesiteNone.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *CookieForHashing_IgnoreSecure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieForHashing_IgnoreSecure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IgnoreSecure != nil {
		{
			size, err := m.IgnoreSecure.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *CookieForHashing_AddSecure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieForHashing_AddSecure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddSecure != nil {
		{
			size, err := m.AddSecure.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *CookieForHashing_IgnoreHttponly) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieForHashing_IgnoreHttponly) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IgnoreHttponly != nil {
		{
			size, err := m.IgnoreHttponly.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *CookieForHashing_AddHttponly) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieForHashing_AddHttponly) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddHttponly != nil {
		{
			size, err := m.AddHttponly.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *HashPolicyType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HashPolicyType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HashPolicyType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Terminal {
		i--
		if m.Terminal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.PolicySpecifier != nil {
		{
			size := m.PolicySpecifier.Size()
			i -= size
			if _, err := m.PolicySpecifier.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *HashPolicyType_HeaderName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HashPolicyType_HeaderName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.HeaderName)
	copy(dAtA[i:], m.HeaderName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.HeaderName)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *HashPolicyType_Cookie) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HashPolicyType_Cookie) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Cookie != nil {
		{
			size, err := m.Cookie.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *HashPolicyType_SourceIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HashPolicyType_SourceIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.SourceIp {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *RouteDestinationList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteDestinationList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteDestinationList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RouteDestinationRewrite != nil {
		{
			size := m.RouteDestinationRewrite.Size()
			i -= size
			if _, err := m.RouteDestinationRewrite.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.CsrfPolicy != nil {
		{
			size, err := m.CsrfPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.ClusterRetractChoice != nil {
		{
			size := m.ClusterRetractChoice.Size()
			i -= size
			if _, err := m.ClusterRetractChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.SpdyConfig != nil {
		{
			size, err := m.SpdyConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.Priority != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.HashPolicy) > 0 {
		for iNdEx := len(m.HashPolicy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HashPolicy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.CorsPolicy != nil {
		{
			size, err := m.CorsPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.BufferPolicy != nil {
		{
			size, err := m.BufferPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.WebSocketConfig != nil {
		{
			size, err := m.WebSocketConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.MirrorPolicy != nil {
		{
			size, err := m.MirrorPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.EndpointSubsets) > 0 {
		keysForEndpointSubsets := make([]string, 0, len(m.EndpointSubsets))
		for k := range m.EndpointSubsets {
			keysForEndpointSubsets = append(keysForEndpointSubsets, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForEndpointSubsets)
		for iNdEx := len(keysForEndpointSubsets) - 1; iNdEx >= 0; iNdEx-- {
			v := m.EndpointSubsets[string(keysForEndpointSubsets[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForEndpointSubsets[iNdEx])
			copy(dAtA[i:], keysForEndpointSubsets[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForEndpointSubsets[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if m.RetryPolicy != nil {
		{
			size, err := m.RetryPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Timeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x40
	}
	if m.HostRewriteParams != nil {
		{
			size := m.HostRewriteParams.Size()
			i -= size
			if _, err := m.HostRewriteParams.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Destinations) > 0 {
		for iNdEx := len(m.Destinations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Destinations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RouteDestinationList_PrefixRewrite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteDestinationList_PrefixRewrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.PrefixRewrite)
	copy(dAtA[i:], m.PrefixRewrite)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.PrefixRewrite)))
	i--
	dAtA[i] = 0x2a
	return len(dAtA) - i, nil
}
func (m *RouteDestinationList_HostRewrite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteDestinationList_HostRewrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.HostRewrite)
	copy(dAtA[i:], m.HostRewrite)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.HostRewrite)))
	i--
	dAtA[i] = 0x32
	return len(dAtA) - i, nil
}
func (m *RouteDestinationList_AutoHostRewrite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteDestinationList_AutoHostRewrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.AutoHostRewrite {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x38
	return len(dAtA) - i, nil
}
func (m *RouteDestinationList_RetractCluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteDestinationList_RetractCluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RetractCluster != nil {
		{
			size, err := m.RetractCluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *RouteDestinationList_DoNotRetractCluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteDestinationList_DoNotRetractCluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DoNotRetractCluster != nil {
		{
			size, err := m.DoNotRetractCluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *RouteDestinationList_RegexRewrite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteDestinationList_RegexRewrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RegexRewrite != nil {
		{
			size, err := m.RegexRewrite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *RouteQueryParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteQueryParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteQueryParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.QueryParams) > 0 {
		for iNdEx := len(m.QueryParams) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.QueryParams[iNdEx])
			copy(dAtA[i:], m.QueryParams[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.QueryParams[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RouteRedirect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteRedirect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteRedirect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PortRedirect != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PortRedirect))
		i--
		dAtA[i] = 0x68
	}
	if m.QueryParams != nil {
		{
			size := m.QueryParams.Size()
			i -= size
			if _, err := m.QueryParams.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.RedirectPathChoice != nil {
		{
			size := m.RedirectPathChoice.Size()
			i -= size
			if _, err := m.RedirectPathChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ResponseCode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ResponseCode))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ProtoRedirect) > 0 {
		i -= len(m.ProtoRedirect)
		copy(dAtA[i:], m.ProtoRedirect)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProtoRedirect)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.HostRedirect) > 0 {
		i -= len(m.HostRedirect)
		copy(dAtA[i:], m.HostRedirect)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HostRedirect)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteRedirect_PathRedirect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteRedirect_PathRedirect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.PathRedirect)
	copy(dAtA[i:], m.PathRedirect)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.PathRedirect)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *RouteRedirect_StripQueryParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteRedirect_StripQueryParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StripQueryParams != nil {
		{
			size, err := m.StripQueryParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *RouteRedirect_AllParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteRedirect_AllParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.AllParams {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *RouteRedirect_RetainAllParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteRedirect_RetainAllParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RetainAllParams != nil {
		{
			size, err := m.RetainAllParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *RouteRedirect_RemoveAllParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteRedirect_RemoveAllParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RemoveAllParams != nil {
		{
			size, err := m.RemoveAllParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *RouteRedirect_PrefixRewrite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteRedirect_PrefixRewrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.PrefixRewrite)
	copy(dAtA[i:], m.PrefixRewrite)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.PrefixRewrite)))
	i--
	dAtA[i] = 0x5a
	return len(dAtA) - i, nil
}
func (m *RouteRedirect_ReplaceParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteRedirect_ReplaceParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ReplaceParams)
	copy(dAtA[i:], m.ReplaceParams)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ReplaceParams)))
	i--
	dAtA[i] = 0x62
	return len(dAtA) - i, nil
}
func (m *RouteDirectResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteDirectResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteDirectResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResponseBody) > 0 {
		i -= len(m.ResponseBody)
		copy(dAtA[i:], m.ResponseBody)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ResponseBody)))
		i--
		dAtA[i] = 0x12
	}
	if m.ResponseCode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ResponseCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ContextExtensionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContextExtensionInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContextExtensionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ContextExtensions) > 0 {
		keysForContextExtensions := make([]string, 0, len(m.ContextExtensions))
		for k := range m.ContextExtensions {
			keysForContextExtensions = append(keysForContextExtensions, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForContextExtensions)
		for iNdEx := len(keysForContextExtensions) - 1; iNdEx >= 0; iNdEx-- {
			v := m.ContextExtensions[string(keysForContextExtensions[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForContextExtensions[iNdEx])
			copy(dAtA[i:], keysForContextExtensions[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForContextExtensions[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BotDefenseJavascriptInjectionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BotDefenseJavascriptInjectionType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseJavascriptInjectionType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.JavascriptTags) > 0 {
		for iNdEx := len(m.JavascriptTags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.JavascriptTags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.JavascriptLocation != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.JavascriptLocation))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *JavaScriptTag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JavaScriptTag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JavaScriptTag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TagAttributes) > 0 {
		for iNdEx := len(m.TagAttributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TagAttributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.JavascriptUrl) > 0 {
		i -= len(m.JavascriptUrl)
		copy(dAtA[i:], m.JavascriptUrl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.JavascriptUrl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TagAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagAttribute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TagAttribute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TagValue) > 0 {
		i -= len(m.TagValue)
		copy(dAtA[i:], m.TagValue)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TagValue)))
		i--
		dAtA[i] = 0x12
	}
	if m.JavascriptTag != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.JavascriptTag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ContentRewriteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContentRewriteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContentRewriteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Position != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Position))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ElementSelector) > 0 {
		i -= len(m.ElementSelector)
		copy(dAtA[i:], m.ElementSelector)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ElementSelector)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.InsertContent) > 0 {
		i -= len(m.InsertContent)
		copy(dAtA[i:], m.InsertContent)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InsertContent)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServicePolicyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServicePolicyInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServicePolicyInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ServicePolicyChoice != nil {
		{
			size := m.ServicePolicyChoice.Size()
			i -= size
			if _, err := m.ServicePolicyChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ServicePolicyInfo_Disable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServicePolicyInfo_Disable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Disable {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *ServicePolicyInfo_ContextExtensions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServicePolicyInfo_ContextExtensions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ContextExtensions != nil {
		{
			size, err := m.ContextExtensions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *RouteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BotDefenseJavascriptInjectionInlineMode != nil {
		{
			size, err := m.BotDefenseJavascriptInjectionInlineMode.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.BotDefenseJavascriptInjectionChoice != nil {
		{
			size := m.BotDefenseJavascriptInjectionChoice.Size()
			i -= size
			if _, err := m.BotDefenseJavascriptInjectionChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.SkipLbOverride {
		i--
		if m.SkipLbOverride {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.DisableLocationAdd {
		i--
		if m.DisableLocationAdd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.ServicePolicy != nil {
		{
			size, err := m.ServicePolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.WafType != nil {
		{
			size, err := m.WafType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for iNdEx := len(m.ResponseHeadersToRemove) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ResponseHeadersToRemove[iNdEx])
			copy(dAtA[i:], m.ResponseHeadersToRemove[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ResponseHeadersToRemove[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for iNdEx := len(m.RequestHeadersToRemove) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RequestHeadersToRemove[iNdEx])
			copy(dAtA[i:], m.RequestHeadersToRemove[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RequestHeadersToRemove[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for iNdEx := len(m.ResponseHeadersToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResponseHeadersToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for iNdEx := len(m.RequestHeadersToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RequestHeadersToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.DisableCustomScript {
		i--
		if m.DisableCustomScript {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.RouteAction != nil {
		{
			size := m.RouteAction.Size()
			i -= size
			if _, err := m.RouteAction.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Match) > 0 {
		for iNdEx := len(m.Match) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Match[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RouteType_RouteDestination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteType_RouteDestination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RouteDestination != nil {
		{
			size, err := m.RouteDestination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *RouteType_RouteRedirect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteType_RouteRedirect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RouteRedirect != nil {
		{
			size, err := m.RouteRedirect.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *RouteType_RouteDirectResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteType_RouteDirectResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RouteDirectResponse != nil {
		{
			size, err := m.RouteDirectResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *RouteType_InheritedBotDefenseJavascriptInjection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteType_InheritedBotDefenseJavascriptInjection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InheritedBotDefenseJavascriptInjection != nil {
		{
			size, err := m.InheritedBotDefenseJavascriptInjection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *RouteType_BotDefenseJavascriptInjection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteType_BotDefenseJavascriptInjection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BotDefenseJavascriptInjection != nil {
		{
			size, err := m.BotDefenseJavascriptInjection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *VerStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RouteDestination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cluster) > 0 {
		for _, e := range m.Cluster {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Weight != 0 {
		n += 1 + sovTypes(uint64(m.Weight))
	}
	if len(m.EndpointSubsets) > 0 {
		for k, v := range m.EndpointSubsets {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.Priority != 0 {
		n += 1 + sovTypes(uint64(m.Priority))
	}
	return n
}

func (m *MirrorPolicyType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cluster) > 0 {
		for _, e := range m.Cluster {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Percent != nil {
		l = m.Percent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SpdyConfigType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseSpdy {
		n += 2
	}
	return n
}

func (m *WebsocketConfigType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseWebsocket {
		n += 2
	}
	return n
}

func (m *CookieForHashing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Ttl != 0 {
		n += 1 + sovTypes(uint64(m.Ttl))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Samesite != nil {
		n += m.Samesite.Size()
	}
	if m.Secure != nil {
		n += m.Secure.Size()
	}
	if m.Httponly != nil {
		n += m.Httponly.Size()
	}
	return n
}

func (m *CookieForHashing_IgnoreSamesite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IgnoreSamesite != nil {
		l = m.IgnoreSamesite.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CookieForHashing_SamesiteStrict) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SamesiteStrict != nil {
		l = m.SamesiteStrict.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CookieForHashing_SamesiteLax) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SamesiteLax != nil {
		l = m.SamesiteLax.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CookieForHashing_SamesiteNone) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SamesiteNone != nil {
		l = m.SamesiteNone.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CookieForHashing_IgnoreSecure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IgnoreSecure != nil {
		l = m.IgnoreSecure.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CookieForHashing_AddSecure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddSecure != nil {
		l = m.AddSecure.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CookieForHashing_IgnoreHttponly) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IgnoreHttponly != nil {
		l = m.IgnoreHttponly.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CookieForHashing_AddHttponly) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddHttponly != nil {
		l = m.AddHttponly.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HashPolicyType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PolicySpecifier != nil {
		n += m.PolicySpecifier.Size()
	}
	if m.Terminal {
		n += 2
	}
	return n
}

func (m *HashPolicyType_HeaderName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HeaderName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *HashPolicyType_Cookie) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cookie != nil {
		l = m.Cookie.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HashPolicyType_SourceIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *RouteDestinationList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Destinations) > 0 {
		for _, e := range m.Destinations {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.RouteDestinationRewrite != nil {
		n += m.RouteDestinationRewrite.Size()
	}
	if m.HostRewriteParams != nil {
		n += m.HostRewriteParams.Size()
	}
	if m.Timeout != 0 {
		n += 1 + sovTypes(uint64(m.Timeout))
	}
	if m.RetryPolicy != nil {
		l = m.RetryPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.EndpointSubsets) > 0 {
		for k, v := range m.EndpointSubsets {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.MirrorPolicy != nil {
		l = m.MirrorPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.WebSocketConfig != nil {
		l = m.WebSocketConfig.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BufferPolicy != nil {
		l = m.BufferPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CorsPolicy != nil {
		l = m.CorsPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.HashPolicy) > 0 {
		for _, e := range m.HashPolicy {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.Priority != 0 {
		n += 2 + sovTypes(uint64(m.Priority))
	}
	if m.SpdyConfig != nil {
		l = m.SpdyConfig.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ClusterRetractChoice != nil {
		n += m.ClusterRetractChoice.Size()
	}
	if m.CsrfPolicy != nil {
		l = m.CsrfPolicy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RouteDestinationList_PrefixRewrite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PrefixRewrite)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *RouteDestinationList_HostRewrite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostRewrite)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *RouteDestinationList_AutoHostRewrite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *RouteDestinationList_RetractCluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetractCluster != nil {
		l = m.RetractCluster.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteDestinationList_DoNotRetractCluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DoNotRetractCluster != nil {
		l = m.DoNotRetractCluster.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteDestinationList_RegexRewrite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RegexRewrite != nil {
		l = m.RegexRewrite.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteQueryParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.QueryParams) > 0 {
		for _, s := range m.QueryParams {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *RouteRedirect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostRedirect)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RedirectPathChoice != nil {
		n += m.RedirectPathChoice.Size()
	}
	l = len(m.ProtoRedirect)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.QueryParams != nil {
		n += m.QueryParams.Size()
	}
	if m.ResponseCode != 0 {
		n += 1 + sovTypes(uint64(m.ResponseCode))
	}
	if m.PortRedirect != 0 {
		n += 1 + sovTypes(uint64(m.PortRedirect))
	}
	return n
}

func (m *RouteRedirect_PathRedirect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PathRedirect)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *RouteRedirect_StripQueryParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StripQueryParams != nil {
		l = m.StripQueryParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteRedirect_AllParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *RouteRedirect_RetainAllParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetainAllParams != nil {
		l = m.RetainAllParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteRedirect_RemoveAllParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RemoveAllParams != nil {
		l = m.RemoveAllParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteRedirect_PrefixRewrite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PrefixRewrite)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *RouteRedirect_ReplaceParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ReplaceParams)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *RouteDirectResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResponseCode != 0 {
		n += 1 + sovTypes(uint64(m.ResponseCode))
	}
	l = len(m.ResponseBody)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ContextExtensionInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ContextExtensions) > 0 {
		for k, v := range m.ContextExtensions {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *BotDefenseJavascriptInjectionType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JavascriptLocation != 0 {
		n += 1 + sovTypes(uint64(m.JavascriptLocation))
	}
	if len(m.JavascriptTags) > 0 {
		for _, e := range m.JavascriptTags {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *JavaScriptTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JavascriptUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.TagAttributes) > 0 {
		for _, e := range m.TagAttributes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *TagAttribute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JavascriptTag != 0 {
		n += 1 + sovTypes(uint64(m.JavascriptTag))
	}
	l = len(m.TagValue)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ContentRewriteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InsertContent)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ElementSelector)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Position != 0 {
		n += 1 + sovTypes(uint64(m.Position))
	}
	return n
}

func (m *ServicePolicyInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServicePolicyChoice != nil {
		n += m.ServicePolicyChoice.Size()
	}
	return n
}

func (m *ServicePolicyInfo_Disable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *ServicePolicyInfo_ContextExtensions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContextExtensions != nil {
		l = m.ContextExtensions.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Match) > 0 {
		for _, e := range m.Match {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.RouteAction != nil {
		n += m.RouteAction.Size()
	}
	if m.DisableCustomScript {
		n += 2
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, e := range m.RequestHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, e := range m.ResponseHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for _, s := range m.RequestHeadersToRemove {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.WafType != nil {
		l = m.WafType.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ServicePolicy != nil {
		l = m.ServicePolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DisableLocationAdd {
		n += 2
	}
	if m.SkipLbOverride {
		n += 2
	}
	if m.BotDefenseJavascriptInjectionChoice != nil {
		n += m.BotDefenseJavascriptInjectionChoice.Size()
	}
	if m.BotDefenseJavascriptInjectionInlineMode != nil {
		l = m.BotDefenseJavascriptInjectionInlineMode.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RouteType_RouteDestination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RouteDestination != nil {
		l = m.RouteDestination.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteType_RouteRedirect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RouteRedirect != nil {
		l = m.RouteRedirect.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteType_RouteDirectResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RouteDirectResponse != nil {
		l = m.RouteDirectResponse.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteType_InheritedBotDefenseJavascriptInjection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InheritedBotDefenseJavascriptInjection != nil {
		l = m.InheritedBotDefenseJavascriptInjection.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteType_BotDefenseJavascriptInjection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BotDefenseJavascriptInjection != nil {
		l = m.BotDefenseJavascriptInjection.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *VerStatusType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VerStatusType{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteDestination) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCluster := "[]*ObjectRefType{"
	for _, f := range this.Cluster {
		repeatedStringForCluster += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForCluster += "}"
	keysForEndpointSubsets := make([]string, 0, len(this.EndpointSubsets))
	for k, _ := range this.EndpointSubsets {
		keysForEndpointSubsets = append(keysForEndpointSubsets, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEndpointSubsets)
	mapStringForEndpointSubsets := "map[string]string{"
	for _, k := range keysForEndpointSubsets {
		mapStringForEndpointSubsets += fmt.Sprintf("%v: %v,", k, this.EndpointSubsets[k])
	}
	mapStringForEndpointSubsets += "}"
	s := strings.Join([]string{`&RouteDestination{`,
		`Cluster:` + repeatedStringForCluster + `,`,
		`Weight:` + fmt.Sprintf("%v", this.Weight) + `,`,
		`EndpointSubsets:` + mapStringForEndpointSubsets + `,`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MirrorPolicyType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCluster := "[]*ObjectRefType{"
	for _, f := range this.Cluster {
		repeatedStringForCluster += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForCluster += "}"
	s := strings.Join([]string{`&MirrorPolicyType{`,
		`Cluster:` + repeatedStringForCluster + `,`,
		`Percent:` + strings.Replace(fmt.Sprintf("%v", this.Percent), "FractionalPercent", "schema.FractionalPercent", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SpdyConfigType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SpdyConfigType{`,
		`UseSpdy:` + fmt.Sprintf("%v", this.UseSpdy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WebsocketConfigType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WebsocketConfigType{`,
		`UseWebsocket:` + fmt.Sprintf("%v", this.UseWebsocket) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieForHashing) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieForHashing{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Ttl:` + fmt.Sprintf("%v", this.Ttl) + `,`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`Samesite:` + fmt.Sprintf("%v", this.Samesite) + `,`,
		`Secure:` + fmt.Sprintf("%v", this.Secure) + `,`,
		`Httponly:` + fmt.Sprintf("%v", this.Httponly) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieForHashing_IgnoreSamesite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieForHashing_IgnoreSamesite{`,
		`IgnoreSamesite:` + strings.Replace(fmt.Sprintf("%v", this.IgnoreSamesite), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieForHashing_SamesiteStrict) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieForHashing_SamesiteStrict{`,
		`SamesiteStrict:` + strings.Replace(fmt.Sprintf("%v", this.SamesiteStrict), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieForHashing_SamesiteLax) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieForHashing_SamesiteLax{`,
		`SamesiteLax:` + strings.Replace(fmt.Sprintf("%v", this.SamesiteLax), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieForHashing_SamesiteNone) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieForHashing_SamesiteNone{`,
		`SamesiteNone:` + strings.Replace(fmt.Sprintf("%v", this.SamesiteNone), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieForHashing_IgnoreSecure) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieForHashing_IgnoreSecure{`,
		`IgnoreSecure:` + strings.Replace(fmt.Sprintf("%v", this.IgnoreSecure), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieForHashing_AddSecure) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieForHashing_AddSecure{`,
		`AddSecure:` + strings.Replace(fmt.Sprintf("%v", this.AddSecure), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieForHashing_IgnoreHttponly) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieForHashing_IgnoreHttponly{`,
		`IgnoreHttponly:` + strings.Replace(fmt.Sprintf("%v", this.IgnoreHttponly), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieForHashing_AddHttponly) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieForHashing_AddHttponly{`,
		`AddHttponly:` + strings.Replace(fmt.Sprintf("%v", this.AddHttponly), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HashPolicyType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HashPolicyType{`,
		`PolicySpecifier:` + fmt.Sprintf("%v", this.PolicySpecifier) + `,`,
		`Terminal:` + fmt.Sprintf("%v", this.Terminal) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HashPolicyType_HeaderName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HashPolicyType_HeaderName{`,
		`HeaderName:` + fmt.Sprintf("%v", this.HeaderName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HashPolicyType_Cookie) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HashPolicyType_Cookie{`,
		`Cookie:` + strings.Replace(fmt.Sprintf("%v", this.Cookie), "CookieForHashing", "CookieForHashing", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HashPolicyType_SourceIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HashPolicyType_SourceIp{`,
		`SourceIp:` + fmt.Sprintf("%v", this.SourceIp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteDestinationList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForDestinations := "[]*RouteDestination{"
	for _, f := range this.Destinations {
		repeatedStringForDestinations += strings.Replace(f.String(), "RouteDestination", "RouteDestination", 1) + ","
	}
	repeatedStringForDestinations += "}"
	repeatedStringForHashPolicy := "[]*HashPolicyType{"
	for _, f := range this.HashPolicy {
		repeatedStringForHashPolicy += strings.Replace(f.String(), "HashPolicyType", "HashPolicyType", 1) + ","
	}
	repeatedStringForHashPolicy += "}"
	keysForEndpointSubsets := make([]string, 0, len(this.EndpointSubsets))
	for k, _ := range this.EndpointSubsets {
		keysForEndpointSubsets = append(keysForEndpointSubsets, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEndpointSubsets)
	mapStringForEndpointSubsets := "map[string]string{"
	for _, k := range keysForEndpointSubsets {
		mapStringForEndpointSubsets += fmt.Sprintf("%v: %v,", k, this.EndpointSubsets[k])
	}
	mapStringForEndpointSubsets += "}"
	s := strings.Join([]string{`&RouteDestinationList{`,
		`Destinations:` + repeatedStringForDestinations + `,`,
		`RouteDestinationRewrite:` + fmt.Sprintf("%v", this.RouteDestinationRewrite) + `,`,
		`HostRewriteParams:` + fmt.Sprintf("%v", this.HostRewriteParams) + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`RetryPolicy:` + strings.Replace(fmt.Sprintf("%v", this.RetryPolicy), "RetryPolicyType", "schema.RetryPolicyType", 1) + `,`,
		`EndpointSubsets:` + mapStringForEndpointSubsets + `,`,
		`MirrorPolicy:` + strings.Replace(this.MirrorPolicy.String(), "MirrorPolicyType", "MirrorPolicyType", 1) + `,`,
		`WebSocketConfig:` + strings.Replace(this.WebSocketConfig.String(), "WebsocketConfigType", "WebsocketConfigType", 1) + `,`,
		`BufferPolicy:` + strings.Replace(fmt.Sprintf("%v", this.BufferPolicy), "BufferConfigType", "schema.BufferConfigType", 1) + `,`,
		`CorsPolicy:` + strings.Replace(fmt.Sprintf("%v", this.CorsPolicy), "CorsPolicy", "schema.CorsPolicy", 1) + `,`,
		`HashPolicy:` + repeatedStringForHashPolicy + `,`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`SpdyConfig:` + strings.Replace(this.SpdyConfig.String(), "SpdyConfigType", "SpdyConfigType", 1) + `,`,
		`ClusterRetractChoice:` + fmt.Sprintf("%v", this.ClusterRetractChoice) + `,`,
		`CsrfPolicy:` + strings.Replace(fmt.Sprintf("%v", this.CsrfPolicy), "CsrfPolicy", "schema.CsrfPolicy", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteDestinationList_PrefixRewrite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteDestinationList_PrefixRewrite{`,
		`PrefixRewrite:` + fmt.Sprintf("%v", this.PrefixRewrite) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteDestinationList_HostRewrite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteDestinationList_HostRewrite{`,
		`HostRewrite:` + fmt.Sprintf("%v", this.HostRewrite) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteDestinationList_AutoHostRewrite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteDestinationList_AutoHostRewrite{`,
		`AutoHostRewrite:` + fmt.Sprintf("%v", this.AutoHostRewrite) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteDestinationList_RetractCluster) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteDestinationList_RetractCluster{`,
		`RetractCluster:` + strings.Replace(fmt.Sprintf("%v", this.RetractCluster), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteDestinationList_DoNotRetractCluster) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteDestinationList_DoNotRetractCluster{`,
		`DoNotRetractCluster:` + strings.Replace(fmt.Sprintf("%v", this.DoNotRetractCluster), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteDestinationList_RegexRewrite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteDestinationList_RegexRewrite{`,
		`RegexRewrite:` + strings.Replace(fmt.Sprintf("%v", this.RegexRewrite), "RegexMatchRewrite", "schema.RegexMatchRewrite", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteQueryParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteQueryParams{`,
		`QueryParams:` + fmt.Sprintf("%v", this.QueryParams) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteRedirect) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteRedirect{`,
		`HostRedirect:` + fmt.Sprintf("%v", this.HostRedirect) + `,`,
		`RedirectPathChoice:` + fmt.Sprintf("%v", this.RedirectPathChoice) + `,`,
		`ProtoRedirect:` + fmt.Sprintf("%v", this.ProtoRedirect) + `,`,
		`QueryParams:` + fmt.Sprintf("%v", this.QueryParams) + `,`,
		`ResponseCode:` + fmt.Sprintf("%v", this.ResponseCode) + `,`,
		`PortRedirect:` + fmt.Sprintf("%v", this.PortRedirect) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteRedirect_PathRedirect) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteRedirect_PathRedirect{`,
		`PathRedirect:` + fmt.Sprintf("%v", this.PathRedirect) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteRedirect_StripQueryParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteRedirect_StripQueryParams{`,
		`StripQueryParams:` + strings.Replace(fmt.Sprintf("%v", this.StripQueryParams), "RouteQueryParams", "RouteQueryParams", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteRedirect_AllParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteRedirect_AllParams{`,
		`AllParams:` + fmt.Sprintf("%v", this.AllParams) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteRedirect_RetainAllParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteRedirect_RetainAllParams{`,
		`RetainAllParams:` + strings.Replace(fmt.Sprintf("%v", this.RetainAllParams), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteRedirect_RemoveAllParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteRedirect_RemoveAllParams{`,
		`RemoveAllParams:` + strings.Replace(fmt.Sprintf("%v", this.RemoveAllParams), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteRedirect_PrefixRewrite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteRedirect_PrefixRewrite{`,
		`PrefixRewrite:` + fmt.Sprintf("%v", this.PrefixRewrite) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteRedirect_ReplaceParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteRedirect_ReplaceParams{`,
		`ReplaceParams:` + fmt.Sprintf("%v", this.ReplaceParams) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteDirectResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteDirectResponse{`,
		`ResponseCode:` + fmt.Sprintf("%v", this.ResponseCode) + `,`,
		`ResponseBody:` + fmt.Sprintf("%v", this.ResponseBody) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContextExtensionInfo) String() string {
	if this == nil {
		return "nil"
	}
	keysForContextExtensions := make([]string, 0, len(this.ContextExtensions))
	for k, _ := range this.ContextExtensions {
		keysForContextExtensions = append(keysForContextExtensions, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForContextExtensions)
	mapStringForContextExtensions := "map[string]string{"
	for _, k := range keysForContextExtensions {
		mapStringForContextExtensions += fmt.Sprintf("%v: %v,", k, this.ContextExtensions[k])
	}
	mapStringForContextExtensions += "}"
	s := strings.Join([]string{`&ContextExtensionInfo{`,
		`ContextExtensions:` + mapStringForContextExtensions + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseJavascriptInjectionType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForJavascriptTags := "[]*JavaScriptTag{"
	for _, f := range this.JavascriptTags {
		repeatedStringForJavascriptTags += strings.Replace(f.String(), "JavaScriptTag", "JavaScriptTag", 1) + ","
	}
	repeatedStringForJavascriptTags += "}"
	s := strings.Join([]string{`&BotDefenseJavascriptInjectionType{`,
		`JavascriptLocation:` + fmt.Sprintf("%v", this.JavascriptLocation) + `,`,
		`JavascriptTags:` + repeatedStringForJavascriptTags + `,`,
		`}`,
	}, "")
	return s
}
func (this *JavaScriptTag) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTagAttributes := "[]*TagAttribute{"
	for _, f := range this.TagAttributes {
		repeatedStringForTagAttributes += strings.Replace(f.String(), "TagAttribute", "TagAttribute", 1) + ","
	}
	repeatedStringForTagAttributes += "}"
	s := strings.Join([]string{`&JavaScriptTag{`,
		`JavascriptUrl:` + fmt.Sprintf("%v", this.JavascriptUrl) + `,`,
		`TagAttributes:` + repeatedStringForTagAttributes + `,`,
		`}`,
	}, "")
	return s
}
func (this *TagAttribute) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TagAttribute{`,
		`JavascriptTag:` + fmt.Sprintf("%v", this.JavascriptTag) + `,`,
		`TagValue:` + fmt.Sprintf("%v", this.TagValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContentRewriteType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContentRewriteType{`,
		`InsertContent:` + fmt.Sprintf("%v", this.InsertContent) + `,`,
		`ElementSelector:` + fmt.Sprintf("%v", this.ElementSelector) + `,`,
		`Position:` + fmt.Sprintf("%v", this.Position) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServicePolicyInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServicePolicyInfo{`,
		`ServicePolicyChoice:` + fmt.Sprintf("%v", this.ServicePolicyChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServicePolicyInfo_Disable) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServicePolicyInfo_Disable{`,
		`Disable:` + fmt.Sprintf("%v", this.Disable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServicePolicyInfo_ContextExtensions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServicePolicyInfo_ContextExtensions{`,
		`ContextExtensions:` + strings.Replace(fmt.Sprintf("%v", this.ContextExtensions), "ContextExtensionInfo", "ContextExtensionInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMatch := "[]*RouteMatch{"
	for _, f := range this.Match {
		repeatedStringForMatch += strings.Replace(fmt.Sprintf("%v", f), "RouteMatch", "schema.RouteMatch", 1) + ","
	}
	repeatedStringForMatch += "}"
	repeatedStringForRequestHeadersToAdd := "[]*HeaderManipulationOptionType{"
	for _, f := range this.RequestHeadersToAdd {
		repeatedStringForRequestHeadersToAdd += strings.Replace(fmt.Sprintf("%v", f), "HeaderManipulationOptionType", "schema.HeaderManipulationOptionType", 1) + ","
	}
	repeatedStringForRequestHeadersToAdd += "}"
	repeatedStringForResponseHeadersToAdd := "[]*HeaderManipulationOptionType{"
	for _, f := range this.ResponseHeadersToAdd {
		repeatedStringForResponseHeadersToAdd += strings.Replace(fmt.Sprintf("%v", f), "HeaderManipulationOptionType", "schema.HeaderManipulationOptionType", 1) + ","
	}
	repeatedStringForResponseHeadersToAdd += "}"
	s := strings.Join([]string{`&RouteType{`,
		`Match:` + repeatedStringForMatch + `,`,
		`RouteAction:` + fmt.Sprintf("%v", this.RouteAction) + `,`,
		`DisableCustomScript:` + fmt.Sprintf("%v", this.DisableCustomScript) + `,`,
		`RequestHeadersToAdd:` + repeatedStringForRequestHeadersToAdd + `,`,
		`ResponseHeadersToAdd:` + repeatedStringForResponseHeadersToAdd + `,`,
		`RequestHeadersToRemove:` + fmt.Sprintf("%v", this.RequestHeadersToRemove) + `,`,
		`ResponseHeadersToRemove:` + fmt.Sprintf("%v", this.ResponseHeadersToRemove) + `,`,
		`WafType:` + strings.Replace(fmt.Sprintf("%v", this.WafType), "WafType", "schema.WafType", 1) + `,`,
		`ServicePolicy:` + strings.Replace(this.ServicePolicy.String(), "ServicePolicyInfo", "ServicePolicyInfo", 1) + `,`,
		`DisableLocationAdd:` + fmt.Sprintf("%v", this.DisableLocationAdd) + `,`,
		`SkipLbOverride:` + fmt.Sprintf("%v", this.SkipLbOverride) + `,`,
		`BotDefenseJavascriptInjectionChoice:` + fmt.Sprintf("%v", this.BotDefenseJavascriptInjectionChoice) + `,`,
		`BotDefenseJavascriptInjectionInlineMode:` + strings.Replace(this.BotDefenseJavascriptInjectionInlineMode.String(), "ContentRewriteType", "ContentRewriteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteType_RouteDestination) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteType_RouteDestination{`,
		`RouteDestination:` + strings.Replace(fmt.Sprintf("%v", this.RouteDestination), "RouteDestinationList", "RouteDestinationList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteType_RouteRedirect) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteType_RouteRedirect{`,
		`RouteRedirect:` + strings.Replace(fmt.Sprintf("%v", this.RouteRedirect), "RouteRedirect", "RouteRedirect", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteType_RouteDirectResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteType_RouteDirectResponse{`,
		`RouteDirectResponse:` + strings.Replace(fmt.Sprintf("%v", this.RouteDirectResponse), "RouteDirectResponse", "RouteDirectResponse", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteType_InheritedBotDefenseJavascriptInjection) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteType_InheritedBotDefenseJavascriptInjection{`,
		`InheritedBotDefenseJavascriptInjection:` + strings.Replace(fmt.Sprintf("%v", this.InheritedBotDefenseJavascriptInjection), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteType_BotDefenseJavascriptInjection) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteType_BotDefenseJavascriptInjection{`,
		`BotDefenseJavascriptInjection:` + strings.Replace(fmt.Sprintf("%v", this.BotDefenseJavascriptInjection), "BotDefenseJavascriptInjectionType", "BotDefenseJavascriptInjectionType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRoutes := "[]*RouteType{"
	for _, f := range this.Routes {
		repeatedStringForRoutes += strings.Replace(f.String(), "RouteType", "RouteType", 1) + ","
	}
	repeatedStringForRoutes += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Routes:` + repeatedStringForRoutes + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRoutes := "[]*RouteType{"
	for _, f := range this.Routes {
		repeatedStringForRoutes += strings.Replace(f.String(), "RouteType", "RouteType", 1) + ","
	}
	repeatedStringForRoutes += "}"
	s := strings.Join([]string{`&CreateSpecType{`,
		`Routes:` + repeatedStringForRoutes + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRoutes := "[]*RouteType{"
	for _, f := range this.Routes {
		repeatedStringForRoutes += strings.Replace(f.String(), "RouteType", "RouteType", 1) + ","
	}
	repeatedStringForRoutes += "}"
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Routes:` + repeatedStringForRoutes + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRoutes := "[]*RouteType{"
	for _, f := range this.Routes {
		repeatedStringForRoutes += strings.Replace(f.String(), "RouteType", "RouteType", 1) + ","
	}
	repeatedStringForRoutes += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`Routes:` + repeatedStringForRoutes + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *VerStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteDestination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteDestination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteDestination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cluster = append(m.Cluster, &schema.ObjectRefType{})
			if err := m.Cluster[len(m.Cluster)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointSubsets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndpointSubsets == nil {
				m.EndpointSubsets = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EndpointSubsets[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorPolicyType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorPolicyType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorPolicyType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cluster = append(m.Cluster, &schema.ObjectRefType{})
			if err := m.Cluster[len(m.Cluster)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Percent == nil {
				m.Percent = &schema.FractionalPercent{}
			}
			if err := m.Percent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpdyConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpdyConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpdyConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseSpdy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseSpdy = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebsocketConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebsocketConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebsocketConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseWebsocket", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseWebsocket = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CookieForHashing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CookieForHashing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CookieForHashing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreSamesite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Samesite = &CookieForHashing_IgnoreSamesite{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SamesiteStrict", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Samesite = &CookieForHashing_SamesiteStrict{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SamesiteLax", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Samesite = &CookieForHashing_SamesiteLax{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SamesiteNone", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Samesite = &CookieForHashing_SamesiteNone{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreSecure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Secure = &CookieForHashing_IgnoreSecure{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddSecure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Secure = &CookieForHashing_AddSecure{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreHttponly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Httponly = &CookieForHashing_IgnoreHttponly{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddHttponly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Httponly = &CookieForHashing_AddHttponly{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HashPolicyType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HashPolicyType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HashPolicyType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PolicySpecifier = &HashPolicyType_HeaderName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookie", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CookieForHashing{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PolicySpecifier = &HashPolicyType_Cookie{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceIp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PolicySpecifier = &HashPolicyType_SourceIp{b}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terminal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Terminal = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteDestinationList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteDestinationList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteDestinationList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destinations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destinations = append(m.Destinations, &RouteDestination{})
			if err := m.Destinations[len(m.Destinations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixRewrite", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteDestinationRewrite = &RouteDestinationList_PrefixRewrite{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostRewrite", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostRewriteParams = &RouteDestinationList_HostRewrite{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoHostRewrite", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.HostRewriteParams = &RouteDestinationList_AutoHostRewrite{b}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetryPolicy == nil {
				m.RetryPolicy = &schema.RetryPolicyType{}
			}
			if err := m.RetryPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointSubsets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndpointSubsets == nil {
				m.EndpointSubsets = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EndpointSubsets[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MirrorPolicy == nil {
				m.MirrorPolicy = &MirrorPolicyType{}
			}
			if err := m.MirrorPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebSocketConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WebSocketConfig == nil {
				m.WebSocketConfig = &WebsocketConfigType{}
			}
			if err := m.WebSocketConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BufferPolicy == nil {
				m.BufferPolicy = &schema.BufferConfigType{}
			}
			if err := m.BufferPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CorsPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CorsPolicy == nil {
				m.CorsPolicy = &schema.CorsPolicy{}
			}
			if err := m.CorsPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashPolicy = append(m.HashPolicy, &HashPolicyType{})
			if err := m.HashPolicy[len(m.HashPolicy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= schema.RoutingPriority(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpdyConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpdyConfig == nil {
				m.SpdyConfig = &SpdyConfigType{}
			}
			if err := m.SpdyConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetractCluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClusterRetractChoice = &RouteDestinationList_RetractCluster{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoNotRetractCluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClusterRetractChoice = &RouteDestinationList_DoNotRetractCluster{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CsrfPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CsrfPolicy == nil {
				m.CsrfPolicy = &schema.CsrfPolicy{}
			}
			if err := m.CsrfPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegexRewrite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.RegexMatchRewrite{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RouteDestinationRewrite = &RouteDestinationList_RegexRewrite{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteQueryParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteQueryParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteQueryParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParams", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryParams = append(m.QueryParams, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteRedirect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteRedirect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteRedirect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostRedirect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostRedirect = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathRedirect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedirectPathChoice = &RouteRedirect_PathRedirect{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtoRedirect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtoRedirect = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StripQueryParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteQueryParams{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.QueryParams = &RouteRedirect_StripQueryParams{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllParams", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.QueryParams = &RouteRedirect_AllParams{b}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
			}
			m.ResponseCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetainAllParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.QueryParams = &RouteRedirect_RetainAllParams{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveAllParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.QueryParams = &RouteRedirect_RemoveAllParams{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixRewrite", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedirectPathChoice = &RouteRedirect_PrefixRewrite{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaceParams", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryParams = &RouteRedirect_ReplaceParams{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortRedirect", wireType)
			}
			m.PortRedirect = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortRedirect |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteDirectResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteDirectResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteDirectResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
			}
			m.ResponseCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseBody", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseBody = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContextExtensionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContextExtensionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContextExtensionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContextExtensions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContextExtensions == nil {
				m.ContextExtensions = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ContextExtensions[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BotDefenseJavascriptInjectionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BotDefenseJavascriptInjectionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BotDefenseJavascriptInjectionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavascriptLocation", wireType)
			}
			m.JavascriptLocation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JavascriptLocation |= JavaScriptLocation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavascriptTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JavascriptTags = append(m.JavascriptTags, &JavaScriptTag{})
			if err := m.JavascriptTags[len(m.JavascriptTags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JavaScriptTag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JavaScriptTag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JavaScriptTag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavascriptUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JavascriptUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagAttributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagAttributes = append(m.TagAttributes, &TagAttribute{})
			if err := m.TagAttributes[len(m.TagAttributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavascriptTag", wireType)
			}
			m.JavascriptTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JavascriptTag |= TagAttributeName(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContentRewriteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentRewriteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentRewriteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertContent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsertContent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElementSelector", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ElementSelector = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= policy.HTMLPosition(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServicePolicyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServicePolicyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServicePolicyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ServicePolicyChoice = &ServicePolicyInfo_Disable{b}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContextExtensions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ContextExtensionInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServicePolicyChoice = &ServicePolicyInfo_ContextExtensions{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Match = append(m.Match, &schema.RouteMatch{})
			if err := m.Match[len(m.Match)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteDestination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteDestinationList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RouteAction = &RouteType_RouteDestination{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteRedirect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteRedirect{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RouteAction = &RouteType_RouteRedirect{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteDirectResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteDirectResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RouteAction = &RouteType_RouteDirectResponse{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableCustomScript", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableCustomScript = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToAdd = append(m.RequestHeadersToAdd, &schema.HeaderManipulationOptionType{})
			if err := m.RequestHeadersToAdd[len(m.RequestHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToAdd = append(m.ResponseHeadersToAdd, &schema.HeaderManipulationOptionType{})
			if err := m.ResponseHeadersToAdd[len(m.ResponseHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToRemove = append(m.RequestHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToRemove = append(m.ResponseHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WafType == nil {
				m.WafType = &schema.WafType{}
			}
			if err := m.WafType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServicePolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServicePolicy == nil {
				m.ServicePolicy = &ServicePolicyInfo{}
			}
			if err := m.ServicePolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableLocationAdd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableLocationAdd = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipLbOverride", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipLbOverride = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InheritedBotDefenseJavascriptInjection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BotDefenseJavascriptInjectionChoice = &RouteType_InheritedBotDefenseJavascriptInjection{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotDefenseJavascriptInjection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BotDefenseJavascriptInjectionType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BotDefenseJavascriptInjectionChoice = &RouteType_BotDefenseJavascriptInjection{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotDefenseJavascriptInjectionInlineMode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BotDefenseJavascriptInjectionInlineMode == nil {
				m.BotDefenseJavascriptInjectionInlineMode = &ContentRewriteType{}
			}
			if err := m.BotDefenseJavascriptInjectionInlineMode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &RouteType{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &RouteType{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &RouteType{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &RouteType{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
