// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/route/types.proto

package route

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// RouteDestination
//
// x-displayName: "Destination"
// Each destination is a reference to cluster, it priority, weight and subset criteria.
type RouteDestination struct {
	// cluster
	//
	// x-displayName: "Cluster"
	// x-required
	// Indicates the upstream cluster to which the request should be sent. If the cluster
	// does not exist ServiceUnavailable response will be sent
	Cluster []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=cluster,proto3" json:"cluster,omitempty"`
	// weight
	//
	// x-displayName: "Weight"
	// x-example: 10
	// When requests have to distributed among multiple upstream clusters,
	// multiple destinations are configured, each having its own cluster and weight.
	// Traffic is distributed among clusters based on the weight configured.
	//
	// Example:
	//    destinations:
	//    - cluster:
	//      - kind: ves.io.vega.cfg.adc.cluster.Object
	//        uid: cluster-1
	//     weight: 20
	//   - cluster:
	//     - kind: ves.io.vega.cfg.adc.cluster.Object
	//       uid: cluster-2
	//     weight: 30
	//   - cluster:
	//     - kind: ves.io.vega.cfg.adc.cluster.Object
	//       uid: cluster-3
	//     weight: 10
	//
	// This indicates that out of every 60 requests, 10 goes to cluster-3, 30 to
	// cluster-2 and 20 to cluster-1
	//
	// When single destination is configured, weight is ignored. All the requests are
	// sent to the cluster specified in the destination
	Weight uint32 `protobuf:"varint,3,opt,name=weight,proto3" json:"weight,omitempty"`
	// endpoint_subsets
	//
	// x-displayName: "Endpoint Subsets"
	// Upstream cluster may be configured to divide its endpoints into subsets based on metadata
	// attached to the endpoints. Routes may then specify the metadata that a endpoint must match in
	// order to be selected by the load balancer
	//
	// Labels field of endpoint object's metadata is used for subset matching.
	// For endpoints which are discovered in K8S or Consul cluster, the label of the service is merged with
	// endpoint's labels. In case of Consul, the label is derived from the "Tag" field.
	// For labels that are common between configured endpoint and discovered service, labels from discovered service
	// takes precedence.
	//
	// List of key-value pairs that will be used as matching metadata. Only those endpoints of
	// upstream cluster which match this metadata will be selected for load balancing
	EndpointSubsets map[string]string `protobuf:"bytes,4,rep,name=endpoint_subsets,json=endpointSubsets,proto3" json:"endpoint_subsets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *RouteDestination) Reset()      { *m = RouteDestination{} }
func (*RouteDestination) ProtoMessage() {}
func (*RouteDestination) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{0}
}
func (m *RouteDestination) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteDestination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteDestination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteDestination.Merge(m, src)
}
func (m *RouteDestination) XXX_Size() int {
	return m.Size()
}
func (m *RouteDestination) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteDestination.DiscardUnknown(m)
}

var xxx_messageInfo_RouteDestination proto.InternalMessageInfo

func (m *RouteDestination) GetCluster() []*schema.ObjectRefType {
	if m != nil {
		return m.Cluster
	}
	return nil
}

func (m *RouteDestination) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *RouteDestination) GetEndpointSubsets() map[string]string {
	if m != nil {
		return m.EndpointSubsets
	}
	return nil
}

// MirrorPolicyType
//
// x-displayName: "Mirror Policy"
// MirrorPolicy is used for shadowing traffic from one cluster to another. The approach used
// is "fire and forget", meaning it will not wait for the shadow cluster to
// respond before returning the response from the primary cluster. All normal statistics are
// collected for the shadow cluster making this feature useful for testing and troubleshooting.
type MirrorPolicyType struct {
	// cluster
	//
	// x-displayName: "Mirror Destination Cluster"
	// x-required
	// Specifies the cluster to which the requests will be mirrored. The cluster object
	// referred here must be present.
	Cluster []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=cluster,proto3" json:"cluster,omitempty"`
	// percent
	//
	// x-displayName: "Mirror Percentage"
	// Percentage of requests to be mirrored
	Percent *schema.FractionalPercent `protobuf:"bytes,2,opt,name=percent,proto3" json:"percent,omitempty"`
}

func (m *MirrorPolicyType) Reset()      { *m = MirrorPolicyType{} }
func (*MirrorPolicyType) ProtoMessage() {}
func (*MirrorPolicyType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{1}
}
func (m *MirrorPolicyType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MirrorPolicyType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MirrorPolicyType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MirrorPolicyType.Merge(m, src)
}
func (m *MirrorPolicyType) XXX_Size() int {
	return m.Size()
}
func (m *MirrorPolicyType) XXX_DiscardUnknown() {
	xxx_messageInfo_MirrorPolicyType.DiscardUnknown(m)
}

var xxx_messageInfo_MirrorPolicyType proto.InternalMessageInfo

func (m *MirrorPolicyType) GetCluster() []*schema.ObjectRefType {
	if m != nil {
		return m.Cluster
	}
	return nil
}

func (m *MirrorPolicyType) GetPercent() *schema.FractionalPercent {
	if m != nil {
		return m.Percent
	}
	return nil
}

// SpdyConfigType
// Configuration to allow UPGRADE of connection to SPDY and any additional tuning
//
// x-displayName: "SPDY Configuration"
// Request headers of such upgrade looks like below
//   'connection', 'Upgrade'
//   'upgrade', 'SPDY/3.1'
//
// With configuration to allow SPDY upgrade, ADC will produce following response
//   'HTTP/1.1 101 Switching Protocols
//   'Upgrade': 'SPDY/3.1'
//   'Connection': 'Upgrade'
type SpdyConfigType struct {
	// use_spdy
	//
	// x-displayName: "Use SPDY"
	// x-example: true
	// Specifies that the HTTP client connection to this route is allowed to upgrade to
	// a SPDY connection
	UseSpdy bool `protobuf:"varint,1,opt,name=use_spdy,json=useSpdy,proto3" json:"use_spdy,omitempty"`
}

func (m *SpdyConfigType) Reset()      { *m = SpdyConfigType{} }
func (*SpdyConfigType) ProtoMessage() {}
func (*SpdyConfigType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{2}
}
func (m *SpdyConfigType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpdyConfigType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SpdyConfigType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpdyConfigType.Merge(m, src)
}
func (m *SpdyConfigType) XXX_Size() int {
	return m.Size()
}
func (m *SpdyConfigType) XXX_DiscardUnknown() {
	xxx_messageInfo_SpdyConfigType.DiscardUnknown(m)
}

var xxx_messageInfo_SpdyConfigType proto.InternalMessageInfo

func (m *SpdyConfigType) GetUseSpdy() bool {
	if m != nil {
		return m.UseSpdy
	}
	return false
}

// WebsocketConfigType
//
// x-displayName: "Websocket Configuration"
// Configuration to allow Websocket
//
// Request headers of such upgrade looks like below
//   'connection', 'Upgrade'
//   'upgrade', 'websocket'
//
// With configuration to allow websocket upgrade, ADC will produce following response
//   'HTTP/1.1 101 Switching Protocols
//   'Upgrade': 'websocket'
//   'Connection': 'Upgrade'
type WebsocketConfigType struct {
	// use_websocket
	//
	// x-displayName: "Use Websocket"
	// x-example: true
	// Specifies that the HTTP client connection to this route is allowed to upgrade to
	// a WebSocket connection
	UseWebsocket bool `protobuf:"varint,1,opt,name=use_websocket,json=useWebsocket,proto3" json:"use_websocket,omitempty"`
	// idle_timeout
	//
	// x-displayName: "Idle Timeout"
	// x-example: 2000
	// Idle Timeout for Websocket in milli seconds. After timeout, connection will be closed
	IdleTimeout uint32 `protobuf:"varint,2,opt,name=idle_timeout,json=idleTimeout,proto3" json:"idle_timeout,omitempty"` // Deprecated: Do not use.
	// max_connect_attempts
	//
	// x-displayName: "Maximum Connection Attempts"
	// x-example: 5
	// The maximum number of unsuccessful connection attempts that will be made before
	// giving up. Default is 1
	MaxConnectAttempts uint32 `protobuf:"varint,3,opt,name=max_connect_attempts,json=maxConnectAttempts,proto3" json:"max_connect_attempts,omitempty"` // Deprecated: Do not use.
}

func (m *WebsocketConfigType) Reset()      { *m = WebsocketConfigType{} }
func (*WebsocketConfigType) ProtoMessage() {}
func (*WebsocketConfigType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{3}
}
func (m *WebsocketConfigType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebsocketConfigType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WebsocketConfigType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebsocketConfigType.Merge(m, src)
}
func (m *WebsocketConfigType) XXX_Size() int {
	return m.Size()
}
func (m *WebsocketConfigType) XXX_DiscardUnknown() {
	xxx_messageInfo_WebsocketConfigType.DiscardUnknown(m)
}

var xxx_messageInfo_WebsocketConfigType proto.InternalMessageInfo

func (m *WebsocketConfigType) GetUseWebsocket() bool {
	if m != nil {
		return m.UseWebsocket
	}
	return false
}

// Deprecated: Do not use.
func (m *WebsocketConfigType) GetIdleTimeout() uint32 {
	if m != nil {
		return m.IdleTimeout
	}
	return 0
}

// Deprecated: Do not use.
func (m *WebsocketConfigType) GetMaxConnectAttempts() uint32 {
	if m != nil {
		return m.MaxConnectAttempts
	}
	return 0
}

// Cookie for hashing
//
// x-displayName: "Hashing using Cookie"
// Two types of cookie affinity:
//
// 1. Passive. Takes a cookie that's present in the cookies header and
//    hashes on its value.
//
// 2. Generated. Generates and sets a cookie with an expiration (TTL)
//    on the first request from the client in its response to the client,
//    based on the endpoint the request gets sent to. The client then
//    presents this on the next and all subsequent requests. The hash of
//    this is sufficient to ensure these requests get sent to the same
//    endpoint. The cookie is generated by hashing the source and
//    destination ports and addresses so that multiple independent HTTP2
//    streams on the same connection will independently receive the same
//    cookie, even if they arrive simultaneously.
type CookieForHashing struct {
	// name
	//
	// x-displayName: "Name"
	// x-required
	// x-example: "userid"
	// The name of the cookie that will be used to obtain the hash key. If the
	// cookie is not present and TTL below is not set, no hash will be
	// produced
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// ttl
	//
	// x-displayName: "TTL"
	// x-example: 5000
	// If specified, a cookie with the TTL will be generated if the cookie is
	// not present. If the TTL is present and zero, the generated cookie will
	// be a session cookie. TTL value is in milliseconds
	Ttl uint32 `protobuf:"varint,2,opt,name=ttl,proto3" json:"ttl,omitempty"`
	// path
	//
	// x-displayName: "Path"
	// x-example: "/Users/userid/browser/cookies"
	// The name of the path for the cookie. If no path is specified here, no path
	// will be set for the cookie
	Path string `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *CookieForHashing) Reset()      { *m = CookieForHashing{} }
func (*CookieForHashing) ProtoMessage() {}
func (*CookieForHashing) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{4}
}
func (m *CookieForHashing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CookieForHashing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CookieForHashing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CookieForHashing.Merge(m, src)
}
func (m *CookieForHashing) XXX_Size() int {
	return m.Size()
}
func (m *CookieForHashing) XXX_DiscardUnknown() {
	xxx_messageInfo_CookieForHashing.DiscardUnknown(m)
}

var xxx_messageInfo_CookieForHashing proto.InternalMessageInfo

func (m *CookieForHashing) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CookieForHashing) GetTtl() uint32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *CookieForHashing) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// HashPolicyType
//
// x-displayName: "Hash Policy"
// HashPolicyType specifies the field of the incoming request that will be used for
// generating hash key. When multiple hash policies are configured, this can also specify
// if the current hash policy is terminal policy or not.
type HashPolicyType struct {
	// PolicySpecifier
	//
	// x-displayName: "Hash Policy Specifier"
	// x-required
	// Specifies whether hashing is done on incoming request header, cookie or source IP
	//
	// Types that are valid to be assigned to PolicySpecifier:
	//	*HashPolicyType_HeaderName
	//	*HashPolicyType_Cookie
	//	*HashPolicyType_SourceIp
	PolicySpecifier isHashPolicyType_PolicySpecifier `protobuf_oneof:"policy_specifier"`
	// terminal
	//
	// x-displayName: "Terminal"
	// x-example: true
	// Specify if its a terminal policy
	Terminal bool `protobuf:"varint,4,opt,name=terminal,proto3" json:"terminal,omitempty"`
}

func (m *HashPolicyType) Reset()      { *m = HashPolicyType{} }
func (*HashPolicyType) ProtoMessage() {}
func (*HashPolicyType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{5}
}
func (m *HashPolicyType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HashPolicyType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HashPolicyType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HashPolicyType.Merge(m, src)
}
func (m *HashPolicyType) XXX_Size() int {
	return m.Size()
}
func (m *HashPolicyType) XXX_DiscardUnknown() {
	xxx_messageInfo_HashPolicyType.DiscardUnknown(m)
}

var xxx_messageInfo_HashPolicyType proto.InternalMessageInfo

type isHashPolicyType_PolicySpecifier interface {
	isHashPolicyType_PolicySpecifier()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type HashPolicyType_HeaderName struct {
	HeaderName string `protobuf:"bytes,1,opt,name=header_name,json=headerName,proto3,oneof" json:"header_name,omitempty"`
}
type HashPolicyType_Cookie struct {
	Cookie *CookieForHashing `protobuf:"bytes,2,opt,name=cookie,proto3,oneof" json:"cookie,omitempty"`
}
type HashPolicyType_SourceIp struct {
	SourceIp bool `protobuf:"varint,3,opt,name=source_ip,json=sourceIp,proto3,oneof" json:"source_ip,omitempty"`
}

func (*HashPolicyType_HeaderName) isHashPolicyType_PolicySpecifier() {}
func (*HashPolicyType_Cookie) isHashPolicyType_PolicySpecifier()     {}
func (*HashPolicyType_SourceIp) isHashPolicyType_PolicySpecifier()   {}

func (m *HashPolicyType) GetPolicySpecifier() isHashPolicyType_PolicySpecifier {
	if m != nil {
		return m.PolicySpecifier
	}
	return nil
}

func (m *HashPolicyType) GetHeaderName() string {
	if x, ok := m.GetPolicySpecifier().(*HashPolicyType_HeaderName); ok {
		return x.HeaderName
	}
	return ""
}

func (m *HashPolicyType) GetCookie() *CookieForHashing {
	if x, ok := m.GetPolicySpecifier().(*HashPolicyType_Cookie); ok {
		return x.Cookie
	}
	return nil
}

func (m *HashPolicyType) GetSourceIp() bool {
	if x, ok := m.GetPolicySpecifier().(*HashPolicyType_SourceIp); ok {
		return x.SourceIp
	}
	return false
}

func (m *HashPolicyType) GetTerminal() bool {
	if m != nil {
		return m.Terminal
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*HashPolicyType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*HashPolicyType_HeaderName)(nil),
		(*HashPolicyType_Cookie)(nil),
		(*HashPolicyType_SourceIp)(nil),
	}
}

// RouteDestinationList
//
// x-displayName: "Destination List"
// List of destination to choose if the route is match.
type RouteDestinationList struct {
	// destinations
	//
	// x-displayName: "Destination Origin pools (clusters)"
	// x-required
	// When requests have to distributed among multiple upstream clusters,
	// multiple destinations are configured, each having its own cluster and weight.
	// Traffic is distributed among clusters based on the weight configured.
	//
	// Example:
	//    destinations:
	//    - cluster:
	//      - kind: ves.io.vega.cfg.adc.cluster.Object
	//        uid: cluster-1
	//     weight: 20
	//   - cluster:
	//     - kind: ves.io.vega.cfg.adc.cluster.Object
	//       uid: cluster-2
	//     weight: 30
	//   - cluster:
	//     - kind: ves.io.vega.cfg.adc.cluster.Object
	//       uid: cluster-3
	//     weight: 50
	//
	// This indicates that out of every 100 requests, 50 goes to cluster-3, 30 to
	// cluster-2 and 20 to cluster-1
	//
	// When single destination is configured, weight is ignored. All the requests are
	// sent to the cluster specified in the destination
	Destinations []*RouteDestination `protobuf:"bytes,1,rep,name=destinations,proto3" json:"destinations,omitempty"`
	// prefix_rewrite
	//
	// x-displayName: "Prefix Rewrite"
	// x-example: "/"
	// prefix_rewrite indicates that during forwarding, the matched prefix (or path) should be swapped
	// with its value. When using regex path matching, the entire path (not including
	// the query string) will be swapped with this value. This option allows application
	// URLs to be rooted at a different path from those exposed at the reverse proxy layer.
	//
	// Example :
	//   gcSpec:
	//     routes:
	//     - match:
	//       - headers: []
	//         path:
	//           prefix : /register/
	//         query_params: []
	//       - headers: []
	//          path:
	//           prefix: /register
	//         query_params: []
	//       routeDestination:
	//         prefixRewrite: "/"
	//         destinations:
	//         - cluster:
	//           - kind: cluster.Object
	//             uid: cluster-1
	//
	// Having above entries in the config, requests to /register will be stripped to /,
	// while requests to /register/public will be stripped to /public
	PrefixRewrite string `protobuf:"bytes,5,opt,name=prefix_rewrite,json=prefixRewrite,proto3" json:"prefix_rewrite,omitempty"`
	// HostRewriteParams
	//
	// x-displayName: "Host Rewrite"
	// x-required
	// Specifies how the host header can be modified during forwarding
	//
	// Types that are valid to be assigned to HostRewriteParams:
	//	*RouteDestinationList_HostRewrite
	//	*RouteDestinationList_AutoHostRewrite
	HostRewriteParams isRouteDestinationList_HostRewriteParams `protobuf_oneof:"host_rewrite_params"`
	// timeout
	//
	// x-displayName: "Timeout"
	// x-example: 2000
	// Specifies the timeout for the route in milliseconds.
	// This timeout includes all retries.
	// For server side streaming, configure this field with higher value or leave it un-configured
	// for infinite timeout
	Timeout uint32 `protobuf:"varint,8,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// retry_policy
	//
	// x-displayName: "Retry Policy"
	// Indicates that the route has a retry policy.
	RetryPolicy *schema.RetryPolicyType `protobuf:"bytes,9,opt,name=retry_policy,json=retryPolicy,proto3" json:"retry_policy,omitempty"`
	// endpoint_subsets
	//
	// x-displayName: "Endpoint Subsets"
	// Upstream cluster may be configured to divide its endpoints into subsets based on metadata
	// attached to the endpoints. Routes may then specify the metadata that a endpoint must match in
	// order to be selected by the load balancer
	//
	// Labels field of endpoint object's metadata is used for subset matching.
	// For endpoint's which are discovered in K8S or Consul cluster, the label of the service is merged with
	// endpoint's labels. In case of Consul, the label is derived from the "Tag" field.
	// For labels that are common between configured endpoint and discovered service, labels from discovered service
	// takes precedence.
	//
	// List of key-value pairs that will be used as matching metadata. Only those endpoints of
	// upstream cluster which match this metadata will be selected for load balancing
	EndpointSubsets map[string]string `protobuf:"bytes,10,rep,name=endpoint_subsets,json=endpointSubsets,proto3" json:"endpoint_subsets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// mirror_policy
	//
	// x-displayName: "Mirror Policy"
	// MirrorPolicy is used for shadowing traffic from one cluster to another. The current
	// implementation is "fire and forget," meaning it will not wait for the shadow cluster to
	// respond before returning the response from the primary cluster. All normal statistics are
	// collected for the shadow cluster making this feature useful for testing.
	//
	// During shadowing, the host/authority header is altered such that *-shadow* is appended. This is
	// useful for logging. For example, *cluster1* becomes *cluster1-shadow*.
	MirrorPolicy *MirrorPolicyType `protobuf:"bytes,11,opt,name=mirror_policy,json=mirrorPolicy,proto3" json:"mirror_policy,omitempty"`
	// web_socket_config
	//
	// x-displayName: "Websocket Configuration"
	// Websocket configuration for each route
	WebSocketConfig *WebsocketConfigType `protobuf:"bytes,13,opt,name=web_socket_config,json=webSocketConfig,proto3" json:"web_socket_config,omitempty"`
	// buffer_policy
	//
	// x-displayName: "Buffer Policy"
	// Buffering configuration for requests
	// Some upstream applications are not capable of handling streamed data. This config
	// enables buffering the entire request before sending to upstream application. We can
	// specify the maximum buffer size and buffer interval with this config.
	// Route level buffer configuration overrides any configuration at VirtualHost level.
	BufferPolicy *schema.BufferConfigType `protobuf:"bytes,14,opt,name=buffer_policy,json=bufferPolicy,proto3" json:"buffer_policy,omitempty"`
	// cors_policy
	//
	// x-displayName: "CORS Policy"
	// Cross-Origin Resource Sharing requests configuration
	//
	// CORS is a mechanism that uses additional HTTP headers to tell a browser to let
	// a web application running at one origin (domain) have permission to access selected
	// resources from a server at a different origin
	CorsPolicy *schema.CorsPolicy `protobuf:"bytes,15,opt,name=cors_policy,json=corsPolicy,proto3" json:"cors_policy,omitempty"`
	// hash_policy
	//
	// x-displayName: "Hash Policy"
	// Specifies a list of hash policies to use for ring hash load balancing. Each
	// hash policy is evaluated individually and the combined result is used to
	// route the request
	HashPolicy []*HashPolicyType `protobuf:"bytes,16,rep,name=hash_policy,json=hashPolicy,proto3" json:"hash_policy,omitempty"`
	// priority
	//
	// x-displayName: "Priority"
	// Priority routing for each route. Different connection pools are used based on the priority of the route.
	// Also, circuit-breaker configuration at destination cluster is chosen based on the route priority.
	Priority schema.RoutingPriority `protobuf:"varint,18,opt,name=priority,proto3,enum=ves.io.schema.RoutingPriority" json:"priority,omitempty"`
	// spdy_config
	//
	// x-displayName: "SPDY Configuration"
	// SPDY configuration for each route
	SpdyConfig *SpdyConfigType `protobuf:"bytes,19,opt,name=spdy_config,json=spdyConfig,proto3" json:"spdy_config,omitempty"`
	// Oneof for Cluster retraction
	//
	// x-displayName: "Select Cluster retract option"
	// Specifies whether retraction of cluster has to be enabled or
	// disabled
	//
	// Types that are valid to be assigned to ClusterRetractChoice:
	//	*RouteDestinationList_RetractCluster
	//	*RouteDestinationList_DoNotRetractCluster
	ClusterRetractChoice isRouteDestinationList_ClusterRetractChoice `protobuf_oneof:"cluster_retract_choice"`
}

func (m *RouteDestinationList) Reset()      { *m = RouteDestinationList{} }
func (*RouteDestinationList) ProtoMessage() {}
func (*RouteDestinationList) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{6}
}
func (m *RouteDestinationList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteDestinationList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteDestinationList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteDestinationList.Merge(m, src)
}
func (m *RouteDestinationList) XXX_Size() int {
	return m.Size()
}
func (m *RouteDestinationList) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteDestinationList.DiscardUnknown(m)
}

var xxx_messageInfo_RouteDestinationList proto.InternalMessageInfo

type isRouteDestinationList_HostRewriteParams interface {
	isRouteDestinationList_HostRewriteParams()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isRouteDestinationList_ClusterRetractChoice interface {
	isRouteDestinationList_ClusterRetractChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type RouteDestinationList_HostRewrite struct {
	HostRewrite string `protobuf:"bytes,6,opt,name=host_rewrite,json=hostRewrite,proto3,oneof" json:"host_rewrite,omitempty"`
}
type RouteDestinationList_AutoHostRewrite struct {
	AutoHostRewrite bool `protobuf:"varint,7,opt,name=auto_host_rewrite,json=autoHostRewrite,proto3,oneof" json:"auto_host_rewrite,omitempty"`
}
type RouteDestinationList_RetractCluster struct {
	RetractCluster *schema.Empty `protobuf:"bytes,21,opt,name=retract_cluster,json=retractCluster,proto3,oneof" json:"retract_cluster,omitempty"`
}
type RouteDestinationList_DoNotRetractCluster struct {
	DoNotRetractCluster *schema.Empty `protobuf:"bytes,22,opt,name=do_not_retract_cluster,json=doNotRetractCluster,proto3,oneof" json:"do_not_retract_cluster,omitempty"`
}

func (*RouteDestinationList_HostRewrite) isRouteDestinationList_HostRewriteParams()            {}
func (*RouteDestinationList_AutoHostRewrite) isRouteDestinationList_HostRewriteParams()        {}
func (*RouteDestinationList_RetractCluster) isRouteDestinationList_ClusterRetractChoice()      {}
func (*RouteDestinationList_DoNotRetractCluster) isRouteDestinationList_ClusterRetractChoice() {}

func (m *RouteDestinationList) GetHostRewriteParams() isRouteDestinationList_HostRewriteParams {
	if m != nil {
		return m.HostRewriteParams
	}
	return nil
}
func (m *RouteDestinationList) GetClusterRetractChoice() isRouteDestinationList_ClusterRetractChoice {
	if m != nil {
		return m.ClusterRetractChoice
	}
	return nil
}

func (m *RouteDestinationList) GetDestinations() []*RouteDestination {
	if m != nil {
		return m.Destinations
	}
	return nil
}

func (m *RouteDestinationList) GetPrefixRewrite() string {
	if m != nil {
		return m.PrefixRewrite
	}
	return ""
}

func (m *RouteDestinationList) GetHostRewrite() string {
	if x, ok := m.GetHostRewriteParams().(*RouteDestinationList_HostRewrite); ok {
		return x.HostRewrite
	}
	return ""
}

func (m *RouteDestinationList) GetAutoHostRewrite() bool {
	if x, ok := m.GetHostRewriteParams().(*RouteDestinationList_AutoHostRewrite); ok {
		return x.AutoHostRewrite
	}
	return false
}

func (m *RouteDestinationList) GetTimeout() uint32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *RouteDestinationList) GetRetryPolicy() *schema.RetryPolicyType {
	if m != nil {
		return m.RetryPolicy
	}
	return nil
}

func (m *RouteDestinationList) GetEndpointSubsets() map[string]string {
	if m != nil {
		return m.EndpointSubsets
	}
	return nil
}

func (m *RouteDestinationList) GetMirrorPolicy() *MirrorPolicyType {
	if m != nil {
		return m.MirrorPolicy
	}
	return nil
}

func (m *RouteDestinationList) GetWebSocketConfig() *WebsocketConfigType {
	if m != nil {
		return m.WebSocketConfig
	}
	return nil
}

func (m *RouteDestinationList) GetBufferPolicy() *schema.BufferConfigType {
	if m != nil {
		return m.BufferPolicy
	}
	return nil
}

func (m *RouteDestinationList) GetCorsPolicy() *schema.CorsPolicy {
	if m != nil {
		return m.CorsPolicy
	}
	return nil
}

func (m *RouteDestinationList) GetHashPolicy() []*HashPolicyType {
	if m != nil {
		return m.HashPolicy
	}
	return nil
}

func (m *RouteDestinationList) GetPriority() schema.RoutingPriority {
	if m != nil {
		return m.Priority
	}
	return schema.DEFAULT
}

func (m *RouteDestinationList) GetSpdyConfig() *SpdyConfigType {
	if m != nil {
		return m.SpdyConfig
	}
	return nil
}

func (m *RouteDestinationList) GetRetractCluster() *schema.Empty {
	if x, ok := m.GetClusterRetractChoice().(*RouteDestinationList_RetractCluster); ok {
		return x.RetractCluster
	}
	return nil
}

func (m *RouteDestinationList) GetDoNotRetractCluster() *schema.Empty {
	if x, ok := m.GetClusterRetractChoice().(*RouteDestinationList_DoNotRetractCluster); ok {
		return x.DoNotRetractCluster
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RouteDestinationList) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RouteDestinationList_HostRewrite)(nil),
		(*RouteDestinationList_AutoHostRewrite)(nil),
		(*RouteDestinationList_RetractCluster)(nil),
		(*RouteDestinationList_DoNotRetractCluster)(nil),
	}
}

// RouteQueryParams
//
// x-displayName: "Query Parameters"
// Query params keys to strip while manipulating the HTTP request
type RouteQueryParams struct {
	// query_params
	//
	// x-displayName: "Query Parameters"
	// x-example: "userid"
	// Query params keys to strip while manipulating the HTTP request
	QueryParams []string `protobuf:"bytes,1,rep,name=query_params,json=queryParams,proto3" json:"query_params,omitempty"`
}

func (m *RouteQueryParams) Reset()      { *m = RouteQueryParams{} }
func (*RouteQueryParams) ProtoMessage() {}
func (*RouteQueryParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{7}
}
func (m *RouteQueryParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteQueryParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteQueryParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteQueryParams.Merge(m, src)
}
func (m *RouteQueryParams) XXX_Size() int {
	return m.Size()
}
func (m *RouteQueryParams) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteQueryParams.DiscardUnknown(m)
}

var xxx_messageInfo_RouteQueryParams proto.InternalMessageInfo

func (m *RouteQueryParams) GetQueryParams() []string {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

// RouteRedirect
//
// x-displayName: "Redirect"
// route redirect parameters when match action is redirect.
type RouteRedirect struct {
	// host_redirect
	//
	// x-displayName: "Host"
	// x-example: "one.ves.io"
	// swap host part of incoming URL in redirect URL
	HostRedirect string `protobuf:"bytes,1,opt,name=host_redirect,json=hostRedirect,proto3" json:"host_redirect,omitempty"`
	// path_redirect
	//
	// x-displayName: "Path"
	// x-example: "/api/register"
	// swap path part of incoming URL in redirect URL
	PathRedirect string `protobuf:"bytes,2,opt,name=path_redirect,json=pathRedirect,proto3" json:"path_redirect,omitempty"`
	// proto_redirect
	//
	// x-displayName: "Protocol"
	// x-example: "https"
	// swap protocol part of incoming URL in redirect URL
	// The protocol can be swapped with either http or https
	// When incoming-proto option is specified, swapping of protocol is not done.
	ProtoRedirect string `protobuf:"bytes,3,opt,name=proto_redirect,json=protoRedirect,proto3" json:"proto_redirect,omitempty"`
	// query_params
	//
	// x-displayName: "Query Parameters"
	// handling of incoming query parameters in redirect request.
	//
	// Types that are valid to be assigned to QueryParams:
	//	*RouteRedirect_StripQueryParams
	//	*RouteRedirect_AllParams
	//	*RouteRedirect_RetainAllParams
	//	*RouteRedirect_RemoveAllParams
	QueryParams isRouteRedirect_QueryParams `protobuf_oneof:"query_params"`
	// response_code
	//
	// x-displayName: "Response Code"
	// x-example: 303
	// The HTTP status code to use in the redirect response. The default response
	// code is MOVED_PERMANENTLY (301).
	ResponseCode uint32 `protobuf:"varint,6,opt,name=response_code,json=responseCode,proto3" json:"response_code,omitempty"`
}

func (m *RouteRedirect) Reset()      { *m = RouteRedirect{} }
func (*RouteRedirect) ProtoMessage() {}
func (*RouteRedirect) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{8}
}
func (m *RouteRedirect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteRedirect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteRedirect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteRedirect.Merge(m, src)
}
func (m *RouteRedirect) XXX_Size() int {
	return m.Size()
}
func (m *RouteRedirect) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteRedirect.DiscardUnknown(m)
}

var xxx_messageInfo_RouteRedirect proto.InternalMessageInfo

type isRouteRedirect_QueryParams interface {
	isRouteRedirect_QueryParams()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type RouteRedirect_StripQueryParams struct {
	StripQueryParams *RouteQueryParams `protobuf:"bytes,4,opt,name=strip_query_params,json=stripQueryParams,proto3,oneof" json:"strip_query_params,omitempty"`
}
type RouteRedirect_AllParams struct {
	AllParams bool `protobuf:"varint,5,opt,name=all_params,json=allParams,proto3,oneof" json:"all_params,omitempty"`
}
type RouteRedirect_RetainAllParams struct {
	RetainAllParams *schema.Empty `protobuf:"bytes,8,opt,name=retain_all_params,json=retainAllParams,proto3,oneof" json:"retain_all_params,omitempty"`
}
type RouteRedirect_RemoveAllParams struct {
	RemoveAllParams *schema.Empty `protobuf:"bytes,9,opt,name=remove_all_params,json=removeAllParams,proto3,oneof" json:"remove_all_params,omitempty"`
}

func (*RouteRedirect_StripQueryParams) isRouteRedirect_QueryParams() {}
func (*RouteRedirect_AllParams) isRouteRedirect_QueryParams()        {}
func (*RouteRedirect_RetainAllParams) isRouteRedirect_QueryParams()  {}
func (*RouteRedirect_RemoveAllParams) isRouteRedirect_QueryParams()  {}

func (m *RouteRedirect) GetQueryParams() isRouteRedirect_QueryParams {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

func (m *RouteRedirect) GetHostRedirect() string {
	if m != nil {
		return m.HostRedirect
	}
	return ""
}

func (m *RouteRedirect) GetPathRedirect() string {
	if m != nil {
		return m.PathRedirect
	}
	return ""
}

func (m *RouteRedirect) GetProtoRedirect() string {
	if m != nil {
		return m.ProtoRedirect
	}
	return ""
}

func (m *RouteRedirect) GetStripQueryParams() *RouteQueryParams {
	if x, ok := m.GetQueryParams().(*RouteRedirect_StripQueryParams); ok {
		return x.StripQueryParams
	}
	return nil
}

func (m *RouteRedirect) GetAllParams() bool {
	if x, ok := m.GetQueryParams().(*RouteRedirect_AllParams); ok {
		return x.AllParams
	}
	return false
}

func (m *RouteRedirect) GetRetainAllParams() *schema.Empty {
	if x, ok := m.GetQueryParams().(*RouteRedirect_RetainAllParams); ok {
		return x.RetainAllParams
	}
	return nil
}

func (m *RouteRedirect) GetRemoveAllParams() *schema.Empty {
	if x, ok := m.GetQueryParams().(*RouteRedirect_RemoveAllParams); ok {
		return x.RemoveAllParams
	}
	return nil
}

func (m *RouteRedirect) GetResponseCode() uint32 {
	if m != nil {
		return m.ResponseCode
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RouteRedirect) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RouteRedirect_StripQueryParams)(nil),
		(*RouteRedirect_AllParams)(nil),
		(*RouteRedirect_RetainAllParams)(nil),
		(*RouteRedirect_RemoveAllParams)(nil),
	}
}

// RouteDirectResponse
//
// x-displayName: "Direct Response"
// Send this direct response in case of route match action is direct response
type RouteDirectResponse struct {
	// response_code
	//
	// x-displayName: "Response Code"
	// x-example: 200
	// response code to send
	ResponseCode uint32 `protobuf:"varint,1,opt,name=response_code,json=responseCode,proto3" json:"response_code,omitempty"`
	// response_body
	//
	// x-displayName: "Response Body"
	// x-example: "OK"
	// response body to send
	ResponseBody string `protobuf:"bytes,2,opt,name=response_body,json=responseBody,proto3" json:"response_body,omitempty"`
}

func (m *RouteDirectResponse) Reset()      { *m = RouteDirectResponse{} }
func (*RouteDirectResponse) ProtoMessage() {}
func (*RouteDirectResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{9}
}
func (m *RouteDirectResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteDirectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteDirectResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteDirectResponse.Merge(m, src)
}
func (m *RouteDirectResponse) XXX_Size() int {
	return m.Size()
}
func (m *RouteDirectResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteDirectResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RouteDirectResponse proto.InternalMessageInfo

func (m *RouteDirectResponse) GetResponseCode() uint32 {
	if m != nil {
		return m.ResponseCode
	}
	return 0
}

func (m *RouteDirectResponse) GetResponseBody() string {
	if m != nil {
		return m.ResponseBody
	}
	return ""
}

// ServicePolicyInfo
//
// x-displayName: "Disable Service Policy"
// ServicePolicy configuration details at route level
type ServicePolicyInfo struct {
	// disable
	//
	// x-displayName: "Disable"
	// x-example: true
	// disable service policy at route level, if it is configured at virtual-host level
	Disable bool `protobuf:"varint,1,opt,name=disable,proto3" json:"disable,omitempty"`
}

func (m *ServicePolicyInfo) Reset()      { *m = ServicePolicyInfo{} }
func (*ServicePolicyInfo) ProtoMessage() {}
func (*ServicePolicyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{10}
}
func (m *ServicePolicyInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServicePolicyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ServicePolicyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServicePolicyInfo.Merge(m, src)
}
func (m *ServicePolicyInfo) XXX_Size() int {
	return m.Size()
}
func (m *ServicePolicyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ServicePolicyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ServicePolicyInfo proto.InternalMessageInfo

func (m *ServicePolicyInfo) GetDisable() bool {
	if m != nil {
		return m.Disable
	}
	return false
}

// RouteType
//
// x-displayName: "Route"
// Each RouteType is a rule which has match condition and action. When the condition is
// matched for incoming request, the specified action is taken.
type RouteType struct {
	// match
	//
	// x-displayName: "Match"
	// route match condition
	Match []*schema.RouteMatch `protobuf:"bytes,1,rep,name=match,proto3" json:"match,omitempty"`
	// route_action
	//
	// x-displayName: "Action"
	// x-required
	// one of action to take when match is successful
	//
	// Types that are valid to be assigned to RouteAction:
	//	*RouteType_RouteDestination
	//	*RouteType_RouteRedirect
	//	*RouteType_RouteDirectResponse
	RouteAction isRouteType_RouteAction `protobuf_oneof:"route_action"`
	// disable_custom_script
	//
	// x-displayName: "Disable Custom Script"
	// x-example: true
	// disable execution of Javascript at route level, if it is configured at virtual-host level
	DisableCustomScript bool `protobuf:"varint,5,opt,name=disable_custom_script,json=disableCustomScript,proto3" json:"disable_custom_script,omitempty"`
	// service_policy
	//
	// x-displayName: "Service Policy"
	// service policy configuration at route level which overrides configuration at virtual-host level
	ServicePolicy *ServicePolicyInfo `protobuf:"bytes,12,opt,name=service_policy,json=servicePolicy,proto3" json:"service_policy,omitempty"`
	// Headers to add in request
	//
	// x-displayName: "Request Headers to Add"
	// Headers are key-value pairs to be added to HTTP requests being sent towards upstream.
	// Headers specified at this level are applied before headers from the
	// enclosing VirtualHost object level
	RequestHeadersToAdd []*schema.HeaderManipulationOptionType `protobuf:"bytes,7,rep,name=request_headers_to_add,json=requestHeadersToAdd,proto3" json:"request_headers_to_add,omitempty"`
	// Headers to add in response
	//
	// x-displayName: "Response Headers to Add"
	// Headers are key-value pairs to be added to HTTP response being sent towards downstream.
	// Headers specified at this level are applied before headers from the
	// enclosing VirtualHost object level
	ResponseHeadersToAdd []*schema.HeaderManipulationOptionType `protobuf:"bytes,8,rep,name=response_headers_to_add,json=responseHeadersToAdd,proto3" json:"response_headers_to_add,omitempty"`
	// Header to be removed from request
	//
	// x-displayName: "Request Headers to Remove"
	// x-example: "host"
	// List of keys of Headers to be removed from the HTTP request being sent towards upstream.
	RequestHeadersToRemove []string `protobuf:"bytes,9,rep,name=request_headers_to_remove,json=requestHeadersToRemove,proto3" json:"request_headers_to_remove,omitempty"`
	// Header to be removed from response
	//
	// x-displayName: "Response Headers to Remove"
	// x-example: "host"
	// List of keys of Headers to be removed from the HTTP response being sent towards downstream.
	ResponseHeadersToRemove []string `protobuf:"bytes,10,rep,name=response_headers_to_remove,json=responseHeadersToRemove,proto3" json:"response_headers_to_remove,omitempty"`
	// Enable the WAF (Web Application Firewall) functionality for Route
	//
	// x-displayName: "WAF"
	// WAF can be used to analyze inbound and outbound http/https traffic.
	// WAF can be configured either in BLOCKing Mode or ALERTing Mode.
	// In BLOCKing mode if WAF detects suspicious inbound/outbound traffic it blocks the request or response.
	// In ALERTing mode if suspicious traffic is detected, WAF generates ALERTs with details on the
	// suspicious traffic (instead of blocking traffic).
	//
	// waf_type can be either WAF or WAFRules.
	// WAF Object allows to
	//     Configure mode of the WAF (BLOCK/ALERT)
	//     Configure language used by the application which is being protected by the WAF
	//     Disable different high level security tags if required (e.g. SQLI_DETECTION, XSS_DETECTION etc)
	// WAFRules allows to
	//     Configure mode of the WAF (BLOCK/ALERT)
	//     Enable/Disable individual WAF security rules
	//
	// waf_type specified at route level overrides waf configuration at VirtualHost level
	WafType *schema.WafType `protobuf:"bytes,11,opt,name=waf_type,json=wafType,proto3" json:"waf_type,omitempty"`
	// disable_location_add
	//
	// x-displayName: "Disable Location Addition"
	// x-example: true
	// disables append of x-volterra-location = <re-site-name> at route level, if it is configured at
	// virtual-host level. This configuration is ignored on CE sites.
	DisableLocationAdd bool `protobuf:"varint,13,opt,name=disable_location_add,json=disableLocationAdd,proto3" json:"disable_location_add,omitempty"`
}

func (m *RouteType) Reset()      { *m = RouteType{} }
func (*RouteType) ProtoMessage() {}
func (*RouteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{11}
}
func (m *RouteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteType.Merge(m, src)
}
func (m *RouteType) XXX_Size() int {
	return m.Size()
}
func (m *RouteType) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteType.DiscardUnknown(m)
}

var xxx_messageInfo_RouteType proto.InternalMessageInfo

type isRouteType_RouteAction interface {
	isRouteType_RouteAction()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type RouteType_RouteDestination struct {
	RouteDestination *RouteDestinationList `protobuf:"bytes,2,opt,name=route_destination,json=routeDestination,proto3,oneof" json:"route_destination,omitempty"`
}
type RouteType_RouteRedirect struct {
	RouteRedirect *RouteRedirect `protobuf:"bytes,3,opt,name=route_redirect,json=routeRedirect,proto3,oneof" json:"route_redirect,omitempty"`
}
type RouteType_RouteDirectResponse struct {
	RouteDirectResponse *RouteDirectResponse `protobuf:"bytes,4,opt,name=route_direct_response,json=routeDirectResponse,proto3,oneof" json:"route_direct_response,omitempty"`
}

func (*RouteType_RouteDestination) isRouteType_RouteAction()    {}
func (*RouteType_RouteRedirect) isRouteType_RouteAction()       {}
func (*RouteType_RouteDirectResponse) isRouteType_RouteAction() {}

func (m *RouteType) GetRouteAction() isRouteType_RouteAction {
	if m != nil {
		return m.RouteAction
	}
	return nil
}

func (m *RouteType) GetMatch() []*schema.RouteMatch {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *RouteType) GetRouteDestination() *RouteDestinationList {
	if x, ok := m.GetRouteAction().(*RouteType_RouteDestination); ok {
		return x.RouteDestination
	}
	return nil
}

func (m *RouteType) GetRouteRedirect() *RouteRedirect {
	if x, ok := m.GetRouteAction().(*RouteType_RouteRedirect); ok {
		return x.RouteRedirect
	}
	return nil
}

func (m *RouteType) GetRouteDirectResponse() *RouteDirectResponse {
	if x, ok := m.GetRouteAction().(*RouteType_RouteDirectResponse); ok {
		return x.RouteDirectResponse
	}
	return nil
}

func (m *RouteType) GetDisableCustomScript() bool {
	if m != nil {
		return m.DisableCustomScript
	}
	return false
}

func (m *RouteType) GetServicePolicy() *ServicePolicyInfo {
	if m != nil {
		return m.ServicePolicy
	}
	return nil
}

func (m *RouteType) GetRequestHeadersToAdd() []*schema.HeaderManipulationOptionType {
	if m != nil {
		return m.RequestHeadersToAdd
	}
	return nil
}

func (m *RouteType) GetResponseHeadersToAdd() []*schema.HeaderManipulationOptionType {
	if m != nil {
		return m.ResponseHeadersToAdd
	}
	return nil
}

func (m *RouteType) GetRequestHeadersToRemove() []string {
	if m != nil {
		return m.RequestHeadersToRemove
	}
	return nil
}

func (m *RouteType) GetResponseHeadersToRemove() []string {
	if m != nil {
		return m.ResponseHeadersToRemove
	}
	return nil
}

func (m *RouteType) GetWafType() *schema.WafType {
	if m != nil {
		return m.WafType
	}
	return nil
}

func (m *RouteType) GetDisableLocationAdd() bool {
	if m != nil {
		return m.DisableLocationAdd
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RouteType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RouteType_RouteDestination)(nil),
		(*RouteType_RouteRedirect)(nil),
		(*RouteType_RouteDirectResponse)(nil),
	}
}

// GlobalSpecType
//
// x-displayName: "Global Configuration Specification"
// Route object configuration
type GlobalSpecType struct {
	// routes
	//
	// x-displayName: "Routes"
	// x-required
	// List of routes to match for incoming request
	Routes []*RouteType `protobuf:"bytes,1,rep,name=routes,proto3" json:"routes,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{12}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

func (m *GlobalSpecType) GetRoutes() []*RouteType {
	if m != nil {
		return m.Routes
	}
	return nil
}

// CreateSpecType
//
// x-displayName: "Create Route"
// Create route object in a given namespace. Route object is list of route rules.
// Each rule has match condition to match incoming requests and actions to take on matching requests.
// Virtual host object has reference to route object
type CreateSpecType struct {
	Routes []*RouteType `protobuf:"bytes,1,rep,name=routes,proto3" json:"routes,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{13}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

func (m *CreateSpecType) GetRoutes() []*RouteType {
	if m != nil {
		return m.Routes
	}
	return nil
}

// ReplaceSpecType
//
// x-displayName: "Replace Route"
// Replace route object in a given namespace. Route object is list of route rules.
// Each rule has match condition to match incoming requests and actions to take on matching requests.
// Virtual host object has reference to route object
type ReplaceSpecType struct {
	Routes []*RouteType `protobuf:"bytes,1,rep,name=routes,proto3" json:"routes,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{14}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

func (m *ReplaceSpecType) GetRoutes() []*RouteType {
	if m != nil {
		return m.Routes
	}
	return nil
}

// GetSpecType
//
// x-displayName: "Get Route"
// Get route object in a given namespace. Route object is list of route rules.
// Each rule has match condition to match incoming requests and actions to take on matching requests.
// Virtual host object has reference to route object
type GetSpecType struct {
	Routes []*RouteType `protobuf:"bytes,1,rep,name=routes,proto3" json:"routes,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8d3aa2b5dcc5c84, []int{15}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

func (m *GetSpecType) GetRoutes() []*RouteType {
	if m != nil {
		return m.Routes
	}
	return nil
}

func init() {
	proto.RegisterType((*RouteDestination)(nil), "ves.io.schema.route.RouteDestination")
	golang_proto.RegisterType((*RouteDestination)(nil), "ves.io.schema.route.RouteDestination")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.route.RouteDestination.EndpointSubsetsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.route.RouteDestination.EndpointSubsetsEntry")
	proto.RegisterType((*MirrorPolicyType)(nil), "ves.io.schema.route.MirrorPolicyType")
	golang_proto.RegisterType((*MirrorPolicyType)(nil), "ves.io.schema.route.MirrorPolicyType")
	proto.RegisterType((*SpdyConfigType)(nil), "ves.io.schema.route.SpdyConfigType")
	golang_proto.RegisterType((*SpdyConfigType)(nil), "ves.io.schema.route.SpdyConfigType")
	proto.RegisterType((*WebsocketConfigType)(nil), "ves.io.schema.route.WebsocketConfigType")
	golang_proto.RegisterType((*WebsocketConfigType)(nil), "ves.io.schema.route.WebsocketConfigType")
	proto.RegisterType((*CookieForHashing)(nil), "ves.io.schema.route.CookieForHashing")
	golang_proto.RegisterType((*CookieForHashing)(nil), "ves.io.schema.route.CookieForHashing")
	proto.RegisterType((*HashPolicyType)(nil), "ves.io.schema.route.HashPolicyType")
	golang_proto.RegisterType((*HashPolicyType)(nil), "ves.io.schema.route.HashPolicyType")
	proto.RegisterType((*RouteDestinationList)(nil), "ves.io.schema.route.RouteDestinationList")
	golang_proto.RegisterType((*RouteDestinationList)(nil), "ves.io.schema.route.RouteDestinationList")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.route.RouteDestinationList.EndpointSubsetsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.route.RouteDestinationList.EndpointSubsetsEntry")
	proto.RegisterType((*RouteQueryParams)(nil), "ves.io.schema.route.RouteQueryParams")
	golang_proto.RegisterType((*RouteQueryParams)(nil), "ves.io.schema.route.RouteQueryParams")
	proto.RegisterType((*RouteRedirect)(nil), "ves.io.schema.route.RouteRedirect")
	golang_proto.RegisterType((*RouteRedirect)(nil), "ves.io.schema.route.RouteRedirect")
	proto.RegisterType((*RouteDirectResponse)(nil), "ves.io.schema.route.RouteDirectResponse")
	golang_proto.RegisterType((*RouteDirectResponse)(nil), "ves.io.schema.route.RouteDirectResponse")
	proto.RegisterType((*ServicePolicyInfo)(nil), "ves.io.schema.route.ServicePolicyInfo")
	golang_proto.RegisterType((*ServicePolicyInfo)(nil), "ves.io.schema.route.ServicePolicyInfo")
	proto.RegisterType((*RouteType)(nil), "ves.io.schema.route.RouteType")
	golang_proto.RegisterType((*RouteType)(nil), "ves.io.schema.route.RouteType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.route.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.route.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.route.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.route.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.route.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.route.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.route.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.route.GetSpecType")
}

func init() { proto.RegisterFile("ves.io/schema/route/types.proto", fileDescriptor_d8d3aa2b5dcc5c84) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/route/types.proto", fileDescriptor_d8d3aa2b5dcc5c84)
}

var fileDescriptor_d8d3aa2b5dcc5c84 = []byte{
	// 2335 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xcd, 0x6f, 0x1b, 0xc7,
	0x15, 0xe7, 0x50, 0x4b, 0x71, 0xf9, 0x44, 0x52, 0xab, 0x91, 0x2c, 0xaf, 0x15, 0x87, 0x66, 0xe8,
	0x3a, 0x95, 0x93, 0xb5, 0x14, 0x52, 0x96, 0x3f, 0x54, 0xc0, 0x89, 0xa8, 0x3a, 0x51, 0x94, 0x0f,
	0xbb, 0xab, 0x00, 0x41, 0x53, 0x20, 0x8b, 0xe5, 0xee, 0x90, 0xdc, 0x9a, 0xe4, 0x6c, 0x76, 0x87,
	0x92, 0x79, 0x08, 0xe0, 0x43, 0x81, 0x14, 0x3d, 0x05, 0x39, 0x1a, 0xbd, 0xf4, 0x50, 0xa0, 0xed,
	0x9f, 0x50, 0x06, 0xa8, 0x61, 0xa0, 0x40, 0xd0, 0x93, 0x6e, 0xf1, 0x31, 0xa1, 0x2f, 0xe9, 0x2d,
	0xf0, 0xa9, 0xa7, 0xa2, 0xd8, 0x99, 0x59, 0x7e, 0x85, 0x71, 0x1d, 0x20, 0xb9, 0x10, 0xdc, 0x99,
	0xdf, 0xfb, 0xbd, 0x8f, 0x79, 0xf3, 0xde, 0xdb, 0x85, 0x73, 0x47, 0x24, 0xdc, 0xf0, 0xe8, 0x66,
	0xe8, 0x34, 0x49, 0xdb, 0xde, 0x0c, 0x68, 0x97, 0x91, 0x4d, 0xd6, 0xf3, 0x49, 0xb8, 0xe1, 0x07,
	0x94, 0x51, 0xbc, 0x2c, 0x00, 0x1b, 0x02, 0xb0, 0xc1, 0x01, 0x6b, 0x97, 0x1a, 0x1e, 0x6b, 0x76,
	0x6b, 0x1b, 0x0e, 0x6d, 0x6f, 0x36, 0x68, 0x83, 0x6e, 0x72, 0x6c, 0xad, 0x5b, 0xe7, 0x4f, 0xfc,
	0x81, 0xff, 0x13, 0x1c, 0x6b, 0xcf, 0x4d, 0x2a, 0xa1, 0x3e, 0xf3, 0x68, 0x47, 0x2a, 0x58, 0x3b,
	0x33, 0xb9, 0x39, 0xa6, 0x7b, 0xed, 0xec, 0xe4, 0xd6, 0x91, 0xdd, 0xf2, 0x5c, 0x9b, 0x11, 0xb9,
	0x5b, 0x9c, 0xda, 0xf5, 0xc8, 0xb1, 0x35, 0x41, 0x5d, 0xfa, 0x6f, 0x12, 0x34, 0x33, 0x32, 0xf8,
	0x97, 0x24, 0x64, 0x5e, 0xc7, 0x8e, 0xf6, 0xf0, 0xdb, 0x90, 0x76, 0x5a, 0xdd, 0x90, 0x91, 0x40,
	0x47, 0xc5, 0xb9, 0xf5, 0x85, 0xca, 0xd9, 0x8d, 0x49, 0x17, 0x6f, 0xd5, 0x7e, 0x4b, 0x1c, 0x66,
	0x92, 0xfa, 0x7b, 0x3d, 0x9f, 0x54, 0x57, 0xfe, 0xf6, 0x71, 0x8c, 0xff, 0xfb, 0xbf, 0x1f, 0xcc,
	0xa5, 0x3e, 0x43, 0x49, 0x0d, 0x99, 0xf1, 0x12, 0x3e, 0x0b, 0xf3, 0xc7, 0xc4, 0x6b, 0x34, 0x99,
	0x3e, 0x57, 0x44, 0xeb, 0xb9, 0xaa, 0xf2, 0x9f, 0x3e, 0x4a, 0x98, 0x72, 0x0d, 0xff, 0x1e, 0x81,
	0x46, 0x3a, 0xae, 0x4f, 0xbd, 0x0e, 0xb3, 0xc2, 0x6e, 0x2d, 0x24, 0x2c, 0xd4, 0x15, 0xae, 0x75,
	0x67, 0x63, 0x46, 0x60, 0x37, 0xa6, 0xad, 0xdd, 0xb8, 0x29, 0xa5, 0x0f, 0x85, 0xf0, 0xcd, 0x0e,
	0x0b, 0x7a, 0xd5, 0x17, 0x1e, 0xf4, 0x11, 0xba, 0xff, 0x39, 0x52, 0x20, 0x99, 0x40, 0xdc, 0xaa,
	0xfb, 0x28, 0xa9, 0x69, 0x83, 0xaf, 0xfe, 0x39, 0x37, 0xff, 0x87, 0xcf, 0x51, 0x52, 0x4d, 0x98,
	0x8b, 0x64, 0x52, 0x70, 0xad, 0x0a, 0x2b, 0xb3, 0xb8, 0xb0, 0x06, 0x73, 0x77, 0x48, 0x4f, 0x47,
	0x45, 0xb4, 0x9e, 0x31, 0xa3, 0xbf, 0x78, 0x05, 0x52, 0x47, 0x76, 0xab, 0x4b, 0xf4, 0x24, 0x5f,
	0x13, 0x0f, 0x3b, 0xc9, 0x6b, 0x68, 0xe7, 0xe2, 0x93, 0x1b, 0xa9, 0xb2, 0xb1, 0x65, 0x5c, 0x7e,
	0xd8, 0x47, 0xcf, 0xc3, 0x73, 0x80, 0xf7, 0x44, 0x14, 0x8a, 0x76, 0xc7, 0x2d, 0xbe, 0x2f, 0x5c,
	0x16, 0x80, 0x03, 0x45, 0x4d, 0x6a, 0x73, 0xa5, 0x3f, 0x22, 0xd0, 0xde, 0xf1, 0x82, 0x80, 0x06,
	0xb7, 0x69, 0xcb, 0x73, 0x7a, 0x51, 0x44, 0x7f, 0xe4, 0x03, 0xd8, 0x81, 0xb4, 0x4f, 0x02, 0x87,
	0x74, 0x18, 0xb7, 0x77, 0xa1, 0x52, 0x9c, 0x62, 0x7b, 0x3d, 0xb0, 0x9d, 0x28, 0x94, 0x76, 0xeb,
	0xb6, 0xc0, 0x99, 0xb1, 0x40, 0xe9, 0x65, 0xc8, 0x1f, 0xfa, 0x6e, 0x6f, 0x8f, 0x76, 0xea, 0x5e,
	0x83, 0xdb, 0x76, 0x06, 0xd4, 0x6e, 0x48, 0xac, 0xd0, 0x77, 0x45, 0x48, 0x54, 0x33, 0xdd, 0x0d,
	0x49, 0x04, 0x2a, 0xfd, 0x19, 0xc1, 0xf2, 0xfb, 0xa4, 0x16, 0x52, 0xe7, 0x0e, 0x61, 0x63, 0x22,
	0xe7, 0x21, 0x17, 0x89, 0x1c, 0xc7, 0x5b, 0x52, 0x2e, 0xdb, 0x0d, 0xc9, 0x10, 0x8e, 0x0d, 0xc8,
	0x7a, 0x6e, 0x8b, 0x58, 0xcc, 0x6b, 0x13, 0xda, 0x15, 0xa6, 0xe6, 0xaa, 0x99, 0x47, 0x1f, 0xa3,
	0x6f, 0xfa, 0x08, 0xe9, 0xc8, 0x5c, 0x88, 0xb6, 0xdf, 0x13, 0xbb, 0xf8, 0x17, 0xb0, 0xd2, 0xb6,
	0xef, 0x5a, 0x0e, 0xed, 0x74, 0x88, 0xc3, 0x2c, 0x9b, 0x31, 0xd2, 0xf6, 0x59, 0x28, 0x53, 0x6c,
	0x4c, 0x0a, 0xb7, 0xed, 0xbb, 0x7b, 0x02, 0xb5, 0x2b, 0x41, 0xa5, 0x0f, 0x41, 0xdb, 0xa3, 0xf4,
	0x8e, 0x47, 0x5e, 0xa7, 0xc1, 0xbe, 0x1d, 0x36, 0xbd, 0x4e, 0x03, 0xff, 0x0c, 0x94, 0x8e, 0xdd,
	0x26, 0xe2, 0x94, 0xab, 0x5a, 0x94, 0xa3, 0x51, 0x2c, 0xd3, 0x41, 0x4a, 0x43, 0xfa, 0xbd, 0xa4,
	0xc9, 0x77, 0xa3, 0x54, 0x60, 0xac, 0x25, 0x6c, 0x33, 0xa3, 0xbf, 0x18, 0x83, 0xe2, 0xdb, 0xac,
	0xc9, 0x15, 0x67, 0x4c, 0xfe, 0xbf, 0x74, 0x3f, 0x09, 0xf9, 0x88, 0x77, 0xec, 0x44, 0xb7, 0x60,
	0xa1, 0x49, 0x6c, 0x97, 0x04, 0xd6, 0xd3, 0xb4, 0xec, 0x27, 0x4c, 0x10, 0xb0, 0x77, 0x23, 0x6d,
	0xaf, 0xc2, 0xbc, 0xc3, 0xed, 0x94, 0xe7, 0x76, 0x61, 0xe6, 0x85, 0x98, 0x76, 0x65, 0x3f, 0x61,
	0x4a, 0x31, 0x7c, 0x1e, 0x32, 0x21, 0xed, 0x06, 0x0e, 0xb1, 0x3c, 0x9f, 0x5b, 0xa8, 0x8a, 0xdb,
	0xb7, 0x9f, 0x30, 0x55, 0xb1, 0xf1, 0xa6, 0x8f, 0x8b, 0xa0, 0x32, 0x12, 0xb4, 0xbd, 0x8e, 0xdd,
	0xd2, 0x95, 0x11, 0xc6, 0x1c, 0xae, 0xee, 0x14, 0x1e, 0xf6, 0xd1, 0x1a, 0xe8, 0xb0, 0x14, 0x69,
	0x28, 0x0a, 0xaf, 0x8a, 0x66, 0xb7, 0x45, 0x42, 0x3c, 0xb7, 0x6d, 0x5c, 0xae, 0x5e, 0x00, 0xcd,
	0xe7, 0x8b, 0x56, 0xe8, 0x13, 0xc7, 0xab, 0x7b, 0x24, 0xc0, 0x4b, 0x0f, 0xfa, 0x28, 0x79, 0xd2,
	0x47, 0xa9, 0x41, 0x1f, 0xa5, 0x2a, 0x46, 0xd9, 0xd8, 0x3a, 0x50, 0xd4, 0x94, 0x36, 0x5f, 0xfa,
	0x5d, 0x16, 0x56, 0xa6, 0xef, 0xf0, 0xdb, 0x5e, 0xc8, 0xf0, 0xaf, 0x21, 0xeb, 0x8e, 0x96, 0x42,
	0x99, 0xf9, 0x17, 0x9e, 0xa9, 0x08, 0x54, 0xf3, 0x27, 0x7d, 0x84, 0x86, 0xc9, 0xaf, 0x99, 0x13,
	0x54, 0xf8, 0x1a, 0xe4, 0xfd, 0x80, 0xd4, 0xbd, 0xbb, 0x56, 0x40, 0x8e, 0x03, 0x8f, 0x11, 0x3d,
	0xc5, 0x0f, 0x60, 0x29, 0x3e, 0x00, 0x35, 0x98, 0xd7, 0xef, 0x25, 0xbf, 0x49, 0x22, 0x33, 0x27,
	0x80, 0xa6, 0xc0, 0xe1, 0x8b, 0x90, 0x6d, 0xd2, 0x90, 0x0d, 0xe5, 0xe6, 0xb9, 0x5c, 0x1c, 0xc4,
	0x85, 0x68, 0x2f, 0x86, 0x56, 0x60, 0xc9, 0xee, 0x32, 0x6a, 0x4d, 0xe0, 0xd3, 0x13, 0x41, 0x5f,
	0x8c, 0x00, 0xfb, 0x63, 0x32, 0x05, 0x48, 0xc7, 0xf9, 0xae, 0x8e, 0x15, 0xc7, 0x78, 0x11, 0xbf,
	0x01, 0xd9, 0x80, 0xb0, 0xa0, 0x67, 0x89, 0xf8, 0xea, 0x19, 0x9e, 0x07, 0x85, 0xa9, 0x98, 0x98,
	0x11, 0x64, 0x94, 0x6c, 0x55, 0x25, 0x0a, 0x86, 0xb9, 0x10, 0x8c, 0x96, 0xf1, 0xa7, 0xb3, 0xca,
	0x2c, 0xf0, 0x08, 0xdf, 0x78, 0xa6, 0x08, 0x47, 0x47, 0x34, 0xbb, 0xd4, 0x5e, 0x88, 0x4a, 0xed,
	0xc9, 0x0f, 0x2e, 0xb7, 0xf8, 0x36, 0xe4, 0xda, 0xbc, 0xf0, 0xc5, 0xce, 0x2d, 0x3c, 0x25, 0xc9,
	0xa7, 0x4b, 0x64, 0x55, 0x89, 0xb4, 0x9a, 0xd9, 0xf6, 0xd8, 0x3a, 0xfe, 0x00, 0x96, 0x8e, 0x49,
	0xcd, 0x12, 0x05, 0x25, 0xaa, 0x0d, 0x75, 0xaf, 0xa1, 0xe7, 0x38, 0xeb, 0xfa, 0x4c, 0xd6, 0x19,
	0xc5, 0x4a, 0x12, 0x2f, 0x1e, 0x93, 0xda, 0xe1, 0xd8, 0x16, 0x3e, 0x80, 0x5c, 0xad, 0x5b, 0xaf,
	0x93, 0xa1, 0xb5, 0x79, 0xce, 0x7b, 0x6e, 0x8a, 0xb7, 0xca, 0x31, 0xdf, 0xa1, 0xcb, 0x0a, 0x59,
	0x69, 0xe7, 0x6b, 0xb0, 0xe0, 0xd0, 0x20, 0x8c, 0x99, 0x16, 0x39, 0xd3, 0x99, 0x29, 0xa6, 0x3d,
	0x1a, 0x84, 0x02, 0x2f, 0x39, 0xc0, 0x19, 0xae, 0xe0, 0x77, 0x61, 0xa1, 0x69, 0x87, 0xcd, 0x98,
	0x41, 0xe3, 0x07, 0x79, 0x7e, 0xa6, 0x8f, 0x93, 0x85, 0xa8, 0xaa, 0xc6, 0xa7, 0x65, 0x42, 0x73,
	0xb8, 0x83, 0x5f, 0x03, 0xd5, 0x0f, 0x3c, 0x1a, 0x78, 0xac, 0xa7, 0xe3, 0x22, 0x5a, 0xcf, 0x7f,
	0x37, 0xc7, 0x68, 0x97, 0x79, 0x9d, 0xc6, 0x6d, 0x89, 0x92, 0x36, 0x0d, 0xa5, 0x22, 0x8b, 0xa2,
	0x96, 0x10, 0x47, 0x7d, 0x99, 0xfb, 0x34, 0xdb, 0xa2, 0xc9, 0x86, 0x22, 0x2c, 0xfa, 0x96, 0x5b,
	0x14, 0x0e, 0x77, 0xf0, 0xab, 0xb0, 0x18, 0xe5, 0xaf, 0xed, 0x30, 0x2b, 0x6e, 0x85, 0xa7, 0x38,
	0xe7, 0xca, 0x14, 0xe7, 0xcd, 0xb6, 0xcf, 0x7a, 0xfb, 0xc8, 0xcc, 0x4b, 0xb8, 0x6c, 0xb8, 0xf8,
	0x2d, 0x58, 0x75, 0xa9, 0xd5, 0xa1, 0xd1, 0x5d, 0x9c, 0xe4, 0x59, 0x7d, 0x2a, 0xcf, 0xb2, 0x4b,
	0xdf, 0xa5, 0xcc, 0x9c, 0x20, 0xfb, 0x51, 0x46, 0x83, 0x4f, 0xd0, 0x93, 0x1b, 0x17, 0xca, 0xc6,
	0x35, 0xe3, 0xba, 0xb1, 0x6d, 0x54, 0x5e, 0x31, 0xca, 0xaf, 0x18, 0xe5, 0xb2, 0x51, 0xde, 0x32,
	0xca, 0x97, 0x8d, 0xf2, 0xb6, 0x51, 0xbe, 0x62, 0x94, 0xaf, 0x19, 0xe5, 0xeb, 0x46, 0x65, 0xeb,
	0x61, 0x1f, 0xfd, 0x06, 0x9e, 0x07, 0xfd, 0x56, 0xe0, 0x35, 0xbc, 0x4e, 0xf1, 0x36, 0xa5, 0xad,
	0x70, 0x6c, 0x80, 0x08, 0x31, 0x2a, 0xc3, 0x0e, 0x2c, 0x8f, 0xdd, 0xce, 0xe2, 0xae, 0x23, 0x2a,
	0xdd, 0xf9, 0x67, 0xa0, 0xaf, 0xbe, 0x08, 0xcb, 0xe3, 0x45, 0xca, 0xf2, 0xed, 0xc0, 0x6e, 0x87,
	0x78, 0xf1, 0x41, 0x1f, 0xa5, 0x4f, 0xfa, 0x68, 0x65, 0xd0, 0x47, 0x73, 0x57, 0x8d, 0x2b, 0xd5,
	0x57, 0x60, 0x55, 0xc6, 0x6c, 0x14, 0xc3, 0x26, 0xf5, 0x1c, 0x82, 0x57, 0x1f, 0xf4, 0xd1, 0xea,
	0x17, 0x22, 0x93, 0x4e, 0x0f, 0xfa, 0x68, 0xbe, 0x52, 0x31, 0x8a, 0x95, 0xb2, 0x98, 0x69, 0x0e,
	0x14, 0x75, 0x4e, 0x53, 0x0e, 0x14, 0x55, 0xd1, 0x52, 0x07, 0x8a, 0xba, 0xa4, 0xe1, 0x03, 0x45,
	0x5d, 0xd1, 0x4e, 0x1d, 0x28, 0x6a, 0x56, 0xcb, 0x1d, 0x28, 0xea, 0x69, 0x4d, 0x2f, 0xdd, 0x94,
	0x73, 0xe7, 0xaf, 0xba, 0x24, 0xe8, 0xdd, 0x16, 0x06, 0x94, 0x21, 0xfb, 0x51, 0xf4, 0x28, 0x0d,
	0xe2, 0x1d, 0x20, 0x53, 0xcd, 0xc7, 0x45, 0x9a, 0x97, 0xf6, 0xa2, 0xb9, 0xf0, 0xd1, 0x48, 0xa4,
	0xf4, 0x0f, 0x05, 0x72, 0x9c, 0xc7, 0x24, 0xae, 0x17, 0x10, 0x87, 0xe1, 0x8b, 0x90, 0x93, 0xce,
	0x89, 0x05, 0xd9, 0x6b, 0x45, 0x61, 0xcd, 0x8a, 0x82, 0x2d, 0xa1, 0x57, 0x20, 0x17, 0xf5, 0xeb,
	0x11, 0x34, 0x39, 0xec, 0x0a, 0x68, 0xb2, 0x2b, 0x64, 0x23, 0xdc, 0x50, 0xee, 0x56, 0xd4, 0x4e,
	0x28, 0xa3, 0x23, 0x41, 0xde, 0xfd, 0xab, 0xeb, 0xb1, 0xa5, 0xe7, 0x82, 0xe7, 0xcd, 0xbc, 0xd7,
	0x71, 0x68, 0xdb, 0xeb, 0x34, 0x2e, 0x71, 0xac, 0xa9, 0x34, 0x19, 0xf3, 0xcd, 0x54, 0xf4, 0x1b,
	0x46, 0x5d, 0x26, 0x5a, 0x8b, 0x09, 0x3f, 0x04, 0x1c, 0xb2, 0xc0, 0xf3, 0xad, 0x09, 0xf7, 0x95,
	0xa7, 0xd4, 0xc3, 0xe9, 0xd8, 0x55, 0xd3, 0x72, 0xe4, 0xd9, 0x4f, 0x98, 0x1a, 0xe7, 0x1a, 0x0f,
	0xec, 0x3a, 0x80, 0xdd, 0x6a, 0xc5, 0xbc, 0x29, 0xde, 0x93, 0xc6, 0x04, 0x32, 0x76, 0xab, 0x25,
	0x91, 0x55, 0x58, 0x0a, 0x08, 0xb3, 0xbd, 0x8e, 0x35, 0x26, 0xa0, 0x3e, 0xe5, 0xc2, 0x24, 0xcc,
	0x45, 0x21, 0xb0, 0x3b, 0xc9, 0xd1, 0xa6, 0x47, 0x64, 0x9c, 0x23, 0xf3, 0xff, 0x38, 0x22, 0x81,
	0x11, 0xc7, 0x16, 0xe4, 0x02, 0x12, 0xfa, 0xb4, 0x13, 0x12, 0xcb, 0xa1, 0xae, 0x68, 0xbc, 0xb9,
	0xb1, 0x5c, 0x78, 0x69, 0x4e, 0xff, 0x52, 0x31, 0xb3, 0x31, 0x68, 0x8f, 0xba, 0x64, 0x27, 0xfb,
	0xe4, 0x46, 0x66, 0xcb, 0x28, 0x1b, 0x15, 0xe3, 0x8a, 0x71, 0xb5, 0x7a, 0x6e, 0x32, 0x9b, 0x78,
	0x7a, 0xab, 0x27, 0x7d, 0x94, 0x8e, 0xd2, 0xfb, 0x9a, 0x71, 0xfd, 0x40, 0x51, 0xd3, 0x9a, 0x5a,
	0xfa, 0x13, 0x82, 0x65, 0xd1, 0xec, 0xf8, 0x59, 0x98, 0x92, 0x10, 0x6f, 0x4f, 0x5b, 0x80, 0xb8,
	0x05, 0xa3, 0x99, 0xed, 0xa5, 0x94, 0xfe, 0xa5, 0xb2, 0xee, 0x4e, 0xda, 0x30, 0x21, 0x56, 0xa3,
	0x6e, 0x4f, 0xe6, 0x54, 0x24, 0x36, 0x27, 0x47, 0xbd, 0x22, 0x5a, 0xbf, 0x57, 0x1c, 0x89, 0x55,
	0xa9, 0xdb, 0xdb, 0x39, 0xfb, 0xb0, 0x8f, 0x74, 0x58, 0x85, 0x45, 0x61, 0x45, 0x71, 0x68, 0xc6,
	0x5c, 0xd9, 0xa8, 0x94, 0x2e, 0xc1, 0xd2, 0x21, 0x09, 0x8e, 0x3c, 0x87, 0x88, 0x7a, 0xfd, 0x66,
	0xa7, 0x4e, 0xb1, 0x0e, 0x69, 0xd7, 0x0b, 0xed, 0x5a, 0x8b, 0xc4, 0x73, 0xb8, 0x7c, 0x2c, 0xfd,
	0x35, 0x03, 0x19, 0xee, 0x12, 0x1f, 0x3d, 0xb7, 0x21, 0xd5, 0xb6, 0x99, 0xd3, 0x94, 0x03, 0xd5,
	0x99, 0x19, 0x85, 0x9d, 0xbc, 0x13, 0x01, 0xe4, 0xdc, 0x20, 0xd0, 0xf8, 0x43, 0x58, 0xe2, 0xa9,
	0x66, 0x8d, 0x4d, 0x52, 0x72, 0x0e, 0xbd, 0xf8, 0xcc, 0x13, 0x83, 0xa0, 0x8c, 0x72, 0x32, 0x98,
	0x7e, 0xc9, 0x7c, 0x0b, 0xf2, 0x82, 0x7f, 0xe2, 0x12, 0x2d, 0x54, 0x4a, 0xdf, 0x4f, 0x1e, 0xdf,
	0x97, 0xfd, 0x84, 0x99, 0x0b, 0x26, 0x2e, 0xbd, 0x0b, 0xa7, 0xa4, 0xb1, 0xfc, 0xd9, 0x8a, 0x63,
	0x2b, 0xef, 0xd0, 0xfa, 0x53, 0x0c, 0x9e, 0x38, 0xf5, 0xa1, 0xbd, 0xcb, 0xc1, 0x8c, 0x94, 0x78,
	0x0d, 0x4e, 0xc9, 0x10, 0x5b, 0x4e, 0x37, 0x64, 0xb4, 0x6d, 0x85, 0x4e, 0xe0, 0xf9, 0x4c, 0xde,
	0xa8, 0x6c, 0xd4, 0xc8, 0xa2, 0x2b, 0xc5, 0x4b, 0xcd, 0xb2, 0x84, 0xee, 0x71, 0xe4, 0x21, 0x07,
	0xe2, 0x43, 0xc8, 0x87, 0xe2, 0x20, 0xe3, 0xd6, 0x9d, 0xe5, 0x06, 0xbe, 0x38, 0xbb, 0x51, 0x4e,
	0x9f, 0xb9, 0xec, 0xba, 0xb9, 0x70, 0x7c, 0x03, 0x33, 0x58, 0x0d, 0xc8, 0x47, 0x5d, 0x12, 0x32,
	0x4b, 0xbc, 0x3c, 0x84, 0x16, 0xa3, 0x96, 0xed, 0xba, 0x7a, 0x9a, 0x9f, 0xf8, 0xcb, 0x53, 0xe4,
	0xfb, 0x1c, 0xf4, 0x8e, 0xdd, 0xf1, 0xfc, 0x6e, 0x8b, 0x1f, 0xc6, 0x2d, 0xfe, 0x4d, 0x80, 0x77,
	0x63, 0x1c, 0xcf, 0x07, 0x63, 0x15, 0x77, 0x59, 0xd2, 0x0b, 0xc1, 0xf0, 0x3d, 0xba, 0xeb, 0xba,
	0xf8, 0x08, 0x4e, 0x0f, 0x13, 0x7d, 0x4a, 0xad, 0xfa, 0xe3, 0xa8, 0x5d, 0x89, 0xf9, 0x27, 0xf4,
	0xd6, 0xe0, 0xcc, 0x0c, 0x6f, 0x45, 0xfd, 0xd0, 0x33, 0xbc, 0x63, 0xfc, 0x3c, 0x26, 0x8b, 0x0b,
	0x79, 0xf6, 0x33, 0x94, 0x29, 0xc9, 0x9b, 0x97, 0x1c, 0xd3, 0xb0, 0x3a, 0xed, 0x98, 0xc9, 0x69,
	0xb0, 0x0b, 0x6b, 0xb3, 0x7c, 0x93, 0x4a, 0xe0, 0x87, 0x29, 0x39, 0xfd, 0x1d, 0x37, 0xa4, 0x96,
	0xab, 0xa0, 0x1e, 0xdb, 0x75, 0x8b, 0xf5, 0x7c, 0x22, 0x67, 0xdf, 0xd5, 0xa9, 0x90, 0xbd, 0x6f,
	0xd7, 0xc7, 0x86, 0xc8, 0xf4, 0xb1, 0x78, 0xc4, 0x57, 0x60, 0x25, 0xce, 0xc3, 0x16, 0x75, 0x78,
	0x28, 0x79, 0xdc, 0x73, 0x63, 0x6f, 0x6f, 0x58, 0x22, 0xde, 0x96, 0x80, 0x5d, 0xd7, 0xdd, 0xf1,
	0x9e, 0xdc, 0xd0, 0xcb, 0x7c, 0x1e, 0xd8, 0x32, 0xca, 0x95, 0x68, 0x3c, 0xb8, 0x6a, 0x5c, 0x37,
	0xae, 0x45, 0xa3, 0xc2, 0xf6, 0xc3, 0x3e, 0x3a, 0x00, 0x0c, 0x39, 0x53, 0x44, 0xa4, 0xc8, 0x2b,
	0x42, 0x34, 0x68, 0xe8, 0x30, 0x2f, 0x86, 0x0b, 0x9c, 0x2f, 0x5f, 0x1e, 0x09, 0x94, 0xb7, 0x60,
	0x0d, 0x16, 0x77, 0xdd, 0x23, 0xbb, 0xe3, 0x10, 0x57, 0xce, 0x1f, 0x38, 0x1d, 0x8d, 0x1c, 0x15,
	0x63, 0xbb, 0xfa, 0x02, 0x64, 0xc5, 0x85, 0x14, 0x5f, 0x16, 0x86, 0xaf, 0x83, 0x79, 0xf1, 0x3a,
	0x28, 0xbe, 0x7f, 0xe4, 0xb5, 0xc5, 0x52, 0x08, 0xf9, 0x37, 0x5a, 0xb4, 0x66, 0xb7, 0x0e, 0x7d,
	0xe2, 0x70, 0xef, 0x5e, 0x87, 0x79, 0x2e, 0x1a, 0xbf, 0x01, 0x16, 0xbe, 0xff, 0xf2, 0xf2, 0xe0,
	0x4c, 0xbf, 0xfa, 0x49, 0xe9, 0x9d, 0x33, 0x0f, 0xfb, 0xe8, 0x14, 0x2c, 0x43, 0x3e, 0x2a, 0x44,
	0x45, 0x5a, 0x2f, 0x8a, 0x75, 0x8c, 0xca, 0xa5, 0x3a, 0xe4, 0xf7, 0x02, 0x62, 0x33, 0x32, 0x54,
	0xba, 0xfb, 0x03, 0x95, 0x66, 0xee, 0x7f, 0x2c, 0x05, 0x86, 0xfa, 0x96, 0xfe, 0x75, 0x63, 0xca,
	0x95, 0x52, 0x03, 0x16, 0x4d, 0xe2, 0xb7, 0x6c, 0xe7, 0xa7, 0x56, 0xe4, 0xc0, 0xc2, 0x1b, 0x84,
	0xfd, 0xb4, 0x4a, 0xaa, 0x9f, 0xa0, 0x93, 0xaf, 0x0b, 0x89, 0x47, 0x5f, 0x17, 0x12, 0xdf, 0x7e,
	0x5d, 0x40, 0xf7, 0x06, 0x05, 0xf4, 0x97, 0x41, 0x01, 0x7d, 0x31, 0x28, 0xa0, 0x93, 0x41, 0x01,
	0x3d, 0x1a, 0x14, 0xd0, 0x57, 0x83, 0x02, 0xfa, 0x66, 0x50, 0x48, 0x7c, 0x3b, 0x28, 0xa0, 0x4f,
	0x1f, 0x17, 0x12, 0x0f, 0x1e, 0x17, 0xd0, 0xc9, 0xe3, 0x42, 0xe2, 0xd1, 0xe3, 0x42, 0xe2, 0x83,
	0x37, 0x1b, 0xd4, 0xbf, 0xd3, 0xd8, 0x38, 0xa2, 0x2d, 0x46, 0x82, 0xc0, 0xde, 0xe8, 0x86, 0x9b,
	0xfc, 0x4f, 0x9d, 0x06, 0xed, 0x68, 0x46, 0x3a, 0xf2, 0x5c, 0x12, 0x5c, 0x8a, 0xb7, 0x37, 0xfd,
	0x5a, 0x83, 0x6e, 0x92, 0xbb, 0x4c, 0x7e, 0xbb, 0x1c, 0xff, 0xfa, 0x5a, 0x9b, 0xe7, 0xe3, 0xd3,
	0xd6, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0x22, 0xe8, 0x9b, 0x8a, 0x9b, 0x15, 0x00, 0x00,
}

func (this *RouteDestination) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteDestination)
	if !ok {
		that2, ok := that.(RouteDestination)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Cluster) != len(that1.Cluster) {
		return false
	}
	for i := range this.Cluster {
		if !this.Cluster[i].Equal(that1.Cluster[i]) {
			return false
		}
	}
	if this.Weight != that1.Weight {
		return false
	}
	if len(this.EndpointSubsets) != len(that1.EndpointSubsets) {
		return false
	}
	for i := range this.EndpointSubsets {
		if this.EndpointSubsets[i] != that1.EndpointSubsets[i] {
			return false
		}
	}
	return true
}
func (this *MirrorPolicyType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MirrorPolicyType)
	if !ok {
		that2, ok := that.(MirrorPolicyType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Cluster) != len(that1.Cluster) {
		return false
	}
	for i := range this.Cluster {
		if !this.Cluster[i].Equal(that1.Cluster[i]) {
			return false
		}
	}
	if !this.Percent.Equal(that1.Percent) {
		return false
	}
	return true
}
func (this *SpdyConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SpdyConfigType)
	if !ok {
		that2, ok := that.(SpdyConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UseSpdy != that1.UseSpdy {
		return false
	}
	return true
}
func (this *WebsocketConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WebsocketConfigType)
	if !ok {
		that2, ok := that.(WebsocketConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UseWebsocket != that1.UseWebsocket {
		return false
	}
	if this.IdleTimeout != that1.IdleTimeout {
		return false
	}
	if this.MaxConnectAttempts != that1.MaxConnectAttempts {
		return false
	}
	return true
}
func (this *CookieForHashing) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieForHashing)
	if !ok {
		that2, ok := that.(CookieForHashing)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Ttl != that1.Ttl {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	return true
}
func (this *HashPolicyType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HashPolicyType)
	if !ok {
		that2, ok := that.(HashPolicyType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PolicySpecifier == nil {
		if this.PolicySpecifier != nil {
			return false
		}
	} else if this.PolicySpecifier == nil {
		return false
	} else if !this.PolicySpecifier.Equal(that1.PolicySpecifier) {
		return false
	}
	if this.Terminal != that1.Terminal {
		return false
	}
	return true
}
func (this *HashPolicyType_HeaderName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HashPolicyType_HeaderName)
	if !ok {
		that2, ok := that.(HashPolicyType_HeaderName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HeaderName != that1.HeaderName {
		return false
	}
	return true
}
func (this *HashPolicyType_Cookie) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HashPolicyType_Cookie)
	if !ok {
		that2, ok := that.(HashPolicyType_Cookie)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Cookie.Equal(that1.Cookie) {
		return false
	}
	return true
}
func (this *HashPolicyType_SourceIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HashPolicyType_SourceIp)
	if !ok {
		that2, ok := that.(HashPolicyType_SourceIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SourceIp != that1.SourceIp {
		return false
	}
	return true
}
func (this *RouteDestinationList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteDestinationList)
	if !ok {
		that2, ok := that.(RouteDestinationList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Destinations) != len(that1.Destinations) {
		return false
	}
	for i := range this.Destinations {
		if !this.Destinations[i].Equal(that1.Destinations[i]) {
			return false
		}
	}
	if this.PrefixRewrite != that1.PrefixRewrite {
		return false
	}
	if that1.HostRewriteParams == nil {
		if this.HostRewriteParams != nil {
			return false
		}
	} else if this.HostRewriteParams == nil {
		return false
	} else if !this.HostRewriteParams.Equal(that1.HostRewriteParams) {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	if !this.RetryPolicy.Equal(that1.RetryPolicy) {
		return false
	}
	if len(this.EndpointSubsets) != len(that1.EndpointSubsets) {
		return false
	}
	for i := range this.EndpointSubsets {
		if this.EndpointSubsets[i] != that1.EndpointSubsets[i] {
			return false
		}
	}
	if !this.MirrorPolicy.Equal(that1.MirrorPolicy) {
		return false
	}
	if !this.WebSocketConfig.Equal(that1.WebSocketConfig) {
		return false
	}
	if !this.BufferPolicy.Equal(that1.BufferPolicy) {
		return false
	}
	if !this.CorsPolicy.Equal(that1.CorsPolicy) {
		return false
	}
	if len(this.HashPolicy) != len(that1.HashPolicy) {
		return false
	}
	for i := range this.HashPolicy {
		if !this.HashPolicy[i].Equal(that1.HashPolicy[i]) {
			return false
		}
	}
	if this.Priority != that1.Priority {
		return false
	}
	if !this.SpdyConfig.Equal(that1.SpdyConfig) {
		return false
	}
	if that1.ClusterRetractChoice == nil {
		if this.ClusterRetractChoice != nil {
			return false
		}
	} else if this.ClusterRetractChoice == nil {
		return false
	} else if !this.ClusterRetractChoice.Equal(that1.ClusterRetractChoice) {
		return false
	}
	return true
}
func (this *RouteDestinationList_HostRewrite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteDestinationList_HostRewrite)
	if !ok {
		that2, ok := that.(RouteDestinationList_HostRewrite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HostRewrite != that1.HostRewrite {
		return false
	}
	return true
}
func (this *RouteDestinationList_AutoHostRewrite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteDestinationList_AutoHostRewrite)
	if !ok {
		that2, ok := that.(RouteDestinationList_AutoHostRewrite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AutoHostRewrite != that1.AutoHostRewrite {
		return false
	}
	return true
}
func (this *RouteDestinationList_RetractCluster) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteDestinationList_RetractCluster)
	if !ok {
		that2, ok := that.(RouteDestinationList_RetractCluster)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RetractCluster.Equal(that1.RetractCluster) {
		return false
	}
	return true
}
func (this *RouteDestinationList_DoNotRetractCluster) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteDestinationList_DoNotRetractCluster)
	if !ok {
		that2, ok := that.(RouteDestinationList_DoNotRetractCluster)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DoNotRetractCluster.Equal(that1.DoNotRetractCluster) {
		return false
	}
	return true
}
func (this *RouteQueryParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteQueryParams)
	if !ok {
		that2, ok := that.(RouteQueryParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.QueryParams) != len(that1.QueryParams) {
		return false
	}
	for i := range this.QueryParams {
		if this.QueryParams[i] != that1.QueryParams[i] {
			return false
		}
	}
	return true
}
func (this *RouteRedirect) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteRedirect)
	if !ok {
		that2, ok := that.(RouteRedirect)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HostRedirect != that1.HostRedirect {
		return false
	}
	if this.PathRedirect != that1.PathRedirect {
		return false
	}
	if this.ProtoRedirect != that1.ProtoRedirect {
		return false
	}
	if that1.QueryParams == nil {
		if this.QueryParams != nil {
			return false
		}
	} else if this.QueryParams == nil {
		return false
	} else if !this.QueryParams.Equal(that1.QueryParams) {
		return false
	}
	if this.ResponseCode != that1.ResponseCode {
		return false
	}
	return true
}
func (this *RouteRedirect_StripQueryParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteRedirect_StripQueryParams)
	if !ok {
		that2, ok := that.(RouteRedirect_StripQueryParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StripQueryParams.Equal(that1.StripQueryParams) {
		return false
	}
	return true
}
func (this *RouteRedirect_AllParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteRedirect_AllParams)
	if !ok {
		that2, ok := that.(RouteRedirect_AllParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AllParams != that1.AllParams {
		return false
	}
	return true
}
func (this *RouteRedirect_RetainAllParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteRedirect_RetainAllParams)
	if !ok {
		that2, ok := that.(RouteRedirect_RetainAllParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RetainAllParams.Equal(that1.RetainAllParams) {
		return false
	}
	return true
}
func (this *RouteRedirect_RemoveAllParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteRedirect_RemoveAllParams)
	if !ok {
		that2, ok := that.(RouteRedirect_RemoveAllParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RemoveAllParams.Equal(that1.RemoveAllParams) {
		return false
	}
	return true
}
func (this *RouteDirectResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteDirectResponse)
	if !ok {
		that2, ok := that.(RouteDirectResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ResponseCode != that1.ResponseCode {
		return false
	}
	if this.ResponseBody != that1.ResponseBody {
		return false
	}
	return true
}
func (this *ServicePolicyInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServicePolicyInfo)
	if !ok {
		that2, ok := that.(ServicePolicyInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Disable != that1.Disable {
		return false
	}
	return true
}
func (this *RouteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteType)
	if !ok {
		that2, ok := that.(RouteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Match) != len(that1.Match) {
		return false
	}
	for i := range this.Match {
		if !this.Match[i].Equal(that1.Match[i]) {
			return false
		}
	}
	if that1.RouteAction == nil {
		if this.RouteAction != nil {
			return false
		}
	} else if this.RouteAction == nil {
		return false
	} else if !this.RouteAction.Equal(that1.RouteAction) {
		return false
	}
	if this.DisableCustomScript != that1.DisableCustomScript {
		return false
	}
	if !this.ServicePolicy.Equal(that1.ServicePolicy) {
		return false
	}
	if len(this.RequestHeadersToAdd) != len(that1.RequestHeadersToAdd) {
		return false
	}
	for i := range this.RequestHeadersToAdd {
		if !this.RequestHeadersToAdd[i].Equal(that1.RequestHeadersToAdd[i]) {
			return false
		}
	}
	if len(this.ResponseHeadersToAdd) != len(that1.ResponseHeadersToAdd) {
		return false
	}
	for i := range this.ResponseHeadersToAdd {
		if !this.ResponseHeadersToAdd[i].Equal(that1.ResponseHeadersToAdd[i]) {
			return false
		}
	}
	if len(this.RequestHeadersToRemove) != len(that1.RequestHeadersToRemove) {
		return false
	}
	for i := range this.RequestHeadersToRemove {
		if this.RequestHeadersToRemove[i] != that1.RequestHeadersToRemove[i] {
			return false
		}
	}
	if len(this.ResponseHeadersToRemove) != len(that1.ResponseHeadersToRemove) {
		return false
	}
	for i := range this.ResponseHeadersToRemove {
		if this.ResponseHeadersToRemove[i] != that1.ResponseHeadersToRemove[i] {
			return false
		}
	}
	if !this.WafType.Equal(that1.WafType) {
		return false
	}
	if this.DisableLocationAdd != that1.DisableLocationAdd {
		return false
	}
	return true
}
func (this *RouteType_RouteDestination) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteType_RouteDestination)
	if !ok {
		that2, ok := that.(RouteType_RouteDestination)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RouteDestination.Equal(that1.RouteDestination) {
		return false
	}
	return true
}
func (this *RouteType_RouteRedirect) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteType_RouteRedirect)
	if !ok {
		that2, ok := that.(RouteType_RouteRedirect)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RouteRedirect.Equal(that1.RouteRedirect) {
		return false
	}
	return true
}
func (this *RouteType_RouteDirectResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteType_RouteDirectResponse)
	if !ok {
		that2, ok := that.(RouteType_RouteDirectResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RouteDirectResponse.Equal(that1.RouteDirectResponse) {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	return true
}
func (this *RouteDestination) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&route.RouteDestination{")
	if this.Cluster != nil {
		s = append(s, "Cluster: "+fmt.Sprintf("%#v", this.Cluster)+",\n")
	}
	s = append(s, "Weight: "+fmt.Sprintf("%#v", this.Weight)+",\n")
	keysForEndpointSubsets := make([]string, 0, len(this.EndpointSubsets))
	for k, _ := range this.EndpointSubsets {
		keysForEndpointSubsets = append(keysForEndpointSubsets, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEndpointSubsets)
	mapStringForEndpointSubsets := "map[string]string{"
	for _, k := range keysForEndpointSubsets {
		mapStringForEndpointSubsets += fmt.Sprintf("%#v: %#v,", k, this.EndpointSubsets[k])
	}
	mapStringForEndpointSubsets += "}"
	if this.EndpointSubsets != nil {
		s = append(s, "EndpointSubsets: "+mapStringForEndpointSubsets+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MirrorPolicyType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&route.MirrorPolicyType{")
	if this.Cluster != nil {
		s = append(s, "Cluster: "+fmt.Sprintf("%#v", this.Cluster)+",\n")
	}
	if this.Percent != nil {
		s = append(s, "Percent: "+fmt.Sprintf("%#v", this.Percent)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SpdyConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&route.SpdyConfigType{")
	s = append(s, "UseSpdy: "+fmt.Sprintf("%#v", this.UseSpdy)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WebsocketConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&route.WebsocketConfigType{")
	s = append(s, "UseWebsocket: "+fmt.Sprintf("%#v", this.UseWebsocket)+",\n")
	s = append(s, "IdleTimeout: "+fmt.Sprintf("%#v", this.IdleTimeout)+",\n")
	s = append(s, "MaxConnectAttempts: "+fmt.Sprintf("%#v", this.MaxConnectAttempts)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CookieForHashing) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&route.CookieForHashing{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Ttl: "+fmt.Sprintf("%#v", this.Ttl)+",\n")
	s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HashPolicyType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&route.HashPolicyType{")
	if this.PolicySpecifier != nil {
		s = append(s, "PolicySpecifier: "+fmt.Sprintf("%#v", this.PolicySpecifier)+",\n")
	}
	s = append(s, "Terminal: "+fmt.Sprintf("%#v", this.Terminal)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HashPolicyType_HeaderName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.HashPolicyType_HeaderName{` +
		`HeaderName:` + fmt.Sprintf("%#v", this.HeaderName) + `}`}, ", ")
	return s
}
func (this *HashPolicyType_Cookie) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.HashPolicyType_Cookie{` +
		`Cookie:` + fmt.Sprintf("%#v", this.Cookie) + `}`}, ", ")
	return s
}
func (this *HashPolicyType_SourceIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.HashPolicyType_SourceIp{` +
		`SourceIp:` + fmt.Sprintf("%#v", this.SourceIp) + `}`}, ", ")
	return s
}
func (this *RouteDestinationList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 20)
	s = append(s, "&route.RouteDestinationList{")
	if this.Destinations != nil {
		s = append(s, "Destinations: "+fmt.Sprintf("%#v", this.Destinations)+",\n")
	}
	s = append(s, "PrefixRewrite: "+fmt.Sprintf("%#v", this.PrefixRewrite)+",\n")
	if this.HostRewriteParams != nil {
		s = append(s, "HostRewriteParams: "+fmt.Sprintf("%#v", this.HostRewriteParams)+",\n")
	}
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	if this.RetryPolicy != nil {
		s = append(s, "RetryPolicy: "+fmt.Sprintf("%#v", this.RetryPolicy)+",\n")
	}
	keysForEndpointSubsets := make([]string, 0, len(this.EndpointSubsets))
	for k, _ := range this.EndpointSubsets {
		keysForEndpointSubsets = append(keysForEndpointSubsets, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEndpointSubsets)
	mapStringForEndpointSubsets := "map[string]string{"
	for _, k := range keysForEndpointSubsets {
		mapStringForEndpointSubsets += fmt.Sprintf("%#v: %#v,", k, this.EndpointSubsets[k])
	}
	mapStringForEndpointSubsets += "}"
	if this.EndpointSubsets != nil {
		s = append(s, "EndpointSubsets: "+mapStringForEndpointSubsets+",\n")
	}
	if this.MirrorPolicy != nil {
		s = append(s, "MirrorPolicy: "+fmt.Sprintf("%#v", this.MirrorPolicy)+",\n")
	}
	if this.WebSocketConfig != nil {
		s = append(s, "WebSocketConfig: "+fmt.Sprintf("%#v", this.WebSocketConfig)+",\n")
	}
	if this.BufferPolicy != nil {
		s = append(s, "BufferPolicy: "+fmt.Sprintf("%#v", this.BufferPolicy)+",\n")
	}
	if this.CorsPolicy != nil {
		s = append(s, "CorsPolicy: "+fmt.Sprintf("%#v", this.CorsPolicy)+",\n")
	}
	if this.HashPolicy != nil {
		s = append(s, "HashPolicy: "+fmt.Sprintf("%#v", this.HashPolicy)+",\n")
	}
	s = append(s, "Priority: "+fmt.Sprintf("%#v", this.Priority)+",\n")
	if this.SpdyConfig != nil {
		s = append(s, "SpdyConfig: "+fmt.Sprintf("%#v", this.SpdyConfig)+",\n")
	}
	if this.ClusterRetractChoice != nil {
		s = append(s, "ClusterRetractChoice: "+fmt.Sprintf("%#v", this.ClusterRetractChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteDestinationList_HostRewrite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteDestinationList_HostRewrite{` +
		`HostRewrite:` + fmt.Sprintf("%#v", this.HostRewrite) + `}`}, ", ")
	return s
}
func (this *RouteDestinationList_AutoHostRewrite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteDestinationList_AutoHostRewrite{` +
		`AutoHostRewrite:` + fmt.Sprintf("%#v", this.AutoHostRewrite) + `}`}, ", ")
	return s
}
func (this *RouteDestinationList_RetractCluster) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteDestinationList_RetractCluster{` +
		`RetractCluster:` + fmt.Sprintf("%#v", this.RetractCluster) + `}`}, ", ")
	return s
}
func (this *RouteDestinationList_DoNotRetractCluster) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteDestinationList_DoNotRetractCluster{` +
		`DoNotRetractCluster:` + fmt.Sprintf("%#v", this.DoNotRetractCluster) + `}`}, ", ")
	return s
}
func (this *RouteQueryParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&route.RouteQueryParams{")
	s = append(s, "QueryParams: "+fmt.Sprintf("%#v", this.QueryParams)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteRedirect) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&route.RouteRedirect{")
	s = append(s, "HostRedirect: "+fmt.Sprintf("%#v", this.HostRedirect)+",\n")
	s = append(s, "PathRedirect: "+fmt.Sprintf("%#v", this.PathRedirect)+",\n")
	s = append(s, "ProtoRedirect: "+fmt.Sprintf("%#v", this.ProtoRedirect)+",\n")
	if this.QueryParams != nil {
		s = append(s, "QueryParams: "+fmt.Sprintf("%#v", this.QueryParams)+",\n")
	}
	s = append(s, "ResponseCode: "+fmt.Sprintf("%#v", this.ResponseCode)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteRedirect_StripQueryParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteRedirect_StripQueryParams{` +
		`StripQueryParams:` + fmt.Sprintf("%#v", this.StripQueryParams) + `}`}, ", ")
	return s
}
func (this *RouteRedirect_AllParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteRedirect_AllParams{` +
		`AllParams:` + fmt.Sprintf("%#v", this.AllParams) + `}`}, ", ")
	return s
}
func (this *RouteRedirect_RetainAllParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteRedirect_RetainAllParams{` +
		`RetainAllParams:` + fmt.Sprintf("%#v", this.RetainAllParams) + `}`}, ", ")
	return s
}
func (this *RouteRedirect_RemoveAllParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteRedirect_RemoveAllParams{` +
		`RemoveAllParams:` + fmt.Sprintf("%#v", this.RemoveAllParams) + `}`}, ", ")
	return s
}
func (this *RouteDirectResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&route.RouteDirectResponse{")
	s = append(s, "ResponseCode: "+fmt.Sprintf("%#v", this.ResponseCode)+",\n")
	s = append(s, "ResponseBody: "+fmt.Sprintf("%#v", this.ResponseBody)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ServicePolicyInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&route.ServicePolicyInfo{")
	s = append(s, "Disable: "+fmt.Sprintf("%#v", this.Disable)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&route.RouteType{")
	if this.Match != nil {
		s = append(s, "Match: "+fmt.Sprintf("%#v", this.Match)+",\n")
	}
	if this.RouteAction != nil {
		s = append(s, "RouteAction: "+fmt.Sprintf("%#v", this.RouteAction)+",\n")
	}
	s = append(s, "DisableCustomScript: "+fmt.Sprintf("%#v", this.DisableCustomScript)+",\n")
	if this.ServicePolicy != nil {
		s = append(s, "ServicePolicy: "+fmt.Sprintf("%#v", this.ServicePolicy)+",\n")
	}
	if this.RequestHeadersToAdd != nil {
		s = append(s, "RequestHeadersToAdd: "+fmt.Sprintf("%#v", this.RequestHeadersToAdd)+",\n")
	}
	if this.ResponseHeadersToAdd != nil {
		s = append(s, "ResponseHeadersToAdd: "+fmt.Sprintf("%#v", this.ResponseHeadersToAdd)+",\n")
	}
	s = append(s, "RequestHeadersToRemove: "+fmt.Sprintf("%#v", this.RequestHeadersToRemove)+",\n")
	s = append(s, "ResponseHeadersToRemove: "+fmt.Sprintf("%#v", this.ResponseHeadersToRemove)+",\n")
	if this.WafType != nil {
		s = append(s, "WafType: "+fmt.Sprintf("%#v", this.WafType)+",\n")
	}
	s = append(s, "DisableLocationAdd: "+fmt.Sprintf("%#v", this.DisableLocationAdd)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteType_RouteDestination) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteType_RouteDestination{` +
		`RouteDestination:` + fmt.Sprintf("%#v", this.RouteDestination) + `}`}, ", ")
	return s
}
func (this *RouteType_RouteRedirect) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteType_RouteRedirect{` +
		`RouteRedirect:` + fmt.Sprintf("%#v", this.RouteRedirect) + `}`}, ", ")
	return s
}
func (this *RouteType_RouteDirectResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&route.RouteType_RouteDirectResponse{` +
		`RouteDirectResponse:` + fmt.Sprintf("%#v", this.RouteDirectResponse) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&route.GlobalSpecType{")
	if this.Routes != nil {
		s = append(s, "Routes: "+fmt.Sprintf("%#v", this.Routes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&route.CreateSpecType{")
	if this.Routes != nil {
		s = append(s, "Routes: "+fmt.Sprintf("%#v", this.Routes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&route.ReplaceSpecType{")
	if this.Routes != nil {
		s = append(s, "Routes: "+fmt.Sprintf("%#v", this.Routes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&route.GetSpecType{")
	if this.Routes != nil {
		s = append(s, "Routes: "+fmt.Sprintf("%#v", this.Routes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *RouteDestination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteDestination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteDestination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EndpointSubsets) > 0 {
		keysForEndpointSubsets := make([]string, 0, len(m.EndpointSubsets))
		for k := range m.EndpointSubsets {
			keysForEndpointSubsets = append(keysForEndpointSubsets, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForEndpointSubsets)
		for iNdEx := len(keysForEndpointSubsets) - 1; iNdEx >= 0; iNdEx-- {
			v := m.EndpointSubsets[string(keysForEndpointSubsets[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForEndpointSubsets[iNdEx])
			copy(dAtA[i:], keysForEndpointSubsets[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForEndpointSubsets[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Weight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Weight))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Cluster) > 0 {
		for iNdEx := len(m.Cluster) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cluster[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MirrorPolicyType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorPolicyType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MirrorPolicyType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Percent != nil {
		{
			size, err := m.Percent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Cluster) > 0 {
		for iNdEx := len(m.Cluster) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cluster[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SpdyConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpdyConfigType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpdyConfigType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UseSpdy {
		i--
		if m.UseSpdy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WebsocketConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebsocketConfigType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WebsocketConfigType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxConnectAttempts != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxConnectAttempts))
		i--
		dAtA[i] = 0x18
	}
	if m.IdleTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.IdleTimeout))
		i--
		dAtA[i] = 0x10
	}
	if m.UseWebsocket {
		i--
		if m.UseWebsocket {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CookieForHashing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CookieForHashing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieForHashing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Ttl != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Ttl))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HashPolicyType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HashPolicyType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HashPolicyType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Terminal {
		i--
		if m.Terminal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.PolicySpecifier != nil {
		{
			size := m.PolicySpecifier.Size()
			i -= size
			if _, err := m.PolicySpecifier.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *HashPolicyType_HeaderName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HashPolicyType_HeaderName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.HeaderName)
	copy(dAtA[i:], m.HeaderName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.HeaderName)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *HashPolicyType_Cookie) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HashPolicyType_Cookie) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Cookie != nil {
		{
			size, err := m.Cookie.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *HashPolicyType_SourceIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HashPolicyType_SourceIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.SourceIp {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *RouteDestinationList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteDestinationList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteDestinationList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClusterRetractChoice != nil {
		{
			size := m.ClusterRetractChoice.Size()
			i -= size
			if _, err := m.ClusterRetractChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.SpdyConfig != nil {
		{
			size, err := m.SpdyConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.Priority != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.HashPolicy) > 0 {
		for iNdEx := len(m.HashPolicy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HashPolicy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.CorsPolicy != nil {
		{
			size, err := m.CorsPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.BufferPolicy != nil {
		{
			size, err := m.BufferPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.WebSocketConfig != nil {
		{
			size, err := m.WebSocketConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.MirrorPolicy != nil {
		{
			size, err := m.MirrorPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.EndpointSubsets) > 0 {
		keysForEndpointSubsets := make([]string, 0, len(m.EndpointSubsets))
		for k := range m.EndpointSubsets {
			keysForEndpointSubsets = append(keysForEndpointSubsets, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForEndpointSubsets)
		for iNdEx := len(keysForEndpointSubsets) - 1; iNdEx >= 0; iNdEx-- {
			v := m.EndpointSubsets[string(keysForEndpointSubsets[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForEndpointSubsets[iNdEx])
			copy(dAtA[i:], keysForEndpointSubsets[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForEndpointSubsets[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if m.RetryPolicy != nil {
		{
			size, err := m.RetryPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Timeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x40
	}
	if m.HostRewriteParams != nil {
		{
			size := m.HostRewriteParams.Size()
			i -= size
			if _, err := m.HostRewriteParams.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.PrefixRewrite) > 0 {
		i -= len(m.PrefixRewrite)
		copy(dAtA[i:], m.PrefixRewrite)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PrefixRewrite)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Destinations) > 0 {
		for iNdEx := len(m.Destinations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Destinations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RouteDestinationList_HostRewrite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteDestinationList_HostRewrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.HostRewrite)
	copy(dAtA[i:], m.HostRewrite)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.HostRewrite)))
	i--
	dAtA[i] = 0x32
	return len(dAtA) - i, nil
}
func (m *RouteDestinationList_AutoHostRewrite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteDestinationList_AutoHostRewrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.AutoHostRewrite {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x38
	return len(dAtA) - i, nil
}
func (m *RouteDestinationList_RetractCluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteDestinationList_RetractCluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RetractCluster != nil {
		{
			size, err := m.RetractCluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *RouteDestinationList_DoNotRetractCluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteDestinationList_DoNotRetractCluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DoNotRetractCluster != nil {
		{
			size, err := m.DoNotRetractCluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *RouteQueryParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteQueryParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteQueryParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.QueryParams) > 0 {
		for iNdEx := len(m.QueryParams) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.QueryParams[iNdEx])
			copy(dAtA[i:], m.QueryParams[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.QueryParams[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RouteRedirect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteRedirect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteRedirect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.QueryParams != nil {
		{
			size := m.QueryParams.Size()
			i -= size
			if _, err := m.QueryParams.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ResponseCode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ResponseCode))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ProtoRedirect) > 0 {
		i -= len(m.ProtoRedirect)
		copy(dAtA[i:], m.ProtoRedirect)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProtoRedirect)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PathRedirect) > 0 {
		i -= len(m.PathRedirect)
		copy(dAtA[i:], m.PathRedirect)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PathRedirect)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.HostRedirect) > 0 {
		i -= len(m.HostRedirect)
		copy(dAtA[i:], m.HostRedirect)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HostRedirect)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteRedirect_StripQueryParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteRedirect_StripQueryParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StripQueryParams != nil {
		{
			size, err := m.StripQueryParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *RouteRedirect_AllParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteRedirect_AllParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.AllParams {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *RouteRedirect_RetainAllParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteRedirect_RetainAllParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RetainAllParams != nil {
		{
			size, err := m.RetainAllParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *RouteRedirect_RemoveAllParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteRedirect_RemoveAllParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RemoveAllParams != nil {
		{
			size, err := m.RemoveAllParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *RouteDirectResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteDirectResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteDirectResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResponseBody) > 0 {
		i -= len(m.ResponseBody)
		copy(dAtA[i:], m.ResponseBody)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ResponseBody)))
		i--
		dAtA[i] = 0x12
	}
	if m.ResponseCode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ResponseCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ServicePolicyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServicePolicyInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServicePolicyInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Disable {
		i--
		if m.Disable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RouteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DisableLocationAdd {
		i--
		if m.DisableLocationAdd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.ServicePolicy != nil {
		{
			size, err := m.ServicePolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.WafType != nil {
		{
			size, err := m.WafType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for iNdEx := len(m.ResponseHeadersToRemove) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ResponseHeadersToRemove[iNdEx])
			copy(dAtA[i:], m.ResponseHeadersToRemove[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ResponseHeadersToRemove[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for iNdEx := len(m.RequestHeadersToRemove) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RequestHeadersToRemove[iNdEx])
			copy(dAtA[i:], m.RequestHeadersToRemove[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RequestHeadersToRemove[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for iNdEx := len(m.ResponseHeadersToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResponseHeadersToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for iNdEx := len(m.RequestHeadersToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RequestHeadersToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.DisableCustomScript {
		i--
		if m.DisableCustomScript {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.RouteAction != nil {
		{
			size := m.RouteAction.Size()
			i -= size
			if _, err := m.RouteAction.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Match) > 0 {
		for iNdEx := len(m.Match) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Match[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RouteType_RouteDestination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteType_RouteDestination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RouteDestination != nil {
		{
			size, err := m.RouteDestination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *RouteType_RouteRedirect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteType_RouteRedirect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RouteRedirect != nil {
		{
			size, err := m.RouteRedirect.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *RouteType_RouteDirectResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteType_RouteDirectResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RouteDirectResponse != nil {
		{
			size, err := m.RouteDirectResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RouteDestination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cluster) > 0 {
		for _, e := range m.Cluster {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Weight != 0 {
		n += 1 + sovTypes(uint64(m.Weight))
	}
	if len(m.EndpointSubsets) > 0 {
		for k, v := range m.EndpointSubsets {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MirrorPolicyType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cluster) > 0 {
		for _, e := range m.Cluster {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Percent != nil {
		l = m.Percent.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SpdyConfigType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseSpdy {
		n += 2
	}
	return n
}

func (m *WebsocketConfigType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseWebsocket {
		n += 2
	}
	if m.IdleTimeout != 0 {
		n += 1 + sovTypes(uint64(m.IdleTimeout))
	}
	if m.MaxConnectAttempts != 0 {
		n += 1 + sovTypes(uint64(m.MaxConnectAttempts))
	}
	return n
}

func (m *CookieForHashing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Ttl != 0 {
		n += 1 + sovTypes(uint64(m.Ttl))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *HashPolicyType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PolicySpecifier != nil {
		n += m.PolicySpecifier.Size()
	}
	if m.Terminal {
		n += 2
	}
	return n
}

func (m *HashPolicyType_HeaderName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HeaderName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *HashPolicyType_Cookie) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cookie != nil {
		l = m.Cookie.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HashPolicyType_SourceIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *RouteDestinationList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Destinations) > 0 {
		for _, e := range m.Destinations {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.PrefixRewrite)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.HostRewriteParams != nil {
		n += m.HostRewriteParams.Size()
	}
	if m.Timeout != 0 {
		n += 1 + sovTypes(uint64(m.Timeout))
	}
	if m.RetryPolicy != nil {
		l = m.RetryPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.EndpointSubsets) > 0 {
		for k, v := range m.EndpointSubsets {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.MirrorPolicy != nil {
		l = m.MirrorPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.WebSocketConfig != nil {
		l = m.WebSocketConfig.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BufferPolicy != nil {
		l = m.BufferPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CorsPolicy != nil {
		l = m.CorsPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.HashPolicy) > 0 {
		for _, e := range m.HashPolicy {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.Priority != 0 {
		n += 2 + sovTypes(uint64(m.Priority))
	}
	if m.SpdyConfig != nil {
		l = m.SpdyConfig.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ClusterRetractChoice != nil {
		n += m.ClusterRetractChoice.Size()
	}
	return n
}

func (m *RouteDestinationList_HostRewrite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostRewrite)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *RouteDestinationList_AutoHostRewrite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *RouteDestinationList_RetractCluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetractCluster != nil {
		l = m.RetractCluster.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteDestinationList_DoNotRetractCluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DoNotRetractCluster != nil {
		l = m.DoNotRetractCluster.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteQueryParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.QueryParams) > 0 {
		for _, s := range m.QueryParams {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *RouteRedirect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostRedirect)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PathRedirect)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProtoRedirect)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.QueryParams != nil {
		n += m.QueryParams.Size()
	}
	if m.ResponseCode != 0 {
		n += 1 + sovTypes(uint64(m.ResponseCode))
	}
	return n
}

func (m *RouteRedirect_StripQueryParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StripQueryParams != nil {
		l = m.StripQueryParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteRedirect_AllParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *RouteRedirect_RetainAllParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetainAllParams != nil {
		l = m.RetainAllParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteRedirect_RemoveAllParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RemoveAllParams != nil {
		l = m.RemoveAllParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteDirectResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResponseCode != 0 {
		n += 1 + sovTypes(uint64(m.ResponseCode))
	}
	l = len(m.ResponseBody)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ServicePolicyInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Disable {
		n += 2
	}
	return n
}

func (m *RouteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Match) > 0 {
		for _, e := range m.Match {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.RouteAction != nil {
		n += m.RouteAction.Size()
	}
	if m.DisableCustomScript {
		n += 2
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for _, e := range m.RequestHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, e := range m.ResponseHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for _, s := range m.RequestHeadersToRemove {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.WafType != nil {
		l = m.WafType.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ServicePolicy != nil {
		l = m.ServicePolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DisableLocationAdd {
		n += 2
	}
	return n
}

func (m *RouteType_RouteDestination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RouteDestination != nil {
		l = m.RouteDestination.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteType_RouteRedirect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RouteRedirect != nil {
		l = m.RouteRedirect.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteType_RouteDirectResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RouteDirectResponse != nil {
		l = m.RouteDirectResponse.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *RouteDestination) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCluster := "[]*ObjectRefType{"
	for _, f := range this.Cluster {
		repeatedStringForCluster += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForCluster += "}"
	keysForEndpointSubsets := make([]string, 0, len(this.EndpointSubsets))
	for k, _ := range this.EndpointSubsets {
		keysForEndpointSubsets = append(keysForEndpointSubsets, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEndpointSubsets)
	mapStringForEndpointSubsets := "map[string]string{"
	for _, k := range keysForEndpointSubsets {
		mapStringForEndpointSubsets += fmt.Sprintf("%v: %v,", k, this.EndpointSubsets[k])
	}
	mapStringForEndpointSubsets += "}"
	s := strings.Join([]string{`&RouteDestination{`,
		`Cluster:` + repeatedStringForCluster + `,`,
		`Weight:` + fmt.Sprintf("%v", this.Weight) + `,`,
		`EndpointSubsets:` + mapStringForEndpointSubsets + `,`,
		`}`,
	}, "")
	return s
}
func (this *MirrorPolicyType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCluster := "[]*ObjectRefType{"
	for _, f := range this.Cluster {
		repeatedStringForCluster += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForCluster += "}"
	s := strings.Join([]string{`&MirrorPolicyType{`,
		`Cluster:` + repeatedStringForCluster + `,`,
		`Percent:` + strings.Replace(fmt.Sprintf("%v", this.Percent), "FractionalPercent", "schema.FractionalPercent", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SpdyConfigType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SpdyConfigType{`,
		`UseSpdy:` + fmt.Sprintf("%v", this.UseSpdy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WebsocketConfigType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WebsocketConfigType{`,
		`UseWebsocket:` + fmt.Sprintf("%v", this.UseWebsocket) + `,`,
		`IdleTimeout:` + fmt.Sprintf("%v", this.IdleTimeout) + `,`,
		`MaxConnectAttempts:` + fmt.Sprintf("%v", this.MaxConnectAttempts) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieForHashing) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieForHashing{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Ttl:` + fmt.Sprintf("%v", this.Ttl) + `,`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HashPolicyType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HashPolicyType{`,
		`PolicySpecifier:` + fmt.Sprintf("%v", this.PolicySpecifier) + `,`,
		`Terminal:` + fmt.Sprintf("%v", this.Terminal) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HashPolicyType_HeaderName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HashPolicyType_HeaderName{`,
		`HeaderName:` + fmt.Sprintf("%v", this.HeaderName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HashPolicyType_Cookie) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HashPolicyType_Cookie{`,
		`Cookie:` + strings.Replace(fmt.Sprintf("%v", this.Cookie), "CookieForHashing", "CookieForHashing", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HashPolicyType_SourceIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HashPolicyType_SourceIp{`,
		`SourceIp:` + fmt.Sprintf("%v", this.SourceIp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteDestinationList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForDestinations := "[]*RouteDestination{"
	for _, f := range this.Destinations {
		repeatedStringForDestinations += strings.Replace(f.String(), "RouteDestination", "RouteDestination", 1) + ","
	}
	repeatedStringForDestinations += "}"
	repeatedStringForHashPolicy := "[]*HashPolicyType{"
	for _, f := range this.HashPolicy {
		repeatedStringForHashPolicy += strings.Replace(f.String(), "HashPolicyType", "HashPolicyType", 1) + ","
	}
	repeatedStringForHashPolicy += "}"
	keysForEndpointSubsets := make([]string, 0, len(this.EndpointSubsets))
	for k, _ := range this.EndpointSubsets {
		keysForEndpointSubsets = append(keysForEndpointSubsets, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEndpointSubsets)
	mapStringForEndpointSubsets := "map[string]string{"
	for _, k := range keysForEndpointSubsets {
		mapStringForEndpointSubsets += fmt.Sprintf("%v: %v,", k, this.EndpointSubsets[k])
	}
	mapStringForEndpointSubsets += "}"
	s := strings.Join([]string{`&RouteDestinationList{`,
		`Destinations:` + repeatedStringForDestinations + `,`,
		`PrefixRewrite:` + fmt.Sprintf("%v", this.PrefixRewrite) + `,`,
		`HostRewriteParams:` + fmt.Sprintf("%v", this.HostRewriteParams) + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`RetryPolicy:` + strings.Replace(fmt.Sprintf("%v", this.RetryPolicy), "RetryPolicyType", "schema.RetryPolicyType", 1) + `,`,
		`EndpointSubsets:` + mapStringForEndpointSubsets + `,`,
		`MirrorPolicy:` + strings.Replace(this.MirrorPolicy.String(), "MirrorPolicyType", "MirrorPolicyType", 1) + `,`,
		`WebSocketConfig:` + strings.Replace(this.WebSocketConfig.String(), "WebsocketConfigType", "WebsocketConfigType", 1) + `,`,
		`BufferPolicy:` + strings.Replace(fmt.Sprintf("%v", this.BufferPolicy), "BufferConfigType", "schema.BufferConfigType", 1) + `,`,
		`CorsPolicy:` + strings.Replace(fmt.Sprintf("%v", this.CorsPolicy), "CorsPolicy", "schema.CorsPolicy", 1) + `,`,
		`HashPolicy:` + repeatedStringForHashPolicy + `,`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`SpdyConfig:` + strings.Replace(this.SpdyConfig.String(), "SpdyConfigType", "SpdyConfigType", 1) + `,`,
		`ClusterRetractChoice:` + fmt.Sprintf("%v", this.ClusterRetractChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteDestinationList_HostRewrite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteDestinationList_HostRewrite{`,
		`HostRewrite:` + fmt.Sprintf("%v", this.HostRewrite) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteDestinationList_AutoHostRewrite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteDestinationList_AutoHostRewrite{`,
		`AutoHostRewrite:` + fmt.Sprintf("%v", this.AutoHostRewrite) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteDestinationList_RetractCluster) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteDestinationList_RetractCluster{`,
		`RetractCluster:` + strings.Replace(fmt.Sprintf("%v", this.RetractCluster), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteDestinationList_DoNotRetractCluster) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteDestinationList_DoNotRetractCluster{`,
		`DoNotRetractCluster:` + strings.Replace(fmt.Sprintf("%v", this.DoNotRetractCluster), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteQueryParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteQueryParams{`,
		`QueryParams:` + fmt.Sprintf("%v", this.QueryParams) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteRedirect) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteRedirect{`,
		`HostRedirect:` + fmt.Sprintf("%v", this.HostRedirect) + `,`,
		`PathRedirect:` + fmt.Sprintf("%v", this.PathRedirect) + `,`,
		`ProtoRedirect:` + fmt.Sprintf("%v", this.ProtoRedirect) + `,`,
		`QueryParams:` + fmt.Sprintf("%v", this.QueryParams) + `,`,
		`ResponseCode:` + fmt.Sprintf("%v", this.ResponseCode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteRedirect_StripQueryParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteRedirect_StripQueryParams{`,
		`StripQueryParams:` + strings.Replace(fmt.Sprintf("%v", this.StripQueryParams), "RouteQueryParams", "RouteQueryParams", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteRedirect_AllParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteRedirect_AllParams{`,
		`AllParams:` + fmt.Sprintf("%v", this.AllParams) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteRedirect_RetainAllParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteRedirect_RetainAllParams{`,
		`RetainAllParams:` + strings.Replace(fmt.Sprintf("%v", this.RetainAllParams), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteRedirect_RemoveAllParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteRedirect_RemoveAllParams{`,
		`RemoveAllParams:` + strings.Replace(fmt.Sprintf("%v", this.RemoveAllParams), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteDirectResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteDirectResponse{`,
		`ResponseCode:` + fmt.Sprintf("%v", this.ResponseCode) + `,`,
		`ResponseBody:` + fmt.Sprintf("%v", this.ResponseBody) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServicePolicyInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServicePolicyInfo{`,
		`Disable:` + fmt.Sprintf("%v", this.Disable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMatch := "[]*RouteMatch{"
	for _, f := range this.Match {
		repeatedStringForMatch += strings.Replace(fmt.Sprintf("%v", f), "RouteMatch", "schema.RouteMatch", 1) + ","
	}
	repeatedStringForMatch += "}"
	repeatedStringForRequestHeadersToAdd := "[]*HeaderManipulationOptionType{"
	for _, f := range this.RequestHeadersToAdd {
		repeatedStringForRequestHeadersToAdd += strings.Replace(fmt.Sprintf("%v", f), "HeaderManipulationOptionType", "schema.HeaderManipulationOptionType", 1) + ","
	}
	repeatedStringForRequestHeadersToAdd += "}"
	repeatedStringForResponseHeadersToAdd := "[]*HeaderManipulationOptionType{"
	for _, f := range this.ResponseHeadersToAdd {
		repeatedStringForResponseHeadersToAdd += strings.Replace(fmt.Sprintf("%v", f), "HeaderManipulationOptionType", "schema.HeaderManipulationOptionType", 1) + ","
	}
	repeatedStringForResponseHeadersToAdd += "}"
	s := strings.Join([]string{`&RouteType{`,
		`Match:` + repeatedStringForMatch + `,`,
		`RouteAction:` + fmt.Sprintf("%v", this.RouteAction) + `,`,
		`DisableCustomScript:` + fmt.Sprintf("%v", this.DisableCustomScript) + `,`,
		`RequestHeadersToAdd:` + repeatedStringForRequestHeadersToAdd + `,`,
		`ResponseHeadersToAdd:` + repeatedStringForResponseHeadersToAdd + `,`,
		`RequestHeadersToRemove:` + fmt.Sprintf("%v", this.RequestHeadersToRemove) + `,`,
		`ResponseHeadersToRemove:` + fmt.Sprintf("%v", this.ResponseHeadersToRemove) + `,`,
		`WafType:` + strings.Replace(fmt.Sprintf("%v", this.WafType), "WafType", "schema.WafType", 1) + `,`,
		`ServicePolicy:` + strings.Replace(this.ServicePolicy.String(), "ServicePolicyInfo", "ServicePolicyInfo", 1) + `,`,
		`DisableLocationAdd:` + fmt.Sprintf("%v", this.DisableLocationAdd) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteType_RouteDestination) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteType_RouteDestination{`,
		`RouteDestination:` + strings.Replace(fmt.Sprintf("%v", this.RouteDestination), "RouteDestinationList", "RouteDestinationList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteType_RouteRedirect) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteType_RouteRedirect{`,
		`RouteRedirect:` + strings.Replace(fmt.Sprintf("%v", this.RouteRedirect), "RouteRedirect", "RouteRedirect", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteType_RouteDirectResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteType_RouteDirectResponse{`,
		`RouteDirectResponse:` + strings.Replace(fmt.Sprintf("%v", this.RouteDirectResponse), "RouteDirectResponse", "RouteDirectResponse", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRoutes := "[]*RouteType{"
	for _, f := range this.Routes {
		repeatedStringForRoutes += strings.Replace(f.String(), "RouteType", "RouteType", 1) + ","
	}
	repeatedStringForRoutes += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Routes:` + repeatedStringForRoutes + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRoutes := "[]*RouteType{"
	for _, f := range this.Routes {
		repeatedStringForRoutes += strings.Replace(f.String(), "RouteType", "RouteType", 1) + ","
	}
	repeatedStringForRoutes += "}"
	s := strings.Join([]string{`&CreateSpecType{`,
		`Routes:` + repeatedStringForRoutes + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRoutes := "[]*RouteType{"
	for _, f := range this.Routes {
		repeatedStringForRoutes += strings.Replace(f.String(), "RouteType", "RouteType", 1) + ","
	}
	repeatedStringForRoutes += "}"
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Routes:` + repeatedStringForRoutes + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRoutes := "[]*RouteType{"
	for _, f := range this.Routes {
		repeatedStringForRoutes += strings.Replace(f.String(), "RouteType", "RouteType", 1) + ","
	}
	repeatedStringForRoutes += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`Routes:` + repeatedStringForRoutes + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *RouteDestination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteDestination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteDestination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cluster = append(m.Cluster, &schema.ObjectRefType{})
			if err := m.Cluster[len(m.Cluster)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointSubsets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndpointSubsets == nil {
				m.EndpointSubsets = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EndpointSubsets[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorPolicyType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorPolicyType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorPolicyType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cluster = append(m.Cluster, &schema.ObjectRefType{})
			if err := m.Cluster[len(m.Cluster)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Percent == nil {
				m.Percent = &schema.FractionalPercent{}
			}
			if err := m.Percent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpdyConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpdyConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpdyConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseSpdy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseSpdy = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebsocketConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebsocketConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebsocketConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseWebsocket", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseWebsocket = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeout", wireType)
			}
			m.IdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxConnectAttempts", wireType)
			}
			m.MaxConnectAttempts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxConnectAttempts |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CookieForHashing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CookieForHashing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CookieForHashing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HashPolicyType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HashPolicyType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HashPolicyType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PolicySpecifier = &HashPolicyType_HeaderName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookie", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CookieForHashing{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PolicySpecifier = &HashPolicyType_Cookie{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceIp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PolicySpecifier = &HashPolicyType_SourceIp{b}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terminal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Terminal = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteDestinationList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteDestinationList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteDestinationList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destinations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destinations = append(m.Destinations, &RouteDestination{})
			if err := m.Destinations[len(m.Destinations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixRewrite", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrefixRewrite = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostRewrite", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostRewriteParams = &RouteDestinationList_HostRewrite{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoHostRewrite", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.HostRewriteParams = &RouteDestinationList_AutoHostRewrite{b}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetryPolicy == nil {
				m.RetryPolicy = &schema.RetryPolicyType{}
			}
			if err := m.RetryPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointSubsets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndpointSubsets == nil {
				m.EndpointSubsets = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EndpointSubsets[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MirrorPolicy == nil {
				m.MirrorPolicy = &MirrorPolicyType{}
			}
			if err := m.MirrorPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebSocketConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WebSocketConfig == nil {
				m.WebSocketConfig = &WebsocketConfigType{}
			}
			if err := m.WebSocketConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BufferPolicy == nil {
				m.BufferPolicy = &schema.BufferConfigType{}
			}
			if err := m.BufferPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CorsPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CorsPolicy == nil {
				m.CorsPolicy = &schema.CorsPolicy{}
			}
			if err := m.CorsPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashPolicy = append(m.HashPolicy, &HashPolicyType{})
			if err := m.HashPolicy[len(m.HashPolicy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= schema.RoutingPriority(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpdyConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpdyConfig == nil {
				m.SpdyConfig = &SpdyConfigType{}
			}
			if err := m.SpdyConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetractCluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClusterRetractChoice = &RouteDestinationList_RetractCluster{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoNotRetractCluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClusterRetractChoice = &RouteDestinationList_DoNotRetractCluster{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteQueryParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteQueryParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteQueryParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParams", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryParams = append(m.QueryParams, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteRedirect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteRedirect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteRedirect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostRedirect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostRedirect = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathRedirect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathRedirect = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtoRedirect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtoRedirect = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StripQueryParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteQueryParams{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.QueryParams = &RouteRedirect_StripQueryParams{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllParams", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.QueryParams = &RouteRedirect_AllParams{b}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
			}
			m.ResponseCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetainAllParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.QueryParams = &RouteRedirect_RetainAllParams{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveAllParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.QueryParams = &RouteRedirect_RemoveAllParams{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteDirectResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteDirectResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteDirectResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
			}
			m.ResponseCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseBody", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseBody = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServicePolicyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServicePolicyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServicePolicyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Match = append(m.Match, &schema.RouteMatch{})
			if err := m.Match[len(m.Match)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteDestination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteDestinationList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RouteAction = &RouteType_RouteDestination{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteRedirect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteRedirect{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RouteAction = &RouteType_RouteRedirect{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteDirectResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteDirectResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RouteAction = &RouteType_RouteDirectResponse{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableCustomScript", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableCustomScript = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToAdd = append(m.RequestHeadersToAdd, &schema.HeaderManipulationOptionType{})
			if err := m.RequestHeadersToAdd[len(m.RequestHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToAdd = append(m.ResponseHeadersToAdd, &schema.HeaderManipulationOptionType{})
			if err := m.ResponseHeadersToAdd[len(m.ResponseHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToRemove = append(m.RequestHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToRemove = append(m.ResponseHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WafType == nil {
				m.WafType = &schema.WafType{}
			}
			if err := m.WafType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServicePolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServicePolicy == nil {
				m.ServicePolicy = &ServicePolicyInfo{}
			}
			if err := m.ServicePolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableLocationAdd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableLocationAdd = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &RouteType{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &RouteType{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &RouteType{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &RouteType{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
