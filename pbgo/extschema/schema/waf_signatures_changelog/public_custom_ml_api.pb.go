// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/waf_signatures_changelog/public_custom_ml_api.proto

// WAF signature related Custom APIs
//
// x-displayName: "WAF Signatures Changelog"
// WAF Signatures Changelog custom APIs

package waf_signatures_changelog

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/vesenv"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// StagedSignaturesReq
//
// x-displayName: "Staged Signatures Request"
// Request to get the list of all staged signatures
type StagedSignaturesReq struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "shared"
	// Fetch staged signatures for the given namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// vh_name
	//
	// x-displayName: "Virtual Host Name"
	// x-example: "blogging-app"
	// Virtual Host for current request
	VhName string `protobuf:"bytes,2,opt,name=vh_name,json=vhName,proto3" json:"vh_name,omitempty"`
	// start_time
	//
	// x-displayName: "Start Time"
	// x-example: "2019-09-23T12:30:11.733Z"
	// Fetch staged signatures whose timestamp >= start_time
	// format: unix_timestamp|rfc 3339
	StartTime string `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// end_time
	//
	// x-displayName: "End Time"
	// x-example: "2019-09-23T12:30:11.733Z"
	// Fetch staged signatures whose timestamp <= end_time
	// format: unix_timestamp|rfc 3339
	EndTime string `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
}

func (m *StagedSignaturesReq) Reset()      { *m = StagedSignaturesReq{} }
func (*StagedSignaturesReq) ProtoMessage() {}
func (*StagedSignaturesReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_758855b686288de9, []int{0}
}
func (m *StagedSignaturesReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StagedSignaturesReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StagedSignaturesReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StagedSignaturesReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StagedSignaturesReq.Merge(m, src)
}
func (m *StagedSignaturesReq) XXX_Size() int {
	return m.Size()
}
func (m *StagedSignaturesReq) XXX_DiscardUnknown() {
	xxx_messageInfo_StagedSignaturesReq.DiscardUnknown(m)
}

var xxx_messageInfo_StagedSignaturesReq proto.InternalMessageInfo

func (m *StagedSignaturesReq) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *StagedSignaturesReq) GetVhName() string {
	if m != nil {
		return m.VhName
	}
	return ""
}

func (m *StagedSignaturesReq) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *StagedSignaturesReq) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

// StagedSignaturesRsp
//
// x-displayName: "Staged Signatures Response"
// Response to get the list of all staged signatures
type StagedSignaturesRsp struct {
	//staged_signatures
	//
	// x-displayName: "Staged Signatures"
	// List of staged signatures
	StagedSignatures []*StagedSignature `protobuf:"bytes,1,rep,name=staged_signatures,json=stagedSignatures,proto3" json:"staged_signatures,omitempty"`
}

func (m *StagedSignaturesRsp) Reset()      { *m = StagedSignaturesRsp{} }
func (*StagedSignaturesRsp) ProtoMessage() {}
func (*StagedSignaturesRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_758855b686288de9, []int{1}
}
func (m *StagedSignaturesRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StagedSignaturesRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StagedSignaturesRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StagedSignaturesRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StagedSignaturesRsp.Merge(m, src)
}
func (m *StagedSignaturesRsp) XXX_Size() int {
	return m.Size()
}
func (m *StagedSignaturesRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_StagedSignaturesRsp.DiscardUnknown(m)
}

var xxx_messageInfo_StagedSignaturesRsp proto.InternalMessageInfo

func (m *StagedSignaturesRsp) GetStagedSignatures() []*StagedSignature {
	if m != nil {
		return m.StagedSignatures
	}
	return nil
}

// StagedSignature
//
// x-displayName: "Staged Signature"
// Staged signature details
type StagedSignature struct {
	// attack_type
	//
	// x-displayName: "Attack Type"
	// x-example: "Server Side Code Injection"
	// The Signature Attack Type
	AttackType string `protobuf:"bytes,1,opt,name=attack_type,json=attackType,proto3" json:"attack_type,omitempty"`
	// matching_info
	//
	// x-displayName: "Matching Info"
	// x-example: "Matched 16 characters on offset 22 against value: '/ontransitionrun/abbc/ontransitionrun='. "
	// Request details for the matched signature
	MatchingInfo string `protobuf:"bytes,2,opt,name=matching_info,json=matchingInfo,proto3" json:"matching_info,omitempty"`
	// context
	//
	// x-displayName: "Context"
	// Context of the signature detected.
	Context string `protobuf:"bytes,3,opt,name=context,proto3" json:"context,omitempty"`
	// name
	//
	// x-displayName: "Name"
	// x-example: "Java code injection FreeMarker - objectWrapper (URI)"
	// Detected signature name
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// accuracy
	//
	// x-displayName: "Accuracy"
	// x-example: "Medium"
	// Detected signature accuracy
	Accuracy string `protobuf:"bytes,5,opt,name=accuracy,proto3" json:"accuracy,omitempty"`
	// id
	//
	// x-displayName: "ID"
	// x-example: "200104853"
	// Detected signature id
	Id string `protobuf:"bytes,6,opt,name=id,proto3" json:"id,omitempty"`
	// state
	//
	// x-displayName: "State"
	// x-example: "Staged"
	// State of the signature
	State string `protobuf:"bytes,7,opt,name=state,proto3" json:"state,omitempty"`
	// id_name
	//
	// x-displayName: "Id name"
	// x-example: "200101746, ontransitionrun (URI)"
	// Signature Id name
	IdName string `protobuf:"bytes,8,opt,name=id_name,json=idName,proto3" json:"id_name,omitempty"`
	// count
	//
	// x-displayName: "Count"
	// x-example: "5"
	// Number of times signature detected in traffic
	Count int32 `protobuf:"varint,9,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *StagedSignature) Reset()      { *m = StagedSignature{} }
func (*StagedSignature) ProtoMessage() {}
func (*StagedSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_758855b686288de9, []int{2}
}
func (m *StagedSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StagedSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StagedSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StagedSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StagedSignature.Merge(m, src)
}
func (m *StagedSignature) XXX_Size() int {
	return m.Size()
}
func (m *StagedSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_StagedSignature.DiscardUnknown(m)
}

var xxx_messageInfo_StagedSignature proto.InternalMessageInfo

func (m *StagedSignature) GetAttackType() string {
	if m != nil {
		return m.AttackType
	}
	return ""
}

func (m *StagedSignature) GetMatchingInfo() string {
	if m != nil {
		return m.MatchingInfo
	}
	return ""
}

func (m *StagedSignature) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

func (m *StagedSignature) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *StagedSignature) GetAccuracy() string {
	if m != nil {
		return m.Accuracy
	}
	return ""
}

func (m *StagedSignature) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *StagedSignature) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *StagedSignature) GetIdName() string {
	if m != nil {
		return m.IdName
	}
	return ""
}

func (m *StagedSignature) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func init() {
	proto.RegisterType((*StagedSignaturesReq)(nil), "ves.io.schema.waf_signatures_changelog.StagedSignaturesReq")
	golang_proto.RegisterType((*StagedSignaturesReq)(nil), "ves.io.schema.waf_signatures_changelog.StagedSignaturesReq")
	proto.RegisterType((*StagedSignaturesRsp)(nil), "ves.io.schema.waf_signatures_changelog.StagedSignaturesRsp")
	golang_proto.RegisterType((*StagedSignaturesRsp)(nil), "ves.io.schema.waf_signatures_changelog.StagedSignaturesRsp")
	proto.RegisterType((*StagedSignature)(nil), "ves.io.schema.waf_signatures_changelog.StagedSignature")
	golang_proto.RegisterType((*StagedSignature)(nil), "ves.io.schema.waf_signatures_changelog.StagedSignature")
}

func init() {
	proto.RegisterFile("ves.io/schema/waf_signatures_changelog/public_custom_ml_api.proto", fileDescriptor_758855b686288de9)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/waf_signatures_changelog/public_custom_ml_api.proto", fileDescriptor_758855b686288de9)
}

var fileDescriptor_758855b686288de9 = []byte{
	// 709 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xbf, 0x6f, 0xd4, 0x48,
	0x14, 0xde, 0x71, 0xb2, 0xd9, 0x64, 0x72, 0x3f, 0x27, 0x91, 0xce, 0xb7, 0x97, 0xf3, 0xad, 0xf6,
	0xa4, 0x53, 0x74, 0xc2, 0x1e, 0x14, 0x84, 0x90, 0x48, 0x15, 0x28, 0x80, 0x02, 0x90, 0x36, 0xa9,
	0x10, 0x92, 0x35, 0x6b, 0xcf, 0x7a, 0x87, 0xac, 0x67, 0x06, 0xcf, 0xd8, 0x49, 0x14, 0x45, 0x42,
	0x29, 0x28, 0xa8, 0x90, 0x90, 0xa8, 0xf8, 0x03, 0xf8, 0x13, 0x90, 0xd2, 0xa4, 0x23, 0x15, 0x8a,
	0xa0, 0x49, 0x49, 0xbc, 0x14, 0x94, 0xa9, 0xa8, 0xd1, 0x8e, 0x9d, 0x25, 0x59, 0x40, 0x44, 0xe9,
	0xde, 0xf7, 0x7d, 0xf3, 0x9e, 0xfd, 0xbe, 0xf7, 0x66, 0xe0, 0x52, 0x46, 0x95, 0xc7, 0x04, 0x56,
	0x41, 0x97, 0xc6, 0x04, 0xaf, 0x91, 0x8e, 0xaf, 0x58, 0xc4, 0x89, 0x4e, 0x13, 0xaa, 0xfc, 0xa0,
	0x4b, 0x78, 0x44, 0x7b, 0x22, 0xc2, 0x32, 0x6d, 0xf7, 0x58, 0xe0, 0x07, 0xa9, 0xd2, 0x22, 0xf6,
	0xe3, 0x9e, 0x4f, 0x24, 0xf3, 0x64, 0x22, 0xb4, 0x40, 0xff, 0x15, 0x25, 0xbc, 0xa2, 0x84, 0xf7,
	0xbd, 0x12, 0x75, 0x37, 0x62, 0xba, 0x9b, 0xb6, 0xbd, 0x40, 0xc4, 0x38, 0x12, 0x91, 0xc0, 0x26,
	0xbd, 0x9d, 0x76, 0x0c, 0x32, 0xc0, 0x44, 0x45, 0xd9, 0xfa, 0x5c, 0x24, 0x44, 0xd4, 0xa3, 0x98,
	0x48, 0x86, 0x09, 0xe7, 0x42, 0x13, 0xcd, 0x04, 0x57, 0xa5, 0xfa, 0xd7, 0xe9, 0xff, 0x16, 0xf2,
	0xa4, 0xd8, 0x3c, 0x2d, 0x66, 0x54, 0x51, 0x9e, 0x8d, 0x9c, 0x59, 0x38, 0x63, 0xe3, 0x7a, 0x43,
	0xd2, 0x32, 0xa7, 0xf9, 0x18, 0xc0, 0x99, 0x65, 0x4d, 0x22, 0x1a, 0x2e, 0x0f, 0x8f, 0xb6, 0xe8,
	0x43, 0x34, 0x07, 0xa7, 0x38, 0x89, 0xa9, 0x92, 0x24, 0xa0, 0x36, 0x68, 0x80, 0xf9, 0xa9, 0xd6,
	0x17, 0x02, 0xfd, 0x01, 0x6b, 0x59, 0xd7, 0x1f, 0x60, 0xdb, 0x32, 0xda, 0x44, 0xd6, 0xbd, 0x43,
	0x62, 0x8a, 0xfe, 0x86, 0x50, 0x69, 0x92, 0x68, 0x5f, 0xb3, 0x98, 0xda, 0x63, 0x45, 0x9e, 0x61,
	0x56, 0x58, 0x4c, 0xd1, 0x9f, 0x70, 0x92, 0xf2, 0xb0, 0x10, 0xc7, 0x8d, 0x58, 0xa3, 0x3c, 0x1c,
	0x48, 0xcd, 0xcd, 0x6f, 0xfc, 0x87, 0x92, 0x28, 0x84, 0xbf, 0x2b, 0x43, 0x9f, 0x68, 0xc5, 0x06,
	0x8d, 0xb1, 0xf9, 0xe9, 0x85, 0x2b, 0xde, 0xd9, 0xa6, 0xe4, 0x8d, 0xd4, 0x6d, 0xfd, 0xa6, 0x46,
	0x3e, 0xd4, 0xfc, 0x04, 0xe0, 0xaf, 0x23, 0xa7, 0xd0, 0x3f, 0x70, 0x9a, 0x68, 0x4d, 0x82, 0x55,
	0x7f, 0xe0, 0x57, 0xe9, 0x01, 0x2c, 0xa8, 0x95, 0x0d, 0x49, 0xd1, 0xbf, 0xf0, 0xe7, 0x98, 0xe8,
	0xa0, 0xcb, 0x78, 0xe4, 0x33, 0xde, 0x11, 0xa5, 0x15, 0x3f, 0x1d, 0x93, 0xb7, 0x78, 0x47, 0x20,
	0x1b, 0xd6, 0x02, 0xc1, 0x35, 0x5d, 0xd7, 0xa5, 0x1b, 0xc7, 0x10, 0x21, 0x38, 0x6e, 0x0c, 0x2c,
	0x7c, 0x30, 0x31, 0xaa, 0xc3, 0x49, 0x12, 0x04, 0x69, 0x42, 0x82, 0x0d, 0xbb, 0x6a, 0xf8, 0x21,
	0x46, 0xbf, 0x40, 0x8b, 0x85, 0xf6, 0x84, 0x61, 0x2d, 0x16, 0xa2, 0x59, 0x58, 0x55, 0x9a, 0x68,
	0x6a, 0xd7, 0x0c, 0x55, 0x80, 0xc1, 0x64, 0x58, 0x58, 0x4c, 0x66, 0xb2, 0x98, 0x0c, 0x0b, 0xcd,
	0x64, 0x66, 0x61, 0x35, 0x10, 0x29, 0xd7, 0xf6, 0x54, 0x03, 0xcc, 0x57, 0x5b, 0x05, 0x58, 0x38,
	0xb2, 0x20, 0x1a, 0xb6, 0x7c, 0xdd, 0xdc, 0x84, 0x25, 0xc9, 0xd0, 0x0b, 0x0b, 0xce, 0xdc, 0xa0,
	0x7a, 0x74, 0x20, 0x68, 0xf1, 0x9c, 0x96, 0x0f, 0x56, 0xaa, 0x7e, 0xfe, 0x64, 0x25, 0x9b, 0x4f,
	0xc0, 0xde, 0x2b, 0x0b, 0xe4, 0xaf, 0x6d, 0xdc, 0xb9, 0xbc, 0x1e, 0xb8, 0x6b, 0x84, 0x48, 0x57,
	0x69, 0xc2, 0x43, 0x92, 0x84, 0x6e, 0x2c, 0x38, 0xd3, 0x22, 0xb9, 0xd0, 0xc8, 0xa8, 0x72, 0x99,
	0x70, 0x23, 0xca, 0x69, 0x42, 0x7a, 0x6e, 0x42, 0x49, 0xb8, 0xfd, 0xee, 0xc3, 0x33, 0xeb, 0x76,
	0xf3, 0x66, 0x79, 0xdd, 0xf1, 0x70, 0x89, 0x15, 0xde, 0x1c, 0xc6, 0x5b, 0x38, 0x63, 0x89, 0x4e,
	0x49, 0xcf, 0xef, 0x0a, 0xa5, 0x15, 0xde, 0x2c, 0xb7, 0x7b, 0x0b, 0x7f, 0xb5, 0x7c, 0x57, 0xc1,
	0xff, 0xf5, 0xc5, 0xdd, 0x1d, 0x30, 0xf6, 0x76, 0x07, 0xb8, 0x67, 0x6c, 0xe8, 0x6e, 0xfb, 0x01,
	0x0d, 0xf4, 0xf6, 0x1b, 0xdb, 0xba, 0x08, 0xae, 0x3d, 0x07, 0xfb, 0x87, 0x4e, 0xe5, 0xe0, 0xd0,
	0xa9, 0x1c, 0x1d, 0x3a, 0xe0, 0x51, 0xee, 0x80, 0x97, 0xb9, 0x03, 0xf6, 0x72, 0x07, 0xec, 0xe7,
	0x0e, 0x78, 0x9f, 0x3b, 0xe0, 0x63, 0xee, 0x54, 0x8e, 0x72, 0x07, 0x3c, 0xed, 0x3b, 0x95, 0xdd,
	0xbe, 0x03, 0xf6, 0xfb, 0x4e, 0xe5, 0xa0, 0xef, 0x54, 0xee, 0xdd, 0x8f, 0x84, 0x5c, 0x8d, 0xbc,
	0x4c, 0xf4, 0x34, 0x4d, 0x12, 0xe2, 0xa5, 0x0a, 0x9b, 0xa0, 0x23, 0x92, 0xd8, 0x95, 0x89, 0xc8,
	0x58, 0x48, 0x13, 0xf7, 0x58, 0xc6, 0xb2, 0x1d, 0x09, 0x4c, 0xd7, 0x75, 0xf9, 0x1e, 0xfc, 0xe0,
	0x59, 0x68, 0x4f, 0x98, 0x17, 0xe1, 0xd2, 0xe7, 0x00, 0x00, 0x00, 0xff, 0xff, 0x06, 0x1b, 0xcb,
	0x8f, 0x40, 0x05, 0x00, 0x00,
}

func (this *StagedSignaturesReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StagedSignaturesReq)
	if !ok {
		that2, ok := that.(StagedSignaturesReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.VhName != that1.VhName {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.EndTime != that1.EndTime {
		return false
	}
	return true
}
func (this *StagedSignaturesRsp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StagedSignaturesRsp)
	if !ok {
		that2, ok := that.(StagedSignaturesRsp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.StagedSignatures) != len(that1.StagedSignatures) {
		return false
	}
	for i := range this.StagedSignatures {
		if !this.StagedSignatures[i].Equal(that1.StagedSignatures[i]) {
			return false
		}
	}
	return true
}
func (this *StagedSignature) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StagedSignature)
	if !ok {
		that2, ok := that.(StagedSignature)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AttackType != that1.AttackType {
		return false
	}
	if this.MatchingInfo != that1.MatchingInfo {
		return false
	}
	if this.Context != that1.Context {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Accuracy != that1.Accuracy {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.IdName != that1.IdName {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	return true
}
func (this *StagedSignaturesReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&waf_signatures_changelog.StagedSignaturesReq{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "VhName: "+fmt.Sprintf("%#v", this.VhName)+",\n")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StagedSignaturesRsp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&waf_signatures_changelog.StagedSignaturesRsp{")
	if this.StagedSignatures != nil {
		s = append(s, "StagedSignatures: "+fmt.Sprintf("%#v", this.StagedSignatures)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StagedSignature) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&waf_signatures_changelog.StagedSignature{")
	s = append(s, "AttackType: "+fmt.Sprintf("%#v", this.AttackType)+",\n")
	s = append(s, "MatchingInfo: "+fmt.Sprintf("%#v", this.MatchingInfo)+",\n")
	s = append(s, "Context: "+fmt.Sprintf("%#v", this.Context)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Accuracy: "+fmt.Sprintf("%#v", this.Accuracy)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "IdName: "+fmt.Sprintf("%#v", this.IdName)+",\n")
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringPublicCustomMlApi(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SignatureCustomApiClient is the client API for SignatureCustomApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SignatureCustomApiClient interface {
	// GetStagedSignatures
	//
	// x-displayName: "Staged Signatures"
	// API to get Staged Signatures
	GetStagedSignatures(ctx context.Context, in *StagedSignaturesReq, opts ...grpc.CallOption) (*StagedSignaturesRsp, error)
}

type signatureCustomApiClient struct {
	cc *grpc.ClientConn
}

func NewSignatureCustomApiClient(cc *grpc.ClientConn) SignatureCustomApiClient {
	return &signatureCustomApiClient{cc}
}

func (c *signatureCustomApiClient) GetStagedSignatures(ctx context.Context, in *StagedSignaturesReq, opts ...grpc.CallOption) (*StagedSignaturesRsp, error) {
	out := new(StagedSignaturesRsp)
	err := c.cc.Invoke(ctx, "/ves.io.schema.waf_signatures_changelog.SignatureCustomApi/GetStagedSignatures", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SignatureCustomApiServer is the server API for SignatureCustomApi service.
type SignatureCustomApiServer interface {
	// GetStagedSignatures
	//
	// x-displayName: "Staged Signatures"
	// API to get Staged Signatures
	GetStagedSignatures(context.Context, *StagedSignaturesReq) (*StagedSignaturesRsp, error)
}

// UnimplementedSignatureCustomApiServer can be embedded to have forward compatible implementations.
type UnimplementedSignatureCustomApiServer struct {
}

func (*UnimplementedSignatureCustomApiServer) GetStagedSignatures(ctx context.Context, req *StagedSignaturesReq) (*StagedSignaturesRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStagedSignatures not implemented")
}

func RegisterSignatureCustomApiServer(s *grpc.Server, srv SignatureCustomApiServer) {
	s.RegisterService(&_SignatureCustomApi_serviceDesc, srv)
}

func _SignatureCustomApi_GetStagedSignatures_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StagedSignaturesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignatureCustomApiServer).GetStagedSignatures(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.waf_signatures_changelog.SignatureCustomApi/GetStagedSignatures",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignatureCustomApiServer).GetStagedSignatures(ctx, req.(*StagedSignaturesReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _SignatureCustomApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ves.io.schema.waf_signatures_changelog.SignatureCustomApi",
	HandlerType: (*SignatureCustomApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetStagedSignatures",
			Handler:    _SignatureCustomApi_GetStagedSignatures_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ves.io/schema/waf_signatures_changelog/public_custom_ml_api.proto",
}

func (m *StagedSignaturesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StagedSignaturesReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StagedSignaturesReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintPublicCustomMlApi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicCustomMlApi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.VhName) > 0 {
		i -= len(m.VhName)
		copy(dAtA[i:], m.VhName)
		i = encodeVarintPublicCustomMlApi(dAtA, i, uint64(len(m.VhName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomMlApi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StagedSignaturesRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StagedSignaturesRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StagedSignaturesRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StagedSignatures) > 0 {
		for iNdEx := len(m.StagedSignatures) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StagedSignatures[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomMlApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StagedSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StagedSignature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StagedSignature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintPublicCustomMlApi(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x48
	}
	if len(m.IdName) > 0 {
		i -= len(m.IdName)
		copy(dAtA[i:], m.IdName)
		i = encodeVarintPublicCustomMlApi(dAtA, i, uint64(len(m.IdName)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintPublicCustomMlApi(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPublicCustomMlApi(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Accuracy) > 0 {
		i -= len(m.Accuracy)
		copy(dAtA[i:], m.Accuracy)
		i = encodeVarintPublicCustomMlApi(dAtA, i, uint64(len(m.Accuracy)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPublicCustomMlApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Context) > 0 {
		i -= len(m.Context)
		copy(dAtA[i:], m.Context)
		i = encodeVarintPublicCustomMlApi(dAtA, i, uint64(len(m.Context)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MatchingInfo) > 0 {
		i -= len(m.MatchingInfo)
		copy(dAtA[i:], m.MatchingInfo)
		i = encodeVarintPublicCustomMlApi(dAtA, i, uint64(len(m.MatchingInfo)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AttackType) > 0 {
		i -= len(m.AttackType)
		copy(dAtA[i:], m.AttackType)
		i = encodeVarintPublicCustomMlApi(dAtA, i, uint64(len(m.AttackType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPublicCustomMlApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovPublicCustomMlApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *StagedSignaturesReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomMlApi(uint64(l))
	}
	l = len(m.VhName)
	if l > 0 {
		n += 1 + l + sovPublicCustomMlApi(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomMlApi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomMlApi(uint64(l))
	}
	return n
}

func (m *StagedSignaturesRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StagedSignatures) > 0 {
		for _, e := range m.StagedSignatures {
			l = e.Size()
			n += 1 + l + sovPublicCustomMlApi(uint64(l))
		}
	}
	return n
}

func (m *StagedSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AttackType)
	if l > 0 {
		n += 1 + l + sovPublicCustomMlApi(uint64(l))
	}
	l = len(m.MatchingInfo)
	if l > 0 {
		n += 1 + l + sovPublicCustomMlApi(uint64(l))
	}
	l = len(m.Context)
	if l > 0 {
		n += 1 + l + sovPublicCustomMlApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPublicCustomMlApi(uint64(l))
	}
	l = len(m.Accuracy)
	if l > 0 {
		n += 1 + l + sovPublicCustomMlApi(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPublicCustomMlApi(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovPublicCustomMlApi(uint64(l))
	}
	l = len(m.IdName)
	if l > 0 {
		n += 1 + l + sovPublicCustomMlApi(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovPublicCustomMlApi(uint64(m.Count))
	}
	return n
}

func sovPublicCustomMlApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPublicCustomMlApi(x uint64) (n int) {
	return sovPublicCustomMlApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *StagedSignaturesReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StagedSignaturesReq{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`VhName:` + fmt.Sprintf("%v", this.VhName) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`EndTime:` + fmt.Sprintf("%v", this.EndTime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StagedSignaturesRsp) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForStagedSignatures := "[]*StagedSignature{"
	for _, f := range this.StagedSignatures {
		repeatedStringForStagedSignatures += strings.Replace(f.String(), "StagedSignature", "StagedSignature", 1) + ","
	}
	repeatedStringForStagedSignatures += "}"
	s := strings.Join([]string{`&StagedSignaturesRsp{`,
		`StagedSignatures:` + repeatedStringForStagedSignatures + `,`,
		`}`,
	}, "")
	return s
}
func (this *StagedSignature) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StagedSignature{`,
		`AttackType:` + fmt.Sprintf("%v", this.AttackType) + `,`,
		`MatchingInfo:` + fmt.Sprintf("%v", this.MatchingInfo) + `,`,
		`Context:` + fmt.Sprintf("%v", this.Context) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Accuracy:` + fmt.Sprintf("%v", this.Accuracy) + `,`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`IdName:` + fmt.Sprintf("%v", this.IdName) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringPublicCustomMlApi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *StagedSignaturesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomMlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StagedSignaturesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StagedSignaturesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomMlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VhName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomMlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VhName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomMlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomMlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomMlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StagedSignaturesRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomMlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StagedSignaturesRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StagedSignaturesRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StagedSignatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomMlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StagedSignatures = append(m.StagedSignatures, &StagedSignature{})
			if err := m.StagedSignatures[len(m.StagedSignatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomMlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StagedSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomMlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StagedSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StagedSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomMlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttackType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchingInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomMlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchingInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomMlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomMlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accuracy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomMlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Accuracy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomMlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomMlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomMlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomMlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomMlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomMlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPublicCustomMlApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPublicCustomMlApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPublicCustomMlApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPublicCustomMlApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPublicCustomMlApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPublicCustomMlApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPublicCustomMlApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPublicCustomMlApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPublicCustomMlApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPublicCustomMlApi = fmt.Errorf("proto: unexpected end of group")
)
