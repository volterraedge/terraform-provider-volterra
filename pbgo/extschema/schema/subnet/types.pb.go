// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/subnet/types.proto

package subnet

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	network_interface "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/network_interface"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SubnetDHCPServerParametersType
//
// x-displayName: "Subnet DHCP server parameters"
// Subnet object DHCP server parameters. This is only stored
// in the db and is not used in the CreateSpec. The CreateSpec
// will contain a subset of the DHCP parameters in this
// message, which corresponds to the parameters currently
// supported by the subnet object.
type SubnetDHCPServerParametersType struct {
	// site reference
	//
	// x-displayName: "Site"
	// Site that the DHCP parameters are for
	Site []*schema.ObjectRefType `protobuf:"bytes,3,rep,name=site,proto3" json:"site,omitempty"`
	// Site DHCP server parameters
	//
	// x-displayName: "Site DHCP server parameters"
	// DHCP parameters for a subnet on a site. This reuses the
	// DHCPServerParametersType from network_interface.
	SubnetDhcpServerParams *network_interface.DHCPServerParametersType `protobuf:"bytes,2,opt,name=subnet_dhcp_server_params,json=subnetDhcpServerParams,proto3" json:"subnet_dhcp_server_params,omitempty"`
}

func (m *SubnetDHCPServerParametersType) Reset()      { *m = SubnetDHCPServerParametersType{} }
func (*SubnetDHCPServerParametersType) ProtoMessage() {}
func (*SubnetDHCPServerParametersType) Descriptor() ([]byte, []int) {
	return fileDescriptor_964a9ec4edc9fd55, []int{0}
}
func (m *SubnetDHCPServerParametersType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubnetDHCPServerParametersType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SubnetDHCPServerParametersType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubnetDHCPServerParametersType.Merge(m, src)
}
func (m *SubnetDHCPServerParametersType) XXX_Size() int {
	return m.Size()
}
func (m *SubnetDHCPServerParametersType) XXX_DiscardUnknown() {
	xxx_messageInfo_SubnetDHCPServerParametersType.DiscardUnknown(m)
}

var xxx_messageInfo_SubnetDHCPServerParametersType proto.InternalMessageInfo

func (m *SubnetDHCPServerParametersType) GetSite() []*schema.ObjectRefType {
	if m != nil {
		return m.Site
	}
	return nil
}

func (m *SubnetDHCPServerParametersType) GetSubnetDhcpServerParams() *network_interface.DHCPServerParametersType {
	if m != nil {
		return m.SubnetDhcpServerParams
	}
	return nil
}

// DHCPNetworkType
//
// x-displayName: "DHCP Network"
// DHCPNetworkType will be a subset of network_interface.DHCPNetworkType
type DHCPNetworkType struct {
	// Network Prefix choice
	//
	// x-displayName: "Subnet Network Prefix"
	// DHCP network prefix for subnet
	//
	// Types that are valid to be assigned to NetworkPrefixChoice:
	//	*DHCPNetworkType_NetworkPrefix
	//	*DHCPNetworkType_NetworkPrefixIpv6
	NetworkPrefixChoice isDHCPNetworkType_NetworkPrefixChoice `protobuf_oneof:"network_prefix_choice"`
}

func (m *DHCPNetworkType) Reset()      { *m = DHCPNetworkType{} }
func (*DHCPNetworkType) ProtoMessage() {}
func (*DHCPNetworkType) Descriptor() ([]byte, []int) {
	return fileDescriptor_964a9ec4edc9fd55, []int{1}
}
func (m *DHCPNetworkType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHCPNetworkType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DHCPNetworkType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHCPNetworkType.Merge(m, src)
}
func (m *DHCPNetworkType) XXX_Size() int {
	return m.Size()
}
func (m *DHCPNetworkType) XXX_DiscardUnknown() {
	xxx_messageInfo_DHCPNetworkType.DiscardUnknown(m)
}

var xxx_messageInfo_DHCPNetworkType proto.InternalMessageInfo

type isDHCPNetworkType_NetworkPrefixChoice interface {
	isDHCPNetworkType_NetworkPrefixChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DHCPNetworkType_NetworkPrefix struct {
	NetworkPrefix string `protobuf:"bytes,2,opt,name=network_prefix,json=networkPrefix,proto3,oneof" json:"network_prefix,omitempty"`
}
type DHCPNetworkType_NetworkPrefixIpv6 struct {
	NetworkPrefixIpv6 string `protobuf:"bytes,3,opt,name=network_prefix_ipv6,json=networkPrefixIpv6,proto3,oneof" json:"network_prefix_ipv6,omitempty"`
}

func (*DHCPNetworkType_NetworkPrefix) isDHCPNetworkType_NetworkPrefixChoice()     {}
func (*DHCPNetworkType_NetworkPrefixIpv6) isDHCPNetworkType_NetworkPrefixChoice() {}

func (m *DHCPNetworkType) GetNetworkPrefixChoice() isDHCPNetworkType_NetworkPrefixChoice {
	if m != nil {
		return m.NetworkPrefixChoice
	}
	return nil
}

func (m *DHCPNetworkType) GetNetworkPrefix() string {
	if x, ok := m.GetNetworkPrefixChoice().(*DHCPNetworkType_NetworkPrefix); ok {
		return x.NetworkPrefix
	}
	return ""
}

func (m *DHCPNetworkType) GetNetworkPrefixIpv6() string {
	if x, ok := m.GetNetworkPrefixChoice().(*DHCPNetworkType_NetworkPrefixIpv6); ok {
		return x.NetworkPrefixIpv6
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DHCPNetworkType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DHCPNetworkType_NetworkPrefix)(nil),
		(*DHCPNetworkType_NetworkPrefixIpv6)(nil),
	}
}

// DHCPServerParametersType
//
// x-displayName: "Subnet DHCP parameters"
// Subnet DHCP parameters will be a subset of network_interface.DHCPServerParametersType as all
// features in network_interface.DHCPServerParametersType may not be supported in a subnet.
type DHCPServerParametersType struct {
	// Subnet DHCP Networks
	//
	// x-displayName: "Subnet DHCP Networks"
	// List of networks from which DHCP server can allocate IP addresses
	DhcpNetworks []*DHCPNetworkType `protobuf:"bytes,1,rep,name=dhcp_networks,json=dhcpNetworks,proto3" json:"dhcp_networks,omitempty"`
}

func (m *DHCPServerParametersType) Reset()      { *m = DHCPServerParametersType{} }
func (*DHCPServerParametersType) ProtoMessage() {}
func (*DHCPServerParametersType) Descriptor() ([]byte, []int) {
	return fileDescriptor_964a9ec4edc9fd55, []int{2}
}
func (m *DHCPServerParametersType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHCPServerParametersType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DHCPServerParametersType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHCPServerParametersType.Merge(m, src)
}
func (m *DHCPServerParametersType) XXX_Size() int {
	return m.Size()
}
func (m *DHCPServerParametersType) XXX_DiscardUnknown() {
	xxx_messageInfo_DHCPServerParametersType.DiscardUnknown(m)
}

var xxx_messageInfo_DHCPServerParametersType proto.InternalMessageInfo

func (m *DHCPServerParametersType) GetDhcpNetworks() []*DHCPNetworkType {
	if m != nil {
		return m.DhcpNetworks
	}
	return nil
}

// Subnet object create spec type
//
// x-displayName: "Create site subnet object"
// Subnet create config for a site
type SiteSubnetParametersType struct {
	// site reference
	//
	// x-displayName: "Site"
	// x-required
	// Site that the subnet parameters are for
	Site *views.ObjectRefType `protobuf:"bytes,1,opt,name=site,proto3" json:"site,omitempty"`
	// Subnet DHCP server parameters
	//
	// x-displayName: "Site DHCP Server Parameters"
	// DHCP parameters for a subnet on a site
	SubnetDhcpServerParams *DHCPServerParametersType `protobuf:"bytes,2,opt,name=subnet_dhcp_server_params,json=subnetDhcpServerParams,proto3" json:"subnet_dhcp_server_params,omitempty"`
	// Subnet IP Addressing
	//
	// x-displayName: "Select Subnet IP Addressing Method"
	// Select whether IP addresses are allocated statically or using DHCP
	//
	// Types that are valid to be assigned to AddressChoice:
	//	*SiteSubnetParametersType_Dhcp
	//	*SiteSubnetParametersType_StaticIp
	AddressChoice isSiteSubnetParametersType_AddressChoice `protobuf_oneof:"address_choice"`
}

func (m *SiteSubnetParametersType) Reset()      { *m = SiteSubnetParametersType{} }
func (*SiteSubnetParametersType) ProtoMessage() {}
func (*SiteSubnetParametersType) Descriptor() ([]byte, []int) {
	return fileDescriptor_964a9ec4edc9fd55, []int{3}
}
func (m *SiteSubnetParametersType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SiteSubnetParametersType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SiteSubnetParametersType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SiteSubnetParametersType.Merge(m, src)
}
func (m *SiteSubnetParametersType) XXX_Size() int {
	return m.Size()
}
func (m *SiteSubnetParametersType) XXX_DiscardUnknown() {
	xxx_messageInfo_SiteSubnetParametersType.DiscardUnknown(m)
}

var xxx_messageInfo_SiteSubnetParametersType proto.InternalMessageInfo

type isSiteSubnetParametersType_AddressChoice interface {
	isSiteSubnetParametersType_AddressChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type SiteSubnetParametersType_Dhcp struct {
	Dhcp *schema.Empty `protobuf:"bytes,4,opt,name=dhcp,proto3,oneof" json:"dhcp,omitempty"`
}
type SiteSubnetParametersType_StaticIp struct {
	StaticIp *schema.Empty `protobuf:"bytes,5,opt,name=static_ip,json=staticIp,proto3,oneof" json:"static_ip,omitempty"`
}

func (*SiteSubnetParametersType_Dhcp) isSiteSubnetParametersType_AddressChoice()     {}
func (*SiteSubnetParametersType_StaticIp) isSiteSubnetParametersType_AddressChoice() {}

func (m *SiteSubnetParametersType) GetAddressChoice() isSiteSubnetParametersType_AddressChoice {
	if m != nil {
		return m.AddressChoice
	}
	return nil
}

func (m *SiteSubnetParametersType) GetSite() *views.ObjectRefType {
	if m != nil {
		return m.Site
	}
	return nil
}

func (m *SiteSubnetParametersType) GetSubnetDhcpServerParams() *DHCPServerParametersType {
	if m != nil {
		return m.SubnetDhcpServerParams
	}
	return nil
}

func (m *SiteSubnetParametersType) GetDhcp() *schema.Empty {
	if x, ok := m.GetAddressChoice().(*SiteSubnetParametersType_Dhcp); ok {
		return x.Dhcp
	}
	return nil
}

func (m *SiteSubnetParametersType) GetStaticIp() *schema.Empty {
	if x, ok := m.GetAddressChoice().(*SiteSubnetParametersType_StaticIp); ok {
		return x.StaticIp
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SiteSubnetParametersType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SiteSubnetParametersType_Dhcp)(nil),
		(*SiteSubnetParametersType_StaticIp)(nil),
	}
}

// Subnet connection to Layer2 interface
//
// x-displayName: "Subnet connection to Layer2 Interface"
type ConnectToLayer2 struct {
	// Layer2 Interface
	//
	// x-displayName: "Layer2 Interface"
	// x-required
	// Layer2 interface to connect to
	Layer2IntfRef *views.ObjectRefType `protobuf:"bytes,1,opt,name=layer2_intf_ref,json=layer2IntfRef,proto3" json:"layer2_intf_ref,omitempty"`
	// Layer2 Interface Internal Object
	//
	// x-displayName: "Layer2 Interface Internal"
	// Layer2 interface to connect to
	Layer2IntfInternalRef []*schema.ObjectRefType `protobuf:"bytes,2,rep,name=layer2_intf_internal_ref,json=layer2IntfInternalRef,proto3" json:"layer2_intf_internal_ref,omitempty"`
}

func (m *ConnectToLayer2) Reset()      { *m = ConnectToLayer2{} }
func (*ConnectToLayer2) ProtoMessage() {}
func (*ConnectToLayer2) Descriptor() ([]byte, []int) {
	return fileDescriptor_964a9ec4edc9fd55, []int{4}
}
func (m *ConnectToLayer2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectToLayer2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConnectToLayer2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectToLayer2.Merge(m, src)
}
func (m *ConnectToLayer2) XXX_Size() int {
	return m.Size()
}
func (m *ConnectToLayer2) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectToLayer2.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectToLayer2 proto.InternalMessageInfo

func (m *ConnectToLayer2) GetLayer2IntfRef() *views.ObjectRefType {
	if m != nil {
		return m.Layer2IntfRef
	}
	return nil
}

func (m *ConnectToLayer2) GetLayer2IntfInternalRef() []*schema.ObjectRefType {
	if m != nil {
		return m.Layer2IntfInternalRef
	}
	return nil
}

// Subnet object global spec
//
// x-displayName: "Global Specification"
// Subnet configuration is applied to an interface of a pod/VM.
type GlobalSpecType struct {
	// Site DHCP server parameters internal structure
	//
	// x-displayName: "Site DHCP server parameters internal"
	// x-required
	// Site DHCP server parameters internal structure is stored
	// in the db and exists to reuse the network_interface
	// DHCPServerParametersType message. Not all fields of the
	// network_interface DHCPServerParametersType object may be
	// relevant to a subnet, so we will always have a separate
	// object for the subnet DHCP server parameters.
	SiteDhcpServerParamsInternal []*SubnetDHCPServerParametersType `protobuf:"bytes,1000,rep,name=site_dhcp_server_params_internal,json=siteDhcpServerParamsInternal,proto3" json:"site_dhcp_server_params_internal,omitempty"`
	// Site subnet parameters that are used by the Create Spec
	//
	// x-displayName: "Site Subnet Parameters"
	// x-required
	// Configure subnet parameters per site
	SiteSubnetParams []*SiteSubnetParametersType `protobuf:"bytes,2,rep,name=site_subnet_params,json=siteSubnetParams,proto3" json:"site_subnet_params,omitempty"`
	// Connection Choice
	//
	// x-displayName: "Network Connection Type"
	// Select the network this subnet should optionally be conected to
	//
	// Types that are valid to be assigned to ConnectionChoice:
	//	*GlobalSpecType_ConnectToSlo
	//	*GlobalSpecType_ConnectToSli
	//	*GlobalSpecType_IsolatedNw
	//	*GlobalSpecType_ConnectToLayer2
	ConnectionChoice isGlobalSpecType_ConnectionChoice `protobuf_oneof:"connection_choice"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_964a9ec4edc9fd55, []int{5}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_ConnectionChoice interface {
	isGlobalSpecType_ConnectionChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_ConnectToSlo struct {
	ConnectToSlo *schema.Empty `protobuf:"bytes,4,opt,name=connect_to_slo,json=connectToSlo,proto3,oneof" json:"connect_to_slo,omitempty"`
}
type GlobalSpecType_ConnectToSli struct {
	ConnectToSli *schema.Empty `protobuf:"bytes,5,opt,name=connect_to_sli,json=connectToSli,proto3,oneof" json:"connect_to_sli,omitempty"`
}
type GlobalSpecType_IsolatedNw struct {
	IsolatedNw *schema.Empty `protobuf:"bytes,6,opt,name=isolated_nw,json=isolatedNw,proto3,oneof" json:"isolated_nw,omitempty"`
}
type GlobalSpecType_ConnectToLayer2 struct {
	ConnectToLayer2 *ConnectToLayer2 `protobuf:"bytes,8,opt,name=connect_to_layer2,json=connectToLayer2,proto3,oneof" json:"connect_to_layer2,omitempty"`
}

func (*GlobalSpecType_ConnectToSlo) isGlobalSpecType_ConnectionChoice()    {}
func (*GlobalSpecType_ConnectToSli) isGlobalSpecType_ConnectionChoice()    {}
func (*GlobalSpecType_IsolatedNw) isGlobalSpecType_ConnectionChoice()      {}
func (*GlobalSpecType_ConnectToLayer2) isGlobalSpecType_ConnectionChoice() {}

func (m *GlobalSpecType) GetConnectionChoice() isGlobalSpecType_ConnectionChoice {
	if m != nil {
		return m.ConnectionChoice
	}
	return nil
}

func (m *GlobalSpecType) GetSiteDhcpServerParamsInternal() []*SubnetDHCPServerParametersType {
	if m != nil {
		return m.SiteDhcpServerParamsInternal
	}
	return nil
}

func (m *GlobalSpecType) GetSiteSubnetParams() []*SiteSubnetParametersType {
	if m != nil {
		return m.SiteSubnetParams
	}
	return nil
}

func (m *GlobalSpecType) GetConnectToSlo() *schema.Empty {
	if x, ok := m.GetConnectionChoice().(*GlobalSpecType_ConnectToSlo); ok {
		return x.ConnectToSlo
	}
	return nil
}

func (m *GlobalSpecType) GetConnectToSli() *schema.Empty {
	if x, ok := m.GetConnectionChoice().(*GlobalSpecType_ConnectToSli); ok {
		return x.ConnectToSli
	}
	return nil
}

func (m *GlobalSpecType) GetIsolatedNw() *schema.Empty {
	if x, ok := m.GetConnectionChoice().(*GlobalSpecType_IsolatedNw); ok {
		return x.IsolatedNw
	}
	return nil
}

func (m *GlobalSpecType) GetConnectToLayer2() *ConnectToLayer2 {
	if x, ok := m.GetConnectionChoice().(*GlobalSpecType_ConnectToLayer2); ok {
		return x.ConnectToLayer2
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_ConnectToSlo)(nil),
		(*GlobalSpecType_ConnectToSli)(nil),
		(*GlobalSpecType_IsolatedNw)(nil),
		(*GlobalSpecType_ConnectToLayer2)(nil),
	}
}

// Create subnet
//
// x-displayName: "Create Subnet"
// Subnet object contains configuration for an interface of a VM/pod.
// It is created in user or shared namespace.
type CreateSpecType struct {
	// Site subnet parameters
	//
	// x-displayName: "Site Subnet Parameters"
	// x-required
	// Configure subnet parameters per site
	SiteSubnetParams []*SiteSubnetParametersType `protobuf:"bytes,1,rep,name=site_subnet_params,json=siteSubnetParams,proto3" json:"site_subnet_params,omitempty"`
	// Connection Choice
	//
	// x-displayName: "Network Connection Type"
	// Select the network this subnet should optionally be conected to
	//
	// Types that are valid to be assigned to ConnectionChoice:
	//	*CreateSpecType_ConnectToSlo
	//	*CreateSpecType_ConnectToSli
	//	*CreateSpecType_IsolatedNw
	//	*CreateSpecType_ConnectToLayer2
	ConnectionChoice isCreateSpecType_ConnectionChoice `protobuf_oneof:"connection_choice"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_964a9ec4edc9fd55, []int{6}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_ConnectionChoice interface {
	isCreateSpecType_ConnectionChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_ConnectToSlo struct {
	ConnectToSlo *schema.Empty `protobuf:"bytes,4,opt,name=connect_to_slo,json=connectToSlo,proto3,oneof" json:"connect_to_slo,omitempty"`
}
type CreateSpecType_ConnectToSli struct {
	ConnectToSli *schema.Empty `protobuf:"bytes,5,opt,name=connect_to_sli,json=connectToSli,proto3,oneof" json:"connect_to_sli,omitempty"`
}
type CreateSpecType_IsolatedNw struct {
	IsolatedNw *schema.Empty `protobuf:"bytes,6,opt,name=isolated_nw,json=isolatedNw,proto3,oneof" json:"isolated_nw,omitempty"`
}
type CreateSpecType_ConnectToLayer2 struct {
	ConnectToLayer2 *ConnectToLayer2 `protobuf:"bytes,8,opt,name=connect_to_layer2,json=connectToLayer2,proto3,oneof" json:"connect_to_layer2,omitempty"`
}

func (*CreateSpecType_ConnectToSlo) isCreateSpecType_ConnectionChoice()    {}
func (*CreateSpecType_ConnectToSli) isCreateSpecType_ConnectionChoice()    {}
func (*CreateSpecType_IsolatedNw) isCreateSpecType_ConnectionChoice()      {}
func (*CreateSpecType_ConnectToLayer2) isCreateSpecType_ConnectionChoice() {}

func (m *CreateSpecType) GetConnectionChoice() isCreateSpecType_ConnectionChoice {
	if m != nil {
		return m.ConnectionChoice
	}
	return nil
}

func (m *CreateSpecType) GetSiteSubnetParams() []*SiteSubnetParametersType {
	if m != nil {
		return m.SiteSubnetParams
	}
	return nil
}

func (m *CreateSpecType) GetConnectToSlo() *schema.Empty {
	if x, ok := m.GetConnectionChoice().(*CreateSpecType_ConnectToSlo); ok {
		return x.ConnectToSlo
	}
	return nil
}

func (m *CreateSpecType) GetConnectToSli() *schema.Empty {
	if x, ok := m.GetConnectionChoice().(*CreateSpecType_ConnectToSli); ok {
		return x.ConnectToSli
	}
	return nil
}

func (m *CreateSpecType) GetIsolatedNw() *schema.Empty {
	if x, ok := m.GetConnectionChoice().(*CreateSpecType_IsolatedNw); ok {
		return x.IsolatedNw
	}
	return nil
}

func (m *CreateSpecType) GetConnectToLayer2() *ConnectToLayer2 {
	if x, ok := m.GetConnectionChoice().(*CreateSpecType_ConnectToLayer2); ok {
		return x.ConnectToLayer2
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_ConnectToSlo)(nil),
		(*CreateSpecType_ConnectToSli)(nil),
		(*CreateSpecType_IsolatedNw)(nil),
		(*CreateSpecType_ConnectToLayer2)(nil),
	}
}

// GetSpecType
//
// x-displayName: "Get Subnet"
// Shape of subnet specification
type GetSpecType struct {
	// x-required
	SiteSubnetParams []*SiteSubnetParametersType `protobuf:"bytes,1,rep,name=site_subnet_params,json=siteSubnetParams,proto3" json:"site_subnet_params,omitempty"`
	// Connection Choice
	//
	// x-displayName: "Network Connection Type"
	// Select the network this subnet should optionally be conected to
	//
	// Types that are valid to be assigned to ConnectionChoice:
	//	*GetSpecType_ConnectToSlo
	//	*GetSpecType_ConnectToSli
	//	*GetSpecType_IsolatedNw
	//	*GetSpecType_ConnectToLayer2
	ConnectionChoice isGetSpecType_ConnectionChoice `protobuf_oneof:"connection_choice"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_964a9ec4edc9fd55, []int{7}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_ConnectionChoice interface {
	isGetSpecType_ConnectionChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_ConnectToSlo struct {
	ConnectToSlo *schema.Empty `protobuf:"bytes,4,opt,name=connect_to_slo,json=connectToSlo,proto3,oneof" json:"connect_to_slo,omitempty"`
}
type GetSpecType_ConnectToSli struct {
	ConnectToSli *schema.Empty `protobuf:"bytes,5,opt,name=connect_to_sli,json=connectToSli,proto3,oneof" json:"connect_to_sli,omitempty"`
}
type GetSpecType_IsolatedNw struct {
	IsolatedNw *schema.Empty `protobuf:"bytes,6,opt,name=isolated_nw,json=isolatedNw,proto3,oneof" json:"isolated_nw,omitempty"`
}
type GetSpecType_ConnectToLayer2 struct {
	ConnectToLayer2 *ConnectToLayer2 `protobuf:"bytes,8,opt,name=connect_to_layer2,json=connectToLayer2,proto3,oneof" json:"connect_to_layer2,omitempty"`
}

func (*GetSpecType_ConnectToSlo) isGetSpecType_ConnectionChoice()    {}
func (*GetSpecType_ConnectToSli) isGetSpecType_ConnectionChoice()    {}
func (*GetSpecType_IsolatedNw) isGetSpecType_ConnectionChoice()      {}
func (*GetSpecType_ConnectToLayer2) isGetSpecType_ConnectionChoice() {}

func (m *GetSpecType) GetConnectionChoice() isGetSpecType_ConnectionChoice {
	if m != nil {
		return m.ConnectionChoice
	}
	return nil
}

func (m *GetSpecType) GetSiteSubnetParams() []*SiteSubnetParametersType {
	if m != nil {
		return m.SiteSubnetParams
	}
	return nil
}

func (m *GetSpecType) GetConnectToSlo() *schema.Empty {
	if x, ok := m.GetConnectionChoice().(*GetSpecType_ConnectToSlo); ok {
		return x.ConnectToSlo
	}
	return nil
}

func (m *GetSpecType) GetConnectToSli() *schema.Empty {
	if x, ok := m.GetConnectionChoice().(*GetSpecType_ConnectToSli); ok {
		return x.ConnectToSli
	}
	return nil
}

func (m *GetSpecType) GetIsolatedNw() *schema.Empty {
	if x, ok := m.GetConnectionChoice().(*GetSpecType_IsolatedNw); ok {
		return x.IsolatedNw
	}
	return nil
}

func (m *GetSpecType) GetConnectToLayer2() *ConnectToLayer2 {
	if x, ok := m.GetConnectionChoice().(*GetSpecType_ConnectToLayer2); ok {
		return x.ConnectToLayer2
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_ConnectToSlo)(nil),
		(*GetSpecType_ConnectToSli)(nil),
		(*GetSpecType_IsolatedNw)(nil),
		(*GetSpecType_ConnectToLayer2)(nil),
	}
}

// ReplaceSpecType
//
// x-displayName: "Replace Subnet"
// Shape of subnet specification
type ReplaceSpecType struct {
	// Connection Choice
	//
	// x-displayName: "Network Connection Type"
	// Select the network this subnet should optionally be conected to
	//
	// Types that are valid to be assigned to ConnectionChoice:
	//	*ReplaceSpecType_ConnectToSlo
	//	*ReplaceSpecType_ConnectToSli
	//	*ReplaceSpecType_IsolatedNw
	//	*ReplaceSpecType_ConnectToLayer2
	ConnectionChoice isReplaceSpecType_ConnectionChoice `protobuf_oneof:"connection_choice"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_964a9ec4edc9fd55, []int{8}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_ConnectionChoice interface {
	isReplaceSpecType_ConnectionChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_ConnectToSlo struct {
	ConnectToSlo *schema.Empty `protobuf:"bytes,4,opt,name=connect_to_slo,json=connectToSlo,proto3,oneof" json:"connect_to_slo,omitempty"`
}
type ReplaceSpecType_ConnectToSli struct {
	ConnectToSli *schema.Empty `protobuf:"bytes,5,opt,name=connect_to_sli,json=connectToSli,proto3,oneof" json:"connect_to_sli,omitempty"`
}
type ReplaceSpecType_IsolatedNw struct {
	IsolatedNw *schema.Empty `protobuf:"bytes,6,opt,name=isolated_nw,json=isolatedNw,proto3,oneof" json:"isolated_nw,omitempty"`
}
type ReplaceSpecType_ConnectToLayer2 struct {
	ConnectToLayer2 *ConnectToLayer2 `protobuf:"bytes,8,opt,name=connect_to_layer2,json=connectToLayer2,proto3,oneof" json:"connect_to_layer2,omitempty"`
}

func (*ReplaceSpecType_ConnectToSlo) isReplaceSpecType_ConnectionChoice()    {}
func (*ReplaceSpecType_ConnectToSli) isReplaceSpecType_ConnectionChoice()    {}
func (*ReplaceSpecType_IsolatedNw) isReplaceSpecType_ConnectionChoice()      {}
func (*ReplaceSpecType_ConnectToLayer2) isReplaceSpecType_ConnectionChoice() {}

func (m *ReplaceSpecType) GetConnectionChoice() isReplaceSpecType_ConnectionChoice {
	if m != nil {
		return m.ConnectionChoice
	}
	return nil
}

func (m *ReplaceSpecType) GetConnectToSlo() *schema.Empty {
	if x, ok := m.GetConnectionChoice().(*ReplaceSpecType_ConnectToSlo); ok {
		return x.ConnectToSlo
	}
	return nil
}

func (m *ReplaceSpecType) GetConnectToSli() *schema.Empty {
	if x, ok := m.GetConnectionChoice().(*ReplaceSpecType_ConnectToSli); ok {
		return x.ConnectToSli
	}
	return nil
}

func (m *ReplaceSpecType) GetIsolatedNw() *schema.Empty {
	if x, ok := m.GetConnectionChoice().(*ReplaceSpecType_IsolatedNw); ok {
		return x.IsolatedNw
	}
	return nil
}

func (m *ReplaceSpecType) GetConnectToLayer2() *ConnectToLayer2 {
	if x, ok := m.GetConnectionChoice().(*ReplaceSpecType_ConnectToLayer2); ok {
		return x.ConnectToLayer2
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_ConnectToSlo)(nil),
		(*ReplaceSpecType_ConnectToSli)(nil),
		(*ReplaceSpecType_IsolatedNw)(nil),
		(*ReplaceSpecType_ConnectToLayer2)(nil),
	}
}

func init() {
	proto.RegisterType((*SubnetDHCPServerParametersType)(nil), "ves.io.schema.subnet.SubnetDHCPServerParametersType")
	golang_proto.RegisterType((*SubnetDHCPServerParametersType)(nil), "ves.io.schema.subnet.SubnetDHCPServerParametersType")
	proto.RegisterType((*DHCPNetworkType)(nil), "ves.io.schema.subnet.DHCPNetworkType")
	golang_proto.RegisterType((*DHCPNetworkType)(nil), "ves.io.schema.subnet.DHCPNetworkType")
	proto.RegisterType((*DHCPServerParametersType)(nil), "ves.io.schema.subnet.DHCPServerParametersType")
	golang_proto.RegisterType((*DHCPServerParametersType)(nil), "ves.io.schema.subnet.DHCPServerParametersType")
	proto.RegisterType((*SiteSubnetParametersType)(nil), "ves.io.schema.subnet.SiteSubnetParametersType")
	golang_proto.RegisterType((*SiteSubnetParametersType)(nil), "ves.io.schema.subnet.SiteSubnetParametersType")
	proto.RegisterType((*ConnectToLayer2)(nil), "ves.io.schema.subnet.ConnectToLayer2")
	golang_proto.RegisterType((*ConnectToLayer2)(nil), "ves.io.schema.subnet.ConnectToLayer2")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.subnet.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.subnet.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.subnet.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.subnet.CreateSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.subnet.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.subnet.GetSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.subnet.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.subnet.ReplaceSpecType")
}

func init() { proto.RegisterFile("ves.io/schema/subnet/types.proto", fileDescriptor_964a9ec4edc9fd55) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/subnet/types.proto", fileDescriptor_964a9ec4edc9fd55)
}

var fileDescriptor_964a9ec4edc9fd55 = []byte{
	// 1179 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x57, 0xcf, 0x4f, 0xe3, 0xc6,
	0x1f, 0xcd, 0xc4, 0x5e, 0xc8, 0x4e, 0x96, 0x24, 0x18, 0xf6, 0x2b, 0xc3, 0x97, 0x7a, 0xd3, 0x48,
	0x55, 0xd3, 0x6d, 0x70, 0xb4, 0xfc, 0xda, 0x16, 0x6d, 0x39, 0x84, 0x5d, 0x2d, 0xd0, 0x8a, 0x45,
	0xce, 0x9e, 0x7a, 0x71, 0x1d, 0x67, 0x1c, 0x5c, 0x12, 0x8f, 0x35, 0x33, 0x04, 0x90, 0x8a, 0x44,
	0x7b, 0xaa, 0x7a, 0xaa, 0xfa, 0x57, 0xac, 0xf6, 0x4f, 0x68, 0x5a, 0x09, 0xf5, 0x54, 0x71, 0xe2,
	0xd0, 0x03, 0x97, 0x4a, 0x25, 0x5c, 0x68, 0x2f, 0x45, 0x55, 0x0f, 0xab, 0x9e, 0x2a, 0x8f, 0x1d,
	0x36, 0x36, 0x09, 0xec, 0x4a, 0x3d, 0x70, 0xd8, 0xdb, 0xc4, 0xf3, 0xe6, 0xbd, 0xf9, 0x7c, 0xde,
	0xfb, 0x38, 0x32, 0xcc, 0x36, 0x11, 0x55, 0x6d, 0x5c, 0xa4, 0xe6, 0x3a, 0x6a, 0x18, 0x45, 0xba,
	0x59, 0x71, 0x10, 0x2b, 0xb2, 0x1d, 0x17, 0x51, 0xd5, 0x25, 0x98, 0x61, 0x69, 0xd4, 0x47, 0xa8,
	0x3e, 0x42, 0xf5, 0x11, 0xe3, 0x93, 0x35, 0x9b, 0xad, 0x6f, 0x56, 0x54, 0x13, 0x37, 0x8a, 0x35,
	0x5c, 0xc3, 0x45, 0x0e, 0xae, 0x6c, 0x5a, 0xfc, 0x17, 0xff, 0xc1, 0x57, 0x3e, 0xc9, 0xf8, 0xfb,
	0x61, 0x19, 0x07, 0xb1, 0x2d, 0x4c, 0x36, 0x74, 0xdb, 0x61, 0x88, 0x58, 0x86, 0x89, 0xba, 0x15,
	0xc7, 0xff, 0x1f, 0x06, 0x63, 0x97, 0xd9, 0xd8, 0xe9, 0x6c, 0x8e, 0x85, 0x37, 0xbb, 0xcf, 0x4d,
	0x84, 0xb7, 0x9a, 0x46, 0xdd, 0xae, 0x1a, 0x0c, 0x05, 0xbb, 0x91, 0x4a, 0x9b, 0x36, 0xda, 0xd2,
	0xc3, 0xd4, 0x77, 0x2e, 0x22, 0x68, 0xb7, 0x40, 0xee, 0x04, 0x40, 0xa5, 0xcc, 0xeb, 0x7f, 0xb8,
	0xb4, 0xb8, 0x56, 0x46, 0xa4, 0x89, 0xc8, 0x9a, 0x41, 0x8c, 0x06, 0x62, 0x88, 0xd0, 0xa7, 0x3b,
	0x2e, 0x92, 0x3e, 0x82, 0x22, 0xb5, 0x19, 0x92, 0x85, 0xac, 0x90, 0x4f, 0x4e, 0x4d, 0xa8, 0xe1,
	0xe6, 0x3d, 0xa9, 0x7c, 0x8e, 0x4c, 0xa6, 0x21, 0xcb, 0xc3, 0x96, 0x92, 0xcf, 0x77, 0x39, 0x78,
	0xef, 0x07, 0x00, 0x34, 0xbe, 0x92, 0x18, 0x1c, 0xf3, 0x1b, 0xac, 0x57, 0xd7, 0x4d, 0x57, 0xa7,
	0x5c, 0x42, 0x77, 0x3d, 0x0d, 0x2a, 0xc7, 0xb3, 0x20, 0x9f, 0x9c, 0xfa, 0x30, 0xc2, 0x79, 0xa1,
	0x97, 0x6a, 0xbf, 0xcb, 0x69, 0xff, 0xf3, 0xb9, 0x1f, 0xae, 0x9b, 0x6e, 0xd7, 0x3e, 0x9d, 0x1f,
	0x38, 0x68, 0x81, 0x78, 0x06, 0xac, 0x88, 0x09, 0x90, 0x89, 0xe7, 0x9e, 0xc5, 0x61, 0xda, 0xa3,
	0x58, 0xf5, 0x89, 0x79, 0x59, 0xf7, 0x61, 0xaa, 0xa3, 0xe3, 0x12, 0x64, 0xd9, 0xdb, 0xfc, 0x32,
	0x37, 0x4b, 0xa9, 0x17, 0x2d, 0x10, 0xfb, 0xfe, 0xf7, 0x7d, 0xe1, 0x06, 0x11, 0x5e, 0x00, 0xb0,
	0x14, 0xd3, 0x86, 0x02, 0xdc, 0x1a, 0x87, 0x49, 0x5f, 0x02, 0x38, 0x12, 0x3e, 0xa9, 0xdb, 0x6e,
	0x73, 0x4e, 0x16, 0xf8, 0xf1, 0x27, 0x7f, 0xec, 0xe6, 0xab, 0xa8, 0x81, 0xef, 0x15, 0x18, 0xa2,
	0xac, 0x60, 0x12, 0x56, 0xa0, 0xcc, 0xa8, 0xd9, 0x4e, 0xad, 0x40, 0xb1, 0xc5, 0x2a, 0x86, 0xb3,
	0xa1, 0x37, 0x90, 0x59, 0x70, 0x09, 0xae, 0x7a, 0x4a, 0xdf, 0xfc, 0x08, 0x24, 0x6b, 0x76, 0xdb,
	0x9c, 0xf4, 0x38, 0x26, 0x29, 0x33, 0x9c, 0xaa, 0x41, 0xaa, 0x81, 0xfe, 0x5e, 0xdc, 0xd3, 0x1f,
	0x0e, 0xe9, 0x2f, 0xbb, 0xcd, 0xb9, 0xf9, 0xfc, 0x5f, 0x0b, 0xe0, 0xde, 0x41, 0x0b, 0x64, 0xa1,
	0x02, 0x07, 0xfc, 0xe7, 0x77, 0x47, 0xa1, 0x04, 0x33, 0xd1, 0xa2, 0x4a, 0x79, 0x78, 0x3b, 0x72,
	0x59, 0x73, 0x1d, 0xdb, 0x26, 0x92, 0xd2, 0xfb, 0x2d, 0x10, 0x3f, 0x6c, 0x01, 0xd0, 0x6e, 0x01,
	0x61, 0xaa, 0x30, 0x1d, 0xb4, 0xea, 0x0b, 0x28, 0xf7, 0x4d, 0xc2, 0x67, 0x70, 0x88, 0x7b, 0x18,
	0x10, 0x52, 0x19, 0xf0, 0x48, 0xbc, 0xa3, 0xf6, 0x9a, 0x27, 0x35, 0xd2, 0xf0, 0xd2, 0x28, 0x2f,
	0xea, 0x3b, 0xcf, 0x96, 0xce, 0x4a, 0x06, 0xda, 0x2d, 0x8f, 0x31, 0x80, 0xd1, 0xdc, 0x4f, 0x02,
	0x94, 0xcb, 0x36, 0x43, 0x7e, 0x24, 0x23, 0xf2, 0x8b, 0x41, 0x10, 0x01, 0x0f, 0x4d, 0x2e, 0xa2,
	0xca, 0xb3, 0x7d, 0x75, 0x1c, 0xf1, 0xd5, 0x71, 0x54, 0xfb, 0xd7, 0xd3, 0xab, 0x2d, 0x25, 0xf1,
	0xac, 0x05, 0x40, 0xbf, 0x24, 0x4a, 0x77, 0xa1, 0xe8, 0x29, 0xc9, 0x22, 0xe7, 0x1e, 0x8d, 0x70,
	0x3f, 0x6a, 0xb8, 0x6c, 0x67, 0x29, 0xa6, 0x71, 0x8c, 0x34, 0x0d, 0x6f, 0x52, 0x66, 0x30, 0xdb,
	0xd4, 0x6d, 0x57, 0xbe, 0x71, 0xe9, 0x81, 0x84, 0x0f, 0x5c, 0x76, 0xe7, 0xad, 0x83, 0x16, 0xa8,
	0xc0, 0x11, 0x28, 0x7a, 0x8d, 0x1b, 0x4f, 0xc2, 0x9b, 0x5e, 0x9d, 0xaa, 0x63, 0x34, 0x10, 0xfc,
	0x18, 0x2a, 0xab, 0x9b, 0x8d, 0x0a, 0x22, 0x59, 0x6c, 0x65, 0xfd, 0x9e, 0x66, 0xbd, 0x32, 0xb2,
	0x9d, 0x86, 0xcf, 0xbf, 0x07, 0xdf, 0xed, 0xdb, 0x0e, 0x35, 0x64, 0x76, 0xe9, 0x6d, 0x98, 0x32,
	0xaa, 0x55, 0x82, 0x28, 0xed, 0x8e, 0x90, 0x78, 0xd8, 0x02, 0x82, 0x17, 0xa1, 0x99, 0xc2, 0xec,
	0x8a, 0x98, 0x10, 0x32, 0x62, 0xee, 0x4f, 0x00, 0xd3, 0x8b, 0xd8, 0x71, 0x90, 0xc9, 0x9e, 0xe2,
	0x4f, 0x8c, 0x1d, 0x44, 0xa6, 0xa4, 0x2a, 0x4c, 0xd7, 0xf9, 0xca, 0x1b, 0x6a, 0x4b, 0x27, 0xc8,
	0x7a, 0x0d, 0x1b, 0xe5, 0xe7, 0xbb, 0xc3, 0x17, 0xde, 0x09, 0xdc, 0xd3, 0x21, 0x9f, 0x74, 0xd9,
	0x61, 0x96, 0x86, 0x2c, 0xa9, 0x09, 0xe5, 0x6e, 0x15, 0x8e, 0x75, 0x8c, 0x3a, 0x97, 0x8b, 0xbf,
	0xc2, 0xeb, 0xeb, 0x4e, 0x2f, 0xa1, 0xa3, 0x5d, 0x70, 0xda, 0x02, 0x80, 0xeb, 0xdd, 0x7e, 0xa9,
	0xb7, 0x1c, 0x90, 0x6b, 0xc8, 0xca, 0xfd, 0x22, 0xc2, 0xd4, 0xe3, 0x3a, 0xae, 0x18, 0xf5, 0xb2,
	0x8b, 0x4c, 0x1e, 0xd6, 0x5d, 0x98, 0xf5, 0x7c, 0xe8, 0xd1, 0xd6, 0xf3, 0x6b, 0xc9, 0xa7, 0x83,
	0xfc, 0x4e, 0x33, 0xbd, 0xf3, 0x76, 0xf9, 0x6b, 0x59, 0x9b, 0xf0, 0xe8, 0xa3, 0x69, 0xeb, 0x5c,
	0x4a, 0x22, 0x50, 0xe2, 0xf2, 0x81, 0xb9, 0xe7, 0xf9, 0x16, 0xfa, 0xe7, 0xbb, 0xdf, 0xdc, 0xf5,
	0x1a, 0xdc, 0x04, 0xd0, 0x32, 0x34, 0x8c, 0xa7, 0xd2, 0x03, 0x98, 0x32, 0x7d, 0xdb, 0x75, 0x86,
	0x75, 0x5a, 0xc7, 0x57, 0x64, 0xfe, 0x96, 0xd9, 0x09, 0x49, 0xb9, 0x8e, 0xa5, 0x47, 0x91, 0xd3,
	0xf6, 0x65, 0x03, 0x50, 0x1a, 0x0c, 0x5c, 0x89, 0xd0, 0xd8, 0xd2, 0x7d, 0x98, 0xb4, 0x29, 0xae,
	0x1b, 0x0c, 0x55, 0x75, 0x67, 0x4b, 0x1e, 0xb8, 0xf4, 0x06, 0xb0, 0x03, 0x5d, 0xdd, 0x92, 0xca,
	0x70, 0xb8, 0x4b, 0xdf, 0xf7, 0x59, 0x4e, 0xf0, 0xe3, 0x7d, 0x5e, 0x70, 0x91, 0x8c, 0x2f, 0xc5,
	0xb4, 0xb4, 0x19, 0x7e, 0xd4, 0xf9, 0x1b, 0x2a, 0xe5, 0xcf, 0xc9, 0x6d, 0xec, 0x74, 0xc6, 0x67,
	0x64, 0xbf, 0x05, 0x06, 0x82, 0xf1, 0x19, 0x9c, 0x29, 0xcc, 0x16, 0xe6, 0x0a, 0x1f, 0xf8, 0x23,
	0xb4, 0x22, 0x26, 0x06, 0x33, 0x89, 0xdc, 0xb1, 0x00, 0x53, 0x8b, 0x04, 0x19, 0x0c, 0x9d, 0xc7,
	0xaa, 0xb7, 0xaf, 0xe0, 0x1a, 0xfb, 0xfa, 0xe0, 0x75, 0x7c, 0xbd, 0xe6, 0x76, 0x0e, 0x1f, 0x2c,
	0x44, 0xe6, 0xbc, 0x34, 0xd5, 0xcb, 0xd9, 0xb7, 0x02, 0x67, 0xe3, 0x5f, 0xfd, 0x03, 0x2e, 0x6e,
	0xaf, 0x88, 0x89, 0x78, 0x46, 0x08, 0x3c, 0xfe, 0x55, 0x80, 0xc9, 0xc7, 0x88, 0xbd, 0x31, 0xf8,
	0x5a, 0x18, 0x3c, 0x7a, 0xc1, 0xe0, 0xd3, 0x05, 0x50, 0x52, 0x7b, 0x79, 0x3c, 0xf6, 0x6a, 0xfe,
	0xfe, 0x1d, 0x87, 0x69, 0x0d, 0xb9, 0x75, 0xc3, 0x7c, 0x39, 0xc4, 0x6f, 0xfa, 0xfd, 0x9f, 0x0f,
	0x14, 0xc8, 0xc4, 0xbb, 0xdb, 0x5e, 0xfa, 0x1a, 0x1c, 0x1e, 0x2b, 0xb1, 0xa3, 0x63, 0x25, 0x76,
	0x76, 0xac, 0x80, 0xbd, 0xb6, 0x02, 0x9e, 0xb5, 0x15, 0xf0, 0x73, 0x5b, 0x01, 0x87, 0x6d, 0x05,
	0x1c, 0xb5, 0x15, 0xf0, 0x5b, 0x5b, 0x01, 0xa7, 0x6d, 0x25, 0x76, 0xd6, 0x56, 0xc0, 0xb7, 0x27,
	0x4a, 0x6c, 0xff, 0x44, 0x01, 0x87, 0x27, 0x4a, 0xec, 0xe8, 0x44, 0x89, 0x7d, 0xba, 0x52, 0xc3,
	0xee, 0x46, 0x4d, 0x6d, 0xe2, 0x3a, 0x43, 0x84, 0x18, 0xea, 0x26, 0x2d, 0xf2, 0x85, 0x85, 0x49,
	0x63, 0xd2, 0x25, 0xb8, 0x69, 0x57, 0x11, 0x99, 0xec, 0x6c, 0x17, 0xdd, 0x4a, 0x0d, 0x17, 0xd1,
	0x36, 0xeb, 0x7c, 0x72, 0x76, 0x7f, 0x79, 0x56, 0x06, 0xf8, 0x97, 0xd6, 0xf4, 0xbf, 0x01, 0x00,
	0x00, 0xff, 0xff, 0x38, 0x87, 0xd7, 0x81, 0x98, 0x0e, 0x00, 0x00,
}

func (this *SubnetDHCPServerParametersType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubnetDHCPServerParametersType)
	if !ok {
		that2, ok := that.(SubnetDHCPServerParametersType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Site) != len(that1.Site) {
		return false
	}
	for i := range this.Site {
		if !this.Site[i].Equal(that1.Site[i]) {
			return false
		}
	}
	if !this.SubnetDhcpServerParams.Equal(that1.SubnetDhcpServerParams) {
		return false
	}
	return true
}
func (this *DHCPNetworkType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPNetworkType)
	if !ok {
		that2, ok := that.(DHCPNetworkType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.NetworkPrefixChoice == nil {
		if this.NetworkPrefixChoice != nil {
			return false
		}
	} else if this.NetworkPrefixChoice == nil {
		return false
	} else if !this.NetworkPrefixChoice.Equal(that1.NetworkPrefixChoice) {
		return false
	}
	return true
}
func (this *DHCPNetworkType_NetworkPrefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPNetworkType_NetworkPrefix)
	if !ok {
		that2, ok := that.(DHCPNetworkType_NetworkPrefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NetworkPrefix != that1.NetworkPrefix {
		return false
	}
	return true
}
func (this *DHCPNetworkType_NetworkPrefixIpv6) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPNetworkType_NetworkPrefixIpv6)
	if !ok {
		that2, ok := that.(DHCPNetworkType_NetworkPrefixIpv6)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NetworkPrefixIpv6 != that1.NetworkPrefixIpv6 {
		return false
	}
	return true
}
func (this *DHCPServerParametersType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPServerParametersType)
	if !ok {
		that2, ok := that.(DHCPServerParametersType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.DhcpNetworks) != len(that1.DhcpNetworks) {
		return false
	}
	for i := range this.DhcpNetworks {
		if !this.DhcpNetworks[i].Equal(that1.DhcpNetworks[i]) {
			return false
		}
	}
	return true
}
func (this *SiteSubnetParametersType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteSubnetParametersType)
	if !ok {
		that2, ok := that.(SiteSubnetParametersType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Site.Equal(that1.Site) {
		return false
	}
	if !this.SubnetDhcpServerParams.Equal(that1.SubnetDhcpServerParams) {
		return false
	}
	if that1.AddressChoice == nil {
		if this.AddressChoice != nil {
			return false
		}
	} else if this.AddressChoice == nil {
		return false
	} else if !this.AddressChoice.Equal(that1.AddressChoice) {
		return false
	}
	return true
}
func (this *SiteSubnetParametersType_Dhcp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteSubnetParametersType_Dhcp)
	if !ok {
		that2, ok := that.(SiteSubnetParametersType_Dhcp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Dhcp.Equal(that1.Dhcp) {
		return false
	}
	return true
}
func (this *SiteSubnetParametersType_StaticIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteSubnetParametersType_StaticIp)
	if !ok {
		that2, ok := that.(SiteSubnetParametersType_StaticIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StaticIp.Equal(that1.StaticIp) {
		return false
	}
	return true
}
func (this *ConnectToLayer2) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConnectToLayer2)
	if !ok {
		that2, ok := that.(ConnectToLayer2)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Layer2IntfRef.Equal(that1.Layer2IntfRef) {
		return false
	}
	if len(this.Layer2IntfInternalRef) != len(that1.Layer2IntfInternalRef) {
		return false
	}
	for i := range this.Layer2IntfInternalRef {
		if !this.Layer2IntfInternalRef[i].Equal(that1.Layer2IntfInternalRef[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.SiteDhcpServerParamsInternal) != len(that1.SiteDhcpServerParamsInternal) {
		return false
	}
	for i := range this.SiteDhcpServerParamsInternal {
		if !this.SiteDhcpServerParamsInternal[i].Equal(that1.SiteDhcpServerParamsInternal[i]) {
			return false
		}
	}
	if len(this.SiteSubnetParams) != len(that1.SiteSubnetParams) {
		return false
	}
	for i := range this.SiteSubnetParams {
		if !this.SiteSubnetParams[i].Equal(that1.SiteSubnetParams[i]) {
			return false
		}
	}
	if that1.ConnectionChoice == nil {
		if this.ConnectionChoice != nil {
			return false
		}
	} else if this.ConnectionChoice == nil {
		return false
	} else if !this.ConnectionChoice.Equal(that1.ConnectionChoice) {
		return false
	}
	return true
}
func (this *GlobalSpecType_ConnectToSlo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ConnectToSlo)
	if !ok {
		that2, ok := that.(GlobalSpecType_ConnectToSlo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ConnectToSlo.Equal(that1.ConnectToSlo) {
		return false
	}
	return true
}
func (this *GlobalSpecType_ConnectToSli) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ConnectToSli)
	if !ok {
		that2, ok := that.(GlobalSpecType_ConnectToSli)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ConnectToSli.Equal(that1.ConnectToSli) {
		return false
	}
	return true
}
func (this *GlobalSpecType_IsolatedNw) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_IsolatedNw)
	if !ok {
		that2, ok := that.(GlobalSpecType_IsolatedNw)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IsolatedNw.Equal(that1.IsolatedNw) {
		return false
	}
	return true
}
func (this *GlobalSpecType_ConnectToLayer2) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ConnectToLayer2)
	if !ok {
		that2, ok := that.(GlobalSpecType_ConnectToLayer2)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ConnectToLayer2.Equal(that1.ConnectToLayer2) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.SiteSubnetParams) != len(that1.SiteSubnetParams) {
		return false
	}
	for i := range this.SiteSubnetParams {
		if !this.SiteSubnetParams[i].Equal(that1.SiteSubnetParams[i]) {
			return false
		}
	}
	if that1.ConnectionChoice == nil {
		if this.ConnectionChoice != nil {
			return false
		}
	} else if this.ConnectionChoice == nil {
		return false
	} else if !this.ConnectionChoice.Equal(that1.ConnectionChoice) {
		return false
	}
	return true
}
func (this *CreateSpecType_ConnectToSlo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ConnectToSlo)
	if !ok {
		that2, ok := that.(CreateSpecType_ConnectToSlo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ConnectToSlo.Equal(that1.ConnectToSlo) {
		return false
	}
	return true
}
func (this *CreateSpecType_ConnectToSli) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ConnectToSli)
	if !ok {
		that2, ok := that.(CreateSpecType_ConnectToSli)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ConnectToSli.Equal(that1.ConnectToSli) {
		return false
	}
	return true
}
func (this *CreateSpecType_IsolatedNw) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_IsolatedNw)
	if !ok {
		that2, ok := that.(CreateSpecType_IsolatedNw)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IsolatedNw.Equal(that1.IsolatedNw) {
		return false
	}
	return true
}
func (this *CreateSpecType_ConnectToLayer2) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ConnectToLayer2)
	if !ok {
		that2, ok := that.(CreateSpecType_ConnectToLayer2)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ConnectToLayer2.Equal(that1.ConnectToLayer2) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.SiteSubnetParams) != len(that1.SiteSubnetParams) {
		return false
	}
	for i := range this.SiteSubnetParams {
		if !this.SiteSubnetParams[i].Equal(that1.SiteSubnetParams[i]) {
			return false
		}
	}
	if that1.ConnectionChoice == nil {
		if this.ConnectionChoice != nil {
			return false
		}
	} else if this.ConnectionChoice == nil {
		return false
	} else if !this.ConnectionChoice.Equal(that1.ConnectionChoice) {
		return false
	}
	return true
}
func (this *GetSpecType_ConnectToSlo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ConnectToSlo)
	if !ok {
		that2, ok := that.(GetSpecType_ConnectToSlo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ConnectToSlo.Equal(that1.ConnectToSlo) {
		return false
	}
	return true
}
func (this *GetSpecType_ConnectToSli) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ConnectToSli)
	if !ok {
		that2, ok := that.(GetSpecType_ConnectToSli)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ConnectToSli.Equal(that1.ConnectToSli) {
		return false
	}
	return true
}
func (this *GetSpecType_IsolatedNw) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_IsolatedNw)
	if !ok {
		that2, ok := that.(GetSpecType_IsolatedNw)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IsolatedNw.Equal(that1.IsolatedNw) {
		return false
	}
	return true
}
func (this *GetSpecType_ConnectToLayer2) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ConnectToLayer2)
	if !ok {
		that2, ok := that.(GetSpecType_ConnectToLayer2)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ConnectToLayer2.Equal(that1.ConnectToLayer2) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ConnectionChoice == nil {
		if this.ConnectionChoice != nil {
			return false
		}
	} else if this.ConnectionChoice == nil {
		return false
	} else if !this.ConnectionChoice.Equal(that1.ConnectionChoice) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ConnectToSlo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ConnectToSlo)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ConnectToSlo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ConnectToSlo.Equal(that1.ConnectToSlo) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ConnectToSli) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ConnectToSli)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ConnectToSli)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ConnectToSli.Equal(that1.ConnectToSli) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_IsolatedNw) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_IsolatedNw)
	if !ok {
		that2, ok := that.(ReplaceSpecType_IsolatedNw)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IsolatedNw.Equal(that1.IsolatedNw) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ConnectToLayer2) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ConnectToLayer2)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ConnectToLayer2)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ConnectToLayer2.Equal(that1.ConnectToLayer2) {
		return false
	}
	return true
}
func (this *SubnetDHCPServerParametersType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&subnet.SubnetDHCPServerParametersType{")
	if this.Site != nil {
		s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	}
	if this.SubnetDhcpServerParams != nil {
		s = append(s, "SubnetDhcpServerParams: "+fmt.Sprintf("%#v", this.SubnetDhcpServerParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DHCPNetworkType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&subnet.DHCPNetworkType{")
	if this.NetworkPrefixChoice != nil {
		s = append(s, "NetworkPrefixChoice: "+fmt.Sprintf("%#v", this.NetworkPrefixChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DHCPNetworkType_NetworkPrefix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&subnet.DHCPNetworkType_NetworkPrefix{` +
		`NetworkPrefix:` + fmt.Sprintf("%#v", this.NetworkPrefix) + `}`}, ", ")
	return s
}
func (this *DHCPNetworkType_NetworkPrefixIpv6) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&subnet.DHCPNetworkType_NetworkPrefixIpv6{` +
		`NetworkPrefixIpv6:` + fmt.Sprintf("%#v", this.NetworkPrefixIpv6) + `}`}, ", ")
	return s
}
func (this *DHCPServerParametersType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&subnet.DHCPServerParametersType{")
	if this.DhcpNetworks != nil {
		s = append(s, "DhcpNetworks: "+fmt.Sprintf("%#v", this.DhcpNetworks)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteSubnetParametersType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&subnet.SiteSubnetParametersType{")
	if this.Site != nil {
		s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	}
	if this.SubnetDhcpServerParams != nil {
		s = append(s, "SubnetDhcpServerParams: "+fmt.Sprintf("%#v", this.SubnetDhcpServerParams)+",\n")
	}
	if this.AddressChoice != nil {
		s = append(s, "AddressChoice: "+fmt.Sprintf("%#v", this.AddressChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteSubnetParametersType_Dhcp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&subnet.SiteSubnetParametersType_Dhcp{` +
		`Dhcp:` + fmt.Sprintf("%#v", this.Dhcp) + `}`}, ", ")
	return s
}
func (this *SiteSubnetParametersType_StaticIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&subnet.SiteSubnetParametersType_StaticIp{` +
		`StaticIp:` + fmt.Sprintf("%#v", this.StaticIp) + `}`}, ", ")
	return s
}
func (this *ConnectToLayer2) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&subnet.ConnectToLayer2{")
	if this.Layer2IntfRef != nil {
		s = append(s, "Layer2IntfRef: "+fmt.Sprintf("%#v", this.Layer2IntfRef)+",\n")
	}
	if this.Layer2IntfInternalRef != nil {
		s = append(s, "Layer2IntfInternalRef: "+fmt.Sprintf("%#v", this.Layer2IntfInternalRef)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&subnet.GlobalSpecType{")
	if this.SiteDhcpServerParamsInternal != nil {
		s = append(s, "SiteDhcpServerParamsInternal: "+fmt.Sprintf("%#v", this.SiteDhcpServerParamsInternal)+",\n")
	}
	if this.SiteSubnetParams != nil {
		s = append(s, "SiteSubnetParams: "+fmt.Sprintf("%#v", this.SiteSubnetParams)+",\n")
	}
	if this.ConnectionChoice != nil {
		s = append(s, "ConnectionChoice: "+fmt.Sprintf("%#v", this.ConnectionChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_ConnectToSlo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&subnet.GlobalSpecType_ConnectToSlo{` +
		`ConnectToSlo:` + fmt.Sprintf("%#v", this.ConnectToSlo) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ConnectToSli) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&subnet.GlobalSpecType_ConnectToSli{` +
		`ConnectToSli:` + fmt.Sprintf("%#v", this.ConnectToSli) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_IsolatedNw) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&subnet.GlobalSpecType_IsolatedNw{` +
		`IsolatedNw:` + fmt.Sprintf("%#v", this.IsolatedNw) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ConnectToLayer2) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&subnet.GlobalSpecType_ConnectToLayer2{` +
		`ConnectToLayer2:` + fmt.Sprintf("%#v", this.ConnectToLayer2) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&subnet.CreateSpecType{")
	if this.SiteSubnetParams != nil {
		s = append(s, "SiteSubnetParams: "+fmt.Sprintf("%#v", this.SiteSubnetParams)+",\n")
	}
	if this.ConnectionChoice != nil {
		s = append(s, "ConnectionChoice: "+fmt.Sprintf("%#v", this.ConnectionChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_ConnectToSlo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&subnet.CreateSpecType_ConnectToSlo{` +
		`ConnectToSlo:` + fmt.Sprintf("%#v", this.ConnectToSlo) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ConnectToSli) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&subnet.CreateSpecType_ConnectToSli{` +
		`ConnectToSli:` + fmt.Sprintf("%#v", this.ConnectToSli) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_IsolatedNw) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&subnet.CreateSpecType_IsolatedNw{` +
		`IsolatedNw:` + fmt.Sprintf("%#v", this.IsolatedNw) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ConnectToLayer2) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&subnet.CreateSpecType_ConnectToLayer2{` +
		`ConnectToLayer2:` + fmt.Sprintf("%#v", this.ConnectToLayer2) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&subnet.GetSpecType{")
	if this.SiteSubnetParams != nil {
		s = append(s, "SiteSubnetParams: "+fmt.Sprintf("%#v", this.SiteSubnetParams)+",\n")
	}
	if this.ConnectionChoice != nil {
		s = append(s, "ConnectionChoice: "+fmt.Sprintf("%#v", this.ConnectionChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_ConnectToSlo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&subnet.GetSpecType_ConnectToSlo{` +
		`ConnectToSlo:` + fmt.Sprintf("%#v", this.ConnectToSlo) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ConnectToSli) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&subnet.GetSpecType_ConnectToSli{` +
		`ConnectToSli:` + fmt.Sprintf("%#v", this.ConnectToSli) + `}`}, ", ")
	return s
}
func (this *GetSpecType_IsolatedNw) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&subnet.GetSpecType_IsolatedNw{` +
		`IsolatedNw:` + fmt.Sprintf("%#v", this.IsolatedNw) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ConnectToLayer2) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&subnet.GetSpecType_ConnectToLayer2{` +
		`ConnectToLayer2:` + fmt.Sprintf("%#v", this.ConnectToLayer2) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&subnet.ReplaceSpecType{")
	if this.ConnectionChoice != nil {
		s = append(s, "ConnectionChoice: "+fmt.Sprintf("%#v", this.ConnectionChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_ConnectToSlo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&subnet.ReplaceSpecType_ConnectToSlo{` +
		`ConnectToSlo:` + fmt.Sprintf("%#v", this.ConnectToSlo) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ConnectToSli) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&subnet.ReplaceSpecType_ConnectToSli{` +
		`ConnectToSli:` + fmt.Sprintf("%#v", this.ConnectToSli) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_IsolatedNw) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&subnet.ReplaceSpecType_IsolatedNw{` +
		`IsolatedNw:` + fmt.Sprintf("%#v", this.IsolatedNw) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ConnectToLayer2) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&subnet.ReplaceSpecType_ConnectToLayer2{` +
		`ConnectToLayer2:` + fmt.Sprintf("%#v", this.ConnectToLayer2) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *SubnetDHCPServerParametersType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetDHCPServerParametersType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubnetDHCPServerParametersType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Site) > 0 {
		for iNdEx := len(m.Site) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Site[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.SubnetDhcpServerParams != nil {
		{
			size, err := m.SubnetDhcpServerParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *DHCPNetworkType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPNetworkType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPNetworkType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NetworkPrefixChoice != nil {
		{
			size := m.NetworkPrefixChoice.Size()
			i -= size
			if _, err := m.NetworkPrefixChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DHCPNetworkType_NetworkPrefix) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPNetworkType_NetworkPrefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.NetworkPrefix)
	copy(dAtA[i:], m.NetworkPrefix)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.NetworkPrefix)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *DHCPNetworkType_NetworkPrefixIpv6) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPNetworkType_NetworkPrefixIpv6) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.NetworkPrefixIpv6)
	copy(dAtA[i:], m.NetworkPrefixIpv6)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.NetworkPrefixIpv6)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *DHCPServerParametersType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPServerParametersType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPServerParametersType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DhcpNetworks) > 0 {
		for iNdEx := len(m.DhcpNetworks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DhcpNetworks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SiteSubnetParametersType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteSubnetParametersType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteSubnetParametersType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AddressChoice != nil {
		{
			size := m.AddressChoice.Size()
			i -= size
			if _, err := m.AddressChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.SubnetDhcpServerParams != nil {
		{
			size, err := m.SubnetDhcpServerParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Site != nil {
		{
			size, err := m.Site.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SiteSubnetParametersType_Dhcp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteSubnetParametersType_Dhcp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Dhcp != nil {
		{
			size, err := m.Dhcp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *SiteSubnetParametersType_StaticIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteSubnetParametersType_StaticIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StaticIp != nil {
		{
			size, err := m.StaticIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ConnectToLayer2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectToLayer2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConnectToLayer2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Layer2IntfInternalRef) > 0 {
		for iNdEx := len(m.Layer2IntfInternalRef) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Layer2IntfInternalRef[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Layer2IntfRef != nil {
		{
			size, err := m.Layer2IntfRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SiteDhcpServerParamsInternal) > 0 {
		for iNdEx := len(m.SiteDhcpServerParamsInternal) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SiteDhcpServerParamsInternal[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xc2
		}
	}
	if m.ConnectionChoice != nil {
		{
			size := m.ConnectionChoice.Size()
			i -= size
			if _, err := m.ConnectionChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.SiteSubnetParams) > 0 {
		for iNdEx := len(m.SiteSubnetParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SiteSubnetParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_ConnectToSlo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_ConnectToSlo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConnectToSlo != nil {
		{
			size, err := m.ConnectToSlo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_ConnectToSli) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_ConnectToSli) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConnectToSli != nil {
		{
			size, err := m.ConnectToSli.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_IsolatedNw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_IsolatedNw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IsolatedNw != nil {
		{
			size, err := m.IsolatedNw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_ConnectToLayer2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_ConnectToLayer2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConnectToLayer2 != nil {
		{
			size, err := m.ConnectToLayer2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConnectionChoice != nil {
		{
			size := m.ConnectionChoice.Size()
			i -= size
			if _, err := m.ConnectionChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.SiteSubnetParams) > 0 {
		for iNdEx := len(m.SiteSubnetParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SiteSubnetParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_ConnectToSlo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_ConnectToSlo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConnectToSlo != nil {
		{
			size, err := m.ConnectToSlo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_ConnectToSli) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_ConnectToSli) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConnectToSli != nil {
		{
			size, err := m.ConnectToSli.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_IsolatedNw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_IsolatedNw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IsolatedNw != nil {
		{
			size, err := m.IsolatedNw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_ConnectToLayer2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_ConnectToLayer2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConnectToLayer2 != nil {
		{
			size, err := m.ConnectToLayer2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConnectionChoice != nil {
		{
			size := m.ConnectionChoice.Size()
			i -= size
			if _, err := m.ConnectionChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.SiteSubnetParams) > 0 {
		for iNdEx := len(m.SiteSubnetParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SiteSubnetParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_ConnectToSlo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_ConnectToSlo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConnectToSlo != nil {
		{
			size, err := m.ConnectToSlo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_ConnectToSli) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_ConnectToSli) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConnectToSli != nil {
		{
			size, err := m.ConnectToSli.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_IsolatedNw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_IsolatedNw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IsolatedNw != nil {
		{
			size, err := m.IsolatedNw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_ConnectToLayer2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_ConnectToLayer2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConnectToLayer2 != nil {
		{
			size, err := m.ConnectToLayer2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConnectionChoice != nil {
		{
			size := m.ConnectionChoice.Size()
			i -= size
			if _, err := m.ConnectionChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_ConnectToSlo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_ConnectToSlo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConnectToSlo != nil {
		{
			size, err := m.ConnectToSlo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_ConnectToSli) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_ConnectToSli) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConnectToSli != nil {
		{
			size, err := m.ConnectToSli.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_IsolatedNw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_IsolatedNw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IsolatedNw != nil {
		{
			size, err := m.IsolatedNw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_ConnectToLayer2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_ConnectToLayer2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConnectToLayer2 != nil {
		{
			size, err := m.ConnectToLayer2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SubnetDHCPServerParametersType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubnetDhcpServerParams != nil {
		l = m.SubnetDhcpServerParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Site) > 0 {
		for _, e := range m.Site {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *DHCPNetworkType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NetworkPrefixChoice != nil {
		n += m.NetworkPrefixChoice.Size()
	}
	return n
}

func (m *DHCPNetworkType_NetworkPrefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NetworkPrefix)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *DHCPNetworkType_NetworkPrefixIpv6) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NetworkPrefixIpv6)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *DHCPServerParametersType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DhcpNetworks) > 0 {
		for _, e := range m.DhcpNetworks {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *SiteSubnetParametersType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Site != nil {
		l = m.Site.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SubnetDhcpServerParams != nil {
		l = m.SubnetDhcpServerParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AddressChoice != nil {
		n += m.AddressChoice.Size()
	}
	return n
}

func (m *SiteSubnetParametersType_Dhcp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dhcp != nil {
		l = m.Dhcp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SiteSubnetParametersType_StaticIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StaticIp != nil {
		l = m.StaticIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ConnectToLayer2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Layer2IntfRef != nil {
		l = m.Layer2IntfRef.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Layer2IntfInternalRef) > 0 {
		for _, e := range m.Layer2IntfInternalRef {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SiteSubnetParams) > 0 {
		for _, e := range m.SiteSubnetParams {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.ConnectionChoice != nil {
		n += m.ConnectionChoice.Size()
	}
	if len(m.SiteDhcpServerParamsInternal) > 0 {
		for _, e := range m.SiteDhcpServerParamsInternal {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalSpecType_ConnectToSlo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectToSlo != nil {
		l = m.ConnectToSlo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_ConnectToSli) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectToSli != nil {
		l = m.ConnectToSli.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_IsolatedNw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsolatedNw != nil {
		l = m.IsolatedNw.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_ConnectToLayer2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectToLayer2 != nil {
		l = m.ConnectToLayer2.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SiteSubnetParams) > 0 {
		for _, e := range m.SiteSubnetParams {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.ConnectionChoice != nil {
		n += m.ConnectionChoice.Size()
	}
	return n
}

func (m *CreateSpecType_ConnectToSlo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectToSlo != nil {
		l = m.ConnectToSlo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_ConnectToSli) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectToSli != nil {
		l = m.ConnectToSli.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_IsolatedNw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsolatedNw != nil {
		l = m.IsolatedNw.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_ConnectToLayer2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectToLayer2 != nil {
		l = m.ConnectToLayer2.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SiteSubnetParams) > 0 {
		for _, e := range m.SiteSubnetParams {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.ConnectionChoice != nil {
		n += m.ConnectionChoice.Size()
	}
	return n
}

func (m *GetSpecType_ConnectToSlo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectToSlo != nil {
		l = m.ConnectToSlo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_ConnectToSli) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectToSli != nil {
		l = m.ConnectToSli.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_IsolatedNw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsolatedNw != nil {
		l = m.IsolatedNw.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_ConnectToLayer2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectToLayer2 != nil {
		l = m.ConnectToLayer2.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectionChoice != nil {
		n += m.ConnectionChoice.Size()
	}
	return n
}

func (m *ReplaceSpecType_ConnectToSlo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectToSlo != nil {
		l = m.ConnectToSlo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_ConnectToSli) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectToSli != nil {
		l = m.ConnectToSli.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_IsolatedNw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsolatedNw != nil {
		l = m.IsolatedNw.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_ConnectToLayer2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectToLayer2 != nil {
		l = m.ConnectToLayer2.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *SubnetDHCPServerParametersType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSite := "[]*ObjectRefType{"
	for _, f := range this.Site {
		repeatedStringForSite += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForSite += "}"
	s := strings.Join([]string{`&SubnetDHCPServerParametersType{`,
		`SubnetDhcpServerParams:` + strings.Replace(fmt.Sprintf("%v", this.SubnetDhcpServerParams), "DHCPServerParametersType", "network_interface.DHCPServerParametersType", 1) + `,`,
		`Site:` + repeatedStringForSite + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPNetworkType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPNetworkType{`,
		`NetworkPrefixChoice:` + fmt.Sprintf("%v", this.NetworkPrefixChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPNetworkType_NetworkPrefix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPNetworkType_NetworkPrefix{`,
		`NetworkPrefix:` + fmt.Sprintf("%v", this.NetworkPrefix) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPNetworkType_NetworkPrefixIpv6) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPNetworkType_NetworkPrefixIpv6{`,
		`NetworkPrefixIpv6:` + fmt.Sprintf("%v", this.NetworkPrefixIpv6) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPServerParametersType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForDhcpNetworks := "[]*DHCPNetworkType{"
	for _, f := range this.DhcpNetworks {
		repeatedStringForDhcpNetworks += strings.Replace(f.String(), "DHCPNetworkType", "DHCPNetworkType", 1) + ","
	}
	repeatedStringForDhcpNetworks += "}"
	s := strings.Join([]string{`&DHCPServerParametersType{`,
		`DhcpNetworks:` + repeatedStringForDhcpNetworks + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteSubnetParametersType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteSubnetParametersType{`,
		`Site:` + strings.Replace(fmt.Sprintf("%v", this.Site), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`SubnetDhcpServerParams:` + strings.Replace(this.SubnetDhcpServerParams.String(), "DHCPServerParametersType", "DHCPServerParametersType", 1) + `,`,
		`AddressChoice:` + fmt.Sprintf("%v", this.AddressChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteSubnetParametersType_Dhcp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteSubnetParametersType_Dhcp{`,
		`Dhcp:` + strings.Replace(fmt.Sprintf("%v", this.Dhcp), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteSubnetParametersType_StaticIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteSubnetParametersType_StaticIp{`,
		`StaticIp:` + strings.Replace(fmt.Sprintf("%v", this.StaticIp), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConnectToLayer2) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForLayer2IntfInternalRef := "[]*ObjectRefType{"
	for _, f := range this.Layer2IntfInternalRef {
		repeatedStringForLayer2IntfInternalRef += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForLayer2IntfInternalRef += "}"
	s := strings.Join([]string{`&ConnectToLayer2{`,
		`Layer2IntfRef:` + strings.Replace(fmt.Sprintf("%v", this.Layer2IntfRef), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`Layer2IntfInternalRef:` + repeatedStringForLayer2IntfInternalRef + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSiteSubnetParams := "[]*SiteSubnetParametersType{"
	for _, f := range this.SiteSubnetParams {
		repeatedStringForSiteSubnetParams += strings.Replace(f.String(), "SiteSubnetParametersType", "SiteSubnetParametersType", 1) + ","
	}
	repeatedStringForSiteSubnetParams += "}"
	repeatedStringForSiteDhcpServerParamsInternal := "[]*SubnetDHCPServerParametersType{"
	for _, f := range this.SiteDhcpServerParamsInternal {
		repeatedStringForSiteDhcpServerParamsInternal += strings.Replace(f.String(), "SubnetDHCPServerParametersType", "SubnetDHCPServerParametersType", 1) + ","
	}
	repeatedStringForSiteDhcpServerParamsInternal += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`SiteSubnetParams:` + repeatedStringForSiteSubnetParams + `,`,
		`ConnectionChoice:` + fmt.Sprintf("%v", this.ConnectionChoice) + `,`,
		`SiteDhcpServerParamsInternal:` + repeatedStringForSiteDhcpServerParamsInternal + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ConnectToSlo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ConnectToSlo{`,
		`ConnectToSlo:` + strings.Replace(fmt.Sprintf("%v", this.ConnectToSlo), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ConnectToSli) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ConnectToSli{`,
		`ConnectToSli:` + strings.Replace(fmt.Sprintf("%v", this.ConnectToSli), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_IsolatedNw) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_IsolatedNw{`,
		`IsolatedNw:` + strings.Replace(fmt.Sprintf("%v", this.IsolatedNw), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ConnectToLayer2) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ConnectToLayer2{`,
		`ConnectToLayer2:` + strings.Replace(fmt.Sprintf("%v", this.ConnectToLayer2), "ConnectToLayer2", "ConnectToLayer2", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSiteSubnetParams := "[]*SiteSubnetParametersType{"
	for _, f := range this.SiteSubnetParams {
		repeatedStringForSiteSubnetParams += strings.Replace(f.String(), "SiteSubnetParametersType", "SiteSubnetParametersType", 1) + ","
	}
	repeatedStringForSiteSubnetParams += "}"
	s := strings.Join([]string{`&CreateSpecType{`,
		`SiteSubnetParams:` + repeatedStringForSiteSubnetParams + `,`,
		`ConnectionChoice:` + fmt.Sprintf("%v", this.ConnectionChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ConnectToSlo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ConnectToSlo{`,
		`ConnectToSlo:` + strings.Replace(fmt.Sprintf("%v", this.ConnectToSlo), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ConnectToSli) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ConnectToSli{`,
		`ConnectToSli:` + strings.Replace(fmt.Sprintf("%v", this.ConnectToSli), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_IsolatedNw) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_IsolatedNw{`,
		`IsolatedNw:` + strings.Replace(fmt.Sprintf("%v", this.IsolatedNw), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ConnectToLayer2) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ConnectToLayer2{`,
		`ConnectToLayer2:` + strings.Replace(fmt.Sprintf("%v", this.ConnectToLayer2), "ConnectToLayer2", "ConnectToLayer2", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSiteSubnetParams := "[]*SiteSubnetParametersType{"
	for _, f := range this.SiteSubnetParams {
		repeatedStringForSiteSubnetParams += strings.Replace(f.String(), "SiteSubnetParametersType", "SiteSubnetParametersType", 1) + ","
	}
	repeatedStringForSiteSubnetParams += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`SiteSubnetParams:` + repeatedStringForSiteSubnetParams + `,`,
		`ConnectionChoice:` + fmt.Sprintf("%v", this.ConnectionChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ConnectToSlo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ConnectToSlo{`,
		`ConnectToSlo:` + strings.Replace(fmt.Sprintf("%v", this.ConnectToSlo), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ConnectToSli) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ConnectToSli{`,
		`ConnectToSli:` + strings.Replace(fmt.Sprintf("%v", this.ConnectToSli), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_IsolatedNw) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_IsolatedNw{`,
		`IsolatedNw:` + strings.Replace(fmt.Sprintf("%v", this.IsolatedNw), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ConnectToLayer2) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ConnectToLayer2{`,
		`ConnectToLayer2:` + strings.Replace(fmt.Sprintf("%v", this.ConnectToLayer2), "ConnectToLayer2", "ConnectToLayer2", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`ConnectionChoice:` + fmt.Sprintf("%v", this.ConnectionChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ConnectToSlo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ConnectToSlo{`,
		`ConnectToSlo:` + strings.Replace(fmt.Sprintf("%v", this.ConnectToSlo), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ConnectToSli) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ConnectToSli{`,
		`ConnectToSli:` + strings.Replace(fmt.Sprintf("%v", this.ConnectToSli), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_IsolatedNw) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_IsolatedNw{`,
		`IsolatedNw:` + strings.Replace(fmt.Sprintf("%v", this.IsolatedNw), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ConnectToLayer2) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ConnectToLayer2{`,
		`ConnectToLayer2:` + strings.Replace(fmt.Sprintf("%v", this.ConnectToLayer2), "ConnectToLayer2", "ConnectToLayer2", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *SubnetDHCPServerParametersType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetDHCPServerParametersType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetDHCPServerParametersType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetDhcpServerParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubnetDhcpServerParams == nil {
				m.SubnetDhcpServerParams = &network_interface.DHCPServerParametersType{}
			}
			if err := m.SubnetDhcpServerParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = append(m.Site, &schema.ObjectRefType{})
			if err := m.Site[len(m.Site)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHCPNetworkType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPNetworkType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPNetworkType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkPrefixChoice = &DHCPNetworkType_NetworkPrefix{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkPrefixIpv6", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkPrefixChoice = &DHCPNetworkType_NetworkPrefixIpv6{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHCPServerParametersType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPServerParametersType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPServerParametersType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpNetworks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DhcpNetworks = append(m.DhcpNetworks, &DHCPNetworkType{})
			if err := m.DhcpNetworks[len(m.DhcpNetworks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteSubnetParametersType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteSubnetParametersType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteSubnetParametersType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Site == nil {
				m.Site = &views.ObjectRefType{}
			}
			if err := m.Site.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetDhcpServerParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubnetDhcpServerParams == nil {
				m.SubnetDhcpServerParams = &DHCPServerParametersType{}
			}
			if err := m.SubnetDhcpServerParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dhcp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AddressChoice = &SiteSubnetParametersType_Dhcp{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AddressChoice = &SiteSubnetParametersType_StaticIp{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectToLayer2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectToLayer2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectToLayer2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer2IntfRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Layer2IntfRef == nil {
				m.Layer2IntfRef = &views.ObjectRefType{}
			}
			if err := m.Layer2IntfRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer2IntfInternalRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Layer2IntfInternalRef = append(m.Layer2IntfInternalRef, &schema.ObjectRefType{})
			if err := m.Layer2IntfInternalRef[len(m.Layer2IntfInternalRef)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteSubnetParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteSubnetParams = append(m.SiteSubnetParams, &SiteSubnetParametersType{})
			if err := m.SiteSubnetParams[len(m.SiteSubnetParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectToSlo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConnectionChoice = &GlobalSpecType_ConnectToSlo{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectToSli", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConnectionChoice = &GlobalSpecType_ConnectToSli{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsolatedNw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConnectionChoice = &GlobalSpecType_IsolatedNw{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectToLayer2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConnectToLayer2{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConnectionChoice = &GlobalSpecType_ConnectToLayer2{v}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteDhcpServerParamsInternal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteDhcpServerParamsInternal = append(m.SiteDhcpServerParamsInternal, &SubnetDHCPServerParametersType{})
			if err := m.SiteDhcpServerParamsInternal[len(m.SiteDhcpServerParamsInternal)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteSubnetParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteSubnetParams = append(m.SiteSubnetParams, &SiteSubnetParametersType{})
			if err := m.SiteSubnetParams[len(m.SiteSubnetParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectToSlo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConnectionChoice = &CreateSpecType_ConnectToSlo{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectToSli", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConnectionChoice = &CreateSpecType_ConnectToSli{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsolatedNw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConnectionChoice = &CreateSpecType_IsolatedNw{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectToLayer2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConnectToLayer2{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConnectionChoice = &CreateSpecType_ConnectToLayer2{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteSubnetParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteSubnetParams = append(m.SiteSubnetParams, &SiteSubnetParametersType{})
			if err := m.SiteSubnetParams[len(m.SiteSubnetParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectToSlo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConnectionChoice = &GetSpecType_ConnectToSlo{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectToSli", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConnectionChoice = &GetSpecType_ConnectToSli{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsolatedNw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConnectionChoice = &GetSpecType_IsolatedNw{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectToLayer2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConnectToLayer2{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConnectionChoice = &GetSpecType_ConnectToLayer2{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectToSlo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConnectionChoice = &ReplaceSpecType_ConnectToSlo{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectToSli", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConnectionChoice = &ReplaceSpecType_ConnectToSli{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsolatedNw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConnectionChoice = &ReplaceSpecType_IsolatedNw{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectToLayer2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConnectToLayer2{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConnectionChoice = &ReplaceSpecType_ConnectToLayer2{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
