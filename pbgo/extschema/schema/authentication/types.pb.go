// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/authentication/types.proto

package authentication

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type OIDCAuthParams struct {
	// Authorization Endpoint
	//
	// x-displayName: "Authorization Endpoint"
	// x-required
	// URL of the authorization server's authorization endpoint.
	AuthEndpointUrl string `protobuf:"bytes,1,opt,name=auth_endpoint_url,json=authEndpointUrl,proto3" json:"auth_endpoint_url,omitempty"`
	// Token Endpoint
	//
	// x-displayName: "Token Endpoint"
	// x-required
	// URL of the authorization server's Token endpoint.
	TokenEndpointUrl string `protobuf:"bytes,2,opt,name=token_endpoint_url,json=tokenEndpointUrl,proto3" json:"token_endpoint_url,omitempty"`
	// Logout Endpoint
	//
	// x-displayName: "Logout Endpoint"
	// x-required
	// URL of the authorization server's Logout endpoint.
	EndSessionEndpointUrl string `protobuf:"bytes,3,opt,name=end_session_endpoint_url,json=endSessionEndpointUrl,proto3" json:"end_session_endpoint_url,omitempty"`
}

func (m *OIDCAuthParams) Reset()      { *m = OIDCAuthParams{} }
func (*OIDCAuthParams) ProtoMessage() {}
func (*OIDCAuthParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_6383c56e4d3ec1bb, []int{0}
}
func (m *OIDCAuthParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OIDCAuthParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OIDCAuthParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OIDCAuthParams.Merge(m, src)
}
func (m *OIDCAuthParams) XXX_Size() int {
	return m.Size()
}
func (m *OIDCAuthParams) XXX_DiscardUnknown() {
	xxx_messageInfo_OIDCAuthParams.DiscardUnknown(m)
}

var xxx_messageInfo_OIDCAuthParams proto.InternalMessageInfo

func (m *OIDCAuthParams) GetAuthEndpointUrl() string {
	if m != nil {
		return m.AuthEndpointUrl
	}
	return ""
}

func (m *OIDCAuthParams) GetTokenEndpointUrl() string {
	if m != nil {
		return m.TokenEndpointUrl
	}
	return ""
}

func (m *OIDCAuthParams) GetEndSessionEndpointUrl() string {
	if m != nil {
		return m.EndSessionEndpointUrl
	}
	return ""
}

type OIDCAuthType struct {
	// OIDC Endpoint Configuration
	//
	// x-displayName: "OIDC Endpoint Configuration"
	// x-required
	// Configure OIDC Endpoints
	//
	// Types that are valid to be assigned to AuthParamsChoice:
	//	*OIDCAuthType_OidcWellKnownConfigUrl
	//	*OIDCAuthType_OidcAuthParams
	AuthParamsChoice isOIDCAuthType_AuthParamsChoice `protobuf_oneof:"auth_params_choice"`
	// OIDC Client ID
	//
	// x-displayName: "OIDC Client ID"
	// x-required
	// Client ID used while sending the Authorization Request to OIDC server
	OidcClientId string `protobuf:"bytes,4,opt,name=oidc_client_id,json=oidcClientId,proto3" json:"oidc_client_id,omitempty"`
	// OIDC Client Secret
	//
	// x-displayName: "OIDC Client Secret"
	// x-required
	// Client secret used while sending token verification request to OIDC server
	ClientSecret *schema.SecretType `protobuf:"bytes,5,opt,name=client_secret,json=clientSecret,proto3" json:"client_secret,omitempty"`
}

func (m *OIDCAuthType) Reset()      { *m = OIDCAuthType{} }
func (*OIDCAuthType) ProtoMessage() {}
func (*OIDCAuthType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6383c56e4d3ec1bb, []int{1}
}
func (m *OIDCAuthType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OIDCAuthType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OIDCAuthType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OIDCAuthType.Merge(m, src)
}
func (m *OIDCAuthType) XXX_Size() int {
	return m.Size()
}
func (m *OIDCAuthType) XXX_DiscardUnknown() {
	xxx_messageInfo_OIDCAuthType.DiscardUnknown(m)
}

var xxx_messageInfo_OIDCAuthType proto.InternalMessageInfo

type isOIDCAuthType_AuthParamsChoice interface {
	isOIDCAuthType_AuthParamsChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type OIDCAuthType_OidcWellKnownConfigUrl struct {
	OidcWellKnownConfigUrl string `protobuf:"bytes,2,opt,name=oidc_well_known_config_url,json=oidcWellKnownConfigUrl,proto3,oneof" json:"oidc_well_known_config_url,omitempty"`
}
type OIDCAuthType_OidcAuthParams struct {
	OidcAuthParams *OIDCAuthParams `protobuf:"bytes,3,opt,name=oidc_auth_params,json=oidcAuthParams,proto3,oneof" json:"oidc_auth_params,omitempty"`
}

func (*OIDCAuthType_OidcWellKnownConfigUrl) isOIDCAuthType_AuthParamsChoice() {}
func (*OIDCAuthType_OidcAuthParams) isOIDCAuthType_AuthParamsChoice()         {}

func (m *OIDCAuthType) GetAuthParamsChoice() isOIDCAuthType_AuthParamsChoice {
	if m != nil {
		return m.AuthParamsChoice
	}
	return nil
}

func (m *OIDCAuthType) GetOidcWellKnownConfigUrl() string {
	if x, ok := m.GetAuthParamsChoice().(*OIDCAuthType_OidcWellKnownConfigUrl); ok {
		return x.OidcWellKnownConfigUrl
	}
	return ""
}

func (m *OIDCAuthType) GetOidcAuthParams() *OIDCAuthParams {
	if x, ok := m.GetAuthParamsChoice().(*OIDCAuthType_OidcAuthParams); ok {
		return x.OidcAuthParams
	}
	return nil
}

func (m *OIDCAuthType) GetOidcClientId() string {
	if m != nil {
		return m.OidcClientId
	}
	return ""
}

func (m *OIDCAuthType) GetClientSecret() *schema.SecretType {
	if m != nil {
		return m.ClientSecret
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*OIDCAuthType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*OIDCAuthType_OidcWellKnownConfigUrl)(nil),
		(*OIDCAuthType_OidcAuthParams)(nil),
	}
}

// HMAC Key Pair
//
// x-displayName: "HMAC Key Pair"
// HMAC primary and secondary keys to be used for hashing the Cookie.
// Each key also have an associated expiry timestamp, beyond which key is invalid.
type HMACKeyPair struct {
	// HMAC Primary Key
	//
	// x-displayName: "HMAC Primary Key"
	// x-required
	// Primary HMAC Key
	PrimKey *schema.SecretType `protobuf:"bytes,1,opt,name=prim_key,json=primKey,proto3" json:"prim_key,omitempty"`
	// HMAC Primary Key Expiry Time
	//
	// x-displayName: "HMAC Primary Key Expiry"
	// x-required
	// Primary HMAC Key Expiry time
	PrimKeyExpiry *types.Timestamp `protobuf:"bytes,2,opt,name=prim_key_expiry,json=primKeyExpiry,proto3" json:"prim_key_expiry,omitempty"`
	//HMAC Secondary Key
	//
	// x-displayName: "HMAC Secondary Key"
	// x-required
	// Secondary HMAC Key
	SecKey *schema.SecretType `protobuf:"bytes,3,opt,name=sec_key,json=secKey,proto3" json:"sec_key,omitempty"`
	// HMAC Secondary Key Expiry Time
	//
	// x-displayName: "HMAC Secondary Key Expiry"
	// x-required
	// Secondary HMAC Key Expiry time
	SecKeyExpiry *types.Timestamp `protobuf:"bytes,4,opt,name=sec_key_expiry,json=secKeyExpiry,proto3" json:"sec_key_expiry,omitempty"`
}

func (m *HMACKeyPair) Reset()      { *m = HMACKeyPair{} }
func (*HMACKeyPair) ProtoMessage() {}
func (*HMACKeyPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_6383c56e4d3ec1bb, []int{2}
}
func (m *HMACKeyPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HMACKeyPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HMACKeyPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HMACKeyPair.Merge(m, src)
}
func (m *HMACKeyPair) XXX_Size() int {
	return m.Size()
}
func (m *HMACKeyPair) XXX_DiscardUnknown() {
	xxx_messageInfo_HMACKeyPair.DiscardUnknown(m)
}

var xxx_messageInfo_HMACKeyPair proto.InternalMessageInfo

func (m *HMACKeyPair) GetPrimKey() *schema.SecretType {
	if m != nil {
		return m.PrimKey
	}
	return nil
}

func (m *HMACKeyPair) GetPrimKeyExpiry() *types.Timestamp {
	if m != nil {
		return m.PrimKeyExpiry
	}
	return nil
}

func (m *HMACKeyPair) GetSecKey() *schema.SecretType {
	if m != nil {
		return m.SecKey
	}
	return nil
}

func (m *HMACKeyPair) GetSecKeyExpiry() *types.Timestamp {
	if m != nil {
		return m.SecKeyExpiry
	}
	return nil
}

// KMS Key Ref
//
// x-displayName: "KMS Key Reference"
// Reference to KMS Key Object
type KMSKeyRefType struct {
	// kms_key Reference
	//
	// x-displayName: "HMAC kms key reference"
	// HMAC configured using the KMS_KEY reference
	AuthHmacKms *views.ObjectRefType `protobuf:"bytes,1,opt,name=auth_hmac_kms,json=authHmacKms,proto3" json:"auth_hmac_kms,omitempty"`
}

func (m *KMSKeyRefType) Reset()      { *m = KMSKeyRefType{} }
func (*KMSKeyRefType) ProtoMessage() {}
func (*KMSKeyRefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6383c56e4d3ec1bb, []int{3}
}
func (m *KMSKeyRefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KMSKeyRefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *KMSKeyRefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KMSKeyRefType.Merge(m, src)
}
func (m *KMSKeyRefType) XXX_Size() int {
	return m.Size()
}
func (m *KMSKeyRefType) XXX_DiscardUnknown() {
	xxx_messageInfo_KMSKeyRefType.DiscardUnknown(m)
}

var xxx_messageInfo_KMSKeyRefType proto.InternalMessageInfo

func (m *KMSKeyRefType) GetAuthHmacKms() *views.ObjectRefType {
	if m != nil {
		return m.AuthHmacKms
	}
	return nil
}

// Cookie Parameters Config
//
// x-displayName: "Cookie Parameters"
// Specifies different cookie related config parameters for authentication
type CookieParams struct {
	// cookie refresh interval
	//
	// x-displayName: "Cookie Refresh Interval"
	// x-example: 3600
	// Specifies in seconds refresh interval for session cookie.
	// This is used to keep the active user active and reduce re-login.
	// When an incoming cookie's session expiry is still valid, and time to expire falls behind this interval,
	// re-issue a cookie with new expiry and with the same original session expiry.
	// Default refresh interval is 3000 seconds
	CookieRefreshInterval uint32 `protobuf:"varint,1,opt,name=cookie_refresh_interval,json=cookieRefreshInterval,proto3" json:"cookie_refresh_interval,omitempty"`
	// cookie expiry
	//
	// x-displayName: "Cookie Expiry duration"
	// x-example: 5000
	// specifies in seconds max duration of the allocated cookie. This maps to “Max-Age” attribute in the session cookie.
	// This will act as an expiry duration on the client side after which client will not  be setting the
	// cookie as part of the request.
	// Default cookie expiry is 3600 seconds
	CookieExpiry uint32 `protobuf:"varint,2,opt,name=cookie_expiry,json=cookieExpiry,proto3" json:"cookie_expiry,omitempty"`
	// session expiry
	//
	// x-displayName: "Session Expiry duration"
	// x-example: 36000
	// specifies in seconds max lifetime of an authenticated session after which the user will be forced to login again.
	// Default session expiry is 86400 seconds(24 hours).
	SessionExpiry uint32 `protobuf:"varint,3,opt,name=session_expiry,json=sessionExpiry,proto3" json:"session_expiry,omitempty"`
	// HMAC Choice
	//
	// x-displayName: "Select HMAC Type"
	// HMAC used to hash the cookie
	//
	// Types that are valid to be assigned to SecretChoice:
	//	*CookieParams_AuthHmac
	//	*CookieParams_KmsKeyHmac
	SecretChoice isCookieParams_SecretChoice `protobuf_oneof:"secret_choice"`
}

func (m *CookieParams) Reset()      { *m = CookieParams{} }
func (*CookieParams) ProtoMessage() {}
func (*CookieParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_6383c56e4d3ec1bb, []int{4}
}
func (m *CookieParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CookieParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CookieParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CookieParams.Merge(m, src)
}
func (m *CookieParams) XXX_Size() int {
	return m.Size()
}
func (m *CookieParams) XXX_DiscardUnknown() {
	xxx_messageInfo_CookieParams.DiscardUnknown(m)
}

var xxx_messageInfo_CookieParams proto.InternalMessageInfo

type isCookieParams_SecretChoice interface {
	isCookieParams_SecretChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CookieParams_AuthHmac struct {
	AuthHmac *HMACKeyPair `protobuf:"bytes,5,opt,name=auth_hmac,json=authHmac,proto3,oneof" json:"auth_hmac,omitempty"`
}
type CookieParams_KmsKeyHmac struct {
	KmsKeyHmac *KMSKeyRefType `protobuf:"bytes,6,opt,name=kms_key_hmac,json=kmsKeyHmac,proto3,oneof" json:"kms_key_hmac,omitempty"`
}

func (*CookieParams_AuthHmac) isCookieParams_SecretChoice()   {}
func (*CookieParams_KmsKeyHmac) isCookieParams_SecretChoice() {}

func (m *CookieParams) GetSecretChoice() isCookieParams_SecretChoice {
	if m != nil {
		return m.SecretChoice
	}
	return nil
}

func (m *CookieParams) GetCookieRefreshInterval() uint32 {
	if m != nil {
		return m.CookieRefreshInterval
	}
	return 0
}

func (m *CookieParams) GetCookieExpiry() uint32 {
	if m != nil {
		return m.CookieExpiry
	}
	return 0
}

func (m *CookieParams) GetSessionExpiry() uint32 {
	if m != nil {
		return m.SessionExpiry
	}
	return 0
}

func (m *CookieParams) GetAuthHmac() *HMACKeyPair {
	if x, ok := m.GetSecretChoice().(*CookieParams_AuthHmac); ok {
		return x.AuthHmac
	}
	return nil
}

func (m *CookieParams) GetKmsKeyHmac() *KMSKeyRefType {
	if x, ok := m.GetSecretChoice().(*CookieParams_KmsKeyHmac); ok {
		return x.KmsKeyHmac
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CookieParams) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CookieParams_AuthHmac)(nil),
		(*CookieParams_KmsKeyHmac)(nil),
	}
}

// GlobalSpecType
//
// x-displayName: "Authentication Specification"
// Shape of Authentication Object
type GlobalSpecType struct {
	// Authentication Type
	//
	// x-displayName: "Authentication Type"
	// x-required
	// Select Authentication Type
	//
	// Types that are valid to be assigned to AuthTypeChoice:
	//	*GlobalSpecType_OidcAuth
	AuthTypeChoice isGlobalSpecType_AuthTypeChoice `protobuf_oneof:"auth_type_choice"`
	// Cookie Configuration details
	//
	// x-displayName: "Cookie Configuration"
	// x-required
	// Cookie configuration details for this Object
	CookieParams *CookieParams `protobuf:"bytes,3,opt,name=cookie_params,json=cookieParams,proto3" json:"cookie_params,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6383c56e4d3ec1bb, []int{5}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_AuthTypeChoice interface {
	isGlobalSpecType_AuthTypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_OidcAuth struct {
	OidcAuth *OIDCAuthType `protobuf:"bytes,2,opt,name=oidc_auth,json=oidcAuth,proto3,oneof" json:"oidc_auth,omitempty"`
}

func (*GlobalSpecType_OidcAuth) isGlobalSpecType_AuthTypeChoice() {}

func (m *GlobalSpecType) GetAuthTypeChoice() isGlobalSpecType_AuthTypeChoice {
	if m != nil {
		return m.AuthTypeChoice
	}
	return nil
}

func (m *GlobalSpecType) GetOidcAuth() *OIDCAuthType {
	if x, ok := m.GetAuthTypeChoice().(*GlobalSpecType_OidcAuth); ok {
		return x.OidcAuth
	}
	return nil
}

func (m *GlobalSpecType) GetCookieParams() *CookieParams {
	if m != nil {
		return m.CookieParams
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_OidcAuth)(nil),
	}
}

// Create Authentication Object
//
// x-displayName: "Create Authentication"
type CreateSpecType struct {
	// Types that are valid to be assigned to AuthTypeChoice:
	//	*CreateSpecType_OidcAuth
	AuthTypeChoice isCreateSpecType_AuthTypeChoice `protobuf_oneof:"auth_type_choice"`
	CookieParams   *CookieParams                   `protobuf:"bytes,3,opt,name=cookie_params,json=cookieParams,proto3" json:"cookie_params,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6383c56e4d3ec1bb, []int{6}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_AuthTypeChoice interface {
	isCreateSpecType_AuthTypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_OidcAuth struct {
	OidcAuth *OIDCAuthType `protobuf:"bytes,2,opt,name=oidc_auth,json=oidcAuth,proto3,oneof" json:"oidc_auth,omitempty"`
}

func (*CreateSpecType_OidcAuth) isCreateSpecType_AuthTypeChoice() {}

func (m *CreateSpecType) GetAuthTypeChoice() isCreateSpecType_AuthTypeChoice {
	if m != nil {
		return m.AuthTypeChoice
	}
	return nil
}

func (m *CreateSpecType) GetOidcAuth() *OIDCAuthType {
	if x, ok := m.GetAuthTypeChoice().(*CreateSpecType_OidcAuth); ok {
		return x.OidcAuth
	}
	return nil
}

func (m *CreateSpecType) GetCookieParams() *CookieParams {
	if m != nil {
		return m.CookieParams
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_OidcAuth)(nil),
	}
}

// Replace Authentication
//
// x-displayName: "Replace Authentication"
type ReplaceSpecType struct {
	// Types that are valid to be assigned to AuthTypeChoice:
	//	*ReplaceSpecType_OidcAuth
	AuthTypeChoice isReplaceSpecType_AuthTypeChoice `protobuf_oneof:"auth_type_choice"`
	CookieParams   *CookieParams                    `protobuf:"bytes,3,opt,name=cookie_params,json=cookieParams,proto3" json:"cookie_params,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6383c56e4d3ec1bb, []int{7}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_AuthTypeChoice interface {
	isReplaceSpecType_AuthTypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_OidcAuth struct {
	OidcAuth *OIDCAuthType `protobuf:"bytes,2,opt,name=oidc_auth,json=oidcAuth,proto3,oneof" json:"oidc_auth,omitempty"`
}

func (*ReplaceSpecType_OidcAuth) isReplaceSpecType_AuthTypeChoice() {}

func (m *ReplaceSpecType) GetAuthTypeChoice() isReplaceSpecType_AuthTypeChoice {
	if m != nil {
		return m.AuthTypeChoice
	}
	return nil
}

func (m *ReplaceSpecType) GetOidcAuth() *OIDCAuthType {
	if x, ok := m.GetAuthTypeChoice().(*ReplaceSpecType_OidcAuth); ok {
		return x.OidcAuth
	}
	return nil
}

func (m *ReplaceSpecType) GetCookieParams() *CookieParams {
	if m != nil {
		return m.CookieParams
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_OidcAuth)(nil),
	}
}

// Get Authentication
//
// x-displayName: "Get Authentication"
type GetSpecType struct {
	// Types that are valid to be assigned to AuthTypeChoice:
	//	*GetSpecType_OidcAuth
	AuthTypeChoice isGetSpecType_AuthTypeChoice `protobuf_oneof:"auth_type_choice"`
	CookieParams   *CookieParams                `protobuf:"bytes,3,opt,name=cookie_params,json=cookieParams,proto3" json:"cookie_params,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6383c56e4d3ec1bb, []int{8}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_AuthTypeChoice interface {
	isGetSpecType_AuthTypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_OidcAuth struct {
	OidcAuth *OIDCAuthType `protobuf:"bytes,2,opt,name=oidc_auth,json=oidcAuth,proto3,oneof" json:"oidc_auth,omitempty"`
}

func (*GetSpecType_OidcAuth) isGetSpecType_AuthTypeChoice() {}

func (m *GetSpecType) GetAuthTypeChoice() isGetSpecType_AuthTypeChoice {
	if m != nil {
		return m.AuthTypeChoice
	}
	return nil
}

func (m *GetSpecType) GetOidcAuth() *OIDCAuthType {
	if x, ok := m.GetAuthTypeChoice().(*GetSpecType_OidcAuth); ok {
		return x.OidcAuth
	}
	return nil
}

func (m *GetSpecType) GetCookieParams() *CookieParams {
	if m != nil {
		return m.CookieParams
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_OidcAuth)(nil),
	}
}

func init() {
	proto.RegisterType((*OIDCAuthParams)(nil), "ves.io.schema.authentication.OIDCAuthParams")
	golang_proto.RegisterType((*OIDCAuthParams)(nil), "ves.io.schema.authentication.OIDCAuthParams")
	proto.RegisterType((*OIDCAuthType)(nil), "ves.io.schema.authentication.OIDCAuthType")
	golang_proto.RegisterType((*OIDCAuthType)(nil), "ves.io.schema.authentication.OIDCAuthType")
	proto.RegisterType((*HMACKeyPair)(nil), "ves.io.schema.authentication.HMACKeyPair")
	golang_proto.RegisterType((*HMACKeyPair)(nil), "ves.io.schema.authentication.HMACKeyPair")
	proto.RegisterType((*KMSKeyRefType)(nil), "ves.io.schema.authentication.KMSKeyRefType")
	golang_proto.RegisterType((*KMSKeyRefType)(nil), "ves.io.schema.authentication.KMSKeyRefType")
	proto.RegisterType((*CookieParams)(nil), "ves.io.schema.authentication.CookieParams")
	golang_proto.RegisterType((*CookieParams)(nil), "ves.io.schema.authentication.CookieParams")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.authentication.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.authentication.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.authentication.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.authentication.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.authentication.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.authentication.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.authentication.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.authentication.GetSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/authentication/types.proto", fileDescriptor_6383c56e4d3ec1bb)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/authentication/types.proto", fileDescriptor_6383c56e4d3ec1bb)
}

var fileDescriptor_6383c56e4d3ec1bb = []byte{
	// 1078 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x56, 0xdb, 0x6f, 0xdb, 0x54,
	0x18, 0xf7, 0xc9, 0xa5, 0x97, 0x93, 0x4b, 0x33, 0xc3, 0x68, 0x16, 0x26, 0xaf, 0x8b, 0x04, 0x2a,
	0xa3, 0x75, 0x4a, 0x3b, 0x2a, 0x84, 0x60, 0xd0, 0x84, 0x69, 0xe9, 0xa2, 0x2a, 0x93, 0x3b, 0x2e,
	0xda, 0x8b, 0xe5, 0x38, 0x5f, 0x13, 0x13, 0xdb, 0xc7, 0xb2, 0x4f, 0xda, 0xe5, 0x01, 0xa9, 0xe2,
	0x19, 0xa4, 0xfe, 0x0b, 0x88, 0x17, 0xc4, 0x9f, 0x40, 0x5e, 0x2a, 0x9e, 0x10, 0x4f, 0x7d, 0xac,
	0xf6, 0x44, 0xd3, 0x97, 0x21, 0x21, 0xd1, 0x17, 0xa4, 0x09, 0x09, 0x09, 0xf9, 0xf8, 0xb8, 0xd8,
	0xe9, 0xd4, 0x96, 0xc7, 0x69, 0x6f, 0xe7, 0x9c, 0xef, 0xfb, 0xfd, 0xbe, 0xfb, 0x67, 0xe3, 0xf9,
	0x6d, 0xf0, 0x64, 0x83, 0x54, 0x3c, 0xbd, 0x0b, 0x96, 0x56, 0xd1, 0xfa, 0xb4, 0x0b, 0x36, 0x35,
	0x74, 0x8d, 0x1a, 0xc4, 0xae, 0xd0, 0x81, 0x03, 0x9e, 0xec, 0xb8, 0x84, 0x12, 0xf1, 0x7a, 0xa0,
	0x29, 0x07, 0x9a, 0x72, 0x5c, 0xb3, 0xb4, 0xd8, 0x31, 0x68, 0xb7, 0xdf, 0x92, 0x75, 0x62, 0x55,
	0x3a, 0xa4, 0x43, 0x2a, 0x0c, 0xd4, 0xea, 0x6f, 0xb1, 0x1b, 0xbb, 0xb0, 0x53, 0x40, 0x56, 0xba,
	0xd1, 0x21, 0xa4, 0x63, 0xc2, 0x7f, 0x5a, 0xd4, 0xb0, 0xc0, 0xa3, 0x9a, 0xe5, 0x70, 0x85, 0xd9,
	0xb8, 0x5f, 0x36, 0x50, 0x2e, 0x78, 0x3d, 0x2e, 0x20, 0x8e, 0x6f, 0x9e, 0xfb, 0x58, 0xba, 0x16,
	0x17, 0x46, 0xdc, 0x2f, 0x5d, 0x8f, 0x8b, 0xb6, 0x35, 0xd3, 0x68, 0x6b, 0x14, 0xb8, 0x74, 0x6e,
	0x4c, 0x6a, 0xc0, 0x8e, 0x1a, 0xa7, 0xbe, 0x71, 0x56, 0xc3, 0x8b, 0x1a, 0x28, 0x7f, 0x93, 0xc0,
	0xf9, 0xe6, 0xfa, 0x27, 0xb5, 0xb5, 0x3e, 0xed, 0x3e, 0xd0, 0x5c, 0xcd, 0xf2, 0xc4, 0x0d, 0x7c,
	0xc5, 0x4f, 0x93, 0x0a, 0x76, 0xdb, 0x21, 0x86, 0x4d, 0xd5, 0xbe, 0x6b, 0x16, 0xd1, 0x1c, 0x9a,
	0x9f, 0xae, 0xde, 0x7c, 0x36, 0x44, 0x89, 0x9f, 0x7e, 0xdf, 0x4f, 0xa6, 0xdd, 0x64, 0x71, 0x17,
	0xf9, 0xa7, 0x94, 0x9b, 0x28, 0x20, 0xfe, 0xb4, 0x87, 0x90, 0x32, 0xe3, 0x63, 0xef, 0x72, 0xe8,
	0xa7, 0xae, 0x29, 0x36, 0xb1, 0x48, 0x49, 0x0f, 0xec, 0x38, 0x5f, 0xe2, 0xb2, 0x7c, 0x05, 0x06,
	0x8e, 0x12, 0x3e, 0xc2, 0x45, 0xb0, 0xdb, 0xaa, 0x07, 0x9e, 0x67, 0x90, 0x31, 0xda, 0xe4, 0x65,
	0x69, 0xaf, 0x82, 0xdd, 0xde, 0x0c, 0x18, 0x22, 0xdc, 0xe5, 0xbf, 0x12, 0x38, 0x1b, 0xa6, 0xe3,
	0xe1, 0xc0, 0x01, 0x51, 0xc5, 0x25, 0x62, 0xb4, 0x75, 0x75, 0x07, 0x4c, 0x53, 0xed, 0xd9, 0x64,
	0xc7, 0x56, 0x75, 0x62, 0x6f, 0x19, 0x9d, 0xff, 0x15, 0x45, 0x5d, 0x50, 0x5e, 0xf3, 0x69, 0x3e,
	0x07, 0xd3, 0x6c, 0xf8, 0x24, 0x35, 0xc6, 0xe1, 0x47, 0xf3, 0x05, 0x2e, 0x30, 0x03, 0x2c, 0xe5,
	0x0e, 0xab, 0x00, 0x8b, 0x22, 0xb3, 0xbc, 0x20, 0x9f, 0xd7, 0xbb, 0x72, 0xbc, 0x6a, 0x75, 0x41,
	0xc9, 0xfb, 0x3c, 0x91, 0x3a, 0x7e, 0x88, 0xd9, 0x8b, 0xaa, 0x9b, 0x06, 0xd8, 0x54, 0x35, 0xda,
	0xc5, 0x14, 0x73, 0x77, 0x36, 0xe6, 0x6e, 0xe2, 0xd4, 0x5d, 0x25, 0xeb, 0xab, 0xd7, 0x98, 0xf6,
	0x7a, 0x5b, 0xbc, 0x83, 0x73, 0x1c, 0xe9, 0x81, 0xee, 0x02, 0x2d, 0xa6, 0x99, 0x57, 0xd7, 0xc6,
	0xbc, 0xda, 0x64, 0x42, 0x3f, 0x57, 0x4a, 0x36, 0xd0, 0x0f, 0x5e, 0xaa, 0x6f, 0x60, 0x31, 0x12,
	0x93, 0xaa, 0x77, 0x89, 0xa1, 0x83, 0x38, 0xb3, 0x3f, 0x44, 0x89, 0x83, 0x21, 0x42, 0xa3, 0x21,
	0x4a, 0x2e, 0x2f, 0xac, 0xdc, 0x4f, 0x4d, 0xa1, 0x42, 0xa2, 0xfc, 0x0f, 0xc2, 0x99, 0xfa, 0xc6,
	0x5a, 0xad, 0x01, 0x83, 0x07, 0x9a, 0xe1, 0x8a, 0xb7, 0xf1, 0x94, 0xe3, 0x1a, 0x96, 0xda, 0x83,
	0x01, 0x6b, 0xbd, 0x73, 0xed, 0x4e, 0xfa, 0xaa, 0x0d, 0x18, 0x88, 0x55, 0x3c, 0x13, 0xa2, 0x54,
	0x78, 0xec, 0x18, 0xee, 0x80, 0x55, 0x28, 0xb3, 0x5c, 0x92, 0x83, 0xc9, 0x95, 0xc3, 0xc9, 0x95,
	0x1f, 0x86, 0x93, 0xab, 0xe4, 0x38, 0xfa, 0x2e, 0x03, 0x88, 0xcb, 0x78, 0xd2, 0x03, 0x9d, 0x19,
	0x4e, 0x5e, 0x64, 0x78, 0xc2, 0x03, 0xdd, 0xb7, 0xfb, 0x31, 0xce, 0x73, 0x4c, 0x68, 0x36, 0x75,
	0xa1, 0xd9, 0x6c, 0x80, 0x0d, 0xac, 0x96, 0x3b, 0x38, 0xd7, 0xd8, 0xd8, 0x6c, 0xc0, 0x40, 0x81,
	0x2d, 0xd6, 0x77, 0x9f, 0xe1, 0x1c, 0xcb, 0x5e, 0xd7, 0xd2, 0x74, 0xb5, 0x67, 0x79, 0x3c, 0x0b,
	0xe5, 0x31, 0x67, 0xd8, 0x40, 0xcb, 0xcd, 0xd6, 0x97, 0xa0, 0x53, 0x0e, 0xad, 0xe6, 0x7f, 0xfc,
	0x6a, 0xb2, 0x67, 0x79, 0xbe, 0x3b, 0x4f, 0x87, 0x08, 0x29, 0x19, 0x9f, 0xa8, 0x6e, 0x69, 0x7a,
	0xc3, 0xf2, 0xca, 0xdf, 0x25, 0x71, 0xb6, 0x46, 0x48, 0xcf, 0x00, 0xde, 0x25, 0x4d, 0x3c, 0xab,
	0xb3, 0xbb, 0xea, 0xc2, 0x96, 0x0b, 0x5e, 0x57, 0x35, 0x6c, 0x0a, 0xee, 0xb6, 0x16, 0xcc, 0x7c,
	0xae, 0x3a, 0xfb, 0x64, 0x88, 0x52, 0x2b, 0x4b, 0x4b, 0x4b, 0xcf, 0x86, 0x48, 0xf0, 0x9b, 0x65,
	0xe2, 0x56, 0xaa, 0xb8, 0xfb, 0x7d, 0x5a, 0xb9, 0x1a, 0xe0, 0x94, 0x00, 0xb6, 0xce, 0x51, 0xe2,
	0x07, 0x38, 0xc7, 0x09, 0x23, 0x25, 0x08, 0x69, 0x56, 0xcf, 0xd2, 0x64, 0x03, 0x6d, 0x9e, 0xfe,
	0x8f, 0xfc, 0x54, 0xf2, 0xc1, 0x0e, 0xe0, 0x49, 0x06, 0x2f, 0x3e, 0x19, 0xa2, 0xf4, 0x7b, 0xab,
	0xb7, 0xc7, 0xf0, 0xdf, 0x36, 0x95, 0x1c, 0xd7, 0xe7, 0x04, 0x75, 0x3c, 0x7d, 0x9a, 0x38, 0xde,
	0xb2, 0x6f, 0x9d, 0x3f, 0x48, 0x91, 0xbe, 0xab, 0x0b, 0xca, 0x54, 0x98, 0x2d, 0xb1, 0x89, 0xb3,
	0x3c, 0x8d, 0x01, 0xd9, 0x04, 0x23, 0x7b, 0xfb, 0x7c, 0xb2, 0x58, 0x15, 0xeb, 0x82, 0x82, 0x7b,
	0x96, 0xd7, 0x80, 0x81, 0x4f, 0x58, 0x9d, 0xc3, 0xb9, 0x60, 0x94, 0xa2, 0xc3, 0x90, 0x3e, 0x18,
	0xa2, 0x94, 0x3f, 0x0c, 0xef, 0x2e, 0xac, 0xde, 0x4f, 0x4d, 0xa5, 0x0a, 0x69, 0x7f, 0x18, 0xf2,
	0xf7, 0x4c, 0xd2, 0xd2, 0xcc, 0x4d, 0x07, 0x74, 0xd6, 0x0e, 0xeb, 0x78, 0xfa, 0x74, 0x4b, 0xf0,
	0x9e, 0xbe, 0x75, 0xb9, 0xf5, 0xc0, 0xfd, 0x98, 0x0a, 0x97, 0x83, 0xd8, 0x3c, 0xad, 0x4f, 0x6c,
	0xdb, 0x5c, 0x40, 0x17, 0xed, 0x99, 0xb0, 0x64, 0xc1, 0xed, 0xfd, 0x37, 0x7f, 0x1e, 0xa2, 0x32,
	0x7e, 0x05, 0xe7, 0xd7, 0x62, 0x10, 0x11, 0xbd, 0x83, 0x33, 0x78, 0x22, 0x00, 0x8a, 0x68, 0xa5,
	0x7a, 0x13, 0x17, 0x58, 0x65, 0xfc, 0xcf, 0x4f, 0x98, 0x81, 0x5c, 0x64, 0x1d, 0xa0, 0x65, 0xbe,
	0x0c, 0xfe, 0x44, 0x38, 0x5f, 0x73, 0x41, 0xa3, 0xf0, 0x42, 0xc4, 0x7f, 0xe5, 0xd7, 0x3b, 0x63,
	0xe5, 0xaa, 0xce, 0x3f, 0x27, 0xd4, 0x57, 0xbf, 0xfe, 0x1b, 0x9d, 0x79, 0xe5, 0x11, 0x9f, 0x20,
	0x3c, 0xa3, 0x80, 0x63, 0x6a, 0xfa, 0x4b, 0x13, 0xf2, 0x1f, 0x08, 0x67, 0xee, 0x01, 0x7d, 0x49,
	0xc2, 0xad, 0xee, 0xa1, 0x83, 0x23, 0x49, 0x38, 0x3c, 0x92, 0x84, 0x93, 0x23, 0x09, 0xed, 0x8e,
	0x24, 0xf4, 0xc3, 0x48, 0x42, 0xbf, 0x8c, 0x24, 0x74, 0x30, 0x92, 0xd0, 0xe1, 0x48, 0x42, 0xbf,
	0x8d, 0x24, 0xf4, 0x74, 0x24, 0x09, 0x27, 0x23, 0x09, 0xed, 0x1d, 0x4b, 0xc2, 0xfe, 0xb1, 0x84,
	0x0e, 0x8e, 0x25, 0xe1, 0xf0, 0x58, 0x12, 0x1e, 0x29, 0x1d, 0xe2, 0xf4, 0x3a, 0xf2, 0x36, 0x31,
	0x29, 0xb8, 0xae, 0x26, 0xf7, 0xbd, 0x0a, 0x3b, 0x6c, 0x11, 0xd7, 0x5a, 0x74, 0x5c, 0xb2, 0x6d,
	0xb4, 0xc1, 0x5d, 0x0c, 0xc5, 0x15, 0xa7, 0xd5, 0x21, 0x15, 0x78, 0x4c, 0xf9, 0x6f, 0xdf, 0x73,
	0x7f, 0x93, 0x5b, 0x13, 0xec, 0xab, 0xb4, 0xf2, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xea, 0xe0,
	0x38, 0x5b, 0x4d, 0x0b, 0x00, 0x00,
}

func (this *OIDCAuthParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OIDCAuthParams)
	if !ok {
		that2, ok := that.(OIDCAuthParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AuthEndpointUrl != that1.AuthEndpointUrl {
		return false
	}
	if this.TokenEndpointUrl != that1.TokenEndpointUrl {
		return false
	}
	if this.EndSessionEndpointUrl != that1.EndSessionEndpointUrl {
		return false
	}
	return true
}
func (this *OIDCAuthType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OIDCAuthType)
	if !ok {
		that2, ok := that.(OIDCAuthType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AuthParamsChoice == nil {
		if this.AuthParamsChoice != nil {
			return false
		}
	} else if this.AuthParamsChoice == nil {
		return false
	} else if !this.AuthParamsChoice.Equal(that1.AuthParamsChoice) {
		return false
	}
	if this.OidcClientId != that1.OidcClientId {
		return false
	}
	if !this.ClientSecret.Equal(that1.ClientSecret) {
		return false
	}
	return true
}
func (this *OIDCAuthType_OidcWellKnownConfigUrl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OIDCAuthType_OidcWellKnownConfigUrl)
	if !ok {
		that2, ok := that.(OIDCAuthType_OidcWellKnownConfigUrl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OidcWellKnownConfigUrl != that1.OidcWellKnownConfigUrl {
		return false
	}
	return true
}
func (this *OIDCAuthType_OidcAuthParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OIDCAuthType_OidcAuthParams)
	if !ok {
		that2, ok := that.(OIDCAuthType_OidcAuthParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OidcAuthParams.Equal(that1.OidcAuthParams) {
		return false
	}
	return true
}
func (this *HMACKeyPair) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HMACKeyPair)
	if !ok {
		that2, ok := that.(HMACKeyPair)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PrimKey.Equal(that1.PrimKey) {
		return false
	}
	if !this.PrimKeyExpiry.Equal(that1.PrimKeyExpiry) {
		return false
	}
	if !this.SecKey.Equal(that1.SecKey) {
		return false
	}
	if !this.SecKeyExpiry.Equal(that1.SecKeyExpiry) {
		return false
	}
	return true
}
func (this *KMSKeyRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*KMSKeyRefType)
	if !ok {
		that2, ok := that.(KMSKeyRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AuthHmacKms.Equal(that1.AuthHmacKms) {
		return false
	}
	return true
}
func (this *CookieParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieParams)
	if !ok {
		that2, ok := that.(CookieParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CookieRefreshInterval != that1.CookieRefreshInterval {
		return false
	}
	if this.CookieExpiry != that1.CookieExpiry {
		return false
	}
	if this.SessionExpiry != that1.SessionExpiry {
		return false
	}
	if that1.SecretChoice == nil {
		if this.SecretChoice != nil {
			return false
		}
	} else if this.SecretChoice == nil {
		return false
	} else if !this.SecretChoice.Equal(that1.SecretChoice) {
		return false
	}
	return true
}
func (this *CookieParams_AuthHmac) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieParams_AuthHmac)
	if !ok {
		that2, ok := that.(CookieParams_AuthHmac)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AuthHmac.Equal(that1.AuthHmac) {
		return false
	}
	return true
}
func (this *CookieParams_KmsKeyHmac) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieParams_KmsKeyHmac)
	if !ok {
		that2, ok := that.(CookieParams_KmsKeyHmac)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.KmsKeyHmac.Equal(that1.KmsKeyHmac) {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AuthTypeChoice == nil {
		if this.AuthTypeChoice != nil {
			return false
		}
	} else if this.AuthTypeChoice == nil {
		return false
	} else if !this.AuthTypeChoice.Equal(that1.AuthTypeChoice) {
		return false
	}
	if !this.CookieParams.Equal(that1.CookieParams) {
		return false
	}
	return true
}
func (this *GlobalSpecType_OidcAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_OidcAuth)
	if !ok {
		that2, ok := that.(GlobalSpecType_OidcAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OidcAuth.Equal(that1.OidcAuth) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AuthTypeChoice == nil {
		if this.AuthTypeChoice != nil {
			return false
		}
	} else if this.AuthTypeChoice == nil {
		return false
	} else if !this.AuthTypeChoice.Equal(that1.AuthTypeChoice) {
		return false
	}
	if !this.CookieParams.Equal(that1.CookieParams) {
		return false
	}
	return true
}
func (this *CreateSpecType_OidcAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_OidcAuth)
	if !ok {
		that2, ok := that.(CreateSpecType_OidcAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OidcAuth.Equal(that1.OidcAuth) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AuthTypeChoice == nil {
		if this.AuthTypeChoice != nil {
			return false
		}
	} else if this.AuthTypeChoice == nil {
		return false
	} else if !this.AuthTypeChoice.Equal(that1.AuthTypeChoice) {
		return false
	}
	if !this.CookieParams.Equal(that1.CookieParams) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_OidcAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_OidcAuth)
	if !ok {
		that2, ok := that.(ReplaceSpecType_OidcAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OidcAuth.Equal(that1.OidcAuth) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AuthTypeChoice == nil {
		if this.AuthTypeChoice != nil {
			return false
		}
	} else if this.AuthTypeChoice == nil {
		return false
	} else if !this.AuthTypeChoice.Equal(that1.AuthTypeChoice) {
		return false
	}
	if !this.CookieParams.Equal(that1.CookieParams) {
		return false
	}
	return true
}
func (this *GetSpecType_OidcAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_OidcAuth)
	if !ok {
		that2, ok := that.(GetSpecType_OidcAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OidcAuth.Equal(that1.OidcAuth) {
		return false
	}
	return true
}
func (this *OIDCAuthParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&authentication.OIDCAuthParams{")
	s = append(s, "AuthEndpointUrl: "+fmt.Sprintf("%#v", this.AuthEndpointUrl)+",\n")
	s = append(s, "TokenEndpointUrl: "+fmt.Sprintf("%#v", this.TokenEndpointUrl)+",\n")
	s = append(s, "EndSessionEndpointUrl: "+fmt.Sprintf("%#v", this.EndSessionEndpointUrl)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OIDCAuthType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&authentication.OIDCAuthType{")
	if this.AuthParamsChoice != nil {
		s = append(s, "AuthParamsChoice: "+fmt.Sprintf("%#v", this.AuthParamsChoice)+",\n")
	}
	s = append(s, "OidcClientId: "+fmt.Sprintf("%#v", this.OidcClientId)+",\n")
	if this.ClientSecret != nil {
		s = append(s, "ClientSecret: "+fmt.Sprintf("%#v", this.ClientSecret)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OIDCAuthType_OidcWellKnownConfigUrl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&authentication.OIDCAuthType_OidcWellKnownConfigUrl{` +
		`OidcWellKnownConfigUrl:` + fmt.Sprintf("%#v", this.OidcWellKnownConfigUrl) + `}`}, ", ")
	return s
}
func (this *OIDCAuthType_OidcAuthParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&authentication.OIDCAuthType_OidcAuthParams{` +
		`OidcAuthParams:` + fmt.Sprintf("%#v", this.OidcAuthParams) + `}`}, ", ")
	return s
}
func (this *HMACKeyPair) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&authentication.HMACKeyPair{")
	if this.PrimKey != nil {
		s = append(s, "PrimKey: "+fmt.Sprintf("%#v", this.PrimKey)+",\n")
	}
	if this.PrimKeyExpiry != nil {
		s = append(s, "PrimKeyExpiry: "+fmt.Sprintf("%#v", this.PrimKeyExpiry)+",\n")
	}
	if this.SecKey != nil {
		s = append(s, "SecKey: "+fmt.Sprintf("%#v", this.SecKey)+",\n")
	}
	if this.SecKeyExpiry != nil {
		s = append(s, "SecKeyExpiry: "+fmt.Sprintf("%#v", this.SecKeyExpiry)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *KMSKeyRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&authentication.KMSKeyRefType{")
	if this.AuthHmacKms != nil {
		s = append(s, "AuthHmacKms: "+fmt.Sprintf("%#v", this.AuthHmacKms)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CookieParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&authentication.CookieParams{")
	s = append(s, "CookieRefreshInterval: "+fmt.Sprintf("%#v", this.CookieRefreshInterval)+",\n")
	s = append(s, "CookieExpiry: "+fmt.Sprintf("%#v", this.CookieExpiry)+",\n")
	s = append(s, "SessionExpiry: "+fmt.Sprintf("%#v", this.SessionExpiry)+",\n")
	if this.SecretChoice != nil {
		s = append(s, "SecretChoice: "+fmt.Sprintf("%#v", this.SecretChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CookieParams_AuthHmac) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&authentication.CookieParams_AuthHmac{` +
		`AuthHmac:` + fmt.Sprintf("%#v", this.AuthHmac) + `}`}, ", ")
	return s
}
func (this *CookieParams_KmsKeyHmac) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&authentication.CookieParams_KmsKeyHmac{` +
		`KmsKeyHmac:` + fmt.Sprintf("%#v", this.KmsKeyHmac) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authentication.GlobalSpecType{")
	if this.AuthTypeChoice != nil {
		s = append(s, "AuthTypeChoice: "+fmt.Sprintf("%#v", this.AuthTypeChoice)+",\n")
	}
	if this.CookieParams != nil {
		s = append(s, "CookieParams: "+fmt.Sprintf("%#v", this.CookieParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_OidcAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&authentication.GlobalSpecType_OidcAuth{` +
		`OidcAuth:` + fmt.Sprintf("%#v", this.OidcAuth) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authentication.CreateSpecType{")
	if this.AuthTypeChoice != nil {
		s = append(s, "AuthTypeChoice: "+fmt.Sprintf("%#v", this.AuthTypeChoice)+",\n")
	}
	if this.CookieParams != nil {
		s = append(s, "CookieParams: "+fmt.Sprintf("%#v", this.CookieParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_OidcAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&authentication.CreateSpecType_OidcAuth{` +
		`OidcAuth:` + fmt.Sprintf("%#v", this.OidcAuth) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authentication.ReplaceSpecType{")
	if this.AuthTypeChoice != nil {
		s = append(s, "AuthTypeChoice: "+fmt.Sprintf("%#v", this.AuthTypeChoice)+",\n")
	}
	if this.CookieParams != nil {
		s = append(s, "CookieParams: "+fmt.Sprintf("%#v", this.CookieParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_OidcAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&authentication.ReplaceSpecType_OidcAuth{` +
		`OidcAuth:` + fmt.Sprintf("%#v", this.OidcAuth) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authentication.GetSpecType{")
	if this.AuthTypeChoice != nil {
		s = append(s, "AuthTypeChoice: "+fmt.Sprintf("%#v", this.AuthTypeChoice)+",\n")
	}
	if this.CookieParams != nil {
		s = append(s, "CookieParams: "+fmt.Sprintf("%#v", this.CookieParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_OidcAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&authentication.GetSpecType_OidcAuth{` +
		`OidcAuth:` + fmt.Sprintf("%#v", this.OidcAuth) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *OIDCAuthParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OIDCAuthParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OIDCAuthParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EndSessionEndpointUrl) > 0 {
		i -= len(m.EndSessionEndpointUrl)
		copy(dAtA[i:], m.EndSessionEndpointUrl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EndSessionEndpointUrl)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TokenEndpointUrl) > 0 {
		i -= len(m.TokenEndpointUrl)
		copy(dAtA[i:], m.TokenEndpointUrl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TokenEndpointUrl)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AuthEndpointUrl) > 0 {
		i -= len(m.AuthEndpointUrl)
		copy(dAtA[i:], m.AuthEndpointUrl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AuthEndpointUrl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OIDCAuthType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OIDCAuthType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OIDCAuthType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClientSecret != nil {
		{
			size, err := m.ClientSecret.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.OidcClientId) > 0 {
		i -= len(m.OidcClientId)
		copy(dAtA[i:], m.OidcClientId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OidcClientId)))
		i--
		dAtA[i] = 0x22
	}
	if m.AuthParamsChoice != nil {
		{
			size := m.AuthParamsChoice.Size()
			i -= size
			if _, err := m.AuthParamsChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *OIDCAuthType_OidcWellKnownConfigUrl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OIDCAuthType_OidcWellKnownConfigUrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.OidcWellKnownConfigUrl)
	copy(dAtA[i:], m.OidcWellKnownConfigUrl)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.OidcWellKnownConfigUrl)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *OIDCAuthType_OidcAuthParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OIDCAuthType_OidcAuthParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OidcAuthParams != nil {
		{
			size, err := m.OidcAuthParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *HMACKeyPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HMACKeyPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HMACKeyPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SecKeyExpiry != nil {
		{
			size, err := m.SecKeyExpiry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.SecKey != nil {
		{
			size, err := m.SecKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PrimKeyExpiry != nil {
		{
			size, err := m.PrimKeyExpiry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PrimKey != nil {
		{
			size, err := m.PrimKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KMSKeyRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KMSKeyRefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KMSKeyRefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuthHmacKms != nil {
		{
			size, err := m.AuthHmacKms.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CookieParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CookieParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SecretChoice != nil {
		{
			size := m.SecretChoice.Size()
			i -= size
			if _, err := m.SecretChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.SessionExpiry != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SessionExpiry))
		i--
		dAtA[i] = 0x18
	}
	if m.CookieExpiry != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CookieExpiry))
		i--
		dAtA[i] = 0x10
	}
	if m.CookieRefreshInterval != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CookieRefreshInterval))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CookieParams_AuthHmac) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieParams_AuthHmac) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AuthHmac != nil {
		{
			size, err := m.AuthHmac.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *CookieParams_KmsKeyHmac) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieParams_KmsKeyHmac) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.KmsKeyHmac != nil {
		{
			size, err := m.KmsKeyHmac.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CookieParams != nil {
		{
			size, err := m.CookieParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AuthTypeChoice != nil {
		{
			size := m.AuthTypeChoice.Size()
			i -= size
			if _, err := m.AuthTypeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_OidcAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_OidcAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OidcAuth != nil {
		{
			size, err := m.OidcAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CookieParams != nil {
		{
			size, err := m.CookieParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AuthTypeChoice != nil {
		{
			size := m.AuthTypeChoice.Size()
			i -= size
			if _, err := m.AuthTypeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_OidcAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_OidcAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OidcAuth != nil {
		{
			size, err := m.OidcAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CookieParams != nil {
		{
			size, err := m.CookieParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AuthTypeChoice != nil {
		{
			size := m.AuthTypeChoice.Size()
			i -= size
			if _, err := m.AuthTypeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_OidcAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_OidcAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OidcAuth != nil {
		{
			size, err := m.OidcAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CookieParams != nil {
		{
			size, err := m.CookieParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AuthTypeChoice != nil {
		{
			size := m.AuthTypeChoice.Size()
			i -= size
			if _, err := m.AuthTypeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_OidcAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_OidcAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OidcAuth != nil {
		{
			size, err := m.OidcAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *OIDCAuthParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AuthEndpointUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TokenEndpointUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EndSessionEndpointUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *OIDCAuthType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthParamsChoice != nil {
		n += m.AuthParamsChoice.Size()
	}
	l = len(m.OidcClientId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ClientSecret != nil {
		l = m.ClientSecret.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *OIDCAuthType_OidcWellKnownConfigUrl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OidcWellKnownConfigUrl)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *OIDCAuthType_OidcAuthParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OidcAuthParams != nil {
		l = m.OidcAuthParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HMACKeyPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrimKey != nil {
		l = m.PrimKey.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PrimKeyExpiry != nil {
		l = m.PrimKeyExpiry.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SecKey != nil {
		l = m.SecKey.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SecKeyExpiry != nil {
		l = m.SecKeyExpiry.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *KMSKeyRefType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthHmacKms != nil {
		l = m.AuthHmacKms.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CookieParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CookieRefreshInterval != 0 {
		n += 1 + sovTypes(uint64(m.CookieRefreshInterval))
	}
	if m.CookieExpiry != 0 {
		n += 1 + sovTypes(uint64(m.CookieExpiry))
	}
	if m.SessionExpiry != 0 {
		n += 1 + sovTypes(uint64(m.SessionExpiry))
	}
	if m.SecretChoice != nil {
		n += m.SecretChoice.Size()
	}
	return n
}

func (m *CookieParams_AuthHmac) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthHmac != nil {
		l = m.AuthHmac.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CookieParams_KmsKeyHmac) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KmsKeyHmac != nil {
		l = m.KmsKeyHmac.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthTypeChoice != nil {
		n += m.AuthTypeChoice.Size()
	}
	if m.CookieParams != nil {
		l = m.CookieParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType_OidcAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OidcAuth != nil {
		l = m.OidcAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthTypeChoice != nil {
		n += m.AuthTypeChoice.Size()
	}
	if m.CookieParams != nil {
		l = m.CookieParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType_OidcAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OidcAuth != nil {
		l = m.OidcAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthTypeChoice != nil {
		n += m.AuthTypeChoice.Size()
	}
	if m.CookieParams != nil {
		l = m.CookieParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType_OidcAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OidcAuth != nil {
		l = m.OidcAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthTypeChoice != nil {
		n += m.AuthTypeChoice.Size()
	}
	if m.CookieParams != nil {
		l = m.CookieParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GetSpecType_OidcAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OidcAuth != nil {
		l = m.OidcAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *OIDCAuthParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OIDCAuthParams{`,
		`AuthEndpointUrl:` + fmt.Sprintf("%v", this.AuthEndpointUrl) + `,`,
		`TokenEndpointUrl:` + fmt.Sprintf("%v", this.TokenEndpointUrl) + `,`,
		`EndSessionEndpointUrl:` + fmt.Sprintf("%v", this.EndSessionEndpointUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OIDCAuthType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OIDCAuthType{`,
		`AuthParamsChoice:` + fmt.Sprintf("%v", this.AuthParamsChoice) + `,`,
		`OidcClientId:` + fmt.Sprintf("%v", this.OidcClientId) + `,`,
		`ClientSecret:` + strings.Replace(fmt.Sprintf("%v", this.ClientSecret), "SecretType", "schema.SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OIDCAuthType_OidcWellKnownConfigUrl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OIDCAuthType_OidcWellKnownConfigUrl{`,
		`OidcWellKnownConfigUrl:` + fmt.Sprintf("%v", this.OidcWellKnownConfigUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OIDCAuthType_OidcAuthParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OIDCAuthType_OidcAuthParams{`,
		`OidcAuthParams:` + strings.Replace(fmt.Sprintf("%v", this.OidcAuthParams), "OIDCAuthParams", "OIDCAuthParams", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HMACKeyPair) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HMACKeyPair{`,
		`PrimKey:` + strings.Replace(fmt.Sprintf("%v", this.PrimKey), "SecretType", "schema.SecretType", 1) + `,`,
		`PrimKeyExpiry:` + strings.Replace(fmt.Sprintf("%v", this.PrimKeyExpiry), "Timestamp", "types.Timestamp", 1) + `,`,
		`SecKey:` + strings.Replace(fmt.Sprintf("%v", this.SecKey), "SecretType", "schema.SecretType", 1) + `,`,
		`SecKeyExpiry:` + strings.Replace(fmt.Sprintf("%v", this.SecKeyExpiry), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *KMSKeyRefType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&KMSKeyRefType{`,
		`AuthHmacKms:` + strings.Replace(fmt.Sprintf("%v", this.AuthHmacKms), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieParams{`,
		`CookieRefreshInterval:` + fmt.Sprintf("%v", this.CookieRefreshInterval) + `,`,
		`CookieExpiry:` + fmt.Sprintf("%v", this.CookieExpiry) + `,`,
		`SessionExpiry:` + fmt.Sprintf("%v", this.SessionExpiry) + `,`,
		`SecretChoice:` + fmt.Sprintf("%v", this.SecretChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieParams_AuthHmac) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieParams_AuthHmac{`,
		`AuthHmac:` + strings.Replace(fmt.Sprintf("%v", this.AuthHmac), "HMACKeyPair", "HMACKeyPair", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieParams_KmsKeyHmac) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieParams_KmsKeyHmac{`,
		`KmsKeyHmac:` + strings.Replace(fmt.Sprintf("%v", this.KmsKeyHmac), "KMSKeyRefType", "KMSKeyRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`AuthTypeChoice:` + fmt.Sprintf("%v", this.AuthTypeChoice) + `,`,
		`CookieParams:` + strings.Replace(this.CookieParams.String(), "CookieParams", "CookieParams", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_OidcAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_OidcAuth{`,
		`OidcAuth:` + strings.Replace(fmt.Sprintf("%v", this.OidcAuth), "OIDCAuthType", "OIDCAuthType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`AuthTypeChoice:` + fmt.Sprintf("%v", this.AuthTypeChoice) + `,`,
		`CookieParams:` + strings.Replace(this.CookieParams.String(), "CookieParams", "CookieParams", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_OidcAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_OidcAuth{`,
		`OidcAuth:` + strings.Replace(fmt.Sprintf("%v", this.OidcAuth), "OIDCAuthType", "OIDCAuthType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`AuthTypeChoice:` + fmt.Sprintf("%v", this.AuthTypeChoice) + `,`,
		`CookieParams:` + strings.Replace(this.CookieParams.String(), "CookieParams", "CookieParams", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_OidcAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_OidcAuth{`,
		`OidcAuth:` + strings.Replace(fmt.Sprintf("%v", this.OidcAuth), "OIDCAuthType", "OIDCAuthType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`AuthTypeChoice:` + fmt.Sprintf("%v", this.AuthTypeChoice) + `,`,
		`CookieParams:` + strings.Replace(this.CookieParams.String(), "CookieParams", "CookieParams", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_OidcAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_OidcAuth{`,
		`OidcAuth:` + strings.Replace(fmt.Sprintf("%v", this.OidcAuth), "OIDCAuthType", "OIDCAuthType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *OIDCAuthParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OIDCAuthParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OIDCAuthParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthEndpointUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthEndpointUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenEndpointUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenEndpointUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndSessionEndpointUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndSessionEndpointUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OIDCAuthType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OIDCAuthType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OIDCAuthType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OidcWellKnownConfigUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthParamsChoice = &OIDCAuthType_OidcWellKnownConfigUrl{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OidcAuthParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OIDCAuthParams{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthParamsChoice = &OIDCAuthType_OidcAuthParams{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OidcClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OidcClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientSecret == nil {
				m.ClientSecret = &schema.SecretType{}
			}
			if err := m.ClientSecret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HMACKeyPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HMACKeyPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HMACKeyPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrimKey == nil {
				m.PrimKey = &schema.SecretType{}
			}
			if err := m.PrimKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimKeyExpiry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrimKeyExpiry == nil {
				m.PrimKeyExpiry = &types.Timestamp{}
			}
			if err := m.PrimKeyExpiry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecKey == nil {
				m.SecKey = &schema.SecretType{}
			}
			if err := m.SecKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecKeyExpiry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecKeyExpiry == nil {
				m.SecKeyExpiry = &types.Timestamp{}
			}
			if err := m.SecKeyExpiry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KMSKeyRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KMSKeyRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KMSKeyRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthHmacKms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthHmacKms == nil {
				m.AuthHmacKms = &views.ObjectRefType{}
			}
			if err := m.AuthHmacKms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CookieParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CookieParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CookieParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieRefreshInterval", wireType)
			}
			m.CookieRefreshInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CookieRefreshInterval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieExpiry", wireType)
			}
			m.CookieExpiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CookieExpiry |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionExpiry", wireType)
			}
			m.SessionExpiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionExpiry |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthHmac", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HMACKeyPair{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SecretChoice = &CookieParams_AuthHmac{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KmsKeyHmac", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &KMSKeyRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SecretChoice = &CookieParams_KmsKeyHmac{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OidcAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OIDCAuthType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthTypeChoice = &GlobalSpecType_OidcAuth{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CookieParams == nil {
				m.CookieParams = &CookieParams{}
			}
			if err := m.CookieParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OidcAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OIDCAuthType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthTypeChoice = &CreateSpecType_OidcAuth{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CookieParams == nil {
				m.CookieParams = &CookieParams{}
			}
			if err := m.CookieParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OidcAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OIDCAuthType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthTypeChoice = &ReplaceSpecType_OidcAuth{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CookieParams == nil {
				m.CookieParams = &CookieParams{}
			}
			if err := m.CookieParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OidcAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OIDCAuthType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthTypeChoice = &GetSpecType_OidcAuth{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CookieParams == nil {
				m.CookieParams = &CookieParams{}
			}
			if err := m.CookieParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
