// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/certified_hardware/types.proto

package certified_hardware

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	usb_policy "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/usb_policy"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Hardware Device Types
//
// x-displayName: "Device Types"
// Different type of devices supported
type HardwareDeviceType int32

const (
	// x-displayName: "Invalid"
	// Invalid device or device thats not supported
	HARDWARE_DEVICE_INVALID HardwareDeviceType = 0
	// x-displayName: "Ethernet"
	// Ethernet device
	HARDWARE_DEVICE_ETHERNET HardwareDeviceType = 1
	// x-displayName: "Virtio"
	// VIRTIO device
	HARDWARE_DEVICE_VIRTIO HardwareDeviceType = 2
	// x-displayName: "Tuntap"
	// TUNTAP device
	HARDWARE_DEVICE_TUNTAP HardwareDeviceType = 3
	// x-displayName: "Bond (Link Aggregation)"
	// LACP based bond interface
	HARDWARE_DEVICE_BOND HardwareDeviceType = 4
	// x-displayName: "External iSCSI Storage"
	// External iSCSI devices supported
	HARDWARE_DEVICE_EXTERNAL_ISCSI_STORTAGE HardwareDeviceType = 5
	// x-displayName: "Nvidia GPU device"
	// Nvidia GPU device used for machine learning
	HARDWARE_DEVICE_NVIDIA_GPU HardwareDeviceType = 6
)

var HardwareDeviceType_name = map[int32]string{
	0: "HARDWARE_DEVICE_INVALID",
	1: "HARDWARE_DEVICE_ETHERNET",
	2: "HARDWARE_DEVICE_VIRTIO",
	3: "HARDWARE_DEVICE_TUNTAP",
	4: "HARDWARE_DEVICE_BOND",
	5: "HARDWARE_DEVICE_EXTERNAL_ISCSI_STORTAGE",
	6: "HARDWARE_DEVICE_NVIDIA_GPU",
}

var HardwareDeviceType_value = map[string]int32{
	"HARDWARE_DEVICE_INVALID":                 0,
	"HARDWARE_DEVICE_ETHERNET":                1,
	"HARDWARE_DEVICE_VIRTIO":                  2,
	"HARDWARE_DEVICE_TUNTAP":                  3,
	"HARDWARE_DEVICE_BOND":                    4,
	"HARDWARE_DEVICE_EXTERNAL_ISCSI_STORTAGE": 5,
	"HARDWARE_DEVICE_NVIDIA_GPU":              6,
}

func (HardwareDeviceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_30cf7db1740c5af8, []int{0}
}

// Hardware Device Instance Use
//
// x-displayName: "Device Use"
// Defines how the device instance must be used
type HardwareDeviceInstanceUseType int32

const (
	// x-displayName: "Device Regular"
	// If the device is owned by volterra software, it is available for users to configure as required
	HARDWARE_DEVICE_USE_REGULAR HardwareDeviceInstanceUseType = 0
	// x-displayName: "Device Internal"
	// Device reserved for internal use by volterra Node
	HARDWARE_DEVICE_USE_INTERNAL HardwareDeviceInstanceUseType = 1
	// x-displayName: "Network Device Regular"
	// If the Network device is owned by VER, it is available for users to configure as required
	HARDWARE_NETWORK_DEVICE_USE_REGULAR HardwareDeviceInstanceUseType = 2
	// x-displayName: "Network Device Internal"
	// Networking device available for internal use by VER
	HARDWARE_NETWORK_DEVICE_USE_INTERNAL HardwareDeviceInstanceUseType = 3
	// x-displayName: "Network Device Management"
	// Networking device to be used for Management access
	HARDWARE_NETWORK_DEVICE_USE_MANAGEMENT HardwareDeviceInstanceUseType = 4
	// x-displayName: "Network Device Outside"
	// Networking device to be used as member of outside network as part of bootstrap
	HARDWARE_NETWORK_DEVICE_USE_OUTSIDE HardwareDeviceInstanceUseType = 5
	// x-displayName: "Network Device Inside"
	// Networking device to be used as member of inside network as part of bootstrap
	HARDWARE_NETWORK_DEVICE_USE_INSIDE HardwareDeviceInstanceUseType = 6
	// x-displayName: "Network Device Outside Lag"
	// LAG device to be used as member of outside network
	HARDWARE_NETWORK_DEVICE_USE_OUTSIDE_LAG HardwareDeviceInstanceUseType = 7
	// x-displayName: "Network Device Inside Lag"
	// LAG device to be used as member of inside network
	HARDWARE_NETWORK_DEVICE_USE_INSIDE_LAG HardwareDeviceInstanceUseType = 8
	// x-displayName: "Network Device Lag Member"
	// Network device to be used as member of another LAG device
	HARDWARE_NETWORK_DEVICE_USE_LAG_MEMBER HardwareDeviceInstanceUseType = 9
	// x-displayName: "Network Device Use Storage"
	// Network device to be used exclusive for storage networks
	HARDWARE_NETWORK_DEVICE_USE_STORAGE HardwareDeviceInstanceUseType = 10
	// x-displayName: "Network Device Fallback Management"
	// Networking device to be used for fallback Management access
	HARDWARE_NETWORK_DEVICE_USE_FALLBACK_MANAGEMENT HardwareDeviceInstanceUseType = 11
)

var HardwareDeviceInstanceUseType_name = map[int32]string{
	0:  "HARDWARE_DEVICE_USE_REGULAR",
	1:  "HARDWARE_DEVICE_USE_INTERNAL",
	2:  "HARDWARE_NETWORK_DEVICE_USE_REGULAR",
	3:  "HARDWARE_NETWORK_DEVICE_USE_INTERNAL",
	4:  "HARDWARE_NETWORK_DEVICE_USE_MANAGEMENT",
	5:  "HARDWARE_NETWORK_DEVICE_USE_OUTSIDE",
	6:  "HARDWARE_NETWORK_DEVICE_USE_INSIDE",
	7:  "HARDWARE_NETWORK_DEVICE_USE_OUTSIDE_LAG",
	8:  "HARDWARE_NETWORK_DEVICE_USE_INSIDE_LAG",
	9:  "HARDWARE_NETWORK_DEVICE_USE_LAG_MEMBER",
	10: "HARDWARE_NETWORK_DEVICE_USE_STORAGE",
	11: "HARDWARE_NETWORK_DEVICE_USE_FALLBACK_MANAGEMENT",
}

var HardwareDeviceInstanceUseType_value = map[string]int32{
	"HARDWARE_DEVICE_USE_REGULAR":                     0,
	"HARDWARE_DEVICE_USE_INTERNAL":                    1,
	"HARDWARE_NETWORK_DEVICE_USE_REGULAR":             2,
	"HARDWARE_NETWORK_DEVICE_USE_INTERNAL":            3,
	"HARDWARE_NETWORK_DEVICE_USE_MANAGEMENT":          4,
	"HARDWARE_NETWORK_DEVICE_USE_OUTSIDE":             5,
	"HARDWARE_NETWORK_DEVICE_USE_INSIDE":              6,
	"HARDWARE_NETWORK_DEVICE_USE_OUTSIDE_LAG":         7,
	"HARDWARE_NETWORK_DEVICE_USE_INSIDE_LAG":          8,
	"HARDWARE_NETWORK_DEVICE_USE_LAG_MEMBER":          9,
	"HARDWARE_NETWORK_DEVICE_USE_STORAGE":             10,
	"HARDWARE_NETWORK_DEVICE_USE_FALLBACK_MANAGEMENT": 11,
}

func (HardwareDeviceInstanceUseType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_30cf7db1740c5af8, []int{1}
}

// Certified Hardware Types
//
// x-displayName: "Certified Hardware Types"
// Different type of certified HW for billing rate
type HardwareType int32

const (
	// x-displayName: "Billed as VoltMesh"
	VOLTMESH HardwareType = 0
	// x-displayName: "Billed as VoltStack Combo"
	VOLTSTACK_COMBO HardwareType = 1
	// x-displayName: "Not Billed by Volterra"
	CLOUD_MARKET_PLACE HardwareType = 2
)

var HardwareType_name = map[int32]string{
	0: "VOLTMESH",
	1: "VOLTSTACK_COMBO",
	2: "CLOUD_MARKET_PLACE",
}

var HardwareType_value = map[string]int32{
	"VOLTMESH":           0,
	"VOLTSTACK_COMBO":    1,
	"CLOUD_MARKET_PLACE": 2,
}

func (HardwareType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_30cf7db1740c5af8, []int{2}
}

// Memory Page Size
//
// x-displayName: "Memory Page Size"
// Memory for packets buffers etc are allocated in blocks of pages. Size of each memory page is defined here.
type MemPageSize int32

const (
	// x-displayName: "Invalid"
	// Invalid Page size
	HARDWARE_MEM_PAGE_SIZE_INVALID MemPageSize = 0
	// x-displayName: "4 KBytes"
	// Page size of 4KB
	HARDWARE_MEM_PAGE_SIZE_4KB MemPageSize = 1
	// x-displayName: "2 MBytes"
	// Page size of 2MB
	HARDWARE_MEM_PAGE_SIZE_2MB MemPageSize = 2
	// x-displayName: "1 GBytes"
	// Page size of 1GB
	HARDWARE_MEM_PAGE_SIZE_1GB MemPageSize = 3
)

var MemPageSize_name = map[int32]string{
	0: "HARDWARE_MEM_PAGE_SIZE_INVALID",
	1: "HARDWARE_MEM_PAGE_SIZE_4KB",
	2: "HARDWARE_MEM_PAGE_SIZE_2MB",
	3: "HARDWARE_MEM_PAGE_SIZE_1GB",
}

var MemPageSize_value = map[string]int32{
	"HARDWARE_MEM_PAGE_SIZE_INVALID": 0,
	"HARDWARE_MEM_PAGE_SIZE_4KB":     1,
	"HARDWARE_MEM_PAGE_SIZE_2MB":     2,
	"HARDWARE_MEM_PAGE_SIZE_1GB":     3,
}

func (MemPageSize) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_30cf7db1740c5af8, []int{3}
}

// Device Type
//
// x-displayName: "Device"
// Different type of devices supported by Certified Hardware
type DeviceType struct {
	// Type
	//
	// x-displayName: "Type"
	// Defines type of device supported in certified hardware
	Type HardwareDeviceType `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.certified_hardware.HardwareDeviceType" json:"type,omitempty"`
	// Use
	//
	// x-displayName: "Use"
	// Defines how the device is used in the certified hardware
	Use HardwareDeviceInstanceUseType `protobuf:"varint,2,opt,name=use,proto3,enum=ves.io.schema.certified_hardware.HardwareDeviceInstanceUseType" json:"use,omitempty"`
	// Name
	//
	// x-displayName: "device"
	// x-example: "eth"
	// Name of the device
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Start unit number for device
	//
	// x-displayName: "Start Unit"
	// x-example: "0"
	// first unit number of the device supported in this certified hardware
	MinUnit int32 `protobuf:"varint,4,opt,name=min_unit,json=minUnit,proto3" json:"min_unit,omitempty"`
	// End unit number for device
	//
	// x-displayName: "End Unit"
	// x-example: "7"
	// last unit number of the device supported in this certified hardware
	MaxUnit int32 `protobuf:"varint,5,opt,name=max_unit,json=maxUnit,proto3" json:"max_unit,omitempty"`
	// Device List
	//
	// x-displayName: "Device List"
	// In case of logical boot strap devices like LACP Link aggregation or RAID
	DeviceList []string `protobuf:"bytes,6,rep,name=device_list,json=deviceList,proto3" json:"device_list,omitempty"`
}

func (m *DeviceType) Reset()      { *m = DeviceType{} }
func (*DeviceType) ProtoMessage() {}
func (*DeviceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_30cf7db1740c5af8, []int{0}
}
func (m *DeviceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeviceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceType.Merge(m, src)
}
func (m *DeviceType) XXX_Size() int {
	return m.Size()
}
func (m *DeviceType) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceType.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceType proto.InternalMessageInfo

func (m *DeviceType) GetType() HardwareDeviceType {
	if m != nil {
		return m.Type
	}
	return HARDWARE_DEVICE_INVALID
}

func (m *DeviceType) GetUse() HardwareDeviceInstanceUseType {
	if m != nil {
		return m.Use
	}
	return HARDWARE_DEVICE_USE_REGULAR
}

func (m *DeviceType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DeviceType) GetMinUnit() int32 {
	if m != nil {
		return m.MinUnit
	}
	return 0
}

func (m *DeviceType) GetMaxUnit() int32 {
	if m != nil {
		return m.MaxUnit
	}
	return 0
}

func (m *DeviceType) GetDeviceList() []string {
	if m != nil {
		return m.DeviceList
	}
	return nil
}

// Vendor and Model
//
// x-displayName: "Vendor and Model"
// Gives vendor and model for the hardware device
type HardwareVendorModel struct {
	// Vendor
	//
	// x-displayName: "Vendor"
	// Vendor could be Volterra, Dell, Cloud provider like AWS or Azure
	Vendor string `protobuf:"bytes,1,opt,name=vendor,proto3" json:"vendor,omitempty"`
	// Model
	//
	// x-displayName: "Model"
	// Hw Model or instance type from cloud provider like number of interfaces, vCPUs, memory
	Model string `protobuf:"bytes,2,opt,name=model,proto3" json:"model,omitempty"`
}

func (m *HardwareVendorModel) Reset()      { *m = HardwareVendorModel{} }
func (*HardwareVendorModel) ProtoMessage() {}
func (*HardwareVendorModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_30cf7db1740c5af8, []int{1}
}
func (m *HardwareVendorModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HardwareVendorModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HardwareVendorModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HardwareVendorModel.Merge(m, src)
}
func (m *HardwareVendorModel) XXX_Size() int {
	return m.Size()
}
func (m *HardwareVendorModel) XXX_DiscardUnknown() {
	xxx_messageInfo_HardwareVendorModel.DiscardUnknown(m)
}

var xxx_messageInfo_HardwareVendorModel proto.InternalMessageInfo

func (m *HardwareVendorModel) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *HardwareVendorModel) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

// Image Type
//
// x-displayName: "Image Type"
// Describes the image to be used for this certified hardware
type ImageType struct {
	// Name
	//
	// x-displayName: "Name"
	// x-example: "ami-0f99d090261d2acd5"
	// Image name to use for this hardware
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"` // Deprecated: Do not use.
	// Provider
	//
	// x-displayName: "Provider"
	// x-example: "Volterra"
	// Image provider Volterra, Cloud provider like AWS or Azure
	Provider string `protobuf:"bytes,2,opt,name=provider,proto3" json:"provider,omitempty"` // Deprecated: Do not use.
	// CloudProvider
	//
	// x-displayName: "Cloud Provider"
	// Cloud provider image specific information like AWS or Azure
	//
	// Types that are valid to be assigned to CloudProvider:
	//	*ImageType_Azure
	//	*ImageType_Aws
	//	*ImageType_Gcp
	CloudProvider isImageType_CloudProvider `protobuf_oneof:"cloud_provider"`
}

func (m *ImageType) Reset()      { *m = ImageType{} }
func (*ImageType) ProtoMessage() {}
func (*ImageType) Descriptor() ([]byte, []int) {
	return fileDescriptor_30cf7db1740c5af8, []int{2}
}
func (m *ImageType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImageType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ImageType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageType.Merge(m, src)
}
func (m *ImageType) XXX_Size() int {
	return m.Size()
}
func (m *ImageType) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageType.DiscardUnknown(m)
}

var xxx_messageInfo_ImageType proto.InternalMessageInfo

type isImageType_CloudProvider interface {
	isImageType_CloudProvider()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ImageType_Azure struct {
	Azure *Azure `protobuf:"bytes,3,opt,name=azure,proto3,oneof" json:"azure,omitempty"`
}
type ImageType_Aws struct {
	Aws *Aws `protobuf:"bytes,4,opt,name=aws,proto3,oneof" json:"aws,omitempty"`
}
type ImageType_Gcp struct {
	Gcp *Gcp `protobuf:"bytes,5,opt,name=gcp,proto3,oneof" json:"gcp,omitempty"`
}

func (*ImageType_Azure) isImageType_CloudProvider() {}
func (*ImageType_Aws) isImageType_CloudProvider()   {}
func (*ImageType_Gcp) isImageType_CloudProvider()   {}

func (m *ImageType) GetCloudProvider() isImageType_CloudProvider {
	if m != nil {
		return m.CloudProvider
	}
	return nil
}

// Deprecated: Do not use.
func (m *ImageType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Deprecated: Do not use.
func (m *ImageType) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *ImageType) GetAzure() *Azure {
	if x, ok := m.GetCloudProvider().(*ImageType_Azure); ok {
		return x.Azure
	}
	return nil
}

func (m *ImageType) GetAws() *Aws {
	if x, ok := m.GetCloudProvider().(*ImageType_Aws); ok {
		return x.Aws
	}
	return nil
}

func (m *ImageType) GetGcp() *Gcp {
	if x, ok := m.GetCloudProvider().(*ImageType_Gcp); ok {
		return x.Gcp
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ImageType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ImageType_Azure)(nil),
		(*ImageType_Aws)(nil),
		(*ImageType_Gcp)(nil),
	}
}

// Azure
//
// x-displayName: "Azure"
// Azure specific information
type Azure struct {
	// Types that are valid to be assigned to Image:
	//	*Azure_Marketplace
	//	*Azure_ImageId
	Image isAzure_Image `protobuf_oneof:"image"`
}

func (m *Azure) Reset()      { *m = Azure{} }
func (*Azure) ProtoMessage() {}
func (*Azure) Descriptor() ([]byte, []int) {
	return fileDescriptor_30cf7db1740c5af8, []int{3}
}
func (m *Azure) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Azure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Azure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Azure.Merge(m, src)
}
func (m *Azure) XXX_Size() int {
	return m.Size()
}
func (m *Azure) XXX_DiscardUnknown() {
	xxx_messageInfo_Azure.DiscardUnknown(m)
}

var xxx_messageInfo_Azure proto.InternalMessageInfo

type isAzure_Image interface {
	isAzure_Image()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Azure_Marketplace struct {
	Marketplace *Marketplace `protobuf:"bytes,1,opt,name=marketplace,proto3,oneof" json:"marketplace,omitempty"`
}
type Azure_ImageId struct {
	ImageId *AzureImage `protobuf:"bytes,2,opt,name=image_id,json=imageId,proto3,oneof" json:"image_id,omitempty"`
}

func (*Azure_Marketplace) isAzure_Image() {}
func (*Azure_ImageId) isAzure_Image()     {}

func (m *Azure) GetImage() isAzure_Image {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *Azure) GetMarketplace() *Marketplace {
	if x, ok := m.GetImage().(*Azure_Marketplace); ok {
		return x.Marketplace
	}
	return nil
}

func (m *Azure) GetImageId() *AzureImage {
	if x, ok := m.GetImage().(*Azure_ImageId); ok {
		return x.ImageId
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Azure) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Azure_Marketplace)(nil),
		(*Azure_ImageId)(nil),
	}
}

type AzureImage struct {
	// ImageId
	//
	// x-displayName: "Azure image id info"
	// Azure image id
	ImageId string `protobuf:"bytes,1,opt,name=image_id,json=imageId,proto3" json:"image_id,omitempty"`
}

func (m *AzureImage) Reset()      { *m = AzureImage{} }
func (*AzureImage) ProtoMessage() {}
func (*AzureImage) Descriptor() ([]byte, []int) {
	return fileDescriptor_30cf7db1740c5af8, []int{4}
}
func (m *AzureImage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureImage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureImage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureImage.Merge(m, src)
}
func (m *AzureImage) XXX_Size() int {
	return m.Size()
}
func (m *AzureImage) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureImage.DiscardUnknown(m)
}

var xxx_messageInfo_AzureImage proto.InternalMessageInfo

func (m *AzureImage) GetImageId() string {
	if m != nil {
		return m.ImageId
	}
	return ""
}

// Marketplace
//
// x-displayName: "Azure Marketplace image info"
// Azure Marketplace image information
type Marketplace struct {
	// Offer
	//
	// x-displayName: "Azure Marketplace offer"
	// Azure Marketplace offer
	Offer string `protobuf:"bytes,1,opt,name=offer,proto3" json:"offer,omitempty"`
	// SKU
	//
	// x-displayName: "Azure Marketplace SKU"
	// Azure Marketplace SKU
	Sku string `protobuf:"bytes,2,opt,name=sku,proto3" json:"sku,omitempty"`
	// Version
	//
	// x-displayName: "Azure Marketplace Version"
	// Azure Marketplace Version
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// Name
	//
	// x-displayName: "Azure Marketplace Name"
	// Azure Marketplace Name
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// Publisher
	//
	// x-displayName: "Azure Marketplace Publisher"
	// Azure Marketplace Publisher
	Publisher string `protobuf:"bytes,5,opt,name=publisher,proto3" json:"publisher,omitempty"`
}

func (m *Marketplace) Reset()      { *m = Marketplace{} }
func (*Marketplace) ProtoMessage() {}
func (*Marketplace) Descriptor() ([]byte, []int) {
	return fileDescriptor_30cf7db1740c5af8, []int{5}
}
func (m *Marketplace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Marketplace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Marketplace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Marketplace.Merge(m, src)
}
func (m *Marketplace) XXX_Size() int {
	return m.Size()
}
func (m *Marketplace) XXX_DiscardUnknown() {
	xxx_messageInfo_Marketplace.DiscardUnknown(m)
}

var xxx_messageInfo_Marketplace proto.InternalMessageInfo

func (m *Marketplace) GetOffer() string {
	if m != nil {
		return m.Offer
	}
	return ""
}

func (m *Marketplace) GetSku() string {
	if m != nil {
		return m.Sku
	}
	return ""
}

func (m *Marketplace) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Marketplace) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Marketplace) GetPublisher() string {
	if m != nil {
		return m.Publisher
	}
	return ""
}

// AWS
//
// x-displayName: "AWS"
// AWS specific information
type Aws struct {
	// Types that are valid to be assigned to Image:
	//	*Aws_ImageId
	Image isAws_Image `protobuf_oneof:"image"`
}

func (m *Aws) Reset()      { *m = Aws{} }
func (*Aws) ProtoMessage() {}
func (*Aws) Descriptor() ([]byte, []int) {
	return fileDescriptor_30cf7db1740c5af8, []int{6}
}
func (m *Aws) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Aws) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Aws) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Aws.Merge(m, src)
}
func (m *Aws) XXX_Size() int {
	return m.Size()
}
func (m *Aws) XXX_DiscardUnknown() {
	xxx_messageInfo_Aws.DiscardUnknown(m)
}

var xxx_messageInfo_Aws proto.InternalMessageInfo

type isAws_Image interface {
	isAws_Image()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Aws_ImageId struct {
	ImageId *AwsImage `protobuf:"bytes,1,opt,name=image_id,json=imageId,proto3,oneof" json:"image_id,omitempty"`
}

func (*Aws_ImageId) isAws_Image() {}

func (m *Aws) GetImage() isAws_Image {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *Aws) GetImageId() *AwsImage {
	if x, ok := m.GetImage().(*Aws_ImageId); ok {
		return x.ImageId
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Aws) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Aws_ImageId)(nil),
	}
}

type AwsImage struct {
	// ImageId
	//
	// x-displayName: "AWS ami image name"
	// AWS ami image
	ImageId string `protobuf:"bytes,1,opt,name=image_id,json=imageId,proto3" json:"image_id,omitempty"`
	// Region
	//
	// x-displayName: "AWS ami image region"
	// AWS ami image region
	Region string `protobuf:"bytes,2,opt,name=region,proto3" json:"region,omitempty"`
}

func (m *AwsImage) Reset()      { *m = AwsImage{} }
func (*AwsImage) ProtoMessage() {}
func (*AwsImage) Descriptor() ([]byte, []int) {
	return fileDescriptor_30cf7db1740c5af8, []int{7}
}
func (m *AwsImage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AwsImage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AwsImage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AwsImage.Merge(m, src)
}
func (m *AwsImage) XXX_Size() int {
	return m.Size()
}
func (m *AwsImage) XXX_DiscardUnknown() {
	xxx_messageInfo_AwsImage.DiscardUnknown(m)
}

var xxx_messageInfo_AwsImage proto.InternalMessageInfo

func (m *AwsImage) GetImageId() string {
	if m != nil {
		return m.ImageId
	}
	return ""
}

func (m *AwsImage) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

// GCP
//
// x-displayName: "GCP"
// GCP specific information
type Gcp struct {
	// Types that are valid to be assigned to Image:
	//	*Gcp_ImageId
	Image isGcp_Image `protobuf_oneof:"image"`
}

func (m *Gcp) Reset()      { *m = Gcp{} }
func (*Gcp) ProtoMessage() {}
func (*Gcp) Descriptor() ([]byte, []int) {
	return fileDescriptor_30cf7db1740c5af8, []int{8}
}
func (m *Gcp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Gcp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Gcp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Gcp.Merge(m, src)
}
func (m *Gcp) XXX_Size() int {
	return m.Size()
}
func (m *Gcp) XXX_DiscardUnknown() {
	xxx_messageInfo_Gcp.DiscardUnknown(m)
}

var xxx_messageInfo_Gcp proto.InternalMessageInfo

type isGcp_Image interface {
	isGcp_Image()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Gcp_ImageId struct {
	ImageId *GcpImage `protobuf:"bytes,1,opt,name=image_id,json=imageId,proto3,oneof" json:"image_id,omitempty"`
}

func (*Gcp_ImageId) isGcp_Image() {}

func (m *Gcp) GetImage() isGcp_Image {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *Gcp) GetImageId() *GcpImage {
	if x, ok := m.GetImage().(*Gcp_ImageId); ok {
		return x.ImageId
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Gcp) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Gcp_ImageId)(nil),
	}
}

type GcpImage struct {
	// ImageId
	//
	// x-displayName: "GCP image name"
	// GCP image
	ImageId string `protobuf:"bytes,1,opt,name=image_id,json=imageId,proto3" json:"image_id,omitempty"`
}

func (m *GcpImage) Reset()      { *m = GcpImage{} }
func (*GcpImage) ProtoMessage() {}
func (*GcpImage) Descriptor() ([]byte, []int) {
	return fileDescriptor_30cf7db1740c5af8, []int{9}
}
func (m *GcpImage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GcpImage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GcpImage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GcpImage.Merge(m, src)
}
func (m *GcpImage) XXX_Size() int {
	return m.Size()
}
func (m *GcpImage) XXX_DiscardUnknown() {
	xxx_messageInfo_GcpImage.DiscardUnknown(m)
}

var xxx_messageInfo_GcpImage proto.InternalMessageInfo

func (m *GcpImage) GetImageId() string {
	if m != nil {
		return m.ImageId
	}
	return ""
}

// NUMA Memory Specification
//
// x-displayName: "NUMA Memory Specification"
// Defines amount of memory (in MB) allocated for a NUMA node
type NumaMem struct {
	// Memory Size
	//
	// x-displayName: "Memory Size"
	// x-example: "1024"
	// The number of MB of instance memory to map to instance NUMA node N
	Memory int32 `protobuf:"varint,1,opt,name=memory,proto3" json:"memory,omitempty"`
	// Node
	//
	// x-displayName: "Node"
	// x-example: "1"
	// NUMA node instance with mapped memory
	Node int32 `protobuf:"varint,2,opt,name=node,proto3" json:"node,omitempty"`
}

func (m *NumaMem) Reset()      { *m = NumaMem{} }
func (*NumaMem) ProtoMessage() {}
func (*NumaMem) Descriptor() ([]byte, []int) {
	return fileDescriptor_30cf7db1740c5af8, []int{10}
}
func (m *NumaMem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NumaMem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NumaMem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NumaMem.Merge(m, src)
}
func (m *NumaMem) XXX_Size() int {
	return m.Size()
}
func (m *NumaMem) XXX_DiscardUnknown() {
	xxx_messageInfo_NumaMem.DiscardUnknown(m)
}

var xxx_messageInfo_NumaMem proto.InternalMessageInfo

func (m *NumaMem) GetMemory() int32 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *NumaMem) GetNode() int32 {
	if m != nil {
		return m.Node
	}
	return 0
}

// Global Specification
//
// x-displayName: "Global Specification"
// Certified Hardware Specification
type GlobalSpecType struct {
	// Vendor and Model
	//
	// x-displayName: "Vendor and Model"
	// List of supported hardware vendor and model for this certified hardware
	VendorModelList []*HardwareVendorModel `protobuf:"bytes,1,rep,name=vendor_model_list,json=vendorModelList,proto3" json:"vendor_model_list,omitempty"`
	// Devices
	//
	// x-displayName: "Devices"
	// List of supported devices in this model
	Devices []*DeviceType `protobuf:"bytes,2,rep,name=devices,proto3" json:"devices,omitempty"`
	// Image List
	//
	// x-displayName: "Image List"
	// List of image names with providers for this certified hardware, e.g. AWS ami-0f99d090261d2acd5
	ImageList []*ImageType `protobuf:"bytes,4,rep,name=image_list,json=imageList,proto3" json:"image_list,omitempty"`
	// NUMA Node Count
	//
	// x-displayName: "NUMA Node Count"
	// x-example: "2"
	// The number of host NUMA nodes used in certified hardware
	NumaNodes int32 `protobuf:"varint,5,opt,name=numa_nodes,json=numaNodes,proto3" json:"numa_nodes,omitempty"`
	// Memory Page Size
	//
	// x-displayName: "Memory Page Size"
	// An explicit page size used in certified hardware, 4KB, 2Mi, 2048, 1Gi
	MemPageSize MemPageSize `protobuf:"varint,6,opt,name=mem_page_size,json=memPageSize,proto3,enum=ves.io.schema.certified_hardware.MemPageSize" json:"mem_page_size,omitempty"`
	// Number of pages
	//
	// x-displayName: "Number of pages"
	// x-example: "2"
	// Number of pages allocated in this certified hardware for Hugepages. Each page size is defined above in 'mem_page_size'
	// Total memory reserved for Hugepages is 'mem_page_size * mem_page_number'
	MemPageNumber int32 `protobuf:"varint,7,opt,name=mem_page_number,json=memPageNumber,proto3" json:"mem_page_number,omitempty"`
	// NUMA Memory
	//
	// x-displayName: "NUMA Memory"
	// List of Numa nodes with the number of MB of instance memory to map to node instance
	// If not specified, memory is evenly divided among available NUMA nodes
	NumaMem []*NumaMem `protobuf:"bytes,8,rep,name=numa_mem,json=numaMem,proto3" json:"numa_mem,omitempty"`
	// Certified Hardware Type
	//
	// x-displayName: "Certified Hardware Type"
	// x-example: "VOLTMESH"
	// HW type defines billing rate per billing node.
	CertifiedHardwareType HardwareType `protobuf:"varint,9,opt,name=certified_hardware_type,json=certifiedHardwareType,proto3,enum=ves.io.schema.certified_hardware.HardwareType" json:"certified_hardware_type,omitempty"`
	// InternalUSBDeviceRule
	//
	// x-displayName: "Internal USB device rules"
	// List of internal USB device rules for server
	InternalUsbDeviceRule []*usb_policy.Rule `protobuf:"bytes,10,rep,name=internal_usb_device_rule,json=internalUsbDeviceRule,proto3" json:"internal_usb_device_rule,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_30cf7db1740c5af8, []int{11}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

func (m *GlobalSpecType) GetVendorModelList() []*HardwareVendorModel {
	if m != nil {
		return m.VendorModelList
	}
	return nil
}

func (m *GlobalSpecType) GetDevices() []*DeviceType {
	if m != nil {
		return m.Devices
	}
	return nil
}

func (m *GlobalSpecType) GetImageList() []*ImageType {
	if m != nil {
		return m.ImageList
	}
	return nil
}

func (m *GlobalSpecType) GetNumaNodes() int32 {
	if m != nil {
		return m.NumaNodes
	}
	return 0
}

func (m *GlobalSpecType) GetMemPageSize() MemPageSize {
	if m != nil {
		return m.MemPageSize
	}
	return HARDWARE_MEM_PAGE_SIZE_INVALID
}

func (m *GlobalSpecType) GetMemPageNumber() int32 {
	if m != nil {
		return m.MemPageNumber
	}
	return 0
}

func (m *GlobalSpecType) GetNumaMem() []*NumaMem {
	if m != nil {
		return m.NumaMem
	}
	return nil
}

func (m *GlobalSpecType) GetCertifiedHardwareType() HardwareType {
	if m != nil {
		return m.CertifiedHardwareType
	}
	return VOLTMESH
}

func (m *GlobalSpecType) GetInternalUsbDeviceRule() []*usb_policy.Rule {
	if m != nil {
		return m.InternalUsbDeviceRule
	}
	return nil
}

// Get certified hardware
//
// x-displayName: "Get Certified Hardware"
// Get Certified Hardware object
type GetSpecType struct {
	VendorModelList       []*HardwareVendorModel `protobuf:"bytes,1,rep,name=vendor_model_list,json=vendorModelList,proto3" json:"vendor_model_list,omitempty"`
	Devices               []*DeviceType          `protobuf:"bytes,2,rep,name=devices,proto3" json:"devices,omitempty"`
	ImageList             []*ImageType           `protobuf:"bytes,4,rep,name=image_list,json=imageList,proto3" json:"image_list,omitempty"`
	NumaNodes             int32                  `protobuf:"varint,5,opt,name=numa_nodes,json=numaNodes,proto3" json:"numa_nodes,omitempty"`
	MemPageSize           MemPageSize            `protobuf:"varint,6,opt,name=mem_page_size,json=memPageSize,proto3,enum=ves.io.schema.certified_hardware.MemPageSize" json:"mem_page_size,omitempty"`
	MemPageNumber         int32                  `protobuf:"varint,7,opt,name=mem_page_number,json=memPageNumber,proto3" json:"mem_page_number,omitempty"`
	NumaMem               []*NumaMem             `protobuf:"bytes,8,rep,name=numa_mem,json=numaMem,proto3" json:"numa_mem,omitempty"`
	CertifiedHardwareType HardwareType           `protobuf:"varint,9,opt,name=certified_hardware_type,json=certifiedHardwareType,proto3,enum=ves.io.schema.certified_hardware.HardwareType" json:"certified_hardware_type,omitempty"`
	InternalUsbDeviceRule []*usb_policy.Rule     `protobuf:"bytes,10,rep,name=internal_usb_device_rule,json=internalUsbDeviceRule,proto3" json:"internal_usb_device_rule,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_30cf7db1740c5af8, []int{12}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

func (m *GetSpecType) GetVendorModelList() []*HardwareVendorModel {
	if m != nil {
		return m.VendorModelList
	}
	return nil
}

func (m *GetSpecType) GetDevices() []*DeviceType {
	if m != nil {
		return m.Devices
	}
	return nil
}

func (m *GetSpecType) GetImageList() []*ImageType {
	if m != nil {
		return m.ImageList
	}
	return nil
}

func (m *GetSpecType) GetNumaNodes() int32 {
	if m != nil {
		return m.NumaNodes
	}
	return 0
}

func (m *GetSpecType) GetMemPageSize() MemPageSize {
	if m != nil {
		return m.MemPageSize
	}
	return HARDWARE_MEM_PAGE_SIZE_INVALID
}

func (m *GetSpecType) GetMemPageNumber() int32 {
	if m != nil {
		return m.MemPageNumber
	}
	return 0
}

func (m *GetSpecType) GetNumaMem() []*NumaMem {
	if m != nil {
		return m.NumaMem
	}
	return nil
}

func (m *GetSpecType) GetCertifiedHardwareType() HardwareType {
	if m != nil {
		return m.CertifiedHardwareType
	}
	return VOLTMESH
}

func (m *GetSpecType) GetInternalUsbDeviceRule() []*usb_policy.Rule {
	if m != nil {
		return m.InternalUsbDeviceRule
	}
	return nil
}

// Certified Hardware Status
//
// x-displayName: "Status"
// Current status of Certified Hardware
type CertifiedHardwareStatus struct {
	// Latest Version
	//
	// x-displayName: "Latest Version"
	// Latest version for the certified hardware
	LatestVersion string `protobuf:"bytes,1,opt,name=latest_version,json=latestVersion,proto3" json:"latest_version,omitempty"`
}

func (m *CertifiedHardwareStatus) Reset()      { *m = CertifiedHardwareStatus{} }
func (*CertifiedHardwareStatus) ProtoMessage() {}
func (*CertifiedHardwareStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_30cf7db1740c5af8, []int{13}
}
func (m *CertifiedHardwareStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertifiedHardwareStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CertifiedHardwareStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertifiedHardwareStatus.Merge(m, src)
}
func (m *CertifiedHardwareStatus) XXX_Size() int {
	return m.Size()
}
func (m *CertifiedHardwareStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_CertifiedHardwareStatus.DiscardUnknown(m)
}

var xxx_messageInfo_CertifiedHardwareStatus proto.InternalMessageInfo

func (m *CertifiedHardwareStatus) GetLatestVersion() string {
	if m != nil {
		return m.LatestVersion
	}
	return ""
}

func init() {
	proto.RegisterEnum("ves.io.schema.certified_hardware.HardwareDeviceType", HardwareDeviceType_name, HardwareDeviceType_value)
	golang_proto.RegisterEnum("ves.io.schema.certified_hardware.HardwareDeviceType", HardwareDeviceType_name, HardwareDeviceType_value)
	proto.RegisterEnum("ves.io.schema.certified_hardware.HardwareDeviceInstanceUseType", HardwareDeviceInstanceUseType_name, HardwareDeviceInstanceUseType_value)
	golang_proto.RegisterEnum("ves.io.schema.certified_hardware.HardwareDeviceInstanceUseType", HardwareDeviceInstanceUseType_name, HardwareDeviceInstanceUseType_value)
	proto.RegisterEnum("ves.io.schema.certified_hardware.HardwareType", HardwareType_name, HardwareType_value)
	golang_proto.RegisterEnum("ves.io.schema.certified_hardware.HardwareType", HardwareType_name, HardwareType_value)
	proto.RegisterEnum("ves.io.schema.certified_hardware.MemPageSize", MemPageSize_name, MemPageSize_value)
	golang_proto.RegisterEnum("ves.io.schema.certified_hardware.MemPageSize", MemPageSize_name, MemPageSize_value)
	proto.RegisterType((*DeviceType)(nil), "ves.io.schema.certified_hardware.DeviceType")
	golang_proto.RegisterType((*DeviceType)(nil), "ves.io.schema.certified_hardware.DeviceType")
	proto.RegisterType((*HardwareVendorModel)(nil), "ves.io.schema.certified_hardware.HardwareVendorModel")
	golang_proto.RegisterType((*HardwareVendorModel)(nil), "ves.io.schema.certified_hardware.HardwareVendorModel")
	proto.RegisterType((*ImageType)(nil), "ves.io.schema.certified_hardware.ImageType")
	golang_proto.RegisterType((*ImageType)(nil), "ves.io.schema.certified_hardware.ImageType")
	proto.RegisterType((*Azure)(nil), "ves.io.schema.certified_hardware.Azure")
	golang_proto.RegisterType((*Azure)(nil), "ves.io.schema.certified_hardware.Azure")
	proto.RegisterType((*AzureImage)(nil), "ves.io.schema.certified_hardware.AzureImage")
	golang_proto.RegisterType((*AzureImage)(nil), "ves.io.schema.certified_hardware.AzureImage")
	proto.RegisterType((*Marketplace)(nil), "ves.io.schema.certified_hardware.Marketplace")
	golang_proto.RegisterType((*Marketplace)(nil), "ves.io.schema.certified_hardware.Marketplace")
	proto.RegisterType((*Aws)(nil), "ves.io.schema.certified_hardware.Aws")
	golang_proto.RegisterType((*Aws)(nil), "ves.io.schema.certified_hardware.Aws")
	proto.RegisterType((*AwsImage)(nil), "ves.io.schema.certified_hardware.AwsImage")
	golang_proto.RegisterType((*AwsImage)(nil), "ves.io.schema.certified_hardware.AwsImage")
	proto.RegisterType((*Gcp)(nil), "ves.io.schema.certified_hardware.Gcp")
	golang_proto.RegisterType((*Gcp)(nil), "ves.io.schema.certified_hardware.Gcp")
	proto.RegisterType((*GcpImage)(nil), "ves.io.schema.certified_hardware.GcpImage")
	golang_proto.RegisterType((*GcpImage)(nil), "ves.io.schema.certified_hardware.GcpImage")
	proto.RegisterType((*NumaMem)(nil), "ves.io.schema.certified_hardware.NumaMem")
	golang_proto.RegisterType((*NumaMem)(nil), "ves.io.schema.certified_hardware.NumaMem")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.certified_hardware.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.certified_hardware.GlobalSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.certified_hardware.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.certified_hardware.GetSpecType")
	proto.RegisterType((*CertifiedHardwareStatus)(nil), "ves.io.schema.certified_hardware.CertifiedHardwareStatus")
	golang_proto.RegisterType((*CertifiedHardwareStatus)(nil), "ves.io.schema.certified_hardware.CertifiedHardwareStatus")
}

func init() {
	proto.RegisterFile("ves.io/schema/certified_hardware/types.proto", fileDescriptor_30cf7db1740c5af8)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/certified_hardware/types.proto", fileDescriptor_30cf7db1740c5af8)
}

var fileDescriptor_30cf7db1740c5af8 = []byte{
	// 1517 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0x4b, 0x73, 0xd3, 0x58,
	0x16, 0xb6, 0xfc, 0xf6, 0x31, 0x04, 0x71, 0x81, 0x44, 0x84, 0x20, 0x5c, 0x1e, 0x20, 0x99, 0x40,
	0xec, 0x1a, 0x03, 0x8b, 0x99, 0xaa, 0x19, 0x46, 0xb6, 0x85, 0xad, 0xc4, 0x8f, 0x20, 0x3f, 0x98,
	0x62, 0xa3, 0x92, 0xed, 0x1b, 0x47, 0x85, 0xf5, 0x28, 0x49, 0x76, 0x08, 0xab, 0x99, 0x7f, 0x30,
	0x53, 0xc5, 0xec, 0xe6, 0x07, 0xf0, 0x13, 0xa6, 0x8a, 0xaa, 0x2e, 0x96, 0x5d, 0xbd, 0xca, 0x92,
	0x65, 0xe3, 0x6c, 0x7a, 0xd5, 0xc5, 0x4f, 0xe8, 0xd2, 0x95, 0xfc, 0x0c, 0xd8, 0xee, 0x5e, 0xf5,
	0x82, 0xdd, 0x3d, 0xf7, 0x7c, 0xe7, 0x9c, 0xef, 0x9c, 0x7b, 0xee, 0xd1, 0xb5, 0xe1, 0xe1, 0x00,
	0x5b, 0x29, 0x45, 0x4f, 0x5b, 0xed, 0x63, 0xac, 0xca, 0xe9, 0x36, 0x36, 0x6d, 0xe5, 0x48, 0xc1,
	0x1d, 0xe9, 0x58, 0x36, 0x3b, 0x27, 0xb2, 0x89, 0xd3, 0xf6, 0xa9, 0x81, 0xad, 0x94, 0x61, 0xea,
	0xb6, 0x8e, 0x12, 0x2e, 0x3a, 0xe5, 0xa2, 0x53, 0x17, 0xd1, 0x9b, 0x7b, 0x5d, 0xc5, 0x3e, 0xee,
	0xb7, 0x52, 0x6d, 0x5d, 0x4d, 0x77, 0xf5, 0xae, 0x9e, 0x26, 0x86, 0xad, 0xfe, 0x11, 0x91, 0x88,
	0x40, 0x56, 0xae, 0xc3, 0xcd, 0x3b, 0x5d, 0x5d, 0xef, 0xf6, 0xf0, 0x04, 0x65, 0x2b, 0x2a, 0xb6,
	0x6c, 0x59, 0x35, 0x3c, 0xc0, 0xc6, 0x2c, 0x3f, 0x0d, 0xdb, 0x9e, 0xe2, 0xd6, 0xac, 0x42, 0x37,
	0x6c, 0x45, 0xd7, 0x3c, 0x9e, 0x9b, 0xb7, 0x67, 0x95, 0xc6, 0xc0, 0x96, 0xa6, 0xd2, 0xd8, 0xbc,
	0x39, 0xab, 0x9e, 0x56, 0xdd, 0x9d, 0x55, 0xf5, 0xad, 0x96, 0x64, 0xe8, 0x3d, 0xa5, 0x7d, 0x3a,
	0x83, 0xda, 0x9a, 0x45, 0x0d, 0xe4, 0x9e, 0xd2, 0x91, 0x6d, 0xec, 0x69, 0x13, 0x73, 0x5a, 0x05,
	0x9f, 0x48, 0x33, 0xfc, 0x92, 0x6f, 0xfd, 0x00, 0x79, 0x3c, 0x50, 0xda, 0xb8, 0x7e, 0x6a, 0x60,
	0x54, 0x84, 0xa0, 0xe3, 0x9d, 0xa1, 0x12, 0xd4, 0xce, 0x5a, 0xe6, 0x71, 0x6a, 0x59, 0x95, 0x53,
	0x45, 0x6f, 0x31, 0xf1, 0x21, 0x12, 0x0f, 0xe8, 0x39, 0x04, 0xfa, 0x16, 0x66, 0xfc, 0xc4, 0xd1,
	0xd3, 0x5f, 0xeb, 0x48, 0xd0, 0x2c, 0x5b, 0xd6, 0xda, 0xb8, 0x61, 0xb9, 0x3e, 0x1d, 0x5f, 0x08,
	0x41, 0x50, 0x93, 0x55, 0xcc, 0x04, 0x12, 0xd4, 0x4e, 0x4c, 0x24, 0x6b, 0x74, 0x13, 0xa2, 0xaa,
	0xa2, 0x49, 0x7d, 0x4d, 0xb1, 0x99, 0x60, 0x82, 0xda, 0x09, 0x89, 0x11, 0x55, 0xd1, 0x1a, 0x9a,
	0x62, 0x13, 0x95, 0xfc, 0xda, 0x55, 0x85, 0x3c, 0x95, 0xfc, 0x9a, 0xa8, 0xee, 0x40, 0xbc, 0x43,
	0xe2, 0x48, 0x3d, 0xc5, 0xb2, 0x99, 0x70, 0x22, 0xb0, 0x13, 0x13, 0xc1, 0xdd, 0x2a, 0x29, 0x96,
	0x9d, 0xcc, 0xc1, 0xb5, 0x11, 0xa1, 0x26, 0xd6, 0x3a, 0xba, 0x59, 0xd6, 0x3b, 0xb8, 0x87, 0xd6,
	0x21, 0x3c, 0x20, 0x22, 0x29, 0x50, 0x4c, 0xf4, 0x24, 0x74, 0x1d, 0x42, 0xaa, 0x03, 0x20, 0xe9,
	0xc6, 0x44, 0x57, 0x48, 0xfe, 0xcf, 0x0f, 0x31, 0x41, 0x95, 0xbb, 0x6e, 0x69, 0xd7, 0x3d, 0xf6,
	0xc4, 0x32, 0xeb, 0x67, 0x28, 0x2f, 0x03, 0x16, 0xa2, 0x86, 0xa9, 0x0f, 0x94, 0x0e, 0x36, 0x5d,
	0x73, 0xa2, 0x1b, 0xef, 0xa1, 0xa7, 0x10, 0x92, 0xdf, 0xf4, 0x4d, 0x37, 0xed, 0x78, 0x66, 0x7b,
	0x79, 0x29, 0x39, 0x07, 0x5e, 0xf4, 0x89, 0xae, 0x1d, 0xfa, 0x33, 0x04, 0xe4, 0x13, 0x8b, 0x54,
	0x27, 0x9e, 0xb9, 0xb7, 0x82, 0xf9, 0x89, 0x55, 0xf4, 0x89, 0x8e, 0x8d, 0x63, 0xda, 0x6d, 0x1b,
	0xa4, 0x7a, 0x2b, 0x99, 0x16, 0xda, 0x86, 0x63, 0xda, 0x6d, 0x1b, 0xd9, 0x4d, 0x58, 0x6b, 0xf7,
	0xf4, 0x7e, 0x47, 0x1a, 0x27, 0x12, 0xfd, 0xf0, 0x9e, 0x0a, 0x9e, 0xbd, 0xa7, 0xc2, 0xfb, 0xc1,
	0x68, 0x98, 0x8e, 0x24, 0xbf, 0xa3, 0x20, 0x44, 0xa8, 0xa2, 0xe7, 0x10, 0x57, 0x65, 0xf3, 0x15,
	0xb6, 0x8d, 0x9e, 0xdc, 0x76, 0x2b, 0x14, 0xcf, 0xec, 0x2d, 0x0f, 0x57, 0x9e, 0x18, 0x15, 0x7d,
	0xe2, 0xb4, 0x0f, 0x24, 0x40, 0x54, 0x71, 0x4a, 0x2f, 0x29, 0x1d, 0x52, 0xd5, 0x78, 0xe6, 0xe1,
	0x8a, 0x85, 0x23, 0x27, 0x56, 0xf4, 0x89, 0x11, 0x62, 0x2f, 0x74, 0xb2, 0x57, 0x21, 0x44, 0x96,
	0x24, 0x01, 0xea, 0xec, 0x3d, 0x15, 0xd8, 0x0f, 0x46, 0x03, 0x74, 0x30, 0xb9, 0x0d, 0x30, 0xb1,
	0x70, 0xda, 0x6d, 0x1c, 0xd1, 0xed, 0x8e, 0x91, 0x87, 0xe4, 0xbf, 0x28, 0x88, 0x4f, 0x71, 0x75,
	0xda, 0x45, 0x3f, 0x3a, 0xc2, 0xa3, 0x2e, 0x72, 0x05, 0x44, 0x43, 0xc0, 0x7a, 0xd5, 0xf7, 0x5a,
	0xc8, 0x59, 0x22, 0x06, 0x22, 0x03, 0x6c, 0x5a, 0x8a, 0xae, 0x79, 0x3d, 0x3f, 0x12, 0xc7, 0x57,
	0x21, 0x38, 0x75, 0x15, 0xb6, 0x20, 0x66, 0xf4, 0x5b, 0x3d, 0xc5, 0x3a, 0xc6, 0x26, 0x39, 0xb2,
	0x98, 0x38, 0xd9, 0x48, 0x76, 0x21, 0xc0, 0x9d, 0x58, 0xa8, 0x30, 0xc7, 0x32, 0x9e, 0xd9, 0x5d,
	0xa9, 0x23, 0x96, 0x57, 0xc5, 0xbf, 0x1f, 0x8c, 0xfa, 0xe9, 0x40, 0xf2, 0xaf, 0x10, 0x1d, 0xe1,
	0x17, 0xd4, 0xc4, 0xb9, 0x4a, 0x26, 0xee, 0x3a, 0xa9, 0xb9, 0x09, 0x7b, 0x92, 0xc3, 0xb3, 0xd0,
	0x36, 0x7e, 0x1b, 0xcf, 0x42, 0xdb, 0x58, 0x9d, 0xe7, 0x3d, 0x88, 0x8e, 0xf0, 0x8b, 0xce, 0xee,
	0x09, 0x44, 0x2a, 0x7d, 0x55, 0x2e, 0x63, 0xd5, 0xa1, 0xac, 0x62, 0x55, 0x37, 0x4f, 0x09, 0x26,
	0x24, 0x7a, 0x12, 0x39, 0x0c, 0xbd, 0xe3, 0xce, 0xba, 0x90, 0x48, 0xd6, 0xc9, 0x77, 0x21, 0x58,
	0x2b, 0xf4, 0xf4, 0x96, 0xdc, 0xab, 0x19, 0xb8, 0x4d, 0x06, 0x80, 0x0c, 0x57, 0xdd, 0x71, 0x21,
	0x91, 0xf1, 0xe0, 0x8e, 0x1e, 0x2a, 0x11, 0xd8, 0x89, 0x67, 0x9e, 0xac, 0x3e, 0x1f, 0xa7, 0xc6,
	0x91, 0x78, 0x65, 0x30, 0x11, 0x9c, 0xb1, 0x85, 0x9e, 0x41, 0xc4, 0x1d, 0x62, 0x16, 0xe3, 0x27,
	0x8e, 0x57, 0x68, 0xfa, 0xa9, 0xc9, 0x3d, 0x32, 0x46, 0xfb, 0x00, 0x6e, 0x3d, 0x08, 0xc7, 0x20,
	0x71, 0xf5, 0x60, 0xb9, 0xab, 0xf1, 0xb0, 0x13, 0x63, 0xc4, 0x9c, 0x70, 0xba, 0x0d, 0xa0, 0xf5,
	0x55, 0x59, 0x72, 0xca, 0x62, 0x79, 0x83, 0x38, 0xe6, 0xec, 0x54, 0x9c, 0x0d, 0xf4, 0x1c, 0x2e,
	0xab, 0x58, 0x95, 0x0c, 0x27, 0x9a, 0xa5, 0xbc, 0xc1, 0x4c, 0x98, 0x7c, 0x31, 0x56, 0xb9, 0xfd,
	0x58, 0x3d, 0x94, 0xbb, 0xb8, 0xa6, 0xbc, 0xc1, 0x62, 0x5c, 0x9d, 0x08, 0xe8, 0x3e, 0x5c, 0x19,
	0xbb, 0xd4, 0xfa, 0x6a, 0x0b, 0x9b, 0x4c, 0x84, 0x84, 0xbd, 0xec, 0xa1, 0x2a, 0x64, 0x13, 0xe5,
	0x21, 0x4a, 0x98, 0xa9, 0x58, 0x65, 0xa2, 0x24, 0xc7, 0x3f, 0x2e, 0x8f, 0xea, 0x35, 0x83, 0x18,
	0xd1, 0xbc, 0xae, 0x38, 0x82, 0x8d, 0x8b, 0x30, 0xf2, 0x91, 0x67, 0x62, 0x24, 0x95, 0xd4, 0xea,
	0x87, 0x4b, 0x6a, 0x77, 0x63, 0x0c, 0x98, 0xde, 0x46, 0x2f, 0x80, 0x51, 0x34, 0x1b, 0x9b, 0x9a,
	0xdc, 0x93, 0x9c, 0xc7, 0x80, 0xf7, 0x01, 0x33, 0xfb, 0x3d, 0xcc, 0x00, 0x61, 0xcf, 0xce, 0x05,
	0x9a, 0x3c, 0x19, 0x52, 0x62, 0xbf, 0x87, 0xc5, 0x1b, 0x23, 0xfb, 0x86, 0xd5, 0x72, 0x4f, 0xdd,
	0xd9, 0x4e, 0xfe, 0x3f, 0x04, 0xf1, 0x02, 0xb6, 0xbf, 0xf5, 0xe9, 0xb7, 0x3e, 0xfd, 0x3d, 0xf7,
	0xe9, 0x5f, 0xae, 0xfe, 0xf0, 0xb7, 0xb9, 0x91, 0x9a, 0xfc, 0x3b, 0x6c, 0xe4, 0xe6, 0x49, 0xd4,
	0x6c, 0xd9, 0xee, 0x5b, 0xe8, 0x1e, 0xac, 0xf5, 0x64, 0x1b, 0x5b, 0xb6, 0x34, 0xfa, 0x84, 0xba,
	0x83, 0xfd, 0xb2, 0xbb, 0xdb, 0x74, 0x37, 0x77, 0x7f, 0xa6, 0x00, 0x5d, 0x7c, 0xc3, 0xa2, 0x5b,
	0xb0, 0x51, 0xe4, 0xc4, 0xfc, 0x0b, 0x4e, 0xe4, 0xa5, 0x3c, 0xdf, 0x14, 0x72, 0xbc, 0x24, 0x54,
	0x9a, 0x5c, 0x49, 0xc8, 0xd3, 0x3e, 0xb4, 0x05, 0xcc, 0xbc, 0x92, 0xaf, 0x17, 0x79, 0xb1, 0xc2,
	0xd7, 0x69, 0x0a, 0x6d, 0xc2, 0xfa, 0xbc, 0xb6, 0x29, 0x88, 0x75, 0xa1, 0x4a, 0xfb, 0xbf, 0xa4,
	0xab, 0x37, 0x2a, 0x75, 0xee, 0x90, 0x0e, 0x20, 0x06, 0xae, 0xcf, 0xeb, 0xb2, 0xd5, 0x4a, 0x9e,
	0x0e, 0xa2, 0x07, 0xb0, 0x7d, 0x21, 0xde, 0x3f, 0xea, 0xbc, 0x58, 0xe1, 0x4a, 0x92, 0x50, 0xcb,
	0xd5, 0x04, 0xa9, 0x56, 0xaf, 0x8a, 0x75, 0xae, 0xc0, 0xd3, 0x21, 0xc4, 0xc2, 0xe6, 0x3c, 0xb8,
	0xd2, 0x14, 0xf2, 0x02, 0x27, 0x15, 0x0e, 0x1b, 0x74, 0x78, 0xf7, 0xbf, 0x41, 0xb8, 0xbd, 0xf0,
	0xad, 0x8d, 0xee, 0xc0, 0xad, 0x79, 0x0f, 0x8d, 0x1a, 0x2f, 0x89, 0x7c, 0xa1, 0x51, 0xe2, 0x44,
	0xda, 0x87, 0x12, 0xb0, 0xf5, 0x25, 0x80, 0x50, 0x71, 0x39, 0xd1, 0x14, 0xda, 0x86, 0x3f, 0x8c,
	0x11, 0x15, 0xbe, 0xfe, 0xa2, 0x2a, 0x1e, 0x7c, 0xc9, 0x95, 0x1f, 0xed, 0xc0, 0xdd, 0x45, 0xc0,
	0xb1, 0xcb, 0x00, 0xda, 0x85, 0xfb, 0x8b, 0x90, 0x65, 0xae, 0xc2, 0x15, 0xf8, 0x32, 0x5f, 0xa9,
	0xd3, 0xc1, 0x65, 0xe1, 0xab, 0x8d, 0x7a, 0x4d, 0xc8, 0x3b, 0xc5, 0xba, 0x0f, 0xc9, 0xc5, 0xe1,
	0x09, 0x2e, 0x3c, 0x73, 0x02, 0x5f, 0x77, 0x28, 0x95, 0xb8, 0x02, 0x1d, 0x59, 0xc6, 0xd4, 0x75,
	0x4a, 0xb0, 0xd1, 0x65, 0xd8, 0x12, 0x57, 0x90, 0xca, 0x7c, 0x39, 0xcb, 0x8b, 0x74, 0x6c, 0x59,
	0x56, 0x4e, 0x0f, 0x38, 0x2d, 0x00, 0xe8, 0x11, 0xa4, 0x17, 0x01, 0x9f, 0x71, 0xa5, 0x52, 0x96,
	0xcb, 0x1d, 0x4c, 0xd7, 0x2c, 0xbe, 0x2b, 0xc0, 0xa5, 0x99, 0x6b, 0x7c, 0x09, 0xa2, 0xcd, 0x6a,
	0xa9, 0x5e, 0xe6, 0x6b, 0x45, 0xda, 0x87, 0xae, 0xc1, 0x15, 0x47, 0xaa, 0xd5, 0x1d, 0xbb, 0x5c,
	0xb5, 0x9c, 0xad, 0xd2, 0x14, 0x5a, 0x07, 0x94, 0x2b, 0x55, 0x1b, 0x79, 0xa9, 0xcc, 0x89, 0x07,
	0x7c, 0x5d, 0x3a, 0x2c, 0x71, 0x39, 0x9e, 0xf6, 0xef, 0xfe, 0xc7, 0x79, 0xee, 0x4e, 0xcd, 0xb9,
	0x24, 0xb0, 0x63, 0x3e, 0x65, 0xbe, 0x2c, 0x1d, 0x72, 0x05, 0x5e, 0xaa, 0x09, 0x2f, 0xa7, 0xef,
	0xd4, 0x74, 0xdb, 0xce, 0x62, 0x1e, 0x1f, 0x64, 0x69, 0x6a, 0x81, 0x3e, 0x53, 0xce, 0xd2, 0xfe,
	0x05, 0xfa, 0x3f, 0x15, 0xb2, 0x74, 0x20, 0xfb, 0x96, 0x3a, 0xfb, 0xc4, 0xfa, 0x3e, 0x7e, 0x62,
	0x7d, 0x9f, 0x3f, 0xb1, 0xd4, 0x3f, 0x87, 0x2c, 0xf5, 0x6e, 0xc8, 0x52, 0xdf, 0x0f, 0x59, 0xea,
	0x6c, 0xc8, 0x52, 0x1f, 0x87, 0x2c, 0xf5, 0xe3, 0x90, 0xa5, 0x7e, 0x1a, 0xb2, 0xbe, 0xcf, 0x43,
	0x96, 0xfa, 0xf7, 0x39, 0xeb, 0xfb, 0x70, 0xce, 0x52, 0x67, 0xe7, 0xac, 0xef, 0xe3, 0x39, 0xeb,
	0x7b, 0xd9, 0xec, 0xea, 0xc6, 0xab, 0x6e, 0x6a, 0xa0, 0xf7, 0x6c, 0x6c, 0x9a, 0xce, 0xc8, 0x4a,
	0x93, 0xc5, 0x91, 0x6e, 0xaa, 0x7b, 0xa3, 0x5f, 0x38, 0x7b, 0x23, 0x75, 0xda, 0x68, 0x75, 0xf5,
	0x34, 0x7e, 0x6d, 0x7b, 0xbf, 0xbb, 0xbf, 0xfa, 0x97, 0x46, 0x2b, 0x4c, 0x7e, 0x85, 0x3f, 0xfa,
	0x25, 0x00, 0x00, 0xff, 0xff, 0xe5, 0x88, 0x52, 0xdf, 0xfd, 0x10, 0x00, 0x00,
}

func (x HardwareDeviceType) String() string {
	s, ok := HardwareDeviceType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x HardwareDeviceInstanceUseType) String() string {
	s, ok := HardwareDeviceInstanceUseType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x HardwareType) String() string {
	s, ok := HardwareType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MemPageSize) String() string {
	s, ok := MemPageSize_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *DeviceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeviceType)
	if !ok {
		that2, ok := that.(DeviceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Use != that1.Use {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.MinUnit != that1.MinUnit {
		return false
	}
	if this.MaxUnit != that1.MaxUnit {
		return false
	}
	if len(this.DeviceList) != len(that1.DeviceList) {
		return false
	}
	for i := range this.DeviceList {
		if this.DeviceList[i] != that1.DeviceList[i] {
			return false
		}
	}
	return true
}
func (this *HardwareVendorModel) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HardwareVendorModel)
	if !ok {
		that2, ok := that.(HardwareVendorModel)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Vendor != that1.Vendor {
		return false
	}
	if this.Model != that1.Model {
		return false
	}
	return true
}
func (this *ImageType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ImageType)
	if !ok {
		that2, ok := that.(ImageType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Provider != that1.Provider {
		return false
	}
	if that1.CloudProvider == nil {
		if this.CloudProvider != nil {
			return false
		}
	} else if this.CloudProvider == nil {
		return false
	} else if !this.CloudProvider.Equal(that1.CloudProvider) {
		return false
	}
	return true
}
func (this *ImageType_Azure) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ImageType_Azure)
	if !ok {
		that2, ok := that.(ImageType_Azure)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Azure.Equal(that1.Azure) {
		return false
	}
	return true
}
func (this *ImageType_Aws) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ImageType_Aws)
	if !ok {
		that2, ok := that.(ImageType_Aws)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Aws.Equal(that1.Aws) {
		return false
	}
	return true
}
func (this *ImageType_Gcp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ImageType_Gcp)
	if !ok {
		that2, ok := that.(ImageType_Gcp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Gcp.Equal(that1.Gcp) {
		return false
	}
	return true
}
func (this *Azure) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Azure)
	if !ok {
		that2, ok := that.(Azure)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Image == nil {
		if this.Image != nil {
			return false
		}
	} else if this.Image == nil {
		return false
	} else if !this.Image.Equal(that1.Image) {
		return false
	}
	return true
}
func (this *Azure_Marketplace) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Azure_Marketplace)
	if !ok {
		that2, ok := that.(Azure_Marketplace)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Marketplace.Equal(that1.Marketplace) {
		return false
	}
	return true
}
func (this *Azure_ImageId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Azure_ImageId)
	if !ok {
		that2, ok := that.(Azure_ImageId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ImageId.Equal(that1.ImageId) {
		return false
	}
	return true
}
func (this *AzureImage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureImage)
	if !ok {
		that2, ok := that.(AzureImage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ImageId != that1.ImageId {
		return false
	}
	return true
}
func (this *Marketplace) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Marketplace)
	if !ok {
		that2, ok := that.(Marketplace)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Offer != that1.Offer {
		return false
	}
	if this.Sku != that1.Sku {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Publisher != that1.Publisher {
		return false
	}
	return true
}
func (this *Aws) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Aws)
	if !ok {
		that2, ok := that.(Aws)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Image == nil {
		if this.Image != nil {
			return false
		}
	} else if this.Image == nil {
		return false
	} else if !this.Image.Equal(that1.Image) {
		return false
	}
	return true
}
func (this *Aws_ImageId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Aws_ImageId)
	if !ok {
		that2, ok := that.(Aws_ImageId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ImageId.Equal(that1.ImageId) {
		return false
	}
	return true
}
func (this *AwsImage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AwsImage)
	if !ok {
		that2, ok := that.(AwsImage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ImageId != that1.ImageId {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	return true
}
func (this *Gcp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Gcp)
	if !ok {
		that2, ok := that.(Gcp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Image == nil {
		if this.Image != nil {
			return false
		}
	} else if this.Image == nil {
		return false
	} else if !this.Image.Equal(that1.Image) {
		return false
	}
	return true
}
func (this *Gcp_ImageId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Gcp_ImageId)
	if !ok {
		that2, ok := that.(Gcp_ImageId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ImageId.Equal(that1.ImageId) {
		return false
	}
	return true
}
func (this *GcpImage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GcpImage)
	if !ok {
		that2, ok := that.(GcpImage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ImageId != that1.ImageId {
		return false
	}
	return true
}
func (this *NumaMem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NumaMem)
	if !ok {
		that2, ok := that.(NumaMem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Memory != that1.Memory {
		return false
	}
	if this.Node != that1.Node {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.VendorModelList) != len(that1.VendorModelList) {
		return false
	}
	for i := range this.VendorModelList {
		if !this.VendorModelList[i].Equal(that1.VendorModelList[i]) {
			return false
		}
	}
	if len(this.Devices) != len(that1.Devices) {
		return false
	}
	for i := range this.Devices {
		if !this.Devices[i].Equal(that1.Devices[i]) {
			return false
		}
	}
	if len(this.ImageList) != len(that1.ImageList) {
		return false
	}
	for i := range this.ImageList {
		if !this.ImageList[i].Equal(that1.ImageList[i]) {
			return false
		}
	}
	if this.NumaNodes != that1.NumaNodes {
		return false
	}
	if this.MemPageSize != that1.MemPageSize {
		return false
	}
	if this.MemPageNumber != that1.MemPageNumber {
		return false
	}
	if len(this.NumaMem) != len(that1.NumaMem) {
		return false
	}
	for i := range this.NumaMem {
		if !this.NumaMem[i].Equal(that1.NumaMem[i]) {
			return false
		}
	}
	if this.CertifiedHardwareType != that1.CertifiedHardwareType {
		return false
	}
	if len(this.InternalUsbDeviceRule) != len(that1.InternalUsbDeviceRule) {
		return false
	}
	for i := range this.InternalUsbDeviceRule {
		if !this.InternalUsbDeviceRule[i].Equal(that1.InternalUsbDeviceRule[i]) {
			return false
		}
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.VendorModelList) != len(that1.VendorModelList) {
		return false
	}
	for i := range this.VendorModelList {
		if !this.VendorModelList[i].Equal(that1.VendorModelList[i]) {
			return false
		}
	}
	if len(this.Devices) != len(that1.Devices) {
		return false
	}
	for i := range this.Devices {
		if !this.Devices[i].Equal(that1.Devices[i]) {
			return false
		}
	}
	if len(this.ImageList) != len(that1.ImageList) {
		return false
	}
	for i := range this.ImageList {
		if !this.ImageList[i].Equal(that1.ImageList[i]) {
			return false
		}
	}
	if this.NumaNodes != that1.NumaNodes {
		return false
	}
	if this.MemPageSize != that1.MemPageSize {
		return false
	}
	if this.MemPageNumber != that1.MemPageNumber {
		return false
	}
	if len(this.NumaMem) != len(that1.NumaMem) {
		return false
	}
	for i := range this.NumaMem {
		if !this.NumaMem[i].Equal(that1.NumaMem[i]) {
			return false
		}
	}
	if this.CertifiedHardwareType != that1.CertifiedHardwareType {
		return false
	}
	if len(this.InternalUsbDeviceRule) != len(that1.InternalUsbDeviceRule) {
		return false
	}
	for i := range this.InternalUsbDeviceRule {
		if !this.InternalUsbDeviceRule[i].Equal(that1.InternalUsbDeviceRule[i]) {
			return false
		}
	}
	return true
}
func (this *CertifiedHardwareStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CertifiedHardwareStatus)
	if !ok {
		that2, ok := that.(CertifiedHardwareStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.LatestVersion != that1.LatestVersion {
		return false
	}
	return true
}
func (this *DeviceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&certified_hardware.DeviceType{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Use: "+fmt.Sprintf("%#v", this.Use)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "MinUnit: "+fmt.Sprintf("%#v", this.MinUnit)+",\n")
	s = append(s, "MaxUnit: "+fmt.Sprintf("%#v", this.MaxUnit)+",\n")
	s = append(s, "DeviceList: "+fmt.Sprintf("%#v", this.DeviceList)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HardwareVendorModel) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&certified_hardware.HardwareVendorModel{")
	s = append(s, "Vendor: "+fmt.Sprintf("%#v", this.Vendor)+",\n")
	s = append(s, "Model: "+fmt.Sprintf("%#v", this.Model)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ImageType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&certified_hardware.ImageType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Provider: "+fmt.Sprintf("%#v", this.Provider)+",\n")
	if this.CloudProvider != nil {
		s = append(s, "CloudProvider: "+fmt.Sprintf("%#v", this.CloudProvider)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ImageType_Azure) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&certified_hardware.ImageType_Azure{` +
		`Azure:` + fmt.Sprintf("%#v", this.Azure) + `}`}, ", ")
	return s
}
func (this *ImageType_Aws) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&certified_hardware.ImageType_Aws{` +
		`Aws:` + fmt.Sprintf("%#v", this.Aws) + `}`}, ", ")
	return s
}
func (this *ImageType_Gcp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&certified_hardware.ImageType_Gcp{` +
		`Gcp:` + fmt.Sprintf("%#v", this.Gcp) + `}`}, ", ")
	return s
}
func (this *Azure) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&certified_hardware.Azure{")
	if this.Image != nil {
		s = append(s, "Image: "+fmt.Sprintf("%#v", this.Image)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Azure_Marketplace) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&certified_hardware.Azure_Marketplace{` +
		`Marketplace:` + fmt.Sprintf("%#v", this.Marketplace) + `}`}, ", ")
	return s
}
func (this *Azure_ImageId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&certified_hardware.Azure_ImageId{` +
		`ImageId:` + fmt.Sprintf("%#v", this.ImageId) + `}`}, ", ")
	return s
}
func (this *AzureImage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&certified_hardware.AzureImage{")
	s = append(s, "ImageId: "+fmt.Sprintf("%#v", this.ImageId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Marketplace) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&certified_hardware.Marketplace{")
	s = append(s, "Offer: "+fmt.Sprintf("%#v", this.Offer)+",\n")
	s = append(s, "Sku: "+fmt.Sprintf("%#v", this.Sku)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Publisher: "+fmt.Sprintf("%#v", this.Publisher)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Aws) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&certified_hardware.Aws{")
	if this.Image != nil {
		s = append(s, "Image: "+fmt.Sprintf("%#v", this.Image)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Aws_ImageId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&certified_hardware.Aws_ImageId{` +
		`ImageId:` + fmt.Sprintf("%#v", this.ImageId) + `}`}, ", ")
	return s
}
func (this *AwsImage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&certified_hardware.AwsImage{")
	s = append(s, "ImageId: "+fmt.Sprintf("%#v", this.ImageId)+",\n")
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Gcp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&certified_hardware.Gcp{")
	if this.Image != nil {
		s = append(s, "Image: "+fmt.Sprintf("%#v", this.Image)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Gcp_ImageId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&certified_hardware.Gcp_ImageId{` +
		`ImageId:` + fmt.Sprintf("%#v", this.ImageId) + `}`}, ", ")
	return s
}
func (this *GcpImage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&certified_hardware.GcpImage{")
	s = append(s, "ImageId: "+fmt.Sprintf("%#v", this.ImageId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NumaMem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&certified_hardware.NumaMem{")
	s = append(s, "Memory: "+fmt.Sprintf("%#v", this.Memory)+",\n")
	s = append(s, "Node: "+fmt.Sprintf("%#v", this.Node)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&certified_hardware.GlobalSpecType{")
	if this.VendorModelList != nil {
		s = append(s, "VendorModelList: "+fmt.Sprintf("%#v", this.VendorModelList)+",\n")
	}
	if this.Devices != nil {
		s = append(s, "Devices: "+fmt.Sprintf("%#v", this.Devices)+",\n")
	}
	if this.ImageList != nil {
		s = append(s, "ImageList: "+fmt.Sprintf("%#v", this.ImageList)+",\n")
	}
	s = append(s, "NumaNodes: "+fmt.Sprintf("%#v", this.NumaNodes)+",\n")
	s = append(s, "MemPageSize: "+fmt.Sprintf("%#v", this.MemPageSize)+",\n")
	s = append(s, "MemPageNumber: "+fmt.Sprintf("%#v", this.MemPageNumber)+",\n")
	if this.NumaMem != nil {
		s = append(s, "NumaMem: "+fmt.Sprintf("%#v", this.NumaMem)+",\n")
	}
	s = append(s, "CertifiedHardwareType: "+fmt.Sprintf("%#v", this.CertifiedHardwareType)+",\n")
	if this.InternalUsbDeviceRule != nil {
		s = append(s, "InternalUsbDeviceRule: "+fmt.Sprintf("%#v", this.InternalUsbDeviceRule)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&certified_hardware.GetSpecType{")
	if this.VendorModelList != nil {
		s = append(s, "VendorModelList: "+fmt.Sprintf("%#v", this.VendorModelList)+",\n")
	}
	if this.Devices != nil {
		s = append(s, "Devices: "+fmt.Sprintf("%#v", this.Devices)+",\n")
	}
	if this.ImageList != nil {
		s = append(s, "ImageList: "+fmt.Sprintf("%#v", this.ImageList)+",\n")
	}
	s = append(s, "NumaNodes: "+fmt.Sprintf("%#v", this.NumaNodes)+",\n")
	s = append(s, "MemPageSize: "+fmt.Sprintf("%#v", this.MemPageSize)+",\n")
	s = append(s, "MemPageNumber: "+fmt.Sprintf("%#v", this.MemPageNumber)+",\n")
	if this.NumaMem != nil {
		s = append(s, "NumaMem: "+fmt.Sprintf("%#v", this.NumaMem)+",\n")
	}
	s = append(s, "CertifiedHardwareType: "+fmt.Sprintf("%#v", this.CertifiedHardwareType)+",\n")
	if this.InternalUsbDeviceRule != nil {
		s = append(s, "InternalUsbDeviceRule: "+fmt.Sprintf("%#v", this.InternalUsbDeviceRule)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CertifiedHardwareStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&certified_hardware.CertifiedHardwareStatus{")
	s = append(s, "LatestVersion: "+fmt.Sprintf("%#v", this.LatestVersion)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *DeviceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DeviceList) > 0 {
		for iNdEx := len(m.DeviceList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DeviceList[iNdEx])
			copy(dAtA[i:], m.DeviceList[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.DeviceList[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.MaxUnit != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxUnit))
		i--
		dAtA[i] = 0x28
	}
	if m.MinUnit != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MinUnit))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Use != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Use))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HardwareVendorModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HardwareVendorModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HardwareVendorModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Model) > 0 {
		i -= len(m.Model)
		copy(dAtA[i:], m.Model)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Model)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Vendor) > 0 {
		i -= len(m.Vendor)
		copy(dAtA[i:], m.Vendor)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Vendor)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ImageType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImageType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CloudProvider != nil {
		{
			size := m.CloudProvider.Size()
			i -= size
			if _, err := m.CloudProvider.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ImageType_Azure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImageType_Azure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Azure != nil {
		{
			size, err := m.Azure.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ImageType_Aws) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImageType_Aws) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Aws != nil {
		{
			size, err := m.Aws.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ImageType_Gcp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImageType_Gcp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Gcp != nil {
		{
			size, err := m.Gcp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Azure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Azure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Azure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Image != nil {
		{
			size := m.Image.Size()
			i -= size
			if _, err := m.Image.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Azure_Marketplace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Azure_Marketplace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Marketplace != nil {
		{
			size, err := m.Marketplace.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Azure_ImageId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Azure_ImageId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ImageId != nil {
		{
			size, err := m.ImageId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AzureImage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureImage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureImage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ImageId) > 0 {
		i -= len(m.ImageId)
		copy(dAtA[i:], m.ImageId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ImageId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Marketplace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Marketplace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Marketplace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Publisher) > 0 {
		i -= len(m.Publisher)
		copy(dAtA[i:], m.Publisher)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Publisher)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sku) > 0 {
		i -= len(m.Sku)
		copy(dAtA[i:], m.Sku)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Sku)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Offer) > 0 {
		i -= len(m.Offer)
		copy(dAtA[i:], m.Offer)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Offer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Aws) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Aws) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Aws) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Image != nil {
		{
			size := m.Image.Size()
			i -= size
			if _, err := m.Image.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Aws_ImageId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Aws_ImageId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ImageId != nil {
		{
			size, err := m.ImageId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AwsImage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AwsImage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AwsImage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ImageId) > 0 {
		i -= len(m.ImageId)
		copy(dAtA[i:], m.ImageId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ImageId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Gcp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Gcp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Gcp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Image != nil {
		{
			size := m.Image.Size()
			i -= size
			if _, err := m.Image.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Gcp_ImageId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Gcp_ImageId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ImageId != nil {
		{
			size, err := m.ImageId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *GcpImage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GcpImage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GcpImage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ImageId) > 0 {
		i -= len(m.ImageId)
		copy(dAtA[i:], m.ImageId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ImageId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NumaMem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NumaMem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NumaMem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Node != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x10
	}
	if m.Memory != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Memory))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InternalUsbDeviceRule) > 0 {
		for iNdEx := len(m.InternalUsbDeviceRule) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InternalUsbDeviceRule[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.CertifiedHardwareType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CertifiedHardwareType))
		i--
		dAtA[i] = 0x48
	}
	if len(m.NumaMem) > 0 {
		for iNdEx := len(m.NumaMem) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NumaMem[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.MemPageNumber != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MemPageNumber))
		i--
		dAtA[i] = 0x38
	}
	if m.MemPageSize != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MemPageSize))
		i--
		dAtA[i] = 0x30
	}
	if m.NumaNodes != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NumaNodes))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ImageList) > 0 {
		for iNdEx := len(m.ImageList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ImageList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Devices) > 0 {
		for iNdEx := len(m.Devices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Devices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.VendorModelList) > 0 {
		for iNdEx := len(m.VendorModelList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VendorModelList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InternalUsbDeviceRule) > 0 {
		for iNdEx := len(m.InternalUsbDeviceRule) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InternalUsbDeviceRule[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.CertifiedHardwareType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CertifiedHardwareType))
		i--
		dAtA[i] = 0x48
	}
	if len(m.NumaMem) > 0 {
		for iNdEx := len(m.NumaMem) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NumaMem[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.MemPageNumber != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MemPageNumber))
		i--
		dAtA[i] = 0x38
	}
	if m.MemPageSize != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MemPageSize))
		i--
		dAtA[i] = 0x30
	}
	if m.NumaNodes != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NumaNodes))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ImageList) > 0 {
		for iNdEx := len(m.ImageList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ImageList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Devices) > 0 {
		for iNdEx := len(m.Devices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Devices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.VendorModelList) > 0 {
		for iNdEx := len(m.VendorModelList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VendorModelList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CertifiedHardwareStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertifiedHardwareStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CertifiedHardwareStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LatestVersion) > 0 {
		i -= len(m.LatestVersion)
		copy(dAtA[i:], m.LatestVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LatestVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DeviceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.Use != 0 {
		n += 1 + sovTypes(uint64(m.Use))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.MinUnit != 0 {
		n += 1 + sovTypes(uint64(m.MinUnit))
	}
	if m.MaxUnit != 0 {
		n += 1 + sovTypes(uint64(m.MaxUnit))
	}
	if len(m.DeviceList) > 0 {
		for _, s := range m.DeviceList {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *HardwareVendorModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ImageType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CloudProvider != nil {
		n += m.CloudProvider.Size()
	}
	return n
}

func (m *ImageType_Azure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Azure != nil {
		l = m.Azure.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ImageType_Aws) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Aws != nil {
		l = m.Aws.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ImageType_Gcp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gcp != nil {
		l = m.Gcp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Azure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Image != nil {
		n += m.Image.Size()
	}
	return n
}

func (m *Azure_Marketplace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Marketplace != nil {
		l = m.Marketplace.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Azure_ImageId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ImageId != nil {
		l = m.ImageId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AzureImage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ImageId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Marketplace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Offer)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Sku)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Publisher)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Aws) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Image != nil {
		n += m.Image.Size()
	}
	return n
}

func (m *Aws_ImageId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ImageId != nil {
		l = m.ImageId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AwsImage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ImageId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Gcp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Image != nil {
		n += m.Image.Size()
	}
	return n
}

func (m *Gcp_ImageId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ImageId != nil {
		l = m.ImageId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GcpImage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ImageId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *NumaMem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Memory != 0 {
		n += 1 + sovTypes(uint64(m.Memory))
	}
	if m.Node != 0 {
		n += 1 + sovTypes(uint64(m.Node))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.VendorModelList) > 0 {
		for _, e := range m.VendorModelList {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ImageList) > 0 {
		for _, e := range m.ImageList {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.NumaNodes != 0 {
		n += 1 + sovTypes(uint64(m.NumaNodes))
	}
	if m.MemPageSize != 0 {
		n += 1 + sovTypes(uint64(m.MemPageSize))
	}
	if m.MemPageNumber != 0 {
		n += 1 + sovTypes(uint64(m.MemPageNumber))
	}
	if len(m.NumaMem) > 0 {
		for _, e := range m.NumaMem {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.CertifiedHardwareType != 0 {
		n += 1 + sovTypes(uint64(m.CertifiedHardwareType))
	}
	if len(m.InternalUsbDeviceRule) > 0 {
		for _, e := range m.InternalUsbDeviceRule {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.VendorModelList) > 0 {
		for _, e := range m.VendorModelList {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ImageList) > 0 {
		for _, e := range m.ImageList {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.NumaNodes != 0 {
		n += 1 + sovTypes(uint64(m.NumaNodes))
	}
	if m.MemPageSize != 0 {
		n += 1 + sovTypes(uint64(m.MemPageSize))
	}
	if m.MemPageNumber != 0 {
		n += 1 + sovTypes(uint64(m.MemPageNumber))
	}
	if len(m.NumaMem) > 0 {
		for _, e := range m.NumaMem {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.CertifiedHardwareType != 0 {
		n += 1 + sovTypes(uint64(m.CertifiedHardwareType))
	}
	if len(m.InternalUsbDeviceRule) > 0 {
		for _, e := range m.InternalUsbDeviceRule {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CertifiedHardwareStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LatestVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *DeviceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeviceType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Use:` + fmt.Sprintf("%v", this.Use) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`MinUnit:` + fmt.Sprintf("%v", this.MinUnit) + `,`,
		`MaxUnit:` + fmt.Sprintf("%v", this.MaxUnit) + `,`,
		`DeviceList:` + fmt.Sprintf("%v", this.DeviceList) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HardwareVendorModel) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HardwareVendorModel{`,
		`Vendor:` + fmt.Sprintf("%v", this.Vendor) + `,`,
		`Model:` + fmt.Sprintf("%v", this.Model) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ImageType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImageType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Provider:` + fmt.Sprintf("%v", this.Provider) + `,`,
		`CloudProvider:` + fmt.Sprintf("%v", this.CloudProvider) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ImageType_Azure) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImageType_Azure{`,
		`Azure:` + strings.Replace(fmt.Sprintf("%v", this.Azure), "Azure", "Azure", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ImageType_Aws) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImageType_Aws{`,
		`Aws:` + strings.Replace(fmt.Sprintf("%v", this.Aws), "Aws", "Aws", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ImageType_Gcp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImageType_Gcp{`,
		`Gcp:` + strings.Replace(fmt.Sprintf("%v", this.Gcp), "Gcp", "Gcp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Azure) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Azure{`,
		`Image:` + fmt.Sprintf("%v", this.Image) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Azure_Marketplace) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Azure_Marketplace{`,
		`Marketplace:` + strings.Replace(fmt.Sprintf("%v", this.Marketplace), "Marketplace", "Marketplace", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Azure_ImageId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Azure_ImageId{`,
		`ImageId:` + strings.Replace(fmt.Sprintf("%v", this.ImageId), "AzureImage", "AzureImage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureImage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureImage{`,
		`ImageId:` + fmt.Sprintf("%v", this.ImageId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Marketplace) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Marketplace{`,
		`Offer:` + fmt.Sprintf("%v", this.Offer) + `,`,
		`Sku:` + fmt.Sprintf("%v", this.Sku) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Publisher:` + fmt.Sprintf("%v", this.Publisher) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Aws) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Aws{`,
		`Image:` + fmt.Sprintf("%v", this.Image) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Aws_ImageId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Aws_ImageId{`,
		`ImageId:` + strings.Replace(fmt.Sprintf("%v", this.ImageId), "AwsImage", "AwsImage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AwsImage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AwsImage{`,
		`ImageId:` + fmt.Sprintf("%v", this.ImageId) + `,`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Gcp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Gcp{`,
		`Image:` + fmt.Sprintf("%v", this.Image) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Gcp_ImageId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Gcp_ImageId{`,
		`ImageId:` + strings.Replace(fmt.Sprintf("%v", this.ImageId), "GcpImage", "GcpImage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GcpImage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GcpImage{`,
		`ImageId:` + fmt.Sprintf("%v", this.ImageId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NumaMem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NumaMem{`,
		`Memory:` + fmt.Sprintf("%v", this.Memory) + `,`,
		`Node:` + fmt.Sprintf("%v", this.Node) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForVendorModelList := "[]*HardwareVendorModel{"
	for _, f := range this.VendorModelList {
		repeatedStringForVendorModelList += strings.Replace(f.String(), "HardwareVendorModel", "HardwareVendorModel", 1) + ","
	}
	repeatedStringForVendorModelList += "}"
	repeatedStringForDevices := "[]*DeviceType{"
	for _, f := range this.Devices {
		repeatedStringForDevices += strings.Replace(f.String(), "DeviceType", "DeviceType", 1) + ","
	}
	repeatedStringForDevices += "}"
	repeatedStringForImageList := "[]*ImageType{"
	for _, f := range this.ImageList {
		repeatedStringForImageList += strings.Replace(f.String(), "ImageType", "ImageType", 1) + ","
	}
	repeatedStringForImageList += "}"
	repeatedStringForNumaMem := "[]*NumaMem{"
	for _, f := range this.NumaMem {
		repeatedStringForNumaMem += strings.Replace(f.String(), "NumaMem", "NumaMem", 1) + ","
	}
	repeatedStringForNumaMem += "}"
	repeatedStringForInternalUsbDeviceRule := "[]*Rule{"
	for _, f := range this.InternalUsbDeviceRule {
		repeatedStringForInternalUsbDeviceRule += strings.Replace(fmt.Sprintf("%v", f), "Rule", "usb_policy.Rule", 1) + ","
	}
	repeatedStringForInternalUsbDeviceRule += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`VendorModelList:` + repeatedStringForVendorModelList + `,`,
		`Devices:` + repeatedStringForDevices + `,`,
		`ImageList:` + repeatedStringForImageList + `,`,
		`NumaNodes:` + fmt.Sprintf("%v", this.NumaNodes) + `,`,
		`MemPageSize:` + fmt.Sprintf("%v", this.MemPageSize) + `,`,
		`MemPageNumber:` + fmt.Sprintf("%v", this.MemPageNumber) + `,`,
		`NumaMem:` + repeatedStringForNumaMem + `,`,
		`CertifiedHardwareType:` + fmt.Sprintf("%v", this.CertifiedHardwareType) + `,`,
		`InternalUsbDeviceRule:` + repeatedStringForInternalUsbDeviceRule + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForVendorModelList := "[]*HardwareVendorModel{"
	for _, f := range this.VendorModelList {
		repeatedStringForVendorModelList += strings.Replace(f.String(), "HardwareVendorModel", "HardwareVendorModel", 1) + ","
	}
	repeatedStringForVendorModelList += "}"
	repeatedStringForDevices := "[]*DeviceType{"
	for _, f := range this.Devices {
		repeatedStringForDevices += strings.Replace(f.String(), "DeviceType", "DeviceType", 1) + ","
	}
	repeatedStringForDevices += "}"
	repeatedStringForImageList := "[]*ImageType{"
	for _, f := range this.ImageList {
		repeatedStringForImageList += strings.Replace(f.String(), "ImageType", "ImageType", 1) + ","
	}
	repeatedStringForImageList += "}"
	repeatedStringForNumaMem := "[]*NumaMem{"
	for _, f := range this.NumaMem {
		repeatedStringForNumaMem += strings.Replace(f.String(), "NumaMem", "NumaMem", 1) + ","
	}
	repeatedStringForNumaMem += "}"
	repeatedStringForInternalUsbDeviceRule := "[]*Rule{"
	for _, f := range this.InternalUsbDeviceRule {
		repeatedStringForInternalUsbDeviceRule += strings.Replace(fmt.Sprintf("%v", f), "Rule", "usb_policy.Rule", 1) + ","
	}
	repeatedStringForInternalUsbDeviceRule += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`VendorModelList:` + repeatedStringForVendorModelList + `,`,
		`Devices:` + repeatedStringForDevices + `,`,
		`ImageList:` + repeatedStringForImageList + `,`,
		`NumaNodes:` + fmt.Sprintf("%v", this.NumaNodes) + `,`,
		`MemPageSize:` + fmt.Sprintf("%v", this.MemPageSize) + `,`,
		`MemPageNumber:` + fmt.Sprintf("%v", this.MemPageNumber) + `,`,
		`NumaMem:` + repeatedStringForNumaMem + `,`,
		`CertifiedHardwareType:` + fmt.Sprintf("%v", this.CertifiedHardwareType) + `,`,
		`InternalUsbDeviceRule:` + repeatedStringForInternalUsbDeviceRule + `,`,
		`}`,
	}, "")
	return s
}
func (this *CertifiedHardwareStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CertifiedHardwareStatus{`,
		`LatestVersion:` + fmt.Sprintf("%v", this.LatestVersion) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *DeviceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= HardwareDeviceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Use", wireType)
			}
			m.Use = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Use |= HardwareDeviceInstanceUseType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinUnit", wireType)
			}
			m.MinUnit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinUnit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUnit", wireType)
			}
			m.MaxUnit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxUnit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceList = append(m.DeviceList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HardwareVendorModel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HardwareVendorModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HardwareVendorModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Azure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Azure{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CloudProvider = &ImageType_Azure{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aws", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Aws{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CloudProvider = &ImageType_Aws{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gcp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Gcp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CloudProvider = &ImageType_Gcp{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Azure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Azure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Azure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Marketplace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Marketplace{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Image = &Azure_Marketplace{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureImage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Image = &Azure_ImageId{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureImage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureImage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureImage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Marketplace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Marketplace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Marketplace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Offer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sku", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sku = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publisher", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Publisher = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Aws) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Aws: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Aws: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AwsImage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Image = &Aws_ImageId{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AwsImage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AwsImage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AwsImage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Gcp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Gcp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Gcp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GcpImage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Image = &Gcp_ImageId{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GcpImage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GcpImage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GcpImage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NumaMem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NumaMem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NumaMem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorModelList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorModelList = append(m.VendorModelList, &HardwareVendorModel{})
			if err := m.VendorModelList[len(m.VendorModelList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, &DeviceType{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageList = append(m.ImageList, &ImageType{})
			if err := m.ImageList[len(m.ImageList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumaNodes", wireType)
			}
			m.NumaNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumaNodes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemPageSize", wireType)
			}
			m.MemPageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemPageSize |= MemPageSize(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemPageNumber", wireType)
			}
			m.MemPageNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemPageNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumaMem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NumaMem = append(m.NumaMem, &NumaMem{})
			if err := m.NumaMem[len(m.NumaMem)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertifiedHardwareType", wireType)
			}
			m.CertifiedHardwareType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CertifiedHardwareType |= HardwareType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalUsbDeviceRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InternalUsbDeviceRule = append(m.InternalUsbDeviceRule, &usb_policy.Rule{})
			if err := m.InternalUsbDeviceRule[len(m.InternalUsbDeviceRule)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorModelList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorModelList = append(m.VendorModelList, &HardwareVendorModel{})
			if err := m.VendorModelList[len(m.VendorModelList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, &DeviceType{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageList = append(m.ImageList, &ImageType{})
			if err := m.ImageList[len(m.ImageList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumaNodes", wireType)
			}
			m.NumaNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumaNodes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemPageSize", wireType)
			}
			m.MemPageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemPageSize |= MemPageSize(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemPageNumber", wireType)
			}
			m.MemPageNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemPageNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumaMem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NumaMem = append(m.NumaMem, &NumaMem{})
			if err := m.NumaMem[len(m.NumaMem)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertifiedHardwareType", wireType)
			}
			m.CertifiedHardwareType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CertifiedHardwareType |= HardwareType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalUsbDeviceRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InternalUsbDeviceRule = append(m.InternalUsbDeviceRule, &usb_policy.Rule{})
			if err := m.InternalUsbDeviceRule[len(m.InternalUsbDeviceRule)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertifiedHardwareStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertifiedHardwareStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertifiedHardwareStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LatestVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
