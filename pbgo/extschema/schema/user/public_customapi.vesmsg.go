// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package user

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AcceptTOSRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AcceptTOSRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AcceptTOSRequest) DeepCopy() *AcceptTOSRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AcceptTOSRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AcceptTOSRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AcceptTOSRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AcceptTOSRequestValidator().Validate(ctx, m, opts...)
}

type ValidateAcceptTOSRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAcceptTOSRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AcceptTOSRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AcceptTOSRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tos_accepted"]; exists {

		vOpts := append(opts, db.WithValidateField("tos_accepted"))
		if err := fv(ctx, m.GetTosAccepted(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tos_accepted_at"]; exists {

		vOpts := append(opts, db.WithValidateField("tos_accepted_at"))
		if err := fv(ctx, m.GetTosAcceptedAt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tos_version"]; exists {

		vOpts := append(opts, db.WithValidateField("tos_version"))
		if err := fv(ctx, m.GetTosVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAcceptTOSRequestValidator = func() *ValidateAcceptTOSRequest {
	v := &ValidateAcceptTOSRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func AcceptTOSRequestValidator() db.Validator {
	return DefaultAcceptTOSRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *AcceptTOSResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AcceptTOSResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AcceptTOSResponse) DeepCopy() *AcceptTOSResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AcceptTOSResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AcceptTOSResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AcceptTOSResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AcceptTOSResponseValidator().Validate(ctx, m, opts...)
}

type ValidateAcceptTOSResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAcceptTOSResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AcceptTOSResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AcceptTOSResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAcceptTOSResponseValidator = func() *ValidateAcceptTOSResponse {
	v := &ValidateAcceptTOSResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func AcceptTOSResponseValidator() db.Validator {
	return DefaultAcceptTOSResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *AssignRoleRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AssignRoleRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AssignRoleRequest) DeepCopy() *AssignRoleRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AssignRoleRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AssignRoleRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AssignRoleRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AssignRoleRequestValidator().Validate(ctx, m, opts...)
}

type ValidateAssignRoleRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAssignRoleRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AssignRoleRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AssignRoleRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespaces_role"]; exists {

		vOpts := append(opts, db.WithValidateField("namespaces_role"))
		if err := fv(ctx, m.GetNamespacesRole(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["username"]; exists {

		vOpts := append(opts, db.WithValidateField("username"))
		for idx, item := range m.GetUsername() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAssignRoleRequestValidator = func() *ValidateAssignRoleRequest {
	v := &ValidateAssignRoleRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func AssignRoleRequestValidator() db.Validator {
	return DefaultAssignRoleRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *BillingFeatureIndicator) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BillingFeatureIndicator) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BillingFeatureIndicator) DeepCopy() *BillingFeatureIndicator {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BillingFeatureIndicator{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BillingFeatureIndicator) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BillingFeatureIndicator) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BillingFeatureIndicatorValidator().Validate(ctx, m, opts...)
}

type ValidateBillingFeatureIndicator struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBillingFeatureIndicator) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BillingFeatureIndicator)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BillingFeatureIndicator got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["action"]; exists {

		vOpts := append(opts, db.WithValidateField("action"))
		if err := fv(ctx, m.GetAction(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["additional_info"]; exists {

		vOpts := append(opts, db.WithValidateField("additional_info"))
		if err := fv(ctx, m.GetAdditionalInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["billing_flag"]; exists {

		vOpts := append(opts, db.WithValidateField("billing_flag"))
		if err := fv(ctx, m.GetBillingFlag(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["failed"]; exists {

		vOpts := append(opts, db.WithValidateField("failed"))
		if err := fv(ctx, m.GetFailed(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBillingFeatureIndicatorValidator = func() *ValidateBillingFeatureIndicator {
	v := &ValidateBillingFeatureIndicator{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func BillingFeatureIndicatorValidator() db.Validator {
	return DefaultBillingFeatureIndicatorValidator
}

// augmented methods on protoc/std generated struct

func (m *CascadeDeleteItemType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CascadeDeleteItemType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CascadeDeleteItemType) DeepCopy() *CascadeDeleteItemType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CascadeDeleteItemType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CascadeDeleteItemType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CascadeDeleteItemType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CascadeDeleteItemTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCascadeDeleteItemType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCascadeDeleteItemType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CascadeDeleteItemType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CascadeDeleteItemType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["error_message"]; exists {

		vOpts := append(opts, db.WithValidateField("error_message"))
		if err := fv(ctx, m.GetErrorMessage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["object_name"]; exists {

		vOpts := append(opts, db.WithValidateField("object_name"))
		if err := fv(ctx, m.GetObjectName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["object_type"]; exists {

		vOpts := append(opts, db.WithValidateField("object_type"))
		if err := fv(ctx, m.GetObjectType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["object_uid"]; exists {

		vOpts := append(opts, db.WithValidateField("object_uid"))
		if err := fv(ctx, m.GetObjectUid(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCascadeDeleteItemTypeValidator = func() *ValidateCascadeDeleteItemType {
	v := &ValidateCascadeDeleteItemType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func CascadeDeleteItemTypeValidator() db.Validator {
	return DefaultCascadeDeleteItemTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CascadeDeleteRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CascadeDeleteRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CascadeDeleteRequest) DeepCopy() *CascadeDeleteRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CascadeDeleteRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CascadeDeleteRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CascadeDeleteRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CascadeDeleteRequestValidator().Validate(ctx, m, opts...)
}

type ValidateCascadeDeleteRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCascadeDeleteRequest) EmailValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for email")
	}

	return validatorFn, nil
}

func (v *ValidateCascadeDeleteRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CascadeDeleteRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CascadeDeleteRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["email"]; exists {

		vOpts := append(opts, db.WithValidateField("email"))
		if err := fv(ctx, m.GetEmail(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCascadeDeleteRequestValidator = func() *ValidateCascadeDeleteRequest {
	v := &ValidateCascadeDeleteRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhEmail := v.EmailValidationRuleHandler
	rulesEmail := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhEmail(rulesEmail)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CascadeDeleteRequest.email: %s", err)
		panic(errMsg)
	}
	v.FldValidators["email"] = vFn

	return v
}()

func CascadeDeleteRequestValidator() db.Validator {
	return DefaultCascadeDeleteRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *CascadeDeleteResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CascadeDeleteResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CascadeDeleteResponse) DeepCopy() *CascadeDeleteResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CascadeDeleteResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CascadeDeleteResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CascadeDeleteResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CascadeDeleteResponseValidator().Validate(ctx, m, opts...)
}

type ValidateCascadeDeleteResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCascadeDeleteResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CascadeDeleteResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CascadeDeleteResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["delete_ok"]; exists {

		vOpts := append(opts, db.WithValidateField("delete_ok"))
		if err := fv(ctx, m.GetDeleteOk(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["items"]; exists {

		vOpts := append(opts, db.WithValidateField("items"))
		for idx, item := range m.GetItems() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCascadeDeleteResponseValidator = func() *ValidateCascadeDeleteResponse {
	v := &ValidateCascadeDeleteResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func CascadeDeleteResponseValidator() db.Validator {
	return DefaultCascadeDeleteResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *Empty) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Empty) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Empty) DeepCopy() *Empty {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Empty{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Empty) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Empty) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EmptyValidator().Validate(ctx, m, opts...)
}

type ValidateEmpty struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEmpty) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Empty)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Empty got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEmptyValidator = func() *ValidateEmpty {
	v := &ValidateEmpty{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func EmptyValidator() db.Validator {
	return DefaultEmptyValidator
}

// augmented methods on protoc/std generated struct

func (m *FeatureFlagType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FeatureFlagType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FeatureFlagType) DeepCopy() *FeatureFlagType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FeatureFlagType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FeatureFlagType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FeatureFlagType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FeatureFlagTypeValidator().Validate(ctx, m, opts...)
}

type ValidateFeatureFlagType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFeatureFlagType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FeatureFlagType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FeatureFlagType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["disabled"]; exists {

		vOpts := append(opts, db.WithValidateField("disabled"))
		if err := fv(ctx, m.GetDisabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFeatureFlagTypeValidator = func() *ValidateFeatureFlagType {
	v := &ValidateFeatureFlagType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FeatureFlagTypeValidator() db.Validator {
	return DefaultFeatureFlagTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GetTOSRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetTOSRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetTOSRequest) DeepCopy() *GetTOSRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetTOSRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetTOSRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetTOSRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetTOSRequestValidator().Validate(ctx, m, opts...)
}

type ValidateGetTOSRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetTOSRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetTOSRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetTOSRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetTOSRequestValidator = func() *ValidateGetTOSRequest {
	v := &ValidateGetTOSRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetTOSRequestValidator() db.Validator {
	return DefaultGetTOSRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *GetTOSResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetTOSResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetTOSResponse) DeepCopy() *GetTOSResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetTOSResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetTOSResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetTOSResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetTOSResponseValidator().Validate(ctx, m, opts...)
}

type ValidateGetTOSResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetTOSResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetTOSResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetTOSResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["text"]; exists {

		vOpts := append(opts, db.WithValidateField("text"))
		if err := fv(ctx, m.GetText(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetTOSResponseValidator = func() *ValidateGetTOSResponse {
	v := &ValidateGetTOSResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetTOSResponseValidator() db.Validator {
	return DefaultGetTOSResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *GetUserRoleRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetUserRoleRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetUserRoleRequest) DeepCopy() *GetUserRoleRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetUserRoleRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetUserRoleRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetUserRoleRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetUserRoleRequestValidator().Validate(ctx, m, opts...)
}

type ValidateGetUserRoleRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetUserRoleRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetUserRoleRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetUserRoleRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetUserRoleRequestValidator = func() *ValidateGetUserRoleRequest {
	v := &ValidateGetUserRoleRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetUserRoleRequestValidator() db.Validator {
	return DefaultGetUserRoleRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *GetUserRoleResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetUserRoleResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetUserRoleResponse) DeepCopy() *GetUserRoleResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetUserRoleResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetUserRoleResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetUserRoleResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetUserRoleResponseValidator().Validate(ctx, m, opts...)
}

type ValidateGetUserRoleResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetUserRoleResponse) SignupOriginValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.SignupOrigin)
		return int32(i)
	}
	// ves_io_schema.SignupOrigin_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.SignupOrigin_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for signup_origin")
	}

	return validatorFn, nil
}

func (v *ValidateGetUserRoleResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetUserRoleResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetUserRoleResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["access_type"]; exists {

		vOpts := append(opts, db.WithValidateField("access_type"))
		if err := fv(ctx, m.GetAccessType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["active_plan_transition_uid"]; exists {

		vOpts := append(opts, db.WithValidateField("active_plan_transition_uid"))
		if err := fv(ctx, m.GetActivePlanTransitionUid(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["addon_service_status"]; exists {

		vOpts := append(opts, db.WithValidateField("addon_service_status"))
		for key, value := range m.GetAddonServiceStatus() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["billing_flags"]; exists {

		vOpts := append(opts, db.WithValidateField("billing_flags"))
		for idx, item := range m.GetBillingFlags() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["billing_plan_name"]; exists {

		vOpts := append(opts, db.WithValidateField("billing_plan_name"))
		if err := fv(ctx, m.GetBillingPlanName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cname"]; exists {

		vOpts := append(opts, db.WithValidateField("cname"))
		if err := fv(ctx, m.GetCname(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["company"]; exists {

		vOpts := append(opts, db.WithValidateField("company"))
		if err := fv(ctx, m.GetCompany(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["creation_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("creation_timestamp"))
		if err := fv(ctx, m.GetCreationTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disabled"]; exists {

		vOpts := append(opts, db.WithValidateField("disabled"))
		if err := fv(ctx, m.GetDisabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["domain_owner"]; exists {

		vOpts := append(opts, db.WithValidateField("domain_owner"))
		if err := fv(ctx, m.GetDomainOwner(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["email"]; exists {

		vOpts := append(opts, db.WithValidateField("email"))
		if err := fv(ctx, m.GetEmail(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["environment"]; exists {

		vOpts := append(opts, db.WithValidateField("environment"))
		if err := fv(ctx, m.GetEnvironment(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["feature_flags"]; exists {

		vOpts := append(opts, db.WithValidateField("feature_flags"))
		for idx, item := range m.GetFeatureFlags() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["first_name"]; exists {

		vOpts := append(opts, db.WithValidateField("first_name"))
		if err := fv(ctx, m.GetFirstName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["group_names"]; exists {

		vOpts := append(opts, db.WithValidateField("group_names"))
		for idx, item := range m.GetGroupNames() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["idm_type"]; exists {

		vOpts := append(opts, db.WithValidateField("idm_type"))
		if err := fv(ctx, m.GetIdmType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["last_login_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("last_login_timestamp"))
		if err := fv(ctx, m.GetLastLoginTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["last_name"]; exists {

		vOpts := append(opts, db.WithValidateField("last_name"))
		if err := fv(ctx, m.GetLastName(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetManagedAccessInfo().(type) {
	case *GetUserRoleResponse_SelfManaged:
		if fv, exists := v.FldValidators["managed_access_info.self_managed"]; exists {
			val := m.GetManagedAccessInfo().(*GetUserRoleResponse_SelfManaged).SelfManaged
			vOpts := append(opts,
				db.WithValidateField("managed_access_info"),
				db.WithValidateField("self_managed"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetUserRoleResponse_MspManaged:
		if fv, exists := v.FldValidators["managed_access_info.msp_managed"]; exists {
			val := m.GetManagedAccessInfo().(*GetUserRoleResponse_MspManaged).MspManaged
			vOpts := append(opts,
				db.WithValidateField("managed_access_info"),
				db.WithValidateField("msp_managed"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace_access"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace_access"))
		if err := fv(ctx, m.GetNamespaceAccess(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace_roles"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace_roles"))
		for idx, item := range m.GetNamespaceRoles() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["original_tenant"]; exists {

		vOpts := append(opts, db.WithValidateField("original_tenant"))
		if err := fv(ctx, m.GetOriginalTenant(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["plan_type"]; exists {

		vOpts := append(opts, db.WithValidateField("plan_type"))
		if err := fv(ctx, m.GetPlanType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["signup_origin"]; exists {

		vOpts := append(opts, db.WithValidateField("signup_origin"))
		if err := fv(ctx, m.GetSignupOrigin(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sync_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("sync_mode"))
		if err := fv(ctx, m.GetSyncMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tenant"]; exists {

		vOpts := append(opts, db.WithValidateField("tenant"))
		if err := fv(ctx, m.GetTenant(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tenant_flags"]; exists {

		vOpts := append(opts, db.WithValidateField("tenant_flags"))
		for key, value := range m.GetTenantFlags() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tenant_state"]; exists {

		vOpts := append(opts, db.WithValidateField("tenant_state"))
		if err := fv(ctx, m.GetTenantState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tenant_type"]; exists {

		vOpts := append(opts, db.WithValidateField("tenant_type"))
		if err := fv(ctx, m.GetTenantType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tile_access"]; exists {

		vOpts := append(opts, db.WithValidateField("tile_access"))
		for key, value := range m.GetTileAccess() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tos_accepted"]; exists {

		vOpts := append(opts, db.WithValidateField("tos_accepted"))
		if err := fv(ctx, m.GetTosAccepted(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tos_accepted_at"]; exists {

		vOpts := append(opts, db.WithValidateField("tos_accepted_at"))
		if err := fv(ctx, m.GetTosAcceptedAt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tos_current_version"]; exists {

		vOpts := append(opts, db.WithValidateField("tos_current_version"))
		if err := fv(ctx, m.GetTosCurrentVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tos_version"]; exists {

		vOpts := append(opts, db.WithValidateField("tos_version"))
		if err := fv(ctx, m.GetTosVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user_uuid"]; exists {

		vOpts := append(opts, db.WithValidateField("user_uuid"))
		if err := fv(ctx, m.GetUserUuid(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetUserRoleResponseValidator = func() *ValidateGetUserRoleResponse {
	v := &ValidateGetUserRoleResponse{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSignupOrigin := v.SignupOriginValidationRuleHandler
	rulesSignupOrigin := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSignupOrigin(rulesSignupOrigin)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetUserRoleResponse.signup_origin: %s", err)
		panic(errMsg)
	}
	v.FldValidators["signup_origin"] = vFn

	v.FldValidators["namespace_roles"] = ves_io_schema.NamespaceRoleTypeValidator().Validate

	v.FldValidators["tile_access"] = TileAccessValidator().Validate

	v.FldValidators["addon_service_status"] = AddonServiceStatusValidator().Validate

	v.FldValidators["namespace_access"] = ves_io_schema.NamespaceAccessTypeValidator().Validate

	return v
}()

func GetUserRoleResponseValidator() db.Validator {
	return DefaultGetUserRoleResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *ListUserRoleRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListUserRoleRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListUserRoleRequest) DeepCopy() *ListUserRoleRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListUserRoleRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListUserRoleRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListUserRoleRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListUserRoleRequestValidator().Validate(ctx, m, opts...)
}

type ValidateListUserRoleRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListUserRoleRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListUserRoleRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListUserRoleRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListUserRoleRequestValidator = func() *ValidateListUserRoleRequest {
	v := &ValidateListUserRoleRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ListUserRoleRequestValidator() db.Validator {
	return DefaultListUserRoleRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ListUserRoleResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListUserRoleResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListUserRoleResponse) DeepCopy() *ListUserRoleResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListUserRoleResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListUserRoleResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListUserRoleResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListUserRoleResponseValidator().Validate(ctx, m, opts...)
}

type ValidateListUserRoleResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListUserRoleResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListUserRoleResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListUserRoleResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["items"]; exists {

		vOpts := append(opts, db.WithValidateField("items"))
		for idx, item := range m.GetItems() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListUserRoleResponseValidator = func() *ValidateListUserRoleResponse {
	v := &ValidateListUserRoleResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["items"] = ListUserRoleResponseItemValidator().Validate

	return v
}()

func ListUserRoleResponseValidator() db.Validator {
	return DefaultListUserRoleResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *ListUserRoleResponseItem) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListUserRoleResponseItem) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListUserRoleResponseItem) DeepCopy() *ListUserRoleResponseItem {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListUserRoleResponseItem{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListUserRoleResponseItem) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListUserRoleResponseItem) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListUserRoleResponseItemValidator().Validate(ctx, m, opts...)
}

type ValidateListUserRoleResponseItem struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListUserRoleResponseItem) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListUserRoleResponseItem)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListUserRoleResponseItem got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["creation_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("creation_timestamp"))
		if err := fv(ctx, m.GetCreationTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disabled"]; exists {

		vOpts := append(opts, db.WithValidateField("disabled"))
		if err := fv(ctx, m.GetDisabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["domain_owner"]; exists {

		vOpts := append(opts, db.WithValidateField("domain_owner"))
		if err := fv(ctx, m.GetDomainOwner(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["email"]; exists {

		vOpts := append(opts, db.WithValidateField("email"))
		if err := fv(ctx, m.GetEmail(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["first_name"]; exists {

		vOpts := append(opts, db.WithValidateField("first_name"))
		if err := fv(ctx, m.GetFirstName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["group_names"]; exists {

		vOpts := append(opts, db.WithValidateField("group_names"))
		for idx, item := range m.GetGroupNames() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["idm_type"]; exists {

		vOpts := append(opts, db.WithValidateField("idm_type"))
		if err := fv(ctx, m.GetIdmType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["last_login_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("last_login_timestamp"))
		if err := fv(ctx, m.GetLastLoginTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["last_name"]; exists {

		vOpts := append(opts, db.WithValidateField("last_name"))
		if err := fv(ctx, m.GetLastName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace_roles"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace_roles"))
		for idx, item := range m.GetNamespaceRoles() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["otp_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("otp_enabled"))
		if err := fv(ctx, m.GetOtpEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sync_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("sync_mode"))
		if err := fv(ctx, m.GetSyncMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tenant"]; exists {

		vOpts := append(opts, db.WithValidateField("tenant"))
		if err := fv(ctx, m.GetTenant(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tenant_type"]; exists {

		vOpts := append(opts, db.WithValidateField("tenant_type"))
		if err := fv(ctx, m.GetTenantType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListUserRoleResponseItemValidator = func() *ValidateListUserRoleResponseItem {
	v := &ValidateListUserRoleResponseItem{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["namespace_roles"] = ves_io_schema.NamespaceRoleTypeValidator().Validate

	return v
}()

func ListUserRoleResponseItemValidator() db.Validator {
	return DefaultListUserRoleResponseItemValidator
}

// augmented methods on protoc/std generated struct

func (m *MSPManaged) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MSPManaged) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MSPManaged) DeepCopy() *MSPManaged {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MSPManaged{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MSPManaged) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MSPManaged) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MSPManagedValidator().Validate(ctx, m, opts...)
}

type ValidateMSPManaged struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMSPManaged) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MSPManaged)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MSPManaged got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["msp_id"]; exists {

		vOpts := append(opts, db.WithValidateField("msp_id"))
		if err := fv(ctx, m.GetMspId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["node_type"]; exists {

		vOpts := append(opts, db.WithValidateField("node_type"))
		if err := fv(ctx, m.GetNodeType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["parent_tenant_id"]; exists {

		vOpts := append(opts, db.WithValidateField("parent_tenant_id"))
		if err := fv(ctx, m.GetParentTenantId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tier"]; exists {

		vOpts := append(opts, db.WithValidateField("tier"))
		if err := fv(ctx, m.GetTier(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMSPManagedValidator = func() *ValidateMSPManaged {
	v := &ValidateMSPManaged{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func MSPManagedValidator() db.Validator {
	return DefaultMSPManagedValidator
}

// augmented methods on protoc/std generated struct

func (m *NamespacesRoleType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NamespacesRoleType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NamespacesRoleType) DeepCopy() *NamespacesRoleType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NamespacesRoleType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NamespacesRoleType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NamespacesRoleType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NamespacesRoleTypeValidator().Validate(ctx, m, opts...)
}

type ValidateNamespacesRoleType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNamespacesRoleType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NamespacesRoleType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NamespacesRoleType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespaces"]; exists {

		vOpts := append(opts, db.WithValidateField("namespaces"))
		for idx, item := range m.GetNamespaces() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["role"]; exists {

		vOpts := append(opts, db.WithValidateField("role"))
		if err := fv(ctx, m.GetRole(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNamespacesRoleTypeValidator = func() *ValidateNamespacesRoleType {
	v := &ValidateNamespacesRoleType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func NamespacesRoleTypeValidator() db.Validator {
	return DefaultNamespacesRoleTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ResetPasswordByAdminRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ResetPasswordByAdminRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ResetPasswordByAdminRequest) DeepCopy() *ResetPasswordByAdminRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ResetPasswordByAdminRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ResetPasswordByAdminRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ResetPasswordByAdminRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ResetPasswordByAdminRequestValidator().Validate(ctx, m, opts...)
}

type ValidateResetPasswordByAdminRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateResetPasswordByAdminRequest) EmailValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for email")
	}

	return validatorFn, nil
}

func (v *ValidateResetPasswordByAdminRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ResetPasswordByAdminRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ResetPasswordByAdminRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["email"]; exists {

		vOpts := append(opts, db.WithValidateField("email"))
		if err := fv(ctx, m.GetEmail(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultResetPasswordByAdminRequestValidator = func() *ValidateResetPasswordByAdminRequest {
	v := &ValidateResetPasswordByAdminRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhEmail := v.EmailValidationRuleHandler
	rulesEmail := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhEmail(rulesEmail)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ResetPasswordByAdminRequest.email: %s", err)
		panic(errMsg)
	}
	v.FldValidators["email"] = vFn

	return v
}()

func ResetPasswordByAdminRequestValidator() db.Validator {
	return DefaultResetPasswordByAdminRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *SendPasswordEmailRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SendPasswordEmailRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SendPasswordEmailRequest) DeepCopy() *SendPasswordEmailRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SendPasswordEmailRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SendPasswordEmailRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SendPasswordEmailRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SendPasswordEmailRequestValidator().Validate(ctx, m, opts...)
}

type ValidateSendPasswordEmailRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSendPasswordEmailRequest) EmailValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for email")
	}

	return validatorFn, nil
}

func (v *ValidateSendPasswordEmailRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SendPasswordEmailRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SendPasswordEmailRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["email"]; exists {

		vOpts := append(opts, db.WithValidateField("email"))
		if err := fv(ctx, m.GetEmail(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSendPasswordEmailRequestValidator = func() *ValidateSendPasswordEmailRequest {
	v := &ValidateSendPasswordEmailRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhEmail := v.EmailValidationRuleHandler
	rulesEmail := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhEmail(rulesEmail)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SendPasswordEmailRequest.email: %s", err)
		panic(errMsg)
	}
	v.FldValidators["email"] = vFn

	return v
}()

func SendPasswordEmailRequestValidator() db.Validator {
	return DefaultSendPasswordEmailRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *SendPasswordEmailResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SendPasswordEmailResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SendPasswordEmailResponse) DeepCopy() *SendPasswordEmailResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SendPasswordEmailResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SendPasswordEmailResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SendPasswordEmailResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SendPasswordEmailResponseValidator().Validate(ctx, m, opts...)
}

type ValidateSendPasswordEmailResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSendPasswordEmailResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SendPasswordEmailResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SendPasswordEmailResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSendPasswordEmailResponseValidator = func() *ValidateSendPasswordEmailResponse {
	v := &ValidateSendPasswordEmailResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SendPasswordEmailResponseValidator() db.Validator {
	return DefaultSendPasswordEmailResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *UserGroupRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UserGroupRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UserGroupRequest) DeepCopy() *UserGroupRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UserGroupRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UserGroupRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UserGroupRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UserGroupRequestValidator().Validate(ctx, m, opts...)
}

type ValidateUserGroupRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUserGroupRequest) UsernameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for username")
	}

	return validatorFn, nil
}

func (v *ValidateUserGroupRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UserGroupRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UserGroupRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["group_names"]; exists {

		vOpts := append(opts, db.WithValidateField("group_names"))
		for idx, item := range m.GetGroupNames() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["username"]; exists {

		vOpts := append(opts, db.WithValidateField("username"))
		if err := fv(ctx, m.GetUsername(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUserGroupRequestValidator = func() *ValidateUserGroupRequest {
	v := &ValidateUserGroupRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhUsername := v.UsernameValidationRuleHandler
	rulesUsername := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "320",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhUsername(rulesUsername)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UserGroupRequest.username: %s", err)
		panic(errMsg)
	}
	v.FldValidators["username"] = vFn

	return v
}()

func UserGroupRequestValidator() db.Validator {
	return DefaultUserGroupRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *UserGroupResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UserGroupResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UserGroupResponse) DeepCopy() *UserGroupResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UserGroupResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UserGroupResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UserGroupResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UserGroupResponseValidator().Validate(ctx, m, opts...)
}

type ValidateUserGroupResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUserGroupResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UserGroupResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UserGroupResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["error"]; exists {

		vOpts := append(opts, db.WithValidateField("error"))
		if err := fv(ctx, m.GetError(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUserGroupResponseValidator = func() *ValidateUserGroupResponse {
	v := &ValidateUserGroupResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UserGroupResponseValidator() db.Validator {
	return DefaultUserGroupResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *UserRoleRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UserRoleRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UserRoleRequest) DeepCopy() *UserRoleRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UserRoleRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UserRoleRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UserRoleRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UserRoleRequestValidator().Validate(ctx, m, opts...)
}

type ValidateUserRoleRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUserRoleRequest) FirstNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for first_name")
	}

	return validatorFn, nil
}

func (v *ValidateUserRoleRequest) LastNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for last_name")
	}

	return validatorFn, nil
}

func (v *ValidateUserRoleRequest) EmailValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for email")
	}

	return validatorFn, nil
}

func (v *ValidateUserRoleRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UserRoleRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UserRoleRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["email"]; exists {

		vOpts := append(opts, db.WithValidateField("email"))
		if err := fv(ctx, m.GetEmail(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["first_name"]; exists {

		vOpts := append(opts, db.WithValidateField("first_name"))
		if err := fv(ctx, m.GetFirstName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["group_names"]; exists {

		vOpts := append(opts, db.WithValidateField("group_names"))
		for idx, item := range m.GetGroupNames() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["idm_type"]; exists {

		vOpts := append(opts, db.WithValidateField("idm_type"))
		if err := fv(ctx, m.GetIdmType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["last_name"]; exists {

		vOpts := append(opts, db.WithValidateField("last_name"))
		if err := fv(ctx, m.GetLastName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace_roles"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace_roles"))
		for idx, item := range m.GetNamespaceRoles() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUserRoleRequestValidator = func() *ValidateUserRoleRequest {
	v := &ValidateUserRoleRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhFirstName := v.FirstNameValidationRuleHandler
	rulesFirstName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhFirstName(rulesFirstName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UserRoleRequest.first_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["first_name"] = vFn

	vrhLastName := v.LastNameValidationRuleHandler
	rulesLastName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhLastName(rulesLastName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UserRoleRequest.last_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["last_name"] = vFn

	vrhEmail := v.EmailValidationRuleHandler
	rulesEmail := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhEmail(rulesEmail)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UserRoleRequest.email: %s", err)
		panic(errMsg)
	}
	v.FldValidators["email"] = vFn

	v.FldValidators["namespace_roles"] = ves_io_schema.NamespaceRoleTypeValidator().Validate

	return v
}()

func UserRoleRequestValidator() db.Validator {
	return DefaultUserRoleRequestValidator
}
