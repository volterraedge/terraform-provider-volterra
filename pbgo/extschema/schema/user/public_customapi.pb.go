// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/user/public_customapi.proto

// User management API
//
// x-displayName: "User"
// This API can be used to manage various attributes of the user like
// role, contact information etc.

package user

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/vesenv"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Billing flag
//
// x-displayName: "Billing flag"
// Possible billing flags used to indicate problems with customer billing.
type BillingFlag int32

const (
	// customer has a valid payment method on our file
	// x-displayName: "Valid payment method"
	VALID_PAYMENT_METHOD BillingFlag = 0
	// customer has at least one overdue invoice with with us
	// x-displayName: "Overdue invoice exists on customers file"
	OVERDUE_INVOICE BillingFlag = 1
	// status of customer's last transaction. a retry may be triggered so this is an early warning.
	// x-displayName: "Customer's last transaction is flagged as failed"
	LAST_TRANSACTION_STATUS BillingFlag = 2
	// this flag is on when the customer has no but expired payment method on it's file.
	// x-displayName: "All payment methods are expired"
	PAYMENT_METHOD_EXPIRED BillingFlag = 3
	// x-displayName: "We could not charge your primary payment method due to insufficient funds"
	// We could not charge your primary payment method due to insufficient funds
	PAYMENT_METHOD_INSUFFICIENT_FUNDS BillingFlag = 4
	// x-displayName: "Your primary payment method was declined"
	// Your primary payment method was declined
	PAYMENT_METHOD_PRIMARY_DECLINED BillingFlag = 5
	// x-displayName: "Security code for your primary payment method is incorrect"
	// Security code for your primary payment method is incorrect
	PAYMENT_METHOD_CVC_INVALID BillingFlag = 6
	// x-displayName: "ZIP code for your primary payment method is incorrect"
	// ZIP code for your primary payment method is incorrect
	PAYMENT_METHOD_ZIP_INVALID BillingFlag = 7
	// x-displayName: "We could not charge your primary payment method due to insufficient funds. Your secondary payment method was charged"
	// We could not charge your primary payment method due to insufficient funds. Your secondary payment method was charged
	PAYMENT_METHOD_INSUFFICIENT_FUNDS_SECONDARY_CHARGED BillingFlag = 8
	// x-displayName: "Your primary payment method has expired. Your secondary payment method was charged"
	// Your primary payment method has expired. Your secondary payment method was charged
	PAYMENT_METHOD_PRIMARY_EXPIRED_SECONDARY_CHARGED BillingFlag = 9
	// x-displayName: "Your primary payment method was declined. Your secondary payment method was charged"
	// Your primary payment method was declined. Your secondary payment method was charged
	PAYMENT_METHOD_PRIMARY_DECLINED_SECONDARY_CHARGED BillingFlag = 10
	// x-displayName: "We could not charge any of the active payment methods"
	// We could not charge any of the active payment methods
	PAYMENT_METHOD_BOTH_PAYMENT_METHOD_FAILED BillingFlag = 11
	// x-displayName: "We could not charge any of the active payment methods"
	// We could not charge any of the active payment methods
	PAYMENT_METHOD_GENERIC_FAILURE BillingFlag = 1000
	// x-displayName: "Adding a payment method resulted in an error"
	// Adding a payment method resulted in an error
	PAYMENT_METHOD_GENERIC_ADD_FAILURE BillingFlag = 1001
)

var BillingFlag_name = map[int32]string{
	0:    "VALID_PAYMENT_METHOD",
	1:    "OVERDUE_INVOICE",
	2:    "LAST_TRANSACTION_STATUS",
	3:    "PAYMENT_METHOD_EXPIRED",
	4:    "PAYMENT_METHOD_INSUFFICIENT_FUNDS",
	5:    "PAYMENT_METHOD_PRIMARY_DECLINED",
	6:    "PAYMENT_METHOD_CVC_INVALID",
	7:    "PAYMENT_METHOD_ZIP_INVALID",
	8:    "PAYMENT_METHOD_INSUFFICIENT_FUNDS_SECONDARY_CHARGED",
	9:    "PAYMENT_METHOD_PRIMARY_EXPIRED_SECONDARY_CHARGED",
	10:   "PAYMENT_METHOD_PRIMARY_DECLINED_SECONDARY_CHARGED",
	11:   "PAYMENT_METHOD_BOTH_PAYMENT_METHOD_FAILED",
	1000: "PAYMENT_METHOD_GENERIC_FAILURE",
	1001: "PAYMENT_METHOD_GENERIC_ADD_FAILURE",
}

var BillingFlag_value = map[string]int32{
	"VALID_PAYMENT_METHOD":                                0,
	"OVERDUE_INVOICE":                                     1,
	"LAST_TRANSACTION_STATUS":                             2,
	"PAYMENT_METHOD_EXPIRED":                              3,
	"PAYMENT_METHOD_INSUFFICIENT_FUNDS":                   4,
	"PAYMENT_METHOD_PRIMARY_DECLINED":                     5,
	"PAYMENT_METHOD_CVC_INVALID":                          6,
	"PAYMENT_METHOD_ZIP_INVALID":                          7,
	"PAYMENT_METHOD_INSUFFICIENT_FUNDS_SECONDARY_CHARGED": 8,
	"PAYMENT_METHOD_PRIMARY_EXPIRED_SECONDARY_CHARGED":    9,
	"PAYMENT_METHOD_PRIMARY_DECLINED_SECONDARY_CHARGED":   10,
	"PAYMENT_METHOD_BOTH_PAYMENT_METHOD_FAILED":           11,
	"PAYMENT_METHOD_GENERIC_FAILURE":                      1000,
	"PAYMENT_METHOD_GENERIC_ADD_FAILURE":                  1001,
}

func (BillingFlag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{0}
}

// Billing flag action
//
// x-displayName: "Billing flag action"
// Action to be executed when customer click on the UI warning
type BillingFlagAction int32

const (
	// we don't expect customer to take any actoon
	// x-displayName: "No action required"
	NO_ACTION BillingFlagAction = 0
	// customer should provide a new payment method
	// x-displayName: "Add new payment method"
	ADD_NEW_PAYMENT_METHOD BillingFlagAction = 1
	// customer should send us an email
	// x-displayName: "Contact us"
	CONTACT_US BillingFlagAction = 2
)

var BillingFlagAction_name = map[int32]string{
	0: "NO_ACTION",
	1: "ADD_NEW_PAYMENT_METHOD",
	2: "CONTACT_US",
}

var BillingFlagAction_value = map[string]int32{
	"NO_ACTION":              0,
	"ADD_NEW_PAYMENT_METHOD": 1,
	"CONTACT_US":             2,
}

func (BillingFlagAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{1}
}

// AccessType
//
// x-displayName: "Identify the tenant access"
// Used to identify the tenant access
type AccessType int32

const (
	// UNKNOWN_ACCESS
	//
	// x-displayName: "UNKNOWN_ACCESS"
	// When unable to determine the tenant access
	UNKNOWN_ACCESS AccessType = 0
	// DIRECT_ACCESS
	//
	// x-displayName: "DIRECT_ACCESS"
	// Accessing tenant through direct login
	DIRECT_ACCESS AccessType = 1
	// MSP_ACCESS
	//
	// x-displayName: "MSP_ACCESS"
	// Accessing tenant from MSP tenant
	MSP_ACCESS AccessType = 2
	// DELEGATED_ACCESS
	//
	// x-displayName: "DELEGATED_ACCESS"
	// Accessing tenant from operating tenant through delegated access
	DELEGATED_ACCESS AccessType = 3
	// SUPPORT_ACCESS
	//
	// x-displayName: "SUPPORT_ACCESS"
	// Accessing tenant from support tenant
	SUPPORT_ACCESS AccessType = 4
)

var AccessType_name = map[int32]string{
	0: "UNKNOWN_ACCESS",
	1: "DIRECT_ACCESS",
	2: "MSP_ACCESS",
	3: "DELEGATED_ACCESS",
	4: "SUPPORT_ACCESS",
}

var AccessType_value = map[string]int32{
	"UNKNOWN_ACCESS":   0,
	"DIRECT_ACCESS":    1,
	"MSP_ACCESS":       2,
	"DELEGATED_ACCESS": 3,
	"SUPPORT_ACCESS":   4,
}

func (AccessType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{2}
}

// Managed services node type
//
// x-displayName: "Managed services node type"
// Managed services node type. This is used to determine if the tenant is a parent or a child or not set at all.
type MSPNodeType int32

const (
	// MspUnknown
	//
	// x-displayName: "Managed services status unknown"
	// Managed services status is unknown or not set
	MspNodeTypeUnknown MSPNodeType = 0
	// MspChild
	//
	// x-displayName: "Managed services child"
	// Tenant acts as a child for another tenant. In other words, the tenant has a parent tenant that is managing it.
	MspNodeTypeChild MSPNodeType = 1
	// MspParent
	//
	// x-displayName: "Managed services parent"
	// Tenant acts as a parent for another tenant(s). In other words, the tenant has child tenants that are managed by it.
	MspNodeTypeParent MSPNodeType = 2
)

var MSPNodeType_name = map[int32]string{
	0: "MspNodeTypeUnknown",
	1: "MspNodeTypeChild",
	2: "MspNodeTypeParent",
}

var MSPNodeType_value = map[string]int32{
	"MspNodeTypeUnknown": 0,
	"MspNodeTypeChild":   1,
	"MspNodeTypeParent":  2,
}

func (MSPNodeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{3}
}

// Billing Feature Indicator
//
// x-displayName: "Billing feature indicator"
// Single instance of a billing indicator.
// It informs the customer of any problems with their billing, including failed payments, overdue invoices, or missing valid payment methods.
type BillingFeatureIndicator struct {
	// Billing flag name
	//
	// x-displayName: "Billing flag"
	// Name of the billing feature this flag relates to
	BillingFlag BillingFlag `protobuf:"varint,1,opt,name=billing_flag,json=billingFlag,proto3,enum=ves.io.schema.user.BillingFlag" json:"billing_flag,omitempty"`
	// Failed
	//
	// x-displayName: "Failed"
	// x-example: "true"
	// If true then the billing feature is failed and to be looked into.
	Failed bool `protobuf:"varint,2,opt,name=failed,proto3" json:"failed,omitempty"`
	// Additional info
	//
	// x-displayName: "Additional info"
	// x-example: "payment failed due to insufficient funds"
	// Any description (such as error message) related to this billing feature.
	AdditionalInfo string `protobuf:"bytes,3,opt,name=additional_info,json=additionalInfo,proto3" json:"additional_info,omitempty"`
	// Action the customer should take
	//
	// x-displayName: "Action to be performed"
	// Indicate an action the customer should make to mitigate the warning.
	Action BillingFlagAction `protobuf:"varint,4,opt,name=action,proto3,enum=ves.io.schema.user.BillingFlagAction" json:"action,omitempty"`
}

func (m *BillingFeatureIndicator) Reset()      { *m = BillingFeatureIndicator{} }
func (*BillingFeatureIndicator) ProtoMessage() {}
func (*BillingFeatureIndicator) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{0}
}
func (m *BillingFeatureIndicator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BillingFeatureIndicator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BillingFeatureIndicator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BillingFeatureIndicator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BillingFeatureIndicator.Merge(m, src)
}
func (m *BillingFeatureIndicator) XXX_Size() int {
	return m.Size()
}
func (m *BillingFeatureIndicator) XXX_DiscardUnknown() {
	xxx_messageInfo_BillingFeatureIndicator.DiscardUnknown(m)
}

var xxx_messageInfo_BillingFeatureIndicator proto.InternalMessageInfo

func (m *BillingFeatureIndicator) GetBillingFlag() BillingFlag {
	if m != nil {
		return m.BillingFlag
	}
	return VALID_PAYMENT_METHOD
}

func (m *BillingFeatureIndicator) GetFailed() bool {
	if m != nil {
		return m.Failed
	}
	return false
}

func (m *BillingFeatureIndicator) GetAdditionalInfo() string {
	if m != nil {
		return m.AdditionalInfo
	}
	return ""
}

func (m *BillingFeatureIndicator) GetAction() BillingFlagAction {
	if m != nil {
		return m.Action
	}
	return NO_ACTION
}

// Send password email request
//
// x-displayName: "Send Password Email Request"
// SendPasswordEmailRequest is the request parameters for sending the password update.
// Note that only admin is allowed to resend the password for users.
type SendPasswordEmailRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Value of namespace is always "system"
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// email of the user
	//
	// x-displayName: "Email"
	// x-example: "value"
	// x-required
	// email of the user requesting for
	Email string `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
}

func (m *SendPasswordEmailRequest) Reset()      { *m = SendPasswordEmailRequest{} }
func (*SendPasswordEmailRequest) ProtoMessage() {}
func (*SendPasswordEmailRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{1}
}
func (m *SendPasswordEmailRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendPasswordEmailRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendPasswordEmailRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendPasswordEmailRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendPasswordEmailRequest.Merge(m, src)
}
func (m *SendPasswordEmailRequest) XXX_Size() int {
	return m.Size()
}
func (m *SendPasswordEmailRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SendPasswordEmailRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SendPasswordEmailRequest proto.InternalMessageInfo

func (m *SendPasswordEmailRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *SendPasswordEmailRequest) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

// Send password email response
//
// x-displayName: "Send Password Email Response"
// SendPasswordEmailResponse is an empty response after an email had been sent.
type SendPasswordEmailResponse struct {
}

func (m *SendPasswordEmailResponse) Reset()      { *m = SendPasswordEmailResponse{} }
func (*SendPasswordEmailResponse) ProtoMessage() {}
func (*SendPasswordEmailResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{2}
}
func (m *SendPasswordEmailResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendPasswordEmailResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendPasswordEmailResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendPasswordEmailResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendPasswordEmailResponse.Merge(m, src)
}
func (m *SendPasswordEmailResponse) XXX_Size() int {
	return m.Size()
}
func (m *SendPasswordEmailResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SendPasswordEmailResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SendPasswordEmailResponse proto.InternalMessageInfo

// Reset password by admin request
//
// x-displayName: "Reset password by admin request"
// Reset password by admin request contains email of user for which password will be reset.
type ResetPasswordByAdminRequest struct {
	// Email
	//
	// x-displayName: "Email"
	// x-example: "john@example.com"
	// x-required
	// Email of user for which password will be reset.
	Email string `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
}

func (m *ResetPasswordByAdminRequest) Reset()      { *m = ResetPasswordByAdminRequest{} }
func (*ResetPasswordByAdminRequest) ProtoMessage() {}
func (*ResetPasswordByAdminRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{3}
}
func (m *ResetPasswordByAdminRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResetPasswordByAdminRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResetPasswordByAdminRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResetPasswordByAdminRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetPasswordByAdminRequest.Merge(m, src)
}
func (m *ResetPasswordByAdminRequest) XXX_Size() int {
	return m.Size()
}
func (m *ResetPasswordByAdminRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetPasswordByAdminRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResetPasswordByAdminRequest proto.InternalMessageInfo

func (m *ResetPasswordByAdminRequest) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

// Namespace Role Type
//
// x-displayName: "Namespace Role Type"
// Association of a role to namespaces
type NamespacesRoleType struct {
	// Namespaces
	//
	// x-displayName: "Namespaces"
	// x-example: "value"
	// Namespace, including star (`*`) which means all tenant's namespaces
	Namespaces []string `protobuf:"bytes,1,rep,name=namespaces,proto3" json:"namespaces,omitempty"`
	// Role
	//
	// x-displayName: "Role"
	// x-example: "value"
	// Users role for this namespace
	Role string `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`
}

func (m *NamespacesRoleType) Reset()      { *m = NamespacesRoleType{} }
func (*NamespacesRoleType) ProtoMessage() {}
func (*NamespacesRoleType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{4}
}
func (m *NamespacesRoleType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamespacesRoleType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NamespacesRoleType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NamespacesRoleType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamespacesRoleType.Merge(m, src)
}
func (m *NamespacesRoleType) XXX_Size() int {
	return m.Size()
}
func (m *NamespacesRoleType) XXX_DiscardUnknown() {
	xxx_messageInfo_NamespacesRoleType.DiscardUnknown(m)
}

var xxx_messageInfo_NamespacesRoleType proto.InternalMessageInfo

func (m *NamespacesRoleType) GetNamespaces() []string {
	if m != nil {
		return m.Namespaces
	}
	return nil
}

func (m *NamespacesRoleType) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

// User role
//
// x-displayName: "User Role"
// Allows creation of a user along with their roles in namespaces.
type UserRoleRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "system"
	// All users of a tenant must be created in tenant's system namespace.
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Username
	//
	// x-displayName: "Username"
	// x-example: "user1@company.com"
	// This is an optional field meant to be used as username.
	// Inside Volterra's UAM, email is already treated as user's username
	// and as best practice, recommendation is to keep this same as email field.
	// if not specified, this field will be set same as email field.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// first name
	//
	// x-displayName: "First Name"
	// x-example: "Dan"
	// x-required
	// User's first name
	FirstName string `protobuf:"bytes,3,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	// last name
	//
	// x-displayName: "Last Name"
	// x-example: "Brown"
	// x-required
	// User's last name
	LastName string `protobuf:"bytes,4,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
	// email
	//
	// x-displayName: "Email Address"
	// x-example: "user1@company.com"
	// x-required
	// user's email
	Email string `protobuf:"bytes,5,opt,name=email,proto3" json:"email,omitempty"`
	// User type
	//
	// x-displayName: "User Type"
	// Type of the user account (USER, SERVICE)
	Type UserType `protobuf:"varint,6,opt,name=type,proto3,enum=ves.io.schema.user.UserType" json:"type,omitempty"`
	// Namespace roles
	//
	// x-displayName: "Namespace Roles"
	// List of directly attached roles that the user has for each namespace.
	NamespaceRoles []*schema.NamespaceRoleType `protobuf:"bytes,7,rep,name=namespace_roles,json=namespaceRoles,proto3" json:"namespace_roles,omitempty"`
	// IDM Type
	//
	// x-displayName: "Identity Management Type"
	// Type of the Identity management required for the user.
	// if SSO is not enabled, set this to VOLTERRA_MANAGED
	// VOLTERRA_MANGED user is a local user fully managed by Volterra's User Access Management.
	IdmType IdmType `protobuf:"varint,8,opt,name=idm_type,json=idmType,proto3,enum=ves.io.schema.user.IdmType" json:"idm_type,omitempty"`
	// Groups
	//
	// x-displayName: "Groups"
	// x-example: "["dev-group-1"]"
	// Group list must be associated to this user.
	GroupNames []string `protobuf:"bytes,9,rep,name=group_names,json=groupNames,proto3" json:"group_names,omitempty"`
}

func (m *UserRoleRequest) Reset()      { *m = UserRoleRequest{} }
func (*UserRoleRequest) ProtoMessage() {}
func (*UserRoleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{5}
}
func (m *UserRoleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserRoleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserRoleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserRoleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRoleRequest.Merge(m, src)
}
func (m *UserRoleRequest) XXX_Size() int {
	return m.Size()
}
func (m *UserRoleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRoleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UserRoleRequest proto.InternalMessageInfo

func (m *UserRoleRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *UserRoleRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UserRoleRequest) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *UserRoleRequest) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *UserRoleRequest) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *UserRoleRequest) GetType() UserType {
	if m != nil {
		return m.Type
	}
	return USER
}

func (m *UserRoleRequest) GetNamespaceRoles() []*schema.NamespaceRoleType {
	if m != nil {
		return m.NamespaceRoles
	}
	return nil
}

func (m *UserRoleRequest) GetIdmType() IdmType {
	if m != nil {
		return m.IdmType
	}
	return SSO
}

func (m *UserRoleRequest) GetGroupNames() []string {
	if m != nil {
		return m.GroupNames
	}
	return nil
}

// List user roles
//
// x-displayName: "List User Roles"
// Allows list user roles in a namespace
type ListUserRoleRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Namespace to use
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *ListUserRoleRequest) Reset()      { *m = ListUserRoleRequest{} }
func (*ListUserRoleRequest) ProtoMessage() {}
func (*ListUserRoleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{6}
}
func (m *ListUserRoleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListUserRoleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListUserRoleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListUserRoleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUserRoleRequest.Merge(m, src)
}
func (m *ListUserRoleRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListUserRoleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUserRoleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListUserRoleRequest proto.InternalMessageInfo

func (m *ListUserRoleRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// Assign role
//
// x-displayName: "Assign Role"
// Allows assigning user's role in a namespace or set of namespaces.
type AssignRoleRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "system"
	// Namespace the requesting user is calling the action from
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Namespace role
	//
	// x-displayName: "Namespace Role"
	// namespace role to assign
	NamespacesRole *NamespacesRoleType `protobuf:"bytes,2,opt,name=namespaces_role,json=namespacesRole,proto3" json:"namespaces_role,omitempty"`
	// Username
	//
	// x-displayName: "Username"
	// x-example: "user1@company.com"
	// Username of the user that needs the role assigned.
	// ideally this will be the email address of the user (which is by default treated as username)
	// check Create RPC UserRoleRequest for more details.
	Username []string `protobuf:"bytes,3,rep,name=username,proto3" json:"username,omitempty"`
}

func (m *AssignRoleRequest) Reset()      { *m = AssignRoleRequest{} }
func (*AssignRoleRequest) ProtoMessage() {}
func (*AssignRoleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{7}
}
func (m *AssignRoleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssignRoleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssignRoleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssignRoleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssignRoleRequest.Merge(m, src)
}
func (m *AssignRoleRequest) XXX_Size() int {
	return m.Size()
}
func (m *AssignRoleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AssignRoleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AssignRoleRequest proto.InternalMessageInfo

func (m *AssignRoleRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *AssignRoleRequest) GetNamespacesRole() *NamespacesRoleType {
	if m != nil {
		return m.NamespacesRole
	}
	return nil
}

func (m *AssignRoleRequest) GetUsername() []string {
	if m != nil {
		return m.Username
	}
	return nil
}

// List user roles
//
// x-displayName: "List User Roles"
// Allows user namespace roles retrieval
type ListUserRoleResponse struct {
	// User namespace roles
	//
	// x-displayName: "User Namespace Roles"
	// List of user namespace roles
	Items []*ListUserRoleResponseItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *ListUserRoleResponse) Reset()      { *m = ListUserRoleResponse{} }
func (*ListUserRoleResponse) ProtoMessage() {}
func (*ListUserRoleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{8}
}
func (m *ListUserRoleResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListUserRoleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListUserRoleResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListUserRoleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUserRoleResponse.Merge(m, src)
}
func (m *ListUserRoleResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListUserRoleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUserRoleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListUserRoleResponse proto.InternalMessageInfo

func (m *ListUserRoleResponse) GetItems() []*ListUserRoleResponseItem {
	if m != nil {
		return m.Items
	}
	return nil
}

// List user role
//
// x-displayName: "List User Role"
// Allows user namespace role retrieval
type ListUserRoleResponseItem struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "system"
	// Namespace of the user object (namespace where the user object is stored).
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Name
	//
	// x-displayName: "Name"
	// x-example: "value"
	// name of the user
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Email
	//
	// x-displayName: "Email Address"
	// x-example: "value"
	// Email of the user object
	Email string `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
	// First name
	//
	// x-displayName: "First Name"
	// x-example: "value"
	// First name of the customer
	FirstName string `protobuf:"bytes,4,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	// Last name
	//
	// x-displayName: "Last Name"
	// x-example: "value"
	// Last name of the customer
	LastName string `protobuf:"bytes,5,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
	// User type
	//
	// x-displayName: "User Type"
	// Type of the user account (USER, SERVICE)
	Type UserType `protobuf:"varint,6,opt,name=type,proto3,enum=ves.io.schema.user.UserType" json:"type,omitempty"`
	// Namespace roles
	//
	// x-displayName: "Namespace Roles"
	// List of directly attached roles that the user has for each namespace.
	NamespaceRoles []*schema.NamespaceRoleType `protobuf:"bytes,7,rep,name=namespace_roles,json=namespaceRoles,proto3" json:"namespace_roles,omitempty"`
	// Tenant
	//
	// x-displayName: "Tenant"
	// x-example: "value"
	// tenant that the user belongs to
	Tenant string `protobuf:"bytes,8,opt,name=tenant,proto3" json:"tenant,omitempty"`
	// Tenant type
	//
	// x-displayName: "Tenant Type"
	// tenant type of the user (FREEMIUM, ENTERPRISE, ...)
	TenantType schema.TenantType `protobuf:"varint,9,opt,name=tenant_type,json=tenantType,proto3,enum=ves.io.schema.TenantType" json:"tenant_type,omitempty"`
	// IDM type
	//
	// x-displayName: "Identity Management Type"
	// Identity management type of the user (F5XC Managed, SSO)
	IdmType IdmType `protobuf:"varint,10,opt,name=idm_type,json=idmType,proto3,enum=ves.io.schema.user.IdmType" json:"idm_type,omitempty"`
	//  Domain Owner
	//
	// x-displayName: "Domain Owner"
	// x-example: "true"
	// Domain owner is the first user who registered or signed up the associated Tenant.
	// User created via signup flow will have this value set to true.
	// Few restrictions apply to this user w.r.t role update and deletion.
	DomainOwner bool `protobuf:"varint,11,opt,name=domain_owner,json=domainOwner,proto3" json:"domain_owner,omitempty"`
	// OTP Enabled
	//
	// x-displayName: "OTP Enabled"
	// Shows if OTP is enabled in IDM Provider.
	OtpEnabled bool `protobuf:"varint,12,opt,name=otp_enabled,json=otpEnabled,proto3" json:"otp_enabled,omitempty"`
	// Disabled
	//
	// x-displayName: "Disabled"
	// If set to true user is completely disabled including IDM.
	Disabled bool `protobuf:"varint,13,opt,name=disabled,proto3" json:"disabled,omitempty"`
	// Creation timestamp
	//
	// x-displayName: "Creation timestamp"
	// Timestamp of user creation.
	CreationTimestamp *types.Timestamp `protobuf:"bytes,14,opt,name=creation_timestamp,json=creationTimestamp,proto3" json:"creation_timestamp,omitempty"`
	// Last login timestamp
	//
	// x-displayName: "Last login timestamp"
	// Last login timestamp when user successfully login to access VoltConsole.
	LastLoginTimestamp *types.Timestamp `protobuf:"bytes,15,opt,name=last_login_timestamp,json=lastLoginTimestamp,proto3" json:"last_login_timestamp,omitempty"`
	// Groups
	//
	// x-displayName: "Groups"
	// x-example: "["dev-group-1"]"
	// Group list must be associated to this user.
	GroupNames []string `protobuf:"bytes,16,rep,name=group_names,json=groupNames,proto3" json:"group_names,omitempty"`
	// Sync Mode
	//
	// x-displayName: "Sync Mode"
	// x-example: "self"
	// Denotes if this is an externally managed entity imported into UAM by SCIM protocol, or self managed.
	SyncMode schema.SyncMode `protobuf:"varint,17,opt,name=sync_mode,json=syncMode,proto3,enum=ves.io.schema.SyncMode" json:"sync_mode,omitempty"`
}

func (m *ListUserRoleResponseItem) Reset()      { *m = ListUserRoleResponseItem{} }
func (*ListUserRoleResponseItem) ProtoMessage() {}
func (*ListUserRoleResponseItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{9}
}
func (m *ListUserRoleResponseItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListUserRoleResponseItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListUserRoleResponseItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListUserRoleResponseItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUserRoleResponseItem.Merge(m, src)
}
func (m *ListUserRoleResponseItem) XXX_Size() int {
	return m.Size()
}
func (m *ListUserRoleResponseItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUserRoleResponseItem.DiscardUnknown(m)
}

var xxx_messageInfo_ListUserRoleResponseItem proto.InternalMessageInfo

func (m *ListUserRoleResponseItem) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ListUserRoleResponseItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListUserRoleResponseItem) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *ListUserRoleResponseItem) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *ListUserRoleResponseItem) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *ListUserRoleResponseItem) GetType() UserType {
	if m != nil {
		return m.Type
	}
	return USER
}

func (m *ListUserRoleResponseItem) GetNamespaceRoles() []*schema.NamespaceRoleType {
	if m != nil {
		return m.NamespaceRoles
	}
	return nil
}

func (m *ListUserRoleResponseItem) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *ListUserRoleResponseItem) GetTenantType() schema.TenantType {
	if m != nil {
		return m.TenantType
	}
	return schema.UNKNOWN
}

func (m *ListUserRoleResponseItem) GetIdmType() IdmType {
	if m != nil {
		return m.IdmType
	}
	return SSO
}

func (m *ListUserRoleResponseItem) GetDomainOwner() bool {
	if m != nil {
		return m.DomainOwner
	}
	return false
}

func (m *ListUserRoleResponseItem) GetOtpEnabled() bool {
	if m != nil {
		return m.OtpEnabled
	}
	return false
}

func (m *ListUserRoleResponseItem) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

func (m *ListUserRoleResponseItem) GetCreationTimestamp() *types.Timestamp {
	if m != nil {
		return m.CreationTimestamp
	}
	return nil
}

func (m *ListUserRoleResponseItem) GetLastLoginTimestamp() *types.Timestamp {
	if m != nil {
		return m.LastLoginTimestamp
	}
	return nil
}

func (m *ListUserRoleResponseItem) GetGroupNames() []string {
	if m != nil {
		return m.GroupNames
	}
	return nil
}

func (m *ListUserRoleResponseItem) GetSyncMode() schema.SyncMode {
	if m != nil {
		return m.SyncMode
	}
	return schema.SELF
}

// Get user role
//
// x-displayName: "Get User Role"
// Allows user namespace role retrieval
type GetUserRoleRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Namespace of the user object (namespace where the user object is stored).
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *GetUserRoleRequest) Reset()      { *m = GetUserRoleRequest{} }
func (*GetUserRoleRequest) ProtoMessage() {}
func (*GetUserRoleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{10}
}
func (m *GetUserRoleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUserRoleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUserRoleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUserRoleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUserRoleRequest.Merge(m, src)
}
func (m *GetUserRoleRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetUserRoleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUserRoleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetUserRoleRequest proto.InternalMessageInfo

func (m *GetUserRoleRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// Get User Detail Response
//
// x-displayName: "User Detail Response"
// Detailed information about user including role assigments and other details for tenant.
type GetUserRoleResponse struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Namespace of the user object (namespace where the user object is stored).
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Name
	//
	// x-displayName: "Username"
	// x-example: "value"
	// Username of the user
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Email
	//
	// x-displayName: "Email Address"
	// x-example: "value"
	// Email of the user object
	Email string `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
	// First name
	//
	// x-displayName: "First Name"
	// x-example: "value"
	// First name of the customer
	FirstName string `protobuf:"bytes,4,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	// Last name
	//
	// x-displayName: "Last Name"
	// x-example: "value"
	// Last name of the customer
	LastName string `protobuf:"bytes,5,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
	// User type
	//
	// x-displayName: "User Type"
	// Type of the user account (USER, SERVICE)
	Type UserType `protobuf:"varint,6,opt,name=type,proto3,enum=ves.io.schema.user.UserType" json:"type,omitempty"`
	// Namespace roles
	//
	// x-displayName: "Namespace Roles"
	// Directly attached namespace roles for the user
	// This field is deprecated, refer to namespace_access field for the access of the user.
	NamespaceRoles []*schema.NamespaceRoleType `protobuf:"bytes,7,rep,name=namespace_roles,json=namespaceRoles,proto3" json:"namespace_roles,omitempty"` // Deprecated: Do not use.
	// Tenant
	//
	// x-displayName: "Tenant"
	// x-example: "value"
	// tenant will represent id of the tenant that is being accessed
	Tenant string `protobuf:"bytes,8,opt,name=tenant,proto3" json:"tenant,omitempty"`
	// Tenant type
	//
	// x-displayName: "Tenant Type"
	// tenant type of the user (FREEMIUM, ENTERPRISE, ...)
	TenantType schema.TenantType `protobuf:"varint,9,opt,name=tenant_type,json=tenantType,proto3,enum=ves.io.schema.TenantType" json:"tenant_type,omitempty"`
	// Feature flag type
	//
	// x-displayName: "Feature Flag Type"
	// feature flag that shows whether this feature should be enabled on UI for the current plan
	FeatureFlags []*FeatureFlagType `protobuf:"bytes,10,rep,name=feature_flags,json=featureFlags,proto3" json:"feature_flags,omitempty"`
	// tos_current_version
	//
	// x-displayName: "TOS Current Version"
	// x-example: "value"
	// tos current version
	TosCurrentVersion string `protobuf:"bytes,11,opt,name=tos_current_version,json=tosCurrentVersion,proto3" json:"tos_current_version,omitempty"`
	// tos_accepted
	//
	// x-displayName: "TOS Accepted"
	// x-example: "value"
	// tos accepted version
	TosAccepted string `protobuf:"bytes,12,opt,name=tos_accepted,json=tosAccepted,proto3" json:"tos_accepted,omitempty"` // Deprecated: Do not use.
	// IDM type
	//
	// x-displayName: "Identity Management Type"
	// Identity management type of the user (F5XC Managed, SSO)
	IdmType IdmType `protobuf:"varint,13,opt,name=idm_type,json=idmType,proto3,enum=ves.io.schema.user.IdmType" json:"idm_type,omitempty"`
	//  Domain Owner
	//
	// x-displayName: "Domain Owner"
	// x-example: "true"
	// Domain owner is the first user who registered or signed up the associated Tenant.
	// User created via signup flow will have this value set to true.
	// Few restrictions apply to this user w.r.t role update and deletion.
	DomainOwner bool `protobuf:"varint,15,opt,name=domain_owner,json=domainOwner,proto3" json:"domain_owner,omitempty"`
	// Cname
	// x-displayName: "CName"
	// x-example: "web"
	// CName via tenant will be accessed from url. <cname>.<domain>
	Cname string `protobuf:"bytes,16,opt,name=cname,proto3" json:"cname,omitempty"`
	// Billing flags
	// x-displayName: "Billing flags"
	// Collection of flags informing the customer of any billing related problems, such as overdue invoices.
	BillingFlags []*BillingFeatureIndicator `protobuf:"bytes,17,rep,name=billing_flags,json=billingFlags,proto3" json:"billing_flags,omitempty"`
	// Creation Timestamp
	// x-displayName: "Creation Timestamp"
	// User object creation timestamp
	CreationTimestamp *types.Timestamp `protobuf:"bytes,18,opt,name=creation_timestamp,json=creationTimestamp,proto3" json:"creation_timestamp,omitempty"`
	// Company name
	// x-displayName: "Company"
	// x-example: "Acme Ltd."
	// Legal name of the company the user/tenant belongs to
	Company string `protobuf:"bytes,19,opt,name=company,proto3" json:"company,omitempty"`
	// Plan type
	//
	// x-displayName: "Plan Type"
	// plan type the tenant is subscribed to (FREE, INDIVIDUAL, TEAM, ORGANIZATION, ...)
	PlanType schema.PlanType `protobuf:"varint,20,opt,name=plan_type,json=planType,proto3,enum=ves.io.schema.PlanType" json:"plan_type,omitempty"`
	// Active plan transition id
	//
	// x-displayName: "Active plan transition id"
	// UUID of the plan transition request which is currently in progress. This field is empty
	// if there is no such request.
	ActivePlanTransitionUid string `protobuf:"bytes,21,opt,name=active_plan_transition_uid,json=activePlanTransitionUid,proto3" json:"active_plan_transition_uid,omitempty"`
	// Disabled
	//
	// x-displayName: "Disabled"
	// If set to true user is completely disabled including IDM.
	Disabled bool `protobuf:"varint,22,opt,name=disabled,proto3" json:"disabled,omitempty"`
	// Tenant State
	//
	// x-displayName: "Tenant State"
	// Contains information about current state of the tenant.
	TenantState string `protobuf:"bytes,23,opt,name=tenant_state,json=tenantState,proto3" json:"tenant_state,omitempty"`
	// Tenant Flags
	//
	// x-displayName: "Tenant Flags"
	// Contains information about tenant configuration for giving UI instructions to show specific sections.
	TenantFlags map[string]bool `protobuf:"bytes,24,rep,name=tenant_flags,json=tenantFlags,proto3" json:"tenant_flags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// State
	//
	// x-displayName: "State"
	// Contains information about current user state.
	State FSMState `protobuf:"varint,26,opt,name=state,proto3,enum=ves.io.schema.user.FSMState" json:"state,omitempty"`
	// Last login timestamp
	//
	// x-displayName: "Last login timestamp"
	// Last login timestamp when user successfully login to access VoltConsole.
	LastLoginTimestamp *types.Timestamp `protobuf:"bytes,25,opt,name=last_login_timestamp,json=lastLoginTimestamp,proto3" json:"last_login_timestamp,omitempty"`
	// Tile Access
	//
	// x-displayName: "Tile Access"
	// Primary Navigation Tile access based on Plan and Addon service subscription.
	TileAccess map[string]*TileAccess `protobuf:"bytes,28,rep,name=tile_access,json=tileAccess,proto3" json:"tile_access,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Addon Service Status
	//
	// x-displayName: "Addon Service Status"
	// Addon service state and access for the user.
	AddonServiceStatus map[string]*AddonServiceStatus `protobuf:"bytes,29,rep,name=addon_service_status,json=addonServiceStatus,proto3" json:"addon_service_status,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Environment
	//
	// x-displayName: "Environment"
	// current global controller deployment enviroment.
	Environment string `protobuf:"bytes,30,opt,name=environment,proto3" json:"environment,omitempty"`
	// tos_version
	//
	// x-displayName: "TOS Version"
	// x-example: "value"
	// tos accepted version
	TosVersion string `protobuf:"bytes,32,opt,name=tos_version,json=tosVersion,proto3" json:"tos_version,omitempty"`
	// tos_accepted_at
	//
	// x-displayName: "TOS Accepted At"
	// x-example: "2020-04-20T12:32:51.341959216Z"
	// tos accepted timestamp
	TosAcceptedAt *types.Timestamp `protobuf:"bytes,33,opt,name=tos_accepted_at,json=tosAcceptedAt,proto3" json:"tos_accepted_at,omitempty"`
	// Groups
	//
	// x-displayName: "Groups"
	// x-example: "["dev-group-1"]"
	// Group list must be associated to this user.
	GroupNames []string `protobuf:"bytes,34,rep,name=group_names,json=groupNames,proto3" json:"group_names,omitempty"`
	// Original Tenant
	//
	// x-displayName: "Original Tenant"
	// x-example: "tenant1"
	// returns original tenant id that the user belongs if request header exist for original tenant else regular tenant id
	OriginalTenant string `protobuf:"bytes,35,opt,name=original_tenant,json=originalTenant,proto3" json:"original_tenant,omitempty"`
	// Namespace Access
	//
	// x-displayName: "namespace access"
	// Resolved roles for the user within the namespaces.
	// This is the union of the directly attached roles to the user and the roles attached to the groups that the user is associated to.
	NamespaceAccess *schema.NamespaceAccessType `protobuf:"bytes,36,opt,name=namespace_access,json=namespaceAccess,proto3" json:"namespace_access,omitempty"`
	// Sync Mode
	//
	// x-displayName: "Sync Mode"
	// x-example: "self"
	// Denotes if this is an externally managed entity imported into UAM by SCIM protocol, or self managed.
	SyncMode schema.SyncMode `protobuf:"varint,37,opt,name=sync_mode,json=syncMode,proto3,enum=ves.io.schema.SyncMode" json:"sync_mode,omitempty"`
	// User UUId
	//
	// x-displayName: "User UUId"
	// x-example: "0795c420-4c6f-406d-a3c9-502baa4ead3b"
	// User UUId of the currently logged in user
	UserUuid string `protobuf:"bytes,38,opt,name=user_uuid,json=userUuid,proto3" json:"user_uuid,omitempty"`
	// Billing plan name
	//
	// x-displayName: "Billing plan name"
	// x-example: "Teams Plan"
	// Billing plan name of the plan template the tenant is subscribed to (Free plan, Teams Plan, Organization Plan, ...)
	BillingPlanName string `protobuf:"bytes,39,opt,name=billing_plan_name,json=billingPlanName,proto3" json:"billing_plan_name,omitempty"`
	// Managed services access info
	//
	// x-displayName: "Managed services access info"
	// Managed services access info for the tenant. Tenant can be either self managed or managed. If that's the case then you can more info about the managed tenant
	// by inspecting the msp_managed field.
	//
	// Types that are valid to be assigned to ManagedAccessInfo:
	//	*GetUserRoleResponse_SelfManaged
	//	*GetUserRoleResponse_MspManaged
	ManagedAccessInfo isGetUserRoleResponse_ManagedAccessInfo `protobuf_oneof:"managed_access_info"`
	AccessType        AccessType                              `protobuf:"varint,43,opt,name=access_type,json=accessType,proto3,enum=ves.io.schema.user.AccessType" json:"access_type,omitempty"`
	// Signup origin
	//
	// x-displayName: "Signup origin"
	// x-required
	// Platform from which the tenant signup is originated, example f5xc, aws, etc
	SignupOrigin schema.SignupOrigin `protobuf:"varint,44,opt,name=signup_origin,json=signupOrigin,proto3,enum=ves.io.schema.SignupOrigin" json:"signup_origin,omitempty"`
}

func (m *GetUserRoleResponse) Reset()      { *m = GetUserRoleResponse{} }
func (*GetUserRoleResponse) ProtoMessage() {}
func (*GetUserRoleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{11}
}
func (m *GetUserRoleResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUserRoleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUserRoleResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUserRoleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUserRoleResponse.Merge(m, src)
}
func (m *GetUserRoleResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetUserRoleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUserRoleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetUserRoleResponse proto.InternalMessageInfo

type isGetUserRoleResponse_ManagedAccessInfo interface {
	isGetUserRoleResponse_ManagedAccessInfo()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetUserRoleResponse_SelfManaged struct {
	SelfManaged *schema.Empty `protobuf:"bytes,41,opt,name=self_managed,json=selfManaged,proto3,oneof" json:"self_managed,omitempty"`
}
type GetUserRoleResponse_MspManaged struct {
	MspManaged *MSPManaged `protobuf:"bytes,42,opt,name=msp_managed,json=mspManaged,proto3,oneof" json:"msp_managed,omitempty"`
}

func (*GetUserRoleResponse_SelfManaged) isGetUserRoleResponse_ManagedAccessInfo() {}
func (*GetUserRoleResponse_MspManaged) isGetUserRoleResponse_ManagedAccessInfo()  {}

func (m *GetUserRoleResponse) GetManagedAccessInfo() isGetUserRoleResponse_ManagedAccessInfo {
	if m != nil {
		return m.ManagedAccessInfo
	}
	return nil
}

func (m *GetUserRoleResponse) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *GetUserRoleResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetUserRoleResponse) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *GetUserRoleResponse) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *GetUserRoleResponse) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *GetUserRoleResponse) GetType() UserType {
	if m != nil {
		return m.Type
	}
	return USER
}

// Deprecated: Do not use.
func (m *GetUserRoleResponse) GetNamespaceRoles() []*schema.NamespaceRoleType {
	if m != nil {
		return m.NamespaceRoles
	}
	return nil
}

func (m *GetUserRoleResponse) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *GetUserRoleResponse) GetTenantType() schema.TenantType {
	if m != nil {
		return m.TenantType
	}
	return schema.UNKNOWN
}

func (m *GetUserRoleResponse) GetFeatureFlags() []*FeatureFlagType {
	if m != nil {
		return m.FeatureFlags
	}
	return nil
}

func (m *GetUserRoleResponse) GetTosCurrentVersion() string {
	if m != nil {
		return m.TosCurrentVersion
	}
	return ""
}

// Deprecated: Do not use.
func (m *GetUserRoleResponse) GetTosAccepted() string {
	if m != nil {
		return m.TosAccepted
	}
	return ""
}

func (m *GetUserRoleResponse) GetIdmType() IdmType {
	if m != nil {
		return m.IdmType
	}
	return SSO
}

func (m *GetUserRoleResponse) GetDomainOwner() bool {
	if m != nil {
		return m.DomainOwner
	}
	return false
}

func (m *GetUserRoleResponse) GetCname() string {
	if m != nil {
		return m.Cname
	}
	return ""
}

func (m *GetUserRoleResponse) GetBillingFlags() []*BillingFeatureIndicator {
	if m != nil {
		return m.BillingFlags
	}
	return nil
}

func (m *GetUserRoleResponse) GetCreationTimestamp() *types.Timestamp {
	if m != nil {
		return m.CreationTimestamp
	}
	return nil
}

func (m *GetUserRoleResponse) GetCompany() string {
	if m != nil {
		return m.Company
	}
	return ""
}

func (m *GetUserRoleResponse) GetPlanType() schema.PlanType {
	if m != nil {
		return m.PlanType
	}
	return schema.FREE
}

func (m *GetUserRoleResponse) GetActivePlanTransitionUid() string {
	if m != nil {
		return m.ActivePlanTransitionUid
	}
	return ""
}

func (m *GetUserRoleResponse) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

func (m *GetUserRoleResponse) GetTenantState() string {
	if m != nil {
		return m.TenantState
	}
	return ""
}

func (m *GetUserRoleResponse) GetTenantFlags() map[string]bool {
	if m != nil {
		return m.TenantFlags
	}
	return nil
}

func (m *GetUserRoleResponse) GetState() FSMState {
	if m != nil {
		return m.State
	}
	return StateUndefined
}

func (m *GetUserRoleResponse) GetLastLoginTimestamp() *types.Timestamp {
	if m != nil {
		return m.LastLoginTimestamp
	}
	return nil
}

func (m *GetUserRoleResponse) GetTileAccess() map[string]*TileAccess {
	if m != nil {
		return m.TileAccess
	}
	return nil
}

func (m *GetUserRoleResponse) GetAddonServiceStatus() map[string]*AddonServiceStatus {
	if m != nil {
		return m.AddonServiceStatus
	}
	return nil
}

func (m *GetUserRoleResponse) GetEnvironment() string {
	if m != nil {
		return m.Environment
	}
	return ""
}

func (m *GetUserRoleResponse) GetTosVersion() string {
	if m != nil {
		return m.TosVersion
	}
	return ""
}

func (m *GetUserRoleResponse) GetTosAcceptedAt() *types.Timestamp {
	if m != nil {
		return m.TosAcceptedAt
	}
	return nil
}

func (m *GetUserRoleResponse) GetGroupNames() []string {
	if m != nil {
		return m.GroupNames
	}
	return nil
}

func (m *GetUserRoleResponse) GetOriginalTenant() string {
	if m != nil {
		return m.OriginalTenant
	}
	return ""
}

func (m *GetUserRoleResponse) GetNamespaceAccess() *schema.NamespaceAccessType {
	if m != nil {
		return m.NamespaceAccess
	}
	return nil
}

func (m *GetUserRoleResponse) GetSyncMode() schema.SyncMode {
	if m != nil {
		return m.SyncMode
	}
	return schema.SELF
}

func (m *GetUserRoleResponse) GetUserUuid() string {
	if m != nil {
		return m.UserUuid
	}
	return ""
}

func (m *GetUserRoleResponse) GetBillingPlanName() string {
	if m != nil {
		return m.BillingPlanName
	}
	return ""
}

func (m *GetUserRoleResponse) GetSelfManaged() *schema.Empty {
	if x, ok := m.GetManagedAccessInfo().(*GetUserRoleResponse_SelfManaged); ok {
		return x.SelfManaged
	}
	return nil
}

func (m *GetUserRoleResponse) GetMspManaged() *MSPManaged {
	if x, ok := m.GetManagedAccessInfo().(*GetUserRoleResponse_MspManaged); ok {
		return x.MspManaged
	}
	return nil
}

func (m *GetUserRoleResponse) GetAccessType() AccessType {
	if m != nil {
		return m.AccessType
	}
	return UNKNOWN_ACCESS
}

func (m *GetUserRoleResponse) GetSignupOrigin() schema.SignupOrigin {
	if m != nil {
		return m.SignupOrigin
	}
	return schema.ORIGIN_UNKNOWN
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetUserRoleResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetUserRoleResponse_SelfManaged)(nil),
		(*GetUserRoleResponse_MspManaged)(nil),
	}
}

// MSP Managed
//
// MSP information for tenant.
// x-displayName: "MSP Managed"
type MSPManaged struct {
	// tier
	//
	// x-displayName: "Tier"
	// x-example: "1"
	// tier of tenant in MSP tree.
	Tier uint32 `protobuf:"varint,1,opt,name=tier,proto3" json:"tier,omitempty"`
	// msp_id
	//
	// x-displayName: "msp_id"
	// x-example: "value"
	// msp Id for the tenant.
	MspId string `protobuf:"bytes,2,opt,name=msp_id,json=mspId,proto3" json:"msp_id,omitempty"`
	// Parent Tenant ID
	//
	// x-displayName: "Parent Tenant ID"
	// x-example: "volterra-abc"
	// Hold parent tenant id
	ParentTenantId string `protobuf:"bytes,3,opt,name=parent_tenant_id,json=parentTenantId,proto3" json:"parent_tenant_id,omitempty"`
	// MSP Node type
	//
	// x-displayName: "MSP node type"
	// Hold parent tenant id
	NodeType MSPNodeType `protobuf:"varint,4,opt,name=node_type,json=nodeType,proto3,enum=ves.io.schema.user.MSPNodeType" json:"node_type,omitempty"`
}

func (m *MSPManaged) Reset()      { *m = MSPManaged{} }
func (*MSPManaged) ProtoMessage() {}
func (*MSPManaged) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{12}
}
func (m *MSPManaged) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MSPManaged) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MSPManaged.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MSPManaged) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MSPManaged.Merge(m, src)
}
func (m *MSPManaged) XXX_Size() int {
	return m.Size()
}
func (m *MSPManaged) XXX_DiscardUnknown() {
	xxx_messageInfo_MSPManaged.DiscardUnknown(m)
}

var xxx_messageInfo_MSPManaged proto.InternalMessageInfo

func (m *MSPManaged) GetTier() uint32 {
	if m != nil {
		return m.Tier
	}
	return 0
}

func (m *MSPManaged) GetMspId() string {
	if m != nil {
		return m.MspId
	}
	return ""
}

func (m *MSPManaged) GetParentTenantId() string {
	if m != nil {
		return m.ParentTenantId
	}
	return ""
}

func (m *MSPManaged) GetNodeType() MSPNodeType {
	if m != nil {
		return m.NodeType
	}
	return MspNodeTypeUnknown
}

// CascadeDeleteRequest
//
// x-displayName: "Delete the User and Associated Namespace Roles"
// CascadeDeleteRequest is the request to delete the user along with the associated namespace role objects.
// Note: only admin is allowed to delete the user and associated objects.
type CascadeDeleteRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Value of namespace is always "system"
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// email of the user
	//
	// x-displayName: "Email"
	// x-example: "value"
	// x-required
	// email of the user requesting for
	Email string `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
}

func (m *CascadeDeleteRequest) Reset()      { *m = CascadeDeleteRequest{} }
func (*CascadeDeleteRequest) ProtoMessage() {}
func (*CascadeDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{13}
}
func (m *CascadeDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CascadeDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CascadeDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CascadeDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CascadeDeleteRequest.Merge(m, src)
}
func (m *CascadeDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *CascadeDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CascadeDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CascadeDeleteRequest proto.InternalMessageInfo

func (m *CascadeDeleteRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *CascadeDeleteRequest) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

// CascadeDeleteResponse
//
// x-displayName: "Delete Response for the User and Associated Namespace Roles"
// CascadeDeleteResponse contains a list of user objects that were deleted
// and possibly any errors when attempting to delete those objects.
type CascadeDeleteResponse struct {
	// delete_ok
	//
	// x-displayName: "Delete Ok"
	// x-example: "true"
	// status of the deleted objects.
	// "true" value indicates that the operation had been successful for all the objects.
	// "false" value indicates that at least one of the delete operations had been unsuccessful.
	DeleteOk bool `protobuf:"varint,1,opt,name=delete_ok,json=deleteOk,proto3" json:"delete_ok,omitempty"`
	// items
	//
	// x-displayName: "Items"
	// The objects deleted for the specific user
	Items []*CascadeDeleteItemType `protobuf:"bytes,2,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *CascadeDeleteResponse) Reset()      { *m = CascadeDeleteResponse{} }
func (*CascadeDeleteResponse) ProtoMessage() {}
func (*CascadeDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{14}
}
func (m *CascadeDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CascadeDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CascadeDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CascadeDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CascadeDeleteResponse.Merge(m, src)
}
func (m *CascadeDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *CascadeDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CascadeDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CascadeDeleteResponse proto.InternalMessageInfo

func (m *CascadeDeleteResponse) GetDeleteOk() bool {
	if m != nil {
		return m.DeleteOk
	}
	return false
}

func (m *CascadeDeleteResponse) GetItems() []*CascadeDeleteItemType {
	if m != nil {
		return m.Items
	}
	return nil
}

// CascadeDeleteItemType
//
// x-displayName: "Cascade Deletion of User and Associated Namespace Roles"
// CascadeDeleteItemType contains details of object that was handled as part of cascade delete
// of user and whether it was successfully deleted
type CascadeDeleteItemType struct {
	// object's type
	//
	// x-displayName: "Object Type"
	// x-example: "value"
	// The type of the object
	ObjectType string `protobuf:"bytes,1,opt,name=object_type,json=objectType,proto3" json:"object_type,omitempty"`
	// object's uid
	//
	// x-displayName: "Object Uid"
	// x-example: "value"
	// The uid of the object
	ObjectUid string `protobuf:"bytes,2,opt,name=object_uid,json=objectUid,proto3" json:"object_uid,omitempty"`
	// object's name
	//
	// x-displayName: "Object Name"
	// x-example: "value"
	// Name of the object
	ObjectName string `protobuf:"bytes,3,opt,name=object_name,json=objectName,proto3" json:"object_name,omitempty"`
	// error message
	//
	// x-displayName: "Error Message"
	// x-example: "value"
	// informative error message about the success or failure of the object's deletion response
	ErrorMessage string `protobuf:"bytes,4,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *CascadeDeleteItemType) Reset()      { *m = CascadeDeleteItemType{} }
func (*CascadeDeleteItemType) ProtoMessage() {}
func (*CascadeDeleteItemType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{15}
}
func (m *CascadeDeleteItemType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CascadeDeleteItemType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CascadeDeleteItemType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CascadeDeleteItemType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CascadeDeleteItemType.Merge(m, src)
}
func (m *CascadeDeleteItemType) XXX_Size() int {
	return m.Size()
}
func (m *CascadeDeleteItemType) XXX_DiscardUnknown() {
	xxx_messageInfo_CascadeDeleteItemType.DiscardUnknown(m)
}

var xxx_messageInfo_CascadeDeleteItemType proto.InternalMessageInfo

func (m *CascadeDeleteItemType) GetObjectType() string {
	if m != nil {
		return m.ObjectType
	}
	return ""
}

func (m *CascadeDeleteItemType) GetObjectUid() string {
	if m != nil {
		return m.ObjectUid
	}
	return ""
}

func (m *CascadeDeleteItemType) GetObjectName() string {
	if m != nil {
		return m.ObjectName
	}
	return ""
}

func (m *CascadeDeleteItemType) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

// Accept TOS request model
//
// x-displayName: "Accept TOS Request"
// Accept TOS request model
type AcceptTOSRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Value of namespace is always "system".
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// tos_accepted
	//
	// x-displayName: "TOS Accepted"
	// x-example: "value"
	// tos accepted version, this field is deprecated refer the fields `tos_accepted_at` and `tos_version` instead.
	TosAccepted string `protobuf:"bytes,2,opt,name=tos_accepted,json=tosAccepted,proto3" json:"tos_accepted,omitempty"` // Deprecated: Do not use.
	// tos_version
	//
	// x-displayName: "TOS version"
	// x-example: "v1.0"
	// tos accepted version
	TosVersion string `protobuf:"bytes,4,opt,name=tos_version,json=tosVersion,proto3" json:"tos_version,omitempty"`
	// tos_accepted_at
	//
	// x-displayName: "TOS Accepted Timestamp"
	// x-example: "1628490105132"
	// tos accepted timestamp in epoch.
	TosAcceptedAt int64 `protobuf:"varint,5,opt,name=tos_accepted_at,json=tosAcceptedAt,proto3" json:"tos_accepted_at,omitempty"`
}

func (m *AcceptTOSRequest) Reset()      { *m = AcceptTOSRequest{} }
func (*AcceptTOSRequest) ProtoMessage() {}
func (*AcceptTOSRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{16}
}
func (m *AcceptTOSRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptTOSRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptTOSRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptTOSRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptTOSRequest.Merge(m, src)
}
func (m *AcceptTOSRequest) XXX_Size() int {
	return m.Size()
}
func (m *AcceptTOSRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptTOSRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptTOSRequest proto.InternalMessageInfo

func (m *AcceptTOSRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// Deprecated: Do not use.
func (m *AcceptTOSRequest) GetTosAccepted() string {
	if m != nil {
		return m.TosAccepted
	}
	return ""
}

func (m *AcceptTOSRequest) GetTosVersion() string {
	if m != nil {
		return m.TosVersion
	}
	return ""
}

func (m *AcceptTOSRequest) GetTosAcceptedAt() int64 {
	if m != nil {
		return m.TosAcceptedAt
	}
	return 0
}

// Accept TOS response model
//
// x-displayName: "Accept TOS Response"
// Accept TOS response model
type AcceptTOSResponse struct {
}

func (m *AcceptTOSResponse) Reset()      { *m = AcceptTOSResponse{} }
func (*AcceptTOSResponse) ProtoMessage() {}
func (*AcceptTOSResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{17}
}
func (m *AcceptTOSResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptTOSResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptTOSResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptTOSResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptTOSResponse.Merge(m, src)
}
func (m *AcceptTOSResponse) XXX_Size() int {
	return m.Size()
}
func (m *AcceptTOSResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptTOSResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptTOSResponse proto.InternalMessageInfo

// Get TOS request model
//
// x-displayName: "Get TOS Request"
// Get TOS request model
type GetTOSRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Value of namespace is always "system"
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *GetTOSRequest) Reset()      { *m = GetTOSRequest{} }
func (*GetTOSRequest) ProtoMessage() {}
func (*GetTOSRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{18}
}
func (m *GetTOSRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTOSRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTOSRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTOSRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTOSRequest.Merge(m, src)
}
func (m *GetTOSRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTOSRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTOSRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTOSRequest proto.InternalMessageInfo

func (m *GetTOSRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// Get TOS response model
//
// x-displayName: "Get TOS Response"
// Get TOS response model
type GetTOSResponse struct {
	// Version
	//
	// x-displayName: "TOS Version"
	// x-example: "value"
	// Value of TOS version
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// Text
	//
	// x-displayName: "TOS Text"
	// x-example: "value"
	// Value of TOS text
	Text string `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
}

func (m *GetTOSResponse) Reset()      { *m = GetTOSResponse{} }
func (*GetTOSResponse) ProtoMessage() {}
func (*GetTOSResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{19}
}
func (m *GetTOSResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTOSResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTOSResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTOSResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTOSResponse.Merge(m, src)
}
func (m *GetTOSResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTOSResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTOSResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTOSResponse proto.InternalMessageInfo

func (m *GetTOSResponse) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *GetTOSResponse) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

// Empty
//
// x-displayName: "Empty"
// Empty is a message without actual content/body.
type Empty struct {
}

func (m *Empty) Reset()      { *m = Empty{} }
func (*Empty) ProtoMessage() {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{20}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

// FeatureFlagType
// x-displayName: "Feature and its Status for the Tenant's Plan"
type FeatureFlagType struct {
	// feature's name
	//
	// x-displayName: "Feature Name"
	// x-example: "value"
	// Name of the feature
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// disabled
	//
	// x-displayName "Disabled"
	// x-example: "true"
	// status of whether this feature should be disabled for current plan
	Disabled bool `protobuf:"varint,2,opt,name=disabled,proto3" json:"disabled,omitempty"`
}

func (m *FeatureFlagType) Reset()      { *m = FeatureFlagType{} }
func (*FeatureFlagType) ProtoMessage() {}
func (*FeatureFlagType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{21}
}
func (m *FeatureFlagType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeatureFlagType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeatureFlagType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeatureFlagType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeatureFlagType.Merge(m, src)
}
func (m *FeatureFlagType) XXX_Size() int {
	return m.Size()
}
func (m *FeatureFlagType) XXX_DiscardUnknown() {
	xxx_messageInfo_FeatureFlagType.DiscardUnknown(m)
}

var xxx_messageInfo_FeatureFlagType proto.InternalMessageInfo

func (m *FeatureFlagType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FeatureFlagType) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

// User group request
//
// x-displayName: "User group request"
// Used for adding or removing specific user to/from group.
type UserGroupRequest struct {
	// Username
	//
	// x-displayName: "Username"
	// x-example: "test@email.com"
	// Username of the user who should be associated with the group.
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	// Groups
	//
	// x-displayName: "Groups"
	// x-example: "["dev-group-1"]"
	// Group list must be associated to this user.
	GroupNames []string `protobuf:"bytes,3,rep,name=group_names,json=groupNames,proto3" json:"group_names,omitempty"`
}

func (m *UserGroupRequest) Reset()      { *m = UserGroupRequest{} }
func (*UserGroupRequest) ProtoMessage() {}
func (*UserGroupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{22}
}
func (m *UserGroupRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserGroupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserGroupRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserGroupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserGroupRequest.Merge(m, src)
}
func (m *UserGroupRequest) XXX_Size() int {
	return m.Size()
}
func (m *UserGroupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UserGroupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UserGroupRequest proto.InternalMessageInfo

func (m *UserGroupRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *UserGroupRequest) GetGroupNames() []string {
	if m != nil {
		return m.GroupNames
	}
	return nil
}

// User Group Response
//
// x-displayName: "User Group Response"
type UserGroupResponse struct {
	// error
	// x-displayName: "Error"
	// Error(if any)
	Error *schema.ErrorType `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *UserGroupResponse) Reset()      { *m = UserGroupResponse{} }
func (*UserGroupResponse) ProtoMessage() {}
func (*UserGroupResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{23}
}
func (m *UserGroupResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserGroupResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserGroupResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserGroupResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserGroupResponse.Merge(m, src)
}
func (m *UserGroupResponse) XXX_Size() int {
	return m.Size()
}
func (m *UserGroupResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UserGroupResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UserGroupResponse proto.InternalMessageInfo

func (m *UserGroupResponse) GetError() *schema.ErrorType {
	if m != nil {
		return m.Error
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.user.BillingFlag", BillingFlag_name, BillingFlag_value)
	golang_proto.RegisterEnum("ves.io.schema.user.BillingFlag", BillingFlag_name, BillingFlag_value)
	proto.RegisterEnum("ves.io.schema.user.BillingFlagAction", BillingFlagAction_name, BillingFlagAction_value)
	golang_proto.RegisterEnum("ves.io.schema.user.BillingFlagAction", BillingFlagAction_name, BillingFlagAction_value)
	proto.RegisterEnum("ves.io.schema.user.AccessType", AccessType_name, AccessType_value)
	golang_proto.RegisterEnum("ves.io.schema.user.AccessType", AccessType_name, AccessType_value)
	proto.RegisterEnum("ves.io.schema.user.MSPNodeType", MSPNodeType_name, MSPNodeType_value)
	golang_proto.RegisterEnum("ves.io.schema.user.MSPNodeType", MSPNodeType_name, MSPNodeType_value)
	proto.RegisterType((*BillingFeatureIndicator)(nil), "ves.io.schema.user.BillingFeatureIndicator")
	golang_proto.RegisterType((*BillingFeatureIndicator)(nil), "ves.io.schema.user.BillingFeatureIndicator")
	proto.RegisterType((*SendPasswordEmailRequest)(nil), "ves.io.schema.user.SendPasswordEmailRequest")
	golang_proto.RegisterType((*SendPasswordEmailRequest)(nil), "ves.io.schema.user.SendPasswordEmailRequest")
	proto.RegisterType((*SendPasswordEmailResponse)(nil), "ves.io.schema.user.SendPasswordEmailResponse")
	golang_proto.RegisterType((*SendPasswordEmailResponse)(nil), "ves.io.schema.user.SendPasswordEmailResponse")
	proto.RegisterType((*ResetPasswordByAdminRequest)(nil), "ves.io.schema.user.ResetPasswordByAdminRequest")
	golang_proto.RegisterType((*ResetPasswordByAdminRequest)(nil), "ves.io.schema.user.ResetPasswordByAdminRequest")
	proto.RegisterType((*NamespacesRoleType)(nil), "ves.io.schema.user.NamespacesRoleType")
	golang_proto.RegisterType((*NamespacesRoleType)(nil), "ves.io.schema.user.NamespacesRoleType")
	proto.RegisterType((*UserRoleRequest)(nil), "ves.io.schema.user.UserRoleRequest")
	golang_proto.RegisterType((*UserRoleRequest)(nil), "ves.io.schema.user.UserRoleRequest")
	proto.RegisterType((*ListUserRoleRequest)(nil), "ves.io.schema.user.ListUserRoleRequest")
	golang_proto.RegisterType((*ListUserRoleRequest)(nil), "ves.io.schema.user.ListUserRoleRequest")
	proto.RegisterType((*AssignRoleRequest)(nil), "ves.io.schema.user.AssignRoleRequest")
	golang_proto.RegisterType((*AssignRoleRequest)(nil), "ves.io.schema.user.AssignRoleRequest")
	proto.RegisterType((*ListUserRoleResponse)(nil), "ves.io.schema.user.ListUserRoleResponse")
	golang_proto.RegisterType((*ListUserRoleResponse)(nil), "ves.io.schema.user.ListUserRoleResponse")
	proto.RegisterType((*ListUserRoleResponseItem)(nil), "ves.io.schema.user.ListUserRoleResponseItem")
	golang_proto.RegisterType((*ListUserRoleResponseItem)(nil), "ves.io.schema.user.ListUserRoleResponseItem")
	proto.RegisterType((*GetUserRoleRequest)(nil), "ves.io.schema.user.GetUserRoleRequest")
	golang_proto.RegisterType((*GetUserRoleRequest)(nil), "ves.io.schema.user.GetUserRoleRequest")
	proto.RegisterType((*GetUserRoleResponse)(nil), "ves.io.schema.user.GetUserRoleResponse")
	golang_proto.RegisterType((*GetUserRoleResponse)(nil), "ves.io.schema.user.GetUserRoleResponse")
	proto.RegisterMapType((map[string]*AddonServiceStatus)(nil), "ves.io.schema.user.GetUserRoleResponse.AddonServiceStatusEntry")
	golang_proto.RegisterMapType((map[string]*AddonServiceStatus)(nil), "ves.io.schema.user.GetUserRoleResponse.AddonServiceStatusEntry")
	proto.RegisterMapType((map[string]bool)(nil), "ves.io.schema.user.GetUserRoleResponse.TenantFlagsEntry")
	golang_proto.RegisterMapType((map[string]bool)(nil), "ves.io.schema.user.GetUserRoleResponse.TenantFlagsEntry")
	proto.RegisterMapType((map[string]*TileAccess)(nil), "ves.io.schema.user.GetUserRoleResponse.TileAccessEntry")
	golang_proto.RegisterMapType((map[string]*TileAccess)(nil), "ves.io.schema.user.GetUserRoleResponse.TileAccessEntry")
	proto.RegisterType((*MSPManaged)(nil), "ves.io.schema.user.MSPManaged")
	golang_proto.RegisterType((*MSPManaged)(nil), "ves.io.schema.user.MSPManaged")
	proto.RegisterType((*CascadeDeleteRequest)(nil), "ves.io.schema.user.CascadeDeleteRequest")
	golang_proto.RegisterType((*CascadeDeleteRequest)(nil), "ves.io.schema.user.CascadeDeleteRequest")
	proto.RegisterType((*CascadeDeleteResponse)(nil), "ves.io.schema.user.CascadeDeleteResponse")
	golang_proto.RegisterType((*CascadeDeleteResponse)(nil), "ves.io.schema.user.CascadeDeleteResponse")
	proto.RegisterType((*CascadeDeleteItemType)(nil), "ves.io.schema.user.CascadeDeleteItemType")
	golang_proto.RegisterType((*CascadeDeleteItemType)(nil), "ves.io.schema.user.CascadeDeleteItemType")
	proto.RegisterType((*AcceptTOSRequest)(nil), "ves.io.schema.user.AcceptTOSRequest")
	golang_proto.RegisterType((*AcceptTOSRequest)(nil), "ves.io.schema.user.AcceptTOSRequest")
	proto.RegisterType((*AcceptTOSResponse)(nil), "ves.io.schema.user.AcceptTOSResponse")
	golang_proto.RegisterType((*AcceptTOSResponse)(nil), "ves.io.schema.user.AcceptTOSResponse")
	proto.RegisterType((*GetTOSRequest)(nil), "ves.io.schema.user.GetTOSRequest")
	golang_proto.RegisterType((*GetTOSRequest)(nil), "ves.io.schema.user.GetTOSRequest")
	proto.RegisterType((*GetTOSResponse)(nil), "ves.io.schema.user.GetTOSResponse")
	golang_proto.RegisterType((*GetTOSResponse)(nil), "ves.io.schema.user.GetTOSResponse")
	proto.RegisterType((*Empty)(nil), "ves.io.schema.user.Empty")
	golang_proto.RegisterType((*Empty)(nil), "ves.io.schema.user.Empty")
	proto.RegisterType((*FeatureFlagType)(nil), "ves.io.schema.user.FeatureFlagType")
	golang_proto.RegisterType((*FeatureFlagType)(nil), "ves.io.schema.user.FeatureFlagType")
	proto.RegisterType((*UserGroupRequest)(nil), "ves.io.schema.user.UserGroupRequest")
	golang_proto.RegisterType((*UserGroupRequest)(nil), "ves.io.schema.user.UserGroupRequest")
	proto.RegisterType((*UserGroupResponse)(nil), "ves.io.schema.user.UserGroupResponse")
	golang_proto.RegisterType((*UserGroupResponse)(nil), "ves.io.schema.user.UserGroupResponse")
}

func init() {
	proto.RegisterFile("ves.io/schema/user/public_customapi.proto", fileDescriptor_5ce53d51230acf0d)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/user/public_customapi.proto", fileDescriptor_5ce53d51230acf0d)
}

var fileDescriptor_5ce53d51230acf0d = []byte{
	// 3186 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x3a, 0xcf, 0x6f, 0x1b, 0x47,
	0x77, 0x5a, 0x92, 0x92, 0xc8, 0x47, 0xfd, 0xa0, 0x46, 0xb2, 0xbd, 0xa6, 0x6c, 0x5a, 0x5e, 0xc7,
	0xb6, 0x24, 0x9b, 0xa2, 0x2b, 0x27, 0x5f, 0x12, 0x7f, 0x69, 0x5c, 0x8a, 0xa4, 0x2d, 0xba, 0x12,
	0x29, 0x2c, 0x29, 0x27, 0x9f, 0x8d, 0x74, 0xb1, 0xe2, 0x8e, 0xe8, 0xad, 0xb9, 0xbb, 0xfc, 0x76,
	0x96, 0x72, 0x94, 0x22, 0x40, 0x11, 0xf4, 0x0f, 0x28, 0x50, 0xf4, 0xd0, 0x43, 0x9b, 0x4b, 0x51,
	0xf4, 0x1f, 0x28, 0x50, 0xd4, 0x87, 0xfa, 0x12, 0x38, 0xe8, 0xa1, 0x70, 0xdb, 0x4b, 0x7a, 0x28,
	0x50, 0xcb, 0x45, 0x91, 0x34, 0x28, 0x90, 0x5b, 0x2f, 0x3d, 0x14, 0x33, 0xb3, 0x4b, 0x2e, 0x57,
	0x4b, 0x89, 0x96, 0xdd, 0x14, 0xbd, 0xcd, 0xbc, 0x79, 0xf3, 0xe6, 0xfd, 0x7e, 0x6f, 0x66, 0x17,
	0x96, 0xf6, 0x30, 0x59, 0xd1, 0xad, 0x1c, 0x69, 0x3c, 0xc2, 0x86, 0x9a, 0xeb, 0x10, 0x6c, 0xe7,
	0xda, 0x9d, 0x9d, 0x96, 0xde, 0x50, 0x1a, 0x1d, 0xe2, 0x58, 0x86, 0xda, 0xd6, 0x57, 0xda, 0xb6,
	0xe5, 0x58, 0x08, 0x71, 0xd4, 0x15, 0x8e, 0xba, 0x42, 0x51, 0xd3, 0xd9, 0xa6, 0xee, 0x3c, 0xea,
	0xec, 0xac, 0x34, 0x2c, 0x23, 0xd7, 0xb4, 0x9a, 0x56, 0x8e, 0xa1, 0xee, 0x74, 0x76, 0xd9, 0x8c,
	0x4d, 0xd8, 0x88, 0x93, 0x48, 0x9f, 0x6b, 0x5a, 0x56, 0xb3, 0x85, 0x73, 0x6a, 0x5b, 0xcf, 0xa9,
	0xa6, 0x69, 0x39, 0xaa, 0xa3, 0x5b, 0x26, 0x71, 0x57, 0x2f, 0xb8, 0xab, 0x5d, 0x1a, 0x8e, 0x6e,
	0x60, 0xe2, 0xa8, 0x46, 0xdb, 0x45, 0x48, 0xf7, 0x33, 0x8b, 0x6d, 0xdb, 0xb2, 0xbd, 0xcd, 0xf3,
	0xfd, 0x6b, 0x56, 0xdb, 0x4f, 0xf9, 0x6c, 0xff, 0xa2, 0xb3, 0xdf, 0xc6, 0xdd, 0x43, 0x43, 0x14,
	0x60, 0xed, 0xfc, 0x2e, 0x6e, 0x38, 0x2e, 0x42, 0x26, 0x04, 0xc1, 0x4f, 0xe0, 0x5c, 0xff, 0xfa,
	0x9e, 0xda, 0xd2, 0x35, 0xd5, 0xc1, 0xee, 0xaa, 0x14, 0x58, 0xc5, 0x04, 0x9b, 0x7b, 0x01, 0xee,
	0x16, 0x02, 0x38, 0x3a, 0x7e, 0xa2, 0xf4, 0x61, 0x48, 0xff, 0x22, 0xc0, 0x99, 0x35, 0xbd, 0xd5,
	0xd2, 0xcd, 0xe6, 0x1d, 0xac, 0x3a, 0x1d, 0x1b, 0x97, 0x4d, 0x4d, 0x6f, 0xa8, 0x8e, 0x65, 0xa3,
	0x35, 0x98, 0xd8, 0xe1, 0x4b, 0xca, 0x6e, 0x4b, 0x6d, 0x8a, 0xc2, 0x82, 0xb0, 0x38, 0xb5, 0x7a,
	0x61, 0xe5, 0xb0, 0xb5, 0x56, 0x3c, 0x12, 0x2d, 0xb5, 0x29, 0x27, 0x77, 0x7a, 0x13, 0x74, 0x1a,
	0xc6, 0x76, 0x55, 0xbd, 0x85, 0x35, 0x31, 0xb2, 0x20, 0x2c, 0xc6, 0x65, 0x77, 0x86, 0xae, 0xc2,
	0xb4, 0xaa, 0x69, 0x3a, 0x65, 0x45, 0x6d, 0x29, 0xba, 0xb9, 0x6b, 0x89, 0xd1, 0x05, 0x61, 0x31,
	0x21, 0x4f, 0xf5, 0xc0, 0x65, 0x73, 0xd7, 0x42, 0xbf, 0x09, 0x63, 0x6a, 0x83, 0xce, 0xc5, 0x18,
	0x3b, 0xfe, 0xf2, 0x31, 0xc7, 0xe7, 0x19, 0xb2, 0xec, 0x6e, 0x92, 0x2a, 0x20, 0xd6, 0xb0, 0xa9,
	0x6d, 0xa9, 0x84, 0x3c, 0xb1, 0x6c, 0xad, 0x64, 0xa8, 0x7a, 0x4b, 0xc6, 0xbf, 0xee, 0x60, 0xe2,
	0xa0, 0x73, 0x90, 0x30, 0x55, 0x03, 0x93, 0xb6, 0xda, 0xc0, 0x8c, 0xbd, 0x84, 0xdc, 0x03, 0xa0,
	0x39, 0x18, 0xc5, 0x14, 0xdb, 0xe5, 0x8b, 0x4f, 0xa4, 0x79, 0x38, 0x1b, 0x42, 0x8f, 0xb4, 0x2d,
	0x93, 0x60, 0xe9, 0x26, 0xcc, 0xcb, 0x98, 0x60, 0xc7, 0x5b, 0x5d, 0xdb, 0xcf, 0x6b, 0x86, 0x6e,
	0x7a, 0xe7, 0x75, 0x29, 0x0a, 0x7e, 0x8a, 0xeb, 0x80, 0x2a, 0xde, 0xa1, 0x44, 0xb6, 0x5a, 0xb8,
	0xbe, 0xdf, 0xc6, 0x28, 0x03, 0xd0, 0x65, 0x85, 0x88, 0xc2, 0x42, 0x74, 0x31, 0x21, 0xfb, 0x20,
	0x08, 0x41, 0xcc, 0xb6, 0x5a, 0x1e, 0xdb, 0x6c, 0x2c, 0xfd, 0x18, 0x81, 0xe9, 0x6d, 0x82, 0x6d,
	0x4a, 0x24, 0x54, 0x46, 0x21, 0x28, 0x23, 0x82, 0x18, 0x9d, 0x78, 0x54, 0xe8, 0x18, 0x9d, 0x07,
	0xd8, 0xd5, 0x6d, 0xe2, 0x28, 0x6c, 0x85, 0x0b, 0x9f, 0x60, 0x10, 0xca, 0x26, 0x9a, 0x87, 0x44,
	0x4b, 0xf5, 0x56, 0x63, 0x6c, 0x35, 0x4e, 0x01, 0x6c, 0xb1, 0x2b, 0xe1, 0xa8, 0x4f, 0x42, 0x74,
	0x03, 0x62, 0xd4, 0xad, 0xc5, 0x31, 0x66, 0xc0, 0x73, 0x61, 0x06, 0xa4, 0x6c, 0x53, 0xb9, 0x65,
	0x86, 0x89, 0xca, 0x30, 0xdd, 0x65, 0x52, 0xa1, 0xb2, 0x11, 0x71, 0x7c, 0x21, 0xba, 0x98, 0x5c,
	0x5d, 0x08, 0x6c, 0xee, 0x6a, 0xce, 0x53, 0x9c, 0x3c, 0x65, 0xfa, 0x41, 0x04, 0xfd, 0x02, 0xe2,
	0xba, 0x66, 0x28, 0x8c, 0x81, 0x38, 0x63, 0x60, 0x3e, 0x8c, 0x81, 0xb2, 0x66, 0xb0, 0xed, 0xe3,
	0x3a, 0x1f, 0xa0, 0x0b, 0x90, 0x6c, 0xda, 0x56, 0xa7, 0xcd, 0x04, 0x25, 0x62, 0x82, 0x5b, 0x80,
	0x81, 0xd8, 0xa1, 0xd2, 0x4d, 0x98, 0xdd, 0xd0, 0x89, 0xf3, 0x5a, 0x0a, 0x97, 0xfe, 0x4c, 0x80,
	0x99, 0x3c, 0x21, 0x7a, 0xd3, 0x1c, 0xde, 0x48, 0x55, 0x9f, 0x32, 0x88, 0xd2, 0xb5, 0x7a, 0x72,
	0xf5, 0x4a, 0x98, 0x20, 0x87, 0x7d, 0xc9, 0xa7, 0x12, 0x06, 0x43, 0x69, 0x88, 0x53, 0x54, 0xd7,
	0xbe, 0x54, 0xae, 0xee, 0x5c, 0x7a, 0x00, 0x73, 0xfd, 0x52, 0x71, 0xd7, 0x46, 0x6b, 0x30, 0xaa,
	0x3b, 0xd8, 0xe0, 0xae, 0x98, 0x5c, 0xbd, 0x1e, 0x76, 0x74, 0xd8, 0xc6, 0xb2, 0x83, 0x0d, 0x99,
	0x6f, 0x95, 0xfe, 0x6b, 0x14, 0xc4, 0x41, 0x38, 0x27, 0x70, 0xd4, 0xd0, 0x00, 0x0d, 0xb8, 0x6f,
	0xec, 0x48, 0xf7, 0x1d, 0x0d, 0xb8, 0xef, 0xff, 0xa9, 0xa3, 0x9e, 0x86, 0x31, 0x07, 0x9b, 0xaa,
	0xe9, 0x30, 0x37, 0x4d, 0xc8, 0xee, 0x0c, 0xdd, 0x82, 0x24, 0x1f, 0x71, 0x1f, 0x4e, 0x30, 0xde,
	0xce, 0x06, 0xc8, 0xd7, 0x19, 0x06, 0xa3, 0x0b, 0x4e, 0x77, 0xdc, 0xe7, 0xfc, 0xf0, 0x1a, 0xce,
	0x7f, 0x11, 0x26, 0x34, 0xcb, 0x50, 0x75, 0x53, 0xb1, 0x9e, 0x98, 0xd8, 0x16, 0x93, 0x2c, 0x77,
	0x27, 0x39, 0xac, 0x4a, 0x41, 0x34, 0x3e, 0x2c, 0xa7, 0xad, 0x60, 0x53, 0xdd, 0xa1, 0xd9, 0x7d,
	0x82, 0x61, 0x80, 0xe5, 0xb4, 0x4b, 0x1c, 0x42, 0xbd, 0x4c, 0xd3, 0x09, 0x5f, 0x9d, 0x64, 0xab,
	0xdd, 0x39, 0x2a, 0x03, 0x6a, 0xd8, 0x98, 0x95, 0x68, 0xa5, 0x5b, 0x8a, 0xc5, 0x29, 0xe6, 0xd5,
	0xe9, 0x15, 0x5e, 0xac, 0x57, 0xbc, 0x62, 0xbd, 0x52, 0xf7, 0x30, 0xe4, 0x19, 0x6f, 0x57, 0x17,
	0x84, 0x36, 0x60, 0x8e, 0x19, 0xb4, 0x65, 0x35, 0x75, 0x3f, 0xb1, 0xe9, 0x63, 0x89, 0x21, 0xba,
	0x6f, 0x83, 0x6e, 0xeb, 0x51, 0x0b, 0x44, 0x7d, 0x2a, 0x18, 0xf5, 0xe8, 0x5d, 0x48, 0x90, 0x7d,
	0xb3, 0xa1, 0x18, 0x96, 0x86, 0xc5, 0x19, 0xa6, 0xd2, 0x33, 0x01, 0x95, 0xd6, 0xf6, 0xcd, 0xc6,
	0xa6, 0xa5, 0x61, 0x39, 0x4e, 0xdc, 0x91, 0xb4, 0x0a, 0xe8, 0x2e, 0x7e, 0xcd, 0x54, 0xf1, 0xdf,
	0x08, 0x66, 0xfb, 0x36, 0xb9, 0x91, 0xf8, 0xff, 0x33, 0x50, 0x36, 0x4f, 0x1c, 0x28, 0x6b, 0x11,
	0x51, 0xf8, 0x59, 0x82, 0x65, 0x1d, 0x26, 0x77, 0x79, 0x0b, 0xc4, 0xda, 0x1d, 0x22, 0x02, 0x63,
	0xf0, 0x52, 0x98, 0x74, 0x6e, 0xaf, 0x44, 0x1b, 0x0e, 0x46, 0x67, 0x62, 0xb7, 0x07, 0x20, 0x68,
	0x05, 0x66, 0x1d, 0x8b, 0x28, 0x8d, 0x8e, 0x6d, 0x63, 0xd3, 0x51, 0xf6, 0xb0, 0x4d, 0x68, 0x03,
	0x93, 0x64, 0xac, 0xce, 0x38, 0x16, 0x29, 0xf0, 0x95, 0xfb, 0x7c, 0x01, 0x5d, 0x86, 0x09, 0x8a,
	0xaf, 0x36, 0x1a, 0xb8, 0xed, 0xb8, 0xc1, 0x94, 0x60, 0x72, 0x27, 0x1d, 0x8b, 0xe4, 0x5d, 0x70,
	0x5f, 0x34, 0x4f, 0xbe, 0x41, 0x34, 0x4f, 0x1f, 0x8e, 0xe6, 0x39, 0x18, 0x6d, 0x30, 0x4b, 0xa7,
	0xb8, 0x8b, 0xb0, 0x09, 0xda, 0x82, 0x49, 0x7f, 0x03, 0x48, 0xc4, 0x19, 0xa6, 0x91, 0x6b, 0x47,
	0xb5, 0x60, 0x81, 0x26, 0x52, 0x9e, 0xf0, 0x75, 0x83, 0x64, 0x40, 0xe0, 0xa3, 0x93, 0x04, 0xbe,
	0x08, 0xe3, 0x0d, 0xcb, 0x68, 0xab, 0xe6, 0xbe, 0x38, 0xcb, 0x98, 0xf6, 0xa6, 0x34, 0x46, 0xdb,
	0x2d, 0xd5, 0xe4, 0x8a, 0x9a, 0x0b, 0x8d, 0xd1, 0xad, 0x96, 0x6a, 0x32, 0x25, 0xc5, 0xdb, 0xee,
	0x08, 0xfd, 0x12, 0xd2, 0xb4, 0x67, 0xdc, 0xc3, 0x0a, 0xdf, 0x6c, 0xab, 0x26, 0x61, 0x8d, 0xa8,
	0xd2, 0xd1, 0x35, 0xf1, 0x14, 0x3b, 0xe2, 0x0c, 0xc7, 0x60, 0xbb, 0xbb, 0xeb, 0xdb, 0x7a, 0x7f,
	0xb2, 0x3b, 0x1d, 0x48, 0x76, 0x17, 0x61, 0xc2, 0xf5, 0x49, 0xe2, 0xa8, 0x0e, 0x16, 0xcf, 0x30,
	0x52, 0xae, 0x9f, 0xd6, 0x28, 0x08, 0x3d, 0xec, 0xa2, 0x70, 0x3d, 0x8b, 0x4c, 0xcf, 0x1f, 0x84,
	0xe9, 0x39, 0x24, 0x25, 0xb8, 0x0e, 0xcd, 0x34, 0x5c, 0x32, 0x1d, 0x7b, 0xdf, 0x23, 0xce, 0x75,
	0xbe, 0x0a, 0xa3, 0xfc, 0xe0, 0xf4, 0xe0, 0x68, 0xbd, 0x53, 0xdb, 0x64, 0x9c, 0xc8, 0x1c, 0x75,
	0x60, 0x56, 0x3d, 0x7b, 0xa2, 0xac, 0xfa, 0x29, 0x24, 0x1d, 0xbd, 0x85, 0x99, 0x83, 0x13, 0x22,
	0x9e, 0x63, 0xd2, 0xbd, 0x3f, 0xb4, 0x74, 0x7a, 0x0b, 0xe7, 0xd9, 0x4e, 0x2e, 0x1c, 0x38, 0x5d,
	0x00, 0xfa, 0x35, 0xcc, 0xa9, 0x9a, 0x66, 0x99, 0x0a, 0xc1, 0xf6, 0x9e, 0xde, 0xc0, 0x4c, 0xc5,
	0x1d, 0x22, 0x9e, 0x67, 0x47, 0xdc, 0x1e, 0xf6, 0x88, 0x3c, 0xa5, 0x51, 0xe3, 0x24, 0x6a, 0x8c,
	0x02, 0x3f, 0x0a, 0xa9, 0x87, 0x16, 0xd0, 0x02, 0x24, 0xb1, 0xb9, 0xa7, 0xdb, 0x96, 0x69, 0x60,
	0xd3, 0x11, 0x33, 0xdc, 0x9a, 0x3e, 0x10, 0x2d, 0x22, 0x34, 0x9c, 0xbd, 0xb0, 0x5f, 0x60, 0x18,
	0xe0, 0x58, 0xc4, 0x8b, 0xf7, 0x35, 0x98, 0xf6, 0xc7, 0xbb, 0xa2, 0x3a, 0xe2, 0xc5, 0x63, 0x15,
	0x3b, 0xe9, 0x4b, 0x05, 0x79, 0x27, 0x58, 0xa9, 0xa4, 0x43, 0x95, 0xea, 0x2a, 0x4c, 0x5b, 0xb6,
	0xde, 0xd4, 0xe9, 0xfd, 0xca, 0xcd, 0x95, 0x97, 0xf8, 0x0d, 0xcb, 0x03, 0x73, 0xb7, 0x41, 0x9b,
	0x90, 0xea, 0xa5, 0x66, 0xd7, 0x44, 0xef, 0x30, 0x76, 0xa4, 0x41, 0xb9, 0x99, 0x6b, 0x9f, 0x05,
	0x50, 0x2f, 0xad, 0xbb, 0x26, 0xe9, 0xab, 0x90, 0x97, 0x87, 0xac, 0x90, 0xb4, 0xdc, 0x50, 0xeb,
	0x28, 0x1d, 0x1a, 0x6c, 0x57, 0x78, 0xb9, 0xa1, 0x80, 0xed, 0x8e, 0xae, 0xa1, 0x65, 0x98, 0xf1,
	0xf2, 0x10, 0x8b, 0x4d, 0x96, 0xa9, 0xae, 0x32, 0xa4, 0x69, 0x77, 0x81, 0x86, 0x24, 0x2b, 0x4d,
	0x1f, 0xc2, 0x04, 0xc1, 0xad, 0x5d, 0xc5, 0x50, 0x4d, 0xb5, 0x89, 0x35, 0x71, 0x89, 0x49, 0x32,
	0x17, 0xe0, 0xa0, 0x64, 0xb4, 0x9d, 0xfd, 0xf5, 0x11, 0x39, 0x49, 0x71, 0x37, 0x39, 0x2a, 0xca,
	0x43, 0xd2, 0x20, 0xed, 0xee, 0xce, 0x65, 0xb6, 0x33, 0x13, 0xe6, 0x43, 0x9b, 0xb5, 0x2d, 0x77,
	0xd3, 0xfa, 0x88, 0x0c, 0x06, 0x69, 0x7b, 0x24, 0x6e, 0x43, 0x92, 0x6b, 0x90, 0x27, 0x9f, 0x6b,
	0x4c, 0xfc, 0x50, 0x12, 0x3e, 0x15, 0x82, 0xda, 0x1d, 0xa3, 0xdf, 0x82, 0x49, 0x7a, 0x3b, 0xe8,
	0xb4, 0x15, 0x6e, 0x25, 0xf1, 0x7a, 0x68, 0xa2, 0xaf, 0x31, 0x9c, 0x2a, 0x43, 0x91, 0x27, 0x88,
	0x6f, 0x96, 0xfe, 0x18, 0x52, 0xc1, 0x7c, 0x80, 0x52, 0x10, 0x7d, 0x8c, 0xf7, 0xdd, 0x6e, 0x81,
	0x0e, 0x69, 0xc2, 0xdf, 0x53, 0x5b, 0x1d, 0xec, 0x5e, 0xcb, 0xf9, 0xe4, 0x56, 0xe4, 0x03, 0x21,
	0xfd, 0x19, 0x4c, 0x07, 0x22, 0x2e, 0x64, 0xfb, 0xbb, 0xfe, 0xed, 0x03, 0x94, 0xd4, 0xa3, 0xe2,
	0x27, 0x6f, 0xc0, 0x99, 0x01, 0xd1, 0x16, 0x72, 0xcc, 0x47, 0xfd, 0xc7, 0x84, 0x5e, 0x78, 0x0e,
	0x53, 0xf3, 0x1d, 0xb7, 0x76, 0x01, 0x66, 0x5d, 0x7b, 0xba, 0xae, 0xcd, 0xde, 0x1a, 0x50, 0xfc,
	0xd9, 0x53, 0x61, 0xe9, 0xc5, 0x53, 0x61, 0xf1, 0x5e, 0x2c, 0x3e, 0x95, 0x9a, 0xbe, 0x17, 0x8b,
	0xcf, 0xa7, 0xce, 0xdd, 0x8b, 0xc5, 0x2f, 0xa4, 0x16, 0xee, 0xc5, 0xe2, 0x8b, 0xa9, 0x25, 0xe9,
	0x6b, 0x01, 0xa0, 0x67, 0x66, 0xda, 0x57, 0x39, 0x3a, 0xb6, 0x19, 0x73, 0x93, 0x32, 0x1b, 0xa3,
	0x53, 0x30, 0x46, 0xfd, 0x45, 0xd7, 0xdc, 0x6e, 0x6b, 0xd4, 0x20, 0xed, 0xb2, 0x86, 0x16, 0x21,
	0xd5, 0x56, 0x59, 0xe1, 0x77, 0x73, 0xba, 0xae, 0x79, 0x6f, 0x1b, 0x1c, 0xce, 0xcd, 0x53, 0xd6,
	0xd0, 0x47, 0x90, 0x30, 0x2d, 0x0d, 0x73, 0x5f, 0x89, 0x0d, 0x7e, 0x5d, 0xd9, 0xac, 0x6d, 0x55,
	0x2c, 0x8d, 0x5f, 0x1b, 0xe2, 0xa6, 0x3b, 0x92, 0xee, 0xc1, 0x5c, 0x41, 0x25, 0x0d, 0x55, 0xc3,
	0x45, 0xdc, 0xc2, 0xce, 0x90, 0xb7, 0xc9, 0x6e, 0x33, 0x18, 0xf1, 0x3f, 0x42, 0x74, 0xe0, 0x54,
	0x80, 0x96, 0xdb, 0x6d, 0xce, 0x43, 0x42, 0x63, 0x10, 0xc5, 0x7a, 0xcc, 0x88, 0xd1, 0xca, 0xc6,
	0x00, 0xd5, 0xc7, 0xe8, 0xb6, 0x77, 0x29, 0x8c, 0xb0, 0x74, 0xbb, 0x14, 0xc6, 0x7b, 0x1f, 0x59,
	0x7a, 0xd3, 0x63, 0x52, 0xb8, 0x37, 0xc2, 0x3f, 0x15, 0x02, 0xe7, 0x7a, 0x08, 0xec, 0x7a, 0xc1,
	0xde, 0xca, 0xb8, 0x72, 0xb8, 0x18, 0xc0, 0x41, 0x0c, 0xe1, 0x3c, 0xb8, 0x33, 0x56, 0x9e, 0xdd,
	0xd7, 0x1b, 0x0e, 0xa1, 0x05, 0xb9, 0xb7, 0xdf, 0xf7, 0x8c, 0xe1, 0xee, 0x60, 0x79, 0xe2, 0x12,
	0x4c, 0xb2, 0x57, 0x3e, 0xc5, 0xc0, 0x84, 0xa8, 0x4d, 0xaf, 0x03, 0x9e, 0x60, 0xc0, 0x4d, 0x0e,
	0x93, 0xfe, 0x42, 0x80, 0x14, 0xcf, 0xb9, 0xf5, 0x6a, 0x6d, 0x38, 0xfd, 0x06, 0x7b, 0xb9, 0x48,
	0x78, 0x2f, 0x17, 0xa8, 0x11, 0xb1, 0x43, 0x35, 0xe2, 0xca, 0xe1, 0x1a, 0x41, 0xbb, 0xf0, 0x68,
	0xa0, 0x0e, 0xdc, 0x8b, 0xc5, 0xa3, 0xa9, 0x98, 0x34, 0x0b, 0x33, 0x3e, 0x3e, 0xdd, 0xe7, 0xa8,
	0x2c, 0x4c, 0xde, 0xc5, 0x43, 0x73, 0x2e, 0x7d, 0x0c, 0x53, 0x1e, 0xba, 0x6b, 0x7c, 0x11, 0xc6,
	0x3d, 0x06, 0x39, 0xb6, 0x37, 0x65, 0xe1, 0x80, 0x3f, 0x77, 0xbc, 0x6b, 0x06, 0x1d, 0x4b, 0xe3,
	0x30, 0xca, 0xd2, 0xaa, 0x94, 0x87, 0xe9, 0x40, 0x7f, 0xdc, 0xbd, 0x96, 0x08, 0xbe, 0x6b, 0x89,
	0xbf, 0x67, 0x8a, 0xf4, 0xf7, 0x4c, 0x52, 0x03, 0x52, 0xb4, 0x48, 0xdf, 0xa5, 0xe5, 0xcc, 0xe3,
	0x7e, 0xd1, 0xf7, 0x6c, 0xc1, 0xe8, 0xac, 0x4d, 0xfc, 0xcd, 0x0f, 0xcf, 0xa2, 0xe3, 0x36, 0xd5,
	0xcb, 0xb3, 0x48, 0xef, 0x11, 0x23, 0x58, 0x1b, 0xa3, 0xc1, 0xda, 0x78, 0x2f, 0x16, 0x8f, 0xa4,
	0xa2, 0x52, 0x01, 0x66, 0x7c, 0x87, 0xb8, 0x32, 0xaf, 0xc0, 0x28, 0x73, 0x01, 0x76, 0x44, 0x72,
	0x55, 0x0c, 0x16, 0x0e, 0xba, 0xc6, 0x5d, 0x98, 0xa1, 0x2d, 0xff, 0x79, 0x0c, 0x92, 0xbe, 0xe7,
	0x47, 0x24, 0xc2, 0xdc, 0xfd, 0xfc, 0x46, 0xb9, 0xa8, 0x6c, 0xe5, 0x7f, 0xb5, 0x59, 0xaa, 0xd4,
	0x95, 0xcd, 0x52, 0x7d, 0xbd, 0x5a, 0x4c, 0x8d, 0xa0, 0x59, 0x98, 0xae, 0xde, 0x2f, 0xc9, 0xc5,
	0xed, 0x92, 0x52, 0xae, 0xdc, 0xaf, 0x96, 0x0b, 0xa5, 0x94, 0x80, 0xe6, 0xe1, 0xcc, 0x46, 0xbe,
	0x56, 0x57, 0xea, 0x72, 0xbe, 0x52, 0xcb, 0x17, 0xea, 0xe5, 0x6a, 0x45, 0xa9, 0xd5, 0xf3, 0xf5,
	0xed, 0x5a, 0x2a, 0x82, 0xd2, 0x70, 0xba, 0x9f, 0x8a, 0x52, 0xfa, 0x74, 0xab, 0x2c, 0x97, 0x8a,
	0xa9, 0x28, 0xba, 0x0c, 0x17, 0x03, 0x6b, 0xe5, 0x4a, 0x6d, 0xfb, 0xce, 0x9d, 0x72, 0xa1, 0x4c,
	0x61, 0x77, 0xb6, 0x2b, 0xc5, 0x5a, 0x2a, 0x86, 0x2e, 0xc1, 0x85, 0x00, 0xda, 0x96, 0x5c, 0xde,
	0xcc, 0xcb, 0xbf, 0x52, 0x8a, 0xa5, 0xc2, 0x46, 0xb9, 0x52, 0x2a, 0xa6, 0x46, 0x51, 0x06, 0xd2,
	0x01, 0xa4, 0xc2, 0xfd, 0x02, 0x65, 0x92, 0x0a, 0x92, 0x1a, 0x0b, 0x59, 0x7f, 0x50, 0xde, 0xea,
	0xae, 0x8f, 0xa3, 0xf7, 0xe1, 0xe6, 0xb1, 0xbc, 0x28, 0xb5, 0x52, 0xa1, 0x5a, 0x29, 0xd2, 0x93,
	0x0b, 0xeb, 0x79, 0xf9, 0x6e, 0xa9, 0x98, 0x8a, 0xa3, 0x77, 0xe1, 0xc6, 0x00, 0xee, 0x5c, 0x41,
	0x43, 0x76, 0x25, 0xd0, 0x7b, 0xf0, 0x1b, 0xc7, 0xc8, 0x14, 0xb2, 0x0d, 0x50, 0x16, 0x96, 0x02,
	0xdb, 0xd6, 0xaa, 0xf5, 0xf5, 0x80, 0x9d, 0x94, 0x3b, 0xf9, 0xf2, 0x46, 0xa9, 0x98, 0x4a, 0xa2,
	0x4b, 0x90, 0x09, 0x2c, 0xdd, 0x2d, 0x55, 0x4a, 0x72, 0xb9, 0xc0, 0x50, 0xb6, 0xe5, 0x52, 0xea,
	0xfb, 0x71, 0x74, 0x15, 0xa4, 0x01, 0x48, 0xf9, 0x62, 0xb1, 0x8b, 0xf8, 0xc3, 0xf8, 0x72, 0x05,
	0x66, 0x0e, 0x3d, 0x52, 0xa3, 0x49, 0x48, 0x54, 0xaa, 0x0a, 0xb7, 0x7a, 0x6a, 0x84, 0x9a, 0x9b,
	0xee, 0xaa, 0x94, 0x3e, 0x09, 0x3a, 0x8f, 0x80, 0xa6, 0x00, 0x0a, 0xd5, 0x4a, 0x3d, 0x5f, 0xa8,
	0x2b, 0xd4, 0x35, 0x96, 0x0d, 0x80, 0x5e, 0x07, 0x81, 0x10, 0x4c, 0x6d, 0x57, 0x7e, 0xbb, 0x52,
	0xfd, 0xa4, 0xa2, 0xe4, 0x0b, 0x85, 0x52, 0xad, 0x96, 0x1a, 0x41, 0x33, 0x30, 0x59, 0x2c, 0xcb,
	0xa5, 0x42, 0xdd, 0x03, 0x31, 0x22, 0x9b, 0xb5, 0x2d, 0x6f, 0x1e, 0x41, 0x73, 0x90, 0x2a, 0x96,
	0x36, 0x4a, 0x77, 0xf3, 0xf5, 0x52, 0xd1, 0x83, 0x46, 0x29, 0xb1, 0xda, 0xf6, 0xd6, 0x56, 0x55,
	0xee, 0xee, 0x8c, 0x2d, 0xcb, 0x90, 0xf4, 0x15, 0x21, 0x74, 0x1a, 0xd0, 0x26, 0x69, 0x7b, 0xd3,
	0x6d, 0xf3, 0xb1, 0x69, 0x3d, 0x31, 0x53, 0x23, 0x94, 0xa0, 0x0f, 0x5e, 0x78, 0xa4, 0xb7, 0xb4,
	0x94, 0x80, 0x4e, 0xc1, 0x8c, 0x0f, 0xba, 0xc5, 0x6a, 0x60, 0x2a, 0xb2, 0xfa, 0x9f, 0x22, 0x24,
	0x0a, 0xec, 0x4b, 0x50, 0x7e, 0xab, 0x8c, 0xbe, 0x11, 0x60, 0xac, 0x40, 0x2f, 0x79, 0x18, 0x5d,
	0x1a, 0xf4, 0x9e, 0xe0, 0x7b, 0x3c, 0x49, 0xa7, 0xc3, 0x90, 0xaa, 0x2c, 0xbf, 0x4b, 0x5f, 0x1c,
	0x3c, 0x17, 0x7f, 0xb9, 0xfb, 0xde, 0xe7, 0x8d, 0x6c, 0xc3, 0x32, 0x89, 0xd5, 0xc2, 0xd9, 0x1d,
	0x95, 0xe8, 0x8d, 0xac, 0xaa, 0x19, 0xba, 0x79, 0x7d, 0x81, 0xad, 0xec, 0xa8, 0x04, 0x5f, 0x5f,
	0xd8, 0xc3, 0x24, 0xab, 0x5b, 0xd9, 0x8e, 0x6a, 0xf0, 0xc5, 0xec, 0x13, 0x5b, 0x77, 0xf0, 0x57,
	0xff, 0xf4, 0x6f, 0x7f, 0x14, 0x79, 0x4f, 0xba, 0xe1, 0x7e, 0xaf, 0xca, 0xf1, 0xef, 0x55, 0xb9,
	0xde, 0x33, 0x6a, 0xee, 0xf7, 0xba, 0xe3, 0x2f, 0xd9, 0x77, 0x1b, 0xfe, 0xa4, 0x71, 0x4b, 0x58,
	0x46, 0x07, 0x51, 0x18, 0x97, 0x71, 0xbb, 0x45, 0x6b, 0xc1, 0x1b, 0x0b, 0xf2, 0xc7, 0xd1, 0x37,
	0x94, 0xe4, 0x3f, 0x9e, 0x8b, 0xdf, 0x09, 0xf0, 0x8e, 0xbb, 0xc8, 0x4f, 0xc8, 0xd2, 0x13, 0xb2,
	0xdd, 0x6f, 0x70, 0x59, 0xdb, 0xe5, 0x76, 0x1d, 0xa2, 0xed, 0x8e, 0x83, 0xf2, 0x83, 0xa5, 0x5e,
	0x7c, 0xa8, 0x66, 0xbf, 0xf8, 0x6c, 0xf1, 0x61, 0x56, 0xcd, 0x7e, 0x71, 0x23, 0xfb, 0xe1, 0x67,
	0xcb, 0x0f, 0xdd, 0xc1, 0xd2, 0xed, 0x25, 0x9f, 0x1a, 0xd0, 0x2e, 0xc4, 0xda, 0x16, 0x71, 0xd0,
	0xef, 0xbc, 0x31, 0xa9, 0x23, 0xf1, 0x98, 0x99, 0x48, 0xfa, 0x24, 0x66, 0x7a, 0xf0, 0x91, 0xf4,
	0xfe, 0xeb, 0x6e, 0xe3, 0xe0, 0x2f, 0xa9, 0x91, 0xff, 0x41, 0x80, 0xd8, 0x86, 0x4e, 0x1c, 0x74,
	0xf5, 0xf8, 0x77, 0x70, 0x6e, 0xe5, 0xc5, 0x61, 0x1f, 0xcc, 0xa5, 0xbd, 0x6f, 0xff, 0x3a, 0x22,
	0x1c, 0x3c, 0x17, 0x7f, 0x11, 0x62, 0x76, 0xc3, 0x32, 0x75, 0xc7, 0xb2, 0x07, 0x19, 0xde, 0xc6,
	0xaa, 0xc6, 0x94, 0xb2, 0x8a, 0x5e, 0x5b, 0x29, 0xe8, 0x6f, 0x05, 0x88, 0xde, 0xc5, 0x0e, 0xba,
	0x72, 0xec, 0xa5, 0x99, 0x4b, 0x74, 0x75, 0xc8, 0xcb, 0xb5, 0xd4, 0x74, 0x05, 0xba, 0xc6, 0x98,
	0xd6, 0xf0, 0xae, 0xda, 0x69, 0x39, 0x59, 0xde, 0x8d, 0x77, 0xd9, 0x7f, 0x82, 0x77, 0x5c, 0x50,
	0x4f, 0x8a, 0x15, 0x74, 0x7d, 0x38, 0x29, 0x9e, 0x3c, 0xb2, 0x54, 0x43, 0x47, 0x3f, 0x0a, 0x30,
	0xd9, 0xd7, 0x4d, 0xa2, 0xc5, 0x63, 0x3b, 0x52, 0x4f, 0x9a, 0xa5, 0x21, 0x30, 0x5d, 0x79, 0xfe,
	0x40, 0x78, 0x1b, 0xe9, 0xe5, 0xb6, 0x74, 0x6b, 0x78, 0x13, 0x91, 0x5c, 0x83, 0xb3, 0xa2, 0xf0,
	0xde, 0x9b, 0xfa, 0xe0, 0xdf, 0x09, 0x00, 0xbd, 0x4f, 0x49, 0x28, 0xf4, 0xbb, 0xe8, 0xa1, 0x4f,
	0x4d, 0xe9, 0xb3, 0x61, 0x68, 0xbc, 0x6d, 0xfb, 0x79, 0xb3, 0x26, 0x75, 0x3a, 0x85, 0xc9, 0x46,
	0x85, 0xf9, 0x77, 0x01, 0x66, 0x0e, 0x7d, 0x57, 0x45, 0xa1, 0x5f, 0x99, 0x06, 0x7d, 0xce, 0x4d,
	0x67, 0x87, 0xc4, 0x76, 0xcd, 0xe8, 0x1c, 0x3c, 0x17, 0xaf, 0x0f, 0xe9, 0x92, 0x3d, 0xf9, 0x3e,
	0x96, 0x3e, 0x1c, 0x4e, 0x3e, 0x82, 0x4d, 0x4d, 0x69, 0xbb, 0x27, 0x2b, 0xec, 0x96, 0x45, 0x05,
	0xfd, 0x5a, 0x80, 0xc9, 0xbe, 0x6f, 0xc4, 0x68, 0xb0, 0x45, 0x8e, 0x32, 0xd6, 0xa7, 0x27, 0xe2,
	0x5e, 0x92, 0xce, 0x07, 0xb8, 0xf7, 0x38, 0xcc, 0xd9, 0x94, 0x29, 0x37, 0xb7, 0xcd, 0x85, 0x7d,
	0xc5, 0x46, 0xb9, 0x30, 0x6e, 0x8e, 0xf8, 0xde, 0x7d, 0x14, 0xfb, 0xc6, 0xdb, 0xf0, 0xb5, 0x45,
	0xe9, 0xd2, 0x20, 0x69, 0x18, 0xaa, 0xd2, 0x95, 0xe9, 0x1b, 0x01, 0x12, 0xdd, 0xfb, 0x11, 0x7a,
	0x67, 0xd0, 0x7b, 0x8c, 0xff, 0x9a, 0x97, 0xbe, 0x7c, 0x0c, 0x96, 0xeb, 0x46, 0x8f, 0x4f, 0x64,
	0x88, 0xa1, 0xc3, 0x84, 0xdf, 0xff, 0x14, 0xc7, 0x62, 0x61, 0xf2, 0x57, 0x02, 0x8c, 0xf1, 0x3b,
	0x1a, 0xba, 0x38, 0x20, 0xfd, 0xfa, 0x24, 0x90, 0x8e, 0x42, 0x71, 0xd9, 0xd7, 0x4e, 0x9a, 0x9c,
	0xaf, 0xa1, 0xa5, 0xe1, 0x24, 0x70, 0x2c, 0x82, 0xfe, 0x44, 0x80, 0x78, 0x6d, 0xdf, 0x6c, 0xd0,
	0xda, 0x70, 0x42, 0x87, 0xff, 0xe4, 0x44, 0x7a, 0xbe, 0x28, 0x9d, 0x0b, 0x70, 0xa9, 0x6b, 0x06,
	0xff, 0xd3, 0x86, 0xec, 0x9b, 0x0d, 0xaa, 0xd3, 0x7f, 0x16, 0x60, 0x2a, 0xaf, 0x69, 0xec, 0x7b,
	0x95, 0xc5, 0xee, 0x82, 0xe1, 0x0e, 0x12, 0xbc, 0x8f, 0x86, 0x3b, 0xc8, 0xa1, 0x0b, 0xe5, 0x5b,
	0x4a, 0xab, 0x47, 0x75, 0x39, 0x64, 0x9f, 0x38, 0xd8, 0x70, 0x0b, 0x05, 0xbf, 0xf8, 0xaa, 0x9a,
	0x46, 0x65, 0x7b, 0x29, 0xc0, 0xac, 0x8c, 0x0d, 0x6b, 0x0f, 0x53, 0xbe, 0xee, 0xd8, 0x96, 0xf1,
	0xbf, 0x20, 0xe0, 0x97, 0x6f, 0x43, 0xc0, 0x0f, 0xd2, 0x37, 0x5f, 0x4b, 0x40, 0x9b, 0x49, 0x75,
	0x4b, 0x58, 0x4e, 0x5f, 0x7d, 0xf6, 0x54, 0x88, 0xfe, 0xe3, 0x53, 0xe1, 0xec, 0xc0, 0x36, 0xfa,
	0xab, 0xbf, 0x17, 0x23, 0x8f, 0x84, 0xb5, 0xaf, 0x84, 0x17, 0x2f, 0x33, 0x23, 0xdf, 0xbd, 0xcc,
	0x8c, 0xfc, 0xf4, 0x32, 0x23, 0xfc, 0xfe, 0x41, 0x46, 0xf8, 0xcb, 0x83, 0x8c, 0xf0, 0xed, 0x41,
	0x46, 0x78, 0x71, 0x90, 0x11, 0xfe, 0xf5, 0x20, 0x23, 0x7c, 0x7f, 0x90, 0x19, 0xf9, 0xe9, 0x20,
	0x23, 0xfc, 0xe1, 0xab, 0xcc, 0xc8, 0xb3, 0x57, 0x19, 0xe1, 0xc5, 0xab, 0xcc, 0xc8, 0x77, 0xaf,
	0x32, 0x23, 0x0f, 0xd6, 0x9b, 0x56, 0xfb, 0x71, 0x73, 0x65, 0xcf, 0x6a, 0x39, 0xd8, 0xb6, 0x29,
	0xf1, 0x1c, 0x1b, 0xec, 0x5a, 0xb6, 0x91, 0x6d, 0xdb, 0xd6, 0x9e, 0xae, 0x61, 0x3b, 0xeb, 0x2d,
	0xe7, 0xda, 0x3b, 0x4d, 0x2b, 0x87, 0x3f, 0x77, 0xdc, 0xdf, 0xae, 0x7c, 0xff, 0x77, 0xed, 0x8c,
	0xb1, 0x97, 0xfd, 0x9b, 0xff, 0x13, 0x00, 0x00, 0xff, 0xff, 0xb0, 0x2e, 0xb2, 0x1a, 0x1e, 0x27,
	0x00, 0x00,
}

func (x BillingFlag) String() string {
	s, ok := BillingFlag_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x BillingFlagAction) String() string {
	s, ok := BillingFlagAction_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x AccessType) String() string {
	s, ok := AccessType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MSPNodeType) String() string {
	s, ok := MSPNodeType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *BillingFeatureIndicator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BillingFeatureIndicator)
	if !ok {
		that2, ok := that.(BillingFeatureIndicator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BillingFlag != that1.BillingFlag {
		return false
	}
	if this.Failed != that1.Failed {
		return false
	}
	if this.AdditionalInfo != that1.AdditionalInfo {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	return true
}
func (this *SendPasswordEmailRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SendPasswordEmailRequest)
	if !ok {
		that2, ok := that.(SendPasswordEmailRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	return true
}
func (this *SendPasswordEmailResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SendPasswordEmailResponse)
	if !ok {
		that2, ok := that.(SendPasswordEmailResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ResetPasswordByAdminRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResetPasswordByAdminRequest)
	if !ok {
		that2, ok := that.(ResetPasswordByAdminRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	return true
}
func (this *NamespacesRoleType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamespacesRoleType)
	if !ok {
		that2, ok := that.(NamespacesRoleType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Namespaces) != len(that1.Namespaces) {
		return false
	}
	for i := range this.Namespaces {
		if this.Namespaces[i] != that1.Namespaces[i] {
			return false
		}
	}
	if this.Role != that1.Role {
		return false
	}
	return true
}
func (this *UserRoleRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserRoleRequest)
	if !ok {
		that2, ok := that.(UserRoleRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.FirstName != that1.FirstName {
		return false
	}
	if this.LastName != that1.LastName {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.NamespaceRoles) != len(that1.NamespaceRoles) {
		return false
	}
	for i := range this.NamespaceRoles {
		if !this.NamespaceRoles[i].Equal(that1.NamespaceRoles[i]) {
			return false
		}
	}
	if this.IdmType != that1.IdmType {
		return false
	}
	if len(this.GroupNames) != len(that1.GroupNames) {
		return false
	}
	for i := range this.GroupNames {
		if this.GroupNames[i] != that1.GroupNames[i] {
			return false
		}
	}
	return true
}
func (this *ListUserRoleRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListUserRoleRequest)
	if !ok {
		that2, ok := that.(ListUserRoleRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	return true
}
func (this *AssignRoleRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AssignRoleRequest)
	if !ok {
		that2, ok := that.(AssignRoleRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if !this.NamespacesRole.Equal(that1.NamespacesRole) {
		return false
	}
	if len(this.Username) != len(that1.Username) {
		return false
	}
	for i := range this.Username {
		if this.Username[i] != that1.Username[i] {
			return false
		}
	}
	return true
}
func (this *ListUserRoleResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListUserRoleResponse)
	if !ok {
		that2, ok := that.(ListUserRoleResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *ListUserRoleResponseItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListUserRoleResponseItem)
	if !ok {
		that2, ok := that.(ListUserRoleResponseItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	if this.FirstName != that1.FirstName {
		return false
	}
	if this.LastName != that1.LastName {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.NamespaceRoles) != len(that1.NamespaceRoles) {
		return false
	}
	for i := range this.NamespaceRoles {
		if !this.NamespaceRoles[i].Equal(that1.NamespaceRoles[i]) {
			return false
		}
	}
	if this.Tenant != that1.Tenant {
		return false
	}
	if this.TenantType != that1.TenantType {
		return false
	}
	if this.IdmType != that1.IdmType {
		return false
	}
	if this.DomainOwner != that1.DomainOwner {
		return false
	}
	if this.OtpEnabled != that1.OtpEnabled {
		return false
	}
	if this.Disabled != that1.Disabled {
		return false
	}
	if !this.CreationTimestamp.Equal(that1.CreationTimestamp) {
		return false
	}
	if !this.LastLoginTimestamp.Equal(that1.LastLoginTimestamp) {
		return false
	}
	if len(this.GroupNames) != len(that1.GroupNames) {
		return false
	}
	for i := range this.GroupNames {
		if this.GroupNames[i] != that1.GroupNames[i] {
			return false
		}
	}
	if this.SyncMode != that1.SyncMode {
		return false
	}
	return true
}
func (this *GetUserRoleRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetUserRoleRequest)
	if !ok {
		that2, ok := that.(GetUserRoleRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	return true
}
func (this *GetUserRoleResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetUserRoleResponse)
	if !ok {
		that2, ok := that.(GetUserRoleResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	if this.FirstName != that1.FirstName {
		return false
	}
	if this.LastName != that1.LastName {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.NamespaceRoles) != len(that1.NamespaceRoles) {
		return false
	}
	for i := range this.NamespaceRoles {
		if !this.NamespaceRoles[i].Equal(that1.NamespaceRoles[i]) {
			return false
		}
	}
	if this.Tenant != that1.Tenant {
		return false
	}
	if this.TenantType != that1.TenantType {
		return false
	}
	if len(this.FeatureFlags) != len(that1.FeatureFlags) {
		return false
	}
	for i := range this.FeatureFlags {
		if !this.FeatureFlags[i].Equal(that1.FeatureFlags[i]) {
			return false
		}
	}
	if this.TosCurrentVersion != that1.TosCurrentVersion {
		return false
	}
	if this.TosAccepted != that1.TosAccepted {
		return false
	}
	if this.IdmType != that1.IdmType {
		return false
	}
	if this.DomainOwner != that1.DomainOwner {
		return false
	}
	if this.Cname != that1.Cname {
		return false
	}
	if len(this.BillingFlags) != len(that1.BillingFlags) {
		return false
	}
	for i := range this.BillingFlags {
		if !this.BillingFlags[i].Equal(that1.BillingFlags[i]) {
			return false
		}
	}
	if !this.CreationTimestamp.Equal(that1.CreationTimestamp) {
		return false
	}
	if this.Company != that1.Company {
		return false
	}
	if this.PlanType != that1.PlanType {
		return false
	}
	if this.ActivePlanTransitionUid != that1.ActivePlanTransitionUid {
		return false
	}
	if this.Disabled != that1.Disabled {
		return false
	}
	if this.TenantState != that1.TenantState {
		return false
	}
	if len(this.TenantFlags) != len(that1.TenantFlags) {
		return false
	}
	for i := range this.TenantFlags {
		if this.TenantFlags[i] != that1.TenantFlags[i] {
			return false
		}
	}
	if this.State != that1.State {
		return false
	}
	if !this.LastLoginTimestamp.Equal(that1.LastLoginTimestamp) {
		return false
	}
	if len(this.TileAccess) != len(that1.TileAccess) {
		return false
	}
	for i := range this.TileAccess {
		if !this.TileAccess[i].Equal(that1.TileAccess[i]) {
			return false
		}
	}
	if len(this.AddonServiceStatus) != len(that1.AddonServiceStatus) {
		return false
	}
	for i := range this.AddonServiceStatus {
		if !this.AddonServiceStatus[i].Equal(that1.AddonServiceStatus[i]) {
			return false
		}
	}
	if this.Environment != that1.Environment {
		return false
	}
	if this.TosVersion != that1.TosVersion {
		return false
	}
	if !this.TosAcceptedAt.Equal(that1.TosAcceptedAt) {
		return false
	}
	if len(this.GroupNames) != len(that1.GroupNames) {
		return false
	}
	for i := range this.GroupNames {
		if this.GroupNames[i] != that1.GroupNames[i] {
			return false
		}
	}
	if this.OriginalTenant != that1.OriginalTenant {
		return false
	}
	if !this.NamespaceAccess.Equal(that1.NamespaceAccess) {
		return false
	}
	if this.SyncMode != that1.SyncMode {
		return false
	}
	if this.UserUuid != that1.UserUuid {
		return false
	}
	if this.BillingPlanName != that1.BillingPlanName {
		return false
	}
	if that1.ManagedAccessInfo == nil {
		if this.ManagedAccessInfo != nil {
			return false
		}
	} else if this.ManagedAccessInfo == nil {
		return false
	} else if !this.ManagedAccessInfo.Equal(that1.ManagedAccessInfo) {
		return false
	}
	if this.AccessType != that1.AccessType {
		return false
	}
	if this.SignupOrigin != that1.SignupOrigin {
		return false
	}
	return true
}
func (this *GetUserRoleResponse_SelfManaged) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetUserRoleResponse_SelfManaged)
	if !ok {
		that2, ok := that.(GetUserRoleResponse_SelfManaged)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SelfManaged.Equal(that1.SelfManaged) {
		return false
	}
	return true
}
func (this *GetUserRoleResponse_MspManaged) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetUserRoleResponse_MspManaged)
	if !ok {
		that2, ok := that.(GetUserRoleResponse_MspManaged)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MspManaged.Equal(that1.MspManaged) {
		return false
	}
	return true
}
func (this *MSPManaged) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MSPManaged)
	if !ok {
		that2, ok := that.(MSPManaged)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Tier != that1.Tier {
		return false
	}
	if this.MspId != that1.MspId {
		return false
	}
	if this.ParentTenantId != that1.ParentTenantId {
		return false
	}
	if this.NodeType != that1.NodeType {
		return false
	}
	return true
}
func (this *CascadeDeleteRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CascadeDeleteRequest)
	if !ok {
		that2, ok := that.(CascadeDeleteRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	return true
}
func (this *CascadeDeleteResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CascadeDeleteResponse)
	if !ok {
		that2, ok := that.(CascadeDeleteResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DeleteOk != that1.DeleteOk {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *CascadeDeleteItemType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CascadeDeleteItemType)
	if !ok {
		that2, ok := that.(CascadeDeleteItemType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ObjectType != that1.ObjectType {
		return false
	}
	if this.ObjectUid != that1.ObjectUid {
		return false
	}
	if this.ObjectName != that1.ObjectName {
		return false
	}
	if this.ErrorMessage != that1.ErrorMessage {
		return false
	}
	return true
}
func (this *AcceptTOSRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AcceptTOSRequest)
	if !ok {
		that2, ok := that.(AcceptTOSRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.TosAccepted != that1.TosAccepted {
		return false
	}
	if this.TosVersion != that1.TosVersion {
		return false
	}
	if this.TosAcceptedAt != that1.TosAcceptedAt {
		return false
	}
	return true
}
func (this *AcceptTOSResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AcceptTOSResponse)
	if !ok {
		that2, ok := that.(AcceptTOSResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *GetTOSRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetTOSRequest)
	if !ok {
		that2, ok := that.(GetTOSRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	return true
}
func (this *GetTOSResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetTOSResponse)
	if !ok {
		that2, ok := that.(GetTOSResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.Text != that1.Text {
		return false
	}
	return true
}
func (this *Empty) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Empty)
	if !ok {
		that2, ok := that.(Empty)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *FeatureFlagType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FeatureFlagType)
	if !ok {
		that2, ok := that.(FeatureFlagType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Disabled != that1.Disabled {
		return false
	}
	return true
}
func (this *UserGroupRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserGroupRequest)
	if !ok {
		that2, ok := that.(UserGroupRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Username != that1.Username {
		return false
	}
	if len(this.GroupNames) != len(that1.GroupNames) {
		return false
	}
	for i := range this.GroupNames {
		if this.GroupNames[i] != that1.GroupNames[i] {
			return false
		}
	}
	return true
}
func (this *UserGroupResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserGroupResponse)
	if !ok {
		that2, ok := that.(UserGroupResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Error.Equal(that1.Error) {
		return false
	}
	return true
}
func (this *BillingFeatureIndicator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&user.BillingFeatureIndicator{")
	s = append(s, "BillingFlag: "+fmt.Sprintf("%#v", this.BillingFlag)+",\n")
	s = append(s, "Failed: "+fmt.Sprintf("%#v", this.Failed)+",\n")
	s = append(s, "AdditionalInfo: "+fmt.Sprintf("%#v", this.AdditionalInfo)+",\n")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SendPasswordEmailRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&user.SendPasswordEmailRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SendPasswordEmailResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&user.SendPasswordEmailResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResetPasswordByAdminRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&user.ResetPasswordByAdminRequest{")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NamespacesRoleType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&user.NamespacesRoleType{")
	s = append(s, "Namespaces: "+fmt.Sprintf("%#v", this.Namespaces)+",\n")
	s = append(s, "Role: "+fmt.Sprintf("%#v", this.Role)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UserRoleRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&user.UserRoleRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "FirstName: "+fmt.Sprintf("%#v", this.FirstName)+",\n")
	s = append(s, "LastName: "+fmt.Sprintf("%#v", this.LastName)+",\n")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.NamespaceRoles != nil {
		s = append(s, "NamespaceRoles: "+fmt.Sprintf("%#v", this.NamespaceRoles)+",\n")
	}
	s = append(s, "IdmType: "+fmt.Sprintf("%#v", this.IdmType)+",\n")
	s = append(s, "GroupNames: "+fmt.Sprintf("%#v", this.GroupNames)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListUserRoleRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&user.ListUserRoleRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AssignRoleRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&user.AssignRoleRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	if this.NamespacesRole != nil {
		s = append(s, "NamespacesRole: "+fmt.Sprintf("%#v", this.NamespacesRole)+",\n")
	}
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListUserRoleResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&user.ListUserRoleResponse{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListUserRoleResponseItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 21)
	s = append(s, "&user.ListUserRoleResponseItem{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "FirstName: "+fmt.Sprintf("%#v", this.FirstName)+",\n")
	s = append(s, "LastName: "+fmt.Sprintf("%#v", this.LastName)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.NamespaceRoles != nil {
		s = append(s, "NamespaceRoles: "+fmt.Sprintf("%#v", this.NamespaceRoles)+",\n")
	}
	s = append(s, "Tenant: "+fmt.Sprintf("%#v", this.Tenant)+",\n")
	s = append(s, "TenantType: "+fmt.Sprintf("%#v", this.TenantType)+",\n")
	s = append(s, "IdmType: "+fmt.Sprintf("%#v", this.IdmType)+",\n")
	s = append(s, "DomainOwner: "+fmt.Sprintf("%#v", this.DomainOwner)+",\n")
	s = append(s, "OtpEnabled: "+fmt.Sprintf("%#v", this.OtpEnabled)+",\n")
	s = append(s, "Disabled: "+fmt.Sprintf("%#v", this.Disabled)+",\n")
	if this.CreationTimestamp != nil {
		s = append(s, "CreationTimestamp: "+fmt.Sprintf("%#v", this.CreationTimestamp)+",\n")
	}
	if this.LastLoginTimestamp != nil {
		s = append(s, "LastLoginTimestamp: "+fmt.Sprintf("%#v", this.LastLoginTimestamp)+",\n")
	}
	s = append(s, "GroupNames: "+fmt.Sprintf("%#v", this.GroupNames)+",\n")
	s = append(s, "SyncMode: "+fmt.Sprintf("%#v", this.SyncMode)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetUserRoleRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&user.GetUserRoleRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetUserRoleResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 44)
	s = append(s, "&user.GetUserRoleResponse{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "FirstName: "+fmt.Sprintf("%#v", this.FirstName)+",\n")
	s = append(s, "LastName: "+fmt.Sprintf("%#v", this.LastName)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.NamespaceRoles != nil {
		s = append(s, "NamespaceRoles: "+fmt.Sprintf("%#v", this.NamespaceRoles)+",\n")
	}
	s = append(s, "Tenant: "+fmt.Sprintf("%#v", this.Tenant)+",\n")
	s = append(s, "TenantType: "+fmt.Sprintf("%#v", this.TenantType)+",\n")
	if this.FeatureFlags != nil {
		s = append(s, "FeatureFlags: "+fmt.Sprintf("%#v", this.FeatureFlags)+",\n")
	}
	s = append(s, "TosCurrentVersion: "+fmt.Sprintf("%#v", this.TosCurrentVersion)+",\n")
	s = append(s, "TosAccepted: "+fmt.Sprintf("%#v", this.TosAccepted)+",\n")
	s = append(s, "IdmType: "+fmt.Sprintf("%#v", this.IdmType)+",\n")
	s = append(s, "DomainOwner: "+fmt.Sprintf("%#v", this.DomainOwner)+",\n")
	s = append(s, "Cname: "+fmt.Sprintf("%#v", this.Cname)+",\n")
	if this.BillingFlags != nil {
		s = append(s, "BillingFlags: "+fmt.Sprintf("%#v", this.BillingFlags)+",\n")
	}
	if this.CreationTimestamp != nil {
		s = append(s, "CreationTimestamp: "+fmt.Sprintf("%#v", this.CreationTimestamp)+",\n")
	}
	s = append(s, "Company: "+fmt.Sprintf("%#v", this.Company)+",\n")
	s = append(s, "PlanType: "+fmt.Sprintf("%#v", this.PlanType)+",\n")
	s = append(s, "ActivePlanTransitionUid: "+fmt.Sprintf("%#v", this.ActivePlanTransitionUid)+",\n")
	s = append(s, "Disabled: "+fmt.Sprintf("%#v", this.Disabled)+",\n")
	s = append(s, "TenantState: "+fmt.Sprintf("%#v", this.TenantState)+",\n")
	keysForTenantFlags := make([]string, 0, len(this.TenantFlags))
	for k, _ := range this.TenantFlags {
		keysForTenantFlags = append(keysForTenantFlags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTenantFlags)
	mapStringForTenantFlags := "map[string]bool{"
	for _, k := range keysForTenantFlags {
		mapStringForTenantFlags += fmt.Sprintf("%#v: %#v,", k, this.TenantFlags[k])
	}
	mapStringForTenantFlags += "}"
	if this.TenantFlags != nil {
		s = append(s, "TenantFlags: "+mapStringForTenantFlags+",\n")
	}
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	if this.LastLoginTimestamp != nil {
		s = append(s, "LastLoginTimestamp: "+fmt.Sprintf("%#v", this.LastLoginTimestamp)+",\n")
	}
	keysForTileAccess := make([]string, 0, len(this.TileAccess))
	for k, _ := range this.TileAccess {
		keysForTileAccess = append(keysForTileAccess, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTileAccess)
	mapStringForTileAccess := "map[string]*TileAccess{"
	for _, k := range keysForTileAccess {
		mapStringForTileAccess += fmt.Sprintf("%#v: %#v,", k, this.TileAccess[k])
	}
	mapStringForTileAccess += "}"
	if this.TileAccess != nil {
		s = append(s, "TileAccess: "+mapStringForTileAccess+",\n")
	}
	keysForAddonServiceStatus := make([]string, 0, len(this.AddonServiceStatus))
	for k, _ := range this.AddonServiceStatus {
		keysForAddonServiceStatus = append(keysForAddonServiceStatus, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAddonServiceStatus)
	mapStringForAddonServiceStatus := "map[string]*AddonServiceStatus{"
	for _, k := range keysForAddonServiceStatus {
		mapStringForAddonServiceStatus += fmt.Sprintf("%#v: %#v,", k, this.AddonServiceStatus[k])
	}
	mapStringForAddonServiceStatus += "}"
	if this.AddonServiceStatus != nil {
		s = append(s, "AddonServiceStatus: "+mapStringForAddonServiceStatus+",\n")
	}
	s = append(s, "Environment: "+fmt.Sprintf("%#v", this.Environment)+",\n")
	s = append(s, "TosVersion: "+fmt.Sprintf("%#v", this.TosVersion)+",\n")
	if this.TosAcceptedAt != nil {
		s = append(s, "TosAcceptedAt: "+fmt.Sprintf("%#v", this.TosAcceptedAt)+",\n")
	}
	s = append(s, "GroupNames: "+fmt.Sprintf("%#v", this.GroupNames)+",\n")
	s = append(s, "OriginalTenant: "+fmt.Sprintf("%#v", this.OriginalTenant)+",\n")
	if this.NamespaceAccess != nil {
		s = append(s, "NamespaceAccess: "+fmt.Sprintf("%#v", this.NamespaceAccess)+",\n")
	}
	s = append(s, "SyncMode: "+fmt.Sprintf("%#v", this.SyncMode)+",\n")
	s = append(s, "UserUuid: "+fmt.Sprintf("%#v", this.UserUuid)+",\n")
	s = append(s, "BillingPlanName: "+fmt.Sprintf("%#v", this.BillingPlanName)+",\n")
	if this.ManagedAccessInfo != nil {
		s = append(s, "ManagedAccessInfo: "+fmt.Sprintf("%#v", this.ManagedAccessInfo)+",\n")
	}
	s = append(s, "AccessType: "+fmt.Sprintf("%#v", this.AccessType)+",\n")
	s = append(s, "SignupOrigin: "+fmt.Sprintf("%#v", this.SignupOrigin)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetUserRoleResponse_SelfManaged) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&user.GetUserRoleResponse_SelfManaged{` +
		`SelfManaged:` + fmt.Sprintf("%#v", this.SelfManaged) + `}`}, ", ")
	return s
}
func (this *GetUserRoleResponse_MspManaged) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&user.GetUserRoleResponse_MspManaged{` +
		`MspManaged:` + fmt.Sprintf("%#v", this.MspManaged) + `}`}, ", ")
	return s
}
func (this *MSPManaged) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&user.MSPManaged{")
	s = append(s, "Tier: "+fmt.Sprintf("%#v", this.Tier)+",\n")
	s = append(s, "MspId: "+fmt.Sprintf("%#v", this.MspId)+",\n")
	s = append(s, "ParentTenantId: "+fmt.Sprintf("%#v", this.ParentTenantId)+",\n")
	s = append(s, "NodeType: "+fmt.Sprintf("%#v", this.NodeType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CascadeDeleteRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&user.CascadeDeleteRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CascadeDeleteResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&user.CascadeDeleteResponse{")
	s = append(s, "DeleteOk: "+fmt.Sprintf("%#v", this.DeleteOk)+",\n")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CascadeDeleteItemType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&user.CascadeDeleteItemType{")
	s = append(s, "ObjectType: "+fmt.Sprintf("%#v", this.ObjectType)+",\n")
	s = append(s, "ObjectUid: "+fmt.Sprintf("%#v", this.ObjectUid)+",\n")
	s = append(s, "ObjectName: "+fmt.Sprintf("%#v", this.ObjectName)+",\n")
	s = append(s, "ErrorMessage: "+fmt.Sprintf("%#v", this.ErrorMessage)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AcceptTOSRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&user.AcceptTOSRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "TosAccepted: "+fmt.Sprintf("%#v", this.TosAccepted)+",\n")
	s = append(s, "TosVersion: "+fmt.Sprintf("%#v", this.TosVersion)+",\n")
	s = append(s, "TosAcceptedAt: "+fmt.Sprintf("%#v", this.TosAcceptedAt)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AcceptTOSResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&user.AcceptTOSResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetTOSRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&user.GetTOSRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetTOSResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&user.GetTOSResponse{")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Text: "+fmt.Sprintf("%#v", this.Text)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Empty) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&user.Empty{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FeatureFlagType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&user.FeatureFlagType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Disabled: "+fmt.Sprintf("%#v", this.Disabled)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UserGroupRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&user.UserGroupRequest{")
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	s = append(s, "GroupNames: "+fmt.Sprintf("%#v", this.GroupNames)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UserGroupResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&user.UserGroupResponse{")
	if this.Error != nil {
		s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringPublicCustomapi(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CustomAPIClient is the client API for CustomAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CustomAPIClient interface {
	// Create User with roles
	//
	// x-displayName: "Create User with Role Assignment"
	// Create creates a user and namespace roles binding for this user
	Create(ctx context.Context, in *UserRoleRequest, opts ...grpc.CallOption) (*Object, error)
	// Update User with roles
	//
	// x-displayName: "Update User and Role Assignments"
	// Replace updates user and namespace roles for this user
	Replace(ctx context.Context, in *UserRoleRequest, opts ...grpc.CallOption) (*Object, error)
	// List User with roles
	//
	// x-displayName: "Get User and Role Assignments"
	// List enumerates users and their namespace roles for this tenant
	List(ctx context.Context, in *ListUserRoleRequest, opts ...grpc.CallOption) (*ListUserRoleResponse, error)
	// Get User information details
	//
	// x-displayName: "Get User Details"
	// Get fetches user information based on the username header from the request context
	// this API is also called as WhoAmI
	Get(ctx context.Context, in *GetUserRoleRequest, opts ...grpc.CallOption) (*GetUserRoleResponse, error)
	// CascadeDelete User
	//
	// x-displayName: "Delete User and Related Objects"
	// CascadeDelete deletes the user and associated namespace roles for this user.
	// Use this only if the user and its referenced objects need to be wiped out altogether.
	// Note: users will always be in the system namespace.
	CascadeDelete(ctx context.Context, in *CascadeDeleteRequest, opts ...grpc.CallOption) (*CascadeDeleteResponse, error)
	// Role assignment request
	//
	// x-displayName: "Assign role to User"
	// AssignRole allows customers to assign a namespace/role pair to multiple users
	AssignRole(ctx context.Context, in *AssignRoleRequest, opts ...grpc.CallOption) (*Empty, error)
	// Send password email
	//
	// x-displayName: "Send Password Email"
	// SendPasswordEmail allows admin user to trigger send password email for a user to update user's password.
	// Deprecated: use ResetPasswordByAdmin RPC instead
	SendPasswordEmail(ctx context.Context, in *SendPasswordEmailRequest, opts ...grpc.CallOption) (*SendPasswordEmailResponse, error)
	// Reset password
	//
	// x-displayName: "Reset password"
	// Reset password resets password for user who is making this request.
	ResetPassword(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// Reset password by admin
	//
	// x-displayName: "Reset password by admin"
	// Reset password by admin resets password for a user specified in request payload.
	// This request is meant to be executed by the tenant's admin.
	ResetPasswordByAdmin(ctx context.Context, in *ResetPasswordByAdminRequest, opts ...grpc.CallOption) (*Empty, error)
	// Accept TOS request
	//
	// x-displayName: "Accept TOS"
	// Accept TOS updates version of accepted terms of service.
	AcceptTOS(ctx context.Context, in *AcceptTOSRequest, opts ...grpc.CallOption) (*AcceptTOSResponse, error)
	// TOS request
	//
	// x-displayName: "Get TOS"
	// Get TOS provides TOS version with text
	GetTOS(ctx context.Context, in *GetTOSRequest, opts ...grpc.CallOption) (*GetTOSResponse, error)
	// Sync user from identity provider
	//
	// x-displayName: "Sync user"
	// In case when user created initially from identity provider we need to sync the user data.
	SyncUser(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// Add user to the groups
	//
	// x-displayName: "Add user to groups"
	// Assign existing user to specific groups.
	AddUserToGroup(ctx context.Context, in *UserGroupRequest, opts ...grpc.CallOption) (*UserGroupResponse, error)
	// Remove user from groups
	//
	// x-displayName: "remove user from groups"
	// remove existing user from specific groups.
	RemoveUserFromGroup(ctx context.Context, in *UserGroupRequest, opts ...grpc.CallOption) (*UserGroupResponse, error)
}

type customAPIClient struct {
	cc *grpc.ClientConn
}

func NewCustomAPIClient(cc *grpc.ClientConn) CustomAPIClient {
	return &customAPIClient{cc}
}

func (c *customAPIClient) Create(ctx context.Context, in *UserRoleRequest, opts ...grpc.CallOption) (*Object, error) {
	out := new(Object)
	err := c.cc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) Replace(ctx context.Context, in *UserRoleRequest, opts ...grpc.CallOption) (*Object, error) {
	out := new(Object)
	err := c.cc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/Replace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) List(ctx context.Context, in *ListUserRoleRequest, opts ...grpc.CallOption) (*ListUserRoleResponse, error) {
	out := new(ListUserRoleResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) Get(ctx context.Context, in *GetUserRoleRequest, opts ...grpc.CallOption) (*GetUserRoleResponse, error) {
	out := new(GetUserRoleResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) CascadeDelete(ctx context.Context, in *CascadeDeleteRequest, opts ...grpc.CallOption) (*CascadeDeleteResponse, error) {
	out := new(CascadeDeleteResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/CascadeDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) AssignRole(ctx context.Context, in *AssignRoleRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/AssignRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) SendPasswordEmail(ctx context.Context, in *SendPasswordEmailRequest, opts ...grpc.CallOption) (*SendPasswordEmailResponse, error) {
	out := new(SendPasswordEmailResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/SendPasswordEmail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) ResetPassword(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/ResetPassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) ResetPasswordByAdmin(ctx context.Context, in *ResetPasswordByAdminRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/ResetPasswordByAdmin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) AcceptTOS(ctx context.Context, in *AcceptTOSRequest, opts ...grpc.CallOption) (*AcceptTOSResponse, error) {
	out := new(AcceptTOSResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/AcceptTOS", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) GetTOS(ctx context.Context, in *GetTOSRequest, opts ...grpc.CallOption) (*GetTOSResponse, error) {
	out := new(GetTOSResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/GetTOS", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) SyncUser(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/SyncUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) AddUserToGroup(ctx context.Context, in *UserGroupRequest, opts ...grpc.CallOption) (*UserGroupResponse, error) {
	out := new(UserGroupResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/AddUserToGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) RemoveUserFromGroup(ctx context.Context, in *UserGroupRequest, opts ...grpc.CallOption) (*UserGroupResponse, error) {
	out := new(UserGroupResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/RemoveUserFromGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CustomAPIServer is the server API for CustomAPI service.
type CustomAPIServer interface {
	// Create User with roles
	//
	// x-displayName: "Create User with Role Assignment"
	// Create creates a user and namespace roles binding for this user
	Create(context.Context, *UserRoleRequest) (*Object, error)
	// Update User with roles
	//
	// x-displayName: "Update User and Role Assignments"
	// Replace updates user and namespace roles for this user
	Replace(context.Context, *UserRoleRequest) (*Object, error)
	// List User with roles
	//
	// x-displayName: "Get User and Role Assignments"
	// List enumerates users and their namespace roles for this tenant
	List(context.Context, *ListUserRoleRequest) (*ListUserRoleResponse, error)
	// Get User information details
	//
	// x-displayName: "Get User Details"
	// Get fetches user information based on the username header from the request context
	// this API is also called as WhoAmI
	Get(context.Context, *GetUserRoleRequest) (*GetUserRoleResponse, error)
	// CascadeDelete User
	//
	// x-displayName: "Delete User and Related Objects"
	// CascadeDelete deletes the user and associated namespace roles for this user.
	// Use this only if the user and its referenced objects need to be wiped out altogether.
	// Note: users will always be in the system namespace.
	CascadeDelete(context.Context, *CascadeDeleteRequest) (*CascadeDeleteResponse, error)
	// Role assignment request
	//
	// x-displayName: "Assign role to User"
	// AssignRole allows customers to assign a namespace/role pair to multiple users
	AssignRole(context.Context, *AssignRoleRequest) (*Empty, error)
	// Send password email
	//
	// x-displayName: "Send Password Email"
	// SendPasswordEmail allows admin user to trigger send password email for a user to update user's password.
	// Deprecated: use ResetPasswordByAdmin RPC instead
	SendPasswordEmail(context.Context, *SendPasswordEmailRequest) (*SendPasswordEmailResponse, error)
	// Reset password
	//
	// x-displayName: "Reset password"
	// Reset password resets password for user who is making this request.
	ResetPassword(context.Context, *Empty) (*Empty, error)
	// Reset password by admin
	//
	// x-displayName: "Reset password by admin"
	// Reset password by admin resets password for a user specified in request payload.
	// This request is meant to be executed by the tenant's admin.
	ResetPasswordByAdmin(context.Context, *ResetPasswordByAdminRequest) (*Empty, error)
	// Accept TOS request
	//
	// x-displayName: "Accept TOS"
	// Accept TOS updates version of accepted terms of service.
	AcceptTOS(context.Context, *AcceptTOSRequest) (*AcceptTOSResponse, error)
	// TOS request
	//
	// x-displayName: "Get TOS"
	// Get TOS provides TOS version with text
	GetTOS(context.Context, *GetTOSRequest) (*GetTOSResponse, error)
	// Sync user from identity provider
	//
	// x-displayName: "Sync user"
	// In case when user created initially from identity provider we need to sync the user data.
	SyncUser(context.Context, *Empty) (*Empty, error)
	// Add user to the groups
	//
	// x-displayName: "Add user to groups"
	// Assign existing user to specific groups.
	AddUserToGroup(context.Context, *UserGroupRequest) (*UserGroupResponse, error)
	// Remove user from groups
	//
	// x-displayName: "remove user from groups"
	// remove existing user from specific groups.
	RemoveUserFromGroup(context.Context, *UserGroupRequest) (*UserGroupResponse, error)
}

// UnimplementedCustomAPIServer can be embedded to have forward compatible implementations.
type UnimplementedCustomAPIServer struct {
}

func (*UnimplementedCustomAPIServer) Create(ctx context.Context, req *UserRoleRequest) (*Object, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (*UnimplementedCustomAPIServer) Replace(ctx context.Context, req *UserRoleRequest) (*Object, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Replace not implemented")
}
func (*UnimplementedCustomAPIServer) List(ctx context.Context, req *ListUserRoleRequest) (*ListUserRoleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (*UnimplementedCustomAPIServer) Get(ctx context.Context, req *GetUserRoleRequest) (*GetUserRoleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (*UnimplementedCustomAPIServer) CascadeDelete(ctx context.Context, req *CascadeDeleteRequest) (*CascadeDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CascadeDelete not implemented")
}
func (*UnimplementedCustomAPIServer) AssignRole(ctx context.Context, req *AssignRoleRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssignRole not implemented")
}
func (*UnimplementedCustomAPIServer) SendPasswordEmail(ctx context.Context, req *SendPasswordEmailRequest) (*SendPasswordEmailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendPasswordEmail not implemented")
}
func (*UnimplementedCustomAPIServer) ResetPassword(ctx context.Context, req *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetPassword not implemented")
}
func (*UnimplementedCustomAPIServer) ResetPasswordByAdmin(ctx context.Context, req *ResetPasswordByAdminRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetPasswordByAdmin not implemented")
}
func (*UnimplementedCustomAPIServer) AcceptTOS(ctx context.Context, req *AcceptTOSRequest) (*AcceptTOSResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AcceptTOS not implemented")
}
func (*UnimplementedCustomAPIServer) GetTOS(ctx context.Context, req *GetTOSRequest) (*GetTOSResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTOS not implemented")
}
func (*UnimplementedCustomAPIServer) SyncUser(ctx context.Context, req *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncUser not implemented")
}
func (*UnimplementedCustomAPIServer) AddUserToGroup(ctx context.Context, req *UserGroupRequest) (*UserGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUserToGroup not implemented")
}
func (*UnimplementedCustomAPIServer) RemoveUserFromGroup(ctx context.Context, req *UserGroupRequest) (*UserGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveUserFromGroup not implemented")
}

func RegisterCustomAPIServer(s *grpc.Server, srv CustomAPIServer) {
	s.RegisterService(&_CustomAPI_serviceDesc, srv)
}

func _CustomAPI_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).Create(ctx, req.(*UserRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_Replace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).Replace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/Replace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).Replace(ctx, req.(*UserRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUserRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).List(ctx, req.(*ListUserRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).Get(ctx, req.(*GetUserRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_CascadeDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CascadeDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).CascadeDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/CascadeDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).CascadeDelete(ctx, req.(*CascadeDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_AssignRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssignRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).AssignRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/AssignRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).AssignRole(ctx, req.(*AssignRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_SendPasswordEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendPasswordEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).SendPasswordEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/SendPasswordEmail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).SendPasswordEmail(ctx, req.(*SendPasswordEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_ResetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).ResetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/ResetPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).ResetPassword(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_ResetPasswordByAdmin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetPasswordByAdminRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).ResetPasswordByAdmin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/ResetPasswordByAdmin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).ResetPasswordByAdmin(ctx, req.(*ResetPasswordByAdminRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_AcceptTOS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcceptTOSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).AcceptTOS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/AcceptTOS",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).AcceptTOS(ctx, req.(*AcceptTOSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_GetTOS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTOSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).GetTOS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/GetTOS",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).GetTOS(ctx, req.(*GetTOSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_SyncUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).SyncUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/SyncUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).SyncUser(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_AddUserToGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).AddUserToGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/AddUserToGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).AddUserToGroup(ctx, req.(*UserGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_RemoveUserFromGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).RemoveUserFromGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/RemoveUserFromGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).RemoveUserFromGroup(ctx, req.(*UserGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CustomAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ves.io.schema.user.CustomAPI",
	HandlerType: (*CustomAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _CustomAPI_Create_Handler,
		},
		{
			MethodName: "Replace",
			Handler:    _CustomAPI_Replace_Handler,
		},
		{
			MethodName: "List",
			Handler:    _CustomAPI_List_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _CustomAPI_Get_Handler,
		},
		{
			MethodName: "CascadeDelete",
			Handler:    _CustomAPI_CascadeDelete_Handler,
		},
		{
			MethodName: "AssignRole",
			Handler:    _CustomAPI_AssignRole_Handler,
		},
		{
			MethodName: "SendPasswordEmail",
			Handler:    _CustomAPI_SendPasswordEmail_Handler,
		},
		{
			MethodName: "ResetPassword",
			Handler:    _CustomAPI_ResetPassword_Handler,
		},
		{
			MethodName: "ResetPasswordByAdmin",
			Handler:    _CustomAPI_ResetPasswordByAdmin_Handler,
		},
		{
			MethodName: "AcceptTOS",
			Handler:    _CustomAPI_AcceptTOS_Handler,
		},
		{
			MethodName: "GetTOS",
			Handler:    _CustomAPI_GetTOS_Handler,
		},
		{
			MethodName: "SyncUser",
			Handler:    _CustomAPI_SyncUser_Handler,
		},
		{
			MethodName: "AddUserToGroup",
			Handler:    _CustomAPI_AddUserToGroup_Handler,
		},
		{
			MethodName: "RemoveUserFromGroup",
			Handler:    _CustomAPI_RemoveUserFromGroup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ves.io/schema/user/public_customapi.proto",
}

func (m *BillingFeatureIndicator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BillingFeatureIndicator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BillingFeatureIndicator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x20
	}
	if len(m.AdditionalInfo) > 0 {
		i -= len(m.AdditionalInfo)
		copy(dAtA[i:], m.AdditionalInfo)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.AdditionalInfo)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Failed {
		i--
		if m.Failed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.BillingFlag != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.BillingFlag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SendPasswordEmailRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendPasswordEmailRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendPasswordEmailRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Email) > 0 {
		i -= len(m.Email)
		copy(dAtA[i:], m.Email)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Email)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *SendPasswordEmailResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendPasswordEmailResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendPasswordEmailResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ResetPasswordByAdminRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetPasswordByAdminRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResetPasswordByAdminRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Email) > 0 {
		i -= len(m.Email)
		copy(dAtA[i:], m.Email)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Email)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NamespacesRoleType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespacesRoleType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NamespacesRoleType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespaces) > 0 {
		for iNdEx := len(m.Namespaces) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Namespaces[iNdEx])
			copy(dAtA[i:], m.Namespaces[iNdEx])
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespaces[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UserRoleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRoleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserRoleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GroupNames) > 0 {
		for iNdEx := len(m.GroupNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.GroupNames[iNdEx])
			copy(dAtA[i:], m.GroupNames[iNdEx])
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.GroupNames[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.IdmType != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.IdmType))
		i--
		dAtA[i] = 0x40
	}
	if len(m.NamespaceRoles) > 0 {
		for iNdEx := len(m.NamespaceRoles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NamespaceRoles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Type != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Email) > 0 {
		i -= len(m.Email)
		copy(dAtA[i:], m.Email)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Email)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.LastName) > 0 {
		i -= len(m.LastName)
		copy(dAtA[i:], m.LastName)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.LastName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FirstName) > 0 {
		i -= len(m.FirstName)
		copy(dAtA[i:], m.FirstName)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.FirstName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListUserRoleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListUserRoleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListUserRoleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AssignRoleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssignRoleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssignRoleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		for iNdEx := len(m.Username) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Username[iNdEx])
			copy(dAtA[i:], m.Username[iNdEx])
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Username[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.NamespacesRole != nil {
		{
			size, err := m.NamespacesRole.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListUserRoleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListUserRoleResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListUserRoleResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListUserRoleResponseItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListUserRoleResponseItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListUserRoleResponseItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SyncMode != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.SyncMode))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.GroupNames) > 0 {
		for iNdEx := len(m.GroupNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.GroupNames[iNdEx])
			copy(dAtA[i:], m.GroupNames[iNdEx])
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.GroupNames[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.LastLoginTimestamp != nil {
		{
			size, err := m.LastLoginTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.CreationTimestamp != nil {
		{
			size, err := m.CreationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.Disabled {
		i--
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.OtpEnabled {
		i--
		if m.OtpEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.DomainOwner {
		i--
		if m.DomainOwner {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.IdmType != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.IdmType))
		i--
		dAtA[i] = 0x50
	}
	if m.TenantType != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.TenantType))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Tenant) > 0 {
		i -= len(m.Tenant)
		copy(dAtA[i:], m.Tenant)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Tenant)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.NamespaceRoles) > 0 {
		for iNdEx := len(m.NamespaceRoles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NamespaceRoles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Type != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x30
	}
	if len(m.LastName) > 0 {
		i -= len(m.LastName)
		copy(dAtA[i:], m.LastName)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.LastName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.FirstName) > 0 {
		i -= len(m.FirstName)
		copy(dAtA[i:], m.FirstName)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.FirstName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Email) > 0 {
		i -= len(m.Email)
		copy(dAtA[i:], m.Email)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Email)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetUserRoleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserRoleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUserRoleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetUserRoleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserRoleResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUserRoleResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SignupOrigin != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.SignupOrigin))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	if m.AccessType != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.AccessType))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd8
	}
	if m.ManagedAccessInfo != nil {
		{
			size := m.ManagedAccessInfo.Size()
			i -= size
			if _, err := m.ManagedAccessInfo.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.BillingPlanName) > 0 {
		i -= len(m.BillingPlanName)
		copy(dAtA[i:], m.BillingPlanName)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.BillingPlanName)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	if len(m.UserUuid) > 0 {
		i -= len(m.UserUuid)
		copy(dAtA[i:], m.UserUuid)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.UserUuid)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	if m.SyncMode != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.SyncMode))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.NamespaceAccess != nil {
		{
			size, err := m.NamespaceAccess.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	if len(m.OriginalTenant) > 0 {
		i -= len(m.OriginalTenant)
		copy(dAtA[i:], m.OriginalTenant)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.OriginalTenant)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if len(m.GroupNames) > 0 {
		for iNdEx := len(m.GroupNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.GroupNames[iNdEx])
			copy(dAtA[i:], m.GroupNames[iNdEx])
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.GroupNames[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x92
		}
	}
	if m.TosAcceptedAt != nil {
		{
			size, err := m.TosAcceptedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if len(m.TosVersion) > 0 {
		i -= len(m.TosVersion)
		copy(dAtA[i:], m.TosVersion)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.TosVersion)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if len(m.Environment) > 0 {
		i -= len(m.Environment)
		copy(dAtA[i:], m.Environment)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Environment)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if len(m.AddonServiceStatus) > 0 {
		for k := range m.AddonServiceStatus {
			v := m.AddonServiceStatus[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.TileAccess) > 0 {
		for k := range m.TileAccess {
			v := m.TileAccess[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe2
		}
	}
	if m.State != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.LastLoginTimestamp != nil {
		{
			size, err := m.LastLoginTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.TenantFlags) > 0 {
		for k := range m.TenantFlags {
			v := m.TenantFlags[k]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.TenantState) > 0 {
		i -= len(m.TenantState)
		copy(dAtA[i:], m.TenantState)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.TenantState)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.Disabled {
		i--
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if len(m.ActivePlanTransitionUid) > 0 {
		i -= len(m.ActivePlanTransitionUid)
		copy(dAtA[i:], m.ActivePlanTransitionUid)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.ActivePlanTransitionUid)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.PlanType != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.PlanType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Company) > 0 {
		i -= len(m.Company)
		copy(dAtA[i:], m.Company)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Company)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.CreationTimestamp != nil {
		{
			size, err := m.CreationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.BillingFlags) > 0 {
		for iNdEx := len(m.BillingFlags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BillingFlags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.Cname) > 0 {
		i -= len(m.Cname)
		copy(dAtA[i:], m.Cname)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Cname)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.DomainOwner {
		i--
		if m.DomainOwner {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.IdmType != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.IdmType))
		i--
		dAtA[i] = 0x68
	}
	if len(m.TosAccepted) > 0 {
		i -= len(m.TosAccepted)
		copy(dAtA[i:], m.TosAccepted)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.TosAccepted)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.TosCurrentVersion) > 0 {
		i -= len(m.TosCurrentVersion)
		copy(dAtA[i:], m.TosCurrentVersion)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.TosCurrentVersion)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.FeatureFlags) > 0 {
		for iNdEx := len(m.FeatureFlags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FeatureFlags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.TenantType != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.TenantType))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Tenant) > 0 {
		i -= len(m.Tenant)
		copy(dAtA[i:], m.Tenant)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Tenant)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.NamespaceRoles) > 0 {
		for iNdEx := len(m.NamespaceRoles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NamespaceRoles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Type != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x30
	}
	if len(m.LastName) > 0 {
		i -= len(m.LastName)
		copy(dAtA[i:], m.LastName)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.LastName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.FirstName) > 0 {
		i -= len(m.FirstName)
		copy(dAtA[i:], m.FirstName)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.FirstName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Email) > 0 {
		i -= len(m.Email)
		copy(dAtA[i:], m.Email)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Email)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetUserRoleResponse_SelfManaged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUserRoleResponse_SelfManaged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SelfManaged != nil {
		{
			size, err := m.SelfManaged.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *GetUserRoleResponse_MspManaged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUserRoleResponse_MspManaged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MspManaged != nil {
		{
			size, err := m.MspManaged.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *MSPManaged) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MSPManaged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MSPManaged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NodeType != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.NodeType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ParentTenantId) > 0 {
		i -= len(m.ParentTenantId)
		copy(dAtA[i:], m.ParentTenantId)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.ParentTenantId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MspId) > 0 {
		i -= len(m.MspId)
		copy(dAtA[i:], m.MspId)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.MspId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Tier != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Tier))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CascadeDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CascadeDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CascadeDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Email) > 0 {
		i -= len(m.Email)
		copy(dAtA[i:], m.Email)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Email)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CascadeDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CascadeDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CascadeDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.DeleteOk {
		i--
		if m.DeleteOk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CascadeDeleteItemType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CascadeDeleteItemType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CascadeDeleteItemType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ObjectName) > 0 {
		i -= len(m.ObjectName)
		copy(dAtA[i:], m.ObjectName)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.ObjectName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ObjectUid) > 0 {
		i -= len(m.ObjectUid)
		copy(dAtA[i:], m.ObjectUid)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.ObjectUid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ObjectType) > 0 {
		i -= len(m.ObjectType)
		copy(dAtA[i:], m.ObjectType)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.ObjectType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AcceptTOSRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptTOSRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AcceptTOSRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TosAcceptedAt != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.TosAcceptedAt))
		i--
		dAtA[i] = 0x28
	}
	if len(m.TosVersion) > 0 {
		i -= len(m.TosVersion)
		copy(dAtA[i:], m.TosVersion)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.TosVersion)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TosAccepted) > 0 {
		i -= len(m.TosAccepted)
		copy(dAtA[i:], m.TosAccepted)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.TosAccepted)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AcceptTOSResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptTOSResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AcceptTOSResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetTOSRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTOSRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTOSRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTOSResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTOSResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTOSResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *FeatureFlagType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureFlagType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeatureFlagType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Disabled {
		i--
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserGroupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserGroupRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserGroupRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GroupNames) > 0 {
		for iNdEx := len(m.GroupNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.GroupNames[iNdEx])
			copy(dAtA[i:], m.GroupNames[iNdEx])
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.GroupNames[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserGroupResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserGroupResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserGroupResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPublicCustomapi(dAtA []byte, offset int, v uint64) int {
	offset -= sovPublicCustomapi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BillingFeatureIndicator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BillingFlag != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.BillingFlag))
	}
	if m.Failed {
		n += 2
	}
	l = len(m.AdditionalInfo)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.Action != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Action))
	}
	return n
}

func (m *SendPasswordEmailRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *SendPasswordEmailResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ResetPasswordByAdminRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *NamespacesRoleType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Namespaces) > 0 {
		for _, s := range m.Namespaces {
			l = len(s)
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *UserRoleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Type))
	}
	if len(m.NamespaceRoles) > 0 {
		for _, e := range m.NamespaceRoles {
			l = e.Size()
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	if m.IdmType != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.IdmType))
	}
	if len(m.GroupNames) > 0 {
		for _, s := range m.GroupNames {
			l = len(s)
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	return n
}

func (m *ListUserRoleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *AssignRoleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.NamespacesRole != nil {
		l = m.NamespacesRole.Size()
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if len(m.Username) > 0 {
		for _, s := range m.Username {
			l = len(s)
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	return n
}

func (m *ListUserRoleResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	return n
}

func (m *ListUserRoleResponseItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Type))
	}
	if len(m.NamespaceRoles) > 0 {
		for _, e := range m.NamespaceRoles {
			l = e.Size()
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.TenantType != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.TenantType))
	}
	if m.IdmType != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.IdmType))
	}
	if m.DomainOwner {
		n += 2
	}
	if m.OtpEnabled {
		n += 2
	}
	if m.Disabled {
		n += 2
	}
	if m.CreationTimestamp != nil {
		l = m.CreationTimestamp.Size()
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.LastLoginTimestamp != nil {
		l = m.LastLoginTimestamp.Size()
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if len(m.GroupNames) > 0 {
		for _, s := range m.GroupNames {
			l = len(s)
			n += 2 + l + sovPublicCustomapi(uint64(l))
		}
	}
	if m.SyncMode != 0 {
		n += 2 + sovPublicCustomapi(uint64(m.SyncMode))
	}
	return n
}

func (m *GetUserRoleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *GetUserRoleResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Type))
	}
	if len(m.NamespaceRoles) > 0 {
		for _, e := range m.NamespaceRoles {
			l = e.Size()
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.TenantType != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.TenantType))
	}
	if len(m.FeatureFlags) > 0 {
		for _, e := range m.FeatureFlags {
			l = e.Size()
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	l = len(m.TosCurrentVersion)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.TosAccepted)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.IdmType != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.IdmType))
	}
	if m.DomainOwner {
		n += 2
	}
	l = len(m.Cname)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	if len(m.BillingFlags) > 0 {
		for _, e := range m.BillingFlags {
			l = e.Size()
			n += 2 + l + sovPublicCustomapi(uint64(l))
		}
	}
	if m.CreationTimestamp != nil {
		l = m.CreationTimestamp.Size()
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Company)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	if m.PlanType != 0 {
		n += 2 + sovPublicCustomapi(uint64(m.PlanType))
	}
	l = len(m.ActivePlanTransitionUid)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	if m.Disabled {
		n += 3
	}
	l = len(m.TenantState)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	if len(m.TenantFlags) > 0 {
		for k, v := range m.TenantFlags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + 1 + 1
			n += mapEntrySize + 2 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	if m.LastLoginTimestamp != nil {
		l = m.LastLoginTimestamp.Size()
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	if m.State != 0 {
		n += 2 + sovPublicCustomapi(uint64(m.State))
	}
	if len(m.TileAccess) > 0 {
		for k, v := range m.TileAccess {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicCustomapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	if len(m.AddonServiceStatus) > 0 {
		for k, v := range m.AddonServiceStatus {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicCustomapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	l = len(m.Environment)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.TosVersion)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	if m.TosAcceptedAt != nil {
		l = m.TosAcceptedAt.Size()
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	if len(m.GroupNames) > 0 {
		for _, s := range m.GroupNames {
			l = len(s)
			n += 2 + l + sovPublicCustomapi(uint64(l))
		}
	}
	l = len(m.OriginalTenant)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	if m.NamespaceAccess != nil {
		l = m.NamespaceAccess.Size()
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	if m.SyncMode != 0 {
		n += 2 + sovPublicCustomapi(uint64(m.SyncMode))
	}
	l = len(m.UserUuid)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.BillingPlanName)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	if m.ManagedAccessInfo != nil {
		n += m.ManagedAccessInfo.Size()
	}
	if m.AccessType != 0 {
		n += 2 + sovPublicCustomapi(uint64(m.AccessType))
	}
	if m.SignupOrigin != 0 {
		n += 2 + sovPublicCustomapi(uint64(m.SignupOrigin))
	}
	return n
}

func (m *GetUserRoleResponse_SelfManaged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SelfManaged != nil {
		l = m.SelfManaged.Size()
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}
func (m *GetUserRoleResponse_MspManaged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MspManaged != nil {
		l = m.MspManaged.Size()
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}
func (m *MSPManaged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tier != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Tier))
	}
	l = len(m.MspId)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.ParentTenantId)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.NodeType != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.NodeType))
	}
	return n
}

func (m *CascadeDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *CascadeDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeleteOk {
		n += 2
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	return n
}

func (m *CascadeDeleteItemType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ObjectType)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.ObjectUid)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.ObjectName)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *AcceptTOSRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.TosAccepted)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.TosVersion)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.TosAcceptedAt != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.TosAcceptedAt))
	}
	return n
}

func (m *AcceptTOSResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetTOSRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *GetTOSResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *FeatureFlagType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.Disabled {
		n += 2
	}
	return n
}

func (m *UserGroupRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if len(m.GroupNames) > 0 {
		for _, s := range m.GroupNames {
			l = len(s)
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	return n
}

func (m *UserGroupResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func sovPublicCustomapi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPublicCustomapi(x uint64) (n int) {
	return sovPublicCustomapi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *BillingFeatureIndicator) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BillingFeatureIndicator{`,
		`BillingFlag:` + fmt.Sprintf("%v", this.BillingFlag) + `,`,
		`Failed:` + fmt.Sprintf("%v", this.Failed) + `,`,
		`AdditionalInfo:` + fmt.Sprintf("%v", this.AdditionalInfo) + `,`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SendPasswordEmailRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SendPasswordEmailRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SendPasswordEmailResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SendPasswordEmailResponse{`,
		`}`,
	}, "")
	return s
}
func (this *ResetPasswordByAdminRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResetPasswordByAdminRequest{`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NamespacesRoleType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NamespacesRoleType{`,
		`Namespaces:` + fmt.Sprintf("%v", this.Namespaces) + `,`,
		`Role:` + fmt.Sprintf("%v", this.Role) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UserRoleRequest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNamespaceRoles := "[]*NamespaceRoleType{"
	for _, f := range this.NamespaceRoles {
		repeatedStringForNamespaceRoles += strings.Replace(fmt.Sprintf("%v", f), "NamespaceRoleType", "schema.NamespaceRoleType", 1) + ","
	}
	repeatedStringForNamespaceRoles += "}"
	s := strings.Join([]string{`&UserRoleRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`FirstName:` + fmt.Sprintf("%v", this.FirstName) + `,`,
		`LastName:` + fmt.Sprintf("%v", this.LastName) + `,`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`NamespaceRoles:` + repeatedStringForNamespaceRoles + `,`,
		`IdmType:` + fmt.Sprintf("%v", this.IdmType) + `,`,
		`GroupNames:` + fmt.Sprintf("%v", this.GroupNames) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListUserRoleRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListUserRoleRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AssignRoleRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AssignRoleRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`NamespacesRole:` + strings.Replace(this.NamespacesRole.String(), "NamespacesRoleType", "NamespacesRoleType", 1) + `,`,
		`Username:` + fmt.Sprintf("%v", this.Username) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListUserRoleResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*ListUserRoleResponseItem{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "ListUserRoleResponseItem", "ListUserRoleResponseItem", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&ListUserRoleResponse{`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListUserRoleResponseItem) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNamespaceRoles := "[]*NamespaceRoleType{"
	for _, f := range this.NamespaceRoles {
		repeatedStringForNamespaceRoles += strings.Replace(fmt.Sprintf("%v", f), "NamespaceRoleType", "schema.NamespaceRoleType", 1) + ","
	}
	repeatedStringForNamespaceRoles += "}"
	s := strings.Join([]string{`&ListUserRoleResponseItem{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`FirstName:` + fmt.Sprintf("%v", this.FirstName) + `,`,
		`LastName:` + fmt.Sprintf("%v", this.LastName) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`NamespaceRoles:` + repeatedStringForNamespaceRoles + `,`,
		`Tenant:` + fmt.Sprintf("%v", this.Tenant) + `,`,
		`TenantType:` + fmt.Sprintf("%v", this.TenantType) + `,`,
		`IdmType:` + fmt.Sprintf("%v", this.IdmType) + `,`,
		`DomainOwner:` + fmt.Sprintf("%v", this.DomainOwner) + `,`,
		`OtpEnabled:` + fmt.Sprintf("%v", this.OtpEnabled) + `,`,
		`Disabled:` + fmt.Sprintf("%v", this.Disabled) + `,`,
		`CreationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.CreationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`LastLoginTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.LastLoginTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`GroupNames:` + fmt.Sprintf("%v", this.GroupNames) + `,`,
		`SyncMode:` + fmt.Sprintf("%v", this.SyncMode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetUserRoleRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetUserRoleRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetUserRoleResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNamespaceRoles := "[]*NamespaceRoleType{"
	for _, f := range this.NamespaceRoles {
		repeatedStringForNamespaceRoles += strings.Replace(fmt.Sprintf("%v", f), "NamespaceRoleType", "schema.NamespaceRoleType", 1) + ","
	}
	repeatedStringForNamespaceRoles += "}"
	repeatedStringForFeatureFlags := "[]*FeatureFlagType{"
	for _, f := range this.FeatureFlags {
		repeatedStringForFeatureFlags += strings.Replace(f.String(), "FeatureFlagType", "FeatureFlagType", 1) + ","
	}
	repeatedStringForFeatureFlags += "}"
	repeatedStringForBillingFlags := "[]*BillingFeatureIndicator{"
	for _, f := range this.BillingFlags {
		repeatedStringForBillingFlags += strings.Replace(f.String(), "BillingFeatureIndicator", "BillingFeatureIndicator", 1) + ","
	}
	repeatedStringForBillingFlags += "}"
	keysForTenantFlags := make([]string, 0, len(this.TenantFlags))
	for k, _ := range this.TenantFlags {
		keysForTenantFlags = append(keysForTenantFlags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTenantFlags)
	mapStringForTenantFlags := "map[string]bool{"
	for _, k := range keysForTenantFlags {
		mapStringForTenantFlags += fmt.Sprintf("%v: %v,", k, this.TenantFlags[k])
	}
	mapStringForTenantFlags += "}"
	keysForTileAccess := make([]string, 0, len(this.TileAccess))
	for k, _ := range this.TileAccess {
		keysForTileAccess = append(keysForTileAccess, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTileAccess)
	mapStringForTileAccess := "map[string]*TileAccess{"
	for _, k := range keysForTileAccess {
		mapStringForTileAccess += fmt.Sprintf("%v: %v,", k, this.TileAccess[k])
	}
	mapStringForTileAccess += "}"
	keysForAddonServiceStatus := make([]string, 0, len(this.AddonServiceStatus))
	for k, _ := range this.AddonServiceStatus {
		keysForAddonServiceStatus = append(keysForAddonServiceStatus, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAddonServiceStatus)
	mapStringForAddonServiceStatus := "map[string]*AddonServiceStatus{"
	for _, k := range keysForAddonServiceStatus {
		mapStringForAddonServiceStatus += fmt.Sprintf("%v: %v,", k, this.AddonServiceStatus[k])
	}
	mapStringForAddonServiceStatus += "}"
	s := strings.Join([]string{`&GetUserRoleResponse{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`FirstName:` + fmt.Sprintf("%v", this.FirstName) + `,`,
		`LastName:` + fmt.Sprintf("%v", this.LastName) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`NamespaceRoles:` + repeatedStringForNamespaceRoles + `,`,
		`Tenant:` + fmt.Sprintf("%v", this.Tenant) + `,`,
		`TenantType:` + fmt.Sprintf("%v", this.TenantType) + `,`,
		`FeatureFlags:` + repeatedStringForFeatureFlags + `,`,
		`TosCurrentVersion:` + fmt.Sprintf("%v", this.TosCurrentVersion) + `,`,
		`TosAccepted:` + fmt.Sprintf("%v", this.TosAccepted) + `,`,
		`IdmType:` + fmt.Sprintf("%v", this.IdmType) + `,`,
		`DomainOwner:` + fmt.Sprintf("%v", this.DomainOwner) + `,`,
		`Cname:` + fmt.Sprintf("%v", this.Cname) + `,`,
		`BillingFlags:` + repeatedStringForBillingFlags + `,`,
		`CreationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.CreationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`Company:` + fmt.Sprintf("%v", this.Company) + `,`,
		`PlanType:` + fmt.Sprintf("%v", this.PlanType) + `,`,
		`ActivePlanTransitionUid:` + fmt.Sprintf("%v", this.ActivePlanTransitionUid) + `,`,
		`Disabled:` + fmt.Sprintf("%v", this.Disabled) + `,`,
		`TenantState:` + fmt.Sprintf("%v", this.TenantState) + `,`,
		`TenantFlags:` + mapStringForTenantFlags + `,`,
		`LastLoginTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.LastLoginTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`TileAccess:` + mapStringForTileAccess + `,`,
		`AddonServiceStatus:` + mapStringForAddonServiceStatus + `,`,
		`Environment:` + fmt.Sprintf("%v", this.Environment) + `,`,
		`TosVersion:` + fmt.Sprintf("%v", this.TosVersion) + `,`,
		`TosAcceptedAt:` + strings.Replace(fmt.Sprintf("%v", this.TosAcceptedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`GroupNames:` + fmt.Sprintf("%v", this.GroupNames) + `,`,
		`OriginalTenant:` + fmt.Sprintf("%v", this.OriginalTenant) + `,`,
		`NamespaceAccess:` + strings.Replace(fmt.Sprintf("%v", this.NamespaceAccess), "NamespaceAccessType", "schema.NamespaceAccessType", 1) + `,`,
		`SyncMode:` + fmt.Sprintf("%v", this.SyncMode) + `,`,
		`UserUuid:` + fmt.Sprintf("%v", this.UserUuid) + `,`,
		`BillingPlanName:` + fmt.Sprintf("%v", this.BillingPlanName) + `,`,
		`ManagedAccessInfo:` + fmt.Sprintf("%v", this.ManagedAccessInfo) + `,`,
		`AccessType:` + fmt.Sprintf("%v", this.AccessType) + `,`,
		`SignupOrigin:` + fmt.Sprintf("%v", this.SignupOrigin) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetUserRoleResponse_SelfManaged) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetUserRoleResponse_SelfManaged{`,
		`SelfManaged:` + strings.Replace(fmt.Sprintf("%v", this.SelfManaged), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetUserRoleResponse_MspManaged) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetUserRoleResponse_MspManaged{`,
		`MspManaged:` + strings.Replace(fmt.Sprintf("%v", this.MspManaged), "MSPManaged", "MSPManaged", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MSPManaged) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MSPManaged{`,
		`Tier:` + fmt.Sprintf("%v", this.Tier) + `,`,
		`MspId:` + fmt.Sprintf("%v", this.MspId) + `,`,
		`ParentTenantId:` + fmt.Sprintf("%v", this.ParentTenantId) + `,`,
		`NodeType:` + fmt.Sprintf("%v", this.NodeType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CascadeDeleteRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CascadeDeleteRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CascadeDeleteResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*CascadeDeleteItemType{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "CascadeDeleteItemType", "CascadeDeleteItemType", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&CascadeDeleteResponse{`,
		`DeleteOk:` + fmt.Sprintf("%v", this.DeleteOk) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *CascadeDeleteItemType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CascadeDeleteItemType{`,
		`ObjectType:` + fmt.Sprintf("%v", this.ObjectType) + `,`,
		`ObjectUid:` + fmt.Sprintf("%v", this.ObjectUid) + `,`,
		`ObjectName:` + fmt.Sprintf("%v", this.ObjectName) + `,`,
		`ErrorMessage:` + fmt.Sprintf("%v", this.ErrorMessage) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AcceptTOSRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AcceptTOSRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`TosAccepted:` + fmt.Sprintf("%v", this.TosAccepted) + `,`,
		`TosVersion:` + fmt.Sprintf("%v", this.TosVersion) + `,`,
		`TosAcceptedAt:` + fmt.Sprintf("%v", this.TosAcceptedAt) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AcceptTOSResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AcceptTOSResponse{`,
		`}`,
	}, "")
	return s
}
func (this *GetTOSRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetTOSRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetTOSResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetTOSResponse{`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Text:` + fmt.Sprintf("%v", this.Text) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Empty) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Empty{`,
		`}`,
	}, "")
	return s
}
func (this *FeatureFlagType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FeatureFlagType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Disabled:` + fmt.Sprintf("%v", this.Disabled) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UserGroupRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UserGroupRequest{`,
		`Username:` + fmt.Sprintf("%v", this.Username) + `,`,
		`GroupNames:` + fmt.Sprintf("%v", this.GroupNames) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UserGroupResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UserGroupResponse{`,
		`Error:` + strings.Replace(fmt.Sprintf("%v", this.Error), "ErrorType", "schema.ErrorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringPublicCustomapi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *BillingFeatureIndicator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BillingFeatureIndicator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BillingFeatureIndicator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BillingFlag", wireType)
			}
			m.BillingFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BillingFlag |= BillingFlag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Failed = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdditionalInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= BillingFlagAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendPasswordEmailRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendPasswordEmailRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendPasswordEmailRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendPasswordEmailResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendPasswordEmailResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendPasswordEmailResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetPasswordByAdminRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetPasswordByAdminRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetPasswordByAdminRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespacesRoleType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespacesRoleType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespacesRoleType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespaces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespaces = append(m.Namespaces, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRoleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRoleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRoleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= UserType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceRoles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamespaceRoles = append(m.NamespaceRoles, &schema.NamespaceRoleType{})
			if err := m.NamespaceRoles[len(m.NamespaceRoles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdmType", wireType)
			}
			m.IdmType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdmType |= IdmType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupNames = append(m.GroupNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUserRoleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUserRoleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUserRoleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssignRoleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssignRoleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssignRoleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespacesRole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NamespacesRole == nil {
				m.NamespacesRole = &NamespacesRoleType{}
			}
			if err := m.NamespacesRole.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = append(m.Username, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUserRoleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUserRoleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUserRoleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ListUserRoleResponseItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUserRoleResponseItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUserRoleResponseItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUserRoleResponseItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= UserType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceRoles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamespaceRoles = append(m.NamespaceRoles, &schema.NamespaceRoleType{})
			if err := m.NamespaceRoles[len(m.NamespaceRoles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantType", wireType)
			}
			m.TenantType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantType |= schema.TenantType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdmType", wireType)
			}
			m.IdmType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdmType |= IdmType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainOwner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DomainOwner = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtpEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OtpEnabled = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreationTimestamp == nil {
				m.CreationTimestamp = &types.Timestamp{}
			}
			if err := m.CreationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLoginTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastLoginTimestamp == nil {
				m.LastLoginTimestamp = &types.Timestamp{}
			}
			if err := m.LastLoginTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupNames = append(m.GroupNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncMode", wireType)
			}
			m.SyncMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SyncMode |= schema.SyncMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserRoleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserRoleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserRoleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserRoleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserRoleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserRoleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= UserType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceRoles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamespaceRoles = append(m.NamespaceRoles, &schema.NamespaceRoleType{})
			if err := m.NamespaceRoles[len(m.NamespaceRoles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantType", wireType)
			}
			m.TenantType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantType |= schema.TenantType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureFlags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeatureFlags = append(m.FeatureFlags, &FeatureFlagType{})
			if err := m.FeatureFlags[len(m.FeatureFlags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TosCurrentVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TosCurrentVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TosAccepted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TosAccepted = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdmType", wireType)
			}
			m.IdmType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdmType |= IdmType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainOwner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DomainOwner = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BillingFlags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BillingFlags = append(m.BillingFlags, &BillingFeatureIndicator{})
			if err := m.BillingFlags[len(m.BillingFlags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreationTimestamp == nil {
				m.CreationTimestamp = &types.Timestamp{}
			}
			if err := m.CreationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Company", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Company = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanType", wireType)
			}
			m.PlanType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlanType |= schema.PlanType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivePlanTransitionUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActivePlanTransitionUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantFlags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TenantFlags == nil {
				m.TenantFlags = make(map[string]bool)
			}
			var mapkey string
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TenantFlags[mapkey] = mapvalue
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLoginTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastLoginTimestamp == nil {
				m.LastLoginTimestamp = &types.Timestamp{}
			}
			if err := m.LastLoginTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= FSMState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TileAccess", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TileAccess == nil {
				m.TileAccess = make(map[string]*TileAccess)
			}
			var mapkey string
			var mapvalue *TileAccess
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TileAccess{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TileAccess[mapkey] = mapvalue
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddonServiceStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddonServiceStatus == nil {
				m.AddonServiceStatus = make(map[string]*AddonServiceStatus)
			}
			var mapkey string
			var mapvalue *AddonServiceStatus
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AddonServiceStatus{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AddonServiceStatus[mapkey] = mapvalue
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Environment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Environment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TosVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TosVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TosAcceptedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TosAcceptedAt == nil {
				m.TosAcceptedAt = &types.Timestamp{}
			}
			if err := m.TosAcceptedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupNames = append(m.GroupNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalTenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginalTenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceAccess", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NamespaceAccess == nil {
				m.NamespaceAccess = &schema.NamespaceAccessType{}
			}
			if err := m.NamespaceAccess.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncMode", wireType)
			}
			m.SyncMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SyncMode |= schema.SyncMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BillingPlanName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BillingPlanName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfManaged", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ManagedAccessInfo = &GetUserRoleResponse_SelfManaged{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MspManaged", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MSPManaged{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ManagedAccessInfo = &GetUserRoleResponse_MspManaged{v}
			iNdEx = postIndex
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessType", wireType)
			}
			m.AccessType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessType |= AccessType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignupOrigin", wireType)
			}
			m.SignupOrigin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignupOrigin |= schema.SignupOrigin(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MSPManaged) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MSPManaged: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MSPManaged: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tier", wireType)
			}
			m.Tier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tier |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MspId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MspId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentTenantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentTenantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeType", wireType)
			}
			m.NodeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeType |= MSPNodeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CascadeDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CascadeDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CascadeDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CascadeDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CascadeDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CascadeDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteOk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeleteOk = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &CascadeDeleteItemType{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CascadeDeleteItemType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CascadeDeleteItemType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CascadeDeleteItemType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptTOSRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptTOSRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptTOSRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TosAccepted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TosAccepted = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TosVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TosVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TosAcceptedAt", wireType)
			}
			m.TosAcceptedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TosAcceptedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptTOSResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptTOSResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptTOSResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTOSRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTOSRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTOSRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTOSResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTOSResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTOSResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureFlagType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureFlagType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureFlagType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserGroupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserGroupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserGroupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupNames = append(m.GroupNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserGroupResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserGroupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserGroupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &schema.ErrorType{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPublicCustomapi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPublicCustomapi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPublicCustomapi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPublicCustomapi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPublicCustomapi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPublicCustomapi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPublicCustomapi = fmt.Errorf("proto: unexpected end of group")
)
