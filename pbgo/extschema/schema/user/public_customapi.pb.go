// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/user/public_customapi.proto

// User management API
//
// x-displayName: "User"
// This API can be used to manage various attributes of the user like
// role, contact information etc.

package user

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/vesenv"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Billing flag
//
// x-displayName: "Billing flag"
// Possible billing flags used to indicate problems with customer billing.
type BillingFlag int32

const (
	// customer has a valid payment method on our file
	// x-displayName: "Valid payment method"
	VALID_PAYMENT_METHOD BillingFlag = 0
	// customer has at least one overdue invoice with with us
	// x-displayName: "Overdue invoice exists on customers file"
	OVERDUE_INVOICE BillingFlag = 1
	// status of customer's last transaction. a retry may be triggered so this is an early warning.
	// x-displayName: "Customer's last transaction is flagged as failed"
	LAST_TRANSACTION_STATUS BillingFlag = 2
	// this flag is on when the customer has no but expired payment method on it's file.
	// x-displayName: "All payment methods are expired"
	PAYMENT_METHOD_EXPIRED BillingFlag = 3
	// x-displayName: "We could not charge your primary payment method due to insufficient funds"
	// We could not charge your primary payment method due to insufficient funds
	PAYMENT_METHOD_INSUFFICIENT_FUNDS BillingFlag = 4
	// x-displayName: "Your primary payment method was declined"
	// Your primary payment method was declined
	PAYMENT_METHOD_PRIMARY_DECLINED BillingFlag = 5
	// x-displayName: "Security code for your primary payment method is incorrect"
	// Security code for your primary payment method is incorrect
	PAYMENT_METHOD_CVC_INVALID BillingFlag = 6
	// x-displayName: "ZIP code for your primary payment method is incorrect"
	// ZIP code for your primary payment method is incorrect
	PAYMENT_METHOD_ZIP_INVALID BillingFlag = 7
	// x-displayName: "We could not charge your primary payment method due to insufficient funds. Your secondary payment method was charged"
	// We could not charge your primary payment method due to insufficient funds. Your secondary payment method was charged
	PAYMENT_METHOD_INSUFFICIENT_FUNDS_SECONDARY_CHARGED BillingFlag = 8
	// x-displayName: "Your primary payment method has expired. Your secondary payment method was charged"
	// Your primary payment method has expired. Your secondary payment method was charged
	PAYMENT_METHOD_PRIMARY_EXPIRED_SECONDARY_CHARGED BillingFlag = 9
	// x-displayName: "Your primary payment method was declined. Your secondary payment method was charged"
	// Your primary payment method was declined. Your secondary payment method was charged
	PAYMENT_METHOD_PRIMARY_DECLINED_SECONDARY_CHARGED BillingFlag = 10
	// x-displayName: "We could not charge any of the active payment methods"
	// We could not charge any of the active payment methods
	PAYMENT_METHOD_BOTH_PAYMENT_METHOD_FAILED BillingFlag = 11
	// x-displayName: "We could not charge any of the active payment methods"
	// We could not charge any of the active payment methods
	PAYMENT_METHOD_GENERIC_FAILURE BillingFlag = 1000
	// x-displayName: "Adding a payment method resulted in an error"
	// Adding a payment method resulted in an error
	PAYMENT_METHOD_GENERIC_ADD_FAILURE BillingFlag = 1001
)

var BillingFlag_name = map[int32]string{
	0:    "VALID_PAYMENT_METHOD",
	1:    "OVERDUE_INVOICE",
	2:    "LAST_TRANSACTION_STATUS",
	3:    "PAYMENT_METHOD_EXPIRED",
	4:    "PAYMENT_METHOD_INSUFFICIENT_FUNDS",
	5:    "PAYMENT_METHOD_PRIMARY_DECLINED",
	6:    "PAYMENT_METHOD_CVC_INVALID",
	7:    "PAYMENT_METHOD_ZIP_INVALID",
	8:    "PAYMENT_METHOD_INSUFFICIENT_FUNDS_SECONDARY_CHARGED",
	9:    "PAYMENT_METHOD_PRIMARY_EXPIRED_SECONDARY_CHARGED",
	10:   "PAYMENT_METHOD_PRIMARY_DECLINED_SECONDARY_CHARGED",
	11:   "PAYMENT_METHOD_BOTH_PAYMENT_METHOD_FAILED",
	1000: "PAYMENT_METHOD_GENERIC_FAILURE",
	1001: "PAYMENT_METHOD_GENERIC_ADD_FAILURE",
}

var BillingFlag_value = map[string]int32{
	"VALID_PAYMENT_METHOD":                                0,
	"OVERDUE_INVOICE":                                     1,
	"LAST_TRANSACTION_STATUS":                             2,
	"PAYMENT_METHOD_EXPIRED":                              3,
	"PAYMENT_METHOD_INSUFFICIENT_FUNDS":                   4,
	"PAYMENT_METHOD_PRIMARY_DECLINED":                     5,
	"PAYMENT_METHOD_CVC_INVALID":                          6,
	"PAYMENT_METHOD_ZIP_INVALID":                          7,
	"PAYMENT_METHOD_INSUFFICIENT_FUNDS_SECONDARY_CHARGED": 8,
	"PAYMENT_METHOD_PRIMARY_EXPIRED_SECONDARY_CHARGED":    9,
	"PAYMENT_METHOD_PRIMARY_DECLINED_SECONDARY_CHARGED":   10,
	"PAYMENT_METHOD_BOTH_PAYMENT_METHOD_FAILED":           11,
	"PAYMENT_METHOD_GENERIC_FAILURE":                      1000,
	"PAYMENT_METHOD_GENERIC_ADD_FAILURE":                  1001,
}

func (BillingFlag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{0}
}

// Billing flag action
//
// x-displayName: "Billing flag action"
// Action to be executed when customer click on the UI warning
type BillingFlagAction int32

const (
	// we don't expect customer to take any actoon
	// x-displayName: "No action required"
	NO_ACTION BillingFlagAction = 0
	// customer should provide a new payment method
	// x-displayName: "Add new payment method"
	ADD_NEW_PAYMENT_METHOD BillingFlagAction = 1
	// customer should send us an email
	// x-displayName: "Contact us"
	CONTACT_US BillingFlagAction = 2
)

var BillingFlagAction_name = map[int32]string{
	0: "NO_ACTION",
	1: "ADD_NEW_PAYMENT_METHOD",
	2: "CONTACT_US",
}

var BillingFlagAction_value = map[string]int32{
	"NO_ACTION":              0,
	"ADD_NEW_PAYMENT_METHOD": 1,
	"CONTACT_US":             2,
}

func (BillingFlagAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{1}
}

// Billing Feature Indicator
//
// x-displayName: "Billing feature indicator"
// Single instance of a billing indicator.
// It informs the customer of any problems with their billing, including failed payments, overdue invoices, or missing valid payment methods.
type BillingFeatureIndicator struct {
	// Billing flag name
	//
	// x-displayName: "Billing flag"
	// Name of the billing feature this flag relates to
	BillingFlag BillingFlag `protobuf:"varint,1,opt,name=billing_flag,json=billingFlag,proto3,enum=ves.io.schema.user.BillingFlag" json:"billing_flag,omitempty"`
	// Failed
	//
	// x-displayName: "Failed"
	// x-example: "true"
	// If true then the billing feature is failed and to be looked into.
	Failed bool `protobuf:"varint,2,opt,name=failed,proto3" json:"failed,omitempty"`
	// Additional info
	//
	// x-displayName: "Additional info"
	// x-example: "payment failed due to insufficient funds"
	// Any description (such as error message) related to this billing feature.
	AdditionalInfo string `protobuf:"bytes,3,opt,name=additional_info,json=additionalInfo,proto3" json:"additional_info,omitempty"`
	// Action the customer should take
	//
	// x-displayName: "Action to be performed"
	// Indicate an action the customer should make to mitigate the warning.
	Action BillingFlagAction `protobuf:"varint,4,opt,name=action,proto3,enum=ves.io.schema.user.BillingFlagAction" json:"action,omitempty"`
}

func (m *BillingFeatureIndicator) Reset()      { *m = BillingFeatureIndicator{} }
func (*BillingFeatureIndicator) ProtoMessage() {}
func (*BillingFeatureIndicator) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{0}
}
func (m *BillingFeatureIndicator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BillingFeatureIndicator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BillingFeatureIndicator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BillingFeatureIndicator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BillingFeatureIndicator.Merge(m, src)
}
func (m *BillingFeatureIndicator) XXX_Size() int {
	return m.Size()
}
func (m *BillingFeatureIndicator) XXX_DiscardUnknown() {
	xxx_messageInfo_BillingFeatureIndicator.DiscardUnknown(m)
}

var xxx_messageInfo_BillingFeatureIndicator proto.InternalMessageInfo

func (m *BillingFeatureIndicator) GetBillingFlag() BillingFlag {
	if m != nil {
		return m.BillingFlag
	}
	return VALID_PAYMENT_METHOD
}

func (m *BillingFeatureIndicator) GetFailed() bool {
	if m != nil {
		return m.Failed
	}
	return false
}

func (m *BillingFeatureIndicator) GetAdditionalInfo() string {
	if m != nil {
		return m.AdditionalInfo
	}
	return ""
}

func (m *BillingFeatureIndicator) GetAction() BillingFlagAction {
	if m != nil {
		return m.Action
	}
	return NO_ACTION
}

// Send password email request
//
// x-displayName: "Send Password Email Request"
// SendPasswordEmailRequest is the request parameters for sending the password update.
// Note that only admin is allowed to resend the password for users.
type SendPasswordEmailRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Value of namespace is always "system"
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// email of the user
	//
	// x-displayName: "Email"
	// x-example: "value"
	// x-required
	// email of the user requesting for
	Email string `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
}

func (m *SendPasswordEmailRequest) Reset()      { *m = SendPasswordEmailRequest{} }
func (*SendPasswordEmailRequest) ProtoMessage() {}
func (*SendPasswordEmailRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{1}
}
func (m *SendPasswordEmailRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendPasswordEmailRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendPasswordEmailRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendPasswordEmailRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendPasswordEmailRequest.Merge(m, src)
}
func (m *SendPasswordEmailRequest) XXX_Size() int {
	return m.Size()
}
func (m *SendPasswordEmailRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SendPasswordEmailRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SendPasswordEmailRequest proto.InternalMessageInfo

func (m *SendPasswordEmailRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *SendPasswordEmailRequest) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

// Send password email response
//
// x-displayName: "Send Password Email Response"
// SendPasswordEmailResponse is an empty response after an email had been sent.
type SendPasswordEmailResponse struct {
}

func (m *SendPasswordEmailResponse) Reset()      { *m = SendPasswordEmailResponse{} }
func (*SendPasswordEmailResponse) ProtoMessage() {}
func (*SendPasswordEmailResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{2}
}
func (m *SendPasswordEmailResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendPasswordEmailResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendPasswordEmailResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendPasswordEmailResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendPasswordEmailResponse.Merge(m, src)
}
func (m *SendPasswordEmailResponse) XXX_Size() int {
	return m.Size()
}
func (m *SendPasswordEmailResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SendPasswordEmailResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SendPasswordEmailResponse proto.InternalMessageInfo

// Reset password by admin request
//
// x-displayName: "Reset password by admin request"
// Reset password by admin request contains email of user for which password will be reset.
type ResetPasswordByAdminRequest struct {
	// Email
	//
	// x-displayName: "Email"
	// x-example: "john@example.com"
	// x-required
	// Email of user for which password will be reset.
	Email string `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
}

func (m *ResetPasswordByAdminRequest) Reset()      { *m = ResetPasswordByAdminRequest{} }
func (*ResetPasswordByAdminRequest) ProtoMessage() {}
func (*ResetPasswordByAdminRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{3}
}
func (m *ResetPasswordByAdminRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResetPasswordByAdminRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResetPasswordByAdminRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResetPasswordByAdminRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetPasswordByAdminRequest.Merge(m, src)
}
func (m *ResetPasswordByAdminRequest) XXX_Size() int {
	return m.Size()
}
func (m *ResetPasswordByAdminRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetPasswordByAdminRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResetPasswordByAdminRequest proto.InternalMessageInfo

func (m *ResetPasswordByAdminRequest) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

// Namespace Role Type
//
// x-displayName: "Namespace Role Type"
// Association of a role to namespaces
type NamespacesRoleType struct {
	// Namespaces
	//
	// x-displayName: "Namespaces"
	// x-example: "value"
	// Namespace, including star (`*`) which means all tenant's namespaces
	Namespaces []string `protobuf:"bytes,1,rep,name=namespaces,proto3" json:"namespaces,omitempty"`
	// Role
	//
	// x-displayName: "Role"
	// x-example: "value"
	// Users role for this namespace
	Role string `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`
}

func (m *NamespacesRoleType) Reset()      { *m = NamespacesRoleType{} }
func (*NamespacesRoleType) ProtoMessage() {}
func (*NamespacesRoleType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{4}
}
func (m *NamespacesRoleType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamespacesRoleType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NamespacesRoleType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NamespacesRoleType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamespacesRoleType.Merge(m, src)
}
func (m *NamespacesRoleType) XXX_Size() int {
	return m.Size()
}
func (m *NamespacesRoleType) XXX_DiscardUnknown() {
	xxx_messageInfo_NamespacesRoleType.DiscardUnknown(m)
}

var xxx_messageInfo_NamespacesRoleType proto.InternalMessageInfo

func (m *NamespacesRoleType) GetNamespaces() []string {
	if m != nil {
		return m.Namespaces
	}
	return nil
}

func (m *NamespacesRoleType) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

// Namespace role
//
// x-displayName: "Namespace Role"
// Allows linking namespaces and roles
type NamespaceRoleType struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// x-required
	// Namespace the role applies to
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Role
	//
	// x-displayName: "Role"
	// x-example: "value"
	// x-required
	// Users role for this namespace
	Role string `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`
}

func (m *NamespaceRoleType) Reset()      { *m = NamespaceRoleType{} }
func (*NamespaceRoleType) ProtoMessage() {}
func (*NamespaceRoleType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{5}
}
func (m *NamespaceRoleType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamespaceRoleType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NamespaceRoleType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NamespaceRoleType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamespaceRoleType.Merge(m, src)
}
func (m *NamespaceRoleType) XXX_Size() int {
	return m.Size()
}
func (m *NamespaceRoleType) XXX_DiscardUnknown() {
	xxx_messageInfo_NamespaceRoleType.DiscardUnknown(m)
}

var xxx_messageInfo_NamespaceRoleType proto.InternalMessageInfo

func (m *NamespaceRoleType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *NamespaceRoleType) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

// User role
//
// x-displayName: "User Role"
// Allows creation of a user along with their roles in namespaces.
type UserRoleRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Tenant's namespace (system)
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// name
	//
	// x-displayName: "Name"
	// x-example: "value"
	// user spec (name and so on)
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// first name
	//
	// x-displayName: "First Name"
	// x-example: "value"
	// x-required
	// User's first name
	FirstName string `protobuf:"bytes,3,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	// last name
	//
	// x-displayName: "Last Name"
	// x-example: "value"
	// x-required
	// User's last name
	LastName string `protobuf:"bytes,4,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
	// email
	//
	// x-displayName: "Email Address"
	// x-example: "value"
	// x-required
	// user's email
	Email string `protobuf:"bytes,5,opt,name=email,proto3" json:"email,omitempty"`
	// User type
	//
	// x-displayName: "User Type"
	// Type of the user account (USER, SERVICE)
	Type UserType `protobuf:"varint,6,opt,name=type,proto3,enum=ves.io.schema.user.UserType" json:"type,omitempty"`
	// Namespace roles
	//
	// x-displayName: "Namespace Roles"
	// List of roles that the user has for each namespace.
	NamespaceRoles []*NamespaceRoleType `protobuf:"bytes,7,rep,name=namespace_roles,json=namespaceRoles,proto3" json:"namespace_roles,omitempty"`
	// IDM Type
	//
	// x-displayName: "Identity Management Type"
	// Type of the Identity management
	IdmType IdmType `protobuf:"varint,8,opt,name=idm_type,json=idmType,proto3,enum=ves.io.schema.user.IdmType" json:"idm_type,omitempty"`
}

func (m *UserRoleRequest) Reset()      { *m = UserRoleRequest{} }
func (*UserRoleRequest) ProtoMessage() {}
func (*UserRoleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{6}
}
func (m *UserRoleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserRoleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserRoleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserRoleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRoleRequest.Merge(m, src)
}
func (m *UserRoleRequest) XXX_Size() int {
	return m.Size()
}
func (m *UserRoleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRoleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UserRoleRequest proto.InternalMessageInfo

func (m *UserRoleRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *UserRoleRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UserRoleRequest) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *UserRoleRequest) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *UserRoleRequest) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *UserRoleRequest) GetType() UserType {
	if m != nil {
		return m.Type
	}
	return USER
}

func (m *UserRoleRequest) GetNamespaceRoles() []*NamespaceRoleType {
	if m != nil {
		return m.NamespaceRoles
	}
	return nil
}

func (m *UserRoleRequest) GetIdmType() IdmType {
	if m != nil {
		return m.IdmType
	}
	return SSO
}

// List user roles
//
// x-displayName: "List User Roles"
// Allows list user roles in a namespace
type ListUserRoleRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Namespace to use
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *ListUserRoleRequest) Reset()      { *m = ListUserRoleRequest{} }
func (*ListUserRoleRequest) ProtoMessage() {}
func (*ListUserRoleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{7}
}
func (m *ListUserRoleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListUserRoleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListUserRoleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListUserRoleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUserRoleRequest.Merge(m, src)
}
func (m *ListUserRoleRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListUserRoleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUserRoleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListUserRoleRequest proto.InternalMessageInfo

func (m *ListUserRoleRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// Assign role
//
// x-displayName: "Assign Role"
// Allows user role in namespace assignment
type AssignRoleRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Namespace the requesting user is calling the action from
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Namespace role
	//
	// x-displayName: "Namespace Role"
	// namespace role to assign
	NamespacesRole *NamespacesRoleType `protobuf:"bytes,2,opt,name=namespaces_role,json=namespacesRole,proto3" json:"namespaces_role,omitempty"`
	// Username
	//
	// x-displayName: "Username"
	// x-example: "value"
	// name of the users we want to assign the role to (we query the tenant/system_namespace for the usernames)
	Username []string `protobuf:"bytes,3,rep,name=username,proto3" json:"username,omitempty"`
}

func (m *AssignRoleRequest) Reset()      { *m = AssignRoleRequest{} }
func (*AssignRoleRequest) ProtoMessage() {}
func (*AssignRoleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{8}
}
func (m *AssignRoleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssignRoleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssignRoleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssignRoleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssignRoleRequest.Merge(m, src)
}
func (m *AssignRoleRequest) XXX_Size() int {
	return m.Size()
}
func (m *AssignRoleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AssignRoleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AssignRoleRequest proto.InternalMessageInfo

func (m *AssignRoleRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *AssignRoleRequest) GetNamespacesRole() *NamespacesRoleType {
	if m != nil {
		return m.NamespacesRole
	}
	return nil
}

func (m *AssignRoleRequest) GetUsername() []string {
	if m != nil {
		return m.Username
	}
	return nil
}

// List user roles
//
// x-displayName: "List User Roles"
// Allows user namespace roles retrieval
type ListUserRoleResponse struct {
	// User namespace roles
	//
	// x-displayName: "User Namespace Roles"
	// List of user namespace roles
	Items []*ListUserRoleResponseItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *ListUserRoleResponse) Reset()      { *m = ListUserRoleResponse{} }
func (*ListUserRoleResponse) ProtoMessage() {}
func (*ListUserRoleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{9}
}
func (m *ListUserRoleResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListUserRoleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListUserRoleResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListUserRoleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUserRoleResponse.Merge(m, src)
}
func (m *ListUserRoleResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListUserRoleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUserRoleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListUserRoleResponse proto.InternalMessageInfo

func (m *ListUserRoleResponse) GetItems() []*ListUserRoleResponseItem {
	if m != nil {
		return m.Items
	}
	return nil
}

// List user role
//
// x-displayName: "List User Role"
// Allows user namespace role retrieval
type ListUserRoleResponseItem struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Namespace of the user object (namespace where the user object is stored).
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Name
	//
	// x-displayName: "Name"
	// x-example: "value"
	// name of the user
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Email
	//
	// x-displayName: "Email Address"
	// x-example: "value"
	// Email of the user object
	Email string `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
	// First name
	//
	// x-displayName: "First Name"
	// x-example: "value"
	// First name of the customer
	FirstName string `protobuf:"bytes,4,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	// Last name
	//
	// x-displayName: "Last Name"
	// x-example: "value"
	// Last name of the customer
	LastName string `protobuf:"bytes,5,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
	// User type
	//
	// x-displayName: "User Type"
	// Type of the user account (USER, SERVICE)
	Type UserType `protobuf:"varint,6,opt,name=type,proto3,enum=ves.io.schema.user.UserType" json:"type,omitempty"`
	// Namespace roles
	//
	// x-displayName: "Namespace Roles"
	// Namespace roles for the user
	NamespaceRoles []*NamespaceRoleType `protobuf:"bytes,7,rep,name=namespace_roles,json=namespaceRoles,proto3" json:"namespace_roles,omitempty"`
	// Tenant
	//
	// x-displayName: "Tenant"
	// x-example: "value"
	// tenant that the user belongs to
	Tenant string `protobuf:"bytes,8,opt,name=tenant,proto3" json:"tenant,omitempty"`
	// Tenant type
	//
	// x-displayName: "Tenant Type"
	// tenant type of the user (FREEMIUM, ENTERPRISE, ...)
	TenantType schema.TenantType `protobuf:"varint,9,opt,name=tenant_type,json=tenantType,proto3,enum=ves.io.schema.TenantType" json:"tenant_type,omitempty"`
	// IDM type
	//
	// x-displayName: "Identity Management Type"
	// Identity management type of the user (Volterra Managed, SSO)
	IdmType IdmType `protobuf:"varint,10,opt,name=idm_type,json=idmType,proto3,enum=ves.io.schema.user.IdmType" json:"idm_type,omitempty"`
	//  Domain Owner
	//
	// x-displayName: "Domain Owner"
	// x-example: "true"
	// Domain owner is the first user who registered or signed up the associated Tenant.
	// User created via signup flow will have this value set to true.
	// Few restrictions apply to this user w.r.t role update and deletion.
	DomainOwner bool `protobuf:"varint,11,opt,name=domain_owner,json=domainOwner,proto3" json:"domain_owner,omitempty"`
	// OTP Enabled
	//
	// x-displayName: "OTP Enabled"
	// Shows if OTP is enabled in IDM Provider.
	OtpEnabled bool `protobuf:"varint,12,opt,name=otp_enabled,json=otpEnabled,proto3" json:"otp_enabled,omitempty"`
	// Disabled
	//
	// x-displayName: "Disabled"
	// If set to true user is completely disabled including IDM.
	Disabled bool `protobuf:"varint,13,opt,name=disabled,proto3" json:"disabled,omitempty"`
	// Creation timestamp
	//
	// x-displayName: "Creation timestamp"
	// Timestamp of user creation.
	CreationTimestamp *types.Timestamp `protobuf:"bytes,14,opt,name=creation_timestamp,json=creationTimestamp,proto3" json:"creation_timestamp,omitempty"`
	// Last login timestamp
	//
	// x-displayName: "Last login timestamp"
	// Last login timestamp when user successfully login to access VoltConsole.
	LastLoginTimestamp *types.Timestamp `protobuf:"bytes,15,opt,name=last_login_timestamp,json=lastLoginTimestamp,proto3" json:"last_login_timestamp,omitempty"`
}

func (m *ListUserRoleResponseItem) Reset()      { *m = ListUserRoleResponseItem{} }
func (*ListUserRoleResponseItem) ProtoMessage() {}
func (*ListUserRoleResponseItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{10}
}
func (m *ListUserRoleResponseItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListUserRoleResponseItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListUserRoleResponseItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListUserRoleResponseItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUserRoleResponseItem.Merge(m, src)
}
func (m *ListUserRoleResponseItem) XXX_Size() int {
	return m.Size()
}
func (m *ListUserRoleResponseItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUserRoleResponseItem.DiscardUnknown(m)
}

var xxx_messageInfo_ListUserRoleResponseItem proto.InternalMessageInfo

func (m *ListUserRoleResponseItem) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ListUserRoleResponseItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListUserRoleResponseItem) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *ListUserRoleResponseItem) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *ListUserRoleResponseItem) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *ListUserRoleResponseItem) GetType() UserType {
	if m != nil {
		return m.Type
	}
	return USER
}

func (m *ListUserRoleResponseItem) GetNamespaceRoles() []*NamespaceRoleType {
	if m != nil {
		return m.NamespaceRoles
	}
	return nil
}

func (m *ListUserRoleResponseItem) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *ListUserRoleResponseItem) GetTenantType() schema.TenantType {
	if m != nil {
		return m.TenantType
	}
	return schema.UNKNOWN
}

func (m *ListUserRoleResponseItem) GetIdmType() IdmType {
	if m != nil {
		return m.IdmType
	}
	return SSO
}

func (m *ListUserRoleResponseItem) GetDomainOwner() bool {
	if m != nil {
		return m.DomainOwner
	}
	return false
}

func (m *ListUserRoleResponseItem) GetOtpEnabled() bool {
	if m != nil {
		return m.OtpEnabled
	}
	return false
}

func (m *ListUserRoleResponseItem) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

func (m *ListUserRoleResponseItem) GetCreationTimestamp() *types.Timestamp {
	if m != nil {
		return m.CreationTimestamp
	}
	return nil
}

func (m *ListUserRoleResponseItem) GetLastLoginTimestamp() *types.Timestamp {
	if m != nil {
		return m.LastLoginTimestamp
	}
	return nil
}

// Get user role
//
// x-displayName: "Get User Role"
// Allows user namespace role retrieval
type GetUserRoleRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Namespace of the user object (namespace where the user object is stored).
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *GetUserRoleRequest) Reset()      { *m = GetUserRoleRequest{} }
func (*GetUserRoleRequest) ProtoMessage() {}
func (*GetUserRoleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{11}
}
func (m *GetUserRoleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUserRoleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUserRoleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUserRoleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUserRoleRequest.Merge(m, src)
}
func (m *GetUserRoleRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetUserRoleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUserRoleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetUserRoleRequest proto.InternalMessageInfo

func (m *GetUserRoleRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// User role
//
// x-displayName: "User Role"
// Allows user and roles retrieval
type GetUserRoleResponse struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Namespace of the user object (namespace where the user object is stored).
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Name
	//
	// x-displayName: "Name"
	// x-example: "value"
	// name of the user
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Email
	//
	// x-displayName: "Email Address"
	// x-example: "value"
	// Email of the user object
	Email string `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
	// First name
	//
	// x-displayName: "First Name"
	// x-example: "value"
	// First name of the customer
	FirstName string `protobuf:"bytes,4,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	// Last name
	//
	// x-displayName: "Last Name"
	// x-example: "value"
	// Last name of the customer
	LastName string `protobuf:"bytes,5,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
	// User type
	//
	// x-displayName: "User Type"
	// Type of the user account (USER, SERVICE)
	Type UserType `protobuf:"varint,6,opt,name=type,proto3,enum=ves.io.schema.user.UserType" json:"type,omitempty"`
	// Namespace roles
	//
	// x-displayName: "Namespace Roles"
	// Namespace roles for the user
	NamespaceRoles []*NamespaceRoleType `protobuf:"bytes,7,rep,name=namespace_roles,json=namespaceRoles,proto3" json:"namespace_roles,omitempty"`
	// Tenant
	//
	// x-displayName: "Tenant"
	// x-example: "value"
	// tenant that the user belongs to
	Tenant string `protobuf:"bytes,8,opt,name=tenant,proto3" json:"tenant,omitempty"`
	// Tenant type
	//
	// x-displayName: "Tenant Type"
	// tenant type of the user (FREEMIUM, ENTERPRISE, ...)
	TenantType schema.TenantType `protobuf:"varint,9,opt,name=tenant_type,json=tenantType,proto3,enum=ves.io.schema.TenantType" json:"tenant_type,omitempty"`
	// Feature flag type
	//
	// x-displayName: "Feature Flag Type"
	// feature flag that shows whether this feature should be enabled on UI for the current plan
	FeatureFlags []*FeatureFlagType `protobuf:"bytes,10,rep,name=feature_flags,json=featureFlags,proto3" json:"feature_flags,omitempty"`
	// tos_current_version
	//
	// x-displayName: "TOS Current Version"
	// x-example: "value"
	// tos current version
	TosCurrentVersion string `protobuf:"bytes,11,opt,name=tos_current_version,json=tosCurrentVersion,proto3" json:"tos_current_version,omitempty"`
	// tos_accepted
	//
	// x-displayName: "TOS Accepted"
	// x-example: "value"
	// tos accepted version
	TosAccepted string `protobuf:"bytes,12,opt,name=tos_accepted,json=tosAccepted,proto3" json:"tos_accepted,omitempty"`
	// IDM type
	//
	// x-displayName: "Identity Management Type"
	// Identity management type of the user (Volterra Managed, SSO)
	IdmType IdmType `protobuf:"varint,13,opt,name=idm_type,json=idmType,proto3,enum=ves.io.schema.user.IdmType" json:"idm_type,omitempty"`
	//  Domain Owner
	//
	// x-displayName: "Domain Owner"
	// x-example: "true"
	// Domain owner is the first user who registered or signed up the associated Tenant.
	// User created via signup flow will have this value set to true.
	// Few restrictions apply to this user w.r.t role update and deletion.
	DomainOwner bool `protobuf:"varint,15,opt,name=domain_owner,json=domainOwner,proto3" json:"domain_owner,omitempty"`
	// Cname
	// x-displayName: "CName"
	// x-example: "web"
	// CName via tenant will be accessed from url. <cname>.<domain>
	Cname string `protobuf:"bytes,16,opt,name=cname,proto3" json:"cname,omitempty"`
	// Billing flags
	// x-displayName: "Billing flags"
	// Collection of flags informing the customer of any billing related problems, such as overdue invoices.
	BillingFlags []*BillingFeatureIndicator `protobuf:"bytes,17,rep,name=billing_flags,json=billingFlags,proto3" json:"billing_flags,omitempty"`
	// Creation Timestamp
	// x-displayName: "Creation Timestamp"
	// User object creation timestamp
	CreationTimestamp *types.Timestamp `protobuf:"bytes,18,opt,name=creation_timestamp,json=creationTimestamp,proto3" json:"creation_timestamp,omitempty"`
	// Company name
	// x-displayName: "Company"
	// x-example: "Acme Ltd."
	// Legal name of the company the user/tenant belongs to
	Company string `protobuf:"bytes,19,opt,name=company,proto3" json:"company,omitempty"`
	// Plan type
	//
	// x-displayName: "Plan Type"
	// plan type the tenant is subscribed to (FREE, INDIVIDUAL, TEAM, ORGANIZATION, ...)
	PlanType schema.PlanType `protobuf:"varint,20,opt,name=plan_type,json=planType,proto3,enum=ves.io.schema.PlanType" json:"plan_type,omitempty"`
	// Active plan transition id
	//
	// x-displayName: "Active plan transition id"
	// UUID of the plan transition request which is currently in progress. This field is empty
	// if there is no such request.
	ActivePlanTransitionUid string `protobuf:"bytes,21,opt,name=active_plan_transition_uid,json=activePlanTransitionUid,proto3" json:"active_plan_transition_uid,omitempty"`
	// Disabled
	//
	// x-displayName: "Disabled"
	// If set to true user is completely disabled including IDM.
	Disabled bool `protobuf:"varint,22,opt,name=disabled,proto3" json:"disabled,omitempty"`
	// Tenant State
	//
	// x-displayName: "Tenant State"
	// Contains information about current state of the tenant.
	TenantState string `protobuf:"bytes,23,opt,name=tenant_state,json=tenantState,proto3" json:"tenant_state,omitempty"`
	// Tenant Flags
	//
	// x-displayName: "Tenant Flags"
	// Contains information about tenant configuration for giving UI instructions to show specific sections.
	TenantFlags map[string]bool `protobuf:"bytes,24,rep,name=tenant_flags,json=tenantFlags,proto3" json:"tenant_flags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// State
	//
	// x-displayName: "State"
	// Contains information about current user state.
	State FSMState `protobuf:"varint,26,opt,name=state,proto3,enum=ves.io.schema.user.FSMState" json:"state,omitempty"`
	// Last login timestamp
	//
	// x-displayName: "Last login timestamp"
	// Last login timestamp when user successfully login to access VoltConsole.
	LastLoginTimestamp *types.Timestamp `protobuf:"bytes,25,opt,name=last_login_timestamp,json=lastLoginTimestamp,proto3" json:"last_login_timestamp,omitempty"`
}

func (m *GetUserRoleResponse) Reset()      { *m = GetUserRoleResponse{} }
func (*GetUserRoleResponse) ProtoMessage() {}
func (*GetUserRoleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{12}
}
func (m *GetUserRoleResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUserRoleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUserRoleResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUserRoleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUserRoleResponse.Merge(m, src)
}
func (m *GetUserRoleResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetUserRoleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUserRoleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetUserRoleResponse proto.InternalMessageInfo

func (m *GetUserRoleResponse) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *GetUserRoleResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetUserRoleResponse) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *GetUserRoleResponse) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *GetUserRoleResponse) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *GetUserRoleResponse) GetType() UserType {
	if m != nil {
		return m.Type
	}
	return USER
}

func (m *GetUserRoleResponse) GetNamespaceRoles() []*NamespaceRoleType {
	if m != nil {
		return m.NamespaceRoles
	}
	return nil
}

func (m *GetUserRoleResponse) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *GetUserRoleResponse) GetTenantType() schema.TenantType {
	if m != nil {
		return m.TenantType
	}
	return schema.UNKNOWN
}

func (m *GetUserRoleResponse) GetFeatureFlags() []*FeatureFlagType {
	if m != nil {
		return m.FeatureFlags
	}
	return nil
}

func (m *GetUserRoleResponse) GetTosCurrentVersion() string {
	if m != nil {
		return m.TosCurrentVersion
	}
	return ""
}

func (m *GetUserRoleResponse) GetTosAccepted() string {
	if m != nil {
		return m.TosAccepted
	}
	return ""
}

func (m *GetUserRoleResponse) GetIdmType() IdmType {
	if m != nil {
		return m.IdmType
	}
	return SSO
}

func (m *GetUserRoleResponse) GetDomainOwner() bool {
	if m != nil {
		return m.DomainOwner
	}
	return false
}

func (m *GetUserRoleResponse) GetCname() string {
	if m != nil {
		return m.Cname
	}
	return ""
}

func (m *GetUserRoleResponse) GetBillingFlags() []*BillingFeatureIndicator {
	if m != nil {
		return m.BillingFlags
	}
	return nil
}

func (m *GetUserRoleResponse) GetCreationTimestamp() *types.Timestamp {
	if m != nil {
		return m.CreationTimestamp
	}
	return nil
}

func (m *GetUserRoleResponse) GetCompany() string {
	if m != nil {
		return m.Company
	}
	return ""
}

func (m *GetUserRoleResponse) GetPlanType() schema.PlanType {
	if m != nil {
		return m.PlanType
	}
	return schema.FREE
}

func (m *GetUserRoleResponse) GetActivePlanTransitionUid() string {
	if m != nil {
		return m.ActivePlanTransitionUid
	}
	return ""
}

func (m *GetUserRoleResponse) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

func (m *GetUserRoleResponse) GetTenantState() string {
	if m != nil {
		return m.TenantState
	}
	return ""
}

func (m *GetUserRoleResponse) GetTenantFlags() map[string]bool {
	if m != nil {
		return m.TenantFlags
	}
	return nil
}

func (m *GetUserRoleResponse) GetState() FSMState {
	if m != nil {
		return m.State
	}
	return StateUndefined
}

func (m *GetUserRoleResponse) GetLastLoginTimestamp() *types.Timestamp {
	if m != nil {
		return m.LastLoginTimestamp
	}
	return nil
}

// CascadeDeleteRequest
//
// x-displayName: "Delete the User and Associated Namespace Roles"
// CascadeDeleteRequest is the request to delete the user along with the associated namespace role objects.
// Note: only admin is allowed to delete the user and associated objects.
type CascadeDeleteRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Value of namespace is always "system"
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// email of the user
	//
	// x-displayName: "Email"
	// x-example: "value"
	// x-required
	// email of the user requesting for
	Email string `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
}

func (m *CascadeDeleteRequest) Reset()      { *m = CascadeDeleteRequest{} }
func (*CascadeDeleteRequest) ProtoMessage() {}
func (*CascadeDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{13}
}
func (m *CascadeDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CascadeDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CascadeDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CascadeDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CascadeDeleteRequest.Merge(m, src)
}
func (m *CascadeDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *CascadeDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CascadeDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CascadeDeleteRequest proto.InternalMessageInfo

func (m *CascadeDeleteRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *CascadeDeleteRequest) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

// CascadeDeleteResponse
//
// x-displayName: "Delete Response for the User and Associated Namespace Roles"
// CascadeDeleteResponse contains a list of user objects that were deleted
// and possibly any errors when attempting to delete those objects.
type CascadeDeleteResponse struct {
	// delete_ok
	//
	// x-displayName: "Delete Ok"
	// x-example: "true"
	// status of the deleted objects.
	// "true" value indicates that the operation had been successful for all the objects.
	// "false" value indicates that at least one of the delete operations had been unsuccessful.
	DeleteOk bool `protobuf:"varint,1,opt,name=delete_ok,json=deleteOk,proto3" json:"delete_ok,omitempty"`
	// items
	//
	// x-displayName: "Items"
	// The objects deleted for the specific user
	Items []*CascadeDeleteItemType `protobuf:"bytes,2,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *CascadeDeleteResponse) Reset()      { *m = CascadeDeleteResponse{} }
func (*CascadeDeleteResponse) ProtoMessage() {}
func (*CascadeDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{14}
}
func (m *CascadeDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CascadeDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CascadeDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CascadeDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CascadeDeleteResponse.Merge(m, src)
}
func (m *CascadeDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *CascadeDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CascadeDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CascadeDeleteResponse proto.InternalMessageInfo

func (m *CascadeDeleteResponse) GetDeleteOk() bool {
	if m != nil {
		return m.DeleteOk
	}
	return false
}

func (m *CascadeDeleteResponse) GetItems() []*CascadeDeleteItemType {
	if m != nil {
		return m.Items
	}
	return nil
}

// CascadeDeleteItemType
//
// x-displayName: "Cascade Deletion of User and Associated Namespace Roles"
// CascadeDeleteItemType contains details of object that was handled as part of cascade delete
// of user and whether it was successfully deleted
type CascadeDeleteItemType struct {
	// object's type
	//
	// x-displayName: "Object Type"
	// x-example: "value"
	// The type of the object
	ObjectType string `protobuf:"bytes,1,opt,name=object_type,json=objectType,proto3" json:"object_type,omitempty"`
	// object's uid
	//
	// x-displayName: "Object Uid"
	// x-example: "value"
	// The uid of the object
	ObjectUid string `protobuf:"bytes,2,opt,name=object_uid,json=objectUid,proto3" json:"object_uid,omitempty"`
	// object's name
	//
	// x-displayName: "Object Name"
	// x-example: "value"
	// Name of the object
	ObjectName string `protobuf:"bytes,3,opt,name=object_name,json=objectName,proto3" json:"object_name,omitempty"`
	// error message
	//
	// x-displayName: "Error Message"
	// x-example: "value"
	// informative error message about the success or failure of the object's deletion response
	ErrorMessage string `protobuf:"bytes,4,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *CascadeDeleteItemType) Reset()      { *m = CascadeDeleteItemType{} }
func (*CascadeDeleteItemType) ProtoMessage() {}
func (*CascadeDeleteItemType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{15}
}
func (m *CascadeDeleteItemType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CascadeDeleteItemType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CascadeDeleteItemType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CascadeDeleteItemType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CascadeDeleteItemType.Merge(m, src)
}
func (m *CascadeDeleteItemType) XXX_Size() int {
	return m.Size()
}
func (m *CascadeDeleteItemType) XXX_DiscardUnknown() {
	xxx_messageInfo_CascadeDeleteItemType.DiscardUnknown(m)
}

var xxx_messageInfo_CascadeDeleteItemType proto.InternalMessageInfo

func (m *CascadeDeleteItemType) GetObjectType() string {
	if m != nil {
		return m.ObjectType
	}
	return ""
}

func (m *CascadeDeleteItemType) GetObjectUid() string {
	if m != nil {
		return m.ObjectUid
	}
	return ""
}

func (m *CascadeDeleteItemType) GetObjectName() string {
	if m != nil {
		return m.ObjectName
	}
	return ""
}

func (m *CascadeDeleteItemType) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

// Accept TOS request model
//
// x-displayName: "Accept TOS Request"
// Accept TOS request model
type AcceptTOSRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Value of namespace is always "system"
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// tos_accepted
	//
	// x-displayName: "TOS Accepted"
	// x-example: "value"
	// tos accepted version
	TosAccepted string `protobuf:"bytes,2,opt,name=tos_accepted,json=tosAccepted,proto3" json:"tos_accepted,omitempty"`
}

func (m *AcceptTOSRequest) Reset()      { *m = AcceptTOSRequest{} }
func (*AcceptTOSRequest) ProtoMessage() {}
func (*AcceptTOSRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{16}
}
func (m *AcceptTOSRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptTOSRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptTOSRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptTOSRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptTOSRequest.Merge(m, src)
}
func (m *AcceptTOSRequest) XXX_Size() int {
	return m.Size()
}
func (m *AcceptTOSRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptTOSRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptTOSRequest proto.InternalMessageInfo

func (m *AcceptTOSRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *AcceptTOSRequest) GetTosAccepted() string {
	if m != nil {
		return m.TosAccepted
	}
	return ""
}

// Accept TOS response model
//
// x-displayName: "Accept TOS Response"
// Accept TOS response model
type AcceptTOSResponse struct {
}

func (m *AcceptTOSResponse) Reset()      { *m = AcceptTOSResponse{} }
func (*AcceptTOSResponse) ProtoMessage() {}
func (*AcceptTOSResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{17}
}
func (m *AcceptTOSResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptTOSResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptTOSResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptTOSResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptTOSResponse.Merge(m, src)
}
func (m *AcceptTOSResponse) XXX_Size() int {
	return m.Size()
}
func (m *AcceptTOSResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptTOSResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptTOSResponse proto.InternalMessageInfo

// Get TOS request model
//
// x-displayName: "Get TOS Request"
// Get TOS request model
type GetTOSRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// Value of namespace is always "system"
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *GetTOSRequest) Reset()      { *m = GetTOSRequest{} }
func (*GetTOSRequest) ProtoMessage() {}
func (*GetTOSRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{18}
}
func (m *GetTOSRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTOSRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTOSRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTOSRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTOSRequest.Merge(m, src)
}
func (m *GetTOSRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTOSRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTOSRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTOSRequest proto.InternalMessageInfo

func (m *GetTOSRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// Get TOS response model
//
// x-displayName: "Get TOS Response"
// Get TOS response model
type GetTOSResponse struct {
	// Version
	//
	// x-displayName: "TOS Version"
	// x-example: "value"
	// Value of TOS version
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// Text
	//
	// x-displayName: "TOS Text"
	// x-example: "value"
	// Value of TOS text
	Text string `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
}

func (m *GetTOSResponse) Reset()      { *m = GetTOSResponse{} }
func (*GetTOSResponse) ProtoMessage() {}
func (*GetTOSResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{19}
}
func (m *GetTOSResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTOSResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTOSResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTOSResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTOSResponse.Merge(m, src)
}
func (m *GetTOSResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTOSResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTOSResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTOSResponse proto.InternalMessageInfo

func (m *GetTOSResponse) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *GetTOSResponse) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

// Empty
//
// x-displayName: "Empty"
// Empty is a message without actual content/body.
type Empty struct {
}

func (m *Empty) Reset()      { *m = Empty{} }
func (*Empty) ProtoMessage() {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{20}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

// FeatureFlagType
// x-displayName: "Feature and its Status for the Tenant's Plan"
type FeatureFlagType struct {
	// feature's name
	//
	// x-displayName: "Feature Name"
	// x-example: "value"
	// Name of the feature
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// disabled
	//
	// x-displayName "Disabled"
	// x-example: "true"
	// status of whether this feature should be disabled for current plan
	Disabled bool `protobuf:"varint,2,opt,name=disabled,proto3" json:"disabled,omitempty"`
}

func (m *FeatureFlagType) Reset()      { *m = FeatureFlagType{} }
func (*FeatureFlagType) ProtoMessage() {}
func (*FeatureFlagType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ce53d51230acf0d, []int{21}
}
func (m *FeatureFlagType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeatureFlagType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeatureFlagType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeatureFlagType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeatureFlagType.Merge(m, src)
}
func (m *FeatureFlagType) XXX_Size() int {
	return m.Size()
}
func (m *FeatureFlagType) XXX_DiscardUnknown() {
	xxx_messageInfo_FeatureFlagType.DiscardUnknown(m)
}

var xxx_messageInfo_FeatureFlagType proto.InternalMessageInfo

func (m *FeatureFlagType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FeatureFlagType) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

func init() {
	proto.RegisterEnum("ves.io.schema.user.BillingFlag", BillingFlag_name, BillingFlag_value)
	golang_proto.RegisterEnum("ves.io.schema.user.BillingFlag", BillingFlag_name, BillingFlag_value)
	proto.RegisterEnum("ves.io.schema.user.BillingFlagAction", BillingFlagAction_name, BillingFlagAction_value)
	golang_proto.RegisterEnum("ves.io.schema.user.BillingFlagAction", BillingFlagAction_name, BillingFlagAction_value)
	proto.RegisterType((*BillingFeatureIndicator)(nil), "ves.io.schema.user.BillingFeatureIndicator")
	golang_proto.RegisterType((*BillingFeatureIndicator)(nil), "ves.io.schema.user.BillingFeatureIndicator")
	proto.RegisterType((*SendPasswordEmailRequest)(nil), "ves.io.schema.user.SendPasswordEmailRequest")
	golang_proto.RegisterType((*SendPasswordEmailRequest)(nil), "ves.io.schema.user.SendPasswordEmailRequest")
	proto.RegisterType((*SendPasswordEmailResponse)(nil), "ves.io.schema.user.SendPasswordEmailResponse")
	golang_proto.RegisterType((*SendPasswordEmailResponse)(nil), "ves.io.schema.user.SendPasswordEmailResponse")
	proto.RegisterType((*ResetPasswordByAdminRequest)(nil), "ves.io.schema.user.ResetPasswordByAdminRequest")
	golang_proto.RegisterType((*ResetPasswordByAdminRequest)(nil), "ves.io.schema.user.ResetPasswordByAdminRequest")
	proto.RegisterType((*NamespacesRoleType)(nil), "ves.io.schema.user.NamespacesRoleType")
	golang_proto.RegisterType((*NamespacesRoleType)(nil), "ves.io.schema.user.NamespacesRoleType")
	proto.RegisterType((*NamespaceRoleType)(nil), "ves.io.schema.user.NamespaceRoleType")
	golang_proto.RegisterType((*NamespaceRoleType)(nil), "ves.io.schema.user.NamespaceRoleType")
	proto.RegisterType((*UserRoleRequest)(nil), "ves.io.schema.user.UserRoleRequest")
	golang_proto.RegisterType((*UserRoleRequest)(nil), "ves.io.schema.user.UserRoleRequest")
	proto.RegisterType((*ListUserRoleRequest)(nil), "ves.io.schema.user.ListUserRoleRequest")
	golang_proto.RegisterType((*ListUserRoleRequest)(nil), "ves.io.schema.user.ListUserRoleRequest")
	proto.RegisterType((*AssignRoleRequest)(nil), "ves.io.schema.user.AssignRoleRequest")
	golang_proto.RegisterType((*AssignRoleRequest)(nil), "ves.io.schema.user.AssignRoleRequest")
	proto.RegisterType((*ListUserRoleResponse)(nil), "ves.io.schema.user.ListUserRoleResponse")
	golang_proto.RegisterType((*ListUserRoleResponse)(nil), "ves.io.schema.user.ListUserRoleResponse")
	proto.RegisterType((*ListUserRoleResponseItem)(nil), "ves.io.schema.user.ListUserRoleResponseItem")
	golang_proto.RegisterType((*ListUserRoleResponseItem)(nil), "ves.io.schema.user.ListUserRoleResponseItem")
	proto.RegisterType((*GetUserRoleRequest)(nil), "ves.io.schema.user.GetUserRoleRequest")
	golang_proto.RegisterType((*GetUserRoleRequest)(nil), "ves.io.schema.user.GetUserRoleRequest")
	proto.RegisterType((*GetUserRoleResponse)(nil), "ves.io.schema.user.GetUserRoleResponse")
	golang_proto.RegisterType((*GetUserRoleResponse)(nil), "ves.io.schema.user.GetUserRoleResponse")
	proto.RegisterMapType((map[string]bool)(nil), "ves.io.schema.user.GetUserRoleResponse.TenantFlagsEntry")
	golang_proto.RegisterMapType((map[string]bool)(nil), "ves.io.schema.user.GetUserRoleResponse.TenantFlagsEntry")
	proto.RegisterType((*CascadeDeleteRequest)(nil), "ves.io.schema.user.CascadeDeleteRequest")
	golang_proto.RegisterType((*CascadeDeleteRequest)(nil), "ves.io.schema.user.CascadeDeleteRequest")
	proto.RegisterType((*CascadeDeleteResponse)(nil), "ves.io.schema.user.CascadeDeleteResponse")
	golang_proto.RegisterType((*CascadeDeleteResponse)(nil), "ves.io.schema.user.CascadeDeleteResponse")
	proto.RegisterType((*CascadeDeleteItemType)(nil), "ves.io.schema.user.CascadeDeleteItemType")
	golang_proto.RegisterType((*CascadeDeleteItemType)(nil), "ves.io.schema.user.CascadeDeleteItemType")
	proto.RegisterType((*AcceptTOSRequest)(nil), "ves.io.schema.user.AcceptTOSRequest")
	golang_proto.RegisterType((*AcceptTOSRequest)(nil), "ves.io.schema.user.AcceptTOSRequest")
	proto.RegisterType((*AcceptTOSResponse)(nil), "ves.io.schema.user.AcceptTOSResponse")
	golang_proto.RegisterType((*AcceptTOSResponse)(nil), "ves.io.schema.user.AcceptTOSResponse")
	proto.RegisterType((*GetTOSRequest)(nil), "ves.io.schema.user.GetTOSRequest")
	golang_proto.RegisterType((*GetTOSRequest)(nil), "ves.io.schema.user.GetTOSRequest")
	proto.RegisterType((*GetTOSResponse)(nil), "ves.io.schema.user.GetTOSResponse")
	golang_proto.RegisterType((*GetTOSResponse)(nil), "ves.io.schema.user.GetTOSResponse")
	proto.RegisterType((*Empty)(nil), "ves.io.schema.user.Empty")
	golang_proto.RegisterType((*Empty)(nil), "ves.io.schema.user.Empty")
	proto.RegisterType((*FeatureFlagType)(nil), "ves.io.schema.user.FeatureFlagType")
	golang_proto.RegisterType((*FeatureFlagType)(nil), "ves.io.schema.user.FeatureFlagType")
}

func init() {
	proto.RegisterFile("ves.io/schema/user/public_customapi.proto", fileDescriptor_5ce53d51230acf0d)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/user/public_customapi.proto", fileDescriptor_5ce53d51230acf0d)
}

var fileDescriptor_5ce53d51230acf0d = []byte{
	// 2339 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x59, 0xcd, 0x6f, 0x1b, 0xc7,
	0x15, 0xd7, 0x52, 0xd4, 0x07, 0x1f, 0xf5, 0x41, 0x8d, 0x14, 0x6b, 0x45, 0x39, 0xb4, 0xbd, 0x8a,
	0x63, 0xc9, 0x09, 0x49, 0x57, 0x4e, 0x9a, 0xc4, 0x6d, 0x6d, 0x50, 0x24, 0x65, 0x31, 0x90, 0x49,
	0x61, 0x49, 0xa9, 0x8d, 0x8d, 0x74, 0xb1, 0x22, 0x47, 0xf4, 0xd6, 0xe4, 0xee, 0x76, 0x67, 0x29,
	0x45, 0x29, 0x02, 0x14, 0x41, 0x2f, 0x6d, 0x2f, 0x05, 0x7a, 0xee, 0xc7, 0xa1, 0x05, 0x8a, 0xa2,
	0x87, 0x1e, 0x0b, 0x04, 0x05, 0x72, 0x29, 0x6c, 0xf4, 0xd0, 0xba, 0xed, 0xc5, 0x97, 0x02, 0xb5,
	0xdc, 0x43, 0xda, 0x93, 0xff, 0x84, 0x62, 0x66, 0x76, 0x57, 0xcb, 0xd5, 0x52, 0xa4, 0x65, 0x14,
	0xbd, 0xf4, 0x36, 0xf3, 0xbe, 0xe6, 0xf7, 0xde, 0xbc, 0x79, 0xf3, 0x76, 0x16, 0x56, 0xf6, 0x31,
	0xc9, 0x68, 0x46, 0x96, 0xd4, 0xef, 0xe3, 0xb6, 0x9a, 0xed, 0x10, 0x6c, 0x65, 0xcd, 0xce, 0x6e,
	0x4b, 0xab, 0x2b, 0xf5, 0x0e, 0xb1, 0x8d, 0xb6, 0x6a, 0x6a, 0x19, 0xd3, 0x32, 0x6c, 0x03, 0x21,
	0x2e, 0x9a, 0xe1, 0xa2, 0x19, 0x2a, 0x9a, 0x4c, 0x37, 0x35, 0xfb, 0x7e, 0x67, 0x37, 0x53, 0x37,
	0xda, 0xd9, 0xa6, 0xd1, 0x34, 0xb2, 0x4c, 0x74, 0xb7, 0xb3, 0xc7, 0x66, 0x6c, 0xc2, 0x46, 0xdc,
	0x44, 0xf2, 0x7c, 0xd3, 0x30, 0x9a, 0x2d, 0x9c, 0x55, 0x4d, 0x2d, 0xab, 0xea, 0xba, 0x61, 0xab,
	0xb6, 0x66, 0xe8, 0xc4, 0xe1, 0x5e, 0x70, 0xb8, 0x9e, 0x0d, 0x5b, 0x6b, 0x63, 0x62, 0xab, 0x6d,
	0xd3, 0x11, 0x58, 0xec, 0x06, 0x6b, 0x98, 0x7e, 0xed, 0x85, 0x6e, 0xa6, 0x7d, 0x68, 0x62, 0xcf,
	0x70, 0x88, 0x93, 0xc6, 0xee, 0xb7, 0x70, 0xdd, 0x76, 0x04, 0x52, 0x21, 0x02, 0x7e, 0x03, 0x52,
	0x37, 0x7f, 0x1f, 0x13, 0xac, 0xef, 0x77, 0xaf, 0x2f, 0xfd, 0x5d, 0x80, 0xf9, 0x35, 0xad, 0xd5,
	0xd2, 0xf4, 0xe6, 0x3a, 0x56, 0xed, 0x8e, 0x85, 0x4b, 0x7a, 0x43, 0xab, 0xab, 0xb6, 0x61, 0xa1,
	0x35, 0x98, 0xd8, 0xe5, 0x2c, 0x65, 0xaf, 0xa5, 0x36, 0x45, 0xe1, 0xa2, 0xb0, 0x3c, 0xb5, 0x7a,
	0x21, 0x73, 0x32, 0xa2, 0x19, 0xd7, 0x44, 0x4b, 0x6d, 0xca, 0xf1, 0xdd, 0xe3, 0x09, 0x3a, 0x07,
	0xa3, 0x7b, 0xaa, 0xd6, 0xc2, 0x0d, 0x31, 0x72, 0x51, 0x58, 0x1e, 0x97, 0x9d, 0x19, 0xba, 0x02,
	0xd3, 0x6a, 0xa3, 0xa1, 0x51, 0x28, 0x6a, 0x4b, 0xd1, 0xf4, 0x3d, 0x43, 0x1c, 0xbe, 0x28, 0x2c,
	0xc7, 0xe4, 0xa9, 0x63, 0x72, 0x49, 0xdf, 0x33, 0xd0, 0xd7, 0x60, 0x54, 0xad, 0xd3, 0xb9, 0x18,
	0x65, 0xcb, 0x5f, 0xee, 0xb3, 0x7c, 0x8e, 0x09, 0xcb, 0x8e, 0x92, 0x54, 0x06, 0xb1, 0x8a, 0xf5,
	0xc6, 0x96, 0x4a, 0xc8, 0x81, 0x61, 0x35, 0x8a, 0x6d, 0x55, 0x6b, 0xc9, 0xf8, 0xdb, 0x1d, 0x4c,
	0x6c, 0x74, 0x1e, 0x62, 0xba, 0xda, 0xc6, 0xc4, 0x54, 0xeb, 0x98, 0xc1, 0x8b, 0xc9, 0xc7, 0x04,
	0x34, 0x07, 0x23, 0x98, 0x4a, 0x3b, 0xb8, 0xf8, 0x44, 0x5a, 0x84, 0x85, 0x10, 0x7b, 0xc4, 0x34,
	0x74, 0x82, 0xa5, 0xeb, 0xb0, 0x28, 0x63, 0x82, 0x6d, 0x97, 0xbb, 0x76, 0x98, 0x6b, 0xb4, 0x35,
	0xdd, 0x5d, 0xcf, 0xb3, 0x28, 0xf8, 0x2d, 0x6e, 0x00, 0x2a, 0xbb, 0x8b, 0x12, 0xd9, 0x68, 0xe1,
	0xda, 0xa1, 0x89, 0x51, 0x0a, 0xc0, 0x83, 0x42, 0x44, 0xe1, 0xe2, 0xf0, 0x72, 0x4c, 0xf6, 0x51,
	0x10, 0x82, 0xa8, 0x65, 0xb4, 0x5c, 0xd8, 0x6c, 0x2c, 0x15, 0x61, 0xc6, 0xb3, 0xe4, 0x19, 0xea,
	0x72, 0x52, 0x08, 0x3a, 0x19, 0x66, 0xe6, 0xcf, 0x11, 0x98, 0xde, 0x26, 0xd8, 0xa2, 0x26, 0x42,
	0x43, 0x15, 0x66, 0x85, 0x4e, 0x5c, 0x2b, 0x74, 0x8c, 0x5e, 0x05, 0xd8, 0xd3, 0x2c, 0x62, 0x2b,
	0x8c, 0xc3, 0x63, 0x18, 0x63, 0x14, 0x8a, 0x11, 0x2d, 0x42, 0xac, 0xa5, 0xba, 0xdc, 0x28, 0xe3,
	0x8e, 0x53, 0x02, 0x63, 0x7a, 0x81, 0x1a, 0xf1, 0x05, 0x0a, 0x5d, 0x83, 0x28, 0xcd, 0x6e, 0x71,
	0x94, 0xe5, 0xc1, 0xf9, 0xb0, 0x3c, 0xa0, 0xb0, 0xa9, 0xd7, 0x32, 0x93, 0x44, 0x65, 0x98, 0xf6,
	0x40, 0x2a, 0xd4, 0x37, 0x22, 0x8e, 0x5d, 0x1c, 0x5e, 0x8e, 0x87, 0x27, 0xd1, 0x89, 0xd8, 0xc9,
	0x53, 0xba, 0x9f, 0x44, 0xd0, 0x97, 0x61, 0x5c, 0x6b, 0xb4, 0x15, 0x86, 0x62, 0x9c, 0xa1, 0x58,
	0x0c, 0x33, 0x54, 0x6a, 0xb4, 0x99, 0xfa, 0x98, 0xc6, 0x07, 0xd2, 0x75, 0x98, 0xdd, 0xd4, 0x88,
	0xfd, 0x42, 0x41, 0x95, 0x7e, 0x2a, 0xc0, 0x4c, 0x8e, 0x10, 0xad, 0xa9, 0x0f, 0xbe, 0x11, 0x15,
	0x9f, 0xc3, 0x44, 0xf1, 0x76, 0x36, 0xbe, 0xfa, 0xfa, 0xa9, 0x0e, 0x93, 0x10, 0x8f, 0x19, 0x0d,
	0x25, 0x61, 0x9c, 0x8a, 0x3a, 0x7b, 0x48, 0x93, 0xd0, 0x9b, 0x4b, 0x77, 0x61, 0xae, 0xdb, 0x2b,
	0x7e, 0x0a, 0xd0, 0x1a, 0x8c, 0x68, 0x36, 0x6e, 0xf3, 0xac, 0x8d, 0xaf, 0xbe, 0x19, 0xb6, 0x74,
	0x98, 0x62, 0xc9, 0xc6, 0x6d, 0x99, 0xab, 0x4a, 0xbf, 0x1c, 0x01, 0xb1, 0x97, 0xcc, 0x19, 0x92,
	0x31, 0xf4, 0x2c, 0x07, 0x52, 0x34, 0x7a, 0x6a, 0x8a, 0x8e, 0x04, 0x52, 0xf4, 0x7f, 0x9f, 0x8c,
	0xe7, 0x60, 0xd4, 0xc6, 0xba, 0xaa, 0xdb, 0x2c, 0x15, 0x63, 0xb2, 0x33, 0x43, 0x37, 0x20, 0xce,
	0x47, 0x3c, 0x4f, 0x63, 0x0c, 0xe0, 0x42, 0x60, 0x8d, 0x1a, 0x93, 0x60, 0x76, 0xc1, 0xf6, 0xc6,
	0x5d, 0x09, 0x0e, 0x83, 0x27, 0x38, 0xba, 0x04, 0x13, 0x0d, 0xa3, 0xad, 0x6a, 0xba, 0x62, 0x1c,
	0xe8, 0xd8, 0x12, 0xe3, 0xac, 0xd6, 0xc7, 0x39, 0xad, 0x42, 0x49, 0xe8, 0x02, 0xc4, 0x0d, 0xdb,
	0x54, 0xb0, 0xae, 0xee, 0xd2, 0xdb, 0x60, 0x82, 0x49, 0x80, 0x61, 0x9b, 0x45, 0x4e, 0xa1, 0xa9,
	0xd6, 0xd0, 0x08, 0xe7, 0x4e, 0x32, 0xae, 0x37, 0x47, 0x25, 0x40, 0x75, 0x0b, 0xb3, 0x6b, 0x57,
	0xf1, 0xae, 0x57, 0x71, 0x8a, 0xa5, 0x76, 0x32, 0xc3, 0x2f, 0xe0, 0x8c, 0x7b, 0x01, 0x67, 0x6a,
	0xae, 0x84, 0x3c, 0xe3, 0x6a, 0x79, 0x24, 0xb4, 0x09, 0x73, 0x6c, 0x57, 0x5b, 0x46, 0x53, 0xf3,
	0x1b, 0x9b, 0xee, 0x6b, 0x0c, 0x51, 0xbd, 0x4d, 0xaa, 0xe6, 0xd1, 0xa4, 0x55, 0x40, 0xb7, 0xf1,
	0x0b, 0x1e, 0xec, 0x1f, 0x02, 0xcc, 0x76, 0x29, 0x39, 0xe7, 0xe6, 0xff, 0x69, 0xfd, 0xdf, 0x4a,
	0xeb, 0x0d, 0x98, 0xdc, 0xe3, 0xcd, 0x0d, 0x6b, 0x64, 0x88, 0x08, 0x0c, 0xe1, 0x52, 0x18, 0x42,
	0xa7, 0x0b, 0xa2, 0xad, 0x04, 0xb3, 0x33, 0xb1, 0x77, 0x4c, 0x20, 0x28, 0x03, 0xb3, 0xb6, 0x41,
	0x94, 0x7a, 0xc7, 0xb2, 0xb0, 0x6e, 0x2b, 0xfb, 0xd8, 0x22, 0xb4, 0x35, 0x89, 0x33, 0xa8, 0x33,
	0xb6, 0x41, 0xf2, 0x9c, 0xb3, 0xc3, 0x19, 0xf4, 0x60, 0x50, 0x79, 0xb5, 0x5e, 0xc7, 0xa6, 0xed,
	0xa4, 0x7d, 0x4c, 0x8e, 0xdb, 0x06, 0xc9, 0x39, 0xa4, 0xae, 0x33, 0x37, 0xf9, 0x12, 0x67, 0x6e,
	0xfa, 0xe4, 0x99, 0x9b, 0x83, 0x91, 0x3a, 0xdb, 0xe6, 0x04, 0xcf, 0x0f, 0x36, 0x41, 0x5b, 0x30,
	0xe9, 0x6f, 0xeb, 0x88, 0x38, 0xc3, 0xa2, 0xf1, 0xc6, 0x69, 0x8d, 0x55, 0xa0, 0x35, 0x94, 0x27,
	0x7c, 0x3d, 0x1e, 0xe9, 0x71, 0x3c, 0xd1, 0x59, 0x8e, 0xa7, 0x08, 0x63, 0x75, 0xa3, 0x6d, 0xaa,
	0xfa, 0xa1, 0x38, 0xcb, 0x40, 0xbb, 0x53, 0xf4, 0x16, 0xc4, 0xcc, 0x96, 0xaa, 0xf3, 0x40, 0xcd,
	0xb1, 0x40, 0xcd, 0x07, 0x20, 0x6f, 0xb5, 0x54, 0x9d, 0x05, 0x69, 0xdc, 0x74, 0x46, 0xe8, 0x2b,
	0x90, 0xa4, 0x9d, 0xe0, 0x3e, 0x56, 0xb8, 0xb2, 0xa5, 0xea, 0x84, 0xb5, 0x97, 0x4a, 0x47, 0x6b,
	0x88, 0xaf, 0xb0, 0x25, 0xe6, 0xb9, 0x04, 0xd3, 0xf6, 0xf8, 0xdb, 0x5a, 0x77, 0x49, 0x3a, 0x17,
	0x28, 0x49, 0x74, 0x67, 0x79, 0x3e, 0x12, 0x5b, 0xb5, 0xb1, 0x38, 0xef, 0xec, 0x2c, 0xa3, 0x55,
	0x29, 0x09, 0xdd, 0xf3, 0x44, 0x78, 0x9c, 0x45, 0x16, 0xe7, 0x77, 0xc3, 0xe2, 0x1c, 0x52, 0x0f,
	0x9c, 0x64, 0x66, 0x11, 0x2e, 0xea, 0xb6, 0x75, 0xe8, 0x1a, 0xe7, 0x31, 0x5f, 0x85, 0x11, 0xbe,
	0x70, 0xb2, 0xf7, 0x51, 0x5d, 0xaf, 0xde, 0x61, 0x48, 0x64, 0x2e, 0xda, 0xb3, 0xf6, 0x2d, 0x9c,
	0xa5, 0xf6, 0x25, 0x6f, 0x42, 0x22, 0x08, 0x11, 0x25, 0x60, 0xf8, 0x01, 0x3e, 0x74, 0xaa, 0x17,
	0x1d, 0xd2, 0x1c, 0xdc, 0x57, 0x5b, 0x1d, 0xec, 0xf4, 0xff, 0x7c, 0x72, 0x23, 0xf2, 0xae, 0xf0,
	0x7e, 0x74, 0x7c, 0x2a, 0x31, 0x2d, 0xbd, 0x0f, 0x73, 0x79, 0x95, 0xd4, 0xd5, 0x06, 0x2e, 0xe0,
	0x16, 0xb6, 0x07, 0x6c, 0x74, 0xbc, 0xca, 0x17, 0xf1, 0xb7, 0xd2, 0x1d, 0x78, 0x25, 0x60, 0xcb,
	0x29, 0xad, 0x8b, 0x10, 0x6b, 0x30, 0x8a, 0x62, 0x3c, 0x60, 0xc6, 0xe8, 0x4e, 0x32, 0x42, 0xe5,
	0x01, 0xba, 0xe5, 0xf6, 0x2b, 0x11, 0xb6, 0x3f, 0x2b, 0x61, 0x91, 0xec, 0x32, 0x4b, 0x9b, 0x10,
	0x96, 0x66, 0x4e, 0xb3, 0xf2, 0x13, 0x21, 0xb0, 0xae, 0x2b, 0xc0, 0x2e, 0x3d, 0xf6, 0xc5, 0xc6,
	0xb3, 0x96, 0xbb, 0x01, 0x9c, 0xc4, 0x04, 0x5e, 0x05, 0x67, 0xc6, 0xd2, 0xd1, 0xf9, 0x06, 0xe1,
	0x14, 0x9a, 0x80, 0xc7, 0xfa, 0xbe, 0x2e, 0xda, 0xd1, 0x60, 0xf5, 0x7a, 0x09, 0x26, 0xb1, 0x65,
	0x19, 0x96, 0xd2, 0xc6, 0x84, 0xa8, 0x4d, 0xb7, 0xdc, 0x4f, 0x30, 0xe2, 0x1d, 0x4e, 0x93, 0xaa,
	0x90, 0xe0, 0xd5, 0xa6, 0x56, 0xa9, 0x0e, 0x16, 0xde, 0x60, 0xd9, 0x8a, 0x9c, 0x28, 0x5b, 0xd2,
	0x2c, 0xcc, 0xf8, 0x8c, 0x3a, 0x1f, 0x40, 0x69, 0x98, 0xbc, 0x8d, 0x07, 0x5e, 0x46, 0xba, 0x09,
	0x53, 0xae, 0xb8, 0xb3, 0x51, 0x22, 0x8c, 0xb9, 0x35, 0x95, 0x4b, 0xbb, 0x53, 0x7a, 0xff, 0xd9,
	0xf8, 0x23, 0xdb, 0xbd, 0xff, 0xe8, 0x58, 0x1a, 0x83, 0x91, 0x62, 0xdb, 0xb4, 0x0f, 0xa5, 0x1c,
	0x4c, 0x07, 0xea, 0xb6, 0x77, 0x5f, 0x0a, 0xbe, 0xfb, 0xd2, 0x7f, 0x9e, 0x23, 0xdd, 0xe7, 0xf9,
	0xea, 0x2f, 0xa2, 0x10, 0xf7, 0x7d, 0x46, 0x22, 0x11, 0xe6, 0x76, 0x72, 0x9b, 0xa5, 0x82, 0xb2,
	0x95, 0xfb, 0xe0, 0x4e, 0xb1, 0x5c, 0x53, 0xee, 0x14, 0x6b, 0x1b, 0x95, 0x42, 0x62, 0x08, 0xcd,
	0xc2, 0x74, 0x65, 0xa7, 0x28, 0x17, 0xb6, 0x8b, 0x4a, 0xa9, 0xbc, 0x53, 0x29, 0xe5, 0x8b, 0x09,
	0x01, 0x2d, 0xc2, 0xfc, 0x66, 0xae, 0x5a, 0x53, 0x6a, 0x72, 0xae, 0x5c, 0xcd, 0xe5, 0x6b, 0xa5,
	0x4a, 0x59, 0xa9, 0xd6, 0x72, 0xb5, 0xed, 0x6a, 0x22, 0x82, 0x92, 0x70, 0xae, 0xdb, 0x8a, 0x52,
	0xfc, 0xc6, 0x56, 0x49, 0x2e, 0x16, 0x12, 0xc3, 0xe8, 0x32, 0x5c, 0x0a, 0xf0, 0x4a, 0xe5, 0xea,
	0xf6, 0xfa, 0x7a, 0x29, 0x5f, 0xa2, 0xb4, 0xf5, 0xed, 0x72, 0xa1, 0x9a, 0x88, 0xa2, 0x25, 0xb8,
	0x10, 0x10, 0xdb, 0x92, 0x4b, 0x77, 0x72, 0xf2, 0x07, 0x4a, 0xa1, 0x98, 0xdf, 0x2c, 0x95, 0x8b,
	0x85, 0xc4, 0x08, 0x4a, 0x41, 0x32, 0x20, 0x94, 0xdf, 0xc9, 0x53, 0x90, 0xd4, 0x91, 0xc4, 0x68,
	0x08, 0xff, 0x6e, 0x69, 0xcb, 0xe3, 0x8f, 0xa1, 0x77, 0xe0, 0x7a, 0x5f, 0x2c, 0x4a, 0xb5, 0x98,
	0xaf, 0x94, 0x0b, 0x74, 0xe5, 0xfc, 0x46, 0x4e, 0xbe, 0x5d, 0x2c, 0x24, 0xc6, 0xd1, 0x5b, 0x70,
	0xad, 0x07, 0x3a, 0xc7, 0xd1, 0x10, 0xad, 0x18, 0x7a, 0x1b, 0xbe, 0xd4, 0xc7, 0xa7, 0x10, 0x35,
	0x40, 0x69, 0x58, 0x09, 0xa8, 0xad, 0x55, 0x6a, 0x1b, 0x81, 0x7d, 0x52, 0xd6, 0x73, 0xa5, 0xcd,
	0x62, 0x21, 0x11, 0x47, 0x4b, 0x90, 0x0a, 0xb0, 0x6e, 0x17, 0xcb, 0x45, 0xb9, 0x94, 0x67, 0x22,
	0xdb, 0x72, 0x31, 0xf1, 0xc5, 0x18, 0xba, 0x02, 0x52, 0x0f, 0xa1, 0x5c, 0xa1, 0xe0, 0x09, 0xfe,
	0x6b, 0xec, 0x6a, 0x19, 0x66, 0x4e, 0x3c, 0x36, 0xa0, 0x49, 0x88, 0x95, 0x2b, 0x0a, 0xdf, 0xf5,
	0xc4, 0x10, 0xdd, 0x6e, 0xaa, 0x55, 0x2e, 0x7e, 0x3d, 0x98, 0x3c, 0x02, 0x9a, 0x02, 0xc8, 0x57,
	0xca, 0xb5, 0x5c, 0xbe, 0xa6, 0xd0, 0xd4, 0x58, 0x7d, 0x84, 0x20, 0x96, 0x67, 0x4f, 0x56, 0xb9,
	0xad, 0x12, 0xfa, 0xb9, 0x00, 0xa3, 0x79, 0x7a, 0x27, 0x62, 0xb4, 0xd4, 0xab, 0xf7, 0xf2, 0x35,
	0x9a, 0xc9, 0x64, 0x98, 0x50, 0x85, 0x95, 0x07, 0x69, 0xfb, 0xe8, 0xa1, 0x78, 0x6e, 0x1f, 0x93,
	0xb4, 0x66, 0xa4, 0x3b, 0x6a, 0x3b, 0xad, 0x36, 0xda, 0x9a, 0x9e, 0x3e, 0xb0, 0x34, 0x1b, 0x7f,
	0xfa, 0xb7, 0x7f, 0xfe, 0x38, 0xf2, 0xb6, 0x74, 0xcd, 0x79, 0x33, 0xcb, 0xf2, 0x37, 0xb3, 0xec,
	0xf1, 0xb7, 0x5f, 0xf6, 0x3b, 0xde, 0xf8, 0x13, 0xf6, 0xae, 0xc4, 0x3b, 0xbb, 0x1b, 0xc2, 0x55,
	0xf4, 0xfb, 0x61, 0x18, 0x93, 0xb1, 0xd9, 0xa2, 0x65, 0xe2, 0xa5, 0x31, 0x3e, 0x8f, 0xf4, 0x06,
	0xf9, 0xef, 0x87, 0xe2, 0x13, 0x01, 0x5e, 0x73, 0x98, 0x5c, 0x39, 0x4d, 0x95, 0xd3, 0xde, 0x13,
	0x5f, 0xda, 0x72, 0x80, 0x6c, 0xc0, 0xb0, 0xd9, 0xb1, 0x51, 0xae, 0xb7, 0x43, 0xcb, 0xf7, 0xd4,
	0xf4, 0xc7, 0x1f, 0x2e, 0xdf, 0x4b, 0xab, 0xe9, 0x8f, 0xaf, 0xa5, 0xdf, 0xfb, 0xf0, 0xea, 0x3d,
	0x67, 0xb0, 0x72, 0x6b, 0xc5, 0xe7, 0x21, 0xda, 0x83, 0xa8, 0x69, 0x10, 0x1b, 0x7d, 0xf3, 0xa5,
	0x4d, 0x9d, 0x2a, 0xc7, 0x76, 0x80, 0x24, 0xcf, 0xb2, 0x03, 0x77, 0xbf, 0x2a, 0xbd, 0xf3, 0xa2,
	0x6a, 0x9c, 0xfc, 0x09, 0xdd, 0xbf, 0x5f, 0x0b, 0x10, 0xa5, 0x5f, 0xd6, 0xe8, 0x4a, 0xff, 0xef,
	0x72, 0xbe, 0x81, 0xcb, 0x83, 0x7e, 0xc0, 0x4b, 0x95, 0x47, 0xbf, 0x8b, 0x08, 0x47, 0x0f, 0xc5,
	0x69, 0xdf, 0x8e, 0x5a, 0x58, 0x6d, 0x30, 0x6f, 0x57, 0xd1, 0x0b, 0x7b, 0x4b, 0xc1, 0x0e, 0xdf,
	0xc6, 0x36, 0x7a, 0xbd, 0x6f, 0xcf, 0xc4, 0xa1, 0x5e, 0x19, 0xb0, 0xb7, 0x92, 0x64, 0x07, 0xa9,
	0x9b, 0x7b, 0x07, 0x78, 0x37, 0x4d, 0x6f, 0x3b, 0x42, 0x8e, 0x01, 0x67, 0xd0, 0x9b, 0x83, 0x01,
	0x3e, 0xb8, 0x6f, 0xa8, 0x6d, 0x0d, 0xfd, 0x41, 0x80, 0xc9, 0xae, 0x36, 0x00, 0x2d, 0xf7, 0x6d,
	0x25, 0x5c, 0xe0, 0x2b, 0x03, 0x48, 0x3a, 0xd0, 0x95, 0x3e, 0xe7, 0xfa, 0x96, 0x74, 0x63, 0xf0,
	0x38, 0x93, 0x6c, 0x9d, 0x2f, 0xa2, 0xf0, 0x76, 0x88, 0x66, 0xc8, 0xcf, 0x04, 0x80, 0xe3, 0x87,
	0x27, 0x14, 0xfa, 0x1d, 0x77, 0xe2, 0x61, 0x2a, 0xb9, 0x10, 0x26, 0xc6, 0x6f, 0xe7, 0xca, 0xd1,
	0x43, 0x31, 0xe1, 0x43, 0x7c, 0x86, 0x1a, 0x44, 0xd3, 0x41, 0x61, 0x80, 0x29, 0xc2, 0xbf, 0x08,
	0x30, 0x73, 0xe2, 0x15, 0x16, 0x85, 0x3e, 0x34, 0xf5, 0x7a, 0xfc, 0x4d, 0xa6, 0x07, 0x94, 0xf6,
	0x45, 0x7d, 0xfe, 0x64, 0xb2, 0x1c, 0xbb, 0x72, 0x53, 0x7a, 0x6f, 0x30, 0x57, 0x08, 0xd6, 0x1b,
	0x8a, 0xe9, 0x2c, 0xa2, 0xb0, 0xc6, 0x95, 0xfa, 0xf4, 0x03, 0x01, 0x26, 0xbb, 0x1e, 0x8f, 0x51,
	0xef, 0x88, 0x9e, 0x16, 0xec, 0x7c, 0x3f, 0xa0, 0x92, 0xf4, 0x6a, 0x00, 0xa8, 0x0b, 0x26, 0x6b,
	0xd1, 0xf5, 0x29, 0x98, 0xdf, 0x08, 0x30, 0x17, 0xf6, 0x92, 0x8d, 0xb2, 0x61, 0x0b, 0x9f, 0xf2,
	0xe6, 0x7d, 0x1a, 0xd2, 0x8d, 0x3e, 0x89, 0xbc, 0x2c, 0x2d, 0xf5, 0x02, 0xca, 0x44, 0x15, 0x0f,
	0xee, 0x6f, 0x05, 0x88, 0x79, 0xcd, 0x28, 0x7a, 0x2d, 0x34, 0x61, 0x03, 0x0d, 0x70, 0xf2, 0x72,
	0x1f, 0x29, 0x67, 0xdf, 0x77, 0xfa, 0x85, 0x73, 0xe0, 0x14, 0xe6, 0xcd, 0xb4, 0x62, 0x1b, 0x2c,
	0x85, 0xe9, 0x4d, 0xcf, 0x7b, 0x5f, 0x74, 0xa9, 0x47, 0xd1, 0xf2, 0x81, 0x95, 0x4e, 0x13, 0x09,
	0x14, 0xdf, 0xd3, 0x4a, 0xda, 0x1b, 0x68, 0x65, 0x30, 0xb0, 0xb6, 0x41, 0xd0, 0xf7, 0x04, 0x18,
	0xaf, 0x1e, 0xea, 0x75, 0x5a, 0x3c, 0xcf, 0x98, 0x8c, 0x6b, 0xfd, 0xa2, 0x77, 0x49, 0x3a, 0x1f,
	0x00, 0xa4, 0x35, 0xda, 0xfc, 0x4f, 0x16, 0x39, 0xd4, 0xeb, 0x37, 0x84, 0xab, 0xc9, 0x2b, 0x9f,
	0x7f, 0x26, 0x0c, 0xff, 0xf5, 0x33, 0x61, 0xa1, 0x67, 0x1b, 0xf1, 0xe9, 0x9f, 0xc4, 0xc8, 0x7d,
	0x61, 0xed, 0xfb, 0xc2, 0x1f, 0x6f, 0x46, 0xf3, 0xf2, 0xf6, 0xe6, 0xe3, 0xa7, 0xa9, 0xa1, 0x27,
	0x4f, 0x53, 0x43, 0xcf, 0x9f, 0xa6, 0x84, 0xef, 0x1e, 0xa5, 0x84, 0x5f, 0x1d, 0xa5, 0x84, 0x47,
	0x47, 0x29, 0xe1, 0xf1, 0x51, 0x4a, 0xf8, 0xc7, 0x51, 0x4a, 0xf8, 0xe2, 0x28, 0x35, 0xf4, 0xfc,
	0x28, 0x25, 0xfc, 0xe8, 0x59, 0x6a, 0xe8, 0xf3, 0x67, 0x29, 0xe1, 0xf1, 0xb3, 0xd4, 0xd0, 0x93,
	0x67, 0xa9, 0xa1, 0xbb, 0x1b, 0x4d, 0xc3, 0x7c, 0xd0, 0xcc, 0xec, 0x1b, 0x2d, 0x1b, 0x5b, 0x16,
	0x5d, 0x23, 0xcb, 0x06, 0x7b, 0x86, 0xd5, 0x4e, 0x9b, 0x96, 0xb1, 0xaf, 0x35, 0xb0, 0x95, 0x76,
	0xd9, 0x59, 0x73, 0xb7, 0x69, 0x64, 0xf1, 0x47, 0xb6, 0xf3, 0x7f, 0xcd, 0xf7, 0x1b, 0x6e, 0x77,
	0x94, 0x7d, 0x43, 0x5f, 0xff, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x73, 0xc4, 0xea, 0x80, 0xa9,
	0x1c, 0x00, 0x00,
}

func (x BillingFlag) String() string {
	s, ok := BillingFlag_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x BillingFlagAction) String() string {
	s, ok := BillingFlagAction_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *BillingFeatureIndicator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BillingFeatureIndicator)
	if !ok {
		that2, ok := that.(BillingFeatureIndicator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BillingFlag != that1.BillingFlag {
		return false
	}
	if this.Failed != that1.Failed {
		return false
	}
	if this.AdditionalInfo != that1.AdditionalInfo {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	return true
}
func (this *SendPasswordEmailRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SendPasswordEmailRequest)
	if !ok {
		that2, ok := that.(SendPasswordEmailRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	return true
}
func (this *SendPasswordEmailResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SendPasswordEmailResponse)
	if !ok {
		that2, ok := that.(SendPasswordEmailResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ResetPasswordByAdminRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResetPasswordByAdminRequest)
	if !ok {
		that2, ok := that.(ResetPasswordByAdminRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	return true
}
func (this *NamespacesRoleType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamespacesRoleType)
	if !ok {
		that2, ok := that.(NamespacesRoleType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Namespaces) != len(that1.Namespaces) {
		return false
	}
	for i := range this.Namespaces {
		if this.Namespaces[i] != that1.Namespaces[i] {
			return false
		}
	}
	if this.Role != that1.Role {
		return false
	}
	return true
}
func (this *NamespaceRoleType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamespaceRoleType)
	if !ok {
		that2, ok := that.(NamespaceRoleType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Role != that1.Role {
		return false
	}
	return true
}
func (this *UserRoleRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserRoleRequest)
	if !ok {
		that2, ok := that.(UserRoleRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.FirstName != that1.FirstName {
		return false
	}
	if this.LastName != that1.LastName {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.NamespaceRoles) != len(that1.NamespaceRoles) {
		return false
	}
	for i := range this.NamespaceRoles {
		if !this.NamespaceRoles[i].Equal(that1.NamespaceRoles[i]) {
			return false
		}
	}
	if this.IdmType != that1.IdmType {
		return false
	}
	return true
}
func (this *ListUserRoleRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListUserRoleRequest)
	if !ok {
		that2, ok := that.(ListUserRoleRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	return true
}
func (this *AssignRoleRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AssignRoleRequest)
	if !ok {
		that2, ok := that.(AssignRoleRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if !this.NamespacesRole.Equal(that1.NamespacesRole) {
		return false
	}
	if len(this.Username) != len(that1.Username) {
		return false
	}
	for i := range this.Username {
		if this.Username[i] != that1.Username[i] {
			return false
		}
	}
	return true
}
func (this *ListUserRoleResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListUserRoleResponse)
	if !ok {
		that2, ok := that.(ListUserRoleResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *ListUserRoleResponseItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListUserRoleResponseItem)
	if !ok {
		that2, ok := that.(ListUserRoleResponseItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	if this.FirstName != that1.FirstName {
		return false
	}
	if this.LastName != that1.LastName {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.NamespaceRoles) != len(that1.NamespaceRoles) {
		return false
	}
	for i := range this.NamespaceRoles {
		if !this.NamespaceRoles[i].Equal(that1.NamespaceRoles[i]) {
			return false
		}
	}
	if this.Tenant != that1.Tenant {
		return false
	}
	if this.TenantType != that1.TenantType {
		return false
	}
	if this.IdmType != that1.IdmType {
		return false
	}
	if this.DomainOwner != that1.DomainOwner {
		return false
	}
	if this.OtpEnabled != that1.OtpEnabled {
		return false
	}
	if this.Disabled != that1.Disabled {
		return false
	}
	if !this.CreationTimestamp.Equal(that1.CreationTimestamp) {
		return false
	}
	if !this.LastLoginTimestamp.Equal(that1.LastLoginTimestamp) {
		return false
	}
	return true
}
func (this *GetUserRoleRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetUserRoleRequest)
	if !ok {
		that2, ok := that.(GetUserRoleRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	return true
}
func (this *GetUserRoleResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetUserRoleResponse)
	if !ok {
		that2, ok := that.(GetUserRoleResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	if this.FirstName != that1.FirstName {
		return false
	}
	if this.LastName != that1.LastName {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.NamespaceRoles) != len(that1.NamespaceRoles) {
		return false
	}
	for i := range this.NamespaceRoles {
		if !this.NamespaceRoles[i].Equal(that1.NamespaceRoles[i]) {
			return false
		}
	}
	if this.Tenant != that1.Tenant {
		return false
	}
	if this.TenantType != that1.TenantType {
		return false
	}
	if len(this.FeatureFlags) != len(that1.FeatureFlags) {
		return false
	}
	for i := range this.FeatureFlags {
		if !this.FeatureFlags[i].Equal(that1.FeatureFlags[i]) {
			return false
		}
	}
	if this.TosCurrentVersion != that1.TosCurrentVersion {
		return false
	}
	if this.TosAccepted != that1.TosAccepted {
		return false
	}
	if this.IdmType != that1.IdmType {
		return false
	}
	if this.DomainOwner != that1.DomainOwner {
		return false
	}
	if this.Cname != that1.Cname {
		return false
	}
	if len(this.BillingFlags) != len(that1.BillingFlags) {
		return false
	}
	for i := range this.BillingFlags {
		if !this.BillingFlags[i].Equal(that1.BillingFlags[i]) {
			return false
		}
	}
	if !this.CreationTimestamp.Equal(that1.CreationTimestamp) {
		return false
	}
	if this.Company != that1.Company {
		return false
	}
	if this.PlanType != that1.PlanType {
		return false
	}
	if this.ActivePlanTransitionUid != that1.ActivePlanTransitionUid {
		return false
	}
	if this.Disabled != that1.Disabled {
		return false
	}
	if this.TenantState != that1.TenantState {
		return false
	}
	if len(this.TenantFlags) != len(that1.TenantFlags) {
		return false
	}
	for i := range this.TenantFlags {
		if this.TenantFlags[i] != that1.TenantFlags[i] {
			return false
		}
	}
	if this.State != that1.State {
		return false
	}
	if !this.LastLoginTimestamp.Equal(that1.LastLoginTimestamp) {
		return false
	}
	return true
}
func (this *CascadeDeleteRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CascadeDeleteRequest)
	if !ok {
		that2, ok := that.(CascadeDeleteRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Email != that1.Email {
		return false
	}
	return true
}
func (this *CascadeDeleteResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CascadeDeleteResponse)
	if !ok {
		that2, ok := that.(CascadeDeleteResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DeleteOk != that1.DeleteOk {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *CascadeDeleteItemType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CascadeDeleteItemType)
	if !ok {
		that2, ok := that.(CascadeDeleteItemType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ObjectType != that1.ObjectType {
		return false
	}
	if this.ObjectUid != that1.ObjectUid {
		return false
	}
	if this.ObjectName != that1.ObjectName {
		return false
	}
	if this.ErrorMessage != that1.ErrorMessage {
		return false
	}
	return true
}
func (this *AcceptTOSRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AcceptTOSRequest)
	if !ok {
		that2, ok := that.(AcceptTOSRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.TosAccepted != that1.TosAccepted {
		return false
	}
	return true
}
func (this *AcceptTOSResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AcceptTOSResponse)
	if !ok {
		that2, ok := that.(AcceptTOSResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *GetTOSRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetTOSRequest)
	if !ok {
		that2, ok := that.(GetTOSRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	return true
}
func (this *GetTOSResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetTOSResponse)
	if !ok {
		that2, ok := that.(GetTOSResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.Text != that1.Text {
		return false
	}
	return true
}
func (this *Empty) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Empty)
	if !ok {
		that2, ok := that.(Empty)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *FeatureFlagType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FeatureFlagType)
	if !ok {
		that2, ok := that.(FeatureFlagType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Disabled != that1.Disabled {
		return false
	}
	return true
}
func (this *BillingFeatureIndicator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&user.BillingFeatureIndicator{")
	s = append(s, "BillingFlag: "+fmt.Sprintf("%#v", this.BillingFlag)+",\n")
	s = append(s, "Failed: "+fmt.Sprintf("%#v", this.Failed)+",\n")
	s = append(s, "AdditionalInfo: "+fmt.Sprintf("%#v", this.AdditionalInfo)+",\n")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SendPasswordEmailRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&user.SendPasswordEmailRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SendPasswordEmailResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&user.SendPasswordEmailResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResetPasswordByAdminRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&user.ResetPasswordByAdminRequest{")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NamespacesRoleType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&user.NamespacesRoleType{")
	s = append(s, "Namespaces: "+fmt.Sprintf("%#v", this.Namespaces)+",\n")
	s = append(s, "Role: "+fmt.Sprintf("%#v", this.Role)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NamespaceRoleType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&user.NamespaceRoleType{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Role: "+fmt.Sprintf("%#v", this.Role)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UserRoleRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&user.UserRoleRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "FirstName: "+fmt.Sprintf("%#v", this.FirstName)+",\n")
	s = append(s, "LastName: "+fmt.Sprintf("%#v", this.LastName)+",\n")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.NamespaceRoles != nil {
		s = append(s, "NamespaceRoles: "+fmt.Sprintf("%#v", this.NamespaceRoles)+",\n")
	}
	s = append(s, "IdmType: "+fmt.Sprintf("%#v", this.IdmType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListUserRoleRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&user.ListUserRoleRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AssignRoleRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&user.AssignRoleRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	if this.NamespacesRole != nil {
		s = append(s, "NamespacesRole: "+fmt.Sprintf("%#v", this.NamespacesRole)+",\n")
	}
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListUserRoleResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&user.ListUserRoleResponse{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListUserRoleResponseItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 19)
	s = append(s, "&user.ListUserRoleResponseItem{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "FirstName: "+fmt.Sprintf("%#v", this.FirstName)+",\n")
	s = append(s, "LastName: "+fmt.Sprintf("%#v", this.LastName)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.NamespaceRoles != nil {
		s = append(s, "NamespaceRoles: "+fmt.Sprintf("%#v", this.NamespaceRoles)+",\n")
	}
	s = append(s, "Tenant: "+fmt.Sprintf("%#v", this.Tenant)+",\n")
	s = append(s, "TenantType: "+fmt.Sprintf("%#v", this.TenantType)+",\n")
	s = append(s, "IdmType: "+fmt.Sprintf("%#v", this.IdmType)+",\n")
	s = append(s, "DomainOwner: "+fmt.Sprintf("%#v", this.DomainOwner)+",\n")
	s = append(s, "OtpEnabled: "+fmt.Sprintf("%#v", this.OtpEnabled)+",\n")
	s = append(s, "Disabled: "+fmt.Sprintf("%#v", this.Disabled)+",\n")
	if this.CreationTimestamp != nil {
		s = append(s, "CreationTimestamp: "+fmt.Sprintf("%#v", this.CreationTimestamp)+",\n")
	}
	if this.LastLoginTimestamp != nil {
		s = append(s, "LastLoginTimestamp: "+fmt.Sprintf("%#v", this.LastLoginTimestamp)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetUserRoleRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&user.GetUserRoleRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetUserRoleResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 29)
	s = append(s, "&user.GetUserRoleResponse{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "FirstName: "+fmt.Sprintf("%#v", this.FirstName)+",\n")
	s = append(s, "LastName: "+fmt.Sprintf("%#v", this.LastName)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.NamespaceRoles != nil {
		s = append(s, "NamespaceRoles: "+fmt.Sprintf("%#v", this.NamespaceRoles)+",\n")
	}
	s = append(s, "Tenant: "+fmt.Sprintf("%#v", this.Tenant)+",\n")
	s = append(s, "TenantType: "+fmt.Sprintf("%#v", this.TenantType)+",\n")
	if this.FeatureFlags != nil {
		s = append(s, "FeatureFlags: "+fmt.Sprintf("%#v", this.FeatureFlags)+",\n")
	}
	s = append(s, "TosCurrentVersion: "+fmt.Sprintf("%#v", this.TosCurrentVersion)+",\n")
	s = append(s, "TosAccepted: "+fmt.Sprintf("%#v", this.TosAccepted)+",\n")
	s = append(s, "IdmType: "+fmt.Sprintf("%#v", this.IdmType)+",\n")
	s = append(s, "DomainOwner: "+fmt.Sprintf("%#v", this.DomainOwner)+",\n")
	s = append(s, "Cname: "+fmt.Sprintf("%#v", this.Cname)+",\n")
	if this.BillingFlags != nil {
		s = append(s, "BillingFlags: "+fmt.Sprintf("%#v", this.BillingFlags)+",\n")
	}
	if this.CreationTimestamp != nil {
		s = append(s, "CreationTimestamp: "+fmt.Sprintf("%#v", this.CreationTimestamp)+",\n")
	}
	s = append(s, "Company: "+fmt.Sprintf("%#v", this.Company)+",\n")
	s = append(s, "PlanType: "+fmt.Sprintf("%#v", this.PlanType)+",\n")
	s = append(s, "ActivePlanTransitionUid: "+fmt.Sprintf("%#v", this.ActivePlanTransitionUid)+",\n")
	s = append(s, "Disabled: "+fmt.Sprintf("%#v", this.Disabled)+",\n")
	s = append(s, "TenantState: "+fmt.Sprintf("%#v", this.TenantState)+",\n")
	keysForTenantFlags := make([]string, 0, len(this.TenantFlags))
	for k, _ := range this.TenantFlags {
		keysForTenantFlags = append(keysForTenantFlags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTenantFlags)
	mapStringForTenantFlags := "map[string]bool{"
	for _, k := range keysForTenantFlags {
		mapStringForTenantFlags += fmt.Sprintf("%#v: %#v,", k, this.TenantFlags[k])
	}
	mapStringForTenantFlags += "}"
	if this.TenantFlags != nil {
		s = append(s, "TenantFlags: "+mapStringForTenantFlags+",\n")
	}
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	if this.LastLoginTimestamp != nil {
		s = append(s, "LastLoginTimestamp: "+fmt.Sprintf("%#v", this.LastLoginTimestamp)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CascadeDeleteRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&user.CascadeDeleteRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Email: "+fmt.Sprintf("%#v", this.Email)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CascadeDeleteResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&user.CascadeDeleteResponse{")
	s = append(s, "DeleteOk: "+fmt.Sprintf("%#v", this.DeleteOk)+",\n")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CascadeDeleteItemType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&user.CascadeDeleteItemType{")
	s = append(s, "ObjectType: "+fmt.Sprintf("%#v", this.ObjectType)+",\n")
	s = append(s, "ObjectUid: "+fmt.Sprintf("%#v", this.ObjectUid)+",\n")
	s = append(s, "ObjectName: "+fmt.Sprintf("%#v", this.ObjectName)+",\n")
	s = append(s, "ErrorMessage: "+fmt.Sprintf("%#v", this.ErrorMessage)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AcceptTOSRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&user.AcceptTOSRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "TosAccepted: "+fmt.Sprintf("%#v", this.TosAccepted)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AcceptTOSResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&user.AcceptTOSResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetTOSRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&user.GetTOSRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetTOSResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&user.GetTOSResponse{")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Text: "+fmt.Sprintf("%#v", this.Text)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Empty) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&user.Empty{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FeatureFlagType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&user.FeatureFlagType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Disabled: "+fmt.Sprintf("%#v", this.Disabled)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringPublicCustomapi(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CustomAPIClient is the client API for CustomAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CustomAPIClient interface {
	// User with roles create
	//
	// x-displayName: "Create User with Role Assignment"
	// Create creates a user and namespace roles binding for this user
	Create(ctx context.Context, in *UserRoleRequest, opts ...grpc.CallOption) (*Object, error)
	// User with roles update
	//
	// x-displayName: "Update User and Role Assignments"
	// Replace updates user and namespace roles for this user
	Replace(ctx context.Context, in *UserRoleRequest, opts ...grpc.CallOption) (*Object, error)
	// User with roles list
	//
	// x-displayName: "Get User and Role Assignments"
	// List enumerates users and their namespace roles for this tenant
	List(ctx context.Context, in *ListUserRoleRequest, opts ...grpc.CallOption) (*ListUserRoleResponse, error)
	// User information details retrieval
	//
	// x-displayName: "Who am I"
	// Get fetches user information based on the username header from the request context
	Get(ctx context.Context, in *GetUserRoleRequest, opts ...grpc.CallOption) (*GetUserRoleResponse, error)
	// CascadeDelete
	//
	// x-displayName: "Delete User and Related Objects"
	// CascadeDelete deletes the user and associated namespace roles for this user.
	// Use this only if the user and its referenced objects need to be wiped out altogether.
	// Note: users will always be in the system namespace.
	CascadeDelete(ctx context.Context, in *CascadeDeleteRequest, opts ...grpc.CallOption) (*CascadeDeleteResponse, error)
	// Role assignment request
	//
	// x-displayName: "Assign role to User"
	// AssignRole allows customers to assign a namespace/role pair to multiple users
	AssignRole(ctx context.Context, in *AssignRoleRequest, opts ...grpc.CallOption) (*Empty, error)
	// Send password email
	//
	// x-displayName: "Send Password Email"
	// SendPasswordEmail allows admin user to send password email for the users to update their password.
	SendPasswordEmail(ctx context.Context, in *SendPasswordEmailRequest, opts ...grpc.CallOption) (*SendPasswordEmailResponse, error)
	// Reset password
	//
	// x-displayName: "Reset password"
	// Reset password resets password for user who is making this request.
	ResetPassword(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// Reset password by admin
	//
	// x-displayName: "Reset password by admin"
	// Reset password by admin resets password for user specified in request.
	// This request is meant to be executed by the tenant's admin.
	ResetPasswordByAdmin(ctx context.Context, in *ResetPasswordByAdminRequest, opts ...grpc.CallOption) (*Empty, error)
	// Accept TOS request
	//
	// x-displayName: "Accept TOS"
	// Accept TOS updates accepted version
	AcceptTOS(ctx context.Context, in *AcceptTOSRequest, opts ...grpc.CallOption) (*AcceptTOSResponse, error)
	// TOS request
	//
	// x-displayName: "Get TOS"
	// Get TOS provides TOS version with text
	GetTOS(ctx context.Context, in *GetTOSRequest, opts ...grpc.CallOption) (*GetTOSResponse, error)
	// Sync user from identity provider
	//
	// x-displayName: "Sync user"
	// In case when user created initially from identity provider we need to sync the user data.
	SyncUser(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
}

type customAPIClient struct {
	cc *grpc.ClientConn
}

func NewCustomAPIClient(cc *grpc.ClientConn) CustomAPIClient {
	return &customAPIClient{cc}
}

func (c *customAPIClient) Create(ctx context.Context, in *UserRoleRequest, opts ...grpc.CallOption) (*Object, error) {
	out := new(Object)
	err := c.cc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) Replace(ctx context.Context, in *UserRoleRequest, opts ...grpc.CallOption) (*Object, error) {
	out := new(Object)
	err := c.cc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/Replace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) List(ctx context.Context, in *ListUserRoleRequest, opts ...grpc.CallOption) (*ListUserRoleResponse, error) {
	out := new(ListUserRoleResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) Get(ctx context.Context, in *GetUserRoleRequest, opts ...grpc.CallOption) (*GetUserRoleResponse, error) {
	out := new(GetUserRoleResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) CascadeDelete(ctx context.Context, in *CascadeDeleteRequest, opts ...grpc.CallOption) (*CascadeDeleteResponse, error) {
	out := new(CascadeDeleteResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/CascadeDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) AssignRole(ctx context.Context, in *AssignRoleRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/AssignRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) SendPasswordEmail(ctx context.Context, in *SendPasswordEmailRequest, opts ...grpc.CallOption) (*SendPasswordEmailResponse, error) {
	out := new(SendPasswordEmailResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/SendPasswordEmail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) ResetPassword(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/ResetPassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) ResetPasswordByAdmin(ctx context.Context, in *ResetPasswordByAdminRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/ResetPasswordByAdmin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) AcceptTOS(ctx context.Context, in *AcceptTOSRequest, opts ...grpc.CallOption) (*AcceptTOSResponse, error) {
	out := new(AcceptTOSResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/AcceptTOS", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) GetTOS(ctx context.Context, in *GetTOSRequest, opts ...grpc.CallOption) (*GetTOSResponse, error) {
	out := new(GetTOSResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/GetTOS", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) SyncUser(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/ves.io.schema.user.CustomAPI/SyncUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CustomAPIServer is the server API for CustomAPI service.
type CustomAPIServer interface {
	// User with roles create
	//
	// x-displayName: "Create User with Role Assignment"
	// Create creates a user and namespace roles binding for this user
	Create(context.Context, *UserRoleRequest) (*Object, error)
	// User with roles update
	//
	// x-displayName: "Update User and Role Assignments"
	// Replace updates user and namespace roles for this user
	Replace(context.Context, *UserRoleRequest) (*Object, error)
	// User with roles list
	//
	// x-displayName: "Get User and Role Assignments"
	// List enumerates users and their namespace roles for this tenant
	List(context.Context, *ListUserRoleRequest) (*ListUserRoleResponse, error)
	// User information details retrieval
	//
	// x-displayName: "Who am I"
	// Get fetches user information based on the username header from the request context
	Get(context.Context, *GetUserRoleRequest) (*GetUserRoleResponse, error)
	// CascadeDelete
	//
	// x-displayName: "Delete User and Related Objects"
	// CascadeDelete deletes the user and associated namespace roles for this user.
	// Use this only if the user and its referenced objects need to be wiped out altogether.
	// Note: users will always be in the system namespace.
	CascadeDelete(context.Context, *CascadeDeleteRequest) (*CascadeDeleteResponse, error)
	// Role assignment request
	//
	// x-displayName: "Assign role to User"
	// AssignRole allows customers to assign a namespace/role pair to multiple users
	AssignRole(context.Context, *AssignRoleRequest) (*Empty, error)
	// Send password email
	//
	// x-displayName: "Send Password Email"
	// SendPasswordEmail allows admin user to send password email for the users to update their password.
	SendPasswordEmail(context.Context, *SendPasswordEmailRequest) (*SendPasswordEmailResponse, error)
	// Reset password
	//
	// x-displayName: "Reset password"
	// Reset password resets password for user who is making this request.
	ResetPassword(context.Context, *Empty) (*Empty, error)
	// Reset password by admin
	//
	// x-displayName: "Reset password by admin"
	// Reset password by admin resets password for user specified in request.
	// This request is meant to be executed by the tenant's admin.
	ResetPasswordByAdmin(context.Context, *ResetPasswordByAdminRequest) (*Empty, error)
	// Accept TOS request
	//
	// x-displayName: "Accept TOS"
	// Accept TOS updates accepted version
	AcceptTOS(context.Context, *AcceptTOSRequest) (*AcceptTOSResponse, error)
	// TOS request
	//
	// x-displayName: "Get TOS"
	// Get TOS provides TOS version with text
	GetTOS(context.Context, *GetTOSRequest) (*GetTOSResponse, error)
	// Sync user from identity provider
	//
	// x-displayName: "Sync user"
	// In case when user created initially from identity provider we need to sync the user data.
	SyncUser(context.Context, *Empty) (*Empty, error)
}

// UnimplementedCustomAPIServer can be embedded to have forward compatible implementations.
type UnimplementedCustomAPIServer struct {
}

func (*UnimplementedCustomAPIServer) Create(ctx context.Context, req *UserRoleRequest) (*Object, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (*UnimplementedCustomAPIServer) Replace(ctx context.Context, req *UserRoleRequest) (*Object, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Replace not implemented")
}
func (*UnimplementedCustomAPIServer) List(ctx context.Context, req *ListUserRoleRequest) (*ListUserRoleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (*UnimplementedCustomAPIServer) Get(ctx context.Context, req *GetUserRoleRequest) (*GetUserRoleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (*UnimplementedCustomAPIServer) CascadeDelete(ctx context.Context, req *CascadeDeleteRequest) (*CascadeDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CascadeDelete not implemented")
}
func (*UnimplementedCustomAPIServer) AssignRole(ctx context.Context, req *AssignRoleRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssignRole not implemented")
}
func (*UnimplementedCustomAPIServer) SendPasswordEmail(ctx context.Context, req *SendPasswordEmailRequest) (*SendPasswordEmailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendPasswordEmail not implemented")
}
func (*UnimplementedCustomAPIServer) ResetPassword(ctx context.Context, req *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetPassword not implemented")
}
func (*UnimplementedCustomAPIServer) ResetPasswordByAdmin(ctx context.Context, req *ResetPasswordByAdminRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetPasswordByAdmin not implemented")
}
func (*UnimplementedCustomAPIServer) AcceptTOS(ctx context.Context, req *AcceptTOSRequest) (*AcceptTOSResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AcceptTOS not implemented")
}
func (*UnimplementedCustomAPIServer) GetTOS(ctx context.Context, req *GetTOSRequest) (*GetTOSResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTOS not implemented")
}
func (*UnimplementedCustomAPIServer) SyncUser(ctx context.Context, req *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncUser not implemented")
}

func RegisterCustomAPIServer(s *grpc.Server, srv CustomAPIServer) {
	s.RegisterService(&_CustomAPI_serviceDesc, srv)
}

func _CustomAPI_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).Create(ctx, req.(*UserRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_Replace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).Replace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/Replace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).Replace(ctx, req.(*UserRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUserRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).List(ctx, req.(*ListUserRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).Get(ctx, req.(*GetUserRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_CascadeDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CascadeDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).CascadeDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/CascadeDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).CascadeDelete(ctx, req.(*CascadeDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_AssignRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssignRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).AssignRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/AssignRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).AssignRole(ctx, req.(*AssignRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_SendPasswordEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendPasswordEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).SendPasswordEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/SendPasswordEmail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).SendPasswordEmail(ctx, req.(*SendPasswordEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_ResetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).ResetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/ResetPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).ResetPassword(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_ResetPasswordByAdmin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetPasswordByAdminRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).ResetPasswordByAdmin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/ResetPasswordByAdmin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).ResetPasswordByAdmin(ctx, req.(*ResetPasswordByAdminRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_AcceptTOS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcceptTOSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).AcceptTOS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/AcceptTOS",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).AcceptTOS(ctx, req.(*AcceptTOSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_GetTOS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTOSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).GetTOS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/GetTOS",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).GetTOS(ctx, req.(*GetTOSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_SyncUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).SyncUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.user.CustomAPI/SyncUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).SyncUser(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _CustomAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ves.io.schema.user.CustomAPI",
	HandlerType: (*CustomAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _CustomAPI_Create_Handler,
		},
		{
			MethodName: "Replace",
			Handler:    _CustomAPI_Replace_Handler,
		},
		{
			MethodName: "List",
			Handler:    _CustomAPI_List_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _CustomAPI_Get_Handler,
		},
		{
			MethodName: "CascadeDelete",
			Handler:    _CustomAPI_CascadeDelete_Handler,
		},
		{
			MethodName: "AssignRole",
			Handler:    _CustomAPI_AssignRole_Handler,
		},
		{
			MethodName: "SendPasswordEmail",
			Handler:    _CustomAPI_SendPasswordEmail_Handler,
		},
		{
			MethodName: "ResetPassword",
			Handler:    _CustomAPI_ResetPassword_Handler,
		},
		{
			MethodName: "ResetPasswordByAdmin",
			Handler:    _CustomAPI_ResetPasswordByAdmin_Handler,
		},
		{
			MethodName: "AcceptTOS",
			Handler:    _CustomAPI_AcceptTOS_Handler,
		},
		{
			MethodName: "GetTOS",
			Handler:    _CustomAPI_GetTOS_Handler,
		},
		{
			MethodName: "SyncUser",
			Handler:    _CustomAPI_SyncUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ves.io/schema/user/public_customapi.proto",
}

func (m *BillingFeatureIndicator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BillingFeatureIndicator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BillingFeatureIndicator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x20
	}
	if len(m.AdditionalInfo) > 0 {
		i -= len(m.AdditionalInfo)
		copy(dAtA[i:], m.AdditionalInfo)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.AdditionalInfo)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Failed {
		i--
		if m.Failed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.BillingFlag != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.BillingFlag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SendPasswordEmailRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendPasswordEmailRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendPasswordEmailRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Email) > 0 {
		i -= len(m.Email)
		copy(dAtA[i:], m.Email)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Email)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *SendPasswordEmailResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendPasswordEmailResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendPasswordEmailResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ResetPasswordByAdminRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetPasswordByAdminRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResetPasswordByAdminRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Email) > 0 {
		i -= len(m.Email)
		copy(dAtA[i:], m.Email)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Email)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NamespacesRoleType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespacesRoleType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NamespacesRoleType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespaces) > 0 {
		for iNdEx := len(m.Namespaces) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Namespaces[iNdEx])
			copy(dAtA[i:], m.Namespaces[iNdEx])
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespaces[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NamespaceRoleType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespaceRoleType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NamespaceRoleType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserRoleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRoleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserRoleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IdmType != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.IdmType))
		i--
		dAtA[i] = 0x40
	}
	if len(m.NamespaceRoles) > 0 {
		for iNdEx := len(m.NamespaceRoles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NamespaceRoles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Type != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Email) > 0 {
		i -= len(m.Email)
		copy(dAtA[i:], m.Email)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Email)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.LastName) > 0 {
		i -= len(m.LastName)
		copy(dAtA[i:], m.LastName)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.LastName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FirstName) > 0 {
		i -= len(m.FirstName)
		copy(dAtA[i:], m.FirstName)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.FirstName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListUserRoleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListUserRoleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListUserRoleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AssignRoleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssignRoleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssignRoleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		for iNdEx := len(m.Username) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Username[iNdEx])
			copy(dAtA[i:], m.Username[iNdEx])
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Username[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.NamespacesRole != nil {
		{
			size, err := m.NamespacesRole.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListUserRoleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListUserRoleResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListUserRoleResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListUserRoleResponseItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListUserRoleResponseItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListUserRoleResponseItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastLoginTimestamp != nil {
		{
			size, err := m.LastLoginTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.CreationTimestamp != nil {
		{
			size, err := m.CreationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.Disabled {
		i--
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.OtpEnabled {
		i--
		if m.OtpEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.DomainOwner {
		i--
		if m.DomainOwner {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.IdmType != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.IdmType))
		i--
		dAtA[i] = 0x50
	}
	if m.TenantType != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.TenantType))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Tenant) > 0 {
		i -= len(m.Tenant)
		copy(dAtA[i:], m.Tenant)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Tenant)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.NamespaceRoles) > 0 {
		for iNdEx := len(m.NamespaceRoles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NamespaceRoles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Type != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x30
	}
	if len(m.LastName) > 0 {
		i -= len(m.LastName)
		copy(dAtA[i:], m.LastName)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.LastName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.FirstName) > 0 {
		i -= len(m.FirstName)
		copy(dAtA[i:], m.FirstName)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.FirstName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Email) > 0 {
		i -= len(m.Email)
		copy(dAtA[i:], m.Email)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Email)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetUserRoleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserRoleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUserRoleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetUserRoleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserRoleResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUserRoleResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.LastLoginTimestamp != nil {
		{
			size, err := m.LastLoginTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.TenantFlags) > 0 {
		for k := range m.TenantFlags {
			v := m.TenantFlags[k]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.TenantState) > 0 {
		i -= len(m.TenantState)
		copy(dAtA[i:], m.TenantState)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.TenantState)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.Disabled {
		i--
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if len(m.ActivePlanTransitionUid) > 0 {
		i -= len(m.ActivePlanTransitionUid)
		copy(dAtA[i:], m.ActivePlanTransitionUid)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.ActivePlanTransitionUid)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.PlanType != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.PlanType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Company) > 0 {
		i -= len(m.Company)
		copy(dAtA[i:], m.Company)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Company)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.CreationTimestamp != nil {
		{
			size, err := m.CreationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.BillingFlags) > 0 {
		for iNdEx := len(m.BillingFlags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BillingFlags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.Cname) > 0 {
		i -= len(m.Cname)
		copy(dAtA[i:], m.Cname)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Cname)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.DomainOwner {
		i--
		if m.DomainOwner {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.IdmType != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.IdmType))
		i--
		dAtA[i] = 0x68
	}
	if len(m.TosAccepted) > 0 {
		i -= len(m.TosAccepted)
		copy(dAtA[i:], m.TosAccepted)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.TosAccepted)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.TosCurrentVersion) > 0 {
		i -= len(m.TosCurrentVersion)
		copy(dAtA[i:], m.TosCurrentVersion)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.TosCurrentVersion)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.FeatureFlags) > 0 {
		for iNdEx := len(m.FeatureFlags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FeatureFlags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.TenantType != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.TenantType))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Tenant) > 0 {
		i -= len(m.Tenant)
		copy(dAtA[i:], m.Tenant)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Tenant)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.NamespaceRoles) > 0 {
		for iNdEx := len(m.NamespaceRoles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NamespaceRoles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Type != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x30
	}
	if len(m.LastName) > 0 {
		i -= len(m.LastName)
		copy(dAtA[i:], m.LastName)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.LastName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.FirstName) > 0 {
		i -= len(m.FirstName)
		copy(dAtA[i:], m.FirstName)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.FirstName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Email) > 0 {
		i -= len(m.Email)
		copy(dAtA[i:], m.Email)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Email)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CascadeDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CascadeDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CascadeDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Email) > 0 {
		i -= len(m.Email)
		copy(dAtA[i:], m.Email)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Email)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CascadeDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CascadeDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CascadeDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.DeleteOk {
		i--
		if m.DeleteOk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CascadeDeleteItemType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CascadeDeleteItemType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CascadeDeleteItemType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ObjectName) > 0 {
		i -= len(m.ObjectName)
		copy(dAtA[i:], m.ObjectName)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.ObjectName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ObjectUid) > 0 {
		i -= len(m.ObjectUid)
		copy(dAtA[i:], m.ObjectUid)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.ObjectUid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ObjectType) > 0 {
		i -= len(m.ObjectType)
		copy(dAtA[i:], m.ObjectType)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.ObjectType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AcceptTOSRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptTOSRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AcceptTOSRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TosAccepted) > 0 {
		i -= len(m.TosAccepted)
		copy(dAtA[i:], m.TosAccepted)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.TosAccepted)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AcceptTOSResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptTOSResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AcceptTOSResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetTOSRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTOSRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTOSRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTOSResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTOSResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTOSResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *FeatureFlagType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureFlagType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeatureFlagType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Disabled {
		i--
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPublicCustomapi(dAtA []byte, offset int, v uint64) int {
	offset -= sovPublicCustomapi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BillingFeatureIndicator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BillingFlag != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.BillingFlag))
	}
	if m.Failed {
		n += 2
	}
	l = len(m.AdditionalInfo)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.Action != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Action))
	}
	return n
}

func (m *SendPasswordEmailRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *SendPasswordEmailResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ResetPasswordByAdminRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *NamespacesRoleType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Namespaces) > 0 {
		for _, s := range m.Namespaces {
			l = len(s)
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *NamespaceRoleType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *UserRoleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Type))
	}
	if len(m.NamespaceRoles) > 0 {
		for _, e := range m.NamespaceRoles {
			l = e.Size()
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	if m.IdmType != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.IdmType))
	}
	return n
}

func (m *ListUserRoleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *AssignRoleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.NamespacesRole != nil {
		l = m.NamespacesRole.Size()
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if len(m.Username) > 0 {
		for _, s := range m.Username {
			l = len(s)
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	return n
}

func (m *ListUserRoleResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	return n
}

func (m *ListUserRoleResponseItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Type))
	}
	if len(m.NamespaceRoles) > 0 {
		for _, e := range m.NamespaceRoles {
			l = e.Size()
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.TenantType != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.TenantType))
	}
	if m.IdmType != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.IdmType))
	}
	if m.DomainOwner {
		n += 2
	}
	if m.OtpEnabled {
		n += 2
	}
	if m.Disabled {
		n += 2
	}
	if m.CreationTimestamp != nil {
		l = m.CreationTimestamp.Size()
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.LastLoginTimestamp != nil {
		l = m.LastLoginTimestamp.Size()
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *GetUserRoleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *GetUserRoleResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Type))
	}
	if len(m.NamespaceRoles) > 0 {
		for _, e := range m.NamespaceRoles {
			l = e.Size()
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.TenantType != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.TenantType))
	}
	if len(m.FeatureFlags) > 0 {
		for _, e := range m.FeatureFlags {
			l = e.Size()
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	l = len(m.TosCurrentVersion)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.TosAccepted)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.IdmType != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.IdmType))
	}
	if m.DomainOwner {
		n += 2
	}
	l = len(m.Cname)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	if len(m.BillingFlags) > 0 {
		for _, e := range m.BillingFlags {
			l = e.Size()
			n += 2 + l + sovPublicCustomapi(uint64(l))
		}
	}
	if m.CreationTimestamp != nil {
		l = m.CreationTimestamp.Size()
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Company)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	if m.PlanType != 0 {
		n += 2 + sovPublicCustomapi(uint64(m.PlanType))
	}
	l = len(m.ActivePlanTransitionUid)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	if m.Disabled {
		n += 3
	}
	l = len(m.TenantState)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	if len(m.TenantFlags) > 0 {
		for k, v := range m.TenantFlags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + 1 + 1
			n += mapEntrySize + 2 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	if m.LastLoginTimestamp != nil {
		l = m.LastLoginTimestamp.Size()
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	if m.State != 0 {
		n += 2 + sovPublicCustomapi(uint64(m.State))
	}
	return n
}

func (m *CascadeDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *CascadeDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeleteOk {
		n += 2
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	return n
}

func (m *CascadeDeleteItemType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ObjectType)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.ObjectUid)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.ObjectName)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *AcceptTOSRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.TosAccepted)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *AcceptTOSResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetTOSRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *GetTOSResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *FeatureFlagType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.Disabled {
		n += 2
	}
	return n
}

func sovPublicCustomapi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPublicCustomapi(x uint64) (n int) {
	return sovPublicCustomapi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *BillingFeatureIndicator) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BillingFeatureIndicator{`,
		`BillingFlag:` + fmt.Sprintf("%v", this.BillingFlag) + `,`,
		`Failed:` + fmt.Sprintf("%v", this.Failed) + `,`,
		`AdditionalInfo:` + fmt.Sprintf("%v", this.AdditionalInfo) + `,`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SendPasswordEmailRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SendPasswordEmailRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SendPasswordEmailResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SendPasswordEmailResponse{`,
		`}`,
	}, "")
	return s
}
func (this *ResetPasswordByAdminRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResetPasswordByAdminRequest{`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NamespacesRoleType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NamespacesRoleType{`,
		`Namespaces:` + fmt.Sprintf("%v", this.Namespaces) + `,`,
		`Role:` + fmt.Sprintf("%v", this.Role) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NamespaceRoleType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NamespaceRoleType{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Role:` + fmt.Sprintf("%v", this.Role) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UserRoleRequest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNamespaceRoles := "[]*NamespaceRoleType{"
	for _, f := range this.NamespaceRoles {
		repeatedStringForNamespaceRoles += strings.Replace(f.String(), "NamespaceRoleType", "NamespaceRoleType", 1) + ","
	}
	repeatedStringForNamespaceRoles += "}"
	s := strings.Join([]string{`&UserRoleRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`FirstName:` + fmt.Sprintf("%v", this.FirstName) + `,`,
		`LastName:` + fmt.Sprintf("%v", this.LastName) + `,`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`NamespaceRoles:` + repeatedStringForNamespaceRoles + `,`,
		`IdmType:` + fmt.Sprintf("%v", this.IdmType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListUserRoleRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListUserRoleRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AssignRoleRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AssignRoleRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`NamespacesRole:` + strings.Replace(this.NamespacesRole.String(), "NamespacesRoleType", "NamespacesRoleType", 1) + `,`,
		`Username:` + fmt.Sprintf("%v", this.Username) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListUserRoleResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*ListUserRoleResponseItem{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "ListUserRoleResponseItem", "ListUserRoleResponseItem", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&ListUserRoleResponse{`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListUserRoleResponseItem) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNamespaceRoles := "[]*NamespaceRoleType{"
	for _, f := range this.NamespaceRoles {
		repeatedStringForNamespaceRoles += strings.Replace(f.String(), "NamespaceRoleType", "NamespaceRoleType", 1) + ","
	}
	repeatedStringForNamespaceRoles += "}"
	s := strings.Join([]string{`&ListUserRoleResponseItem{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`FirstName:` + fmt.Sprintf("%v", this.FirstName) + `,`,
		`LastName:` + fmt.Sprintf("%v", this.LastName) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`NamespaceRoles:` + repeatedStringForNamespaceRoles + `,`,
		`Tenant:` + fmt.Sprintf("%v", this.Tenant) + `,`,
		`TenantType:` + fmt.Sprintf("%v", this.TenantType) + `,`,
		`IdmType:` + fmt.Sprintf("%v", this.IdmType) + `,`,
		`DomainOwner:` + fmt.Sprintf("%v", this.DomainOwner) + `,`,
		`OtpEnabled:` + fmt.Sprintf("%v", this.OtpEnabled) + `,`,
		`Disabled:` + fmt.Sprintf("%v", this.Disabled) + `,`,
		`CreationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.CreationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`LastLoginTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.LastLoginTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetUserRoleRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetUserRoleRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetUserRoleResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNamespaceRoles := "[]*NamespaceRoleType{"
	for _, f := range this.NamespaceRoles {
		repeatedStringForNamespaceRoles += strings.Replace(f.String(), "NamespaceRoleType", "NamespaceRoleType", 1) + ","
	}
	repeatedStringForNamespaceRoles += "}"
	repeatedStringForFeatureFlags := "[]*FeatureFlagType{"
	for _, f := range this.FeatureFlags {
		repeatedStringForFeatureFlags += strings.Replace(f.String(), "FeatureFlagType", "FeatureFlagType", 1) + ","
	}
	repeatedStringForFeatureFlags += "}"
	repeatedStringForBillingFlags := "[]*BillingFeatureIndicator{"
	for _, f := range this.BillingFlags {
		repeatedStringForBillingFlags += strings.Replace(f.String(), "BillingFeatureIndicator", "BillingFeatureIndicator", 1) + ","
	}
	repeatedStringForBillingFlags += "}"
	keysForTenantFlags := make([]string, 0, len(this.TenantFlags))
	for k, _ := range this.TenantFlags {
		keysForTenantFlags = append(keysForTenantFlags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTenantFlags)
	mapStringForTenantFlags := "map[string]bool{"
	for _, k := range keysForTenantFlags {
		mapStringForTenantFlags += fmt.Sprintf("%v: %v,", k, this.TenantFlags[k])
	}
	mapStringForTenantFlags += "}"
	s := strings.Join([]string{`&GetUserRoleResponse{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`FirstName:` + fmt.Sprintf("%v", this.FirstName) + `,`,
		`LastName:` + fmt.Sprintf("%v", this.LastName) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`NamespaceRoles:` + repeatedStringForNamespaceRoles + `,`,
		`Tenant:` + fmt.Sprintf("%v", this.Tenant) + `,`,
		`TenantType:` + fmt.Sprintf("%v", this.TenantType) + `,`,
		`FeatureFlags:` + repeatedStringForFeatureFlags + `,`,
		`TosCurrentVersion:` + fmt.Sprintf("%v", this.TosCurrentVersion) + `,`,
		`TosAccepted:` + fmt.Sprintf("%v", this.TosAccepted) + `,`,
		`IdmType:` + fmt.Sprintf("%v", this.IdmType) + `,`,
		`DomainOwner:` + fmt.Sprintf("%v", this.DomainOwner) + `,`,
		`Cname:` + fmt.Sprintf("%v", this.Cname) + `,`,
		`BillingFlags:` + repeatedStringForBillingFlags + `,`,
		`CreationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.CreationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`Company:` + fmt.Sprintf("%v", this.Company) + `,`,
		`PlanType:` + fmt.Sprintf("%v", this.PlanType) + `,`,
		`ActivePlanTransitionUid:` + fmt.Sprintf("%v", this.ActivePlanTransitionUid) + `,`,
		`Disabled:` + fmt.Sprintf("%v", this.Disabled) + `,`,
		`TenantState:` + fmt.Sprintf("%v", this.TenantState) + `,`,
		`TenantFlags:` + mapStringForTenantFlags + `,`,
		`LastLoginTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.LastLoginTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CascadeDeleteRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CascadeDeleteRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Email:` + fmt.Sprintf("%v", this.Email) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CascadeDeleteResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*CascadeDeleteItemType{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "CascadeDeleteItemType", "CascadeDeleteItemType", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&CascadeDeleteResponse{`,
		`DeleteOk:` + fmt.Sprintf("%v", this.DeleteOk) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *CascadeDeleteItemType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CascadeDeleteItemType{`,
		`ObjectType:` + fmt.Sprintf("%v", this.ObjectType) + `,`,
		`ObjectUid:` + fmt.Sprintf("%v", this.ObjectUid) + `,`,
		`ObjectName:` + fmt.Sprintf("%v", this.ObjectName) + `,`,
		`ErrorMessage:` + fmt.Sprintf("%v", this.ErrorMessage) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AcceptTOSRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AcceptTOSRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`TosAccepted:` + fmt.Sprintf("%v", this.TosAccepted) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AcceptTOSResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AcceptTOSResponse{`,
		`}`,
	}, "")
	return s
}
func (this *GetTOSRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetTOSRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetTOSResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetTOSResponse{`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Text:` + fmt.Sprintf("%v", this.Text) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Empty) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Empty{`,
		`}`,
	}, "")
	return s
}
func (this *FeatureFlagType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FeatureFlagType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Disabled:` + fmt.Sprintf("%v", this.Disabled) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringPublicCustomapi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *BillingFeatureIndicator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BillingFeatureIndicator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BillingFeatureIndicator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BillingFlag", wireType)
			}
			m.BillingFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BillingFlag |= BillingFlag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Failed = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdditionalInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= BillingFlagAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendPasswordEmailRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendPasswordEmailRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendPasswordEmailRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendPasswordEmailResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendPasswordEmailResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendPasswordEmailResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetPasswordByAdminRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetPasswordByAdminRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetPasswordByAdminRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespacesRoleType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespacesRoleType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespacesRoleType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespaces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespaces = append(m.Namespaces, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespaceRoleType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespaceRoleType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespaceRoleType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRoleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRoleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRoleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= UserType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceRoles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamespaceRoles = append(m.NamespaceRoles, &NamespaceRoleType{})
			if err := m.NamespaceRoles[len(m.NamespaceRoles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdmType", wireType)
			}
			m.IdmType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdmType |= IdmType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUserRoleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUserRoleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUserRoleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssignRoleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssignRoleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssignRoleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespacesRole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NamespacesRole == nil {
				m.NamespacesRole = &NamespacesRoleType{}
			}
			if err := m.NamespacesRole.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = append(m.Username, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUserRoleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUserRoleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUserRoleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ListUserRoleResponseItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUserRoleResponseItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUserRoleResponseItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUserRoleResponseItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= UserType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceRoles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamespaceRoles = append(m.NamespaceRoles, &NamespaceRoleType{})
			if err := m.NamespaceRoles[len(m.NamespaceRoles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantType", wireType)
			}
			m.TenantType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantType |= schema.TenantType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdmType", wireType)
			}
			m.IdmType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdmType |= IdmType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainOwner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DomainOwner = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtpEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OtpEnabled = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreationTimestamp == nil {
				m.CreationTimestamp = &types.Timestamp{}
			}
			if err := m.CreationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLoginTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastLoginTimestamp == nil {
				m.LastLoginTimestamp = &types.Timestamp{}
			}
			if err := m.LastLoginTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserRoleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserRoleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserRoleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserRoleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserRoleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserRoleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= UserType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceRoles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamespaceRoles = append(m.NamespaceRoles, &NamespaceRoleType{})
			if err := m.NamespaceRoles[len(m.NamespaceRoles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantType", wireType)
			}
			m.TenantType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantType |= schema.TenantType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureFlags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeatureFlags = append(m.FeatureFlags, &FeatureFlagType{})
			if err := m.FeatureFlags[len(m.FeatureFlags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TosCurrentVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TosCurrentVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TosAccepted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TosAccepted = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdmType", wireType)
			}
			m.IdmType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdmType |= IdmType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainOwner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DomainOwner = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BillingFlags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BillingFlags = append(m.BillingFlags, &BillingFeatureIndicator{})
			if err := m.BillingFlags[len(m.BillingFlags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreationTimestamp == nil {
				m.CreationTimestamp = &types.Timestamp{}
			}
			if err := m.CreationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Company", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Company = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanType", wireType)
			}
			m.PlanType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlanType |= schema.PlanType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivePlanTransitionUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActivePlanTransitionUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantFlags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TenantFlags == nil {
				m.TenantFlags = make(map[string]bool)
			}
			var mapkey string
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TenantFlags[mapkey] = mapvalue
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLoginTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastLoginTimestamp == nil {
				m.LastLoginTimestamp = &types.Timestamp{}
			}
			if err := m.LastLoginTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= FSMState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CascadeDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CascadeDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CascadeDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CascadeDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CascadeDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CascadeDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteOk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeleteOk = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &CascadeDeleteItemType{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CascadeDeleteItemType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CascadeDeleteItemType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CascadeDeleteItemType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptTOSRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptTOSRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptTOSRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TosAccepted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TosAccepted = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptTOSResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptTOSResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptTOSResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTOSRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTOSRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTOSRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTOSResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTOSResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTOSResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureFlagType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureFlagType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureFlagType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPublicCustomapi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPublicCustomapi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPublicCustomapi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPublicCustomapi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPublicCustomapi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPublicCustomapi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPublicCustomapi = fmt.Errorf("proto: unexpected end of group")
)
