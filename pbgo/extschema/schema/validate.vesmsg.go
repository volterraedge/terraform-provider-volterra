// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package schema

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AnyRules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AnyRules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AnyRules) DeepCopy() *AnyRules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AnyRules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AnyRules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AnyRules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AnyRulesValidator().Validate(ctx, m, opts...)
}

type ValidateAnyRules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAnyRules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AnyRules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AnyRules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["in"]; exists {

		vOpts := append(opts, db.WithValidateField("in"))
		for idx, item := range m.GetIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["not_in"]; exists {

		vOpts := append(opts, db.WithValidateField("not_in"))
		for idx, item := range m.GetNotIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["required"]; exists {

		vOpts := append(opts, db.WithValidateField("required"))
		if err := fv(ctx, m.GetRequired(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAnyRulesValidator = func() *ValidateAnyRules {
	v := &ValidateAnyRules{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func AnyRulesValidator() db.Validator {
	return DefaultAnyRulesValidator
}

// augmented methods on protoc/std generated struct

func (m *BoolRules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BoolRules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BoolRules) DeepCopy() *BoolRules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BoolRules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BoolRules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BoolRules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BoolRulesValidator().Validate(ctx, m, opts...)
}

type ValidateBoolRules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBoolRules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BoolRules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BoolRules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["const"]; exists {

		vOpts := append(opts, db.WithValidateField("const"))
		if err := fv(ctx, m.GetConst(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBoolRulesValidator = func() *ValidateBoolRules {
	v := &ValidateBoolRules{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func BoolRulesValidator() db.Validator {
	return DefaultBoolRulesValidator
}

// augmented methods on protoc/std generated struct

func (m *BytesRules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BytesRules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BytesRules) DeepCopy() *BytesRules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BytesRules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BytesRules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BytesRules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BytesRulesValidator().Validate(ctx, m, opts...)
}

type ValidateBytesRules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBytesRules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BytesRules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BytesRules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["const"]; exists {

		vOpts := append(opts, db.WithValidateField("const"))
		if err := fv(ctx, m.GetConst(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["contains"]; exists {

		vOpts := append(opts, db.WithValidateField("contains"))
		if err := fv(ctx, m.GetContains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["in"]; exists {

		vOpts := append(opts, db.WithValidateField("in"))
		for idx, item := range m.GetIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["len"]; exists {

		vOpts := append(opts, db.WithValidateField("len"))
		if err := fv(ctx, m.GetLen(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_len"]; exists {

		vOpts := append(opts, db.WithValidateField("max_len"))
		if err := fv(ctx, m.GetMaxLen(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["min_len"]; exists {

		vOpts := append(opts, db.WithValidateField("min_len"))
		if err := fv(ctx, m.GetMinLen(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["not_in"]; exists {

		vOpts := append(opts, db.WithValidateField("not_in"))
		for idx, item := range m.GetNotIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["pattern"]; exists {

		vOpts := append(opts, db.WithValidateField("pattern"))
		if err := fv(ctx, m.GetPattern(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["prefix"]; exists {

		vOpts := append(opts, db.WithValidateField("prefix"))
		if err := fv(ctx, m.GetPrefix(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["suffix"]; exists {

		vOpts := append(opts, db.WithValidateField("suffix"))
		if err := fv(ctx, m.GetSuffix(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetWellKnown().(type) {
	case *BytesRules_Ip:
		if fv, exists := v.FldValidators["well_known.ip"]; exists {
			val := m.GetWellKnown().(*BytesRules_Ip).Ip
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BytesRules_Ipv4:
		if fv, exists := v.FldValidators["well_known.ipv4"]; exists {
			val := m.GetWellKnown().(*BytesRules_Ipv4).Ipv4
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("ipv4"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BytesRules_Ipv6:
		if fv, exists := v.FldValidators["well_known.ipv6"]; exists {
			val := m.GetWellKnown().(*BytesRules_Ipv6).Ipv6
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("ipv6"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBytesRulesValidator = func() *ValidateBytesRules {
	v := &ValidateBytesRules{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func BytesRulesValidator() db.Validator {
	return DefaultBytesRulesValidator
}

// augmented methods on protoc/std generated struct

func (m *DateRangeRules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DateRangeRules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DateRangeRules) DeepCopy() *DateRangeRules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DateRangeRules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DateRangeRules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DateRangeRules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DateRangeRulesValidator().Validate(ctx, m, opts...)
}

type ValidateDateRangeRules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDateRangeRules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DateRangeRules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DateRangeRules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["max_duration"]; exists {

		vOpts := append(opts, db.WithValidateField("max_duration"))
		if err := fv(ctx, m.GetMaxDuration(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["min_duration"]; exists {

		vOpts := append(opts, db.WithValidateField("min_duration"))
		if err := fv(ctx, m.GetMinDuration(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDateRangeRulesValidator = func() *ValidateDateRangeRules {
	v := &ValidateDateRangeRules{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DateRangeRulesValidator() db.Validator {
	return DefaultDateRangeRulesValidator
}

// augmented methods on protoc/std generated struct

func (m *DoubleRules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DoubleRules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DoubleRules) DeepCopy() *DoubleRules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DoubleRules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DoubleRules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DoubleRules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DoubleRulesValidator().Validate(ctx, m, opts...)
}

type ValidateDoubleRules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDoubleRules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DoubleRules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DoubleRules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["const"]; exists {

		vOpts := append(opts, db.WithValidateField("const"))
		if err := fv(ctx, m.GetConst(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gt"]; exists {

		vOpts := append(opts, db.WithValidateField("gt"))
		if err := fv(ctx, m.GetGt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gte"]; exists {

		vOpts := append(opts, db.WithValidateField("gte"))
		if err := fv(ctx, m.GetGte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["in"]; exists {

		vOpts := append(opts, db.WithValidateField("in"))
		for idx, item := range m.GetIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["lt"]; exists {

		vOpts := append(opts, db.WithValidateField("lt"))
		if err := fv(ctx, m.GetLt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["lte"]; exists {

		vOpts := append(opts, db.WithValidateField("lte"))
		if err := fv(ctx, m.GetLte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["not_in"]; exists {

		vOpts := append(opts, db.WithValidateField("not_in"))
		for idx, item := range m.GetNotIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDoubleRulesValidator = func() *ValidateDoubleRules {
	v := &ValidateDoubleRules{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DoubleRulesValidator() db.Validator {
	return DefaultDoubleRulesValidator
}

// augmented methods on protoc/std generated struct

func (m *DurationRules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DurationRules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DurationRules) DeepCopy() *DurationRules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DurationRules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DurationRules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DurationRules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DurationRulesValidator().Validate(ctx, m, opts...)
}

type ValidateDurationRules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDurationRules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DurationRules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DurationRules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["const"]; exists {

		vOpts := append(opts, db.WithValidateField("const"))
		if err := fv(ctx, m.GetConst(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gt"]; exists {

		vOpts := append(opts, db.WithValidateField("gt"))
		if err := fv(ctx, m.GetGt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gte"]; exists {

		vOpts := append(opts, db.WithValidateField("gte"))
		if err := fv(ctx, m.GetGte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["in"]; exists {

		vOpts := append(opts, db.WithValidateField("in"))
		for idx, item := range m.GetIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["lt"]; exists {

		vOpts := append(opts, db.WithValidateField("lt"))
		if err := fv(ctx, m.GetLt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["lte"]; exists {

		vOpts := append(opts, db.WithValidateField("lte"))
		if err := fv(ctx, m.GetLte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["not_in"]; exists {

		vOpts := append(opts, db.WithValidateField("not_in"))
		for idx, item := range m.GetNotIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["required"]; exists {

		vOpts := append(opts, db.WithValidateField("required"))
		if err := fv(ctx, m.GetRequired(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDurationRulesValidator = func() *ValidateDurationRules {
	v := &ValidateDurationRules{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DurationRulesValidator() db.Validator {
	return DefaultDurationRulesValidator
}

// augmented methods on protoc/std generated struct

func (m *EnumRules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *EnumRules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *EnumRules) DeepCopy() *EnumRules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &EnumRules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *EnumRules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *EnumRules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EnumRulesValidator().Validate(ctx, m, opts...)
}

type ValidateEnumRules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEnumRules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*EnumRules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *EnumRules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["const"]; exists {

		vOpts := append(opts, db.WithValidateField("const"))
		if err := fv(ctx, m.GetConst(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["defined_only"]; exists {

		vOpts := append(opts, db.WithValidateField("defined_only"))
		if err := fv(ctx, m.GetDefinedOnly(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["in"]; exists {

		vOpts := append(opts, db.WithValidateField("in"))
		for idx, item := range m.GetIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["not_in"]; exists {

		vOpts := append(opts, db.WithValidateField("not_in"))
		for idx, item := range m.GetNotIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEnumRulesValidator = func() *ValidateEnumRules {
	v := &ValidateEnumRules{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func EnumRulesValidator() db.Validator {
	return DefaultEnumRulesValidator
}

// augmented methods on protoc/std generated struct

func (m *FieldRules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FieldRules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FieldRules) DeepCopy() *FieldRules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FieldRules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FieldRules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FieldRules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FieldRulesValidator().Validate(ctx, m, opts...)
}

type ValidateFieldRules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFieldRules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FieldRules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FieldRules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetType().(type) {
	case *FieldRules_Float:
		if fv, exists := v.FldValidators["type.float"]; exists {
			val := m.GetType().(*FieldRules_Float).Float
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("float"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldRules_Double:
		if fv, exists := v.FldValidators["type.double"]; exists {
			val := m.GetType().(*FieldRules_Double).Double
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("double"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldRules_Int32:
		if fv, exists := v.FldValidators["type.int32"]; exists {
			val := m.GetType().(*FieldRules_Int32).Int32
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("int32"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldRules_Int64:
		if fv, exists := v.FldValidators["type.int64"]; exists {
			val := m.GetType().(*FieldRules_Int64).Int64
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("int64"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldRules_Uint32:
		if fv, exists := v.FldValidators["type.uint32"]; exists {
			val := m.GetType().(*FieldRules_Uint32).Uint32
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("uint32"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldRules_Uint64:
		if fv, exists := v.FldValidators["type.uint64"]; exists {
			val := m.GetType().(*FieldRules_Uint64).Uint64
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("uint64"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldRules_Sint32:
		if fv, exists := v.FldValidators["type.sint32"]; exists {
			val := m.GetType().(*FieldRules_Sint32).Sint32
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("sint32"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldRules_Sint64:
		if fv, exists := v.FldValidators["type.sint64"]; exists {
			val := m.GetType().(*FieldRules_Sint64).Sint64
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("sint64"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldRules_Fixed32:
		if fv, exists := v.FldValidators["type.fixed32"]; exists {
			val := m.GetType().(*FieldRules_Fixed32).Fixed32
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("fixed32"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldRules_Fixed64:
		if fv, exists := v.FldValidators["type.fixed64"]; exists {
			val := m.GetType().(*FieldRules_Fixed64).Fixed64
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("fixed64"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldRules_Sfixed32:
		if fv, exists := v.FldValidators["type.sfixed32"]; exists {
			val := m.GetType().(*FieldRules_Sfixed32).Sfixed32
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("sfixed32"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldRules_Sfixed64:
		if fv, exists := v.FldValidators["type.sfixed64"]; exists {
			val := m.GetType().(*FieldRules_Sfixed64).Sfixed64
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("sfixed64"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldRules_Bool:
		if fv, exists := v.FldValidators["type.bool"]; exists {
			val := m.GetType().(*FieldRules_Bool).Bool
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("bool"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldRules_String_:
		if fv, exists := v.FldValidators["type.string"]; exists {
			val := m.GetType().(*FieldRules_String_).String_
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("string"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldRules_Bytes:
		if fv, exists := v.FldValidators["type.bytes"]; exists {
			val := m.GetType().(*FieldRules_Bytes).Bytes
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("bytes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldRules_Enum:
		if fv, exists := v.FldValidators["type.enum"]; exists {
			val := m.GetType().(*FieldRules_Enum).Enum
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("enum"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldRules_Message:
		if fv, exists := v.FldValidators["type.message"]; exists {
			val := m.GetType().(*FieldRules_Message).Message
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("message"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldRules_Repeated:
		if fv, exists := v.FldValidators["type.repeated"]; exists {
			val := m.GetType().(*FieldRules_Repeated).Repeated
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("repeated"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldRules_Map:
		if fv, exists := v.FldValidators["type.map"]; exists {
			val := m.GetType().(*FieldRules_Map).Map
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("map"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldRules_Any:
		if fv, exists := v.FldValidators["type.any"]; exists {
			val := m.GetType().(*FieldRules_Any).Any
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("any"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldRules_Duration:
		if fv, exists := v.FldValidators["type.duration"]; exists {
			val := m.GetType().(*FieldRules_Duration).Duration
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("duration"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FieldRules_Timestamp:
		if fv, exists := v.FldValidators["type.timestamp"]; exists {
			val := m.GetType().(*FieldRules_Timestamp).Timestamp
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("timestamp"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFieldRulesValidator = func() *ValidateFieldRules {
	v := &ValidateFieldRules{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FieldRulesValidator() db.Validator {
	return DefaultFieldRulesValidator
}

// augmented methods on protoc/std generated struct

func (m *Fixed32Rules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Fixed32Rules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Fixed32Rules) DeepCopy() *Fixed32Rules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Fixed32Rules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Fixed32Rules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Fixed32Rules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return Fixed32RulesValidator().Validate(ctx, m, opts...)
}

type ValidateFixed32Rules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFixed32Rules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Fixed32Rules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Fixed32Rules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["const"]; exists {

		vOpts := append(opts, db.WithValidateField("const"))
		if err := fv(ctx, m.GetConst(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gt"]; exists {

		vOpts := append(opts, db.WithValidateField("gt"))
		if err := fv(ctx, m.GetGt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gte"]; exists {

		vOpts := append(opts, db.WithValidateField("gte"))
		if err := fv(ctx, m.GetGte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["in"]; exists {

		vOpts := append(opts, db.WithValidateField("in"))
		for idx, item := range m.GetIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["lt"]; exists {

		vOpts := append(opts, db.WithValidateField("lt"))
		if err := fv(ctx, m.GetLt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["lte"]; exists {

		vOpts := append(opts, db.WithValidateField("lte"))
		if err := fv(ctx, m.GetLte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["not_in"]; exists {

		vOpts := append(opts, db.WithValidateField("not_in"))
		for idx, item := range m.GetNotIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFixed32RulesValidator = func() *ValidateFixed32Rules {
	v := &ValidateFixed32Rules{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func Fixed32RulesValidator() db.Validator {
	return DefaultFixed32RulesValidator
}

// augmented methods on protoc/std generated struct

func (m *Fixed64Rules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Fixed64Rules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Fixed64Rules) DeepCopy() *Fixed64Rules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Fixed64Rules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Fixed64Rules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Fixed64Rules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return Fixed64RulesValidator().Validate(ctx, m, opts...)
}

type ValidateFixed64Rules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFixed64Rules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Fixed64Rules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Fixed64Rules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["const"]; exists {

		vOpts := append(opts, db.WithValidateField("const"))
		if err := fv(ctx, m.GetConst(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gt"]; exists {

		vOpts := append(opts, db.WithValidateField("gt"))
		if err := fv(ctx, m.GetGt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gte"]; exists {

		vOpts := append(opts, db.WithValidateField("gte"))
		if err := fv(ctx, m.GetGte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["in"]; exists {

		vOpts := append(opts, db.WithValidateField("in"))
		for idx, item := range m.GetIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["lt"]; exists {

		vOpts := append(opts, db.WithValidateField("lt"))
		if err := fv(ctx, m.GetLt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["lte"]; exists {

		vOpts := append(opts, db.WithValidateField("lte"))
		if err := fv(ctx, m.GetLte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["not_in"]; exists {

		vOpts := append(opts, db.WithValidateField("not_in"))
		for idx, item := range m.GetNotIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFixed64RulesValidator = func() *ValidateFixed64Rules {
	v := &ValidateFixed64Rules{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func Fixed64RulesValidator() db.Validator {
	return DefaultFixed64RulesValidator
}

// augmented methods on protoc/std generated struct

func (m *FloatRules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FloatRules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FloatRules) DeepCopy() *FloatRules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FloatRules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FloatRules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FloatRules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FloatRulesValidator().Validate(ctx, m, opts...)
}

type ValidateFloatRules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFloatRules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FloatRules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FloatRules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["const"]; exists {

		vOpts := append(opts, db.WithValidateField("const"))
		if err := fv(ctx, m.GetConst(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gt"]; exists {

		vOpts := append(opts, db.WithValidateField("gt"))
		if err := fv(ctx, m.GetGt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gte"]; exists {

		vOpts := append(opts, db.WithValidateField("gte"))
		if err := fv(ctx, m.GetGte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["in"]; exists {

		vOpts := append(opts, db.WithValidateField("in"))
		for idx, item := range m.GetIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["lt"]; exists {

		vOpts := append(opts, db.WithValidateField("lt"))
		if err := fv(ctx, m.GetLt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["lte"]; exists {

		vOpts := append(opts, db.WithValidateField("lte"))
		if err := fv(ctx, m.GetLte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["not_in"]; exists {

		vOpts := append(opts, db.WithValidateField("not_in"))
		for idx, item := range m.GetNotIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFloatRulesValidator = func() *ValidateFloatRules {
	v := &ValidateFloatRules{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FloatRulesValidator() db.Validator {
	return DefaultFloatRulesValidator
}

// augmented methods on protoc/std generated struct

func (m *Int32Rules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Int32Rules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Int32Rules) DeepCopy() *Int32Rules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Int32Rules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Int32Rules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Int32Rules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return Int32RulesValidator().Validate(ctx, m, opts...)
}

type ValidateInt32Rules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInt32Rules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Int32Rules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Int32Rules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["const"]; exists {

		vOpts := append(opts, db.WithValidateField("const"))
		if err := fv(ctx, m.GetConst(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gt"]; exists {

		vOpts := append(opts, db.WithValidateField("gt"))
		if err := fv(ctx, m.GetGt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gte"]; exists {

		vOpts := append(opts, db.WithValidateField("gte"))
		if err := fv(ctx, m.GetGte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["in"]; exists {

		vOpts := append(opts, db.WithValidateField("in"))
		for idx, item := range m.GetIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["lt"]; exists {

		vOpts := append(opts, db.WithValidateField("lt"))
		if err := fv(ctx, m.GetLt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["lte"]; exists {

		vOpts := append(opts, db.WithValidateField("lte"))
		if err := fv(ctx, m.GetLte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["not_in"]; exists {

		vOpts := append(opts, db.WithValidateField("not_in"))
		for idx, item := range m.GetNotIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInt32RulesValidator = func() *ValidateInt32Rules {
	v := &ValidateInt32Rules{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func Int32RulesValidator() db.Validator {
	return DefaultInt32RulesValidator
}

// augmented methods on protoc/std generated struct

func (m *Int64Rules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Int64Rules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Int64Rules) DeepCopy() *Int64Rules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Int64Rules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Int64Rules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Int64Rules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return Int64RulesValidator().Validate(ctx, m, opts...)
}

type ValidateInt64Rules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInt64Rules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Int64Rules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Int64Rules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["const"]; exists {

		vOpts := append(opts, db.WithValidateField("const"))
		if err := fv(ctx, m.GetConst(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gt"]; exists {

		vOpts := append(opts, db.WithValidateField("gt"))
		if err := fv(ctx, m.GetGt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gte"]; exists {

		vOpts := append(opts, db.WithValidateField("gte"))
		if err := fv(ctx, m.GetGte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["in"]; exists {

		vOpts := append(opts, db.WithValidateField("in"))
		for idx, item := range m.GetIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["lt"]; exists {

		vOpts := append(opts, db.WithValidateField("lt"))
		if err := fv(ctx, m.GetLt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["lte"]; exists {

		vOpts := append(opts, db.WithValidateField("lte"))
		if err := fv(ctx, m.GetLte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["not_in"]; exists {

		vOpts := append(opts, db.WithValidateField("not_in"))
		for idx, item := range m.GetNotIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInt64RulesValidator = func() *ValidateInt64Rules {
	v := &ValidateInt64Rules{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func Int64RulesValidator() db.Validator {
	return DefaultInt64RulesValidator
}

// augmented methods on protoc/std generated struct

func (m *MapRules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MapRules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MapRules) DeepCopy() *MapRules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MapRules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MapRules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MapRules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MapRulesValidator().Validate(ctx, m, opts...)
}

type ValidateMapRules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMapRules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MapRules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MapRules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["keys"]; exists {

		vOpts := append(opts, db.WithValidateField("keys"))
		if err := fv(ctx, m.GetKeys(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_pairs"]; exists {

		vOpts := append(opts, db.WithValidateField("max_pairs"))
		if err := fv(ctx, m.GetMaxPairs(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["min_pairs"]; exists {

		vOpts := append(opts, db.WithValidateField("min_pairs"))
		if err := fv(ctx, m.GetMinPairs(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["no_sparse"]; exists {

		vOpts := append(opts, db.WithValidateField("no_sparse"))
		if err := fv(ctx, m.GetNoSparse(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["unique_values"]; exists {

		vOpts := append(opts, db.WithValidateField("unique_values"))
		if err := fv(ctx, m.GetUniqueValues(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["values"]; exists {

		vOpts := append(opts, db.WithValidateField("values"))
		if err := fv(ctx, m.GetValues(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMapRulesValidator = func() *ValidateMapRules {
	v := &ValidateMapRules{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func MapRulesValidator() db.Validator {
	return DefaultMapRulesValidator
}

// augmented methods on protoc/std generated struct

func (m *MessageRules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MessageRules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MessageRules) DeepCopy() *MessageRules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MessageRules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MessageRules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MessageRules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MessageRulesValidator().Validate(ctx, m, opts...)
}

type ValidateMessageRules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMessageRules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MessageRules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MessageRules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["date_range"]; exists {

		vOpts := append(opts, db.WithValidateField("date_range"))
		if err := fv(ctx, m.GetDateRange(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["file_content_max_bytes"]; exists {

		vOpts := append(opts, db.WithValidateField("file_content_max_bytes"))
		if err := fv(ctx, m.GetFileContentMaxBytes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["file_content_min_bytes"]; exists {

		vOpts := append(opts, db.WithValidateField("file_content_min_bytes"))
		if err := fv(ctx, m.GetFileContentMinBytes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["required"]; exists {

		vOpts := append(opts, db.WithValidateField("required"))
		if err := fv(ctx, m.GetRequired(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["required_one_nonzero_field"]; exists {

		vOpts := append(opts, db.WithValidateField("required_one_nonzero_field"))
		if err := fv(ctx, m.GetRequiredOneNonzeroField(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["required_oneof"]; exists {

		vOpts := append(opts, db.WithValidateField("required_oneof"))
		if err := fv(ctx, m.GetRequiredOneof(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["skip"]; exists {

		vOpts := append(opts, db.WithValidateField("skip"))
		if err := fv(ctx, m.GetSkip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["validate_ipv4_range"]; exists {

		vOpts := append(opts, db.WithValidateField("validate_ipv4_range"))
		if err := fv(ctx, m.GetValidateIpv4Range(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["validate_ipv6_range"]; exists {

		vOpts := append(opts, db.WithValidateField("validate_ipv6_range"))
		if err := fv(ctx, m.GetValidateIpv6Range(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMessageRulesValidator = func() *ValidateMessageRules {
	v := &ValidateMessageRules{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func MessageRulesValidator() db.Validator {
	return DefaultMessageRulesValidator
}

// augmented methods on protoc/std generated struct

func (m *RepeatedRules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RepeatedRules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RepeatedRules) DeepCopy() *RepeatedRules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RepeatedRules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RepeatedRules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RepeatedRules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RepeatedRulesValidator().Validate(ctx, m, opts...)
}

type ValidateRepeatedRules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRepeatedRules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RepeatedRules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RepeatedRules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["items"]; exists {

		vOpts := append(opts, db.WithValidateField("items"))
		if err := fv(ctx, m.GetItems(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_items"]; exists {

		vOpts := append(opts, db.WithValidateField("max_items"))
		if err := fv(ctx, m.GetMaxItems(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["min_items"]; exists {

		vOpts := append(opts, db.WithValidateField("min_items"))
		if err := fv(ctx, m.GetMinItems(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["num_items"]; exists {

		vOpts := append(opts, db.WithValidateField("num_items"))
		if err := fv(ctx, m.GetNumItems(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["unique"]; exists {

		vOpts := append(opts, db.WithValidateField("unique"))
		if err := fv(ctx, m.GetUnique(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["unique_metadata_name"]; exists {

		vOpts := append(opts, db.WithValidateField("unique_metadata_name"))
		if err := fv(ctx, m.GetUniqueMetadataName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["unique_threat_level"]; exists {

		vOpts := append(opts, db.WithValidateField("unique_threat_level"))
		if err := fv(ctx, m.GetUniqueThreatLevel(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRepeatedRulesValidator = func() *ValidateRepeatedRules {
	v := &ValidateRepeatedRules{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func RepeatedRulesValidator() db.Validator {
	return DefaultRepeatedRulesValidator
}

// augmented methods on protoc/std generated struct

func (m *SFixed32Rules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SFixed32Rules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SFixed32Rules) DeepCopy() *SFixed32Rules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SFixed32Rules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SFixed32Rules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SFixed32Rules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SFixed32RulesValidator().Validate(ctx, m, opts...)
}

type ValidateSFixed32Rules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSFixed32Rules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SFixed32Rules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SFixed32Rules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["const"]; exists {

		vOpts := append(opts, db.WithValidateField("const"))
		if err := fv(ctx, m.GetConst(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gt"]; exists {

		vOpts := append(opts, db.WithValidateField("gt"))
		if err := fv(ctx, m.GetGt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gte"]; exists {

		vOpts := append(opts, db.WithValidateField("gte"))
		if err := fv(ctx, m.GetGte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["in"]; exists {

		vOpts := append(opts, db.WithValidateField("in"))
		for idx, item := range m.GetIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["lt"]; exists {

		vOpts := append(opts, db.WithValidateField("lt"))
		if err := fv(ctx, m.GetLt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["lte"]; exists {

		vOpts := append(opts, db.WithValidateField("lte"))
		if err := fv(ctx, m.GetLte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["not_in"]; exists {

		vOpts := append(opts, db.WithValidateField("not_in"))
		for idx, item := range m.GetNotIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSFixed32RulesValidator = func() *ValidateSFixed32Rules {
	v := &ValidateSFixed32Rules{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SFixed32RulesValidator() db.Validator {
	return DefaultSFixed32RulesValidator
}

// augmented methods on protoc/std generated struct

func (m *SFixed64Rules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SFixed64Rules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SFixed64Rules) DeepCopy() *SFixed64Rules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SFixed64Rules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SFixed64Rules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SFixed64Rules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SFixed64RulesValidator().Validate(ctx, m, opts...)
}

type ValidateSFixed64Rules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSFixed64Rules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SFixed64Rules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SFixed64Rules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["const"]; exists {

		vOpts := append(opts, db.WithValidateField("const"))
		if err := fv(ctx, m.GetConst(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gt"]; exists {

		vOpts := append(opts, db.WithValidateField("gt"))
		if err := fv(ctx, m.GetGt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gte"]; exists {

		vOpts := append(opts, db.WithValidateField("gte"))
		if err := fv(ctx, m.GetGte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["in"]; exists {

		vOpts := append(opts, db.WithValidateField("in"))
		for idx, item := range m.GetIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["lt"]; exists {

		vOpts := append(opts, db.WithValidateField("lt"))
		if err := fv(ctx, m.GetLt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["lte"]; exists {

		vOpts := append(opts, db.WithValidateField("lte"))
		if err := fv(ctx, m.GetLte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["not_in"]; exists {

		vOpts := append(opts, db.WithValidateField("not_in"))
		for idx, item := range m.GetNotIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSFixed64RulesValidator = func() *ValidateSFixed64Rules {
	v := &ValidateSFixed64Rules{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SFixed64RulesValidator() db.Validator {
	return DefaultSFixed64RulesValidator
}

// augmented methods on protoc/std generated struct

func (m *SInt32Rules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SInt32Rules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SInt32Rules) DeepCopy() *SInt32Rules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SInt32Rules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SInt32Rules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SInt32Rules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SInt32RulesValidator().Validate(ctx, m, opts...)
}

type ValidateSInt32Rules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSInt32Rules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SInt32Rules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SInt32Rules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["const"]; exists {

		vOpts := append(opts, db.WithValidateField("const"))
		if err := fv(ctx, m.GetConst(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gt"]; exists {

		vOpts := append(opts, db.WithValidateField("gt"))
		if err := fv(ctx, m.GetGt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gte"]; exists {

		vOpts := append(opts, db.WithValidateField("gte"))
		if err := fv(ctx, m.GetGte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["in"]; exists {

		vOpts := append(opts, db.WithValidateField("in"))
		for idx, item := range m.GetIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["lt"]; exists {

		vOpts := append(opts, db.WithValidateField("lt"))
		if err := fv(ctx, m.GetLt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["lte"]; exists {

		vOpts := append(opts, db.WithValidateField("lte"))
		if err := fv(ctx, m.GetLte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["not_in"]; exists {

		vOpts := append(opts, db.WithValidateField("not_in"))
		for idx, item := range m.GetNotIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSInt32RulesValidator = func() *ValidateSInt32Rules {
	v := &ValidateSInt32Rules{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SInt32RulesValidator() db.Validator {
	return DefaultSInt32RulesValidator
}

// augmented methods on protoc/std generated struct

func (m *SInt64Rules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SInt64Rules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SInt64Rules) DeepCopy() *SInt64Rules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SInt64Rules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SInt64Rules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SInt64Rules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SInt64RulesValidator().Validate(ctx, m, opts...)
}

type ValidateSInt64Rules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSInt64Rules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SInt64Rules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SInt64Rules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["const"]; exists {

		vOpts := append(opts, db.WithValidateField("const"))
		if err := fv(ctx, m.GetConst(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gt"]; exists {

		vOpts := append(opts, db.WithValidateField("gt"))
		if err := fv(ctx, m.GetGt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gte"]; exists {

		vOpts := append(opts, db.WithValidateField("gte"))
		if err := fv(ctx, m.GetGte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["in"]; exists {

		vOpts := append(opts, db.WithValidateField("in"))
		for idx, item := range m.GetIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["lt"]; exists {

		vOpts := append(opts, db.WithValidateField("lt"))
		if err := fv(ctx, m.GetLt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["lte"]; exists {

		vOpts := append(opts, db.WithValidateField("lte"))
		if err := fv(ctx, m.GetLte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["not_in"]; exists {

		vOpts := append(opts, db.WithValidateField("not_in"))
		for idx, item := range m.GetNotIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSInt64RulesValidator = func() *ValidateSInt64Rules {
	v := &ValidateSInt64Rules{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SInt64RulesValidator() db.Validator {
	return DefaultSInt64RulesValidator
}

// augmented methods on protoc/std generated struct

func (m *StringRules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StringRules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StringRules) DeepCopy() *StringRules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StringRules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StringRules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StringRules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StringRulesValidator().Validate(ctx, m, opts...)
}

type ValidateStringRules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStringRules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StringRules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StringRules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["const"]; exists {

		vOpts := append(opts, db.WithValidateField("const"))
		if err := fv(ctx, m.GetConst(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["contains"]; exists {

		vOpts := append(opts, db.WithValidateField("contains"))
		if err := fv(ctx, m.GetContains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["glob_pattern"]; exists {

		vOpts := append(opts, db.WithValidateField("glob_pattern"))
		if err := fv(ctx, m.GetGlobPattern(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["in"]; exists {

		vOpts := append(opts, db.WithValidateField("in"))
		for idx, item := range m.GetIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["len"]; exists {

		vOpts := append(opts, db.WithValidateField("len"))
		if err := fv(ctx, m.GetLen(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["len_bytes"]; exists {

		vOpts := append(opts, db.WithValidateField("len_bytes"))
		if err := fv(ctx, m.GetLenBytes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_bytes"]; exists {

		vOpts := append(opts, db.WithValidateField("max_bytes"))
		if err := fv(ctx, m.GetMaxBytes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_ip_prefix_length"]; exists {

		vOpts := append(opts, db.WithValidateField("max_ip_prefix_length"))
		if err := fv(ctx, m.GetMaxIpPrefixLength(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_len"]; exists {

		vOpts := append(opts, db.WithValidateField("max_len"))
		if err := fv(ctx, m.GetMaxLen(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_ports"]; exists {

		vOpts := append(opts, db.WithValidateField("max_ports"))
		if err := fv(ctx, m.GetMaxPorts(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_time_interval"]; exists {

		vOpts := append(opts, db.WithValidateField("max_time_interval"))
		if err := fv(ctx, m.GetMaxTimeInterval(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["min_bytes"]; exists {

		vOpts := append(opts, db.WithValidateField("min_bytes"))
		if err := fv(ctx, m.GetMinBytes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["min_ip_prefix_length"]; exists {

		vOpts := append(opts, db.WithValidateField("min_ip_prefix_length"))
		if err := fv(ctx, m.GetMinIpPrefixLength(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["min_len"]; exists {

		vOpts := append(opts, db.WithValidateField("min_len"))
		if err := fv(ctx, m.GetMinLen(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["min_time_interval"]; exists {

		vOpts := append(opts, db.WithValidateField("min_time_interval"))
		if err := fv(ctx, m.GetMinTimeInterval(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["not_in"]; exists {

		vOpts := append(opts, db.WithValidateField("not_in"))
		for idx, item := range m.GetNotIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["pattern"]; exists {

		vOpts := append(opts, db.WithValidateField("pattern"))
		if err := fv(ctx, m.GetPattern(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["prefix"]; exists {

		vOpts := append(opts, db.WithValidateField("prefix"))
		if err := fv(ctx, m.GetPrefix(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["suffix"]; exists {

		vOpts := append(opts, db.WithValidateField("suffix"))
		if err := fv(ctx, m.GetSuffix(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetWellKnown().(type) {
	case *StringRules_Email:
		if fv, exists := v.FldValidators["well_known.email"]; exists {
			val := m.GetWellKnown().(*StringRules_Email).Email
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("email"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_Hostname:
		if fv, exists := v.FldValidators["well_known.hostname"]; exists {
			val := m.GetWellKnown().(*StringRules_Hostname).Hostname
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("hostname"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_Ip:
		if fv, exists := v.FldValidators["well_known.ip"]; exists {
			val := m.GetWellKnown().(*StringRules_Ip).Ip
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_Ipv4:
		if fv, exists := v.FldValidators["well_known.ipv4"]; exists {
			val := m.GetWellKnown().(*StringRules_Ipv4).Ipv4
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("ipv4"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_Ipv6:
		if fv, exists := v.FldValidators["well_known.ipv6"]; exists {
			val := m.GetWellKnown().(*StringRules_Ipv6).Ipv6
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("ipv6"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_Uri:
		if fv, exists := v.FldValidators["well_known.uri"]; exists {
			val := m.GetWellKnown().(*StringRules_Uri).Uri
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("uri"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_UriRef:
		if fv, exists := v.FldValidators["well_known.uri_ref"]; exists {
			val := m.GetWellKnown().(*StringRules_UriRef).UriRef
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("uri_ref"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_IpPrefix:
		if fv, exists := v.FldValidators["well_known.ip_prefix"]; exists {
			val := m.GetWellKnown().(*StringRules_IpPrefix).IpPrefix
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("ip_prefix"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_PortRange:
		if fv, exists := v.FldValidators["well_known.port_range"]; exists {
			val := m.GetWellKnown().(*StringRules_PortRange).PortRange
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("port_range"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_Mac:
		if fv, exists := v.FldValidators["well_known.mac"]; exists {
			val := m.GetWellKnown().(*StringRules_Mac).Mac
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("mac"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_Regex:
		if fv, exists := v.FldValidators["well_known.regex"]; exists {
			val := m.GetWellKnown().(*StringRules_Regex).Regex
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("regex"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_HttpHeaderField:
		if fv, exists := v.FldValidators["well_known.http_header_field"]; exists {
			val := m.GetWellKnown().(*StringRules_HttpHeaderField).HttpHeaderField
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("http_header_field"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_K8SLabelValue:
		if fv, exists := v.FldValidators["well_known.k8s_label_value"]; exists {
			val := m.GetWellKnown().(*StringRules_K8SLabelValue).K8SLabelValue
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("k8s_label_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_NotEmpty:
		if fv, exists := v.FldValidators["well_known.not_empty"]; exists {
			val := m.GetWellKnown().(*StringRules_NotEmpty).NotEmpty
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("not_empty"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_Hostport:
		if fv, exists := v.FldValidators["well_known.hostport"]; exists {
			val := m.GetWellKnown().(*StringRules_Hostport).Hostport
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("hostport"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_JsonPath:
		if fv, exists := v.FldValidators["well_known.json_path"]; exists {
			val := m.GetWellKnown().(*StringRules_JsonPath).JsonPath
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("json_path"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_Hex:
		if fv, exists := v.FldValidators["well_known.hex"]; exists {
			val := m.GetWellKnown().(*StringRules_Hex).Hex
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("hex"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_Ipv4Prefix:
		if fv, exists := v.FldValidators["well_known.ipv4_prefix"]; exists {
			val := m.GetWellKnown().(*StringRules_Ipv4Prefix).Ipv4Prefix
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("ipv4_prefix"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_Ipv6Prefix:
		if fv, exists := v.FldValidators["well_known.ipv6_prefix"]; exists {
			val := m.GetWellKnown().(*StringRules_Ipv6Prefix).Ipv6Prefix
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("ipv6_prefix"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_VhDomain:
		if fv, exists := v.FldValidators["well_known.vh_domain"]; exists {
			val := m.GetWellKnown().(*StringRules_VhDomain).VhDomain
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("vh_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_VesObjectName:
		if fv, exists := v.FldValidators["well_known.ves_object_name"]; exists {
			val := m.GetWellKnown().(*StringRules_VesObjectName).VesObjectName
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("ves_object_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_IanaSvcName:
		if fv, exists := v.FldValidators["well_known.iana_svc_name"]; exists {
			val := m.GetWellKnown().(*StringRules_IanaSvcName).IanaSvcName
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("iana_svc_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_Dns_1123Label:
		if fv, exists := v.FldValidators["well_known.dns_1123_label"]; exists {
			val := m.GetWellKnown().(*StringRules_Dns_1123Label).Dns_1123Label
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("dns_1123_label"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_UnixFilePath:
		if fv, exists := v.FldValidators["well_known.unix_file_path"]; exists {
			val := m.GetWellKnown().(*StringRules_UnixFilePath).UnixFilePath
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("unix_file_path"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_PhoneNumber:
		if fv, exists := v.FldValidators["well_known.phone_number"]; exists {
			val := m.GetWellKnown().(*StringRules_PhoneNumber).PhoneNumber
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("phone_number"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_PortRangeList:
		if fv, exists := v.FldValidators["well_known.port_range_list"]; exists {
			val := m.GetWellKnown().(*StringRules_PortRangeList).PortRangeList
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("port_range_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_VhDomainNoPort:
		if fv, exists := v.FldValidators["well_known.vh_domain_no_port"]; exists {
			val := m.GetWellKnown().(*StringRules_VhDomainNoPort).VhDomainNoPort
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("vh_domain_no_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_HostnameOrIp:
		if fv, exists := v.FldValidators["well_known.hostname_or_ip"]; exists {
			val := m.GetWellKnown().(*StringRules_HostnameOrIp).HostnameOrIp
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("hostname_or_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_K8SLabelSelector:
		if fv, exists := v.FldValidators["well_known.k8s_label_selector"]; exists {
			val := m.GetWellKnown().(*StringRules_K8SLabelSelector).K8SLabelSelector
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("k8s_label_selector"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_HttpPath:
		if fv, exists := v.FldValidators["well_known.http_path"]; exists {
			val := m.GetWellKnown().(*StringRules_HttpPath).HttpPath
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("http_path"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_TimeInterval:
		if fv, exists := v.FldValidators["well_known.time_interval"]; exists {
			val := m.GetWellKnown().(*StringRules_TimeInterval).TimeInterval
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("time_interval"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_EtldPlusOne:
		if fv, exists := v.FldValidators["well_known.etld_plus_one"]; exists {
			val := m.GetWellKnown().(*StringRules_EtldPlusOne).EtldPlusOne
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("etld_plus_one"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_CertificateUrl:
		if fv, exists := v.FldValidators["well_known.certificate_url"]; exists {
			val := m.GetWellKnown().(*StringRules_CertificateUrl).CertificateUrl
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("certificate_url"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_TruststoreUrl:
		if fv, exists := v.FldValidators["well_known.truststore_url"]; exists {
			val := m.GetWellKnown().(*StringRules_TruststoreUrl).TruststoreUrl
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("truststore_url"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_TemplatedHttpPath:
		if fv, exists := v.FldValidators["well_known.templated_http_path"]; exists {
			val := m.GetWellKnown().(*StringRules_TemplatedHttpPath).TemplatedHttpPath
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("templated_http_path"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_Glob:
		if fv, exists := v.FldValidators["well_known.glob"]; exists {
			val := m.GetWellKnown().(*StringRules_Glob).Glob
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("glob"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_VesServiceNamespaceName:
		if fv, exists := v.FldValidators["well_known.ves_service_namespace_name"]; exists {
			val := m.GetWellKnown().(*StringRules_VesServiceNamespaceName).VesServiceNamespaceName
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("ves_service_namespace_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_HttpStatusRange:
		if fv, exists := v.FldValidators["well_known.http_status_range"]; exists {
			val := m.GetWellKnown().(*StringRules_HttpStatusRange).HttpStatusRange
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("http_status_range"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_QueryTime:
		if fv, exists := v.FldValidators["well_known.query_time"]; exists {
			val := m.GetWellKnown().(*StringRules_QueryTime).QueryTime
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("query_time"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_QueryStep:
		if fv, exists := v.FldValidators["well_known.query_step"]; exists {
			val := m.GetWellKnown().(*StringRules_QueryStep).QueryStep
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("query_step"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_Ipv4PrefixStrict:
		if fv, exists := v.FldValidators["well_known.ipv4_prefix_strict"]; exists {
			val := m.GetWellKnown().(*StringRules_Ipv4PrefixStrict).Ipv4PrefixStrict
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("ipv4_prefix_strict"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_Ipv6PrefixStrict:
		if fv, exists := v.FldValidators["well_known.ipv6_prefix_strict"]; exists {
			val := m.GetWellKnown().(*StringRules_Ipv6PrefixStrict).Ipv6PrefixStrict
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("ipv6_prefix_strict"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_IpPrefixStrict:
		if fv, exists := v.FldValidators["well_known.ip_prefix_strict"]; exists {
			val := m.GetWellKnown().(*StringRules_IpPrefixStrict).IpPrefixStrict
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("ip_prefix_strict"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_IntermediateCertificateChainUrl:
		if fv, exists := v.FldValidators["well_known.intermediate_certificate_chain_url"]; exists {
			val := m.GetWellKnown().(*StringRules_IntermediateCertificateChainUrl).IntermediateCertificateChainUrl
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("intermediate_certificate_chain_url"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_CookieName:
		if fv, exists := v.FldValidators["well_known.cookie_name"]; exists {
			val := m.GetWellKnown().(*StringRules_CookieName).CookieName
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("cookie_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_UniquePortRangeList:
		if fv, exists := v.FldValidators["well_known.unique_port_range_list"]; exists {
			val := m.GetWellKnown().(*StringRules_UniquePortRangeList).UniquePortRangeList
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("unique_port_range_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_IpGloballyRoutable:
		if fv, exists := v.FldValidators["well_known.ip_globally_routable"]; exists {
			val := m.GetWellKnown().(*StringRules_IpGloballyRoutable).IpGloballyRoutable
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("ip_globally_routable"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_Ipv4GloballyRoutable:
		if fv, exists := v.FldValidators["well_known.ipv4_globally_routable"]; exists {
			val := m.GetWellKnown().(*StringRules_Ipv4GloballyRoutable).Ipv4GloballyRoutable
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("ipv4_globally_routable"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_Ipv6GloballyRoutable:
		if fv, exists := v.FldValidators["well_known.ipv6_globally_routable"]; exists {
			val := m.GetWellKnown().(*StringRules_Ipv6GloballyRoutable).Ipv6GloballyRoutable
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("ipv6_globally_routable"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_HttpValidMethods:
		if fv, exists := v.FldValidators["well_known.http_valid_methods"]; exists {
			val := m.GetWellKnown().(*StringRules_HttpValidMethods).HttpValidMethods
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("http_valid_methods"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_UrlOrUriRef:
		if fv, exists := v.FldValidators["well_known.url_or_uri_ref"]; exists {
			val := m.GetWellKnown().(*StringRules_UrlOrUriRef).UrlOrUriRef
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("url_or_uri_ref"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_Ipv4PrefixGloballyRoutable:
		if fv, exists := v.FldValidators["well_known.ipv4_prefix_globally_routable"]; exists {
			val := m.GetWellKnown().(*StringRules_Ipv4PrefixGloballyRoutable).Ipv4PrefixGloballyRoutable
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("ipv4_prefix_globally_routable"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_Ipv6PrefixGloballyRoutable:
		if fv, exists := v.FldValidators["well_known.ipv6_prefix_globally_routable"]; exists {
			val := m.GetWellKnown().(*StringRules_Ipv6PrefixGloballyRoutable).Ipv6PrefixGloballyRoutable
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("ipv6_prefix_globally_routable"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StringRules_IpPrefixGloballyRoutable:
		if fv, exists := v.FldValidators["well_known.ip_prefix_globally_routable"]; exists {
			val := m.GetWellKnown().(*StringRules_IpPrefixGloballyRoutable).IpPrefixGloballyRoutable
			vOpts := append(opts,
				db.WithValidateField("well_known"),
				db.WithValidateField("ip_prefix_globally_routable"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStringRulesValidator = func() *ValidateStringRules {
	v := &ValidateStringRules{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func StringRulesValidator() db.Validator {
	return DefaultStringRulesValidator
}

// augmented methods on protoc/std generated struct

func (m *TimestampRules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TimestampRules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TimestampRules) DeepCopy() *TimestampRules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TimestampRules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TimestampRules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TimestampRules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TimestampRulesValidator().Validate(ctx, m, opts...)
}

type ValidateTimestampRules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTimestampRules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TimestampRules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TimestampRules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["const"]; exists {

		vOpts := append(opts, db.WithValidateField("const"))
		if err := fv(ctx, m.GetConst(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gt"]; exists {

		vOpts := append(opts, db.WithValidateField("gt"))
		if err := fv(ctx, m.GetGt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gt_now"]; exists {

		vOpts := append(opts, db.WithValidateField("gt_now"))
		if err := fv(ctx, m.GetGtNow(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gte"]; exists {

		vOpts := append(opts, db.WithValidateField("gte"))
		if err := fv(ctx, m.GetGte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["lt"]; exists {

		vOpts := append(opts, db.WithValidateField("lt"))
		if err := fv(ctx, m.GetLt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["lt_now"]; exists {

		vOpts := append(opts, db.WithValidateField("lt_now"))
		if err := fv(ctx, m.GetLtNow(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["lte"]; exists {

		vOpts := append(opts, db.WithValidateField("lte"))
		if err := fv(ctx, m.GetLte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["required"]; exists {

		vOpts := append(opts, db.WithValidateField("required"))
		if err := fv(ctx, m.GetRequired(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["within"]; exists {

		vOpts := append(opts, db.WithValidateField("within"))
		if err := fv(ctx, m.GetWithin(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTimestampRulesValidator = func() *ValidateTimestampRules {
	v := &ValidateTimestampRules{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func TimestampRulesValidator() db.Validator {
	return DefaultTimestampRulesValidator
}

// augmented methods on protoc/std generated struct

func (m *UInt32Rules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UInt32Rules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UInt32Rules) DeepCopy() *UInt32Rules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UInt32Rules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UInt32Rules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UInt32Rules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UInt32RulesValidator().Validate(ctx, m, opts...)
}

type ValidateUInt32Rules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUInt32Rules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UInt32Rules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UInt32Rules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["const"]; exists {

		vOpts := append(opts, db.WithValidateField("const"))
		if err := fv(ctx, m.GetConst(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gt"]; exists {

		vOpts := append(opts, db.WithValidateField("gt"))
		if err := fv(ctx, m.GetGt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gte"]; exists {

		vOpts := append(opts, db.WithValidateField("gte"))
		if err := fv(ctx, m.GetGte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["in"]; exists {

		vOpts := append(opts, db.WithValidateField("in"))
		for idx, item := range m.GetIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["lt"]; exists {

		vOpts := append(opts, db.WithValidateField("lt"))
		if err := fv(ctx, m.GetLt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["lte"]; exists {

		vOpts := append(opts, db.WithValidateField("lte"))
		if err := fv(ctx, m.GetLte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["not_in"]; exists {

		vOpts := append(opts, db.WithValidateField("not_in"))
		for idx, item := range m.GetNotIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["not_in_ranges"]; exists {

		vOpts := append(opts, db.WithValidateField("not_in_ranges"))
		if err := fv(ctx, m.GetNotInRanges(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ranges"]; exists {

		vOpts := append(opts, db.WithValidateField("ranges"))
		if err := fv(ctx, m.GetRanges(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUInt32RulesValidator = func() *ValidateUInt32Rules {
	v := &ValidateUInt32Rules{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UInt32RulesValidator() db.Validator {
	return DefaultUInt32RulesValidator
}

// augmented methods on protoc/std generated struct

func (m *UInt64Rules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UInt64Rules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UInt64Rules) DeepCopy() *UInt64Rules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UInt64Rules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UInt64Rules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UInt64Rules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UInt64RulesValidator().Validate(ctx, m, opts...)
}

type ValidateUInt64Rules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUInt64Rules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UInt64Rules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UInt64Rules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["const"]; exists {

		vOpts := append(opts, db.WithValidateField("const"))
		if err := fv(ctx, m.GetConst(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gt"]; exists {

		vOpts := append(opts, db.WithValidateField("gt"))
		if err := fv(ctx, m.GetGt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gte"]; exists {

		vOpts := append(opts, db.WithValidateField("gte"))
		if err := fv(ctx, m.GetGte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["in"]; exists {

		vOpts := append(opts, db.WithValidateField("in"))
		for idx, item := range m.GetIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["lt"]; exists {

		vOpts := append(opts, db.WithValidateField("lt"))
		if err := fv(ctx, m.GetLt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["lte"]; exists {

		vOpts := append(opts, db.WithValidateField("lte"))
		if err := fv(ctx, m.GetLte(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["not_in"]; exists {

		vOpts := append(opts, db.WithValidateField("not_in"))
		for idx, item := range m.GetNotIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUInt64RulesValidator = func() *ValidateUInt64Rules {
	v := &ValidateUInt64Rules{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UInt64RulesValidator() db.Validator {
	return DefaultUInt64RulesValidator
}
