// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/ztna/types.proto

package ztna

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ServerType
//
// x-displayName: "Server Type"
//
// External server for using the per session policy
type ServerType int32

const (
	// ActiveDirectory
	//
	// x-displayName: "ActiveDirectory"
	//
	// ActiveDirectory Server Type
	ActiveDirectory ServerType = 0
	// RadiusServer
	//
	// x-displayName: "RadiusServer"
	//
	// Radius Server Type
	RadiusServer ServerType = 1
)

var ServerType_name = map[int32]string{
	0: "ActiveDirectory",
	1: "RadiusServer",
}

var ServerType_value = map[string]int32{
	"ActiveDirectory": 0,
	"RadiusServer":    1,
}

func (ServerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1f3dffd23827b659, []int{0}
}

// Ztna Policy Action
//
// x-displayName: "Action"
// This sends allow/reject action in entry configuration of per session policy
type Action int32

const (
	// Reject
	//
	// x-displayName: "Reject"
	// Reject will be choosen as action
	reject Action = 0
	//allow
	//
	// x-displayName: "Allow"
	// Allow will be choosen as action .
	allow Action = 1
)

var Action_name = map[int32]string{
	0: "reject",
	1: "allow",
}

var Action_value = map[string]int32{
	"reject": 0,
	"allow":  1,
}

func (Action) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1f3dffd23827b659, []int{1}
}

// Ztna Connectivity Policy
//
// x-displayName: "Ztna Connectivity Policy"
//
// List of Ztna Connectivity policy tunnel type
type Connectivity int32

const (
	// PPP
	//
	// x-displayName: "PPP Tunnel"
	//
	// PPP tunnel type for connectivity policy.
	PPP Connectivity = 0
	// DTLS
	//
	// x-displayName: "DTLS Tunnel"
	//
	// Tunnel Type is DTLS Tunnel for connectivity policy
	DTLS Connectivity = 1
)

var Connectivity_name = map[int32]string{
	0: "PPP",
	1: "DTLS",
}

var Connectivity_value = map[string]int32{
	"PPP":  0,
	"DTLS": 1,
}

func (Connectivity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1f3dffd23827b659, []int{2}
}

// Ztna Policy Lease Pools Members
//
// x-displayName: "Lease Pools Member"
//
// The lease pool member is pool member for per session policy.
type LeasePoolMember struct {
	// StartAddress
	//
	// x-displayName: "Start Address"
	//
	// startAddress of Lease Pool member
	StartAddress *schema.IpAddressType `protobuf:"bytes,1,opt,name=start_address,json=startAddress,proto3" json:"start_address,omitempty"`
	// endaddress
	//
	// x-displayName: "End Address"
	//
	// End Address of Lease Pool member
	EndAddress *schema.IpAddressType `protobuf:"bytes,2,opt,name=end_address,json=endAddress,proto3" json:"end_address,omitempty"`
}

func (m *LeasePoolMember) Reset()      { *m = LeasePoolMember{} }
func (*LeasePoolMember) ProtoMessage() {}
func (*LeasePoolMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f3dffd23827b659, []int{0}
}
func (m *LeasePoolMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeasePoolMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LeasePoolMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeasePoolMember.Merge(m, src)
}
func (m *LeasePoolMember) XXX_Size() int {
	return m.Size()
}
func (m *LeasePoolMember) XXX_DiscardUnknown() {
	xxx_messageInfo_LeasePoolMember.DiscardUnknown(m)
}

var xxx_messageInfo_LeasePoolMember proto.InternalMessageInfo

func (m *LeasePoolMember) GetStartAddress() *schema.IpAddressType {
	if m != nil {
		return m.StartAddress
	}
	return nil
}

func (m *LeasePoolMember) GetEndAddress() *schema.IpAddressType {
	if m != nil {
		return m.EndAddress
	}
	return nil
}

// Ztna Policy ExternalServers
//
// x-displayName: "External Servers"
//
// External server is list of server for ztna per session policy.
type ExternalServers struct {
	// serverType
	//
	// x-displayName: "Server Type"
	//
	// serverType of External server
	ServerType ServerType `protobuf:"varint,2,opt,name=server_type,json=serverType,proto3,enum=ves.io.schema.ztna.ServerType" json:"server_type,omitempty"`
	// domain
	//
	// x-displayName: "Domain"
	// x-example: "apm.f5net.com"
	// Domain name for the external server
	Domain string `protobuf:"bytes,3,opt,name=domain,proto3" json:"domain,omitempty"`
	// adminName
	//
	// x-displayName: "Admin Name"
	// x-example: "Admin"
	// Credentials used for external server
	AdminUsername string `protobuf:"bytes,4,opt,name=admin_username,json=adminUsername,proto3" json:"admin_username,omitempty"`
	// Admin Password
	//
	// x-displayName: "Admin Password"
	//
	// Secret password credential used for external server
	AdminPassword *schema.SecretType `protobuf:"bytes,5,opt,name=admin_password,json=adminPassword,proto3" json:"admin_password,omitempty"`
}

func (m *ExternalServers) Reset()      { *m = ExternalServers{} }
func (*ExternalServers) ProtoMessage() {}
func (*ExternalServers) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f3dffd23827b659, []int{1}
}
func (m *ExternalServers) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternalServers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExternalServers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalServers.Merge(m, src)
}
func (m *ExternalServers) XXX_Size() int {
	return m.Size()
}
func (m *ExternalServers) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalServers.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalServers proto.InternalMessageInfo

func (m *ExternalServers) GetServerType() ServerType {
	if m != nil {
		return m.ServerType
	}
	return ActiveDirectory
}

func (m *ExternalServers) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *ExternalServers) GetAdminUsername() string {
	if m != nil {
		return m.AdminUsername
	}
	return ""
}

func (m *ExternalServers) GetAdminPassword() *schema.SecretType {
	if m != nil {
		return m.AdminPassword
	}
	return nil
}

// Entry
//
// x-displayName: "Entry"
//
// List of entries for diferrent Acl resource type.
type Entry struct {
	// action
	//
	// x-displayName: "Action"
	//
	// action is either allow/reject for acl resource type
	Action Action `protobuf:"varint,1,opt,name=action,proto3,enum=ves.io.schema.ztna.Action" json:"action,omitempty"`
	// dstIp
	//
	// x-displayName: "Destination IP"
	//
	// Destination IP address for the acl resource type.
	DestinationIp *schema.IpAddressType `protobuf:"bytes,2,opt,name=destination_ip,json=destinationIp,proto3" json:"destination_ip,omitempty"`
	// dstStartPort
	//
	// x-displayName: "Destination Start Port"
	//
	// Destination start port for acl resource type.
	DestinationStartPort uint32 `protobuf:"varint,3,opt,name=destination_start_port,json=destinationStartPort,proto3" json:"destination_start_port,omitempty"`
	// dstEndPort
	//
	// x-displayName: "destination End Port"
	//
	// Destination End Port for acl resource type.
	DestinationEndPort uint32 `protobuf:"varint,4,opt,name=destination_end_port,json=destinationEndPort,proto3" json:"destination_end_port,omitempty"`
}

func (m *Entry) Reset()      { *m = Entry{} }
func (*Entry) ProtoMessage() {}
func (*Entry) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f3dffd23827b659, []int{2}
}
func (m *Entry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Entry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Entry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entry.Merge(m, src)
}
func (m *Entry) XXX_Size() int {
	return m.Size()
}
func (m *Entry) XXX_DiscardUnknown() {
	xxx_messageInfo_Entry.DiscardUnknown(m)
}

var xxx_messageInfo_Entry proto.InternalMessageInfo

func (m *Entry) GetAction() Action {
	if m != nil {
		return m.Action
	}
	return reject
}

func (m *Entry) GetDestinationIp() *schema.IpAddressType {
	if m != nil {
		return m.DestinationIp
	}
	return nil
}

func (m *Entry) GetDestinationStartPort() uint32 {
	if m != nil {
		return m.DestinationStartPort
	}
	return 0
}

func (m *Entry) GetDestinationEndPort() uint32 {
	if m != nil {
		return m.DestinationEndPort
	}
	return 0
}

// AclResourceEntry
//
// x-displayName: "Acl Resource Entry"
//
// List of configuration for acl resource type.
type AclResourceEntry struct {
	// entries
	//
	// x-displayName: "Entries"
	//
	// Entries Config for Acl Resource
	Entries []*Entry `protobuf:"bytes,2,rep,name=entries,proto3" json:"entries,omitempty"`
}

func (m *AclResourceEntry) Reset()      { *m = AclResourceEntry{} }
func (*AclResourceEntry) ProtoMessage() {}
func (*AclResourceEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f3dffd23827b659, []int{3}
}
func (m *AclResourceEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AclResourceEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AclResourceEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AclResourceEntry.Merge(m, src)
}
func (m *AclResourceEntry) XXX_Size() int {
	return m.Size()
}
func (m *AclResourceEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_AclResourceEntry.DiscardUnknown(m)
}

var xxx_messageInfo_AclResourceEntry proto.InternalMessageInfo

func (m *AclResourceEntry) GetEntries() []*Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

// Resource for Per Session Policy
//
// x-displayName: "Resources"
//
// Choose the resource type for session policy type as WebTopFull/Acl/ConnectivityResource
type Resource struct {
	// Resource Type
	//
	// x-displayName: "Select Resource Type"
	// Select resource type WebTopFull/Acl/ConnectivityResource
	//
	// Types that are valid to be assigned to ResourceType:
	//	*Resource_Acl
	//	*Resource_Web
	//	*Resource_Connectivity
	ResourceType isResource_ResourceType `protobuf_oneof:"resource_type"`
}

func (m *Resource) Reset()      { *m = Resource{} }
func (*Resource) ProtoMessage() {}
func (*Resource) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f3dffd23827b659, []int{4}
}
func (m *Resource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Resource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Resource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Resource.Merge(m, src)
}
func (m *Resource) XXX_Size() int {
	return m.Size()
}
func (m *Resource) XXX_DiscardUnknown() {
	xxx_messageInfo_Resource.DiscardUnknown(m)
}

var xxx_messageInfo_Resource proto.InternalMessageInfo

type isResource_ResourceType interface {
	isResource_ResourceType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Resource_Acl struct {
	Acl *AclResourceEntry `protobuf:"bytes,2,opt,name=acl,proto3,oneof" json:"acl,omitempty"`
}
type Resource_Web struct {
	Web *schema.Empty `protobuf:"bytes,3,opt,name=web,proto3,oneof" json:"web,omitempty"`
}
type Resource_Connectivity struct {
	Connectivity *schema.Empty `protobuf:"bytes,4,opt,name=connectivity,proto3,oneof" json:"connectivity,omitempty"`
}

func (*Resource_Acl) isResource_ResourceType()          {}
func (*Resource_Web) isResource_ResourceType()          {}
func (*Resource_Connectivity) isResource_ResourceType() {}

func (m *Resource) GetResourceType() isResource_ResourceType {
	if m != nil {
		return m.ResourceType
	}
	return nil
}

func (m *Resource) GetAcl() *AclResourceEntry {
	if x, ok := m.GetResourceType().(*Resource_Acl); ok {
		return x.Acl
	}
	return nil
}

func (m *Resource) GetWeb() *schema.Empty {
	if x, ok := m.GetResourceType().(*Resource_Web); ok {
		return x.Web
	}
	return nil
}

func (m *Resource) GetConnectivity() *schema.Empty {
	if x, ok := m.GetResourceType().(*Resource_Connectivity); ok {
		return x.Connectivity
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Resource) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Resource_Acl)(nil),
		(*Resource_Web)(nil),
		(*Resource_Connectivity)(nil),
	}
}

// Rules
//
// x-displayName: "Rules"
//
// Send all the configuration rules.
type Rules struct {
	// Network access rules
	//
	// x-displayName: "Network Access Rules"
	// x-example: "cp-demo"
	// List of network access rules configuration
	NetworkAccessRule []string `protobuf:"bytes,1,rep,name=network_access_rule,json=networkAccessRule,proto3" json:"network_access_rule,omitempty"`
	// Web Top Name
	//
	// x-displayName: "Web Top Name"
	// x-example: "webtop1"
	// Put the name of webtopfull resource type
	WebTopName string `protobuf:"bytes,2,opt,name=web_top_name,json=webTopName,proto3" json:"web_top_name,omitempty"`
	// Acls
	//
	// x-displayName: "Acls"
	// x-example: "acltest1"
	// Put the list of all acls resource type name.
	Acls []string `protobuf:"bytes,3,rep,name=acls,proto3" json:"acls,omitempty"`
}

func (m *Rules) Reset()      { *m = Rules{} }
func (*Rules) ProtoMessage() {}
func (*Rules) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f3dffd23827b659, []int{5}
}
func (m *Rules) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rules) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Rules) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rules.Merge(m, src)
}
func (m *Rules) XXX_Size() int {
	return m.Size()
}
func (m *Rules) XXX_DiscardUnknown() {
	xxx_messageInfo_Rules.DiscardUnknown(m)
}

var xxx_messageInfo_Rules proto.InternalMessageInfo

func (m *Rules) GetNetworkAccessRule() []string {
	if m != nil {
		return m.NetworkAccessRule
	}
	return nil
}

func (m *Rules) GetWebTopName() string {
	if m != nil {
		return m.WebTopName
	}
	return ""
}

func (m *Rules) GetAcls() []string {
	if m != nil {
		return m.Acls
	}
	return nil
}

// Resource Assign
//
// x-displayName: "Resource Assign"
//
// Configuration of assigned resource after success of directory query
type AllowResourceAssign struct {
	// Server Name
	//
	// x-displayName: "Server"
	// x-example: "ad_auth_server"
	// Server name for assigning the resources
	Server string `protobuf:"bytes,1,opt,name=server,proto3" json:"server,omitempty"`
	// Rules
	//
	// x-displayName: "Rules"
	// Rules for assigning the resources
	RulesResourceAssign []*Rules `protobuf:"bytes,2,rep,name=rules_resource_assign,json=rulesResourceAssign,proto3" json:"rules_resource_assign,omitempty"`
	// Resource Assign Failure
	//
	// x-displayName: "Resource Assign Failure Configuration"
	// x-example: "Deny"
	// Send deny as next item in case of failure
	DenyName string `protobuf:"bytes,3,opt,name=deny_name,json=denyName,proto3" json:"deny_name,omitempty"`
	// Resource Assign Success
	//
	// x-displayName: "Resource Assign Success Configuration"
	// x-example: "Allow"
	// Send allow as next item in case of success
	AllowName string `protobuf:"bytes,4,opt,name=allow_name,json=allowName,proto3" json:"allow_name,omitempty"`
}

func (m *AllowResourceAssign) Reset()      { *m = AllowResourceAssign{} }
func (*AllowResourceAssign) ProtoMessage() {}
func (*AllowResourceAssign) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f3dffd23827b659, []int{6}
}
func (m *AllowResourceAssign) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllowResourceAssign) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AllowResourceAssign) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllowResourceAssign.Merge(m, src)
}
func (m *AllowResourceAssign) XXX_Size() int {
	return m.Size()
}
func (m *AllowResourceAssign) XXX_DiscardUnknown() {
	xxx_messageInfo_AllowResourceAssign.DiscardUnknown(m)
}

var xxx_messageInfo_AllowResourceAssign proto.InternalMessageInfo

func (m *AllowResourceAssign) GetServer() string {
	if m != nil {
		return m.Server
	}
	return ""
}

func (m *AllowResourceAssign) GetRulesResourceAssign() []*Rules {
	if m != nil {
		return m.RulesResourceAssign
	}
	return nil
}

func (m *AllowResourceAssign) GetDenyName() string {
	if m != nil {
		return m.DenyName
	}
	return ""
}

func (m *AllowResourceAssign) GetAllowName() string {
	if m != nil {
		return m.AllowName
	}
	return ""
}

// Resource Assign
//
// x-displayName: "Resource Assign"
//
// List of all assigned resources.
type ResourceAssign struct {
	// Resource Assign
	//
	// x-displayName: "Resource Assign Configuration"
	//
	// This sends resource assign configuration
	Allow []*AllowResourceAssign `protobuf:"bytes,2,rep,name=allow,proto3" json:"allow,omitempty"`
}

func (m *ResourceAssign) Reset()      { *m = ResourceAssign{} }
func (*ResourceAssign) ProtoMessage() {}
func (*ResourceAssign) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f3dffd23827b659, []int{7}
}
func (m *ResourceAssign) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceAssign) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResourceAssign) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceAssign.Merge(m, src)
}
func (m *ResourceAssign) XXX_Size() int {
	return m.Size()
}
func (m *ResourceAssign) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceAssign.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceAssign proto.InternalMessageInfo

func (m *ResourceAssign) GetAllow() []*AllowResourceAssign {
	if m != nil {
		return m.Allow
	}
	return nil
}

// Active Directory Query
//
// x-displayName: "Active Directory Query"
//
// Send active directory query configuration on success of active directory Auth.
type ActiveDirectoryQuery struct {
	// Server Name
	//
	// x-displayName: "Server"
	// x-example: "ad_auth_server"
	// Name of the server which gets assigned.
	Server string `protobuf:"bytes,1,opt,name=server,proto3" json:"server,omitempty"`
	// Filter
	//
	// x-displayName: "Filter"
	// x-example: "(CN=%{session.logon.last.username})"
	// Filter setting for filtering out the assigned resources
	Filter string `protobuf:"bytes,2,opt,name=filter,proto3" json:"filter,omitempty"`
	// Active Directory Query Failure
	//
	// x-displayName: "AAA Active Directory Query Failure"
	// x-example: "Deny"
	// Send deny as next item if query gets failed.
	DenyName string `protobuf:"bytes,3,opt,name=deny_name,json=denyName,proto3" json:"deny_name,omitempty"`
	// resource assigned
	//
	// x-displayName: "Resource Assign"
	//
	// List of all assigned resources list
	ResourceAssign *ResourceAssign `protobuf:"bytes,4,opt,name=resource_assign,json=resourceAssign,proto3" json:"resource_assign,omitempty"`
}

func (m *ActiveDirectoryQuery) Reset()      { *m = ActiveDirectoryQuery{} }
func (*ActiveDirectoryQuery) ProtoMessage() {}
func (*ActiveDirectoryQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f3dffd23827b659, []int{8}
}
func (m *ActiveDirectoryQuery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActiveDirectoryQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ActiveDirectoryQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActiveDirectoryQuery.Merge(m, src)
}
func (m *ActiveDirectoryQuery) XXX_Size() int {
	return m.Size()
}
func (m *ActiveDirectoryQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_ActiveDirectoryQuery.DiscardUnknown(m)
}

var xxx_messageInfo_ActiveDirectoryQuery proto.InternalMessageInfo

func (m *ActiveDirectoryQuery) GetServer() string {
	if m != nil {
		return m.Server
	}
	return ""
}

func (m *ActiveDirectoryQuery) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

func (m *ActiveDirectoryQuery) GetDenyName() string {
	if m != nil {
		return m.DenyName
	}
	return ""
}

func (m *ActiveDirectoryQuery) GetResourceAssign() *ResourceAssign {
	if m != nil {
		return m.ResourceAssign
	}
	return nil
}

// Active Directory Auth
//
// x-displayName: "AAA Active Directory Auth"
//
// List of configuration of Active directory Auth.
type ActiveDirectoryAuth struct {
	// Server Name
	//
	// x-displayName: "Server"
	// x-example: "ad_auth_server"
	// Server name on which log on is success.
	Server string `protobuf:"bytes,1,opt,name=server,proto3" json:"server,omitempty"`
	// Expression
	//
	// x-displayName: "Expression"
	// x-example: "expr {[mcget {session.ad.last.authresult}] == 1}"
	// Expression string to filter the Directory query.
	Expression string `protobuf:"bytes,2,opt,name=expression,proto3" json:"expression,omitempty"`
	// AAA Active Directory Failure
	//
	// x-displayName: "AAA Active Directory Failure"
	// x-example: "Deny"
	// Send deny as next item in case it fails to find the query.
	DenyName string `protobuf:"bytes,3,opt,name=deny_name,json=denyName,proto3" json:"deny_name,omitempty"`
	// AAA Active Directory success
	//
	// x-displayName: "AAA Active Directory Success"
	// Send active directory query configuration on success of allow directory auth.
	ActiveDirectoryQuery []*ActiveDirectoryQuery `protobuf:"bytes,4,rep,name=active_directory_query,json=activeDirectoryQuery,proto3" json:"active_directory_query,omitempty"`
}

func (m *ActiveDirectoryAuth) Reset()      { *m = ActiveDirectoryAuth{} }
func (*ActiveDirectoryAuth) ProtoMessage() {}
func (*ActiveDirectoryAuth) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f3dffd23827b659, []int{9}
}
func (m *ActiveDirectoryAuth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActiveDirectoryAuth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ActiveDirectoryAuth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActiveDirectoryAuth.Merge(m, src)
}
func (m *ActiveDirectoryAuth) XXX_Size() int {
	return m.Size()
}
func (m *ActiveDirectoryAuth) XXX_DiscardUnknown() {
	xxx_messageInfo_ActiveDirectoryAuth.DiscardUnknown(m)
}

var xxx_messageInfo_ActiveDirectoryAuth proto.InternalMessageInfo

func (m *ActiveDirectoryAuth) GetServer() string {
	if m != nil {
		return m.Server
	}
	return ""
}

func (m *ActiveDirectoryAuth) GetExpression() string {
	if m != nil {
		return m.Expression
	}
	return ""
}

func (m *ActiveDirectoryAuth) GetDenyName() string {
	if m != nil {
		return m.DenyName
	}
	return ""
}

func (m *ActiveDirectoryAuth) GetActiveDirectoryQuery() []*ActiveDirectoryQuery {
	if m != nil {
		return m.ActiveDirectoryQuery
	}
	return nil
}

// Custmization
//
// x-displayName: "Custmization"
//
// User name and password to log on
type Custmization struct {
	// Username
	//
	// x-displayName: "User Name"
	// x-example: "User Name"
	//This contains the user name to log on.
	UserName string `protobuf:"bytes,2,opt,name=user_name,json=userName,proto3" json:"user_name,omitempty"`
	// Secret Password
	//
	// x-displayName: "Secret Password"
	//
	// This field contains the secret password for log on.
	Password *schema.SecretType `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
}

func (m *Custmization) Reset()      { *m = Custmization{} }
func (*Custmization) ProtoMessage() {}
func (*Custmization) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f3dffd23827b659, []int{10}
}
func (m *Custmization) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Custmization) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Custmization) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Custmization.Merge(m, src)
}
func (m *Custmization) XXX_Size() int {
	return m.Size()
}
func (m *Custmization) XXX_DiscardUnknown() {
	xxx_messageInfo_Custmization.DiscardUnknown(m)
}

var xxx_messageInfo_Custmization proto.InternalMessageInfo

func (m *Custmization) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *Custmization) GetPassword() *schema.SecretType {
	if m != nil {
		return m.Password
	}
	return nil
}

// Log on as nextItem
//
// x-displayName: "Log On Next Item"
//
// Send log on configuration as user name and password
type LogonItemType struct {
	// Credentials
	//
	// x-displayName: "Credentials"
	//
	// This contains language , username and secret to login
	Customization []*Custmization `protobuf:"bytes,1,rep,name=customization,proto3" json:"customization,omitempty"`
	// nextItem
	//
	// x-displayName: "AAA Active Directory Auth"
	//
	// After logon next item is to verify the group and directory.
	ActiveDirectoryAuth []*ActiveDirectoryAuth `protobuf:"bytes,2,rep,name=active_directory_auth,json=activeDirectoryAuth,proto3" json:"active_directory_auth,omitempty"`
}

func (m *LogonItemType) Reset()      { *m = LogonItemType{} }
func (*LogonItemType) ProtoMessage() {}
func (*LogonItemType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f3dffd23827b659, []int{11}
}
func (m *LogonItemType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogonItemType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LogonItemType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogonItemType.Merge(m, src)
}
func (m *LogonItemType) XXX_Size() int {
	return m.Size()
}
func (m *LogonItemType) XXX_DiscardUnknown() {
	xxx_messageInfo_LogonItemType.DiscardUnknown(m)
}

var xxx_messageInfo_LogonItemType proto.InternalMessageInfo

func (m *LogonItemType) GetCustomization() []*Custmization {
	if m != nil {
		return m.Customization
	}
	return nil
}

func (m *LogonItemType) GetActiveDirectoryAuth() []*ActiveDirectoryAuth {
	if m != nil {
		return m.ActiveDirectoryAuth
	}
	return nil
}

// Action Type
//
// x-displayName: "Action Type"
//
// Choose the next action as logon/active dir auth/ active dir query/resource assign.
type ActionType struct {
	// item type
	//
	// x-displayName: "Item Type"
	//
	// Choose the Next Configuration Item from the Log On/AAA Directory Auth/
	// Active Directory Query/Resource Assign
	//
	// Types that are valid to be assigned to ItemType:
	//	*ActionType_LogOn
	//	*ActionType_ActiveDirectoryAuth
	//	*ActionType_ActiveDirectoryQuery
	//	*ActionType_ResourceAssign
	ItemType isActionType_ItemType `protobuf_oneof:"item_type"`
}

func (m *ActionType) Reset()      { *m = ActionType{} }
func (*ActionType) ProtoMessage() {}
func (*ActionType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f3dffd23827b659, []int{12}
}
func (m *ActionType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ActionType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionType.Merge(m, src)
}
func (m *ActionType) XXX_Size() int {
	return m.Size()
}
func (m *ActionType) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionType.DiscardUnknown(m)
}

var xxx_messageInfo_ActionType proto.InternalMessageInfo

type isActionType_ItemType interface {
	isActionType_ItemType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ActionType_LogOn struct {
	LogOn *LogonItemType `protobuf:"bytes,2,opt,name=log_on,json=logOn,proto3,oneof" json:"log_on,omitempty"`
}
type ActionType_ActiveDirectoryAuth struct {
	ActiveDirectoryAuth *ActiveDirectoryAuth `protobuf:"bytes,3,opt,name=active_directory_auth,json=activeDirectoryAuth,proto3,oneof" json:"active_directory_auth,omitempty"`
}
type ActionType_ActiveDirectoryQuery struct {
	ActiveDirectoryQuery *ActiveDirectoryQuery `protobuf:"bytes,4,opt,name=active_directory_query,json=activeDirectoryQuery,proto3,oneof" json:"active_directory_query,omitempty"`
}
type ActionType_ResourceAssign struct {
	ResourceAssign *ResourceAssign `protobuf:"bytes,5,opt,name=resource_assign,json=resourceAssign,proto3,oneof" json:"resource_assign,omitempty"`
}

func (*ActionType_LogOn) isActionType_ItemType()                {}
func (*ActionType_ActiveDirectoryAuth) isActionType_ItemType()  {}
func (*ActionType_ActiveDirectoryQuery) isActionType_ItemType() {}
func (*ActionType_ResourceAssign) isActionType_ItemType()       {}

func (m *ActionType) GetItemType() isActionType_ItemType {
	if m != nil {
		return m.ItemType
	}
	return nil
}

func (m *ActionType) GetLogOn() *LogonItemType {
	if x, ok := m.GetItemType().(*ActionType_LogOn); ok {
		return x.LogOn
	}
	return nil
}

func (m *ActionType) GetActiveDirectoryAuth() *ActiveDirectoryAuth {
	if x, ok := m.GetItemType().(*ActionType_ActiveDirectoryAuth); ok {
		return x.ActiveDirectoryAuth
	}
	return nil
}

func (m *ActionType) GetActiveDirectoryQuery() *ActiveDirectoryQuery {
	if x, ok := m.GetItemType().(*ActionType_ActiveDirectoryQuery); ok {
		return x.ActiveDirectoryQuery
	}
	return nil
}

func (m *ActionType) GetResourceAssign() *ResourceAssign {
	if x, ok := m.GetItemType().(*ActionType_ResourceAssign); ok {
		return x.ResourceAssign
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ActionType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ActionType_LogOn)(nil),
		(*ActionType_ActiveDirectoryAuth)(nil),
		(*ActionType_ActiveDirectoryQuery)(nil),
		(*ActionType_ResourceAssign)(nil),
	}
}

// sequenceAction
//
// x-displayName: "SequenceAction"
//
// This configuration is used to specify the sequence of action
// for connectivity access Policy
type SequenceAction struct {
	// connectivityAccessPolicyName
	//
	// x-displayName: "Connectivity AccessPolicy Name"
	// x-example: "connectivity_demo"
	// Name of connectivity policy
	ConnectivityAccessPolicyName string `protobuf:"bytes,1,opt,name=connectivity_access_policy_name,json=connectivityAccessPolicyName,proto3" json:"connectivity_access_policy_name,omitempty"`
	// Next Item
	//
	// x-displayName: "Next Item "
	// Next Action could be any one from the Log On/AAA Directory Auth/
	// Active Directory Query/Resource Assign
	NextAction *ActionType `protobuf:"bytes,2,opt,name=next_action,json=nextAction,proto3" json:"next_action,omitempty"`
}

func (m *SequenceAction) Reset()      { *m = SequenceAction{} }
func (*SequenceAction) ProtoMessage() {}
func (*SequenceAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f3dffd23827b659, []int{13}
}
func (m *SequenceAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SequenceAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SequenceAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SequenceAction.Merge(m, src)
}
func (m *SequenceAction) XXX_Size() int {
	return m.Size()
}
func (m *SequenceAction) XXX_DiscardUnknown() {
	xxx_messageInfo_SequenceAction.DiscardUnknown(m)
}

var xxx_messageInfo_SequenceAction proto.InternalMessageInfo

func (m *SequenceAction) GetConnectivityAccessPolicyName() string {
	if m != nil {
		return m.ConnectivityAccessPolicyName
	}
	return ""
}

func (m *SequenceAction) GetNextAction() *ActionType {
	if m != nil {
		return m.NextAction
	}
	return nil
}

// Ztna Per Session Type
//
// x-displayName: "Session Policy Type"
// List of Per Session Policy type.
type PerSessionPolicyType struct {
	// Session Policy configuration
	//
	// x-displayName: "Resources"
	// List of the Policy of session type.
	Resources map[string]*Resource `protobuf:"bytes,1,rep,name=resources,proto3" json:"resources,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Lease Pool Member
	//
	// x-displayName: "Lease Pool Member"
	// List of Lease pool member for Session Policy
	LeasePoolMember map[string]*LeasePoolMember `protobuf:"bytes,2,rep,name=lease_pool_member,json=leasePoolMember,proto3" json:"lease_pool_member,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// ExternalServers
	//
	// x-displayName: "External Servers"
	// List of configuration of external server
	ExternalServer map[string]*ExternalServers `protobuf:"bytes,3,rep,name=external_server,json=externalServer,proto3" json:"external_server,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Name
	//
	// x-displayName: "Session Policy Name"
	// This contains the name of session policy
	PerSessionPolicyName string `protobuf:"bytes,4,opt,name=per_session_policy_name,json=perSessionPolicyName,proto3" json:"per_session_policy_name,omitempty"`
	// Sequence of Action
	//
	// x-displayName: "Sequence Action"
	// Choose the sequence action from Log On/AAA Directory Auth/
	// Active Directory Query/Resource Assign
	SequenceAction *SequenceAction `protobuf:"bytes,5,opt,name=sequence_action,json=sequenceAction,proto3" json:"sequence_action,omitempty"`
}

func (m *PerSessionPolicyType) Reset()      { *m = PerSessionPolicyType{} }
func (*PerSessionPolicyType) ProtoMessage() {}
func (*PerSessionPolicyType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f3dffd23827b659, []int{14}
}
func (m *PerSessionPolicyType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PerSessionPolicyType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PerSessionPolicyType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PerSessionPolicyType.Merge(m, src)
}
func (m *PerSessionPolicyType) XXX_Size() int {
	return m.Size()
}
func (m *PerSessionPolicyType) XXX_DiscardUnknown() {
	xxx_messageInfo_PerSessionPolicyType.DiscardUnknown(m)
}

var xxx_messageInfo_PerSessionPolicyType proto.InternalMessageInfo

func (m *PerSessionPolicyType) GetResources() map[string]*Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *PerSessionPolicyType) GetLeasePoolMember() map[string]*LeasePoolMember {
	if m != nil {
		return m.LeasePoolMember
	}
	return nil
}

func (m *PerSessionPolicyType) GetExternalServer() map[string]*ExternalServers {
	if m != nil {
		return m.ExternalServer
	}
	return nil
}

func (m *PerSessionPolicyType) GetPerSessionPolicyName() string {
	if m != nil {
		return m.PerSessionPolicyName
	}
	return ""
}

func (m *PerSessionPolicyType) GetSequenceAction() *SequenceAction {
	if m != nil {
		return m.SequenceAction
	}
	return nil
}

// Ztna ConnectivityPolicyType
//
// x-displayName: "Ztna Connectivity Policy Type"
// List of Ztna Connectivity Policy type.
type ConnectivityPolicyType struct {
	// Connectivities
	//
	// x-displayName: "Tunnel for Connectivities"
	// Connectivity policy configuration. Select connectivity policy as PPP/DTLS
	Connectivities Connectivity `protobuf:"varint,1,opt,name=connectivities,proto3,enum=ves.io.schema.ztna.Connectivity" json:"connectivities,omitempty"`
	// Name
	//
	// x-displayName: "Name of Connectivity Policy"
	// Name of connectivity policy
	ConnectivityPolicyName string `protobuf:"bytes,2,opt,name=connectivity_policy_name,json=connectivityPolicyName,proto3" json:"connectivity_policy_name,omitempty"`
}

func (m *ConnectivityPolicyType) Reset()      { *m = ConnectivityPolicyType{} }
func (*ConnectivityPolicyType) ProtoMessage() {}
func (*ConnectivityPolicyType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f3dffd23827b659, []int{15}
}
func (m *ConnectivityPolicyType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectivityPolicyType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConnectivityPolicyType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectivityPolicyType.Merge(m, src)
}
func (m *ConnectivityPolicyType) XXX_Size() int {
	return m.Size()
}
func (m *ConnectivityPolicyType) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectivityPolicyType.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectivityPolicyType proto.InternalMessageInfo

func (m *ConnectivityPolicyType) GetConnectivities() Connectivity {
	if m != nil {
		return m.Connectivities
	}
	return PPP
}

func (m *ConnectivityPolicyType) GetConnectivityPolicyName() string {
	if m != nil {
		return m.ConnectivityPolicyName
	}
	return ""
}

// Ztna Policy Configuration Spec
//
// x-displayName: "Global Specification"
// Ztna Policy Configuration Spec
type GlobalSpecType struct {
	// ConnectivityPolicyType
	//
	// x-displayName: "Connectivity Access Policy"
	// List of Connectivity Policy Type
	Connectivity *ConnectivityPolicyType `protobuf:"bytes,1,opt,name=connectivity,proto3" json:"connectivity,omitempty"`
	// PerSessionPolicyType
	//
	// x-displayName: "Session Policy Type"
	// List of configuration for per session policy type.
	PerSession *PerSessionPolicyType `protobuf:"bytes,2,opt,name=per_session,json=perSession,proto3" json:"per_session,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f3dffd23827b659, []int{16}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

func (m *GlobalSpecType) GetConnectivity() *ConnectivityPolicyType {
	if m != nil {
		return m.Connectivity
	}
	return nil
}

func (m *GlobalSpecType) GetPerSession() *PerSessionPolicyType {
	if m != nil {
		return m.PerSession
	}
	return nil
}

// Create Ztna Policy
//
// x-displayName: "Create Ztna Policy"
// Creates a new Ztna Policy Object
type CreateSpecType struct {
	Connectivity *ConnectivityPolicyType `protobuf:"bytes,1,opt,name=connectivity,proto3" json:"connectivity,omitempty"`
	PerSession   *PerSessionPolicyType   `protobuf:"bytes,2,opt,name=per_session,json=perSession,proto3" json:"per_session,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f3dffd23827b659, []int{17}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

func (m *CreateSpecType) GetConnectivity() *ConnectivityPolicyType {
	if m != nil {
		return m.Connectivity
	}
	return nil
}

func (m *CreateSpecType) GetPerSession() *PerSessionPolicyType {
	if m != nil {
		return m.PerSession
	}
	return nil
}

// Replace Ztna Policy
//
// x-displayName: "Replace Ztna Policy"
// Replaces the content of the Ztna policy object
type ReplaceSpecType struct {
	Connectivity *ConnectivityPolicyType `protobuf:"bytes,1,opt,name=connectivity,proto3" json:"connectivity,omitempty"`
	PerSession   *PerSessionPolicyType   `protobuf:"bytes,2,opt,name=per_session,json=perSession,proto3" json:"per_session,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f3dffd23827b659, []int{18}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

func (m *ReplaceSpecType) GetConnectivity() *ConnectivityPolicyType {
	if m != nil {
		return m.Connectivity
	}
	return nil
}

func (m *ReplaceSpecType) GetPerSession() *PerSessionPolicyType {
	if m != nil {
		return m.PerSession
	}
	return nil
}

// Get Ztna Policy
//
// x-displayName: "Get Ztna Policy"
// Get the ztna policy object
type GetSpecType struct {
	Connectivity *ConnectivityPolicyType `protobuf:"bytes,1,opt,name=connectivity,proto3" json:"connectivity,omitempty"`
	PerSession   *PerSessionPolicyType   `protobuf:"bytes,2,opt,name=per_session,json=perSession,proto3" json:"per_session,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f3dffd23827b659, []int{19}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

func (m *GetSpecType) GetConnectivity() *ConnectivityPolicyType {
	if m != nil {
		return m.Connectivity
	}
	return nil
}

func (m *GetSpecType) GetPerSession() *PerSessionPolicyType {
	if m != nil {
		return m.PerSession
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.ztna.ServerType", ServerType_name, ServerType_value)
	proto.RegisterEnum("ves.io.schema.ztna.Action", Action_name, Action_value)
	proto.RegisterEnum("ves.io.schema.ztna.Connectivity", Connectivity_name, Connectivity_value)
	proto.RegisterType((*LeasePoolMember)(nil), "ves.io.schema.ztna.LeasePoolMember")
	proto.RegisterType((*ExternalServers)(nil), "ves.io.schema.ztna.ExternalServers")
	proto.RegisterType((*Entry)(nil), "ves.io.schema.ztna.Entry")
	proto.RegisterType((*AclResourceEntry)(nil), "ves.io.schema.ztna.AclResourceEntry")
	proto.RegisterType((*Resource)(nil), "ves.io.schema.ztna.Resource")
	proto.RegisterType((*Rules)(nil), "ves.io.schema.ztna.Rules")
	proto.RegisterType((*AllowResourceAssign)(nil), "ves.io.schema.ztna.AllowResourceAssign")
	proto.RegisterType((*ResourceAssign)(nil), "ves.io.schema.ztna.ResourceAssign")
	proto.RegisterType((*ActiveDirectoryQuery)(nil), "ves.io.schema.ztna.ActiveDirectoryQuery")
	proto.RegisterType((*ActiveDirectoryAuth)(nil), "ves.io.schema.ztna.ActiveDirectoryAuth")
	proto.RegisterType((*Custmization)(nil), "ves.io.schema.ztna.Custmization")
	proto.RegisterType((*LogonItemType)(nil), "ves.io.schema.ztna.LogonItemType")
	proto.RegisterType((*ActionType)(nil), "ves.io.schema.ztna.ActionType")
	proto.RegisterType((*SequenceAction)(nil), "ves.io.schema.ztna.SequenceAction")
	proto.RegisterType((*PerSessionPolicyType)(nil), "ves.io.schema.ztna.PerSessionPolicyType")
	proto.RegisterMapType((map[string]*ExternalServers)(nil), "ves.io.schema.ztna.PerSessionPolicyType.ExternalServerEntry")
	proto.RegisterMapType((map[string]*LeasePoolMember)(nil), "ves.io.schema.ztna.PerSessionPolicyType.LeasePoolMemberEntry")
	proto.RegisterMapType((map[string]*Resource)(nil), "ves.io.schema.ztna.PerSessionPolicyType.ResourcesEntry")
	proto.RegisterType((*ConnectivityPolicyType)(nil), "ves.io.schema.ztna.ConnectivityPolicyType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.ztna.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.ztna.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.ztna.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.ztna.GetSpecType")
}

func init() { proto.RegisterFile("ves.io/schema/ztna/types.proto", fileDescriptor_1f3dffd23827b659) }

var fileDescriptor_1f3dffd23827b659 = []byte{
	// 2355 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x59, 0x4d, 0x6c, 0xdb, 0xc8,
	0xf5, 0xd7, 0x48, 0xb6, 0x63, 0x3d, 0x5b, 0xb2, 0x32, 0x76, 0x1c, 0x85, 0xeb, 0x68, 0x19, 0x6d,
	0x80, 0x35, 0x0c, 0x47, 0xfe, 0xff, 0xe5, 0x4d, 0x9b, 0x55, 0x37, 0xbb, 0xb1, 0xf3, 0xe5, 0xb4,
	0xf9, 0x70, 0xe9, 0x2c, 0x8a, 0xee, 0x76, 0xc3, 0x52, 0xd4, 0x58, 0x66, 0x43, 0x91, 0x0c, 0x49,
	0xd9, 0xf1, 0xa2, 0x28, 0x82, 0x3d, 0xea, 0x50, 0x14, 0xe8, 0xa5, 0x08, 0xda, 0x1e, 0xba, 0x97,
	0x02, 0x5b, 0xb4, 0x87, 0xb6, 0x28, 0xb0, 0x54, 0xdb, 0x1c, 0x5a, 0x60, 0xe1, 0x4b, 0x73, 0x4c,
	0x2f, 0x45, 0xa2, 0x5c, 0x5a, 0xf7, 0xb2, 0x28, 0x7a, 0xd8, 0x63, 0x31, 0x33, 0xa4, 0x4c, 0xd2,
	0x94, 0xe3, 0xf6, 0x96, 0xdb, 0x7c, 0xbc, 0x37, 0xef, 0x37, 0xbf, 0xf7, 0xe6, 0xcd, 0xe3, 0x10,
	0x4a, 0x9b, 0xc4, 0xa9, 0x68, 0xe6, 0x82, 0xa3, 0x6e, 0x90, 0x96, 0xb2, 0xf0, 0xa1, 0x6b, 0x28,
	0x0b, 0xee, 0xb6, 0x45, 0x9c, 0x8a, 0x65, 0x9b, 0xae, 0x89, 0x31, 0x9f, 0xaf, 0xf0, 0xf9, 0x0a,
	0x9d, 0x17, 0xce, 0x34, 0x35, 0x77, 0xa3, 0x5d, 0xaf, 0xa8, 0x66, 0x6b, 0xa1, 0x69, 0x36, 0xcd,
	0x05, 0x26, 0x5a, 0x6f, 0xaf, 0xb3, 0x1e, 0xeb, 0xb0, 0x16, 0x5f, 0x42, 0x38, 0x1e, 0x35, 0x61,
	0x10, 0xd7, 0x9f, 0x78, 0x25, 0x3a, 0x61, 0x5a, 0xae, 0x66, 0x1a, 0xbe, 0x61, 0xe1, 0x44, 0x74,
	0x32, 0x84, 0x49, 0x98, 0x89, 0x4e, 0x6d, 0x2a, 0xba, 0xd6, 0x50, 0x5c, 0xe2, 0xcf, 0x8a, 0xb1,
	0x59, 0x8d, 0x6c, 0xc9, 0x91, 0xa5, 0xcb, 0x7f, 0x45, 0x30, 0x71, 0x9d, 0x28, 0x0e, 0x59, 0x35,
	0x4d, 0xfd, 0x06, 0x69, 0xd5, 0x89, 0x8d, 0x97, 0x20, 0xe7, 0xb8, 0x8a, 0xed, 0xca, 0x4a, 0xa3,
	0x61, 0x13, 0xc7, 0x29, 0x22, 0x11, 0xcd, 0x8e, 0x55, 0x67, 0x2a, 0xd1, 0xfd, 0x5f, 0xb3, 0x96,
	0xf8, 0xfc, 0xed, 0x6d, 0x8b, 0x48, 0xe3, 0x4c, 0xc5, 0x1f, 0xc1, 0xe7, 0x61, 0x8c, 0x18, 0x8d,
	0xfe, 0x02, 0xe9, 0x43, 0x2c, 0x00, 0xc4, 0x68, 0xf8, 0xfd, 0xda, 0xa5, 0x1d, 0x0f, 0x5d, 0x00,
	0x31, 0x86, 0x43, 0x98, 0x88, 0x0d, 0xc0, 0x4c, 0xc4, 0x8c, 0x90, 0x8b, 0x74, 0xcb, 0x7f, 0x4b,
	0xc3, 0xc4, 0xe5, 0xfb, 0x2e, 0xb1, 0x0d, 0x45, 0x5f, 0x23, 0xf6, 0x26, 0xb1, 0x1d, 0xfc, 0x0e,
	0x8c, 0x39, 0xac, 0x29, 0x53, 0x16, 0x19, 0xb0, 0x7c, 0xb5, 0x54, 0xd9, 0xef, 0xd9, 0x0a, 0xd7,
	0xe0, 0xd0, 0x9c, 0x7e, 0x1b, 0x4f, 0xc3, 0x48, 0xc3, 0x6c, 0x29, 0x9a, 0x51, 0xcc, 0x88, 0x68,
	0x36, 0x2b, 0xf9, 0x3d, 0x7c, 0x16, 0xf2, 0x4a, 0xa3, 0xa5, 0x19, 0x72, 0xdb, 0xa1, 0x06, 0x5b,
	0xa4, 0x38, 0x44, 0xe7, 0x97, 0xf3, 0x5f, 0x78, 0x28, 0xf5, 0xe9, 0x3f, 0x1e, 0x65, 0x86, 0xed,
	0x4c, 0xf1, 0x41, 0x5a, 0xca, 0x31, 0xa9, 0x77, 0x7d, 0x21, 0x7c, 0x21, 0x50, 0xb3, 0x14, 0xc7,
	0xd9, 0x32, 0xed, 0x46, 0x71, 0x98, 0x71, 0x75, 0x22, 0x06, 0x69, 0x8d, 0xa8, 0x36, 0x71, 0x19,
	0x1a, 0xbe, 0xc2, 0xaa, 0x2f, 0x5f, 0xdb, 0xde, 0xf1, 0x50, 0x1b, 0x4e, 0x42, 0x08, 0xa4, 0x30,
	0x11, 0xd9, 0xa5, 0x88, 0x00, 0x07, 0xa8, 0x85, 0xd1, 0xa0, 0x05, 0x27, 0x21, 0xcb, 0x56, 0xba,
	0xa9, 0xb4, 0x88, 0x50, 0x88, 0xc3, 0x87, 0x53, 0x10, 0x35, 0xb4, 0x27, 0x12, 0x40, 0x2d, 0x7f,
	0x3f, 0x03, 0xc3, 0x97, 0x0d, 0xd7, 0xde, 0xc6, 0x55, 0x18, 0x51, 0x54, 0x1a, 0x57, 0x2c, 0x56,
	0xf2, 0x55, 0x21, 0x89, 0xd1, 0x25, 0x26, 0x21, 0xf9, 0x92, 0xf8, 0x22, 0xe4, 0x1b, 0xc4, 0x71,
	0x35, 0x43, 0xa1, 0x5d, 0x59, 0xb3, 0x0e, 0x15, 0x26, 0xb9, 0x90, 0xce, 0x35, 0x0b, 0xbf, 0x01,
	0xd3, 0xe1, 0x45, 0x78, 0x78, 0x58, 0xa6, 0xed, 0x32, 0xf7, 0xe4, 0xa4, 0xa9, 0xd0, 0xec, 0x1a,
	0x9d, 0x5c, 0x35, 0x6d, 0x17, 0xff, 0x1f, 0x84, 0xc7, 0x65, 0x1a, 0x34, 0x4c, 0x67, 0x88, 0xe9,
	0xe0, 0xd0, 0xdc, 0x65, 0xa3, 0x41, 0x35, 0x6a, 0x1f, 0xa3, 0x1d, 0x0f, 0xfd, 0x14, 0xc1, 0x54,
	0xb0, 0x51, 0x01, 0x82, 0x96, 0x88, 0xa0, 0x1c, 0xdf, 0x0a, 0x25, 0x2b, 0x3a, 0x02, 0xd5, 0x41,
	0x48, 0x85, 0xe2, 0xa0, 0x19, 0xa8, 0x24, 0xe3, 0x14, 0xa6, 0x93, 0xc7, 0xcb, 0x57, 0xa1, 0xb0,
	0xa4, 0xea, 0x12, 0x71, 0xcc, 0xb6, 0xad, 0x12, 0xee, 0x9a, 0x45, 0x38, 0x42, 0x0c, 0xd7, 0xd6,
	0x08, 0x3d, 0x86, 0x99, 0x84, 0xd0, 0x62, 0xbe, 0x61, 0xb2, 0x52, 0x20, 0x59, 0xfe, 0x6d, 0x1a,
	0x46, 0x83, 0x65, 0xf0, 0x39, 0xc8, 0x28, 0xaa, 0xee, 0x7b, 0xe7, 0x74, 0xb2, 0x67, 0xa3, 0x46,
	0x57, 0x52, 0x12, 0x55, 0xc1, 0xb3, 0x90, 0xd9, 0x22, 0x75, 0xe6, 0x8a, 0xb1, 0xea, 0x54, 0x4c,
	0xf3, 0x72, 0xcb, 0x72, 0x99, 0xe4, 0x16, 0xa9, 0xe3, 0x1a, 0x8c, 0xab, 0xa6, 0x61, 0x10, 0xd5,
	0xd5, 0x36, 0x35, 0x77, 0x9b, 0x79, 0x62, 0xb0, 0x4a, 0x44, 0xb6, 0x26, 0xef, 0x78, 0xe8, 0x7d,
	0xf8, 0x26, 0xe4, 0x02, 0x0c, 0x22, 0x8d, 0x94, 0xb9, 0x15, 0xb8, 0x02, 0xc7, 0x19, 0xf4, 0xea,
	0x3e, 0x56, 0x20, 0xc7, 0x90, 0x55, 0x47, 0xbe, 0x41, 0xea, 0xae, 0x69, 0xc1, 0x4c, 0xd4, 0x7c,
	0x75, 0xfc, 0x62, 0xa8, 0xb7, 0x5c, 0x86, 0x9c, 0xed, 0x6b, 0xb3, 0x03, 0x85, 0x8f, 0x3e, 0xf6,
	0x10, 0xea, 0x79, 0x68, 0xb8, 0x3a, 0xbf, 0x38, 0xff, 0xc6, 0x17, 0x1e, 0x4a, 0x7f, 0x75, 0x68,
	0x14, 0x15, 0xd2, 0xe5, 0x3f, 0x21, 0x18, 0x96, 0xda, 0x3a, 0x71, 0x70, 0x05, 0x26, 0x0d, 0xe2,
	0x6e, 0x99, 0xf6, 0x5d, 0x59, 0x51, 0x55, 0xe2, 0x38, 0xb2, 0xdd, 0xd6, 0x49, 0x11, 0x89, 0x99,
	0xd9, 0xac, 0x74, 0xd4, 0x9f, 0x5a, 0x62, 0x33, 0x54, 0x01, 0x8b, 0x30, 0xbe, 0x45, 0xea, 0xb2,
	0x6b, 0x5a, 0x32, 0xcb, 0x1e, 0x69, 0x96, 0x5d, 0x60, 0x8b, 0xd4, 0x6f, 0x9b, 0x16, 0x3d, 0xa2,
	0x18, 0xc3, 0x90, 0xa2, 0xea, 0x4e, 0x31, 0xc3, 0x96, 0x60, 0xed, 0xda, 0xbb, 0xff, 0x7a, 0xfb,
	0xc8, 0xff, 0xcf, 0x33, 0x14, 0x3b, 0x1e, 0xba, 0x0a, 0x8b, 0x50, 0xbc, 0xc9, 0x97, 0x16, 0xf9,
	0xda, 0x62, 0xb0, 0x6d, 0x67, 0xf9, 0x78, 0x22, 0xa2, 0x42, 0x06, 0x0a, 0x30, 0xb4, 0xa4, 0xea,
	0xce, 0xf2, 0x28, 0x37, 0x50, 0xc8, 0x94, 0x7f, 0x91, 0x86, 0xc9, 0x25, 0x5d, 0x37, 0xb7, 0x02,
	0xed, 0x25, 0xc7, 0xd1, 0x9a, 0x06, 0x4d, 0x7e, 0x3c, 0xaf, 0xb0, 0x63, 0x9e, 0x95, 0xfc, 0x1e,
	0xbe, 0x01, 0xc7, 0xe8, 0x5a, 0x8e, 0xdc, 0xa7, 0x49, 0x61, 0x0a, 0x07, 0x45, 0x1c, 0xa3, 0x49,
	0x9a, 0x64, 0x7a, 0x31, 0x33, 0xaf, 0x40, 0xb6, 0x41, 0x8c, 0x6d, 0x4e, 0x04, 0x4f, 0xb3, 0xa3,
	0x74, 0x80, 0xd1, 0x70, 0x12, 0x40, 0xa1, 0xd0, 0xe4, 0xbd, 0x24, 0x2b, 0x65, 0xd9, 0x08, 0x9d,
	0xae, 0xd9, 0x3b, 0x1e, 0x32, 0x40, 0x87, 0xec, 0x4d, 0x72, 0xdf, 0x15, 0xaf, 0xb9, 0xa4, 0x35,
	0x27, 0xc3, 0x07, 0x50, 0x08, 0x90, 0x57, 0x47, 0x1c, 0xd7, 0xd6, 0x8c, 0x26, 0x94, 0x06, 0x60,
	0xae, 0x72, 0x07, 0xc2, 0x64, 0x08, 0x44, 0x5f, 0x69, 0x2a, 0x6c, 0x3c, 0x18, 0x2d, 0xdf, 0x82,
	0x7c, 0x6c, 0x07, 0xe7, 0x61, 0x98, 0xc9, 0xf9, 0x04, 0xbc, 0x9e, 0x78, 0x68, 0xf6, 0x13, 0x2c,
	0x71, 0xad, 0xf2, 0xc7, 0x69, 0x98, 0xa2, 0xd9, 0x72, 0x93, 0x5c, 0xd2, 0x6c, 0xa2, 0xba, 0xa6,
	0xbd, 0xfd, 0xf5, 0x36, 0xb1, 0xb7, 0x07, 0x3a, 0x60, 0x1a, 0x46, 0xd6, 0x35, 0xdd, 0x25, 0xb6,
	0x1f, 0x37, 0x7e, 0xef, 0x60, 0x26, 0xbf, 0x06, 0x13, 0x71, 0x7f, 0xf1, 0x63, 0x57, 0x4e, 0xf4,
	0x57, 0x14, 0x69, 0xde, 0x8e, 0xf4, 0x6b, 0xf7, 0x76, 0x3c, 0xd4, 0x82, 0xbb, 0x61, 0xde, 0xef,
	0xc0, 0xb7, 0x12, 0x78, 0x2f, 0x04, 0x50, 0xfb, 0x23, 0x89, 0x4c, 0x9f, 0xda, 0x07, 0xae, 0x1a,
	0x23, 0xb9, 0xfc, 0x17, 0x1a, 0xa5, 0x51, 0x96, 0x96, 0xda, 0xee, 0xc6, 0x40, 0x92, 0x4a, 0x00,
	0xe4, 0xbe, 0x45, 0x6f, 0x12, 0x7a, 0x51, 0xf9, 0x07, 0x6c, 0x6f, 0xe4, 0x60, 0xb2, 0xee, 0xc0,
	0xb4, 0xc2, 0x6c, 0xc9, 0x8d, 0xc0, 0x98, 0x7c, 0x8f, 0xfa, 0xa4, 0x38, 0xc4, 0x5c, 0x3c, 0x3b,
	0xe8, 0xc6, 0x8b, 0xfb, 0x50, 0x9a, 0x52, 0x12, 0x46, 0x6b, 0x1f, 0xd1, 0x0b, 0xe6, 0x7b, 0xf0,
	0xdd, 0x30, 0x81, 0x26, 0xb4, 0x12, 0x08, 0x9c, 0x0a, 0x6f, 0xe3, 0x60, 0x12, 0x2b, 0x83, 0x40,
	0x57, 0x13, 0xc3, 0xab, 0xfc, 0x3b, 0x04, 0xe3, 0x17, 0xdb, 0x8e, 0xdb, 0xd2, 0x3e, 0x64, 0x37,
	0x0b, 0xa5, 0x84, 0x16, 0x04, 0xe1, 0x94, 0x34, 0x4a, 0x07, 0x18, 0x25, 0x67, 0x61, 0xb4, 0x5f,
	0xb5, 0x64, 0x5e, 0x54, 0xb5, 0xf4, 0x45, 0x6b, 0x6b, 0x3b, 0x1e, 0xba, 0x05, 0x37, 0xa2, 0x96,
	0xe6, 0xce, 0xc3, 0x57, 0xe8, 0x1e, 0xfa, 0xd6, 0xfa, 0x7b, 0x38, 0xbd, 0x67, 0xa5, 0x5a, 0x1c,
	0xb4, 0x7c, 0xf9, 0x37, 0x08, 0x72, 0xd7, 0xcd, 0xa6, 0x69, 0x50, 0xe2, 0x58, 0xa1, 0x76, 0x05,
	0x72, 0x6a, 0xdb, 0x71, 0xcd, 0xc0, 0x02, 0x4b, 0xbd, 0x63, 0x55, 0x31, 0xc9, 0x4f, 0x61, 0x24,
	0x52, 0x54, 0x0d, 0xbf, 0x0f, 0xc7, 0xf6, 0x71, 0xa8, 0xb4, 0xdd, 0x8d, 0x03, 0x8f, 0xf6, 0xfe,
	0xa8, 0x94, 0x26, 0x95, 0xfd, 0x83, 0xe5, 0x5f, 0x0d, 0x01, 0xf0, 0xb2, 0x88, 0x61, 0xae, 0xc1,
	0x88, 0x6e, 0x36, 0x65, 0x3f, 0x3a, 0xc7, 0xaa, 0xa7, 0x92, 0x16, 0x8f, 0x6c, 0x73, 0x25, 0x25,
	0x0d, 0xeb, 0x66, 0xf3, 0x96, 0x81, 0x3f, 0x18, 0x84, 0x93, 0xbb, 0xe6, 0xb0, 0x38, 0x57, 0x52,
	0x89, 0x48, 0xf1, 0xb7, 0x0f, 0x88, 0x7f, 0xf4, 0xdf, 0xc4, 0xff, 0x4a, 0x2a, 0xf9, 0x04, 0xe0,
	0x1b, 0xfb, 0xd3, 0xd1, 0xf0, 0x61, 0xd3, 0xd1, 0x4a, 0x6a, 0x5f, 0x42, 0xfa, 0x35, 0x3d, 0x50,
	0xbf, 0x44, 0xf0, 0x09, 0x0a, 0x1f, 0xa9, 0x9f, 0x20, 0x78, 0x88, 0xe0, 0x78, 0xc0, 0x73, 0x35,
	0xa7, 0x87, 0xd9, 0x84, 0xf9, 0x01, 0x24, 0x56, 0x93, 0x38, 0x39, 0xe8, 0x78, 0x25, 0xed, 0x30,
	0x31, 0xa7, 0x45, 0x51, 0x2f, 0x9f, 0x80, 0xac, 0xe6, 0x92, 0x16, 0x2f, 0x33, 0xc6, 0x1f, 0x79,
	0x28, 0x4d, 0x4b, 0x8d, 0x50, 0x85, 0xf1, 0x23, 0x04, 0xf9, 0x35, 0x72, 0xaf, 0x4d, 0x0c, 0x95,
	0xf0, 0xc8, 0xc1, 0x97, 0xe1, 0xd5, 0x70, 0xf1, 0x12, 0xdc, 0xee, 0x96, 0xa9, 0x6b, 0xaa, 0x9f,
	0xcd, 0x78, 0x22, 0x9c, 0x09, 0x8b, 0xf1, 0xfa, 0x60, 0x95, 0x09, 0xb1, 0xe3, 0xfc, 0x0e, 0x8c,
	0x19, 0xe4, 0xbe, 0x2b, 0xfb, 0x85, 0x3c, 0x8f, 0xc0, 0xd2, 0xe0, 0x42, 0x9e, 0x7f, 0x1a, 0x51,
	0x15, 0xde, 0x2f, 0xff, 0x7e, 0x1c, 0xa6, 0x56, 0x89, 0xbd, 0xc6, 0x33, 0x13, 0x5f, 0x99, 0x85,
	0xf5, 0x3f, 0xd3, 0x90, 0x0d, 0xf6, 0xe9, 0xf8, 0xe7, 0xf0, 0xcb, 0x49, 0x0b, 0x27, 0x69, 0xf7,
	0x3d, 0xed, 0xb0, 0xca, 0x6d, 0xf9, 0x87, 0x69, 0xfa, 0x35, 0x35, 0xfe, 0x10, 0x65, 0xcb, 0x47,
	0xec, 0xe1, 0x02, 0x2a, 0x3e, 0x60, 0x03, 0xc3, 0x0f, 0x51, 0xba, 0x70, 0xa1, 0xf7, 0xf4, 0xcf,
	0x99, 0xd3, 0x9d, 0x2e, 0x12, 0x71, 0x69, 0xd7, 0x43, 0x02, 0xdd, 0x97, 0x68, 0xae, 0x8b, 0xee,
	0x06, 0x11, 0x03, 0x00, 0x22, 0xa5, 0xb6, 0x42, 0x05, 0x67, 0x3a, 0x5d, 0x54, 0xc4, 0xd3, 0x3d,
	0x0f, 0xe1, 0x48, 0xe5, 0x28, 0x52, 0x35, 0x2a, 0x00, 0x9d, 0x2e, 0x1a, 0xc1, 0x43, 0x9f, 0x79,
	0x28, 0x4d, 0xbb, 0x23, 0x9d, 0x2e, 0x4a, 0x8f, 0x22, 0xda, 0xdc, 0xe8, 0x74, 0x51, 0x43, 0xa8,
	0xef, 0x7a, 0xe8, 0xce, 0x45, 0xd3, 0x70, 0x15, 0xcd, 0x70, 0x98, 0x11, 0x51, 0x35, 0x8d, 0x75,
	0xad, 0xd9, 0xb6, 0x59, 0xee, 0x10, 0xd7, 0x4d, 0x5b, 0xe4, 0x15, 0xe6, 0x95, 0xb6, 0xae, 0x2f,
	0x2c, 0xa9, 0xfa, 0x42, 0xb8, 0xb0, 0x0c, 0xac, 0xde, 0x0c, 0x57, 0x83, 0x51, 0xa0, 0xd4, 0xd8,
	0x64, 0xa7, 0x8b, 0x26, 0x84, 0x5c, 0xcf, 0x43, 0xd9, 0x3e, 0xce, 0x3e, 0x3c, 0x61, 0xe8, 0x91,
	0x87, 0x90, 0xb4, 0xc7, 0x2f, 0x7e, 0x9a, 0x86, 0xa3, 0x3a, 0xfd, 0xa4, 0x97, 0x2d, 0xd3, 0xd4,
	0xe5, 0x16, 0xfb, 0xa8, 0xf7, 0xb3, 0xd5, 0xf9, 0x43, 0xb3, 0x1e, 0x7b, 0x14, 0xe0, 0xdc, 0xff,
	0x1b, 0xbd, 0x80, 0xfb, 0xd7, 0x3b, 0x5d, 0xf4, 0x1a, 0x3e, 0xb5, 0xeb, 0xa1, 0x93, 0x61, 0xee,
	0x19, 0x1c, 0x91, 0xc2, 0x11, 0x39, 0x1c, 0x2a, 0x2b, 0x76, 0xba, 0x68, 0x06, 0x0b, 0x3d, 0x0f,
	0x4d, 0x33, 0x63, 0x22, 0xb5, 0x26, 0x72, 0x73, 0x87, 0x70, 0xc1, 0x9b, 0x9d, 0x2e, 0x3a, 0x2b,
	0x2c, 0xee, 0x7a, 0x68, 0xc1, 0x77, 0x01, 0x33, 0xc5, 0xbe, 0x9e, 0x44, 0xc5, 0x68, 0x88, 0xc4,
	0x68, 0x88, 0xfe, 0x53, 0x00, 0xc5, 0xb1, 0x87, 0xa1, 0xef, 0x7b, 0x81, 0xf9, 0x3e, 0x6a, 0x9c,
	0xf8, 0xe8, 0xc2, 0xe4, 0x4e, 0xe8, 0xb1, 0x17, 0x92, 0x9f, 0x65, 0x60, 0x82, 0xf8, 0x2f, 0x0b,
	0xb2, 0x5f, 0x6b, 0x64, 0x18, 0xc1, 0x6f, 0x1d, 0x9a, 0xe0, 0xe8, 0xcb, 0x04, 0xe7, 0xf7, 0xd3,
	0x17, 0xc5, 0xf6, 0x5b, 0x9d, 0x2e, 0x3a, 0x87, 0xbf, 0xb4, 0xeb, 0xa1, 0x6a, 0x98, 0xdf, 0x00,
	0x8b, 0xc8, 0xb1, 0xb0, 0xb8, 0xb3, 0x88, 0x2d, 0x3a, 0xdc, 0xaa, 0xc8, 0x53, 0x01, 0x5d, 0xa0,
	0xd4, 0xe9, 0x22, 0x01, 0x17, 0x7b, 0x1e, 0x9a, 0x0a, 0x00, 0x88, 0x1c, 0xc1, 0x21, 0x28, 0x37,
	0x3b, 0x5d, 0x74, 0x57, 0xd0, 0x76, 0x3d, 0x44, 0x6e, 0x6f, 0x68, 0x8e, 0xb8, 0xae, 0x11, 0xbd,
	0x41, 0x43, 0x7e, 0xef, 0x00, 0xec, 0x8f, 0xff, 0x38, 0x36, 0x1a, 0xd5, 0xf3, 0x22, 0x7b, 0x49,
	0x10, 0x69, 0x6e, 0x12, 0xe7, 0x79, 0x3b, 0xb8, 0xe4, 0x99, 0xef, 0xf8, 0x13, 0x05, 0xb5, 0x79,
	0xa2, 0xd3, 0x45, 0xc7, 0x84, 0xc9, 0x9e, 0x87, 0x26, 0x62, 0x80, 0xe3, 0x5e, 0xca, 0x93, 0x08,
	0xa3, 0xf8, 0x2c, 0x1c, 0xb7, 0x88, 0x2d, 0xfb, 0x1c, 0x44, 0xd2, 0x21, 0xff, 0x6a, 0x98, 0xb2,
	0x62, 0x7e, 0x09, 0xaa, 0x62, 0xc7, 0xcf, 0xaf, 0x41, 0x2a, 0x3c, 0xe0, 0x1a, 0x8a, 0xa6, 0x62,
	0x29, 0xef, 0x44, 0xfa, 0xc2, 0x7b, 0x7b, 0x5f, 0x06, 0x3c, 0x7d, 0xe1, 0x02, 0x64, 0xee, 0x92,
	0x6d, 0x3f, 0x21, 0xd3, 0x26, 0xae, 0xc2, 0xf0, 0xa6, 0xa2, 0xb7, 0xc9, 0x80, 0xe7, 0x8f, 0xc8,
	0x6d, 0x27, 0x71, 0xd1, 0x5a, 0xfa, 0x1c, 0x12, 0x9a, 0x30, 0x95, 0x74, 0x48, 0x13, 0x2c, 0xbc,
	0x19, 0xb5, 0xf0, 0x5a, 0x62, 0x55, 0x11, 0x5d, 0x2a, 0x6c, 0x68, 0x1d, 0x26, 0x13, 0x82, 0xf5,
	0x7f, 0xb4, 0x13, 0x7b, 0x90, 0x0b, 0xd9, 0x29, 0xff, 0x18, 0xc1, 0x74, 0x38, 0x3d, 0x86, 0x6e,
	0x90, 0x15, 0xc8, 0x87, 0xee, 0x2e, 0x8d, 0x38, 0xfe, 0x3b, 0x53, 0x72, 0x35, 0x17, 0x4e, 0xb1,
	0x31, 0x3d, 0x7c, 0x0e, 0x8a, 0x91, 0xcb, 0x32, 0x1c, 0x16, 0xbc, 0xc0, 0x9d, 0x56, 0xf7, 0x61,
	0xa0, 0x81, 0x51, 0xfe, 0x04, 0x41, 0xfe, 0xaa, 0x6e, 0xd6, 0x15, 0x7d, 0xcd, 0x22, 0x2a, 0x83,
	0x75, 0x33, 0xf6, 0x6a, 0xc1, 0x1f, 0x4a, 0xe7, 0x5e, 0x04, 0x6a, 0x6f, 0x63, 0xd1, 0x97, 0x0c,
	0x7c, 0x0d, 0xc6, 0x42, 0x21, 0xeb, 0xd3, 0x38, 0x7b, 0xd8, 0x94, 0x22, 0xc1, 0x5e, 0x40, 0x97,
	0xff, 0x80, 0x20, 0x7f, 0xd1, 0x26, 0x8a, 0x4b, 0x5e, 0x02, 0xb4, 0xb5, 0xa3, 0x3b, 0x6f, 0xc7,
	0xb8, 0x2d, 0xff, 0x11, 0xc1, 0x84, 0x44, 0x2c, 0x5d, 0x51, 0x5f, 0xd6, 0x1d, 0x78, 0x08, 0xc6,
	0xae, 0x12, 0xf7, 0xe5, 0x44, 0x3f, 0xb7, 0x08, 0xb0, 0xf7, 0x04, 0x8e, 0x27, 0x61, 0x22, 0x56,
	0xcc, 0x17, 0x52, 0xb8, 0x00, 0xe3, 0x92, 0xd2, 0xd0, 0xda, 0x0e, 0x17, 0x2c, 0xa0, 0xb9, 0x57,
	0x61, 0xc4, 0x2f, 0x4a, 0x01, 0x46, 0x6c, 0xf2, 0x1d, 0xa2, 0xba, 0x85, 0x14, 0xce, 0xfa, 0xaf,
	0x21, 0x05, 0x34, 0x77, 0x0a, 0x22, 0x4f, 0x6b, 0xf8, 0x08, 0x64, 0x56, 0x57, 0x57, 0x0b, 0x29,
	0x3c, 0x0a, 0x43, 0x97, 0x6e, 0x5f, 0x5f, 0x2b, 0xa0, 0xe5, 0x8f, 0xd0, 0xe3, 0x67, 0xa5, 0xd4,
	0x93, 0x67, 0xa5, 0xd4, 0xe7, 0xcf, 0x4a, 0xe8, 0x41, 0xaf, 0x84, 0x7e, 0xde, 0x2b, 0xa1, 0xcf,
	0x7a, 0x25, 0xf4, 0xb8, 0x57, 0x42, 0x4f, 0x7a, 0x25, 0xf4, 0xb4, 0x57, 0x42, 0x7f, 0xef, 0x95,
	0x52, 0x9f, 0xf7, 0x4a, 0xe8, 0x07, 0xcf, 0x4b, 0xa9, 0xc7, 0xcf, 0x4b, 0xa9, 0x27, 0xcf, 0x4b,
	0xa9, 0xf7, 0x56, 0x9a, 0xa6, 0x75, 0xb7, 0x59, 0xd9, 0x34, 0x75, 0x97, 0xd8, 0xb6, 0x52, 0x69,
	0x3b, 0x0b, 0xac, 0xb1, 0x6e, 0xda, 0xad, 0x33, 0x96, 0x6d, 0x6e, 0x6a, 0x0d, 0x62, 0x9f, 0x09,
	0xa6, 0x17, 0xac, 0x7a, 0xd3, 0x5c, 0x20, 0xf7, 0x5d, 0xff, 0xf7, 0x48, 0xe8, 0xbf, 0x4f, 0x7d,
	0x84, 0xfd, 0x1e, 0x59, 0xfc, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0a, 0x05, 0x31, 0x54, 0x14,
	0x1a, 0x00, 0x00,
}

func (x ServerType) String() string {
	s, ok := ServerType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Action) String() string {
	s, ok := Action_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Connectivity) String() string {
	s, ok := Connectivity_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *LeasePoolMember) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LeasePoolMember)
	if !ok {
		that2, ok := that.(LeasePoolMember)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StartAddress.Equal(that1.StartAddress) {
		return false
	}
	if !this.EndAddress.Equal(that1.EndAddress) {
		return false
	}
	return true
}
func (this *ExternalServers) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExternalServers)
	if !ok {
		that2, ok := that.(ExternalServers)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerType != that1.ServerType {
		return false
	}
	if this.Domain != that1.Domain {
		return false
	}
	if this.AdminUsername != that1.AdminUsername {
		return false
	}
	if !this.AdminPassword.Equal(that1.AdminPassword) {
		return false
	}
	return true
}
func (this *Entry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Entry)
	if !ok {
		that2, ok := that.(Entry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if !this.DestinationIp.Equal(that1.DestinationIp) {
		return false
	}
	if this.DestinationStartPort != that1.DestinationStartPort {
		return false
	}
	if this.DestinationEndPort != that1.DestinationEndPort {
		return false
	}
	return true
}
func (this *AclResourceEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AclResourceEntry)
	if !ok {
		that2, ok := that.(AclResourceEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Entries) != len(that1.Entries) {
		return false
	}
	for i := range this.Entries {
		if !this.Entries[i].Equal(that1.Entries[i]) {
			return false
		}
	}
	return true
}
func (this *Resource) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Resource)
	if !ok {
		that2, ok := that.(Resource)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ResourceType == nil {
		if this.ResourceType != nil {
			return false
		}
	} else if this.ResourceType == nil {
		return false
	} else if !this.ResourceType.Equal(that1.ResourceType) {
		return false
	}
	return true
}
func (this *Resource_Acl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Resource_Acl)
	if !ok {
		that2, ok := that.(Resource_Acl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Acl.Equal(that1.Acl) {
		return false
	}
	return true
}
func (this *Resource_Web) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Resource_Web)
	if !ok {
		that2, ok := that.(Resource_Web)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Web.Equal(that1.Web) {
		return false
	}
	return true
}
func (this *Resource_Connectivity) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Resource_Connectivity)
	if !ok {
		that2, ok := that.(Resource_Connectivity)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Connectivity.Equal(that1.Connectivity) {
		return false
	}
	return true
}
func (this *Rules) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Rules)
	if !ok {
		that2, ok := that.(Rules)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.NetworkAccessRule) != len(that1.NetworkAccessRule) {
		return false
	}
	for i := range this.NetworkAccessRule {
		if this.NetworkAccessRule[i] != that1.NetworkAccessRule[i] {
			return false
		}
	}
	if this.WebTopName != that1.WebTopName {
		return false
	}
	if len(this.Acls) != len(that1.Acls) {
		return false
	}
	for i := range this.Acls {
		if this.Acls[i] != that1.Acls[i] {
			return false
		}
	}
	return true
}
func (this *AllowResourceAssign) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AllowResourceAssign)
	if !ok {
		that2, ok := that.(AllowResourceAssign)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Server != that1.Server {
		return false
	}
	if len(this.RulesResourceAssign) != len(that1.RulesResourceAssign) {
		return false
	}
	for i := range this.RulesResourceAssign {
		if !this.RulesResourceAssign[i].Equal(that1.RulesResourceAssign[i]) {
			return false
		}
	}
	if this.DenyName != that1.DenyName {
		return false
	}
	if this.AllowName != that1.AllowName {
		return false
	}
	return true
}
func (this *ResourceAssign) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResourceAssign)
	if !ok {
		that2, ok := that.(ResourceAssign)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Allow) != len(that1.Allow) {
		return false
	}
	for i := range this.Allow {
		if !this.Allow[i].Equal(that1.Allow[i]) {
			return false
		}
	}
	return true
}
func (this *ActiveDirectoryQuery) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActiveDirectoryQuery)
	if !ok {
		that2, ok := that.(ActiveDirectoryQuery)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Server != that1.Server {
		return false
	}
	if this.Filter != that1.Filter {
		return false
	}
	if this.DenyName != that1.DenyName {
		return false
	}
	if !this.ResourceAssign.Equal(that1.ResourceAssign) {
		return false
	}
	return true
}
func (this *ActiveDirectoryAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActiveDirectoryAuth)
	if !ok {
		that2, ok := that.(ActiveDirectoryAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Server != that1.Server {
		return false
	}
	if this.Expression != that1.Expression {
		return false
	}
	if this.DenyName != that1.DenyName {
		return false
	}
	if len(this.ActiveDirectoryQuery) != len(that1.ActiveDirectoryQuery) {
		return false
	}
	for i := range this.ActiveDirectoryQuery {
		if !this.ActiveDirectoryQuery[i].Equal(that1.ActiveDirectoryQuery[i]) {
			return false
		}
	}
	return true
}
func (this *Custmization) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Custmization)
	if !ok {
		that2, ok := that.(Custmization)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UserName != that1.UserName {
		return false
	}
	if !this.Password.Equal(that1.Password) {
		return false
	}
	return true
}
func (this *LogonItemType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LogonItemType)
	if !ok {
		that2, ok := that.(LogonItemType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Customization) != len(that1.Customization) {
		return false
	}
	for i := range this.Customization {
		if !this.Customization[i].Equal(that1.Customization[i]) {
			return false
		}
	}
	if len(this.ActiveDirectoryAuth) != len(that1.ActiveDirectoryAuth) {
		return false
	}
	for i := range this.ActiveDirectoryAuth {
		if !this.ActiveDirectoryAuth[i].Equal(that1.ActiveDirectoryAuth[i]) {
			return false
		}
	}
	return true
}
func (this *ActionType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActionType)
	if !ok {
		that2, ok := that.(ActionType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ItemType == nil {
		if this.ItemType != nil {
			return false
		}
	} else if this.ItemType == nil {
		return false
	} else if !this.ItemType.Equal(that1.ItemType) {
		return false
	}
	return true
}
func (this *ActionType_LogOn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActionType_LogOn)
	if !ok {
		that2, ok := that.(ActionType_LogOn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogOn.Equal(that1.LogOn) {
		return false
	}
	return true
}
func (this *ActionType_ActiveDirectoryAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActionType_ActiveDirectoryAuth)
	if !ok {
		that2, ok := that.(ActionType_ActiveDirectoryAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ActiveDirectoryAuth.Equal(that1.ActiveDirectoryAuth) {
		return false
	}
	return true
}
func (this *ActionType_ActiveDirectoryQuery) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActionType_ActiveDirectoryQuery)
	if !ok {
		that2, ok := that.(ActionType_ActiveDirectoryQuery)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ActiveDirectoryQuery.Equal(that1.ActiveDirectoryQuery) {
		return false
	}
	return true
}
func (this *ActionType_ResourceAssign) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActionType_ResourceAssign)
	if !ok {
		that2, ok := that.(ActionType_ResourceAssign)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ResourceAssign.Equal(that1.ResourceAssign) {
		return false
	}
	return true
}
func (this *SequenceAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SequenceAction)
	if !ok {
		that2, ok := that.(SequenceAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ConnectivityAccessPolicyName != that1.ConnectivityAccessPolicyName {
		return false
	}
	if !this.NextAction.Equal(that1.NextAction) {
		return false
	}
	return true
}
func (this *PerSessionPolicyType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PerSessionPolicyType)
	if !ok {
		that2, ok := that.(PerSessionPolicyType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Resources) != len(that1.Resources) {
		return false
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(that1.Resources[i]) {
			return false
		}
	}
	if len(this.LeasePoolMember) != len(that1.LeasePoolMember) {
		return false
	}
	for i := range this.LeasePoolMember {
		if !this.LeasePoolMember[i].Equal(that1.LeasePoolMember[i]) {
			return false
		}
	}
	if len(this.ExternalServer) != len(that1.ExternalServer) {
		return false
	}
	for i := range this.ExternalServer {
		if !this.ExternalServer[i].Equal(that1.ExternalServer[i]) {
			return false
		}
	}
	if this.PerSessionPolicyName != that1.PerSessionPolicyName {
		return false
	}
	if !this.SequenceAction.Equal(that1.SequenceAction) {
		return false
	}
	return true
}
func (this *ConnectivityPolicyType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConnectivityPolicyType)
	if !ok {
		that2, ok := that.(ConnectivityPolicyType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Connectivities != that1.Connectivities {
		return false
	}
	if this.ConnectivityPolicyName != that1.ConnectivityPolicyName {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Connectivity.Equal(that1.Connectivity) {
		return false
	}
	if !this.PerSession.Equal(that1.PerSession) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Connectivity.Equal(that1.Connectivity) {
		return false
	}
	if !this.PerSession.Equal(that1.PerSession) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Connectivity.Equal(that1.Connectivity) {
		return false
	}
	if !this.PerSession.Equal(that1.PerSession) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Connectivity.Equal(that1.Connectivity) {
		return false
	}
	if !this.PerSession.Equal(that1.PerSession) {
		return false
	}
	return true
}
func (this *LeasePoolMember) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&ztna.LeasePoolMember{")
	if this.StartAddress != nil {
		s = append(s, "StartAddress: "+fmt.Sprintf("%#v", this.StartAddress)+",\n")
	}
	if this.EndAddress != nil {
		s = append(s, "EndAddress: "+fmt.Sprintf("%#v", this.EndAddress)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExternalServers) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&ztna.ExternalServers{")
	s = append(s, "ServerType: "+fmt.Sprintf("%#v", this.ServerType)+",\n")
	s = append(s, "Domain: "+fmt.Sprintf("%#v", this.Domain)+",\n")
	s = append(s, "AdminUsername: "+fmt.Sprintf("%#v", this.AdminUsername)+",\n")
	if this.AdminPassword != nil {
		s = append(s, "AdminPassword: "+fmt.Sprintf("%#v", this.AdminPassword)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Entry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&ztna.Entry{")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	if this.DestinationIp != nil {
		s = append(s, "DestinationIp: "+fmt.Sprintf("%#v", this.DestinationIp)+",\n")
	}
	s = append(s, "DestinationStartPort: "+fmt.Sprintf("%#v", this.DestinationStartPort)+",\n")
	s = append(s, "DestinationEndPort: "+fmt.Sprintf("%#v", this.DestinationEndPort)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AclResourceEntry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&ztna.AclResourceEntry{")
	if this.Entries != nil {
		s = append(s, "Entries: "+fmt.Sprintf("%#v", this.Entries)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Resource) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&ztna.Resource{")
	if this.ResourceType != nil {
		s = append(s, "ResourceType: "+fmt.Sprintf("%#v", this.ResourceType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Resource_Acl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ztna.Resource_Acl{` +
		`Acl:` + fmt.Sprintf("%#v", this.Acl) + `}`}, ", ")
	return s
}
func (this *Resource_Web) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ztna.Resource_Web{` +
		`Web:` + fmt.Sprintf("%#v", this.Web) + `}`}, ", ")
	return s
}
func (this *Resource_Connectivity) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ztna.Resource_Connectivity{` +
		`Connectivity:` + fmt.Sprintf("%#v", this.Connectivity) + `}`}, ", ")
	return s
}
func (this *Rules) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&ztna.Rules{")
	s = append(s, "NetworkAccessRule: "+fmt.Sprintf("%#v", this.NetworkAccessRule)+",\n")
	s = append(s, "WebTopName: "+fmt.Sprintf("%#v", this.WebTopName)+",\n")
	s = append(s, "Acls: "+fmt.Sprintf("%#v", this.Acls)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AllowResourceAssign) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&ztna.AllowResourceAssign{")
	s = append(s, "Server: "+fmt.Sprintf("%#v", this.Server)+",\n")
	if this.RulesResourceAssign != nil {
		s = append(s, "RulesResourceAssign: "+fmt.Sprintf("%#v", this.RulesResourceAssign)+",\n")
	}
	s = append(s, "DenyName: "+fmt.Sprintf("%#v", this.DenyName)+",\n")
	s = append(s, "AllowName: "+fmt.Sprintf("%#v", this.AllowName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResourceAssign) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&ztna.ResourceAssign{")
	if this.Allow != nil {
		s = append(s, "Allow: "+fmt.Sprintf("%#v", this.Allow)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ActiveDirectoryQuery) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&ztna.ActiveDirectoryQuery{")
	s = append(s, "Server: "+fmt.Sprintf("%#v", this.Server)+",\n")
	s = append(s, "Filter: "+fmt.Sprintf("%#v", this.Filter)+",\n")
	s = append(s, "DenyName: "+fmt.Sprintf("%#v", this.DenyName)+",\n")
	if this.ResourceAssign != nil {
		s = append(s, "ResourceAssign: "+fmt.Sprintf("%#v", this.ResourceAssign)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ActiveDirectoryAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&ztna.ActiveDirectoryAuth{")
	s = append(s, "Server: "+fmt.Sprintf("%#v", this.Server)+",\n")
	s = append(s, "Expression: "+fmt.Sprintf("%#v", this.Expression)+",\n")
	s = append(s, "DenyName: "+fmt.Sprintf("%#v", this.DenyName)+",\n")
	if this.ActiveDirectoryQuery != nil {
		s = append(s, "ActiveDirectoryQuery: "+fmt.Sprintf("%#v", this.ActiveDirectoryQuery)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Custmization) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&ztna.Custmization{")
	s = append(s, "UserName: "+fmt.Sprintf("%#v", this.UserName)+",\n")
	if this.Password != nil {
		s = append(s, "Password: "+fmt.Sprintf("%#v", this.Password)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LogonItemType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&ztna.LogonItemType{")
	if this.Customization != nil {
		s = append(s, "Customization: "+fmt.Sprintf("%#v", this.Customization)+",\n")
	}
	if this.ActiveDirectoryAuth != nil {
		s = append(s, "ActiveDirectoryAuth: "+fmt.Sprintf("%#v", this.ActiveDirectoryAuth)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ActionType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&ztna.ActionType{")
	if this.ItemType != nil {
		s = append(s, "ItemType: "+fmt.Sprintf("%#v", this.ItemType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ActionType_LogOn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ztna.ActionType_LogOn{` +
		`LogOn:` + fmt.Sprintf("%#v", this.LogOn) + `}`}, ", ")
	return s
}
func (this *ActionType_ActiveDirectoryAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ztna.ActionType_ActiveDirectoryAuth{` +
		`ActiveDirectoryAuth:` + fmt.Sprintf("%#v", this.ActiveDirectoryAuth) + `}`}, ", ")
	return s
}
func (this *ActionType_ActiveDirectoryQuery) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ztna.ActionType_ActiveDirectoryQuery{` +
		`ActiveDirectoryQuery:` + fmt.Sprintf("%#v", this.ActiveDirectoryQuery) + `}`}, ", ")
	return s
}
func (this *ActionType_ResourceAssign) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ztna.ActionType_ResourceAssign{` +
		`ResourceAssign:` + fmt.Sprintf("%#v", this.ResourceAssign) + `}`}, ", ")
	return s
}
func (this *SequenceAction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&ztna.SequenceAction{")
	s = append(s, "ConnectivityAccessPolicyName: "+fmt.Sprintf("%#v", this.ConnectivityAccessPolicyName)+",\n")
	if this.NextAction != nil {
		s = append(s, "NextAction: "+fmt.Sprintf("%#v", this.NextAction)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PerSessionPolicyType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&ztna.PerSessionPolicyType{")
	keysForResources := make([]string, 0, len(this.Resources))
	for k, _ := range this.Resources {
		keysForResources = append(keysForResources, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForResources)
	mapStringForResources := "map[string]*Resource{"
	for _, k := range keysForResources {
		mapStringForResources += fmt.Sprintf("%#v: %#v,", k, this.Resources[k])
	}
	mapStringForResources += "}"
	if this.Resources != nil {
		s = append(s, "Resources: "+mapStringForResources+",\n")
	}
	keysForLeasePoolMember := make([]string, 0, len(this.LeasePoolMember))
	for k, _ := range this.LeasePoolMember {
		keysForLeasePoolMember = append(keysForLeasePoolMember, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLeasePoolMember)
	mapStringForLeasePoolMember := "map[string]*LeasePoolMember{"
	for _, k := range keysForLeasePoolMember {
		mapStringForLeasePoolMember += fmt.Sprintf("%#v: %#v,", k, this.LeasePoolMember[k])
	}
	mapStringForLeasePoolMember += "}"
	if this.LeasePoolMember != nil {
		s = append(s, "LeasePoolMember: "+mapStringForLeasePoolMember+",\n")
	}
	keysForExternalServer := make([]string, 0, len(this.ExternalServer))
	for k, _ := range this.ExternalServer {
		keysForExternalServer = append(keysForExternalServer, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForExternalServer)
	mapStringForExternalServer := "map[string]*ExternalServers{"
	for _, k := range keysForExternalServer {
		mapStringForExternalServer += fmt.Sprintf("%#v: %#v,", k, this.ExternalServer[k])
	}
	mapStringForExternalServer += "}"
	if this.ExternalServer != nil {
		s = append(s, "ExternalServer: "+mapStringForExternalServer+",\n")
	}
	s = append(s, "PerSessionPolicyName: "+fmt.Sprintf("%#v", this.PerSessionPolicyName)+",\n")
	if this.SequenceAction != nil {
		s = append(s, "SequenceAction: "+fmt.Sprintf("%#v", this.SequenceAction)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConnectivityPolicyType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&ztna.ConnectivityPolicyType{")
	s = append(s, "Connectivities: "+fmt.Sprintf("%#v", this.Connectivities)+",\n")
	s = append(s, "ConnectivityPolicyName: "+fmt.Sprintf("%#v", this.ConnectivityPolicyName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&ztna.GlobalSpecType{")
	if this.Connectivity != nil {
		s = append(s, "Connectivity: "+fmt.Sprintf("%#v", this.Connectivity)+",\n")
	}
	if this.PerSession != nil {
		s = append(s, "PerSession: "+fmt.Sprintf("%#v", this.PerSession)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&ztna.CreateSpecType{")
	if this.Connectivity != nil {
		s = append(s, "Connectivity: "+fmt.Sprintf("%#v", this.Connectivity)+",\n")
	}
	if this.PerSession != nil {
		s = append(s, "PerSession: "+fmt.Sprintf("%#v", this.PerSession)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&ztna.ReplaceSpecType{")
	if this.Connectivity != nil {
		s = append(s, "Connectivity: "+fmt.Sprintf("%#v", this.Connectivity)+",\n")
	}
	if this.PerSession != nil {
		s = append(s, "PerSession: "+fmt.Sprintf("%#v", this.PerSession)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&ztna.GetSpecType{")
	if this.Connectivity != nil {
		s = append(s, "Connectivity: "+fmt.Sprintf("%#v", this.Connectivity)+",\n")
	}
	if this.PerSession != nil {
		s = append(s, "PerSession: "+fmt.Sprintf("%#v", this.PerSession)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *LeasePoolMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeasePoolMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeasePoolMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndAddress != nil {
		{
			size, err := m.EndAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.StartAddress != nil {
		{
			size, err := m.StartAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExternalServers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalServers) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternalServers) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdminPassword != nil {
		{
			size, err := m.AdminPassword.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AdminUsername) > 0 {
		i -= len(m.AdminUsername)
		copy(dAtA[i:], m.AdminUsername)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AdminUsername)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ServerType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ServerType))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DestinationEndPort != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DestinationEndPort))
		i--
		dAtA[i] = 0x20
	}
	if m.DestinationStartPort != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DestinationStartPort))
		i--
		dAtA[i] = 0x18
	}
	if m.DestinationIp != nil {
		{
			size, err := m.DestinationIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Action != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AclResourceEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclResourceEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclResourceEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *Resource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Resource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResourceType != nil {
		{
			size := m.ResourceType.Size()
			i -= size
			if _, err := m.ResourceType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Resource_Acl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Resource_Acl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Acl != nil {
		{
			size, err := m.Acl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Resource_Web) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Resource_Web) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Web != nil {
		{
			size, err := m.Web.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Resource_Connectivity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Resource_Connectivity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Connectivity != nil {
		{
			size, err := m.Connectivity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Rules) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rules) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rules) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Acls) > 0 {
		for iNdEx := len(m.Acls) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Acls[iNdEx])
			copy(dAtA[i:], m.Acls[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Acls[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.WebTopName) > 0 {
		i -= len(m.WebTopName)
		copy(dAtA[i:], m.WebTopName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.WebTopName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NetworkAccessRule) > 0 {
		for iNdEx := len(m.NetworkAccessRule) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NetworkAccessRule[iNdEx])
			copy(dAtA[i:], m.NetworkAccessRule[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.NetworkAccessRule[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AllowResourceAssign) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllowResourceAssign) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllowResourceAssign) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AllowName) > 0 {
		i -= len(m.AllowName)
		copy(dAtA[i:], m.AllowName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AllowName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DenyName) > 0 {
		i -= len(m.DenyName)
		copy(dAtA[i:], m.DenyName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DenyName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RulesResourceAssign) > 0 {
		for iNdEx := len(m.RulesResourceAssign) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RulesResourceAssign[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Server) > 0 {
		i -= len(m.Server)
		copy(dAtA[i:], m.Server)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Server)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResourceAssign) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceAssign) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceAssign) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Allow) > 0 {
		for iNdEx := len(m.Allow) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Allow[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActiveDirectoryQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActiveDirectoryQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActiveDirectoryQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResourceAssign != nil {
		{
			size, err := m.ResourceAssign.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.DenyName) > 0 {
		i -= len(m.DenyName)
		copy(dAtA[i:], m.DenyName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DenyName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Filter) > 0 {
		i -= len(m.Filter)
		copy(dAtA[i:], m.Filter)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Filter)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Server) > 0 {
		i -= len(m.Server)
		copy(dAtA[i:], m.Server)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Server)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActiveDirectoryAuth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActiveDirectoryAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActiveDirectoryAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ActiveDirectoryQuery) > 0 {
		for iNdEx := len(m.ActiveDirectoryQuery) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ActiveDirectoryQuery[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.DenyName) > 0 {
		i -= len(m.DenyName)
		copy(dAtA[i:], m.DenyName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DenyName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Expression) > 0 {
		i -= len(m.Expression)
		copy(dAtA[i:], m.Expression)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Expression)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Server) > 0 {
		i -= len(m.Server)
		copy(dAtA[i:], m.Server)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Server)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Custmization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Custmization) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Custmization) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Password != nil {
		{
			size, err := m.Password.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *LogonItemType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogonItemType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogonItemType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ActiveDirectoryAuth) > 0 {
		for iNdEx := len(m.ActiveDirectoryAuth) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ActiveDirectoryAuth[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Customization) > 0 {
		for iNdEx := len(m.Customization) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Customization[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ItemType != nil {
		{
			size := m.ItemType.Size()
			i -= size
			if _, err := m.ItemType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActionType_LogOn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionType_LogOn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LogOn != nil {
		{
			size, err := m.LogOn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ActionType_ActiveDirectoryAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionType_ActiveDirectoryAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ActiveDirectoryAuth != nil {
		{
			size, err := m.ActiveDirectoryAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ActionType_ActiveDirectoryQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionType_ActiveDirectoryQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ActiveDirectoryQuery != nil {
		{
			size, err := m.ActiveDirectoryQuery.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ActionType_ResourceAssign) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionType_ResourceAssign) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ResourceAssign != nil {
		{
			size, err := m.ResourceAssign.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *SequenceAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SequenceAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SequenceAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NextAction != nil {
		{
			size, err := m.NextAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ConnectivityAccessPolicyName) > 0 {
		i -= len(m.ConnectivityAccessPolicyName)
		copy(dAtA[i:], m.ConnectivityAccessPolicyName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ConnectivityAccessPolicyName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PerSessionPolicyType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PerSessionPolicyType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PerSessionPolicyType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SequenceAction != nil {
		{
			size, err := m.SequenceAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PerSessionPolicyName) > 0 {
		i -= len(m.PerSessionPolicyName)
		copy(dAtA[i:], m.PerSessionPolicyName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PerSessionPolicyName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ExternalServer) > 0 {
		keysForExternalServer := make([]string, 0, len(m.ExternalServer))
		for k := range m.ExternalServer {
			keysForExternalServer = append(keysForExternalServer, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForExternalServer)
		for iNdEx := len(keysForExternalServer) - 1; iNdEx >= 0; iNdEx-- {
			v := m.ExternalServer[string(keysForExternalServer[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTypes(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForExternalServer[iNdEx])
			copy(dAtA[i:], keysForExternalServer[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForExternalServer[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.LeasePoolMember) > 0 {
		keysForLeasePoolMember := make([]string, 0, len(m.LeasePoolMember))
		for k := range m.LeasePoolMember {
			keysForLeasePoolMember = append(keysForLeasePoolMember, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLeasePoolMember)
		for iNdEx := len(keysForLeasePoolMember) - 1; iNdEx >= 0; iNdEx-- {
			v := m.LeasePoolMember[string(keysForLeasePoolMember[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTypes(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForLeasePoolMember[iNdEx])
			copy(dAtA[i:], keysForLeasePoolMember[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLeasePoolMember[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Resources) > 0 {
		keysForResources := make([]string, 0, len(m.Resources))
		for k := range m.Resources {
			keysForResources = append(keysForResources, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForResources)
		for iNdEx := len(keysForResources) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Resources[string(keysForResources[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTypes(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForResources[iNdEx])
			copy(dAtA[i:], keysForResources[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForResources[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ConnectivityPolicyType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectivityPolicyType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConnectivityPolicyType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ConnectivityPolicyName) > 0 {
		i -= len(m.ConnectivityPolicyName)
		copy(dAtA[i:], m.ConnectivityPolicyName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ConnectivityPolicyName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Connectivities != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Connectivities))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PerSession != nil {
		{
			size, err := m.PerSession.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Connectivity != nil {
		{
			size, err := m.Connectivity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PerSession != nil {
		{
			size, err := m.PerSession.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Connectivity != nil {
		{
			size, err := m.Connectivity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PerSession != nil {
		{
			size, err := m.PerSession.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Connectivity != nil {
		{
			size, err := m.Connectivity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PerSession != nil {
		{
			size, err := m.PerSession.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Connectivity != nil {
		{
			size, err := m.Connectivity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LeasePoolMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartAddress != nil {
		l = m.StartAddress.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EndAddress != nil {
		l = m.EndAddress.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ExternalServers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerType != 0 {
		n += 1 + sovTypes(uint64(m.ServerType))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AdminUsername)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AdminPassword != nil {
		l = m.AdminPassword.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Entry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	if m.DestinationIp != nil {
		l = m.DestinationIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DestinationStartPort != 0 {
		n += 1 + sovTypes(uint64(m.DestinationStartPort))
	}
	if m.DestinationEndPort != 0 {
		n += 1 + sovTypes(uint64(m.DestinationEndPort))
	}
	return n
}

func (m *AclResourceEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *Resource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResourceType != nil {
		n += m.ResourceType.Size()
	}
	return n
}

func (m *Resource_Acl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Acl != nil {
		l = m.Acl.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Resource_Web) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Web != nil {
		l = m.Web.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Resource_Connectivity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Connectivity != nil {
		l = m.Connectivity.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Rules) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NetworkAccessRule) > 0 {
		for _, s := range m.NetworkAccessRule {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.WebTopName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Acls) > 0 {
		for _, s := range m.Acls {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AllowResourceAssign) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Server)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.RulesResourceAssign) > 0 {
		for _, e := range m.RulesResourceAssign {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.DenyName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AllowName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ResourceAssign) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Allow) > 0 {
		for _, e := range m.Allow {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ActiveDirectoryQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Server)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Filter)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DenyName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ResourceAssign != nil {
		l = m.ResourceAssign.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ActiveDirectoryAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Server)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Expression)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DenyName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.ActiveDirectoryQuery) > 0 {
		for _, e := range m.ActiveDirectoryQuery {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *Custmization) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Password != nil {
		l = m.Password.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *LogonItemType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Customization) > 0 {
		for _, e := range m.Customization {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ActiveDirectoryAuth) > 0 {
		for _, e := range m.ActiveDirectoryAuth {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ActionType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ItemType != nil {
		n += m.ItemType.Size()
	}
	return n
}

func (m *ActionType_LogOn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogOn != nil {
		l = m.LogOn.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ActionType_ActiveDirectoryAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActiveDirectoryAuth != nil {
		l = m.ActiveDirectoryAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ActionType_ActiveDirectoryQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActiveDirectoryQuery != nil {
		l = m.ActiveDirectoryQuery.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ActionType_ResourceAssign) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResourceAssign != nil {
		l = m.ResourceAssign.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SequenceAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConnectivityAccessPolicyName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NextAction != nil {
		l = m.NextAction.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *PerSessionPolicyType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for k, v := range m.Resources {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.LeasePoolMember) > 0 {
		for k, v := range m.LeasePoolMember {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.ExternalServer) > 0 {
		for k, v := range m.ExternalServer {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.PerSessionPolicyName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SequenceAction != nil {
		l = m.SequenceAction.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ConnectivityPolicyType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Connectivities != 0 {
		n += 1 + sovTypes(uint64(m.Connectivities))
	}
	l = len(m.ConnectivityPolicyName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Connectivity != nil {
		l = m.Connectivity.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PerSession != nil {
		l = m.PerSession.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Connectivity != nil {
		l = m.Connectivity.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PerSession != nil {
		l = m.PerSession.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Connectivity != nil {
		l = m.Connectivity.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PerSession != nil {
		l = m.PerSession.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Connectivity != nil {
		l = m.Connectivity.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PerSession != nil {
		l = m.PerSession.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *LeasePoolMember) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LeasePoolMember{`,
		`StartAddress:` + strings.Replace(fmt.Sprintf("%v", this.StartAddress), "IpAddressType", "schema.IpAddressType", 1) + `,`,
		`EndAddress:` + strings.Replace(fmt.Sprintf("%v", this.EndAddress), "IpAddressType", "schema.IpAddressType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ExternalServers) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ExternalServers{`,
		`ServerType:` + fmt.Sprintf("%v", this.ServerType) + `,`,
		`Domain:` + fmt.Sprintf("%v", this.Domain) + `,`,
		`AdminUsername:` + fmt.Sprintf("%v", this.AdminUsername) + `,`,
		`AdminPassword:` + strings.Replace(fmt.Sprintf("%v", this.AdminPassword), "SecretType", "schema.SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Entry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Entry{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`DestinationIp:` + strings.Replace(fmt.Sprintf("%v", this.DestinationIp), "IpAddressType", "schema.IpAddressType", 1) + `,`,
		`DestinationStartPort:` + fmt.Sprintf("%v", this.DestinationStartPort) + `,`,
		`DestinationEndPort:` + fmt.Sprintf("%v", this.DestinationEndPort) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AclResourceEntry) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForEntries := "[]*Entry{"
	for _, f := range this.Entries {
		repeatedStringForEntries += strings.Replace(f.String(), "Entry", "Entry", 1) + ","
	}
	repeatedStringForEntries += "}"
	s := strings.Join([]string{`&AclResourceEntry{`,
		`Entries:` + repeatedStringForEntries + `,`,
		`}`,
	}, "")
	return s
}
func (this *Resource) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Resource{`,
		`ResourceType:` + fmt.Sprintf("%v", this.ResourceType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Resource_Acl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Resource_Acl{`,
		`Acl:` + strings.Replace(fmt.Sprintf("%v", this.Acl), "AclResourceEntry", "AclResourceEntry", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Resource_Web) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Resource_Web{`,
		`Web:` + strings.Replace(fmt.Sprintf("%v", this.Web), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Resource_Connectivity) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Resource_Connectivity{`,
		`Connectivity:` + strings.Replace(fmt.Sprintf("%v", this.Connectivity), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Rules) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Rules{`,
		`NetworkAccessRule:` + fmt.Sprintf("%v", this.NetworkAccessRule) + `,`,
		`WebTopName:` + fmt.Sprintf("%v", this.WebTopName) + `,`,
		`Acls:` + fmt.Sprintf("%v", this.Acls) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AllowResourceAssign) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRulesResourceAssign := "[]*Rules{"
	for _, f := range this.RulesResourceAssign {
		repeatedStringForRulesResourceAssign += strings.Replace(f.String(), "Rules", "Rules", 1) + ","
	}
	repeatedStringForRulesResourceAssign += "}"
	s := strings.Join([]string{`&AllowResourceAssign{`,
		`Server:` + fmt.Sprintf("%v", this.Server) + `,`,
		`RulesResourceAssign:` + repeatedStringForRulesResourceAssign + `,`,
		`DenyName:` + fmt.Sprintf("%v", this.DenyName) + `,`,
		`AllowName:` + fmt.Sprintf("%v", this.AllowName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResourceAssign) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAllow := "[]*AllowResourceAssign{"
	for _, f := range this.Allow {
		repeatedStringForAllow += strings.Replace(f.String(), "AllowResourceAssign", "AllowResourceAssign", 1) + ","
	}
	repeatedStringForAllow += "}"
	s := strings.Join([]string{`&ResourceAssign{`,
		`Allow:` + repeatedStringForAllow + `,`,
		`}`,
	}, "")
	return s
}
func (this *ActiveDirectoryQuery) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ActiveDirectoryQuery{`,
		`Server:` + fmt.Sprintf("%v", this.Server) + `,`,
		`Filter:` + fmt.Sprintf("%v", this.Filter) + `,`,
		`DenyName:` + fmt.Sprintf("%v", this.DenyName) + `,`,
		`ResourceAssign:` + strings.Replace(this.ResourceAssign.String(), "ResourceAssign", "ResourceAssign", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ActiveDirectoryAuth) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForActiveDirectoryQuery := "[]*ActiveDirectoryQuery{"
	for _, f := range this.ActiveDirectoryQuery {
		repeatedStringForActiveDirectoryQuery += strings.Replace(f.String(), "ActiveDirectoryQuery", "ActiveDirectoryQuery", 1) + ","
	}
	repeatedStringForActiveDirectoryQuery += "}"
	s := strings.Join([]string{`&ActiveDirectoryAuth{`,
		`Server:` + fmt.Sprintf("%v", this.Server) + `,`,
		`Expression:` + fmt.Sprintf("%v", this.Expression) + `,`,
		`DenyName:` + fmt.Sprintf("%v", this.DenyName) + `,`,
		`ActiveDirectoryQuery:` + repeatedStringForActiveDirectoryQuery + `,`,
		`}`,
	}, "")
	return s
}
func (this *Custmization) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Custmization{`,
		`UserName:` + fmt.Sprintf("%v", this.UserName) + `,`,
		`Password:` + strings.Replace(fmt.Sprintf("%v", this.Password), "SecretType", "schema.SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LogonItemType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCustomization := "[]*Custmization{"
	for _, f := range this.Customization {
		repeatedStringForCustomization += strings.Replace(f.String(), "Custmization", "Custmization", 1) + ","
	}
	repeatedStringForCustomization += "}"
	repeatedStringForActiveDirectoryAuth := "[]*ActiveDirectoryAuth{"
	for _, f := range this.ActiveDirectoryAuth {
		repeatedStringForActiveDirectoryAuth += strings.Replace(f.String(), "ActiveDirectoryAuth", "ActiveDirectoryAuth", 1) + ","
	}
	repeatedStringForActiveDirectoryAuth += "}"
	s := strings.Join([]string{`&LogonItemType{`,
		`Customization:` + repeatedStringForCustomization + `,`,
		`ActiveDirectoryAuth:` + repeatedStringForActiveDirectoryAuth + `,`,
		`}`,
	}, "")
	return s
}
func (this *ActionType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ActionType{`,
		`ItemType:` + fmt.Sprintf("%v", this.ItemType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ActionType_LogOn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ActionType_LogOn{`,
		`LogOn:` + strings.Replace(fmt.Sprintf("%v", this.LogOn), "LogonItemType", "LogonItemType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ActionType_ActiveDirectoryAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ActionType_ActiveDirectoryAuth{`,
		`ActiveDirectoryAuth:` + strings.Replace(fmt.Sprintf("%v", this.ActiveDirectoryAuth), "ActiveDirectoryAuth", "ActiveDirectoryAuth", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ActionType_ActiveDirectoryQuery) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ActionType_ActiveDirectoryQuery{`,
		`ActiveDirectoryQuery:` + strings.Replace(fmt.Sprintf("%v", this.ActiveDirectoryQuery), "ActiveDirectoryQuery", "ActiveDirectoryQuery", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ActionType_ResourceAssign) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ActionType_ResourceAssign{`,
		`ResourceAssign:` + strings.Replace(fmt.Sprintf("%v", this.ResourceAssign), "ResourceAssign", "ResourceAssign", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SequenceAction) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SequenceAction{`,
		`ConnectivityAccessPolicyName:` + fmt.Sprintf("%v", this.ConnectivityAccessPolicyName) + `,`,
		`NextAction:` + strings.Replace(this.NextAction.String(), "ActionType", "ActionType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PerSessionPolicyType) String() string {
	if this == nil {
		return "nil"
	}
	keysForResources := make([]string, 0, len(this.Resources))
	for k, _ := range this.Resources {
		keysForResources = append(keysForResources, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForResources)
	mapStringForResources := "map[string]*Resource{"
	for _, k := range keysForResources {
		mapStringForResources += fmt.Sprintf("%v: %v,", k, this.Resources[k])
	}
	mapStringForResources += "}"
	keysForLeasePoolMember := make([]string, 0, len(this.LeasePoolMember))
	for k, _ := range this.LeasePoolMember {
		keysForLeasePoolMember = append(keysForLeasePoolMember, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLeasePoolMember)
	mapStringForLeasePoolMember := "map[string]*LeasePoolMember{"
	for _, k := range keysForLeasePoolMember {
		mapStringForLeasePoolMember += fmt.Sprintf("%v: %v,", k, this.LeasePoolMember[k])
	}
	mapStringForLeasePoolMember += "}"
	keysForExternalServer := make([]string, 0, len(this.ExternalServer))
	for k, _ := range this.ExternalServer {
		keysForExternalServer = append(keysForExternalServer, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForExternalServer)
	mapStringForExternalServer := "map[string]*ExternalServers{"
	for _, k := range keysForExternalServer {
		mapStringForExternalServer += fmt.Sprintf("%v: %v,", k, this.ExternalServer[k])
	}
	mapStringForExternalServer += "}"
	s := strings.Join([]string{`&PerSessionPolicyType{`,
		`Resources:` + mapStringForResources + `,`,
		`LeasePoolMember:` + mapStringForLeasePoolMember + `,`,
		`ExternalServer:` + mapStringForExternalServer + `,`,
		`PerSessionPolicyName:` + fmt.Sprintf("%v", this.PerSessionPolicyName) + `,`,
		`SequenceAction:` + strings.Replace(this.SequenceAction.String(), "SequenceAction", "SequenceAction", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConnectivityPolicyType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConnectivityPolicyType{`,
		`Connectivities:` + fmt.Sprintf("%v", this.Connectivities) + `,`,
		`ConnectivityPolicyName:` + fmt.Sprintf("%v", this.ConnectivityPolicyName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Connectivity:` + strings.Replace(this.Connectivity.String(), "ConnectivityPolicyType", "ConnectivityPolicyType", 1) + `,`,
		`PerSession:` + strings.Replace(this.PerSession.String(), "PerSessionPolicyType", "PerSessionPolicyType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Connectivity:` + strings.Replace(this.Connectivity.String(), "ConnectivityPolicyType", "ConnectivityPolicyType", 1) + `,`,
		`PerSession:` + strings.Replace(this.PerSession.String(), "PerSessionPolicyType", "PerSessionPolicyType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Connectivity:` + strings.Replace(this.Connectivity.String(), "ConnectivityPolicyType", "ConnectivityPolicyType", 1) + `,`,
		`PerSession:` + strings.Replace(this.PerSession.String(), "PerSessionPolicyType", "PerSessionPolicyType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`Connectivity:` + strings.Replace(this.Connectivity.String(), "ConnectivityPolicyType", "ConnectivityPolicyType", 1) + `,`,
		`PerSession:` + strings.Replace(this.PerSession.String(), "PerSessionPolicyType", "PerSessionPolicyType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *LeasePoolMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeasePoolMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeasePoolMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartAddress == nil {
				m.StartAddress = &schema.IpAddressType{}
			}
			if err := m.StartAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndAddress == nil {
				m.EndAddress = &schema.IpAddressType{}
			}
			if err := m.EndAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalServers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalServers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalServers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerType", wireType)
			}
			m.ServerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerType |= ServerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdminUsername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminPassword", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdminPassword == nil {
				m.AdminPassword = &schema.SecretType{}
			}
			if err := m.AdminPassword.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= Action(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DestinationIp == nil {
				m.DestinationIp = &schema.IpAddressType{}
			}
			if err := m.DestinationIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationStartPort", wireType)
			}
			m.DestinationStartPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestinationStartPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationEndPort", wireType)
			}
			m.DestinationEndPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestinationEndPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclResourceEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclResourceEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclResourceEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Resource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Resource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AclResourceEntry{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceType = &Resource_Acl{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Web", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceType = &Resource_Web{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connectivity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceType = &Resource_Connectivity{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rules) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkAccessRule", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkAccessRule = append(m.NetworkAccessRule, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebTopName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WebTopName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acls", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Acls = append(m.Acls, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllowResourceAssign) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllowResourceAssign: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllowResourceAssign: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Server = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RulesResourceAssign", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RulesResourceAssign = append(m.RulesResourceAssign, &Rules{})
			if err := m.RulesResourceAssign[len(m.RulesResourceAssign)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DenyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceAssign) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceAssign: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceAssign: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Allow = append(m.Allow, &AllowResourceAssign{})
			if err := m.Allow[len(m.Allow)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActiveDirectoryQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActiveDirectoryQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActiveDirectoryQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Server = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DenyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceAssign", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceAssign == nil {
				m.ResourceAssign = &ResourceAssign{}
			}
			if err := m.ResourceAssign.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActiveDirectoryAuth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActiveDirectoryAuth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActiveDirectoryAuth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Server = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DenyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveDirectoryQuery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActiveDirectoryQuery = append(m.ActiveDirectoryQuery, &ActiveDirectoryQuery{})
			if err := m.ActiveDirectoryQuery[len(m.ActiveDirectoryQuery)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Custmization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Custmization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Custmization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Password == nil {
				m.Password = &schema.SecretType{}
			}
			if err := m.Password.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogonItemType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogonItemType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogonItemType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Customization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Customization = append(m.Customization, &Custmization{})
			if err := m.Customization[len(m.Customization)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveDirectoryAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActiveDirectoryAuth = append(m.ActiveDirectoryAuth, &ActiveDirectoryAuth{})
			if err := m.ActiveDirectoryAuth[len(m.ActiveDirectoryAuth)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogOn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LogonItemType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ItemType = &ActionType_LogOn{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveDirectoryAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ActiveDirectoryAuth{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ItemType = &ActionType_ActiveDirectoryAuth{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveDirectoryQuery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ActiveDirectoryQuery{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ItemType = &ActionType_ActiveDirectoryQuery{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceAssign", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ResourceAssign{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ItemType = &ActionType_ResourceAssign{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SequenceAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SequenceAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SequenceAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectivityAccessPolicyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectivityAccessPolicyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NextAction == nil {
				m.NextAction = &ActionType{}
			}
			if err := m.NextAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PerSessionPolicyType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PerSessionPolicyType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PerSessionPolicyType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = make(map[string]*Resource)
			}
			var mapkey string
			var mapvalue *Resource
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Resource{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Resources[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeasePoolMember", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeasePoolMember == nil {
				m.LeasePoolMember = make(map[string]*LeasePoolMember)
			}
			var mapkey string
			var mapvalue *LeasePoolMember
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &LeasePoolMember{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.LeasePoolMember[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExternalServer == nil {
				m.ExternalServer = make(map[string]*ExternalServers)
			}
			var mapkey string
			var mapvalue *ExternalServers
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ExternalServers{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ExternalServer[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerSessionPolicyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PerSessionPolicyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SequenceAction == nil {
				m.SequenceAction = &SequenceAction{}
			}
			if err := m.SequenceAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectivityPolicyType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectivityPolicyType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectivityPolicyType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connectivities", wireType)
			}
			m.Connectivities = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Connectivities |= Connectivity(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectivityPolicyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectivityPolicyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connectivity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connectivity == nil {
				m.Connectivity = &ConnectivityPolicyType{}
			}
			if err := m.Connectivity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerSession", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PerSession == nil {
				m.PerSession = &PerSessionPolicyType{}
			}
			if err := m.PerSession.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connectivity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connectivity == nil {
				m.Connectivity = &ConnectivityPolicyType{}
			}
			if err := m.Connectivity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerSession", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PerSession == nil {
				m.PerSession = &PerSessionPolicyType{}
			}
			if err := m.PerSession.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connectivity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connectivity == nil {
				m.Connectivity = &ConnectivityPolicyType{}
			}
			if err := m.Connectivity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerSession", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PerSession == nil {
				m.PerSession = &PerSessionPolicyType{}
			}
			if err := m.PerSession.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connectivity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connectivity == nil {
				m.Connectivity = &ConnectivityPolicyType{}
			}
			if err := m.Connectivity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerSession", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PerSession == nil {
				m.PerSession = &PerSessionPolicyType{}
			}
			if err := m.PerSession.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
