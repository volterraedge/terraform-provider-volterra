// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package quota

import (
	"fmt"
	"strings"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	"gopkg.volterra.us/stdlib/svcfw"
)

func (o *DBObject) GetObjectMaxLimit(objKind string) (int, error) {
	if o == nil {
		return 0, status.Errorf(codes.Internal, "Nil quota.DBObject")
	}
	limits := o.GetSpec().GetGcSpec().GetObjectLimits()
	if limits == nil {
		return 0, svcfw.QuotaNotConfiguredError{Kind: objKind, Message: "Nil ObjectLimits in quota"}
	}
	lim, exists := limits[objKind]
	if !exists {
		return 0, svcfw.QuotaNotConfiguredError{Kind: objKind, Message: "Limit not configured for object kind"}
	}
	return int(lim.GetMaximum()), nil
}

func (o *DBObject) GetAPIRateLimits(rpcFQN string, rate *int, burst *int, unit *string) error {
	if o == nil {
		return fmt.Errorf("DBObject is nil")
	}
	if rate == nil || burst == nil || unit == nil {
		return fmt.Errorf("rate(%v), burst(%v), or unit(%v) is nil", rate, burst, unit)
	}

	limits := o.GetSpec().GetGcSpec().GetApiLimits()
	if limits == nil {
		*rate = -1
		*burst = -1
		*unit = "rate-per-second"
	}
	lim, exists := limits[rpcFQN]
	if !exists {
		return svcfw.QuotaNotConfiguredError{Kind: rpcFQN, Message: "RateLimit not configured for API"}
	}

	*rate = int(lim.GetRate())
	*burst = int(lim.GetBurst())
	*unit = lim.GetUnit()
	return nil
}

// GetResourceMaxLimit returns the value configured in quota.Object.ResourceLimits for rkey
// If outLPM is not nil, then it returns the value for the longest-prefix-match of rkey
func (o *DBObject) GetResourceMaxLimit(rkey string, outLPM *string) (float64, error) {
	if o == nil {
		return 0, status.Errorf(codes.Internal, "Nil quota.DBObject")
	}
	limits := o.GetSpec().GetGcSpec().GetResourceLimits()
	if limits == nil {
		return 0, svcfw.QuotaNotConfiguredError{Kind: rkey, Message: "Nil ResourceLimits in quota"}
	}
	var lim *FloatLimitType
	if outLPM == nil {
		// exact match needed
		if l, exists := limits[rkey]; !exists {
			return 0, svcfw.QuotaNotConfiguredError{Kind: rkey, Message: "Limit not configured for resource"}
		} else {
			lim = l
		}
	} else {
		// find which resource key in quota object is both a prefix of rkey and the longest one at that
		matchingRK := ""
		for rk := range limits {
			if !strings.HasPrefix(rkey, rk) {
				continue
			}
			if len(rk) > len(matchingRK) {
				matchingRK = rk
			}
		}
		if matchingRK == "" {
			return 0, svcfw.QuotaNotConfiguredError{Kind: rkey, Message: "Limit not configured for resource prefix"}
		}
		lim = limits[matchingRK]
		*outLPM = matchingRK
	}
	return lim.GetMaximum(), nil
}
