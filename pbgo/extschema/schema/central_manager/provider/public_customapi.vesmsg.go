// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AlertState) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AlertState) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AlertState) DeepCopy() *AlertState {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AlertState{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AlertState) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AlertState) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AlertStateValidator().Validate(ctx, m, opts...)
}

type ValidateAlertState struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAlertState) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AlertState)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AlertState got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["resource"]; exists {

		vOpts := append(opts, db.WithValidateField("resource"))
		if err := fv(ctx, m.GetResource(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAlertStateValidator = func() *ValidateAlertState {
	v := &ValidateAlertState{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["state"] = StateValidator().Validate

	return v
}()

func AlertStateValidator() db.Validator {
	return DefaultAlertStateValidator
}

// augmented methods on protoc/std generated struct

func (m *Deployment) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Deployment) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Deployment) DeepCopy() *Deployment {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Deployment{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Deployment) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Deployment) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DeploymentValidator().Validate(ctx, m, opts...)
}

type ValidateDeployment struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDeployment) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Deployment)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Deployment got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cpu"]; exists {

		vOpts := append(opts, db.WithValidateField("cpu"))
		for idx, item := range m.GetCpu() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["disk"]; exists {

		vOpts := append(opts, db.WithValidateField("disk"))
		for idx, item := range m.GetDisk() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["disk_total"]; exists {

		vOpts := append(opts, db.WithValidateField("disk_total"))
		if err := fv(ctx, m.GetDiskTotal(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["memory"]; exists {

		vOpts := append(opts, db.WithValidateField("memory"))
		for idx, item := range m.GetMemory() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["memory_total"]; exists {

		vOpts := append(opts, db.WithValidateField("memory_total"))
		if err := fv(ctx, m.GetMemoryTotal(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vcpu"]; exists {

		vOpts := append(opts, db.WithValidateField("vcpu"))
		if err := fv(ctx, m.GetVcpu(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDeploymentValidator = func() *ValidateDeployment {
	v := &ValidateDeployment{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DeploymentValidator() db.Validator {
	return DefaultDeploymentValidator
}

// augmented methods on protoc/std generated struct

func (m *GetDeploymentRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetDeploymentRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetDeploymentRequest) DeepCopy() *GetDeploymentRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetDeploymentRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetDeploymentRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetDeploymentRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetDeploymentRequestValidator().Validate(ctx, m, opts...)
}

type ValidateGetDeploymentRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetDeploymentRequest) CmIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cm_id")
	}

	return validatorFn, nil
}

func (v *ValidateGetDeploymentRequest) ProviderIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for provider_id")
	}

	return validatorFn, nil
}

func (v *ValidateGetDeploymentRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetDeploymentRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetDeploymentRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cm_id"]; exists {

		vOpts := append(opts, db.WithValidateField("cm_id"))
		if err := fv(ctx, m.GetCmId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["limit"]; exists {

		vOpts := append(opts, db.WithValidateField("limit"))
		if err := fv(ctx, m.GetLimit(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["page"]; exists {

		vOpts := append(opts, db.WithValidateField("page"))
		if err := fv(ctx, m.GetPage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["provider_id"]; exists {

		vOpts := append(opts, db.WithValidateField("provider_id"))
		if err := fv(ctx, m.GetProviderId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetDeploymentRequestValidator = func() *ValidateGetDeploymentRequest {
	v := &ValidateGetDeploymentRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCmId := v.CmIdValidationRuleHandler
	rulesCmId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhCmId(rulesCmId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetDeploymentRequest.cm_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cm_id"] = vFn

	vrhProviderId := v.ProviderIdValidationRuleHandler
	rulesProviderId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhProviderId(rulesProviderId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetDeploymentRequest.provider_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["provider_id"] = vFn

	return v
}()

func GetDeploymentRequestValidator() db.Validator {
	return DefaultGetDeploymentRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *GetDeploymentResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetDeploymentResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetDeploymentResponse) DeepCopy() *GetDeploymentResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetDeploymentResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetDeploymentResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetDeploymentResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetDeploymentResponseValidator().Validate(ctx, m, opts...)
}

type ValidateGetDeploymentResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetDeploymentResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetDeploymentResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetDeploymentResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["count"]; exists {

		vOpts := append(opts, db.WithValidateField("count"))
		if err := fv(ctx, m.GetCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["deployments"]; exists {

		vOpts := append(opts, db.WithValidateField("deployments"))
		for idx, item := range m.GetDeployments() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["link"]; exists {

		vOpts := append(opts, db.WithValidateField("link"))
		if err := fv(ctx, m.GetLink(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["total"]; exists {

		vOpts := append(opts, db.WithValidateField("total"))
		if err := fv(ctx, m.GetTotal(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetDeploymentResponseValidator = func() *ValidateGetDeploymentResponse {
	v := &ValidateGetDeploymentResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetDeploymentResponseValidator() db.Validator {
	return DefaultGetDeploymentResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *GetRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetRequest) DeepCopy() *GetRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetRequestValidator().Validate(ctx, m, opts...)
}

type ValidateGetRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetRequest) CmIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cm_id")
	}

	return validatorFn, nil
}

func (v *ValidateGetRequest) ProviderIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for provider_id")
	}

	return validatorFn, nil
}

func (v *ValidateGetRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cm_id"]; exists {

		vOpts := append(opts, db.WithValidateField("cm_id"))
		if err := fv(ctx, m.GetCmId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["provider_id"]; exists {

		vOpts := append(opts, db.WithValidateField("provider_id"))
		if err := fv(ctx, m.GetProviderId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetRequestValidator = func() *ValidateGetRequest {
	v := &ValidateGetRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCmId := v.CmIdValidationRuleHandler
	rulesCmId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhCmId(rulesCmId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetRequest.cm_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cm_id"] = vFn

	vrhProviderId := v.ProviderIdValidationRuleHandler
	rulesProviderId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhProviderId(rulesProviderId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetRequest.provider_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["provider_id"] = vFn

	return v
}()

func GetRequestValidator() db.Validator {
	return DefaultGetRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *GetResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetResponse) DeepCopy() *GetResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetResponseValidator().Validate(ctx, m, opts...)
}

type ValidateGetResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["alerts"]; exists {

		vOpts := append(opts, db.WithValidateField("alerts"))
		for idx, item := range m.GetAlerts() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["base_os_version"]; exists {

		vOpts := append(opts, db.WithValidateField("base_os_version"))
		if err := fv(ctx, m.GetBaseOsVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bytes_in"]; exists {

		vOpts := append(opts, db.WithValidateField("bytes_in"))
		for idx, item := range m.GetBytesIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["bytes_out"]; exists {

		vOpts := append(opts, db.WithValidateField("bytes_out"))
		for idx, item := range m.GetBytesOut() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["cpu"]; exists {

		vOpts := append(opts, db.WithValidateField("cpu"))
		for idx, item := range m.GetCpu() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["disk_available"]; exists {

		vOpts := append(opts, db.WithValidateField("disk_available"))
		if err := fv(ctx, m.GetDiskAvailable(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disk_size"]; exists {

		vOpts := append(opts, db.WithValidateField("disk_size"))
		if err := fv(ctx, m.GetDiskSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disk_usage"]; exists {

		vOpts := append(opts, db.WithValidateField("disk_usage"))
		for idx, item := range m.GetDiskUsage() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["memory"]; exists {

		vOpts := append(opts, db.WithValidateField("memory"))
		for idx, item := range m.GetMemory() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["product_name"]; exists {

		vOpts := append(opts, db.WithValidateField("product_name"))
		if err := fv(ctx, m.GetProductName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["provider_host"]; exists {

		vOpts := append(opts, db.WithValidateField("provider_host"))
		if err := fv(ctx, m.GetProviderHost(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["provider_id"]; exists {

		vOpts := append(opts, db.WithValidateField("provider_id"))
		if err := fv(ctx, m.GetProviderId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["provider_name"]; exists {

		vOpts := append(opts, db.WithValidateField("provider_name"))
		if err := fv(ctx, m.GetProviderName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["provider_type"]; exists {

		vOpts := append(opts, db.WithValidateField("provider_type"))
		if err := fv(ctx, m.GetProviderType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["software_version"]; exists {

		vOpts := append(opts, db.WithValidateField("software_version"))
		if err := fv(ctx, m.GetSoftwareVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["system_memory_available"]; exists {

		vOpts := append(opts, db.WithValidateField("system_memory_available"))
		if err := fv(ctx, m.GetSystemMemoryAvailable(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["system_memory_total"]; exists {

		vOpts := append(opts, db.WithValidateField("system_memory_total"))
		if err := fv(ctx, m.GetSystemMemoryTotal(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tenants"]; exists {

		vOpts := append(opts, db.WithValidateField("tenants"))
		if err := fv(ctx, m.GetTenants(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["updated"]; exists {

		vOpts := append(opts, db.WithValidateField("updated"))
		if err := fv(ctx, m.GetUpdated(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vcpu_deployed"]; exists {

		vOpts := append(opts, db.WithValidateField("vcpu_deployed"))
		if err := fv(ctx, m.GetVcpuDeployed(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vcpu_total"]; exists {

		vOpts := append(opts, db.WithValidateField("vcpu_total"))
		if err := fv(ctx, m.GetVcpuTotal(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetResponseValidator = func() *ValidateGetResponse {
	v := &ValidateGetResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["alerts"] = AlertStateValidator().Validate

	return v
}()

func GetResponseValidator() db.Validator {
	return DefaultGetResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *Links) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Links) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Links) DeepCopy() *Links {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Links{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Links) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Links) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LinksValidator().Validate(ctx, m, opts...)
}

type ValidateLinks struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLinks) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Links)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Links got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["first"]; exists {

		vOpts := append(opts, db.WithValidateField("first"))
		if err := fv(ctx, m.GetFirst(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["last"]; exists {

		vOpts := append(opts, db.WithValidateField("last"))
		if err := fv(ctx, m.GetLast(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["next"]; exists {

		vOpts := append(opts, db.WithValidateField("next"))
		if err := fv(ctx, m.GetNext(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["prev"]; exists {

		vOpts := append(opts, db.WithValidateField("prev"))
		if err := fv(ctx, m.GetPrev(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["self"]; exists {

		vOpts := append(opts, db.WithValidateField("self"))
		if err := fv(ctx, m.GetSelf(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLinksValidator = func() *ValidateLinks {
	v := &ValidateLinks{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LinksValidator() db.Validator {
	return DefaultLinksValidator
}

// augmented methods on protoc/std generated struct

func (m *ListRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListRequest) DeepCopy() *ListRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListRequestValidator().Validate(ctx, m, opts...)
}

type ValidateListRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListRequest) CmIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cm_id")
	}

	return validatorFn, nil
}

func (v *ValidateListRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cm_id"]; exists {

		vOpts := append(opts, db.WithValidateField("cm_id"))
		if err := fv(ctx, m.GetCmId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListRequestValidator = func() *ValidateListRequest {
	v := &ValidateListRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCmId := v.CmIdValidationRuleHandler
	rulesCmId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhCmId(rulesCmId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListRequest.cm_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cm_id"] = vFn

	return v
}()

func ListRequestValidator() db.Validator {
	return DefaultListRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ListResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListResponse) DeepCopy() *ListResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListResponseValidator().Validate(ctx, m, opts...)
}

type ValidateListResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["count"]; exists {

		vOpts := append(opts, db.WithValidateField("count"))
		if err := fv(ctx, m.GetCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["providers"]; exists {

		vOpts := append(opts, db.WithValidateField("providers"))
		for idx, item := range m.GetProviders() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["total"]; exists {

		vOpts := append(opts, db.WithValidateField("total"))
		if err := fv(ctx, m.GetTotal(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListResponseValidator = func() *ValidateListResponse {
	v := &ValidateListResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ListResponseValidator() db.Validator {
	return DefaultListResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *MetricsAttribute) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MetricsAttribute) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MetricsAttribute) DeepCopy() *MetricsAttribute {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MetricsAttribute{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MetricsAttribute) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MetricsAttribute) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MetricsAttributeValidator().Validate(ctx, m, opts...)
}

type ValidateMetricsAttribute struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMetricsAttribute) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MetricsAttribute)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MetricsAttribute got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("timestamp"))
		if err := fv(ctx, m.GetTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMetricsAttributeValidator = func() *ValidateMetricsAttribute {
	v := &ValidateMetricsAttribute{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func MetricsAttributeValidator() db.Validator {
	return DefaultMetricsAttributeValidator
}

// augmented methods on protoc/std generated struct

func (m *Provider) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Provider) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Provider) DeepCopy() *Provider {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Provider{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Provider) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Provider) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ProviderValidator().Validate(ctx, m, opts...)
}

type ValidateProvider struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateProvider) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Provider)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Provider got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["bytes_in"]; exists {

		vOpts := append(opts, db.WithValidateField("bytes_in"))
		for idx, item := range m.GetBytesIn() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["bytes_out"]; exists {

		vOpts := append(opts, db.WithValidateField("bytes_out"))
		for idx, item := range m.GetBytesOut() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["cpu"]; exists {

		vOpts := append(opts, db.WithValidateField("cpu"))
		for idx, item := range m.GetCpu() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["memory"]; exists {

		vOpts := append(opts, db.WithValidateField("memory"))
		for idx, item := range m.GetMemory() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["product_name"]; exists {

		vOpts := append(opts, db.WithValidateField("product_name"))
		if err := fv(ctx, m.GetProductName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["provider_host"]; exists {

		vOpts := append(opts, db.WithValidateField("provider_host"))
		if err := fv(ctx, m.GetProviderHost(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["provider_id"]; exists {

		vOpts := append(opts, db.WithValidateField("provider_id"))
		if err := fv(ctx, m.GetProviderId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["provider_name"]; exists {

		vOpts := append(opts, db.WithValidateField("provider_name"))
		if err := fv(ctx, m.GetProviderName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["provider_type"]; exists {

		vOpts := append(opts, db.WithValidateField("provider_type"))
		if err := fv(ctx, m.GetProviderType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["updated"]; exists {

		vOpts := append(opts, db.WithValidateField("updated"))
		if err := fv(ctx, m.GetUpdated(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultProviderValidator = func() *ValidateProvider {
	v := &ValidateProvider{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ProviderValidator() db.Validator {
	return DefaultProviderValidator
}

// augmented methods on protoc/std generated struct

func (m *State) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *State) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *State) DeepCopy() *State {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &State{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *State) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *State) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StateValidator().Validate(ctx, m, opts...)
}

type ValidateState struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateState) SeverityValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for severity")
	}

	return validatorFn, nil
}

func (v *ValidateState) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*State)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *State got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["severity"]; exists {

		vOpts := append(opts, db.WithValidateField("severity"))
		if err := fv(ctx, m.GetSeverity(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["text"]; exists {

		vOpts := append(opts, db.WithValidateField("text"))
		if err := fv(ctx, m.GetText(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["time_created"]; exists {

		vOpts := append(opts, db.WithValidateField("time_created"))
		if err := fv(ctx, m.GetTimeCreated(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStateValidator = func() *ValidateState {
	v := &ValidateState{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSeverity := v.SeverityValidationRuleHandler
	rulesSeverity := map[string]string{
		"ves.io.schema.rules.string.in": "[\"f5-alarm-types:EMERGENCY\", \"f5-alarm-types:ALERT\", \"openconfig-alarm-types:CRITICAL\", \"f5-alarm-types:ERROR\", \"openconfig-alarm-types:WARNING\", \"f5-alarm-types:NOTICE\", \"f5-alarm-types:INFO\", \"f5-alarm-types:DEBUG\"]",
	}
	vFn, err = vrhSeverity(rulesSeverity)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for State.severity: %s", err)
		panic(errMsg)
	}
	v.FldValidators["severity"] = vFn

	return v
}()

func StateValidator() db.Validator {
	return DefaultStateValidator
}

// augmented methods on protoc/std generated struct

func (m *Tenants) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Tenants) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Tenants) DeepCopy() *Tenants {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Tenants{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Tenants) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Tenants) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TenantsValidator().Validate(ctx, m, opts...)
}

type ValidateTenants struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTenants) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Tenants)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Tenants got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cpu"]; exists {

		vOpts := append(opts, db.WithValidateField("cpu"))
		for idx, item := range m.GetCpu() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["disk"]; exists {

		vOpts := append(opts, db.WithValidateField("disk"))
		for idx, item := range m.GetDisk() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["memory"]; exists {

		vOpts := append(opts, db.WithValidateField("memory"))
		for idx, item := range m.GetMemory() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTenantsValidator = func() *ValidateTenants {
	v := &ValidateTenants{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func TenantsValidator() db.Validator {
	return DefaultTenantsValidator
}
