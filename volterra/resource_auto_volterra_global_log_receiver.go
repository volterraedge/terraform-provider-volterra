//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-tf-provider. DO NOT EDIT.
//

package volterra

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"gopkg.volterra.us/stdlib/client/vesapi"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_global_log_receiver "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/global_log_receiver"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
)

// resourceVolterraGlobalLogReceiver is implementation of Volterra's GlobalLogReceiver resources
func resourceVolterraGlobalLogReceiver() *schema.Resource {
	return &schema.Resource{
		Create: resourceVolterraGlobalLogReceiverCreate,
		Read:   resourceVolterraGlobalLogReceiverRead,
		Update: resourceVolterraGlobalLogReceiverUpdate,
		Delete: resourceVolterraGlobalLogReceiverDelete,

		Schema: map[string]*schema.Schema{

			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"description": {
				Type:     schema.TypeString,
				Optional: true,
			},

			"disable": {
				Type:     schema.TypeBool,
				Optional: true,
			},

			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"namespace": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"ns_all": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"ns_current": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"ns_list": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"namespaces": {

							Type: schema.TypeList,

							Required: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},

			"ns_system": {

				Type:       schema.TypeBool,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
			},

			"audit_logs": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"dns_logs": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"request_logs": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"security_events": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"aws_cloud_watch_receiver": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"aws_cred": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Required: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"aws_region": {
							Type:     schema.TypeString,
							Required: true,
						},

						"batch": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"max_bytes": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"max_bytes_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"max_events": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"max_events_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"timeout_seconds": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"timeout_seconds_default": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"compression": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"compression_default": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"compression_gzip": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"compression_none": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"group_name": {
							Type:     schema.TypeString,
							Required: true,
						},

						"stream_name": {
							Type:     schema.TypeString,
							Required: true,
						},
					},
				},
			},

			"azure_event_hubs_receiver": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"connection_string": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Required: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"blindfold_secret_info_internal": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"decryption_provider": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"location": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"store_provider": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},

									"secret_encoding_type": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"blindfold_secret_info": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"decryption_provider": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"location": {
													Type:     schema.TypeString,
													Required: true,
												},

												"store_provider": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},

									"clear_secret_info": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"provider": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"url": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"vault_secret_info": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"key": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"location": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"provider": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"secret_encoding": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"version": {
													Type:       schema.TypeInt,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},

									"wingman_secret_info": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},
								},
							},
						},

						"instance": {
							Type:     schema.TypeString,
							Required: true,
						},

						"namespace": {
							Type:     schema.TypeString,
							Required: true,
						},
					},
				},
			},

			"azure_receiver": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"batch": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"max_bytes": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"max_bytes_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"max_events": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"max_events_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"timeout_seconds": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"timeout_seconds_default": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"compression": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"compression_default": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"compression_gzip": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"compression_none": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"connection_string": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Required: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"blindfold_secret_info_internal": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"decryption_provider": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"location": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"store_provider": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},

									"secret_encoding_type": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"blindfold_secret_info": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"decryption_provider": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"location": {
													Type:     schema.TypeString,
													Required: true,
												},

												"store_provider": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},

									"clear_secret_info": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"provider": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"url": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"vault_secret_info": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"key": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"location": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"provider": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"secret_encoding": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"version": {
													Type:       schema.TypeInt,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},

									"wingman_secret_info": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},
								},
							},
						},

						"container_name": {
							Type:     schema.TypeString,
							Required: true,
						},

						"filename_options": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"custom_folder": {

										Type:     schema.TypeString,
										Optional: true,
									},

									"log_type_folder": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"no_folder": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"datadog_receiver": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"batch": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"max_bytes": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"max_bytes_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"max_events": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"max_events_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"timeout_seconds": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"timeout_seconds_default": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"compression": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"compression_default": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"compression_gzip": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"compression_none": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"datadog_api_key": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Required: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"blindfold_secret_info_internal": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"decryption_provider": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"location": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"store_provider": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},

									"secret_encoding_type": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"blindfold_secret_info": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"decryption_provider": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"location": {
													Type:     schema.TypeString,
													Required: true,
												},

												"store_provider": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},

									"clear_secret_info": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"provider": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"url": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"vault_secret_info": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"key": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"location": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"provider": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"secret_encoding": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"version": {
													Type:       schema.TypeInt,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},

									"wingman_secret_info": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},
								},
							},
						},

						"endpoint": {

							Type:     schema.TypeString,
							Optional: true,
						},

						"site": {

							Type:     schema.TypeString,
							Optional: true,
						},

						"no_tls": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"use_tls": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"no_ca": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"trusted_ca_url": {

										Type:     schema.TypeString,
										Optional: true,
									},

									"mtls_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"mtls_enable": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"certificate": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"key_url": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"blindfold_secret_info_internal": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"decryption_provider": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"location": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"store_provider": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"secret_encoding_type": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"blindfold_secret_info": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"decryption_provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"location": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"store_provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"clear_secret_info": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"url": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																	},
																},
															},

															"vault_secret_info": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"key": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"location": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"provider": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"secret_encoding": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"version": {
																			Type:       schema.TypeInt,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"wingman_secret_info": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},

									"disable_verify_certificate": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"enable_verify_certificate": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"disable_verify_hostname": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"enable_verify_hostname": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"elastic_receiver": {

				Type:       schema.TypeList,
				MaxItems:   1,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"auth_aws": {

							Type:       schema.TypeList,
							MaxItems:   1,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
									"namespace": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
									"tenant": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
								},
							},
						},

						"auth_basic": {

							Type:       schema.TypeList,
							MaxItems:   1,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"password": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"blindfold_secret_info_internal": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"decryption_provider": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"location": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"store_provider": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},

												"secret_encoding_type": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"blindfold_secret_info": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"decryption_provider": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"location": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"store_provider": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},

												"clear_secret_info": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"provider": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"url": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},

												"vault_secret_info": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"key": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"location": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"provider": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"secret_encoding": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"version": {
																Type:       schema.TypeInt,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},

												"wingman_secret_info": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"name": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},
											},
										},
									},

									"user_name": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
								},
							},
						},

						"auth_none": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"batch": {

							Type:       schema.TypeList,
							MaxItems:   1,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"max_bytes": {

										Type:       schema.TypeInt,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"max_bytes_disabled": {

										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"max_events": {

										Type:       schema.TypeInt,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"max_events_disabled": {

										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"timeout_seconds": {

										Type:       schema.TypeInt,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"timeout_seconds_default": {

										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
								},
							},
						},

						"compression": {

							Type:       schema.TypeList,
							MaxItems:   1,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"compression_default": {

										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"compression_gzip": {

										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"compression_none": {

										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
								},
							},
						},

						"endpoint": {
							Type:       schema.TypeString,
							Required:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"no_tls": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"use_tls": {

							Type:       schema.TypeList,
							MaxItems:   1,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"no_ca": {

										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"trusted_ca_url": {

										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"mtls_disabled": {

										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"mtls_enable": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"certificate": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"key_url": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"blindfold_secret_info_internal": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"decryption_provider": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"location": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"store_provider": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"secret_encoding_type": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"blindfold_secret_info": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"decryption_provider": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"location": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"store_provider": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"clear_secret_info": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"provider": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"url": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"vault_secret_info": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"key": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"location": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"provider": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"secret_encoding": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"version": {
																			Type:       schema.TypeInt,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"wingman_secret_info": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},

									"disable_verify_certificate": {

										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"enable_verify_certificate": {

										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"disable_verify_hostname": {

										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"enable_verify_hostname": {

										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
								},
							},
						},
					},
				},
			},

			"gcp_bucket_receiver": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"batch": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"max_bytes": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"max_bytes_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"max_events": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"max_events_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"timeout_seconds": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"timeout_seconds_default": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"bucket": {
							Type:     schema.TypeString,
							Required: true,
						},

						"compression": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"compression_default": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"compression_gzip": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"compression_none": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"filename_options": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"custom_folder": {

										Type:     schema.TypeString,
										Optional: true,
									},

									"log_type_folder": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"no_folder": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"gcp_cred": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Required: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"http_receiver": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"auth_basic": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"password": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"blindfold_secret_info_internal": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"decryption_provider": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"location": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"store_provider": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},

												"secret_encoding_type": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"blindfold_secret_info": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"decryption_provider": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"location": {
																Type:     schema.TypeString,
																Required: true,
															},

															"store_provider": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"clear_secret_info": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"provider": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"url": {
																Type:     schema.TypeString,
																Required: true,
															},
														},
													},
												},

												"vault_secret_info": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"key": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"location": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"provider": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"secret_encoding": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"version": {
																Type:       schema.TypeInt,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},

												"wingman_secret_info": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"name": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},
											},
										},
									},

									"user_name": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"auth_none": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"auth_token": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"token": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"blindfold_secret_info_internal": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"decryption_provider": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"location": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"store_provider": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},

												"secret_encoding_type": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"blindfold_secret_info": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"decryption_provider": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"location": {
																Type:     schema.TypeString,
																Required: true,
															},

															"store_provider": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"clear_secret_info": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"provider": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"url": {
																Type:     schema.TypeString,
																Required: true,
															},
														},
													},
												},

												"vault_secret_info": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"key": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"location": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"provider": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"secret_encoding": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"version": {
																Type:       schema.TypeInt,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},

												"wingman_secret_info": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"name": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"batch": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"max_bytes": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"max_bytes_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"max_events": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"max_events_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"timeout_seconds": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"timeout_seconds_default": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"compression": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"compression_default": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"compression_gzip": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"compression_none": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"no_tls": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"use_tls": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"no_ca": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"trusted_ca_url": {

										Type:     schema.TypeString,
										Optional: true,
									},

									"mtls_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"mtls_enable": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"certificate": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"key_url": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"blindfold_secret_info_internal": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"decryption_provider": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"location": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"store_provider": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"secret_encoding_type": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"blindfold_secret_info": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"decryption_provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"location": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"store_provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"clear_secret_info": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"url": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																	},
																},
															},

															"vault_secret_info": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"key": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"location": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"provider": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"secret_encoding": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"version": {
																			Type:       schema.TypeInt,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"wingman_secret_info": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},

									"disable_verify_certificate": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"enable_verify_certificate": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"disable_verify_hostname": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"enable_verify_hostname": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"uri": {
							Type:     schema.TypeString,
							Required: true,
						},
					},
				},
			},

			"kafka_receiver": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"batch": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"max_bytes": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"max_bytes_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"max_events": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"max_events_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"timeout_seconds": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"timeout_seconds_default": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"bootstrap_servers": {

							Type: schema.TypeList,

							Required: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},

						"compression": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"compression_default": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"compression_gzip": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"compression_none": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"kafka_topic": {
							Type:     schema.TypeString,
							Required: true,
						},

						"no_tls": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"use_tls": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"no_ca": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"trusted_ca_url": {

										Type:     schema.TypeString,
										Optional: true,
									},

									"mtls_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"mtls_enable": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"certificate": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"key_url": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"blindfold_secret_info_internal": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"decryption_provider": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"location": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"store_provider": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"secret_encoding_type": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"blindfold_secret_info": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"decryption_provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"location": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"store_provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"clear_secret_info": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"url": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																	},
																},
															},

															"vault_secret_info": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"key": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"location": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"provider": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"secret_encoding": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"version": {
																			Type:       schema.TypeInt,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"wingman_secret_info": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},

									"disable_verify_certificate": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"enable_verify_certificate": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"disable_verify_hostname": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"enable_verify_hostname": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"new_relic_receiver": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"api_key": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Required: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"blindfold_secret_info_internal": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"decryption_provider": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"location": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"store_provider": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},

									"secret_encoding_type": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"blindfold_secret_info": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"decryption_provider": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"location": {
													Type:     schema.TypeString,
													Required: true,
												},

												"store_provider": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},

									"clear_secret_info": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"provider": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"url": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"vault_secret_info": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"key": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"location": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"provider": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"secret_encoding": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"version": {
													Type:       schema.TypeInt,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},

									"wingman_secret_info": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},
								},
							},
						},

						"eu": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"us": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"qradar_receiver": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"batch": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"max_bytes": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"max_bytes_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"max_events": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"max_events_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"timeout_seconds": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"timeout_seconds_default": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"compression": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"compression_default": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"compression_gzip": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"compression_none": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"no_tls": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"use_tls": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"no_ca": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"trusted_ca_url": {

										Type:     schema.TypeString,
										Optional: true,
									},

									"mtls_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"mtls_enable": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"certificate": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"key_url": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"blindfold_secret_info_internal": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"decryption_provider": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"location": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"store_provider": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"secret_encoding_type": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"blindfold_secret_info": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"decryption_provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"location": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"store_provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"clear_secret_info": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"url": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																	},
																},
															},

															"vault_secret_info": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"key": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"location": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"provider": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"secret_encoding": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"version": {
																			Type:       schema.TypeInt,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"wingman_secret_info": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},

									"disable_verify_certificate": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"enable_verify_certificate": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"disable_verify_hostname": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"enable_verify_hostname": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"uri": {
							Type:     schema.TypeString,
							Required: true,
						},
					},
				},
			},

			"s3_receiver": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"aws_cred": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Required: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"aws_region": {
							Type:     schema.TypeString,
							Required: true,
						},

						"batch": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"max_bytes": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"max_bytes_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"max_events": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"max_events_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"timeout_seconds": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"timeout_seconds_default": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"bucket": {
							Type:     schema.TypeString,
							Required: true,
						},

						"compression": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"compression_default": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"compression_gzip": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"compression_none": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"filename_options": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"custom_folder": {

										Type:     schema.TypeString,
										Optional: true,
									},

									"log_type_folder": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"no_folder": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"splunk_receiver": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"batch": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"max_bytes": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"max_bytes_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"max_events": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"max_events_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"timeout_seconds": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"timeout_seconds_default": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"compression": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"compression_default": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"compression_gzip": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"compression_none": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"endpoint": {
							Type:     schema.TypeString,
							Required: true,
						},

						"splunk_hec_token": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Required: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"blindfold_secret_info_internal": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"decryption_provider": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"location": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"store_provider": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},

									"secret_encoding_type": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"blindfold_secret_info": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"decryption_provider": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"location": {
													Type:     schema.TypeString,
													Required: true,
												},

												"store_provider": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},

									"clear_secret_info": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"provider": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"url": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"vault_secret_info": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"key": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"location": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"provider": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"secret_encoding": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"version": {
													Type:       schema.TypeInt,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},

									"wingman_secret_info": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},
								},
							},
						},

						"no_tls": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"use_tls": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"no_ca": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"trusted_ca_url": {

										Type:     schema.TypeString,
										Optional: true,
									},

									"mtls_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"mtls_enable": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"certificate": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"key_url": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"blindfold_secret_info_internal": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"decryption_provider": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"location": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"store_provider": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"secret_encoding_type": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"blindfold_secret_info": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"decryption_provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"location": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"store_provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"clear_secret_info": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"url": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																	},
																},
															},

															"vault_secret_info": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"key": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"location": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"provider": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"secret_encoding": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"version": {
																			Type:       schema.TypeInt,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"wingman_secret_info": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},

									"disable_verify_certificate": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"enable_verify_certificate": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"disable_verify_hostname": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"enable_verify_hostname": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"sumo_logic_receiver": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"url": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Required: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"blindfold_secret_info_internal": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"decryption_provider": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"location": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"store_provider": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},

									"secret_encoding_type": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"blindfold_secret_info": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"decryption_provider": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"location": {
													Type:     schema.TypeString,
													Required: true,
												},

												"store_provider": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},

									"clear_secret_info": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"provider": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"url": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"vault_secret_info": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"key": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"location": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"provider": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"secret_encoding": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"version": {
													Type:       schema.TypeInt,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},

									"wingman_secret_info": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

// resourceVolterraGlobalLogReceiverCreate creates GlobalLogReceiver resource
func resourceVolterraGlobalLogReceiverCreate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	createMeta := &ves_io_schema.ObjectCreateMetaType{}
	createSpec := &ves_io_schema_global_log_receiver.CreateSpecType{}
	createReq := &ves_io_schema_global_log_receiver.CreateRequest{
		Metadata: createMeta,
		Spec:     createSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		createMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		createMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		createMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		createMeta.Namespace =
			v.(string)
	}

	//filter_choice

	filterChoiceTypeFound := false

	if v, ok := d.GetOk("ns_all"); ok && !filterChoiceTypeFound {

		filterChoiceTypeFound = true

		if v.(bool) {
			filterChoiceInt := &ves_io_schema_global_log_receiver.CreateSpecType_NsAll{}
			filterChoiceInt.NsAll = &ves_io_schema.Empty{}
			createSpec.FilterChoice = filterChoiceInt
		}

	}

	if v, ok := d.GetOk("ns_current"); ok && !filterChoiceTypeFound {

		filterChoiceTypeFound = true

		if v.(bool) {
			filterChoiceInt := &ves_io_schema_global_log_receiver.CreateSpecType_NsCurrent{}
			filterChoiceInt.NsCurrent = &ves_io_schema.Empty{}
			createSpec.FilterChoice = filterChoiceInt
		}

	}

	if v, ok := d.GetOk("ns_list"); ok && !isIntfNil(v) && !filterChoiceTypeFound {

		filterChoiceTypeFound = true
		filterChoiceInt := &ves_io_schema_global_log_receiver.CreateSpecType_NsList{}
		filterChoiceInt.NsList = &ves_io_schema_global_log_receiver.NSList{}
		createSpec.FilterChoice = filterChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["namespaces"]; ok && !isIntfNil(v) {

					ls := make([]string, len(v.([]interface{})))
					for i, v := range v.([]interface{}) {
						if v == nil {
							return fmt.Errorf("please provide valid non-empty string value of field namespaces")
						}
						if str, ok := v.(string); ok {
							ls[i] = str
						}
					}
					filterChoiceInt.NsList.Namespaces = ls

				}

			}
		}

	}

	if v, ok := d.GetOk("ns_system"); ok && !filterChoiceTypeFound {

		filterChoiceTypeFound = true

		if v.(bool) {
			filterChoiceInt := &ves_io_schema_global_log_receiver.CreateSpecType_NsSystem{}
			filterChoiceInt.NsSystem = &ves_io_schema.Empty{}
			createSpec.FilterChoice = filterChoiceInt
		}

	}

	//log_type

	logTypeTypeFound := false

	if v, ok := d.GetOk("audit_logs"); ok && !logTypeTypeFound {

		logTypeTypeFound = true

		if v.(bool) {
			logTypeInt := &ves_io_schema_global_log_receiver.CreateSpecType_AuditLogs{}
			logTypeInt.AuditLogs = &ves_io_schema.Empty{}
			createSpec.LogType = logTypeInt
		}

	}

	if v, ok := d.GetOk("dns_logs"); ok && !logTypeTypeFound {

		logTypeTypeFound = true

		if v.(bool) {
			logTypeInt := &ves_io_schema_global_log_receiver.CreateSpecType_DnsLogs{}
			logTypeInt.DnsLogs = &ves_io_schema.Empty{}
			createSpec.LogType = logTypeInt
		}

	}

	if v, ok := d.GetOk("request_logs"); ok && !logTypeTypeFound {

		logTypeTypeFound = true

		if v.(bool) {
			logTypeInt := &ves_io_schema_global_log_receiver.CreateSpecType_RequestLogs{}
			logTypeInt.RequestLogs = &ves_io_schema.Empty{}
			createSpec.LogType = logTypeInt
		}

	}

	if v, ok := d.GetOk("security_events"); ok && !logTypeTypeFound {

		logTypeTypeFound = true

		if v.(bool) {
			logTypeInt := &ves_io_schema_global_log_receiver.CreateSpecType_SecurityEvents{}
			logTypeInt.SecurityEvents = &ves_io_schema.Empty{}
			createSpec.LogType = logTypeInt
		}

	}

	//receiver

	receiverTypeFound := false

	if v, ok := d.GetOk("aws_cloud_watch_receiver"); ok && !isIntfNil(v) && !receiverTypeFound {

		receiverTypeFound = true
		receiverInt := &ves_io_schema_global_log_receiver.CreateSpecType_AwsCloudWatchReceiver{}
		receiverInt.AwsCloudWatchReceiver = &ves_io_schema_global_log_receiver.AWSCloudwatchConfig{}
		createSpec.Receiver = receiverInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["aws_cred"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					awsCredInt := &ves_io_schema_views.ObjectRefType{}
					receiverInt.AwsCloudWatchReceiver.AwsCred = awsCredInt

					for _, set := range sl {
						if set != nil {
							acMapToStrVal := set.(map[string]interface{})
							if val, ok := acMapToStrVal["name"]; ok && !isIntfNil(v) {
								awsCredInt.Name = val.(string)
							}
							if val, ok := acMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								awsCredInt.Namespace = val.(string)
							}

							if val, ok := acMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								awsCredInt.Tenant = val.(string)
							}
						}
					}

				}

				if v, ok := cs["aws_region"]; ok && !isIntfNil(v) {

					receiverInt.AwsCloudWatchReceiver.AwsRegion = v.(string)

				}

				if v, ok := cs["batch"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					batch := &ves_io_schema_global_log_receiver.BatchOptionType{}
					receiverInt.AwsCloudWatchReceiver.Batch = batch
					for _, set := range sl {
						if set != nil {
							batchMapStrToI := set.(map[string]interface{})

							batchBytesTypeFound := false

							if v, ok := batchMapStrToI["max_bytes"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true
								batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytes{}

								batch.BatchBytes = batchBytesInt

								batchBytesInt.MaxBytes = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_bytes_disabled"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true

								if v.(bool) {
									batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytesDisabled{}
									batchBytesInt.MaxBytesDisabled = &ves_io_schema.Empty{}
									batch.BatchBytes = batchBytesInt
								}

							}

							batchEventsTypeFound := false

							if v, ok := batchMapStrToI["max_events"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true
								batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEvents{}

								batch.BatchEvents = batchEventsInt

								batchEventsInt.MaxEvents = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_events_disabled"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true

								if v.(bool) {
									batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEventsDisabled{}
									batchEventsInt.MaxEventsDisabled = &ves_io_schema.Empty{}
									batch.BatchEvents = batchEventsInt
								}

							}

							batchTimeoutTypeFound := false

							if v, ok := batchMapStrToI["timeout_seconds"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true
								batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSeconds{}

								batch.BatchTimeout = batchTimeoutInt

								batchTimeoutInt.TimeoutSeconds = uint64(v.(int))

							}

							if v, ok := batchMapStrToI["timeout_seconds_default"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true

								if v.(bool) {
									batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSecondsDefault{}
									batchTimeoutInt.TimeoutSecondsDefault = &ves_io_schema.Empty{}
									batch.BatchTimeout = batchTimeoutInt
								}

							}

						}
					}

				}

				if v, ok := cs["compression"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					compression := &ves_io_schema_global_log_receiver.CompressionType{}
					receiverInt.AwsCloudWatchReceiver.Compression = compression
					for _, set := range sl {
						if set != nil {
							compressionMapStrToI := set.(map[string]interface{})

							compressionChoiceTypeFound := false

							if v, ok := compressionMapStrToI["compression_default"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionDefault{}
									compressionChoiceInt.CompressionDefault = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_gzip"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionGzip{}
									compressionChoiceInt.CompressionGzip = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_none"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionNone{}
									compressionChoiceInt.CompressionNone = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

						}
					}

				}

				if v, ok := cs["group_name"]; ok && !isIntfNil(v) {

					receiverInt.AwsCloudWatchReceiver.GroupName = v.(string)

				}

				if v, ok := cs["stream_name"]; ok && !isIntfNil(v) {

					receiverInt.AwsCloudWatchReceiver.StreamName = v.(string)

				}

			}
		}

	}

	if v, ok := d.GetOk("azure_event_hubs_receiver"); ok && !isIntfNil(v) && !receiverTypeFound {

		receiverTypeFound = true
		receiverInt := &ves_io_schema_global_log_receiver.CreateSpecType_AzureEventHubsReceiver{}
		receiverInt.AzureEventHubsReceiver = &ves_io_schema_global_log_receiver.AzureEventHubsConfig{}
		createSpec.Receiver = receiverInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["connection_string"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					connectionString := &ves_io_schema.SecretType{}
					receiverInt.AzureEventHubsReceiver.ConnectionString = connectionString
					for _, set := range sl {
						if set != nil {
							connectionStringMapStrToI := set.(map[string]interface{})

							if v, ok := connectionStringMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
								connectionString.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
								for _, set := range sl {
									if set != nil {
										blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

										if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.Location = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.StoreProvider = w.(string)
										}

									}
								}

							}

							if v, ok := connectionStringMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

								connectionString.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

							}

							secretInfoOneofTypeFound := false

							if v, ok := connectionStringMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
								secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
								connectionString.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

										}

										if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

										}

									}
								}

							}

							if v, ok := connectionStringMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
								secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
								connectionString.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["url"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

										}

									}
								}

							}

							if v, ok := connectionStringMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
								secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
								connectionString.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["key"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

										}

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										if v, ok := cs["version"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

										}

									}
								}

							}

							if v, ok := connectionStringMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
								secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
								connectionString.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["name"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["instance"]; ok && !isIntfNil(v) {

					receiverInt.AzureEventHubsReceiver.Instance = v.(string)

				}

				if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

					receiverInt.AzureEventHubsReceiver.Namespace = v.(string)

				}

			}
		}

	}

	if v, ok := d.GetOk("azure_receiver"); ok && !isIntfNil(v) && !receiverTypeFound {

		receiverTypeFound = true
		receiverInt := &ves_io_schema_global_log_receiver.CreateSpecType_AzureReceiver{}
		receiverInt.AzureReceiver = &ves_io_schema_global_log_receiver.AzureBlobConfig{}
		createSpec.Receiver = receiverInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["batch"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					batch := &ves_io_schema_global_log_receiver.BatchOptionType{}
					receiverInt.AzureReceiver.Batch = batch
					for _, set := range sl {
						if set != nil {
							batchMapStrToI := set.(map[string]interface{})

							batchBytesTypeFound := false

							if v, ok := batchMapStrToI["max_bytes"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true
								batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytes{}

								batch.BatchBytes = batchBytesInt

								batchBytesInt.MaxBytes = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_bytes_disabled"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true

								if v.(bool) {
									batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytesDisabled{}
									batchBytesInt.MaxBytesDisabled = &ves_io_schema.Empty{}
									batch.BatchBytes = batchBytesInt
								}

							}

							batchEventsTypeFound := false

							if v, ok := batchMapStrToI["max_events"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true
								batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEvents{}

								batch.BatchEvents = batchEventsInt

								batchEventsInt.MaxEvents = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_events_disabled"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true

								if v.(bool) {
									batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEventsDisabled{}
									batchEventsInt.MaxEventsDisabled = &ves_io_schema.Empty{}
									batch.BatchEvents = batchEventsInt
								}

							}

							batchTimeoutTypeFound := false

							if v, ok := batchMapStrToI["timeout_seconds"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true
								batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSeconds{}

								batch.BatchTimeout = batchTimeoutInt

								batchTimeoutInt.TimeoutSeconds = uint64(v.(int))

							}

							if v, ok := batchMapStrToI["timeout_seconds_default"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true

								if v.(bool) {
									batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSecondsDefault{}
									batchTimeoutInt.TimeoutSecondsDefault = &ves_io_schema.Empty{}
									batch.BatchTimeout = batchTimeoutInt
								}

							}

						}
					}

				}

				if v, ok := cs["compression"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					compression := &ves_io_schema_global_log_receiver.CompressionType{}
					receiverInt.AzureReceiver.Compression = compression
					for _, set := range sl {
						if set != nil {
							compressionMapStrToI := set.(map[string]interface{})

							compressionChoiceTypeFound := false

							if v, ok := compressionMapStrToI["compression_default"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionDefault{}
									compressionChoiceInt.CompressionDefault = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_gzip"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionGzip{}
									compressionChoiceInt.CompressionGzip = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_none"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionNone{}
									compressionChoiceInt.CompressionNone = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

						}
					}

				}

				if v, ok := cs["connection_string"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					connectionString := &ves_io_schema.SecretType{}
					receiverInt.AzureReceiver.ConnectionString = connectionString
					for _, set := range sl {
						if set != nil {
							connectionStringMapStrToI := set.(map[string]interface{})

							if v, ok := connectionStringMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
								connectionString.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
								for _, set := range sl {
									if set != nil {
										blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

										if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.Location = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.StoreProvider = w.(string)
										}

									}
								}

							}

							if v, ok := connectionStringMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

								connectionString.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

							}

							secretInfoOneofTypeFound := false

							if v, ok := connectionStringMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
								secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
								connectionString.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

										}

										if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

										}

									}
								}

							}

							if v, ok := connectionStringMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
								secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
								connectionString.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["url"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

										}

									}
								}

							}

							if v, ok := connectionStringMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
								secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
								connectionString.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["key"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

										}

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										if v, ok := cs["version"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

										}

									}
								}

							}

							if v, ok := connectionStringMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
								secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
								connectionString.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["name"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["container_name"]; ok && !isIntfNil(v) {

					receiverInt.AzureReceiver.ContainerName = v.(string)

				}

				if v, ok := cs["filename_options"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					filenameOptions := &ves_io_schema_global_log_receiver.FilenameOptionsType{}
					receiverInt.AzureReceiver.FilenameOptions = filenameOptions
					for _, set := range sl {
						if set != nil {
							filenameOptionsMapStrToI := set.(map[string]interface{})

							folderTypeFound := false

							if v, ok := filenameOptionsMapStrToI["custom_folder"]; ok && !isIntfNil(v) && !folderTypeFound {

								folderTypeFound = true
								folderInt := &ves_io_schema_global_log_receiver.FilenameOptionsType_CustomFolder{}

								filenameOptions.Folder = folderInt

								folderInt.CustomFolder = v.(string)

							}

							if v, ok := filenameOptionsMapStrToI["log_type_folder"]; ok && !isIntfNil(v) && !folderTypeFound {

								folderTypeFound = true

								if v.(bool) {
									folderInt := &ves_io_schema_global_log_receiver.FilenameOptionsType_LogTypeFolder{}
									folderInt.LogTypeFolder = &ves_io_schema.Empty{}
									filenameOptions.Folder = folderInt
								}

							}

							if v, ok := filenameOptionsMapStrToI["no_folder"]; ok && !isIntfNil(v) && !folderTypeFound {

								folderTypeFound = true

								if v.(bool) {
									folderInt := &ves_io_schema_global_log_receiver.FilenameOptionsType_NoFolder{}
									folderInt.NoFolder = &ves_io_schema.Empty{}
									filenameOptions.Folder = folderInt
								}

							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("datadog_receiver"); ok && !isIntfNil(v) && !receiverTypeFound {

		receiverTypeFound = true
		receiverInt := &ves_io_schema_global_log_receiver.CreateSpecType_DatadogReceiver{}
		receiverInt.DatadogReceiver = &ves_io_schema_global_log_receiver.DatadogConfig{}
		createSpec.Receiver = receiverInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["batch"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					batch := &ves_io_schema_global_log_receiver.BatchOptionType{}
					receiverInt.DatadogReceiver.Batch = batch
					for _, set := range sl {
						if set != nil {
							batchMapStrToI := set.(map[string]interface{})

							batchBytesTypeFound := false

							if v, ok := batchMapStrToI["max_bytes"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true
								batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytes{}

								batch.BatchBytes = batchBytesInt

								batchBytesInt.MaxBytes = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_bytes_disabled"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true

								if v.(bool) {
									batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytesDisabled{}
									batchBytesInt.MaxBytesDisabled = &ves_io_schema.Empty{}
									batch.BatchBytes = batchBytesInt
								}

							}

							batchEventsTypeFound := false

							if v, ok := batchMapStrToI["max_events"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true
								batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEvents{}

								batch.BatchEvents = batchEventsInt

								batchEventsInt.MaxEvents = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_events_disabled"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true

								if v.(bool) {
									batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEventsDisabled{}
									batchEventsInt.MaxEventsDisabled = &ves_io_schema.Empty{}
									batch.BatchEvents = batchEventsInt
								}

							}

							batchTimeoutTypeFound := false

							if v, ok := batchMapStrToI["timeout_seconds"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true
								batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSeconds{}

								batch.BatchTimeout = batchTimeoutInt

								batchTimeoutInt.TimeoutSeconds = uint64(v.(int))

							}

							if v, ok := batchMapStrToI["timeout_seconds_default"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true

								if v.(bool) {
									batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSecondsDefault{}
									batchTimeoutInt.TimeoutSecondsDefault = &ves_io_schema.Empty{}
									batch.BatchTimeout = batchTimeoutInt
								}

							}

						}
					}

				}

				if v, ok := cs["compression"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					compression := &ves_io_schema_global_log_receiver.CompressionType{}
					receiverInt.DatadogReceiver.Compression = compression
					for _, set := range sl {
						if set != nil {
							compressionMapStrToI := set.(map[string]interface{})

							compressionChoiceTypeFound := false

							if v, ok := compressionMapStrToI["compression_default"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionDefault{}
									compressionChoiceInt.CompressionDefault = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_gzip"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionGzip{}
									compressionChoiceInt.CompressionGzip = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_none"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionNone{}
									compressionChoiceInt.CompressionNone = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

						}
					}

				}

				if v, ok := cs["datadog_api_key"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					datadogApiKey := &ves_io_schema.SecretType{}
					receiverInt.DatadogReceiver.DatadogApiKey = datadogApiKey
					for _, set := range sl {
						if set != nil {
							datadogApiKeyMapStrToI := set.(map[string]interface{})

							if v, ok := datadogApiKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
								datadogApiKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
								for _, set := range sl {
									if set != nil {
										blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

										if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.Location = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.StoreProvider = w.(string)
										}

									}
								}

							}

							if v, ok := datadogApiKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

								datadogApiKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

							}

							secretInfoOneofTypeFound := false

							if v, ok := datadogApiKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
								secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
								datadogApiKey.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

										}

										if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

										}

									}
								}

							}

							if v, ok := datadogApiKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
								secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
								datadogApiKey.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["url"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

										}

									}
								}

							}

							if v, ok := datadogApiKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
								secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
								datadogApiKey.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["key"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

										}

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										if v, ok := cs["version"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

										}

									}
								}

							}

							if v, ok := datadogApiKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
								secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
								datadogApiKey.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["name"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

										}

									}
								}

							}

						}
					}

				}

				endpointChoiceTypeFound := false

				if v, ok := cs["endpoint"]; ok && !isIntfNil(v) && !endpointChoiceTypeFound {

					endpointChoiceTypeFound = true
					endpointChoiceInt := &ves_io_schema_global_log_receiver.DatadogConfig_Endpoint{}

					receiverInt.DatadogReceiver.EndpointChoice = endpointChoiceInt

					endpointChoiceInt.Endpoint = v.(string)

				}

				if v, ok := cs["site"]; ok && !isIntfNil(v) && !endpointChoiceTypeFound {

					endpointChoiceTypeFound = true
					endpointChoiceInt := &ves_io_schema_global_log_receiver.DatadogConfig_Site{}

					receiverInt.DatadogReceiver.EndpointChoice = endpointChoiceInt

					endpointChoiceInt.Site = v.(string)

				}

				tlsChoiceTypeFound := false

				if v, ok := cs["no_tls"]; ok && !isIntfNil(v) && !tlsChoiceTypeFound {

					tlsChoiceTypeFound = true

					if v.(bool) {
						tlsChoiceInt := &ves_io_schema_global_log_receiver.DatadogConfig_NoTls{}
						tlsChoiceInt.NoTls = &ves_io_schema.Empty{}
						receiverInt.DatadogReceiver.TlsChoice = tlsChoiceInt
					}

				}

				if v, ok := cs["use_tls"]; ok && !isIntfNil(v) && !tlsChoiceTypeFound {

					tlsChoiceTypeFound = true
					tlsChoiceInt := &ves_io_schema_global_log_receiver.DatadogConfig_UseTls{}
					tlsChoiceInt.UseTls = &ves_io_schema_global_log_receiver.TLSConfigType{}
					receiverInt.DatadogReceiver.TlsChoice = tlsChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							caChoiceTypeFound := false

							if v, ok := cs["no_ca"]; ok && !isIntfNil(v) && !caChoiceTypeFound {

								caChoiceTypeFound = true

								if v.(bool) {
									caChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_NoCa{}
									caChoiceInt.NoCa = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.CaChoice = caChoiceInt
								}

							}

							if v, ok := cs["trusted_ca_url"]; ok && !isIntfNil(v) && !caChoiceTypeFound {

								caChoiceTypeFound = true
								caChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_TrustedCaUrl{}

								tlsChoiceInt.UseTls.CaChoice = caChoiceInt

								caChoiceInt.TrustedCaUrl = v.(string)

							}

							mtlsChoiceTypeFound := false

							if v, ok := cs["mtls_disabled"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

								mtlsChoiceTypeFound = true

								if v.(bool) {
									mtlsChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_MtlsDisabled{}
									mtlsChoiceInt.MtlsDisabled = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt
								}

							}

							if v, ok := cs["mtls_enable"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

								mtlsChoiceTypeFound = true
								mtlsChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_MtlsEnable{}
								mtlsChoiceInt.MtlsEnable = &ves_io_schema_global_log_receiver.TLSClientConfigType{}
								tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["certificate"]; ok && !isIntfNil(v) {

											mtlsChoiceInt.MtlsEnable.Certificate = v.(string)

										}

										if v, ok := cs["key_url"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											keyUrl := &ves_io_schema.SecretType{}
											mtlsChoiceInt.MtlsEnable.KeyUrl = keyUrl
											for _, set := range sl {
												if set != nil {
													keyUrlMapStrToI := set.(map[string]interface{})

													if v, ok := keyUrlMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
														keyUrl.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
														for _, set := range sl {
															if set != nil {
																blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.Location = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.StoreProvider = w.(string)
																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

														keyUrl.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													secretInfoOneofTypeFound := false

													if v, ok := keyUrlMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
														secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																}

																if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
														secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["url"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
														secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["key"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																}

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																}

																if v, ok := cs["version"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
														secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																}

															}
														}

													}

												}
											}

										}

									}
								}

							}

							verifyCertificateTypeFound := false

							if v, ok := cs["disable_verify_certificate"]; ok && !isIntfNil(v) && !verifyCertificateTypeFound {

								verifyCertificateTypeFound = true

								if v.(bool) {
									verifyCertificateInt := &ves_io_schema_global_log_receiver.TLSConfigType_DisableVerifyCertificate{}
									verifyCertificateInt.DisableVerifyCertificate = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyCertificate = verifyCertificateInt
								}

							}

							if v, ok := cs["enable_verify_certificate"]; ok && !isIntfNil(v) && !verifyCertificateTypeFound {

								verifyCertificateTypeFound = true

								if v.(bool) {
									verifyCertificateInt := &ves_io_schema_global_log_receiver.TLSConfigType_EnableVerifyCertificate{}
									verifyCertificateInt.EnableVerifyCertificate = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyCertificate = verifyCertificateInt
								}

							}

							verifyHostnameTypeFound := false

							if v, ok := cs["disable_verify_hostname"]; ok && !isIntfNil(v) && !verifyHostnameTypeFound {

								verifyHostnameTypeFound = true

								if v.(bool) {
									verifyHostnameInt := &ves_io_schema_global_log_receiver.TLSConfigType_DisableVerifyHostname{}
									verifyHostnameInt.DisableVerifyHostname = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyHostname = verifyHostnameInt
								}

							}

							if v, ok := cs["enable_verify_hostname"]; ok && !isIntfNil(v) && !verifyHostnameTypeFound {

								verifyHostnameTypeFound = true

								if v.(bool) {
									verifyHostnameInt := &ves_io_schema_global_log_receiver.TLSConfigType_EnableVerifyHostname{}
									verifyHostnameInt.EnableVerifyHostname = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyHostname = verifyHostnameInt
								}

							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("elastic_receiver"); ok && !isIntfNil(v) && !receiverTypeFound {

		receiverTypeFound = true
		receiverInt := &ves_io_schema_global_log_receiver.CreateSpecType_ElasticReceiver{}
		receiverInt.ElasticReceiver = &ves_io_schema_global_log_receiver.ElasticConfig{}
		createSpec.Receiver = receiverInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				authChoiceTypeFound := false

				if v, ok := cs["auth_aws"]; ok && !isIntfNil(v) && !authChoiceTypeFound {

					authChoiceTypeFound = true
					authChoiceInt := &ves_io_schema_global_log_receiver.ElasticConfig_AuthAws{}
					authChoiceInt.AuthAws = &ves_io_schema_views.ObjectRefType{}
					receiverInt.ElasticReceiver.AuthChoice = authChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								authChoiceInt.AuthAws.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								authChoiceInt.AuthAws.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								authChoiceInt.AuthAws.Tenant = v.(string)

							}

						}
					}

				}

				if v, ok := cs["auth_basic"]; ok && !isIntfNil(v) && !authChoiceTypeFound {

					authChoiceTypeFound = true
					authChoiceInt := &ves_io_schema_global_log_receiver.ElasticConfig_AuthBasic{}
					authChoiceInt.AuthBasic = &ves_io_schema_global_log_receiver.HttpAuthBasic{}
					receiverInt.ElasticReceiver.AuthChoice = authChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["password"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								password := &ves_io_schema.SecretType{}
								authChoiceInt.AuthBasic.Password = password
								for _, set := range sl {
									if set != nil {
										passwordMapStrToI := set.(map[string]interface{})

										if v, ok := passwordMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
											password.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
											for _, set := range sl {
												if set != nil {
													blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

													if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.Location = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.StoreProvider = w.(string)
													}

												}
											}

										}

										if v, ok := passwordMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

											password.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										secretInfoOneofTypeFound := false

										if v, ok := passwordMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
											secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
											password.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

													}

													if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

													}

												}
											}

										}

										if v, ok := passwordMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
											secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
											password.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["url"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

													}

												}
											}

										}

										if v, ok := passwordMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
											secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
											password.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["key"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

													}

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													if v, ok := cs["version"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

													}

												}
											}

										}

										if v, ok := passwordMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
											secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
											password.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if v, ok := cs["user_name"]; ok && !isIntfNil(v) {

								authChoiceInt.AuthBasic.UserName = v.(string)

							}

						}
					}

				}

				if v, ok := cs["auth_none"]; ok && !isIntfNil(v) && !authChoiceTypeFound {

					authChoiceTypeFound = true

					if v.(bool) {
						authChoiceInt := &ves_io_schema_global_log_receiver.ElasticConfig_AuthNone{}
						authChoiceInt.AuthNone = &ves_io_schema.Empty{}
						receiverInt.ElasticReceiver.AuthChoice = authChoiceInt
					}

				}

				if v, ok := cs["batch"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					batch := &ves_io_schema_global_log_receiver.BatchOptionType{}
					receiverInt.ElasticReceiver.Batch = batch
					for _, set := range sl {
						if set != nil {
							batchMapStrToI := set.(map[string]interface{})

							batchBytesTypeFound := false

							if v, ok := batchMapStrToI["max_bytes"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true
								batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytes{}

								batch.BatchBytes = batchBytesInt

								batchBytesInt.MaxBytes = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_bytes_disabled"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true

								if v.(bool) {
									batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytesDisabled{}
									batchBytesInt.MaxBytesDisabled = &ves_io_schema.Empty{}
									batch.BatchBytes = batchBytesInt
								}

							}

							batchEventsTypeFound := false

							if v, ok := batchMapStrToI["max_events"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true
								batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEvents{}

								batch.BatchEvents = batchEventsInt

								batchEventsInt.MaxEvents = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_events_disabled"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true

								if v.(bool) {
									batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEventsDisabled{}
									batchEventsInt.MaxEventsDisabled = &ves_io_schema.Empty{}
									batch.BatchEvents = batchEventsInt
								}

							}

							batchTimeoutTypeFound := false

							if v, ok := batchMapStrToI["timeout_seconds"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true
								batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSeconds{}

								batch.BatchTimeout = batchTimeoutInt

								batchTimeoutInt.TimeoutSeconds = uint64(v.(int))

							}

							if v, ok := batchMapStrToI["timeout_seconds_default"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true

								if v.(bool) {
									batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSecondsDefault{}
									batchTimeoutInt.TimeoutSecondsDefault = &ves_io_schema.Empty{}
									batch.BatchTimeout = batchTimeoutInt
								}

							}

						}
					}

				}

				if v, ok := cs["compression"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					compression := &ves_io_schema_global_log_receiver.CompressionType{}
					receiverInt.ElasticReceiver.Compression = compression
					for _, set := range sl {
						if set != nil {
							compressionMapStrToI := set.(map[string]interface{})

							compressionChoiceTypeFound := false

							if v, ok := compressionMapStrToI["compression_default"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionDefault{}
									compressionChoiceInt.CompressionDefault = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_gzip"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionGzip{}
									compressionChoiceInt.CompressionGzip = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_none"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionNone{}
									compressionChoiceInt.CompressionNone = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

						}
					}

				}

				if v, ok := cs["endpoint"]; ok && !isIntfNil(v) {

					receiverInt.ElasticReceiver.Endpoint = v.(string)

				}

				tlsChoiceTypeFound := false

				if v, ok := cs["no_tls"]; ok && !isIntfNil(v) && !tlsChoiceTypeFound {

					tlsChoiceTypeFound = true

					if v.(bool) {
						tlsChoiceInt := &ves_io_schema_global_log_receiver.ElasticConfig_NoTls{}
						tlsChoiceInt.NoTls = &ves_io_schema.Empty{}
						receiverInt.ElasticReceiver.TlsChoice = tlsChoiceInt
					}

				}

				if v, ok := cs["use_tls"]; ok && !isIntfNil(v) && !tlsChoiceTypeFound {

					tlsChoiceTypeFound = true
					tlsChoiceInt := &ves_io_schema_global_log_receiver.ElasticConfig_UseTls{}
					tlsChoiceInt.UseTls = &ves_io_schema_global_log_receiver.TLSConfigType{}
					receiverInt.ElasticReceiver.TlsChoice = tlsChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							caChoiceTypeFound := false

							if v, ok := cs["no_ca"]; ok && !isIntfNil(v) && !caChoiceTypeFound {

								caChoiceTypeFound = true

								if v.(bool) {
									caChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_NoCa{}
									caChoiceInt.NoCa = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.CaChoice = caChoiceInt
								}

							}

							if v, ok := cs["trusted_ca_url"]; ok && !isIntfNil(v) && !caChoiceTypeFound {

								caChoiceTypeFound = true
								caChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_TrustedCaUrl{}

								tlsChoiceInt.UseTls.CaChoice = caChoiceInt

								caChoiceInt.TrustedCaUrl = v.(string)

							}

							mtlsChoiceTypeFound := false

							if v, ok := cs["mtls_disabled"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

								mtlsChoiceTypeFound = true

								if v.(bool) {
									mtlsChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_MtlsDisabled{}
									mtlsChoiceInt.MtlsDisabled = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt
								}

							}

							if v, ok := cs["mtls_enable"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

								mtlsChoiceTypeFound = true
								mtlsChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_MtlsEnable{}
								mtlsChoiceInt.MtlsEnable = &ves_io_schema_global_log_receiver.TLSClientConfigType{}
								tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["certificate"]; ok && !isIntfNil(v) {

											mtlsChoiceInt.MtlsEnable.Certificate = v.(string)

										}

										if v, ok := cs["key_url"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											keyUrl := &ves_io_schema.SecretType{}
											mtlsChoiceInt.MtlsEnable.KeyUrl = keyUrl
											for _, set := range sl {
												if set != nil {
													keyUrlMapStrToI := set.(map[string]interface{})

													if v, ok := keyUrlMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
														keyUrl.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
														for _, set := range sl {
															if set != nil {
																blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.Location = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.StoreProvider = w.(string)
																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

														keyUrl.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													secretInfoOneofTypeFound := false

													if v, ok := keyUrlMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
														secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																}

																if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
														secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["url"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
														secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["key"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																}

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																}

																if v, ok := cs["version"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
														secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																}

															}
														}

													}

												}
											}

										}

									}
								}

							}

							verifyCertificateTypeFound := false

							if v, ok := cs["disable_verify_certificate"]; ok && !isIntfNil(v) && !verifyCertificateTypeFound {

								verifyCertificateTypeFound = true

								if v.(bool) {
									verifyCertificateInt := &ves_io_schema_global_log_receiver.TLSConfigType_DisableVerifyCertificate{}
									verifyCertificateInt.DisableVerifyCertificate = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyCertificate = verifyCertificateInt
								}

							}

							if v, ok := cs["enable_verify_certificate"]; ok && !isIntfNil(v) && !verifyCertificateTypeFound {

								verifyCertificateTypeFound = true

								if v.(bool) {
									verifyCertificateInt := &ves_io_schema_global_log_receiver.TLSConfigType_EnableVerifyCertificate{}
									verifyCertificateInt.EnableVerifyCertificate = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyCertificate = verifyCertificateInt
								}

							}

							verifyHostnameTypeFound := false

							if v, ok := cs["disable_verify_hostname"]; ok && !isIntfNil(v) && !verifyHostnameTypeFound {

								verifyHostnameTypeFound = true

								if v.(bool) {
									verifyHostnameInt := &ves_io_schema_global_log_receiver.TLSConfigType_DisableVerifyHostname{}
									verifyHostnameInt.DisableVerifyHostname = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyHostname = verifyHostnameInt
								}

							}

							if v, ok := cs["enable_verify_hostname"]; ok && !isIntfNil(v) && !verifyHostnameTypeFound {

								verifyHostnameTypeFound = true

								if v.(bool) {
									verifyHostnameInt := &ves_io_schema_global_log_receiver.TLSConfigType_EnableVerifyHostname{}
									verifyHostnameInt.EnableVerifyHostname = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyHostname = verifyHostnameInt
								}

							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("gcp_bucket_receiver"); ok && !isIntfNil(v) && !receiverTypeFound {

		receiverTypeFound = true
		receiverInt := &ves_io_schema_global_log_receiver.CreateSpecType_GcpBucketReceiver{}
		receiverInt.GcpBucketReceiver = &ves_io_schema_global_log_receiver.GCPBucketConfig{}
		createSpec.Receiver = receiverInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["batch"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					batch := &ves_io_schema_global_log_receiver.BatchOptionType{}
					receiverInt.GcpBucketReceiver.Batch = batch
					for _, set := range sl {
						if set != nil {
							batchMapStrToI := set.(map[string]interface{})

							batchBytesTypeFound := false

							if v, ok := batchMapStrToI["max_bytes"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true
								batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytes{}

								batch.BatchBytes = batchBytesInt

								batchBytesInt.MaxBytes = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_bytes_disabled"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true

								if v.(bool) {
									batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytesDisabled{}
									batchBytesInt.MaxBytesDisabled = &ves_io_schema.Empty{}
									batch.BatchBytes = batchBytesInt
								}

							}

							batchEventsTypeFound := false

							if v, ok := batchMapStrToI["max_events"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true
								batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEvents{}

								batch.BatchEvents = batchEventsInt

								batchEventsInt.MaxEvents = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_events_disabled"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true

								if v.(bool) {
									batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEventsDisabled{}
									batchEventsInt.MaxEventsDisabled = &ves_io_schema.Empty{}
									batch.BatchEvents = batchEventsInt
								}

							}

							batchTimeoutTypeFound := false

							if v, ok := batchMapStrToI["timeout_seconds"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true
								batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSeconds{}

								batch.BatchTimeout = batchTimeoutInt

								batchTimeoutInt.TimeoutSeconds = uint64(v.(int))

							}

							if v, ok := batchMapStrToI["timeout_seconds_default"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true

								if v.(bool) {
									batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSecondsDefault{}
									batchTimeoutInt.TimeoutSecondsDefault = &ves_io_schema.Empty{}
									batch.BatchTimeout = batchTimeoutInt
								}

							}

						}
					}

				}

				if v, ok := cs["bucket"]; ok && !isIntfNil(v) {

					receiverInt.GcpBucketReceiver.Bucket = v.(string)

				}

				if v, ok := cs["compression"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					compression := &ves_io_schema_global_log_receiver.CompressionType{}
					receiverInt.GcpBucketReceiver.Compression = compression
					for _, set := range sl {
						if set != nil {
							compressionMapStrToI := set.(map[string]interface{})

							compressionChoiceTypeFound := false

							if v, ok := compressionMapStrToI["compression_default"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionDefault{}
									compressionChoiceInt.CompressionDefault = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_gzip"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionGzip{}
									compressionChoiceInt.CompressionGzip = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_none"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionNone{}
									compressionChoiceInt.CompressionNone = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

						}
					}

				}

				if v, ok := cs["filename_options"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					filenameOptions := &ves_io_schema_global_log_receiver.FilenameOptionsType{}
					receiverInt.GcpBucketReceiver.FilenameOptions = filenameOptions
					for _, set := range sl {
						if set != nil {
							filenameOptionsMapStrToI := set.(map[string]interface{})

							folderTypeFound := false

							if v, ok := filenameOptionsMapStrToI["custom_folder"]; ok && !isIntfNil(v) && !folderTypeFound {

								folderTypeFound = true
								folderInt := &ves_io_schema_global_log_receiver.FilenameOptionsType_CustomFolder{}

								filenameOptions.Folder = folderInt

								folderInt.CustomFolder = v.(string)

							}

							if v, ok := filenameOptionsMapStrToI["log_type_folder"]; ok && !isIntfNil(v) && !folderTypeFound {

								folderTypeFound = true

								if v.(bool) {
									folderInt := &ves_io_schema_global_log_receiver.FilenameOptionsType_LogTypeFolder{}
									folderInt.LogTypeFolder = &ves_io_schema.Empty{}
									filenameOptions.Folder = folderInt
								}

							}

							if v, ok := filenameOptionsMapStrToI["no_folder"]; ok && !isIntfNil(v) && !folderTypeFound {

								folderTypeFound = true

								if v.(bool) {
									folderInt := &ves_io_schema_global_log_receiver.FilenameOptionsType_NoFolder{}
									folderInt.NoFolder = &ves_io_schema.Empty{}
									filenameOptions.Folder = folderInt
								}

							}

						}
					}

				}

				if v, ok := cs["gcp_cred"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					gcpCredInt := &ves_io_schema_views.ObjectRefType{}
					receiverInt.GcpBucketReceiver.GcpCred = gcpCredInt

					for _, set := range sl {
						if set != nil {
							gcMapToStrVal := set.(map[string]interface{})
							if val, ok := gcMapToStrVal["name"]; ok && !isIntfNil(v) {
								gcpCredInt.Name = val.(string)
							}
							if val, ok := gcMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								gcpCredInt.Namespace = val.(string)
							}

							if val, ok := gcMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								gcpCredInt.Tenant = val.(string)
							}
						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("http_receiver"); ok && !isIntfNil(v) && !receiverTypeFound {

		receiverTypeFound = true
		receiverInt := &ves_io_schema_global_log_receiver.CreateSpecType_HttpReceiver{}
		receiverInt.HttpReceiver = &ves_io_schema_global_log_receiver.HTTPConfig{}
		createSpec.Receiver = receiverInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				authChoiceTypeFound := false

				if v, ok := cs["auth_basic"]; ok && !isIntfNil(v) && !authChoiceTypeFound {

					authChoiceTypeFound = true
					authChoiceInt := &ves_io_schema_global_log_receiver.HTTPConfig_AuthBasic{}
					authChoiceInt.AuthBasic = &ves_io_schema_global_log_receiver.HttpAuthBasic{}
					receiverInt.HttpReceiver.AuthChoice = authChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["password"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								password := &ves_io_schema.SecretType{}
								authChoiceInt.AuthBasic.Password = password
								for _, set := range sl {
									if set != nil {
										passwordMapStrToI := set.(map[string]interface{})

										if v, ok := passwordMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
											password.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
											for _, set := range sl {
												if set != nil {
													blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

													if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.Location = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.StoreProvider = w.(string)
													}

												}
											}

										}

										if v, ok := passwordMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

											password.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										secretInfoOneofTypeFound := false

										if v, ok := passwordMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
											secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
											password.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

													}

													if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

													}

												}
											}

										}

										if v, ok := passwordMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
											secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
											password.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["url"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

													}

												}
											}

										}

										if v, ok := passwordMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
											secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
											password.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["key"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

													}

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													if v, ok := cs["version"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

													}

												}
											}

										}

										if v, ok := passwordMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
											secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
											password.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if v, ok := cs["user_name"]; ok && !isIntfNil(v) {

								authChoiceInt.AuthBasic.UserName = v.(string)

							}

						}
					}

				}

				if v, ok := cs["auth_none"]; ok && !isIntfNil(v) && !authChoiceTypeFound {

					authChoiceTypeFound = true

					if v.(bool) {
						authChoiceInt := &ves_io_schema_global_log_receiver.HTTPConfig_AuthNone{}
						authChoiceInt.AuthNone = &ves_io_schema.Empty{}
						receiverInt.HttpReceiver.AuthChoice = authChoiceInt
					}

				}

				if v, ok := cs["auth_token"]; ok && !isIntfNil(v) && !authChoiceTypeFound {

					authChoiceTypeFound = true
					authChoiceInt := &ves_io_schema_global_log_receiver.HTTPConfig_AuthToken{}
					authChoiceInt.AuthToken = &ves_io_schema_global_log_receiver.AuthToken{}
					receiverInt.HttpReceiver.AuthChoice = authChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["token"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								token := &ves_io_schema.SecretType{}
								authChoiceInt.AuthToken.Token = token
								for _, set := range sl {
									if set != nil {
										tokenMapStrToI := set.(map[string]interface{})

										if v, ok := tokenMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
											token.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
											for _, set := range sl {
												if set != nil {
													blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

													if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.Location = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.StoreProvider = w.(string)
													}

												}
											}

										}

										if v, ok := tokenMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

											token.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										secretInfoOneofTypeFound := false

										if v, ok := tokenMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
											secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
											token.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

													}

													if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

													}

												}
											}

										}

										if v, ok := tokenMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
											secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
											token.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["url"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

													}

												}
											}

										}

										if v, ok := tokenMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
											secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
											token.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["key"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

													}

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													if v, ok := cs["version"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

													}

												}
											}

										}

										if v, ok := tokenMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
											secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
											token.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["batch"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					batch := &ves_io_schema_global_log_receiver.BatchOptionType{}
					receiverInt.HttpReceiver.Batch = batch
					for _, set := range sl {
						if set != nil {
							batchMapStrToI := set.(map[string]interface{})

							batchBytesTypeFound := false

							if v, ok := batchMapStrToI["max_bytes"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true
								batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytes{}

								batch.BatchBytes = batchBytesInt

								batchBytesInt.MaxBytes = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_bytes_disabled"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true

								if v.(bool) {
									batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytesDisabled{}
									batchBytesInt.MaxBytesDisabled = &ves_io_schema.Empty{}
									batch.BatchBytes = batchBytesInt
								}

							}

							batchEventsTypeFound := false

							if v, ok := batchMapStrToI["max_events"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true
								batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEvents{}

								batch.BatchEvents = batchEventsInt

								batchEventsInt.MaxEvents = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_events_disabled"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true

								if v.(bool) {
									batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEventsDisabled{}
									batchEventsInt.MaxEventsDisabled = &ves_io_schema.Empty{}
									batch.BatchEvents = batchEventsInt
								}

							}

							batchTimeoutTypeFound := false

							if v, ok := batchMapStrToI["timeout_seconds"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true
								batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSeconds{}

								batch.BatchTimeout = batchTimeoutInt

								batchTimeoutInt.TimeoutSeconds = uint64(v.(int))

							}

							if v, ok := batchMapStrToI["timeout_seconds_default"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true

								if v.(bool) {
									batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSecondsDefault{}
									batchTimeoutInt.TimeoutSecondsDefault = &ves_io_schema.Empty{}
									batch.BatchTimeout = batchTimeoutInt
								}

							}

						}
					}

				}

				if v, ok := cs["compression"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					compression := &ves_io_schema_global_log_receiver.CompressionType{}
					receiverInt.HttpReceiver.Compression = compression
					for _, set := range sl {
						if set != nil {
							compressionMapStrToI := set.(map[string]interface{})

							compressionChoiceTypeFound := false

							if v, ok := compressionMapStrToI["compression_default"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionDefault{}
									compressionChoiceInt.CompressionDefault = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_gzip"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionGzip{}
									compressionChoiceInt.CompressionGzip = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_none"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionNone{}
									compressionChoiceInt.CompressionNone = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

						}
					}

				}

				tlsChoiceTypeFound := false

				if v, ok := cs["no_tls"]; ok && !isIntfNil(v) && !tlsChoiceTypeFound {

					tlsChoiceTypeFound = true

					if v.(bool) {
						tlsChoiceInt := &ves_io_schema_global_log_receiver.HTTPConfig_NoTls{}
						tlsChoiceInt.NoTls = &ves_io_schema.Empty{}
						receiverInt.HttpReceiver.TlsChoice = tlsChoiceInt
					}

				}

				if v, ok := cs["use_tls"]; ok && !isIntfNil(v) && !tlsChoiceTypeFound {

					tlsChoiceTypeFound = true
					tlsChoiceInt := &ves_io_schema_global_log_receiver.HTTPConfig_UseTls{}
					tlsChoiceInt.UseTls = &ves_io_schema_global_log_receiver.TLSConfigType{}
					receiverInt.HttpReceiver.TlsChoice = tlsChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							caChoiceTypeFound := false

							if v, ok := cs["no_ca"]; ok && !isIntfNil(v) && !caChoiceTypeFound {

								caChoiceTypeFound = true

								if v.(bool) {
									caChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_NoCa{}
									caChoiceInt.NoCa = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.CaChoice = caChoiceInt
								}

							}

							if v, ok := cs["trusted_ca_url"]; ok && !isIntfNil(v) && !caChoiceTypeFound {

								caChoiceTypeFound = true
								caChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_TrustedCaUrl{}

								tlsChoiceInt.UseTls.CaChoice = caChoiceInt

								caChoiceInt.TrustedCaUrl = v.(string)

							}

							mtlsChoiceTypeFound := false

							if v, ok := cs["mtls_disabled"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

								mtlsChoiceTypeFound = true

								if v.(bool) {
									mtlsChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_MtlsDisabled{}
									mtlsChoiceInt.MtlsDisabled = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt
								}

							}

							if v, ok := cs["mtls_enable"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

								mtlsChoiceTypeFound = true
								mtlsChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_MtlsEnable{}
								mtlsChoiceInt.MtlsEnable = &ves_io_schema_global_log_receiver.TLSClientConfigType{}
								tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["certificate"]; ok && !isIntfNil(v) {

											mtlsChoiceInt.MtlsEnable.Certificate = v.(string)

										}

										if v, ok := cs["key_url"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											keyUrl := &ves_io_schema.SecretType{}
											mtlsChoiceInt.MtlsEnable.KeyUrl = keyUrl
											for _, set := range sl {
												if set != nil {
													keyUrlMapStrToI := set.(map[string]interface{})

													if v, ok := keyUrlMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
														keyUrl.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
														for _, set := range sl {
															if set != nil {
																blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.Location = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.StoreProvider = w.(string)
																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

														keyUrl.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													secretInfoOneofTypeFound := false

													if v, ok := keyUrlMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
														secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																}

																if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
														secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["url"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
														secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["key"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																}

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																}

																if v, ok := cs["version"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
														secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																}

															}
														}

													}

												}
											}

										}

									}
								}

							}

							verifyCertificateTypeFound := false

							if v, ok := cs["disable_verify_certificate"]; ok && !isIntfNil(v) && !verifyCertificateTypeFound {

								verifyCertificateTypeFound = true

								if v.(bool) {
									verifyCertificateInt := &ves_io_schema_global_log_receiver.TLSConfigType_DisableVerifyCertificate{}
									verifyCertificateInt.DisableVerifyCertificate = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyCertificate = verifyCertificateInt
								}

							}

							if v, ok := cs["enable_verify_certificate"]; ok && !isIntfNil(v) && !verifyCertificateTypeFound {

								verifyCertificateTypeFound = true

								if v.(bool) {
									verifyCertificateInt := &ves_io_schema_global_log_receiver.TLSConfigType_EnableVerifyCertificate{}
									verifyCertificateInt.EnableVerifyCertificate = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyCertificate = verifyCertificateInt
								}

							}

							verifyHostnameTypeFound := false

							if v, ok := cs["disable_verify_hostname"]; ok && !isIntfNil(v) && !verifyHostnameTypeFound {

								verifyHostnameTypeFound = true

								if v.(bool) {
									verifyHostnameInt := &ves_io_schema_global_log_receiver.TLSConfigType_DisableVerifyHostname{}
									verifyHostnameInt.DisableVerifyHostname = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyHostname = verifyHostnameInt
								}

							}

							if v, ok := cs["enable_verify_hostname"]; ok && !isIntfNil(v) && !verifyHostnameTypeFound {

								verifyHostnameTypeFound = true

								if v.(bool) {
									verifyHostnameInt := &ves_io_schema_global_log_receiver.TLSConfigType_EnableVerifyHostname{}
									verifyHostnameInt.EnableVerifyHostname = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyHostname = verifyHostnameInt
								}

							}

						}
					}

				}

				if v, ok := cs["uri"]; ok && !isIntfNil(v) {

					receiverInt.HttpReceiver.Uri = v.(string)

				}

			}
		}

	}

	if v, ok := d.GetOk("kafka_receiver"); ok && !isIntfNil(v) && !receiverTypeFound {

		receiverTypeFound = true
		receiverInt := &ves_io_schema_global_log_receiver.CreateSpecType_KafkaReceiver{}
		receiverInt.KafkaReceiver = &ves_io_schema_global_log_receiver.KafkaConfig{}
		createSpec.Receiver = receiverInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["batch"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					batch := &ves_io_schema_global_log_receiver.BatchOptionType{}
					receiverInt.KafkaReceiver.Batch = batch
					for _, set := range sl {
						if set != nil {
							batchMapStrToI := set.(map[string]interface{})

							batchBytesTypeFound := false

							if v, ok := batchMapStrToI["max_bytes"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true
								batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytes{}

								batch.BatchBytes = batchBytesInt

								batchBytesInt.MaxBytes = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_bytes_disabled"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true

								if v.(bool) {
									batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytesDisabled{}
									batchBytesInt.MaxBytesDisabled = &ves_io_schema.Empty{}
									batch.BatchBytes = batchBytesInt
								}

							}

							batchEventsTypeFound := false

							if v, ok := batchMapStrToI["max_events"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true
								batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEvents{}

								batch.BatchEvents = batchEventsInt

								batchEventsInt.MaxEvents = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_events_disabled"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true

								if v.(bool) {
									batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEventsDisabled{}
									batchEventsInt.MaxEventsDisabled = &ves_io_schema.Empty{}
									batch.BatchEvents = batchEventsInt
								}

							}

							batchTimeoutTypeFound := false

							if v, ok := batchMapStrToI["timeout_seconds"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true
								batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSeconds{}

								batch.BatchTimeout = batchTimeoutInt

								batchTimeoutInt.TimeoutSeconds = uint64(v.(int))

							}

							if v, ok := batchMapStrToI["timeout_seconds_default"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true

								if v.(bool) {
									batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSecondsDefault{}
									batchTimeoutInt.TimeoutSecondsDefault = &ves_io_schema.Empty{}
									batch.BatchTimeout = batchTimeoutInt
								}

							}

						}
					}

				}

				if v, ok := cs["bootstrap_servers"]; ok && !isIntfNil(v) {

					ls := make([]string, len(v.([]interface{})))
					for i, v := range v.([]interface{}) {
						if v == nil {
							return fmt.Errorf("please provide valid non-empty string value of field bootstrap_servers")
						}
						if str, ok := v.(string); ok {
							ls[i] = str
						}
					}
					receiverInt.KafkaReceiver.BootstrapServers = ls

				}

				if v, ok := cs["compression"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					compression := &ves_io_schema_global_log_receiver.CompressionType{}
					receiverInt.KafkaReceiver.Compression = compression
					for _, set := range sl {
						if set != nil {
							compressionMapStrToI := set.(map[string]interface{})

							compressionChoiceTypeFound := false

							if v, ok := compressionMapStrToI["compression_default"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionDefault{}
									compressionChoiceInt.CompressionDefault = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_gzip"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionGzip{}
									compressionChoiceInt.CompressionGzip = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_none"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionNone{}
									compressionChoiceInt.CompressionNone = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

						}
					}

				}

				if v, ok := cs["kafka_topic"]; ok && !isIntfNil(v) {

					receiverInt.KafkaReceiver.KafkaTopic = v.(string)

				}

				tlsChoiceTypeFound := false

				if v, ok := cs["no_tls"]; ok && !isIntfNil(v) && !tlsChoiceTypeFound {

					tlsChoiceTypeFound = true

					if v.(bool) {
						tlsChoiceInt := &ves_io_schema_global_log_receiver.KafkaConfig_NoTls{}
						tlsChoiceInt.NoTls = &ves_io_schema.Empty{}
						receiverInt.KafkaReceiver.TlsChoice = tlsChoiceInt
					}

				}

				if v, ok := cs["use_tls"]; ok && !isIntfNil(v) && !tlsChoiceTypeFound {

					tlsChoiceTypeFound = true
					tlsChoiceInt := &ves_io_schema_global_log_receiver.KafkaConfig_UseTls{}
					tlsChoiceInt.UseTls = &ves_io_schema_global_log_receiver.TLSConfigType{}
					receiverInt.KafkaReceiver.TlsChoice = tlsChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							caChoiceTypeFound := false

							if v, ok := cs["no_ca"]; ok && !isIntfNil(v) && !caChoiceTypeFound {

								caChoiceTypeFound = true

								if v.(bool) {
									caChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_NoCa{}
									caChoiceInt.NoCa = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.CaChoice = caChoiceInt
								}

							}

							if v, ok := cs["trusted_ca_url"]; ok && !isIntfNil(v) && !caChoiceTypeFound {

								caChoiceTypeFound = true
								caChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_TrustedCaUrl{}

								tlsChoiceInt.UseTls.CaChoice = caChoiceInt

								caChoiceInt.TrustedCaUrl = v.(string)

							}

							mtlsChoiceTypeFound := false

							if v, ok := cs["mtls_disabled"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

								mtlsChoiceTypeFound = true

								if v.(bool) {
									mtlsChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_MtlsDisabled{}
									mtlsChoiceInt.MtlsDisabled = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt
								}

							}

							if v, ok := cs["mtls_enable"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

								mtlsChoiceTypeFound = true
								mtlsChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_MtlsEnable{}
								mtlsChoiceInt.MtlsEnable = &ves_io_schema_global_log_receiver.TLSClientConfigType{}
								tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["certificate"]; ok && !isIntfNil(v) {

											mtlsChoiceInt.MtlsEnable.Certificate = v.(string)

										}

										if v, ok := cs["key_url"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											keyUrl := &ves_io_schema.SecretType{}
											mtlsChoiceInt.MtlsEnable.KeyUrl = keyUrl
											for _, set := range sl {
												if set != nil {
													keyUrlMapStrToI := set.(map[string]interface{})

													if v, ok := keyUrlMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
														keyUrl.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
														for _, set := range sl {
															if set != nil {
																blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.Location = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.StoreProvider = w.(string)
																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

														keyUrl.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													secretInfoOneofTypeFound := false

													if v, ok := keyUrlMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
														secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																}

																if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
														secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["url"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
														secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["key"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																}

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																}

																if v, ok := cs["version"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
														secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																}

															}
														}

													}

												}
											}

										}

									}
								}

							}

							verifyCertificateTypeFound := false

							if v, ok := cs["disable_verify_certificate"]; ok && !isIntfNil(v) && !verifyCertificateTypeFound {

								verifyCertificateTypeFound = true

								if v.(bool) {
									verifyCertificateInt := &ves_io_schema_global_log_receiver.TLSConfigType_DisableVerifyCertificate{}
									verifyCertificateInt.DisableVerifyCertificate = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyCertificate = verifyCertificateInt
								}

							}

							if v, ok := cs["enable_verify_certificate"]; ok && !isIntfNil(v) && !verifyCertificateTypeFound {

								verifyCertificateTypeFound = true

								if v.(bool) {
									verifyCertificateInt := &ves_io_schema_global_log_receiver.TLSConfigType_EnableVerifyCertificate{}
									verifyCertificateInt.EnableVerifyCertificate = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyCertificate = verifyCertificateInt
								}

							}

							verifyHostnameTypeFound := false

							if v, ok := cs["disable_verify_hostname"]; ok && !isIntfNil(v) && !verifyHostnameTypeFound {

								verifyHostnameTypeFound = true

								if v.(bool) {
									verifyHostnameInt := &ves_io_schema_global_log_receiver.TLSConfigType_DisableVerifyHostname{}
									verifyHostnameInt.DisableVerifyHostname = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyHostname = verifyHostnameInt
								}

							}

							if v, ok := cs["enable_verify_hostname"]; ok && !isIntfNil(v) && !verifyHostnameTypeFound {

								verifyHostnameTypeFound = true

								if v.(bool) {
									verifyHostnameInt := &ves_io_schema_global_log_receiver.TLSConfigType_EnableVerifyHostname{}
									verifyHostnameInt.EnableVerifyHostname = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyHostname = verifyHostnameInt
								}

							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("new_relic_receiver"); ok && !isIntfNil(v) && !receiverTypeFound {

		receiverTypeFound = true
		receiverInt := &ves_io_schema_global_log_receiver.CreateSpecType_NewRelicReceiver{}
		receiverInt.NewRelicReceiver = &ves_io_schema_global_log_receiver.NewRelicConfig{}
		createSpec.Receiver = receiverInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["api_key"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					apiKey := &ves_io_schema.SecretType{}
					receiverInt.NewRelicReceiver.ApiKey = apiKey
					for _, set := range sl {
						if set != nil {
							apiKeyMapStrToI := set.(map[string]interface{})

							if v, ok := apiKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
								apiKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
								for _, set := range sl {
									if set != nil {
										blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

										if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.Location = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.StoreProvider = w.(string)
										}

									}
								}

							}

							if v, ok := apiKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

								apiKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

							}

							secretInfoOneofTypeFound := false

							if v, ok := apiKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
								secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
								apiKey.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

										}

										if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

										}

									}
								}

							}

							if v, ok := apiKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
								secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
								apiKey.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["url"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

										}

									}
								}

							}

							if v, ok := apiKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
								secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
								apiKey.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["key"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

										}

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										if v, ok := cs["version"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

										}

									}
								}

							}

							if v, ok := apiKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
								secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
								apiKey.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["name"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

										}

									}
								}

							}

						}
					}

				}

				endpointChoiceTypeFound := false

				if v, ok := cs["eu"]; ok && !isIntfNil(v) && !endpointChoiceTypeFound {

					endpointChoiceTypeFound = true

					if v.(bool) {
						endpointChoiceInt := &ves_io_schema_global_log_receiver.NewRelicConfig_Eu{}
						endpointChoiceInt.Eu = &ves_io_schema.Empty{}
						receiverInt.NewRelicReceiver.EndpointChoice = endpointChoiceInt
					}

				}

				if v, ok := cs["us"]; ok && !isIntfNil(v) && !endpointChoiceTypeFound {

					endpointChoiceTypeFound = true

					if v.(bool) {
						endpointChoiceInt := &ves_io_schema_global_log_receiver.NewRelicConfig_Us{}
						endpointChoiceInt.Us = &ves_io_schema.Empty{}
						receiverInt.NewRelicReceiver.EndpointChoice = endpointChoiceInt
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("qradar_receiver"); ok && !isIntfNil(v) && !receiverTypeFound {

		receiverTypeFound = true
		receiverInt := &ves_io_schema_global_log_receiver.CreateSpecType_QradarReceiver{}
		receiverInt.QradarReceiver = &ves_io_schema_global_log_receiver.QRadarConfig{}
		createSpec.Receiver = receiverInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["batch"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					batch := &ves_io_schema_global_log_receiver.BatchOptionType{}
					receiverInt.QradarReceiver.Batch = batch
					for _, set := range sl {
						if set != nil {
							batchMapStrToI := set.(map[string]interface{})

							batchBytesTypeFound := false

							if v, ok := batchMapStrToI["max_bytes"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true
								batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytes{}

								batch.BatchBytes = batchBytesInt

								batchBytesInt.MaxBytes = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_bytes_disabled"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true

								if v.(bool) {
									batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytesDisabled{}
									batchBytesInt.MaxBytesDisabled = &ves_io_schema.Empty{}
									batch.BatchBytes = batchBytesInt
								}

							}

							batchEventsTypeFound := false

							if v, ok := batchMapStrToI["max_events"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true
								batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEvents{}

								batch.BatchEvents = batchEventsInt

								batchEventsInt.MaxEvents = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_events_disabled"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true

								if v.(bool) {
									batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEventsDisabled{}
									batchEventsInt.MaxEventsDisabled = &ves_io_schema.Empty{}
									batch.BatchEvents = batchEventsInt
								}

							}

							batchTimeoutTypeFound := false

							if v, ok := batchMapStrToI["timeout_seconds"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true
								batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSeconds{}

								batch.BatchTimeout = batchTimeoutInt

								batchTimeoutInt.TimeoutSeconds = uint64(v.(int))

							}

							if v, ok := batchMapStrToI["timeout_seconds_default"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true

								if v.(bool) {
									batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSecondsDefault{}
									batchTimeoutInt.TimeoutSecondsDefault = &ves_io_schema.Empty{}
									batch.BatchTimeout = batchTimeoutInt
								}

							}

						}
					}

				}

				if v, ok := cs["compression"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					compression := &ves_io_schema_global_log_receiver.CompressionType{}
					receiverInt.QradarReceiver.Compression = compression
					for _, set := range sl {
						if set != nil {
							compressionMapStrToI := set.(map[string]interface{})

							compressionChoiceTypeFound := false

							if v, ok := compressionMapStrToI["compression_default"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionDefault{}
									compressionChoiceInt.CompressionDefault = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_gzip"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionGzip{}
									compressionChoiceInt.CompressionGzip = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_none"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionNone{}
									compressionChoiceInt.CompressionNone = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

						}
					}

				}

				tlsChoiceTypeFound := false

				if v, ok := cs["no_tls"]; ok && !isIntfNil(v) && !tlsChoiceTypeFound {

					tlsChoiceTypeFound = true

					if v.(bool) {
						tlsChoiceInt := &ves_io_schema_global_log_receiver.QRadarConfig_NoTls{}
						tlsChoiceInt.NoTls = &ves_io_schema.Empty{}
						receiverInt.QradarReceiver.TlsChoice = tlsChoiceInt
					}

				}

				if v, ok := cs["use_tls"]; ok && !isIntfNil(v) && !tlsChoiceTypeFound {

					tlsChoiceTypeFound = true
					tlsChoiceInt := &ves_io_schema_global_log_receiver.QRadarConfig_UseTls{}
					tlsChoiceInt.UseTls = &ves_io_schema_global_log_receiver.TLSConfigType{}
					receiverInt.QradarReceiver.TlsChoice = tlsChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							caChoiceTypeFound := false

							if v, ok := cs["no_ca"]; ok && !isIntfNil(v) && !caChoiceTypeFound {

								caChoiceTypeFound = true

								if v.(bool) {
									caChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_NoCa{}
									caChoiceInt.NoCa = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.CaChoice = caChoiceInt
								}

							}

							if v, ok := cs["trusted_ca_url"]; ok && !isIntfNil(v) && !caChoiceTypeFound {

								caChoiceTypeFound = true
								caChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_TrustedCaUrl{}

								tlsChoiceInt.UseTls.CaChoice = caChoiceInt

								caChoiceInt.TrustedCaUrl = v.(string)

							}

							mtlsChoiceTypeFound := false

							if v, ok := cs["mtls_disabled"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

								mtlsChoiceTypeFound = true

								if v.(bool) {
									mtlsChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_MtlsDisabled{}
									mtlsChoiceInt.MtlsDisabled = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt
								}

							}

							if v, ok := cs["mtls_enable"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

								mtlsChoiceTypeFound = true
								mtlsChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_MtlsEnable{}
								mtlsChoiceInt.MtlsEnable = &ves_io_schema_global_log_receiver.TLSClientConfigType{}
								tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["certificate"]; ok && !isIntfNil(v) {

											mtlsChoiceInt.MtlsEnable.Certificate = v.(string)

										}

										if v, ok := cs["key_url"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											keyUrl := &ves_io_schema.SecretType{}
											mtlsChoiceInt.MtlsEnable.KeyUrl = keyUrl
											for _, set := range sl {
												if set != nil {
													keyUrlMapStrToI := set.(map[string]interface{})

													if v, ok := keyUrlMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
														keyUrl.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
														for _, set := range sl {
															if set != nil {
																blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.Location = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.StoreProvider = w.(string)
																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

														keyUrl.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													secretInfoOneofTypeFound := false

													if v, ok := keyUrlMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
														secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																}

																if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
														secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["url"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
														secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["key"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																}

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																}

																if v, ok := cs["version"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
														secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																}

															}
														}

													}

												}
											}

										}

									}
								}

							}

							verifyCertificateTypeFound := false

							if v, ok := cs["disable_verify_certificate"]; ok && !isIntfNil(v) && !verifyCertificateTypeFound {

								verifyCertificateTypeFound = true

								if v.(bool) {
									verifyCertificateInt := &ves_io_schema_global_log_receiver.TLSConfigType_DisableVerifyCertificate{}
									verifyCertificateInt.DisableVerifyCertificate = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyCertificate = verifyCertificateInt
								}

							}

							if v, ok := cs["enable_verify_certificate"]; ok && !isIntfNil(v) && !verifyCertificateTypeFound {

								verifyCertificateTypeFound = true

								if v.(bool) {
									verifyCertificateInt := &ves_io_schema_global_log_receiver.TLSConfigType_EnableVerifyCertificate{}
									verifyCertificateInt.EnableVerifyCertificate = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyCertificate = verifyCertificateInt
								}

							}

							verifyHostnameTypeFound := false

							if v, ok := cs["disable_verify_hostname"]; ok && !isIntfNil(v) && !verifyHostnameTypeFound {

								verifyHostnameTypeFound = true

								if v.(bool) {
									verifyHostnameInt := &ves_io_schema_global_log_receiver.TLSConfigType_DisableVerifyHostname{}
									verifyHostnameInt.DisableVerifyHostname = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyHostname = verifyHostnameInt
								}

							}

							if v, ok := cs["enable_verify_hostname"]; ok && !isIntfNil(v) && !verifyHostnameTypeFound {

								verifyHostnameTypeFound = true

								if v.(bool) {
									verifyHostnameInt := &ves_io_schema_global_log_receiver.TLSConfigType_EnableVerifyHostname{}
									verifyHostnameInt.EnableVerifyHostname = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyHostname = verifyHostnameInt
								}

							}

						}
					}

				}

				if v, ok := cs["uri"]; ok && !isIntfNil(v) {

					receiverInt.QradarReceiver.Uri = v.(string)

				}

			}
		}

	}

	if v, ok := d.GetOk("s3_receiver"); ok && !isIntfNil(v) && !receiverTypeFound {

		receiverTypeFound = true
		receiverInt := &ves_io_schema_global_log_receiver.CreateSpecType_S3Receiver{}
		receiverInt.S3Receiver = &ves_io_schema_global_log_receiver.S3Config{}
		createSpec.Receiver = receiverInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["aws_cred"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					awsCredInt := &ves_io_schema_views.ObjectRefType{}
					receiverInt.S3Receiver.AwsCred = awsCredInt

					for _, set := range sl {
						if set != nil {
							acMapToStrVal := set.(map[string]interface{})
							if val, ok := acMapToStrVal["name"]; ok && !isIntfNil(v) {
								awsCredInt.Name = val.(string)
							}
							if val, ok := acMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								awsCredInt.Namespace = val.(string)
							}

							if val, ok := acMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								awsCredInt.Tenant = val.(string)
							}
						}
					}

				}

				if v, ok := cs["aws_region"]; ok && !isIntfNil(v) {

					receiverInt.S3Receiver.AwsRegion = v.(string)

				}

				if v, ok := cs["batch"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					batch := &ves_io_schema_global_log_receiver.BatchOptionType{}
					receiverInt.S3Receiver.Batch = batch
					for _, set := range sl {
						if set != nil {
							batchMapStrToI := set.(map[string]interface{})

							batchBytesTypeFound := false

							if v, ok := batchMapStrToI["max_bytes"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true
								batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytes{}

								batch.BatchBytes = batchBytesInt

								batchBytesInt.MaxBytes = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_bytes_disabled"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true

								if v.(bool) {
									batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytesDisabled{}
									batchBytesInt.MaxBytesDisabled = &ves_io_schema.Empty{}
									batch.BatchBytes = batchBytesInt
								}

							}

							batchEventsTypeFound := false

							if v, ok := batchMapStrToI["max_events"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true
								batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEvents{}

								batch.BatchEvents = batchEventsInt

								batchEventsInt.MaxEvents = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_events_disabled"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true

								if v.(bool) {
									batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEventsDisabled{}
									batchEventsInt.MaxEventsDisabled = &ves_io_schema.Empty{}
									batch.BatchEvents = batchEventsInt
								}

							}

							batchTimeoutTypeFound := false

							if v, ok := batchMapStrToI["timeout_seconds"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true
								batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSeconds{}

								batch.BatchTimeout = batchTimeoutInt

								batchTimeoutInt.TimeoutSeconds = uint64(v.(int))

							}

							if v, ok := batchMapStrToI["timeout_seconds_default"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true

								if v.(bool) {
									batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSecondsDefault{}
									batchTimeoutInt.TimeoutSecondsDefault = &ves_io_schema.Empty{}
									batch.BatchTimeout = batchTimeoutInt
								}

							}

						}
					}

				}

				if v, ok := cs["bucket"]; ok && !isIntfNil(v) {

					receiverInt.S3Receiver.Bucket = v.(string)

				}

				if v, ok := cs["compression"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					compression := &ves_io_schema_global_log_receiver.CompressionType{}
					receiverInt.S3Receiver.Compression = compression
					for _, set := range sl {
						if set != nil {
							compressionMapStrToI := set.(map[string]interface{})

							compressionChoiceTypeFound := false

							if v, ok := compressionMapStrToI["compression_default"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionDefault{}
									compressionChoiceInt.CompressionDefault = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_gzip"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionGzip{}
									compressionChoiceInt.CompressionGzip = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_none"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionNone{}
									compressionChoiceInt.CompressionNone = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

						}
					}

				}

				if v, ok := cs["filename_options"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					filenameOptions := &ves_io_schema_global_log_receiver.FilenameOptionsType{}
					receiverInt.S3Receiver.FilenameOptions = filenameOptions
					for _, set := range sl {
						if set != nil {
							filenameOptionsMapStrToI := set.(map[string]interface{})

							folderTypeFound := false

							if v, ok := filenameOptionsMapStrToI["custom_folder"]; ok && !isIntfNil(v) && !folderTypeFound {

								folderTypeFound = true
								folderInt := &ves_io_schema_global_log_receiver.FilenameOptionsType_CustomFolder{}

								filenameOptions.Folder = folderInt

								folderInt.CustomFolder = v.(string)

							}

							if v, ok := filenameOptionsMapStrToI["log_type_folder"]; ok && !isIntfNil(v) && !folderTypeFound {

								folderTypeFound = true

								if v.(bool) {
									folderInt := &ves_io_schema_global_log_receiver.FilenameOptionsType_LogTypeFolder{}
									folderInt.LogTypeFolder = &ves_io_schema.Empty{}
									filenameOptions.Folder = folderInt
								}

							}

							if v, ok := filenameOptionsMapStrToI["no_folder"]; ok && !isIntfNil(v) && !folderTypeFound {

								folderTypeFound = true

								if v.(bool) {
									folderInt := &ves_io_schema_global_log_receiver.FilenameOptionsType_NoFolder{}
									folderInt.NoFolder = &ves_io_schema.Empty{}
									filenameOptions.Folder = folderInt
								}

							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("splunk_receiver"); ok && !isIntfNil(v) && !receiverTypeFound {

		receiverTypeFound = true
		receiverInt := &ves_io_schema_global_log_receiver.CreateSpecType_SplunkReceiver{}
		receiverInt.SplunkReceiver = &ves_io_schema_global_log_receiver.SplunkConfig{}
		createSpec.Receiver = receiverInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["batch"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					batch := &ves_io_schema_global_log_receiver.BatchOptionType{}
					receiverInt.SplunkReceiver.Batch = batch
					for _, set := range sl {
						if set != nil {
							batchMapStrToI := set.(map[string]interface{})

							batchBytesTypeFound := false

							if v, ok := batchMapStrToI["max_bytes"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true
								batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytes{}

								batch.BatchBytes = batchBytesInt

								batchBytesInt.MaxBytes = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_bytes_disabled"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true

								if v.(bool) {
									batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytesDisabled{}
									batchBytesInt.MaxBytesDisabled = &ves_io_schema.Empty{}
									batch.BatchBytes = batchBytesInt
								}

							}

							batchEventsTypeFound := false

							if v, ok := batchMapStrToI["max_events"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true
								batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEvents{}

								batch.BatchEvents = batchEventsInt

								batchEventsInt.MaxEvents = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_events_disabled"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true

								if v.(bool) {
									batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEventsDisabled{}
									batchEventsInt.MaxEventsDisabled = &ves_io_schema.Empty{}
									batch.BatchEvents = batchEventsInt
								}

							}

							batchTimeoutTypeFound := false

							if v, ok := batchMapStrToI["timeout_seconds"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true
								batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSeconds{}

								batch.BatchTimeout = batchTimeoutInt

								batchTimeoutInt.TimeoutSeconds = uint64(v.(int))

							}

							if v, ok := batchMapStrToI["timeout_seconds_default"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true

								if v.(bool) {
									batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSecondsDefault{}
									batchTimeoutInt.TimeoutSecondsDefault = &ves_io_schema.Empty{}
									batch.BatchTimeout = batchTimeoutInt
								}

							}

						}
					}

				}

				if v, ok := cs["compression"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					compression := &ves_io_schema_global_log_receiver.CompressionType{}
					receiverInt.SplunkReceiver.Compression = compression
					for _, set := range sl {
						if set != nil {
							compressionMapStrToI := set.(map[string]interface{})

							compressionChoiceTypeFound := false

							if v, ok := compressionMapStrToI["compression_default"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionDefault{}
									compressionChoiceInt.CompressionDefault = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_gzip"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionGzip{}
									compressionChoiceInt.CompressionGzip = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_none"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionNone{}
									compressionChoiceInt.CompressionNone = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

						}
					}

				}

				if v, ok := cs["endpoint"]; ok && !isIntfNil(v) {

					receiverInt.SplunkReceiver.Endpoint = v.(string)

				}

				if v, ok := cs["splunk_hec_token"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					splunkHecToken := &ves_io_schema.SecretType{}
					receiverInt.SplunkReceiver.SplunkHecToken = splunkHecToken
					for _, set := range sl {
						if set != nil {
							splunkHecTokenMapStrToI := set.(map[string]interface{})

							if v, ok := splunkHecTokenMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
								splunkHecToken.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
								for _, set := range sl {
									if set != nil {
										blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

										if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.Location = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.StoreProvider = w.(string)
										}

									}
								}

							}

							if v, ok := splunkHecTokenMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

								splunkHecToken.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

							}

							secretInfoOneofTypeFound := false

							if v, ok := splunkHecTokenMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
								secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
								splunkHecToken.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

										}

										if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

										}

									}
								}

							}

							if v, ok := splunkHecTokenMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
								secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
								splunkHecToken.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["url"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

										}

									}
								}

							}

							if v, ok := splunkHecTokenMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
								secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
								splunkHecToken.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["key"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

										}

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										if v, ok := cs["version"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

										}

									}
								}

							}

							if v, ok := splunkHecTokenMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
								secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
								splunkHecToken.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["name"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

										}

									}
								}

							}

						}
					}

				}

				tlsChoiceTypeFound := false

				if v, ok := cs["no_tls"]; ok && !isIntfNil(v) && !tlsChoiceTypeFound {

					tlsChoiceTypeFound = true

					if v.(bool) {
						tlsChoiceInt := &ves_io_schema_global_log_receiver.SplunkConfig_NoTls{}
						tlsChoiceInt.NoTls = &ves_io_schema.Empty{}
						receiverInt.SplunkReceiver.TlsChoice = tlsChoiceInt
					}

				}

				if v, ok := cs["use_tls"]; ok && !isIntfNil(v) && !tlsChoiceTypeFound {

					tlsChoiceTypeFound = true
					tlsChoiceInt := &ves_io_schema_global_log_receiver.SplunkConfig_UseTls{}
					tlsChoiceInt.UseTls = &ves_io_schema_global_log_receiver.TLSConfigType{}
					receiverInt.SplunkReceiver.TlsChoice = tlsChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							caChoiceTypeFound := false

							if v, ok := cs["no_ca"]; ok && !isIntfNil(v) && !caChoiceTypeFound {

								caChoiceTypeFound = true

								if v.(bool) {
									caChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_NoCa{}
									caChoiceInt.NoCa = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.CaChoice = caChoiceInt
								}

							}

							if v, ok := cs["trusted_ca_url"]; ok && !isIntfNil(v) && !caChoiceTypeFound {

								caChoiceTypeFound = true
								caChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_TrustedCaUrl{}

								tlsChoiceInt.UseTls.CaChoice = caChoiceInt

								caChoiceInt.TrustedCaUrl = v.(string)

							}

							mtlsChoiceTypeFound := false

							if v, ok := cs["mtls_disabled"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

								mtlsChoiceTypeFound = true

								if v.(bool) {
									mtlsChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_MtlsDisabled{}
									mtlsChoiceInt.MtlsDisabled = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt
								}

							}

							if v, ok := cs["mtls_enable"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

								mtlsChoiceTypeFound = true
								mtlsChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_MtlsEnable{}
								mtlsChoiceInt.MtlsEnable = &ves_io_schema_global_log_receiver.TLSClientConfigType{}
								tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["certificate"]; ok && !isIntfNil(v) {

											mtlsChoiceInt.MtlsEnable.Certificate = v.(string)

										}

										if v, ok := cs["key_url"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											keyUrl := &ves_io_schema.SecretType{}
											mtlsChoiceInt.MtlsEnable.KeyUrl = keyUrl
											for _, set := range sl {
												if set != nil {
													keyUrlMapStrToI := set.(map[string]interface{})

													if v, ok := keyUrlMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
														keyUrl.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
														for _, set := range sl {
															if set != nil {
																blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.Location = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.StoreProvider = w.(string)
																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

														keyUrl.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													secretInfoOneofTypeFound := false

													if v, ok := keyUrlMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
														secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																}

																if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
														secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["url"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
														secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["key"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																}

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																}

																if v, ok := cs["version"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
														secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																}

															}
														}

													}

												}
											}

										}

									}
								}

							}

							verifyCertificateTypeFound := false

							if v, ok := cs["disable_verify_certificate"]; ok && !isIntfNil(v) && !verifyCertificateTypeFound {

								verifyCertificateTypeFound = true

								if v.(bool) {
									verifyCertificateInt := &ves_io_schema_global_log_receiver.TLSConfigType_DisableVerifyCertificate{}
									verifyCertificateInt.DisableVerifyCertificate = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyCertificate = verifyCertificateInt
								}

							}

							if v, ok := cs["enable_verify_certificate"]; ok && !isIntfNil(v) && !verifyCertificateTypeFound {

								verifyCertificateTypeFound = true

								if v.(bool) {
									verifyCertificateInt := &ves_io_schema_global_log_receiver.TLSConfigType_EnableVerifyCertificate{}
									verifyCertificateInt.EnableVerifyCertificate = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyCertificate = verifyCertificateInt
								}

							}

							verifyHostnameTypeFound := false

							if v, ok := cs["disable_verify_hostname"]; ok && !isIntfNil(v) && !verifyHostnameTypeFound {

								verifyHostnameTypeFound = true

								if v.(bool) {
									verifyHostnameInt := &ves_io_schema_global_log_receiver.TLSConfigType_DisableVerifyHostname{}
									verifyHostnameInt.DisableVerifyHostname = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyHostname = verifyHostnameInt
								}

							}

							if v, ok := cs["enable_verify_hostname"]; ok && !isIntfNil(v) && !verifyHostnameTypeFound {

								verifyHostnameTypeFound = true

								if v.(bool) {
									verifyHostnameInt := &ves_io_schema_global_log_receiver.TLSConfigType_EnableVerifyHostname{}
									verifyHostnameInt.EnableVerifyHostname = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyHostname = verifyHostnameInt
								}

							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("sumo_logic_receiver"); ok && !isIntfNil(v) && !receiverTypeFound {

		receiverTypeFound = true
		receiverInt := &ves_io_schema_global_log_receiver.CreateSpecType_SumoLogicReceiver{}
		receiverInt.SumoLogicReceiver = &ves_io_schema_global_log_receiver.SumoLogicConfig{}
		createSpec.Receiver = receiverInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["url"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					url := &ves_io_schema.SecretType{}
					receiverInt.SumoLogicReceiver.Url = url
					for _, set := range sl {
						if set != nil {
							urlMapStrToI := set.(map[string]interface{})

							if v, ok := urlMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
								url.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
								for _, set := range sl {
									if set != nil {
										blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

										if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.Location = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.StoreProvider = w.(string)
										}

									}
								}

							}

							if v, ok := urlMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

								url.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

							}

							secretInfoOneofTypeFound := false

							if v, ok := urlMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
								secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
								url.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

										}

										if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

										}

									}
								}

							}

							if v, ok := urlMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
								secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
								url.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["url"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

										}

									}
								}

							}

							if v, ok := urlMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
								secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
								url.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["key"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

										}

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										if v, ok := cs["version"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

										}

									}
								}

							}

							if v, ok := urlMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
								secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
								url.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["name"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

										}

									}
								}

							}

						}
					}

				}

			}
		}

	}

	log.Printf("[DEBUG] Creating Volterra GlobalLogReceiver object with struct: %+v", createReq)

	createGlobalLogReceiverResp, err := client.CreateObject(context.Background(), ves_io_schema_global_log_receiver.ObjectType, createReq)
	if err != nil {
		return fmt.Errorf("error creating GlobalLogReceiver: %s", err)
	}
	d.SetId(createGlobalLogReceiverResp.GetObjSystemMetadata().GetUid())

	return resourceVolterraGlobalLogReceiverRead(d, meta)
}

func resourceVolterraGlobalLogReceiverRead(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	resp, err := client.GetObject(context.Background(), ves_io_schema_global_log_receiver.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] GlobalLogReceiver %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra GlobalLogReceiver %q: %s", d.Id(), err)
	}
	return setGlobalLogReceiverFields(client, d, resp)
}

func setGlobalLogReceiverFields(client *APIClient, d *schema.ResourceData, resp vesapi.GetObjectResponse) error {
	metadata := resp.GetObjMetadata()

	d.Set("annotations", metadata.GetAnnotations())

	d.Set("description", metadata.GetDescription())

	d.Set("disable", metadata.GetDisable())

	d.Set("labels", metadata.GetLabels())

	d.Set("name", metadata.GetName())

	d.Set("namespace", metadata.GetNamespace())

	return nil
}

// resourceVolterraGlobalLogReceiverUpdate updates GlobalLogReceiver resource
func resourceVolterraGlobalLogReceiverUpdate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	updateMeta := &ves_io_schema.ObjectReplaceMetaType{}
	updateSpec := &ves_io_schema_global_log_receiver.ReplaceSpecType{}
	updateReq := &ves_io_schema_global_log_receiver.ReplaceRequest{
		Metadata: updateMeta,
		Spec:     updateSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		updateMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		updateMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		updateMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		updateMeta.Namespace =
			v.(string)
	}

	filterChoiceTypeFound := false

	if v, ok := d.GetOk("ns_all"); ok && !filterChoiceTypeFound {

		filterChoiceTypeFound = true

		if v.(bool) {
			filterChoiceInt := &ves_io_schema_global_log_receiver.ReplaceSpecType_NsAll{}
			filterChoiceInt.NsAll = &ves_io_schema.Empty{}
			updateSpec.FilterChoice = filterChoiceInt
		}

	}

	if v, ok := d.GetOk("ns_current"); ok && !filterChoiceTypeFound {

		filterChoiceTypeFound = true

		if v.(bool) {
			filterChoiceInt := &ves_io_schema_global_log_receiver.ReplaceSpecType_NsCurrent{}
			filterChoiceInt.NsCurrent = &ves_io_schema.Empty{}
			updateSpec.FilterChoice = filterChoiceInt
		}

	}

	if v, ok := d.GetOk("ns_list"); ok && !isIntfNil(v) && !filterChoiceTypeFound {

		filterChoiceTypeFound = true
		filterChoiceInt := &ves_io_schema_global_log_receiver.ReplaceSpecType_NsList{}
		filterChoiceInt.NsList = &ves_io_schema_global_log_receiver.NSList{}
		updateSpec.FilterChoice = filterChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["namespaces"]; ok && !isIntfNil(v) {

					ls := make([]string, len(v.([]interface{})))
					for i, v := range v.([]interface{}) {
						if v == nil {
							return fmt.Errorf("please provide valid non-empty string value of field namespaces")
						}
						if str, ok := v.(string); ok {
							ls[i] = str
						}
					}
					filterChoiceInt.NsList.Namespaces = ls

				}

			}
		}

	}

	if v, ok := d.GetOk("ns_system"); ok && !filterChoiceTypeFound {

		filterChoiceTypeFound = true

		if v.(bool) {
			filterChoiceInt := &ves_io_schema_global_log_receiver.ReplaceSpecType_NsSystem{}
			filterChoiceInt.NsSystem = &ves_io_schema.Empty{}
			updateSpec.FilterChoice = filterChoiceInt
		}

	}

	logTypeTypeFound := false

	if v, ok := d.GetOk("audit_logs"); ok && !logTypeTypeFound {

		logTypeTypeFound = true

		if v.(bool) {
			logTypeInt := &ves_io_schema_global_log_receiver.ReplaceSpecType_AuditLogs{}
			logTypeInt.AuditLogs = &ves_io_schema.Empty{}
			updateSpec.LogType = logTypeInt
		}

	}

	if v, ok := d.GetOk("dns_logs"); ok && !logTypeTypeFound {

		logTypeTypeFound = true

		if v.(bool) {
			logTypeInt := &ves_io_schema_global_log_receiver.ReplaceSpecType_DnsLogs{}
			logTypeInt.DnsLogs = &ves_io_schema.Empty{}
			updateSpec.LogType = logTypeInt
		}

	}

	if v, ok := d.GetOk("request_logs"); ok && !logTypeTypeFound {

		logTypeTypeFound = true

		if v.(bool) {
			logTypeInt := &ves_io_schema_global_log_receiver.ReplaceSpecType_RequestLogs{}
			logTypeInt.RequestLogs = &ves_io_schema.Empty{}
			updateSpec.LogType = logTypeInt
		}

	}

	if v, ok := d.GetOk("security_events"); ok && !logTypeTypeFound {

		logTypeTypeFound = true

		if v.(bool) {
			logTypeInt := &ves_io_schema_global_log_receiver.ReplaceSpecType_SecurityEvents{}
			logTypeInt.SecurityEvents = &ves_io_schema.Empty{}
			updateSpec.LogType = logTypeInt
		}

	}

	receiverTypeFound := false

	if v, ok := d.GetOk("aws_cloud_watch_receiver"); ok && !isIntfNil(v) && !receiverTypeFound {

		receiverTypeFound = true
		receiverInt := &ves_io_schema_global_log_receiver.ReplaceSpecType_AwsCloudWatchReceiver{}
		receiverInt.AwsCloudWatchReceiver = &ves_io_schema_global_log_receiver.AWSCloudwatchConfig{}
		updateSpec.Receiver = receiverInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["aws_cred"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					awsCredInt := &ves_io_schema_views.ObjectRefType{}
					receiverInt.AwsCloudWatchReceiver.AwsCred = awsCredInt

					for _, set := range sl {
						if set != nil {
							acMapToStrVal := set.(map[string]interface{})
							if val, ok := acMapToStrVal["name"]; ok && !isIntfNil(v) {
								awsCredInt.Name = val.(string)
							}
							if val, ok := acMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								awsCredInt.Namespace = val.(string)
							}

							if val, ok := acMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								awsCredInt.Tenant = val.(string)
							}
						}
					}

				}

				if v, ok := cs["aws_region"]; ok && !isIntfNil(v) {

					receiverInt.AwsCloudWatchReceiver.AwsRegion = v.(string)

				}

				if v, ok := cs["batch"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					batch := &ves_io_schema_global_log_receiver.BatchOptionType{}
					receiverInt.AwsCloudWatchReceiver.Batch = batch
					for _, set := range sl {
						if set != nil {
							batchMapStrToI := set.(map[string]interface{})

							batchBytesTypeFound := false

							if v, ok := batchMapStrToI["max_bytes"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true
								batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytes{}

								batch.BatchBytes = batchBytesInt

								batchBytesInt.MaxBytes = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_bytes_disabled"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true

								if v.(bool) {
									batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytesDisabled{}
									batchBytesInt.MaxBytesDisabled = &ves_io_schema.Empty{}
									batch.BatchBytes = batchBytesInt
								}

							}

							batchEventsTypeFound := false

							if v, ok := batchMapStrToI["max_events"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true
								batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEvents{}

								batch.BatchEvents = batchEventsInt

								batchEventsInt.MaxEvents = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_events_disabled"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true

								if v.(bool) {
									batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEventsDisabled{}
									batchEventsInt.MaxEventsDisabled = &ves_io_schema.Empty{}
									batch.BatchEvents = batchEventsInt
								}

							}

							batchTimeoutTypeFound := false

							if v, ok := batchMapStrToI["timeout_seconds"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true
								batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSeconds{}

								batch.BatchTimeout = batchTimeoutInt

								batchTimeoutInt.TimeoutSeconds = uint64(v.(int))

							}

							if v, ok := batchMapStrToI["timeout_seconds_default"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true

								if v.(bool) {
									batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSecondsDefault{}
									batchTimeoutInt.TimeoutSecondsDefault = &ves_io_schema.Empty{}
									batch.BatchTimeout = batchTimeoutInt
								}

							}

						}
					}

				}

				if v, ok := cs["compression"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					compression := &ves_io_schema_global_log_receiver.CompressionType{}
					receiverInt.AwsCloudWatchReceiver.Compression = compression
					for _, set := range sl {
						if set != nil {
							compressionMapStrToI := set.(map[string]interface{})

							compressionChoiceTypeFound := false

							if v, ok := compressionMapStrToI["compression_default"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionDefault{}
									compressionChoiceInt.CompressionDefault = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_gzip"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionGzip{}
									compressionChoiceInt.CompressionGzip = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_none"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionNone{}
									compressionChoiceInt.CompressionNone = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

						}
					}

				}

				if v, ok := cs["group_name"]; ok && !isIntfNil(v) {

					receiverInt.AwsCloudWatchReceiver.GroupName = v.(string)

				}

				if v, ok := cs["stream_name"]; ok && !isIntfNil(v) {

					receiverInt.AwsCloudWatchReceiver.StreamName = v.(string)

				}

			}
		}

	}

	if v, ok := d.GetOk("azure_event_hubs_receiver"); ok && !isIntfNil(v) && !receiverTypeFound {

		receiverTypeFound = true
		receiverInt := &ves_io_schema_global_log_receiver.ReplaceSpecType_AzureEventHubsReceiver{}
		receiverInt.AzureEventHubsReceiver = &ves_io_schema_global_log_receiver.AzureEventHubsConfig{}
		updateSpec.Receiver = receiverInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["connection_string"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					connectionString := &ves_io_schema.SecretType{}
					receiverInt.AzureEventHubsReceiver.ConnectionString = connectionString
					for _, set := range sl {
						if set != nil {
							connectionStringMapStrToI := set.(map[string]interface{})

							if v, ok := connectionStringMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
								connectionString.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
								for _, set := range sl {
									if set != nil {
										blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

										if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.Location = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.StoreProvider = w.(string)
										}

									}
								}

							}

							if v, ok := connectionStringMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

								connectionString.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

							}

							secretInfoOneofTypeFound := false

							if v, ok := connectionStringMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
								secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
								connectionString.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

										}

										if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

										}

									}
								}

							}

							if v, ok := connectionStringMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
								secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
								connectionString.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["url"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

										}

									}
								}

							}

							if v, ok := connectionStringMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
								secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
								connectionString.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["key"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

										}

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										if v, ok := cs["version"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

										}

									}
								}

							}

							if v, ok := connectionStringMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
								secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
								connectionString.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["name"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["instance"]; ok && !isIntfNil(v) {

					receiverInt.AzureEventHubsReceiver.Instance = v.(string)

				}

				if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

					receiverInt.AzureEventHubsReceiver.Namespace = v.(string)

				}

			}
		}

	}

	if v, ok := d.GetOk("azure_receiver"); ok && !isIntfNil(v) && !receiverTypeFound {

		receiverTypeFound = true
		receiverInt := &ves_io_schema_global_log_receiver.ReplaceSpecType_AzureReceiver{}
		receiverInt.AzureReceiver = &ves_io_schema_global_log_receiver.AzureBlobConfig{}
		updateSpec.Receiver = receiverInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["batch"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					batch := &ves_io_schema_global_log_receiver.BatchOptionType{}
					receiverInt.AzureReceiver.Batch = batch
					for _, set := range sl {
						if set != nil {
							batchMapStrToI := set.(map[string]interface{})

							batchBytesTypeFound := false

							if v, ok := batchMapStrToI["max_bytes"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true
								batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytes{}

								batch.BatchBytes = batchBytesInt

								batchBytesInt.MaxBytes = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_bytes_disabled"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true

								if v.(bool) {
									batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytesDisabled{}
									batchBytesInt.MaxBytesDisabled = &ves_io_schema.Empty{}
									batch.BatchBytes = batchBytesInt
								}

							}

							batchEventsTypeFound := false

							if v, ok := batchMapStrToI["max_events"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true
								batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEvents{}

								batch.BatchEvents = batchEventsInt

								batchEventsInt.MaxEvents = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_events_disabled"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true

								if v.(bool) {
									batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEventsDisabled{}
									batchEventsInt.MaxEventsDisabled = &ves_io_schema.Empty{}
									batch.BatchEvents = batchEventsInt
								}

							}

							batchTimeoutTypeFound := false

							if v, ok := batchMapStrToI["timeout_seconds"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true
								batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSeconds{}

								batch.BatchTimeout = batchTimeoutInt

								batchTimeoutInt.TimeoutSeconds = uint64(v.(int))

							}

							if v, ok := batchMapStrToI["timeout_seconds_default"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true

								if v.(bool) {
									batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSecondsDefault{}
									batchTimeoutInt.TimeoutSecondsDefault = &ves_io_schema.Empty{}
									batch.BatchTimeout = batchTimeoutInt
								}

							}

						}
					}

				}

				if v, ok := cs["compression"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					compression := &ves_io_schema_global_log_receiver.CompressionType{}
					receiverInt.AzureReceiver.Compression = compression
					for _, set := range sl {
						if set != nil {
							compressionMapStrToI := set.(map[string]interface{})

							compressionChoiceTypeFound := false

							if v, ok := compressionMapStrToI["compression_default"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionDefault{}
									compressionChoiceInt.CompressionDefault = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_gzip"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionGzip{}
									compressionChoiceInt.CompressionGzip = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_none"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionNone{}
									compressionChoiceInt.CompressionNone = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

						}
					}

				}

				if v, ok := cs["connection_string"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					connectionString := &ves_io_schema.SecretType{}
					receiverInt.AzureReceiver.ConnectionString = connectionString
					for _, set := range sl {
						if set != nil {
							connectionStringMapStrToI := set.(map[string]interface{})

							if v, ok := connectionStringMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
								connectionString.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
								for _, set := range sl {
									if set != nil {
										blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

										if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.Location = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.StoreProvider = w.(string)
										}

									}
								}

							}

							if v, ok := connectionStringMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

								connectionString.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

							}

							secretInfoOneofTypeFound := false

							if v, ok := connectionStringMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
								secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
								connectionString.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

										}

										if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

										}

									}
								}

							}

							if v, ok := connectionStringMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
								secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
								connectionString.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["url"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

										}

									}
								}

							}

							if v, ok := connectionStringMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
								secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
								connectionString.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["key"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

										}

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										if v, ok := cs["version"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

										}

									}
								}

							}

							if v, ok := connectionStringMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
								secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
								connectionString.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["name"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["container_name"]; ok && !isIntfNil(v) {

					receiverInt.AzureReceiver.ContainerName = v.(string)

				}

				if v, ok := cs["filename_options"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					filenameOptions := &ves_io_schema_global_log_receiver.FilenameOptionsType{}
					receiverInt.AzureReceiver.FilenameOptions = filenameOptions
					for _, set := range sl {
						if set != nil {
							filenameOptionsMapStrToI := set.(map[string]interface{})

							folderTypeFound := false

							if v, ok := filenameOptionsMapStrToI["custom_folder"]; ok && !isIntfNil(v) && !folderTypeFound {

								folderTypeFound = true
								folderInt := &ves_io_schema_global_log_receiver.FilenameOptionsType_CustomFolder{}

								filenameOptions.Folder = folderInt

								folderInt.CustomFolder = v.(string)

							}

							if v, ok := filenameOptionsMapStrToI["log_type_folder"]; ok && !isIntfNil(v) && !folderTypeFound {

								folderTypeFound = true

								if v.(bool) {
									folderInt := &ves_io_schema_global_log_receiver.FilenameOptionsType_LogTypeFolder{}
									folderInt.LogTypeFolder = &ves_io_schema.Empty{}
									filenameOptions.Folder = folderInt
								}

							}

							if v, ok := filenameOptionsMapStrToI["no_folder"]; ok && !isIntfNil(v) && !folderTypeFound {

								folderTypeFound = true

								if v.(bool) {
									folderInt := &ves_io_schema_global_log_receiver.FilenameOptionsType_NoFolder{}
									folderInt.NoFolder = &ves_io_schema.Empty{}
									filenameOptions.Folder = folderInt
								}

							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("datadog_receiver"); ok && !isIntfNil(v) && !receiverTypeFound {

		receiverTypeFound = true
		receiverInt := &ves_io_schema_global_log_receiver.ReplaceSpecType_DatadogReceiver{}
		receiverInt.DatadogReceiver = &ves_io_schema_global_log_receiver.DatadogConfig{}
		updateSpec.Receiver = receiverInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["batch"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					batch := &ves_io_schema_global_log_receiver.BatchOptionType{}
					receiverInt.DatadogReceiver.Batch = batch
					for _, set := range sl {
						if set != nil {
							batchMapStrToI := set.(map[string]interface{})

							batchBytesTypeFound := false

							if v, ok := batchMapStrToI["max_bytes"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true
								batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytes{}

								batch.BatchBytes = batchBytesInt

								batchBytesInt.MaxBytes = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_bytes_disabled"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true

								if v.(bool) {
									batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytesDisabled{}
									batchBytesInt.MaxBytesDisabled = &ves_io_schema.Empty{}
									batch.BatchBytes = batchBytesInt
								}

							}

							batchEventsTypeFound := false

							if v, ok := batchMapStrToI["max_events"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true
								batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEvents{}

								batch.BatchEvents = batchEventsInt

								batchEventsInt.MaxEvents = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_events_disabled"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true

								if v.(bool) {
									batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEventsDisabled{}
									batchEventsInt.MaxEventsDisabled = &ves_io_schema.Empty{}
									batch.BatchEvents = batchEventsInt
								}

							}

							batchTimeoutTypeFound := false

							if v, ok := batchMapStrToI["timeout_seconds"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true
								batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSeconds{}

								batch.BatchTimeout = batchTimeoutInt

								batchTimeoutInt.TimeoutSeconds = uint64(v.(int))

							}

							if v, ok := batchMapStrToI["timeout_seconds_default"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true

								if v.(bool) {
									batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSecondsDefault{}
									batchTimeoutInt.TimeoutSecondsDefault = &ves_io_schema.Empty{}
									batch.BatchTimeout = batchTimeoutInt
								}

							}

						}
					}

				}

				if v, ok := cs["compression"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					compression := &ves_io_schema_global_log_receiver.CompressionType{}
					receiverInt.DatadogReceiver.Compression = compression
					for _, set := range sl {
						if set != nil {
							compressionMapStrToI := set.(map[string]interface{})

							compressionChoiceTypeFound := false

							if v, ok := compressionMapStrToI["compression_default"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionDefault{}
									compressionChoiceInt.CompressionDefault = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_gzip"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionGzip{}
									compressionChoiceInt.CompressionGzip = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_none"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionNone{}
									compressionChoiceInt.CompressionNone = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

						}
					}

				}

				if v, ok := cs["datadog_api_key"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					datadogApiKey := &ves_io_schema.SecretType{}
					receiverInt.DatadogReceiver.DatadogApiKey = datadogApiKey
					for _, set := range sl {
						if set != nil {
							datadogApiKeyMapStrToI := set.(map[string]interface{})

							if v, ok := datadogApiKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
								datadogApiKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
								for _, set := range sl {
									if set != nil {
										blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

										if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.Location = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.StoreProvider = w.(string)
										}

									}
								}

							}

							if v, ok := datadogApiKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

								datadogApiKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

							}

							secretInfoOneofTypeFound := false

							if v, ok := datadogApiKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
								secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
								datadogApiKey.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

										}

										if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

										}

									}
								}

							}

							if v, ok := datadogApiKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
								secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
								datadogApiKey.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["url"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

										}

									}
								}

							}

							if v, ok := datadogApiKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
								secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
								datadogApiKey.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["key"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

										}

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										if v, ok := cs["version"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

										}

									}
								}

							}

							if v, ok := datadogApiKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
								secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
								datadogApiKey.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["name"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

										}

									}
								}

							}

						}
					}

				}

				endpointChoiceTypeFound := false

				if v, ok := cs["endpoint"]; ok && !isIntfNil(v) && !endpointChoiceTypeFound {

					endpointChoiceTypeFound = true
					endpointChoiceInt := &ves_io_schema_global_log_receiver.DatadogConfig_Endpoint{}

					receiverInt.DatadogReceiver.EndpointChoice = endpointChoiceInt

					endpointChoiceInt.Endpoint = v.(string)

				}

				if v, ok := cs["site"]; ok && !isIntfNil(v) && !endpointChoiceTypeFound {

					endpointChoiceTypeFound = true
					endpointChoiceInt := &ves_io_schema_global_log_receiver.DatadogConfig_Site{}

					receiverInt.DatadogReceiver.EndpointChoice = endpointChoiceInt

					endpointChoiceInt.Site = v.(string)

				}

				tlsChoiceTypeFound := false

				if v, ok := cs["no_tls"]; ok && !isIntfNil(v) && !tlsChoiceTypeFound {

					tlsChoiceTypeFound = true

					if v.(bool) {
						tlsChoiceInt := &ves_io_schema_global_log_receiver.DatadogConfig_NoTls{}
						tlsChoiceInt.NoTls = &ves_io_schema.Empty{}
						receiverInt.DatadogReceiver.TlsChoice = tlsChoiceInt
					}

				}

				if v, ok := cs["use_tls"]; ok && !isIntfNil(v) && !tlsChoiceTypeFound {

					tlsChoiceTypeFound = true
					tlsChoiceInt := &ves_io_schema_global_log_receiver.DatadogConfig_UseTls{}
					tlsChoiceInt.UseTls = &ves_io_schema_global_log_receiver.TLSConfigType{}
					receiverInt.DatadogReceiver.TlsChoice = tlsChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							caChoiceTypeFound := false

							if v, ok := cs["no_ca"]; ok && !isIntfNil(v) && !caChoiceTypeFound {

								caChoiceTypeFound = true

								if v.(bool) {
									caChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_NoCa{}
									caChoiceInt.NoCa = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.CaChoice = caChoiceInt
								}

							}

							if v, ok := cs["trusted_ca_url"]; ok && !isIntfNil(v) && !caChoiceTypeFound {

								caChoiceTypeFound = true
								caChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_TrustedCaUrl{}

								tlsChoiceInt.UseTls.CaChoice = caChoiceInt

								caChoiceInt.TrustedCaUrl = v.(string)

							}

							mtlsChoiceTypeFound := false

							if v, ok := cs["mtls_disabled"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

								mtlsChoiceTypeFound = true

								if v.(bool) {
									mtlsChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_MtlsDisabled{}
									mtlsChoiceInt.MtlsDisabled = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt
								}

							}

							if v, ok := cs["mtls_enable"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

								mtlsChoiceTypeFound = true
								mtlsChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_MtlsEnable{}
								mtlsChoiceInt.MtlsEnable = &ves_io_schema_global_log_receiver.TLSClientConfigType{}
								tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["certificate"]; ok && !isIntfNil(v) {

											mtlsChoiceInt.MtlsEnable.Certificate = v.(string)

										}

										if v, ok := cs["key_url"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											keyUrl := &ves_io_schema.SecretType{}
											mtlsChoiceInt.MtlsEnable.KeyUrl = keyUrl
											for _, set := range sl {
												if set != nil {
													keyUrlMapStrToI := set.(map[string]interface{})

													if v, ok := keyUrlMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
														keyUrl.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
														for _, set := range sl {
															if set != nil {
																blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.Location = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.StoreProvider = w.(string)
																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

														keyUrl.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													secretInfoOneofTypeFound := false

													if v, ok := keyUrlMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
														secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																}

																if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
														secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["url"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
														secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["key"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																}

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																}

																if v, ok := cs["version"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
														secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																}

															}
														}

													}

												}
											}

										}

									}
								}

							}

							verifyCertificateTypeFound := false

							if v, ok := cs["disable_verify_certificate"]; ok && !isIntfNil(v) && !verifyCertificateTypeFound {

								verifyCertificateTypeFound = true

								if v.(bool) {
									verifyCertificateInt := &ves_io_schema_global_log_receiver.TLSConfigType_DisableVerifyCertificate{}
									verifyCertificateInt.DisableVerifyCertificate = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyCertificate = verifyCertificateInt
								}

							}

							if v, ok := cs["enable_verify_certificate"]; ok && !isIntfNil(v) && !verifyCertificateTypeFound {

								verifyCertificateTypeFound = true

								if v.(bool) {
									verifyCertificateInt := &ves_io_schema_global_log_receiver.TLSConfigType_EnableVerifyCertificate{}
									verifyCertificateInt.EnableVerifyCertificate = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyCertificate = verifyCertificateInt
								}

							}

							verifyHostnameTypeFound := false

							if v, ok := cs["disable_verify_hostname"]; ok && !isIntfNil(v) && !verifyHostnameTypeFound {

								verifyHostnameTypeFound = true

								if v.(bool) {
									verifyHostnameInt := &ves_io_schema_global_log_receiver.TLSConfigType_DisableVerifyHostname{}
									verifyHostnameInt.DisableVerifyHostname = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyHostname = verifyHostnameInt
								}

							}

							if v, ok := cs["enable_verify_hostname"]; ok && !isIntfNil(v) && !verifyHostnameTypeFound {

								verifyHostnameTypeFound = true

								if v.(bool) {
									verifyHostnameInt := &ves_io_schema_global_log_receiver.TLSConfigType_EnableVerifyHostname{}
									verifyHostnameInt.EnableVerifyHostname = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyHostname = verifyHostnameInt
								}

							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("elastic_receiver"); ok && !isIntfNil(v) && !receiverTypeFound {

		receiverTypeFound = true
		receiverInt := &ves_io_schema_global_log_receiver.ReplaceSpecType_ElasticReceiver{}
		receiverInt.ElasticReceiver = &ves_io_schema_global_log_receiver.ElasticConfig{}
		updateSpec.Receiver = receiverInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				authChoiceTypeFound := false

				if v, ok := cs["auth_aws"]; ok && !isIntfNil(v) && !authChoiceTypeFound {

					authChoiceTypeFound = true
					authChoiceInt := &ves_io_schema_global_log_receiver.ElasticConfig_AuthAws{}
					authChoiceInt.AuthAws = &ves_io_schema_views.ObjectRefType{}
					receiverInt.ElasticReceiver.AuthChoice = authChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								authChoiceInt.AuthAws.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								authChoiceInt.AuthAws.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								authChoiceInt.AuthAws.Tenant = v.(string)

							}

						}
					}

				}

				if v, ok := cs["auth_basic"]; ok && !isIntfNil(v) && !authChoiceTypeFound {

					authChoiceTypeFound = true
					authChoiceInt := &ves_io_schema_global_log_receiver.ElasticConfig_AuthBasic{}
					authChoiceInt.AuthBasic = &ves_io_schema_global_log_receiver.HttpAuthBasic{}
					receiverInt.ElasticReceiver.AuthChoice = authChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["password"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								password := &ves_io_schema.SecretType{}
								authChoiceInt.AuthBasic.Password = password
								for _, set := range sl {
									if set != nil {
										passwordMapStrToI := set.(map[string]interface{})

										if v, ok := passwordMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
											password.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
											for _, set := range sl {
												if set != nil {
													blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

													if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.Location = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.StoreProvider = w.(string)
													}

												}
											}

										}

										if v, ok := passwordMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

											password.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										secretInfoOneofTypeFound := false

										if v, ok := passwordMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
											secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
											password.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

													}

													if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

													}

												}
											}

										}

										if v, ok := passwordMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
											secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
											password.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["url"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

													}

												}
											}

										}

										if v, ok := passwordMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
											secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
											password.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["key"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

													}

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													if v, ok := cs["version"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

													}

												}
											}

										}

										if v, ok := passwordMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
											secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
											password.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if v, ok := cs["user_name"]; ok && !isIntfNil(v) {

								authChoiceInt.AuthBasic.UserName = v.(string)

							}

						}
					}

				}

				if v, ok := cs["auth_none"]; ok && !isIntfNil(v) && !authChoiceTypeFound {

					authChoiceTypeFound = true

					if v.(bool) {
						authChoiceInt := &ves_io_schema_global_log_receiver.ElasticConfig_AuthNone{}
						authChoiceInt.AuthNone = &ves_io_schema.Empty{}
						receiverInt.ElasticReceiver.AuthChoice = authChoiceInt
					}

				}

				if v, ok := cs["batch"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					batch := &ves_io_schema_global_log_receiver.BatchOptionType{}
					receiverInt.ElasticReceiver.Batch = batch
					for _, set := range sl {
						if set != nil {
							batchMapStrToI := set.(map[string]interface{})

							batchBytesTypeFound := false

							if v, ok := batchMapStrToI["max_bytes"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true
								batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytes{}

								batch.BatchBytes = batchBytesInt

								batchBytesInt.MaxBytes = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_bytes_disabled"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true

								if v.(bool) {
									batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytesDisabled{}
									batchBytesInt.MaxBytesDisabled = &ves_io_schema.Empty{}
									batch.BatchBytes = batchBytesInt
								}

							}

							batchEventsTypeFound := false

							if v, ok := batchMapStrToI["max_events"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true
								batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEvents{}

								batch.BatchEvents = batchEventsInt

								batchEventsInt.MaxEvents = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_events_disabled"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true

								if v.(bool) {
									batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEventsDisabled{}
									batchEventsInt.MaxEventsDisabled = &ves_io_schema.Empty{}
									batch.BatchEvents = batchEventsInt
								}

							}

							batchTimeoutTypeFound := false

							if v, ok := batchMapStrToI["timeout_seconds"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true
								batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSeconds{}

								batch.BatchTimeout = batchTimeoutInt

								batchTimeoutInt.TimeoutSeconds = uint64(v.(int))

							}

							if v, ok := batchMapStrToI["timeout_seconds_default"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true

								if v.(bool) {
									batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSecondsDefault{}
									batchTimeoutInt.TimeoutSecondsDefault = &ves_io_schema.Empty{}
									batch.BatchTimeout = batchTimeoutInt
								}

							}

						}
					}

				}

				if v, ok := cs["compression"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					compression := &ves_io_schema_global_log_receiver.CompressionType{}
					receiverInt.ElasticReceiver.Compression = compression
					for _, set := range sl {
						if set != nil {
							compressionMapStrToI := set.(map[string]interface{})

							compressionChoiceTypeFound := false

							if v, ok := compressionMapStrToI["compression_default"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionDefault{}
									compressionChoiceInt.CompressionDefault = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_gzip"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionGzip{}
									compressionChoiceInt.CompressionGzip = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_none"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionNone{}
									compressionChoiceInt.CompressionNone = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

						}
					}

				}

				if v, ok := cs["endpoint"]; ok && !isIntfNil(v) {

					receiverInt.ElasticReceiver.Endpoint = v.(string)

				}

				tlsChoiceTypeFound := false

				if v, ok := cs["no_tls"]; ok && !isIntfNil(v) && !tlsChoiceTypeFound {

					tlsChoiceTypeFound = true

					if v.(bool) {
						tlsChoiceInt := &ves_io_schema_global_log_receiver.ElasticConfig_NoTls{}
						tlsChoiceInt.NoTls = &ves_io_schema.Empty{}
						receiverInt.ElasticReceiver.TlsChoice = tlsChoiceInt
					}

				}

				if v, ok := cs["use_tls"]; ok && !isIntfNil(v) && !tlsChoiceTypeFound {

					tlsChoiceTypeFound = true
					tlsChoiceInt := &ves_io_schema_global_log_receiver.ElasticConfig_UseTls{}
					tlsChoiceInt.UseTls = &ves_io_schema_global_log_receiver.TLSConfigType{}
					receiverInt.ElasticReceiver.TlsChoice = tlsChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							caChoiceTypeFound := false

							if v, ok := cs["no_ca"]; ok && !isIntfNil(v) && !caChoiceTypeFound {

								caChoiceTypeFound = true

								if v.(bool) {
									caChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_NoCa{}
									caChoiceInt.NoCa = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.CaChoice = caChoiceInt
								}

							}

							if v, ok := cs["trusted_ca_url"]; ok && !isIntfNil(v) && !caChoiceTypeFound {

								caChoiceTypeFound = true
								caChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_TrustedCaUrl{}

								tlsChoiceInt.UseTls.CaChoice = caChoiceInt

								caChoiceInt.TrustedCaUrl = v.(string)

							}

							mtlsChoiceTypeFound := false

							if v, ok := cs["mtls_disabled"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

								mtlsChoiceTypeFound = true

								if v.(bool) {
									mtlsChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_MtlsDisabled{}
									mtlsChoiceInt.MtlsDisabled = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt
								}

							}

							if v, ok := cs["mtls_enable"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

								mtlsChoiceTypeFound = true
								mtlsChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_MtlsEnable{}
								mtlsChoiceInt.MtlsEnable = &ves_io_schema_global_log_receiver.TLSClientConfigType{}
								tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["certificate"]; ok && !isIntfNil(v) {

											mtlsChoiceInt.MtlsEnable.Certificate = v.(string)

										}

										if v, ok := cs["key_url"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											keyUrl := &ves_io_schema.SecretType{}
											mtlsChoiceInt.MtlsEnable.KeyUrl = keyUrl
											for _, set := range sl {
												if set != nil {
													keyUrlMapStrToI := set.(map[string]interface{})

													if v, ok := keyUrlMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
														keyUrl.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
														for _, set := range sl {
															if set != nil {
																blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.Location = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.StoreProvider = w.(string)
																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

														keyUrl.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													secretInfoOneofTypeFound := false

													if v, ok := keyUrlMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
														secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																}

																if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
														secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["url"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
														secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["key"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																}

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																}

																if v, ok := cs["version"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
														secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																}

															}
														}

													}

												}
											}

										}

									}
								}

							}

							verifyCertificateTypeFound := false

							if v, ok := cs["disable_verify_certificate"]; ok && !isIntfNil(v) && !verifyCertificateTypeFound {

								verifyCertificateTypeFound = true

								if v.(bool) {
									verifyCertificateInt := &ves_io_schema_global_log_receiver.TLSConfigType_DisableVerifyCertificate{}
									verifyCertificateInt.DisableVerifyCertificate = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyCertificate = verifyCertificateInt
								}

							}

							if v, ok := cs["enable_verify_certificate"]; ok && !isIntfNil(v) && !verifyCertificateTypeFound {

								verifyCertificateTypeFound = true

								if v.(bool) {
									verifyCertificateInt := &ves_io_schema_global_log_receiver.TLSConfigType_EnableVerifyCertificate{}
									verifyCertificateInt.EnableVerifyCertificate = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyCertificate = verifyCertificateInt
								}

							}

							verifyHostnameTypeFound := false

							if v, ok := cs["disable_verify_hostname"]; ok && !isIntfNil(v) && !verifyHostnameTypeFound {

								verifyHostnameTypeFound = true

								if v.(bool) {
									verifyHostnameInt := &ves_io_schema_global_log_receiver.TLSConfigType_DisableVerifyHostname{}
									verifyHostnameInt.DisableVerifyHostname = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyHostname = verifyHostnameInt
								}

							}

							if v, ok := cs["enable_verify_hostname"]; ok && !isIntfNil(v) && !verifyHostnameTypeFound {

								verifyHostnameTypeFound = true

								if v.(bool) {
									verifyHostnameInt := &ves_io_schema_global_log_receiver.TLSConfigType_EnableVerifyHostname{}
									verifyHostnameInt.EnableVerifyHostname = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyHostname = verifyHostnameInt
								}

							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("gcp_bucket_receiver"); ok && !isIntfNil(v) && !receiverTypeFound {

		receiverTypeFound = true
		receiverInt := &ves_io_schema_global_log_receiver.ReplaceSpecType_GcpBucketReceiver{}
		receiverInt.GcpBucketReceiver = &ves_io_schema_global_log_receiver.GCPBucketConfig{}
		updateSpec.Receiver = receiverInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["batch"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					batch := &ves_io_schema_global_log_receiver.BatchOptionType{}
					receiverInt.GcpBucketReceiver.Batch = batch
					for _, set := range sl {
						if set != nil {
							batchMapStrToI := set.(map[string]interface{})

							batchBytesTypeFound := false

							if v, ok := batchMapStrToI["max_bytes"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true
								batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytes{}

								batch.BatchBytes = batchBytesInt

								batchBytesInt.MaxBytes = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_bytes_disabled"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true

								if v.(bool) {
									batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytesDisabled{}
									batchBytesInt.MaxBytesDisabled = &ves_io_schema.Empty{}
									batch.BatchBytes = batchBytesInt
								}

							}

							batchEventsTypeFound := false

							if v, ok := batchMapStrToI["max_events"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true
								batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEvents{}

								batch.BatchEvents = batchEventsInt

								batchEventsInt.MaxEvents = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_events_disabled"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true

								if v.(bool) {
									batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEventsDisabled{}
									batchEventsInt.MaxEventsDisabled = &ves_io_schema.Empty{}
									batch.BatchEvents = batchEventsInt
								}

							}

							batchTimeoutTypeFound := false

							if v, ok := batchMapStrToI["timeout_seconds"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true
								batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSeconds{}

								batch.BatchTimeout = batchTimeoutInt

								batchTimeoutInt.TimeoutSeconds = uint64(v.(int))

							}

							if v, ok := batchMapStrToI["timeout_seconds_default"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true

								if v.(bool) {
									batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSecondsDefault{}
									batchTimeoutInt.TimeoutSecondsDefault = &ves_io_schema.Empty{}
									batch.BatchTimeout = batchTimeoutInt
								}

							}

						}
					}

				}

				if v, ok := cs["bucket"]; ok && !isIntfNil(v) {

					receiverInt.GcpBucketReceiver.Bucket = v.(string)

				}

				if v, ok := cs["compression"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					compression := &ves_io_schema_global_log_receiver.CompressionType{}
					receiverInt.GcpBucketReceiver.Compression = compression
					for _, set := range sl {
						if set != nil {
							compressionMapStrToI := set.(map[string]interface{})

							compressionChoiceTypeFound := false

							if v, ok := compressionMapStrToI["compression_default"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionDefault{}
									compressionChoiceInt.CompressionDefault = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_gzip"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionGzip{}
									compressionChoiceInt.CompressionGzip = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_none"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionNone{}
									compressionChoiceInt.CompressionNone = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

						}
					}

				}

				if v, ok := cs["filename_options"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					filenameOptions := &ves_io_schema_global_log_receiver.FilenameOptionsType{}
					receiverInt.GcpBucketReceiver.FilenameOptions = filenameOptions
					for _, set := range sl {
						if set != nil {
							filenameOptionsMapStrToI := set.(map[string]interface{})

							folderTypeFound := false

							if v, ok := filenameOptionsMapStrToI["custom_folder"]; ok && !isIntfNil(v) && !folderTypeFound {

								folderTypeFound = true
								folderInt := &ves_io_schema_global_log_receiver.FilenameOptionsType_CustomFolder{}

								filenameOptions.Folder = folderInt

								folderInt.CustomFolder = v.(string)

							}

							if v, ok := filenameOptionsMapStrToI["log_type_folder"]; ok && !isIntfNil(v) && !folderTypeFound {

								folderTypeFound = true

								if v.(bool) {
									folderInt := &ves_io_schema_global_log_receiver.FilenameOptionsType_LogTypeFolder{}
									folderInt.LogTypeFolder = &ves_io_schema.Empty{}
									filenameOptions.Folder = folderInt
								}

							}

							if v, ok := filenameOptionsMapStrToI["no_folder"]; ok && !isIntfNil(v) && !folderTypeFound {

								folderTypeFound = true

								if v.(bool) {
									folderInt := &ves_io_schema_global_log_receiver.FilenameOptionsType_NoFolder{}
									folderInt.NoFolder = &ves_io_schema.Empty{}
									filenameOptions.Folder = folderInt
								}

							}

						}
					}

				}

				if v, ok := cs["gcp_cred"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					gcpCredInt := &ves_io_schema_views.ObjectRefType{}
					receiverInt.GcpBucketReceiver.GcpCred = gcpCredInt

					for _, set := range sl {
						if set != nil {
							gcMapToStrVal := set.(map[string]interface{})
							if val, ok := gcMapToStrVal["name"]; ok && !isIntfNil(v) {
								gcpCredInt.Name = val.(string)
							}
							if val, ok := gcMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								gcpCredInt.Namespace = val.(string)
							}

							if val, ok := gcMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								gcpCredInt.Tenant = val.(string)
							}
						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("http_receiver"); ok && !isIntfNil(v) && !receiverTypeFound {

		receiverTypeFound = true
		receiverInt := &ves_io_schema_global_log_receiver.ReplaceSpecType_HttpReceiver{}
		receiverInt.HttpReceiver = &ves_io_schema_global_log_receiver.HTTPConfig{}
		updateSpec.Receiver = receiverInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				authChoiceTypeFound := false

				if v, ok := cs["auth_basic"]; ok && !isIntfNil(v) && !authChoiceTypeFound {

					authChoiceTypeFound = true
					authChoiceInt := &ves_io_schema_global_log_receiver.HTTPConfig_AuthBasic{}
					authChoiceInt.AuthBasic = &ves_io_schema_global_log_receiver.HttpAuthBasic{}
					receiverInt.HttpReceiver.AuthChoice = authChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["password"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								password := &ves_io_schema.SecretType{}
								authChoiceInt.AuthBasic.Password = password
								for _, set := range sl {
									if set != nil {
										passwordMapStrToI := set.(map[string]interface{})

										if v, ok := passwordMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
											password.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
											for _, set := range sl {
												if set != nil {
													blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

													if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.Location = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.StoreProvider = w.(string)
													}

												}
											}

										}

										if v, ok := passwordMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

											password.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										secretInfoOneofTypeFound := false

										if v, ok := passwordMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
											secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
											password.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

													}

													if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

													}

												}
											}

										}

										if v, ok := passwordMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
											secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
											password.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["url"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

													}

												}
											}

										}

										if v, ok := passwordMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
											secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
											password.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["key"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

													}

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													if v, ok := cs["version"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

													}

												}
											}

										}

										if v, ok := passwordMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
											secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
											password.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if v, ok := cs["user_name"]; ok && !isIntfNil(v) {

								authChoiceInt.AuthBasic.UserName = v.(string)

							}

						}
					}

				}

				if v, ok := cs["auth_none"]; ok && !isIntfNil(v) && !authChoiceTypeFound {

					authChoiceTypeFound = true

					if v.(bool) {
						authChoiceInt := &ves_io_schema_global_log_receiver.HTTPConfig_AuthNone{}
						authChoiceInt.AuthNone = &ves_io_schema.Empty{}
						receiverInt.HttpReceiver.AuthChoice = authChoiceInt
					}

				}

				if v, ok := cs["auth_token"]; ok && !isIntfNil(v) && !authChoiceTypeFound {

					authChoiceTypeFound = true
					authChoiceInt := &ves_io_schema_global_log_receiver.HTTPConfig_AuthToken{}
					authChoiceInt.AuthToken = &ves_io_schema_global_log_receiver.AuthToken{}
					receiverInt.HttpReceiver.AuthChoice = authChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["token"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								token := &ves_io_schema.SecretType{}
								authChoiceInt.AuthToken.Token = token
								for _, set := range sl {
									if set != nil {
										tokenMapStrToI := set.(map[string]interface{})

										if v, ok := tokenMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
											token.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
											for _, set := range sl {
												if set != nil {
													blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

													if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.Location = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.StoreProvider = w.(string)
													}

												}
											}

										}

										if v, ok := tokenMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

											token.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										secretInfoOneofTypeFound := false

										if v, ok := tokenMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
											secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
											token.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

													}

													if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

													}

												}
											}

										}

										if v, ok := tokenMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
											secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
											token.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["url"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

													}

												}
											}

										}

										if v, ok := tokenMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
											secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
											token.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["key"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

													}

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													if v, ok := cs["version"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

													}

												}
											}

										}

										if v, ok := tokenMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
											secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
											token.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["batch"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					batch := &ves_io_schema_global_log_receiver.BatchOptionType{}
					receiverInt.HttpReceiver.Batch = batch
					for _, set := range sl {
						if set != nil {
							batchMapStrToI := set.(map[string]interface{})

							batchBytesTypeFound := false

							if v, ok := batchMapStrToI["max_bytes"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true
								batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytes{}

								batch.BatchBytes = batchBytesInt

								batchBytesInt.MaxBytes = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_bytes_disabled"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true

								if v.(bool) {
									batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytesDisabled{}
									batchBytesInt.MaxBytesDisabled = &ves_io_schema.Empty{}
									batch.BatchBytes = batchBytesInt
								}

							}

							batchEventsTypeFound := false

							if v, ok := batchMapStrToI["max_events"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true
								batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEvents{}

								batch.BatchEvents = batchEventsInt

								batchEventsInt.MaxEvents = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_events_disabled"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true

								if v.(bool) {
									batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEventsDisabled{}
									batchEventsInt.MaxEventsDisabled = &ves_io_schema.Empty{}
									batch.BatchEvents = batchEventsInt
								}

							}

							batchTimeoutTypeFound := false

							if v, ok := batchMapStrToI["timeout_seconds"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true
								batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSeconds{}

								batch.BatchTimeout = batchTimeoutInt

								batchTimeoutInt.TimeoutSeconds = uint64(v.(int))

							}

							if v, ok := batchMapStrToI["timeout_seconds_default"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true

								if v.(bool) {
									batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSecondsDefault{}
									batchTimeoutInt.TimeoutSecondsDefault = &ves_io_schema.Empty{}
									batch.BatchTimeout = batchTimeoutInt
								}

							}

						}
					}

				}

				if v, ok := cs["compression"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					compression := &ves_io_schema_global_log_receiver.CompressionType{}
					receiverInt.HttpReceiver.Compression = compression
					for _, set := range sl {
						if set != nil {
							compressionMapStrToI := set.(map[string]interface{})

							compressionChoiceTypeFound := false

							if v, ok := compressionMapStrToI["compression_default"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionDefault{}
									compressionChoiceInt.CompressionDefault = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_gzip"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionGzip{}
									compressionChoiceInt.CompressionGzip = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_none"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionNone{}
									compressionChoiceInt.CompressionNone = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

						}
					}

				}

				tlsChoiceTypeFound := false

				if v, ok := cs["no_tls"]; ok && !isIntfNil(v) && !tlsChoiceTypeFound {

					tlsChoiceTypeFound = true

					if v.(bool) {
						tlsChoiceInt := &ves_io_schema_global_log_receiver.HTTPConfig_NoTls{}
						tlsChoiceInt.NoTls = &ves_io_schema.Empty{}
						receiverInt.HttpReceiver.TlsChoice = tlsChoiceInt
					}

				}

				if v, ok := cs["use_tls"]; ok && !isIntfNil(v) && !tlsChoiceTypeFound {

					tlsChoiceTypeFound = true
					tlsChoiceInt := &ves_io_schema_global_log_receiver.HTTPConfig_UseTls{}
					tlsChoiceInt.UseTls = &ves_io_schema_global_log_receiver.TLSConfigType{}
					receiverInt.HttpReceiver.TlsChoice = tlsChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							caChoiceTypeFound := false

							if v, ok := cs["no_ca"]; ok && !isIntfNil(v) && !caChoiceTypeFound {

								caChoiceTypeFound = true

								if v.(bool) {
									caChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_NoCa{}
									caChoiceInt.NoCa = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.CaChoice = caChoiceInt
								}

							}

							if v, ok := cs["trusted_ca_url"]; ok && !isIntfNil(v) && !caChoiceTypeFound {

								caChoiceTypeFound = true
								caChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_TrustedCaUrl{}

								tlsChoiceInt.UseTls.CaChoice = caChoiceInt

								caChoiceInt.TrustedCaUrl = v.(string)

							}

							mtlsChoiceTypeFound := false

							if v, ok := cs["mtls_disabled"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

								mtlsChoiceTypeFound = true

								if v.(bool) {
									mtlsChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_MtlsDisabled{}
									mtlsChoiceInt.MtlsDisabled = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt
								}

							}

							if v, ok := cs["mtls_enable"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

								mtlsChoiceTypeFound = true
								mtlsChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_MtlsEnable{}
								mtlsChoiceInt.MtlsEnable = &ves_io_schema_global_log_receiver.TLSClientConfigType{}
								tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["certificate"]; ok && !isIntfNil(v) {

											mtlsChoiceInt.MtlsEnable.Certificate = v.(string)

										}

										if v, ok := cs["key_url"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											keyUrl := &ves_io_schema.SecretType{}
											mtlsChoiceInt.MtlsEnable.KeyUrl = keyUrl
											for _, set := range sl {
												if set != nil {
													keyUrlMapStrToI := set.(map[string]interface{})

													if v, ok := keyUrlMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
														keyUrl.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
														for _, set := range sl {
															if set != nil {
																blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.Location = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.StoreProvider = w.(string)
																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

														keyUrl.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													secretInfoOneofTypeFound := false

													if v, ok := keyUrlMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
														secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																}

																if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
														secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["url"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
														secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["key"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																}

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																}

																if v, ok := cs["version"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
														secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																}

															}
														}

													}

												}
											}

										}

									}
								}

							}

							verifyCertificateTypeFound := false

							if v, ok := cs["disable_verify_certificate"]; ok && !isIntfNil(v) && !verifyCertificateTypeFound {

								verifyCertificateTypeFound = true

								if v.(bool) {
									verifyCertificateInt := &ves_io_schema_global_log_receiver.TLSConfigType_DisableVerifyCertificate{}
									verifyCertificateInt.DisableVerifyCertificate = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyCertificate = verifyCertificateInt
								}

							}

							if v, ok := cs["enable_verify_certificate"]; ok && !isIntfNil(v) && !verifyCertificateTypeFound {

								verifyCertificateTypeFound = true

								if v.(bool) {
									verifyCertificateInt := &ves_io_schema_global_log_receiver.TLSConfigType_EnableVerifyCertificate{}
									verifyCertificateInt.EnableVerifyCertificate = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyCertificate = verifyCertificateInt
								}

							}

							verifyHostnameTypeFound := false

							if v, ok := cs["disable_verify_hostname"]; ok && !isIntfNil(v) && !verifyHostnameTypeFound {

								verifyHostnameTypeFound = true

								if v.(bool) {
									verifyHostnameInt := &ves_io_schema_global_log_receiver.TLSConfigType_DisableVerifyHostname{}
									verifyHostnameInt.DisableVerifyHostname = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyHostname = verifyHostnameInt
								}

							}

							if v, ok := cs["enable_verify_hostname"]; ok && !isIntfNil(v) && !verifyHostnameTypeFound {

								verifyHostnameTypeFound = true

								if v.(bool) {
									verifyHostnameInt := &ves_io_schema_global_log_receiver.TLSConfigType_EnableVerifyHostname{}
									verifyHostnameInt.EnableVerifyHostname = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyHostname = verifyHostnameInt
								}

							}

						}
					}

				}

				if v, ok := cs["uri"]; ok && !isIntfNil(v) {

					receiverInt.HttpReceiver.Uri = v.(string)

				}

			}
		}

	}

	if v, ok := d.GetOk("kafka_receiver"); ok && !isIntfNil(v) && !receiverTypeFound {

		receiverTypeFound = true
		receiverInt := &ves_io_schema_global_log_receiver.ReplaceSpecType_KafkaReceiver{}
		receiverInt.KafkaReceiver = &ves_io_schema_global_log_receiver.KafkaConfig{}
		updateSpec.Receiver = receiverInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["batch"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					batch := &ves_io_schema_global_log_receiver.BatchOptionType{}
					receiverInt.KafkaReceiver.Batch = batch
					for _, set := range sl {
						if set != nil {
							batchMapStrToI := set.(map[string]interface{})

							batchBytesTypeFound := false

							if v, ok := batchMapStrToI["max_bytes"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true
								batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytes{}

								batch.BatchBytes = batchBytesInt

								batchBytesInt.MaxBytes = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_bytes_disabled"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true

								if v.(bool) {
									batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytesDisabled{}
									batchBytesInt.MaxBytesDisabled = &ves_io_schema.Empty{}
									batch.BatchBytes = batchBytesInt
								}

							}

							batchEventsTypeFound := false

							if v, ok := batchMapStrToI["max_events"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true
								batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEvents{}

								batch.BatchEvents = batchEventsInt

								batchEventsInt.MaxEvents = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_events_disabled"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true

								if v.(bool) {
									batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEventsDisabled{}
									batchEventsInt.MaxEventsDisabled = &ves_io_schema.Empty{}
									batch.BatchEvents = batchEventsInt
								}

							}

							batchTimeoutTypeFound := false

							if v, ok := batchMapStrToI["timeout_seconds"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true
								batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSeconds{}

								batch.BatchTimeout = batchTimeoutInt

								batchTimeoutInt.TimeoutSeconds = uint64(v.(int))

							}

							if v, ok := batchMapStrToI["timeout_seconds_default"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true

								if v.(bool) {
									batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSecondsDefault{}
									batchTimeoutInt.TimeoutSecondsDefault = &ves_io_schema.Empty{}
									batch.BatchTimeout = batchTimeoutInt
								}

							}

						}
					}

				}

				if v, ok := cs["bootstrap_servers"]; ok && !isIntfNil(v) {

					ls := make([]string, len(v.([]interface{})))
					for i, v := range v.([]interface{}) {
						if v == nil {
							return fmt.Errorf("please provide valid non-empty string value of field bootstrap_servers")
						}
						if str, ok := v.(string); ok {
							ls[i] = str
						}
					}
					receiverInt.KafkaReceiver.BootstrapServers = ls

				}

				if v, ok := cs["compression"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					compression := &ves_io_schema_global_log_receiver.CompressionType{}
					receiverInt.KafkaReceiver.Compression = compression
					for _, set := range sl {
						if set != nil {
							compressionMapStrToI := set.(map[string]interface{})

							compressionChoiceTypeFound := false

							if v, ok := compressionMapStrToI["compression_default"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionDefault{}
									compressionChoiceInt.CompressionDefault = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_gzip"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionGzip{}
									compressionChoiceInt.CompressionGzip = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_none"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionNone{}
									compressionChoiceInt.CompressionNone = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

						}
					}

				}

				if v, ok := cs["kafka_topic"]; ok && !isIntfNil(v) {

					receiverInt.KafkaReceiver.KafkaTopic = v.(string)

				}

				tlsChoiceTypeFound := false

				if v, ok := cs["no_tls"]; ok && !isIntfNil(v) && !tlsChoiceTypeFound {

					tlsChoiceTypeFound = true

					if v.(bool) {
						tlsChoiceInt := &ves_io_schema_global_log_receiver.KafkaConfig_NoTls{}
						tlsChoiceInt.NoTls = &ves_io_schema.Empty{}
						receiverInt.KafkaReceiver.TlsChoice = tlsChoiceInt
					}

				}

				if v, ok := cs["use_tls"]; ok && !isIntfNil(v) && !tlsChoiceTypeFound {

					tlsChoiceTypeFound = true
					tlsChoiceInt := &ves_io_schema_global_log_receiver.KafkaConfig_UseTls{}
					tlsChoiceInt.UseTls = &ves_io_schema_global_log_receiver.TLSConfigType{}
					receiverInt.KafkaReceiver.TlsChoice = tlsChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							caChoiceTypeFound := false

							if v, ok := cs["no_ca"]; ok && !isIntfNil(v) && !caChoiceTypeFound {

								caChoiceTypeFound = true

								if v.(bool) {
									caChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_NoCa{}
									caChoiceInt.NoCa = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.CaChoice = caChoiceInt
								}

							}

							if v, ok := cs["trusted_ca_url"]; ok && !isIntfNil(v) && !caChoiceTypeFound {

								caChoiceTypeFound = true
								caChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_TrustedCaUrl{}

								tlsChoiceInt.UseTls.CaChoice = caChoiceInt

								caChoiceInt.TrustedCaUrl = v.(string)

							}

							mtlsChoiceTypeFound := false

							if v, ok := cs["mtls_disabled"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

								mtlsChoiceTypeFound = true

								if v.(bool) {
									mtlsChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_MtlsDisabled{}
									mtlsChoiceInt.MtlsDisabled = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt
								}

							}

							if v, ok := cs["mtls_enable"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

								mtlsChoiceTypeFound = true
								mtlsChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_MtlsEnable{}
								mtlsChoiceInt.MtlsEnable = &ves_io_schema_global_log_receiver.TLSClientConfigType{}
								tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["certificate"]; ok && !isIntfNil(v) {

											mtlsChoiceInt.MtlsEnable.Certificate = v.(string)

										}

										if v, ok := cs["key_url"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											keyUrl := &ves_io_schema.SecretType{}
											mtlsChoiceInt.MtlsEnable.KeyUrl = keyUrl
											for _, set := range sl {
												if set != nil {
													keyUrlMapStrToI := set.(map[string]interface{})

													if v, ok := keyUrlMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
														keyUrl.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
														for _, set := range sl {
															if set != nil {
																blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.Location = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.StoreProvider = w.(string)
																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

														keyUrl.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													secretInfoOneofTypeFound := false

													if v, ok := keyUrlMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
														secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																}

																if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
														secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["url"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
														secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["key"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																}

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																}

																if v, ok := cs["version"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
														secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																}

															}
														}

													}

												}
											}

										}

									}
								}

							}

							verifyCertificateTypeFound := false

							if v, ok := cs["disable_verify_certificate"]; ok && !isIntfNil(v) && !verifyCertificateTypeFound {

								verifyCertificateTypeFound = true

								if v.(bool) {
									verifyCertificateInt := &ves_io_schema_global_log_receiver.TLSConfigType_DisableVerifyCertificate{}
									verifyCertificateInt.DisableVerifyCertificate = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyCertificate = verifyCertificateInt
								}

							}

							if v, ok := cs["enable_verify_certificate"]; ok && !isIntfNil(v) && !verifyCertificateTypeFound {

								verifyCertificateTypeFound = true

								if v.(bool) {
									verifyCertificateInt := &ves_io_schema_global_log_receiver.TLSConfigType_EnableVerifyCertificate{}
									verifyCertificateInt.EnableVerifyCertificate = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyCertificate = verifyCertificateInt
								}

							}

							verifyHostnameTypeFound := false

							if v, ok := cs["disable_verify_hostname"]; ok && !isIntfNil(v) && !verifyHostnameTypeFound {

								verifyHostnameTypeFound = true

								if v.(bool) {
									verifyHostnameInt := &ves_io_schema_global_log_receiver.TLSConfigType_DisableVerifyHostname{}
									verifyHostnameInt.DisableVerifyHostname = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyHostname = verifyHostnameInt
								}

							}

							if v, ok := cs["enable_verify_hostname"]; ok && !isIntfNil(v) && !verifyHostnameTypeFound {

								verifyHostnameTypeFound = true

								if v.(bool) {
									verifyHostnameInt := &ves_io_schema_global_log_receiver.TLSConfigType_EnableVerifyHostname{}
									verifyHostnameInt.EnableVerifyHostname = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyHostname = verifyHostnameInt
								}

							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("new_relic_receiver"); ok && !isIntfNil(v) && !receiverTypeFound {

		receiverTypeFound = true
		receiverInt := &ves_io_schema_global_log_receiver.ReplaceSpecType_NewRelicReceiver{}
		receiverInt.NewRelicReceiver = &ves_io_schema_global_log_receiver.NewRelicConfig{}
		updateSpec.Receiver = receiverInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["api_key"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					apiKey := &ves_io_schema.SecretType{}
					receiverInt.NewRelicReceiver.ApiKey = apiKey
					for _, set := range sl {
						if set != nil {
							apiKeyMapStrToI := set.(map[string]interface{})

							if v, ok := apiKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
								apiKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
								for _, set := range sl {
									if set != nil {
										blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

										if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.Location = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.StoreProvider = w.(string)
										}

									}
								}

							}

							if v, ok := apiKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

								apiKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

							}

							secretInfoOneofTypeFound := false

							if v, ok := apiKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
								secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
								apiKey.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

										}

										if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

										}

									}
								}

							}

							if v, ok := apiKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
								secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
								apiKey.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["url"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

										}

									}
								}

							}

							if v, ok := apiKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
								secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
								apiKey.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["key"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

										}

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										if v, ok := cs["version"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

										}

									}
								}

							}

							if v, ok := apiKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
								secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
								apiKey.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["name"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

										}

									}
								}

							}

						}
					}

				}

				endpointChoiceTypeFound := false

				if v, ok := cs["eu"]; ok && !isIntfNil(v) && !endpointChoiceTypeFound {

					endpointChoiceTypeFound = true

					if v.(bool) {
						endpointChoiceInt := &ves_io_schema_global_log_receiver.NewRelicConfig_Eu{}
						endpointChoiceInt.Eu = &ves_io_schema.Empty{}
						receiverInt.NewRelicReceiver.EndpointChoice = endpointChoiceInt
					}

				}

				if v, ok := cs["us"]; ok && !isIntfNil(v) && !endpointChoiceTypeFound {

					endpointChoiceTypeFound = true

					if v.(bool) {
						endpointChoiceInt := &ves_io_schema_global_log_receiver.NewRelicConfig_Us{}
						endpointChoiceInt.Us = &ves_io_schema.Empty{}
						receiverInt.NewRelicReceiver.EndpointChoice = endpointChoiceInt
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("qradar_receiver"); ok && !isIntfNil(v) && !receiverTypeFound {

		receiverTypeFound = true
		receiverInt := &ves_io_schema_global_log_receiver.ReplaceSpecType_QradarReceiver{}
		receiverInt.QradarReceiver = &ves_io_schema_global_log_receiver.QRadarConfig{}
		updateSpec.Receiver = receiverInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["batch"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					batch := &ves_io_schema_global_log_receiver.BatchOptionType{}
					receiverInt.QradarReceiver.Batch = batch
					for _, set := range sl {
						if set != nil {
							batchMapStrToI := set.(map[string]interface{})

							batchBytesTypeFound := false

							if v, ok := batchMapStrToI["max_bytes"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true
								batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytes{}

								batch.BatchBytes = batchBytesInt

								batchBytesInt.MaxBytes = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_bytes_disabled"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true

								if v.(bool) {
									batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytesDisabled{}
									batchBytesInt.MaxBytesDisabled = &ves_io_schema.Empty{}
									batch.BatchBytes = batchBytesInt
								}

							}

							batchEventsTypeFound := false

							if v, ok := batchMapStrToI["max_events"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true
								batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEvents{}

								batch.BatchEvents = batchEventsInt

								batchEventsInt.MaxEvents = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_events_disabled"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true

								if v.(bool) {
									batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEventsDisabled{}
									batchEventsInt.MaxEventsDisabled = &ves_io_schema.Empty{}
									batch.BatchEvents = batchEventsInt
								}

							}

							batchTimeoutTypeFound := false

							if v, ok := batchMapStrToI["timeout_seconds"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true
								batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSeconds{}

								batch.BatchTimeout = batchTimeoutInt

								batchTimeoutInt.TimeoutSeconds = uint64(v.(int))

							}

							if v, ok := batchMapStrToI["timeout_seconds_default"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true

								if v.(bool) {
									batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSecondsDefault{}
									batchTimeoutInt.TimeoutSecondsDefault = &ves_io_schema.Empty{}
									batch.BatchTimeout = batchTimeoutInt
								}

							}

						}
					}

				}

				if v, ok := cs["compression"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					compression := &ves_io_schema_global_log_receiver.CompressionType{}
					receiverInt.QradarReceiver.Compression = compression
					for _, set := range sl {
						if set != nil {
							compressionMapStrToI := set.(map[string]interface{})

							compressionChoiceTypeFound := false

							if v, ok := compressionMapStrToI["compression_default"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionDefault{}
									compressionChoiceInt.CompressionDefault = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_gzip"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionGzip{}
									compressionChoiceInt.CompressionGzip = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_none"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionNone{}
									compressionChoiceInt.CompressionNone = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

						}
					}

				}

				tlsChoiceTypeFound := false

				if v, ok := cs["no_tls"]; ok && !isIntfNil(v) && !tlsChoiceTypeFound {

					tlsChoiceTypeFound = true

					if v.(bool) {
						tlsChoiceInt := &ves_io_schema_global_log_receiver.QRadarConfig_NoTls{}
						tlsChoiceInt.NoTls = &ves_io_schema.Empty{}
						receiverInt.QradarReceiver.TlsChoice = tlsChoiceInt
					}

				}

				if v, ok := cs["use_tls"]; ok && !isIntfNil(v) && !tlsChoiceTypeFound {

					tlsChoiceTypeFound = true
					tlsChoiceInt := &ves_io_schema_global_log_receiver.QRadarConfig_UseTls{}
					tlsChoiceInt.UseTls = &ves_io_schema_global_log_receiver.TLSConfigType{}
					receiverInt.QradarReceiver.TlsChoice = tlsChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							caChoiceTypeFound := false

							if v, ok := cs["no_ca"]; ok && !isIntfNil(v) && !caChoiceTypeFound {

								caChoiceTypeFound = true

								if v.(bool) {
									caChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_NoCa{}
									caChoiceInt.NoCa = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.CaChoice = caChoiceInt
								}

							}

							if v, ok := cs["trusted_ca_url"]; ok && !isIntfNil(v) && !caChoiceTypeFound {

								caChoiceTypeFound = true
								caChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_TrustedCaUrl{}

								tlsChoiceInt.UseTls.CaChoice = caChoiceInt

								caChoiceInt.TrustedCaUrl = v.(string)

							}

							mtlsChoiceTypeFound := false

							if v, ok := cs["mtls_disabled"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

								mtlsChoiceTypeFound = true

								if v.(bool) {
									mtlsChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_MtlsDisabled{}
									mtlsChoiceInt.MtlsDisabled = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt
								}

							}

							if v, ok := cs["mtls_enable"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

								mtlsChoiceTypeFound = true
								mtlsChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_MtlsEnable{}
								mtlsChoiceInt.MtlsEnable = &ves_io_schema_global_log_receiver.TLSClientConfigType{}
								tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["certificate"]; ok && !isIntfNil(v) {

											mtlsChoiceInt.MtlsEnable.Certificate = v.(string)

										}

										if v, ok := cs["key_url"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											keyUrl := &ves_io_schema.SecretType{}
											mtlsChoiceInt.MtlsEnable.KeyUrl = keyUrl
											for _, set := range sl {
												if set != nil {
													keyUrlMapStrToI := set.(map[string]interface{})

													if v, ok := keyUrlMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
														keyUrl.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
														for _, set := range sl {
															if set != nil {
																blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.Location = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.StoreProvider = w.(string)
																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

														keyUrl.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													secretInfoOneofTypeFound := false

													if v, ok := keyUrlMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
														secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																}

																if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
														secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["url"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
														secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["key"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																}

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																}

																if v, ok := cs["version"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
														secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																}

															}
														}

													}

												}
											}

										}

									}
								}

							}

							verifyCertificateTypeFound := false

							if v, ok := cs["disable_verify_certificate"]; ok && !isIntfNil(v) && !verifyCertificateTypeFound {

								verifyCertificateTypeFound = true

								if v.(bool) {
									verifyCertificateInt := &ves_io_schema_global_log_receiver.TLSConfigType_DisableVerifyCertificate{}
									verifyCertificateInt.DisableVerifyCertificate = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyCertificate = verifyCertificateInt
								}

							}

							if v, ok := cs["enable_verify_certificate"]; ok && !isIntfNil(v) && !verifyCertificateTypeFound {

								verifyCertificateTypeFound = true

								if v.(bool) {
									verifyCertificateInt := &ves_io_schema_global_log_receiver.TLSConfigType_EnableVerifyCertificate{}
									verifyCertificateInt.EnableVerifyCertificate = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyCertificate = verifyCertificateInt
								}

							}

							verifyHostnameTypeFound := false

							if v, ok := cs["disable_verify_hostname"]; ok && !isIntfNil(v) && !verifyHostnameTypeFound {

								verifyHostnameTypeFound = true

								if v.(bool) {
									verifyHostnameInt := &ves_io_schema_global_log_receiver.TLSConfigType_DisableVerifyHostname{}
									verifyHostnameInt.DisableVerifyHostname = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyHostname = verifyHostnameInt
								}

							}

							if v, ok := cs["enable_verify_hostname"]; ok && !isIntfNil(v) && !verifyHostnameTypeFound {

								verifyHostnameTypeFound = true

								if v.(bool) {
									verifyHostnameInt := &ves_io_schema_global_log_receiver.TLSConfigType_EnableVerifyHostname{}
									verifyHostnameInt.EnableVerifyHostname = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyHostname = verifyHostnameInt
								}

							}

						}
					}

				}

				if v, ok := cs["uri"]; ok && !isIntfNil(v) {

					receiverInt.QradarReceiver.Uri = v.(string)

				}

			}
		}

	}

	if v, ok := d.GetOk("s3_receiver"); ok && !isIntfNil(v) && !receiverTypeFound {

		receiverTypeFound = true
		receiverInt := &ves_io_schema_global_log_receiver.ReplaceSpecType_S3Receiver{}
		receiverInt.S3Receiver = &ves_io_schema_global_log_receiver.S3Config{}
		updateSpec.Receiver = receiverInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["aws_cred"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					awsCredInt := &ves_io_schema_views.ObjectRefType{}
					receiverInt.S3Receiver.AwsCred = awsCredInt

					for _, set := range sl {
						if set != nil {
							acMapToStrVal := set.(map[string]interface{})
							if val, ok := acMapToStrVal["name"]; ok && !isIntfNil(v) {
								awsCredInt.Name = val.(string)
							}
							if val, ok := acMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								awsCredInt.Namespace = val.(string)
							}

							if val, ok := acMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								awsCredInt.Tenant = val.(string)
							}
						}
					}

				}

				if v, ok := cs["aws_region"]; ok && !isIntfNil(v) {

					receiverInt.S3Receiver.AwsRegion = v.(string)

				}

				if v, ok := cs["batch"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					batch := &ves_io_schema_global_log_receiver.BatchOptionType{}
					receiverInt.S3Receiver.Batch = batch
					for _, set := range sl {
						if set != nil {
							batchMapStrToI := set.(map[string]interface{})

							batchBytesTypeFound := false

							if v, ok := batchMapStrToI["max_bytes"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true
								batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytes{}

								batch.BatchBytes = batchBytesInt

								batchBytesInt.MaxBytes = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_bytes_disabled"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true

								if v.(bool) {
									batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytesDisabled{}
									batchBytesInt.MaxBytesDisabled = &ves_io_schema.Empty{}
									batch.BatchBytes = batchBytesInt
								}

							}

							batchEventsTypeFound := false

							if v, ok := batchMapStrToI["max_events"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true
								batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEvents{}

								batch.BatchEvents = batchEventsInt

								batchEventsInt.MaxEvents = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_events_disabled"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true

								if v.(bool) {
									batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEventsDisabled{}
									batchEventsInt.MaxEventsDisabled = &ves_io_schema.Empty{}
									batch.BatchEvents = batchEventsInt
								}

							}

							batchTimeoutTypeFound := false

							if v, ok := batchMapStrToI["timeout_seconds"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true
								batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSeconds{}

								batch.BatchTimeout = batchTimeoutInt

								batchTimeoutInt.TimeoutSeconds = uint64(v.(int))

							}

							if v, ok := batchMapStrToI["timeout_seconds_default"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true

								if v.(bool) {
									batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSecondsDefault{}
									batchTimeoutInt.TimeoutSecondsDefault = &ves_io_schema.Empty{}
									batch.BatchTimeout = batchTimeoutInt
								}

							}

						}
					}

				}

				if v, ok := cs["bucket"]; ok && !isIntfNil(v) {

					receiverInt.S3Receiver.Bucket = v.(string)

				}

				if v, ok := cs["compression"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					compression := &ves_io_schema_global_log_receiver.CompressionType{}
					receiverInt.S3Receiver.Compression = compression
					for _, set := range sl {
						if set != nil {
							compressionMapStrToI := set.(map[string]interface{})

							compressionChoiceTypeFound := false

							if v, ok := compressionMapStrToI["compression_default"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionDefault{}
									compressionChoiceInt.CompressionDefault = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_gzip"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionGzip{}
									compressionChoiceInt.CompressionGzip = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_none"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionNone{}
									compressionChoiceInt.CompressionNone = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

						}
					}

				}

				if v, ok := cs["filename_options"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					filenameOptions := &ves_io_schema_global_log_receiver.FilenameOptionsType{}
					receiverInt.S3Receiver.FilenameOptions = filenameOptions
					for _, set := range sl {
						if set != nil {
							filenameOptionsMapStrToI := set.(map[string]interface{})

							folderTypeFound := false

							if v, ok := filenameOptionsMapStrToI["custom_folder"]; ok && !isIntfNil(v) && !folderTypeFound {

								folderTypeFound = true
								folderInt := &ves_io_schema_global_log_receiver.FilenameOptionsType_CustomFolder{}

								filenameOptions.Folder = folderInt

								folderInt.CustomFolder = v.(string)

							}

							if v, ok := filenameOptionsMapStrToI["log_type_folder"]; ok && !isIntfNil(v) && !folderTypeFound {

								folderTypeFound = true

								if v.(bool) {
									folderInt := &ves_io_schema_global_log_receiver.FilenameOptionsType_LogTypeFolder{}
									folderInt.LogTypeFolder = &ves_io_schema.Empty{}
									filenameOptions.Folder = folderInt
								}

							}

							if v, ok := filenameOptionsMapStrToI["no_folder"]; ok && !isIntfNil(v) && !folderTypeFound {

								folderTypeFound = true

								if v.(bool) {
									folderInt := &ves_io_schema_global_log_receiver.FilenameOptionsType_NoFolder{}
									folderInt.NoFolder = &ves_io_schema.Empty{}
									filenameOptions.Folder = folderInt
								}

							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("splunk_receiver"); ok && !isIntfNil(v) && !receiverTypeFound {

		receiverTypeFound = true
		receiverInt := &ves_io_schema_global_log_receiver.ReplaceSpecType_SplunkReceiver{}
		receiverInt.SplunkReceiver = &ves_io_schema_global_log_receiver.SplunkConfig{}
		updateSpec.Receiver = receiverInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["batch"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					batch := &ves_io_schema_global_log_receiver.BatchOptionType{}
					receiverInt.SplunkReceiver.Batch = batch
					for _, set := range sl {
						if set != nil {
							batchMapStrToI := set.(map[string]interface{})

							batchBytesTypeFound := false

							if v, ok := batchMapStrToI["max_bytes"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true
								batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytes{}

								batch.BatchBytes = batchBytesInt

								batchBytesInt.MaxBytes = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_bytes_disabled"]; ok && !isIntfNil(v) && !batchBytesTypeFound {

								batchBytesTypeFound = true

								if v.(bool) {
									batchBytesInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxBytesDisabled{}
									batchBytesInt.MaxBytesDisabled = &ves_io_schema.Empty{}
									batch.BatchBytes = batchBytesInt
								}

							}

							batchEventsTypeFound := false

							if v, ok := batchMapStrToI["max_events"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true
								batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEvents{}

								batch.BatchEvents = batchEventsInt

								batchEventsInt.MaxEvents = uint32(v.(int))

							}

							if v, ok := batchMapStrToI["max_events_disabled"]; ok && !isIntfNil(v) && !batchEventsTypeFound {

								batchEventsTypeFound = true

								if v.(bool) {
									batchEventsInt := &ves_io_schema_global_log_receiver.BatchOptionType_MaxEventsDisabled{}
									batchEventsInt.MaxEventsDisabled = &ves_io_schema.Empty{}
									batch.BatchEvents = batchEventsInt
								}

							}

							batchTimeoutTypeFound := false

							if v, ok := batchMapStrToI["timeout_seconds"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true
								batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSeconds{}

								batch.BatchTimeout = batchTimeoutInt

								batchTimeoutInt.TimeoutSeconds = uint64(v.(int))

							}

							if v, ok := batchMapStrToI["timeout_seconds_default"]; ok && !isIntfNil(v) && !batchTimeoutTypeFound {

								batchTimeoutTypeFound = true

								if v.(bool) {
									batchTimeoutInt := &ves_io_schema_global_log_receiver.BatchOptionType_TimeoutSecondsDefault{}
									batchTimeoutInt.TimeoutSecondsDefault = &ves_io_schema.Empty{}
									batch.BatchTimeout = batchTimeoutInt
								}

							}

						}
					}

				}

				if v, ok := cs["compression"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					compression := &ves_io_schema_global_log_receiver.CompressionType{}
					receiverInt.SplunkReceiver.Compression = compression
					for _, set := range sl {
						if set != nil {
							compressionMapStrToI := set.(map[string]interface{})

							compressionChoiceTypeFound := false

							if v, ok := compressionMapStrToI["compression_default"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionDefault{}
									compressionChoiceInt.CompressionDefault = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_gzip"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionGzip{}
									compressionChoiceInt.CompressionGzip = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

							if v, ok := compressionMapStrToI["compression_none"]; ok && !isIntfNil(v) && !compressionChoiceTypeFound {

								compressionChoiceTypeFound = true

								if v.(bool) {
									compressionChoiceInt := &ves_io_schema_global_log_receiver.CompressionType_CompressionNone{}
									compressionChoiceInt.CompressionNone = &ves_io_schema.Empty{}
									compression.CompressionChoice = compressionChoiceInt
								}

							}

						}
					}

				}

				if v, ok := cs["endpoint"]; ok && !isIntfNil(v) {

					receiverInt.SplunkReceiver.Endpoint = v.(string)

				}

				if v, ok := cs["splunk_hec_token"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					splunkHecToken := &ves_io_schema.SecretType{}
					receiverInt.SplunkReceiver.SplunkHecToken = splunkHecToken
					for _, set := range sl {
						if set != nil {
							splunkHecTokenMapStrToI := set.(map[string]interface{})

							if v, ok := splunkHecTokenMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
								splunkHecToken.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
								for _, set := range sl {
									if set != nil {
										blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

										if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.Location = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.StoreProvider = w.(string)
										}

									}
								}

							}

							if v, ok := splunkHecTokenMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

								splunkHecToken.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

							}

							secretInfoOneofTypeFound := false

							if v, ok := splunkHecTokenMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
								secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
								splunkHecToken.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

										}

										if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

										}

									}
								}

							}

							if v, ok := splunkHecTokenMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
								secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
								splunkHecToken.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["url"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

										}

									}
								}

							}

							if v, ok := splunkHecTokenMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
								secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
								splunkHecToken.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["key"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

										}

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										if v, ok := cs["version"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

										}

									}
								}

							}

							if v, ok := splunkHecTokenMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
								secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
								splunkHecToken.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["name"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

										}

									}
								}

							}

						}
					}

				}

				tlsChoiceTypeFound := false

				if v, ok := cs["no_tls"]; ok && !isIntfNil(v) && !tlsChoiceTypeFound {

					tlsChoiceTypeFound = true

					if v.(bool) {
						tlsChoiceInt := &ves_io_schema_global_log_receiver.SplunkConfig_NoTls{}
						tlsChoiceInt.NoTls = &ves_io_schema.Empty{}
						receiverInt.SplunkReceiver.TlsChoice = tlsChoiceInt
					}

				}

				if v, ok := cs["use_tls"]; ok && !isIntfNil(v) && !tlsChoiceTypeFound {

					tlsChoiceTypeFound = true
					tlsChoiceInt := &ves_io_schema_global_log_receiver.SplunkConfig_UseTls{}
					tlsChoiceInt.UseTls = &ves_io_schema_global_log_receiver.TLSConfigType{}
					receiverInt.SplunkReceiver.TlsChoice = tlsChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							caChoiceTypeFound := false

							if v, ok := cs["no_ca"]; ok && !isIntfNil(v) && !caChoiceTypeFound {

								caChoiceTypeFound = true

								if v.(bool) {
									caChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_NoCa{}
									caChoiceInt.NoCa = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.CaChoice = caChoiceInt
								}

							}

							if v, ok := cs["trusted_ca_url"]; ok && !isIntfNil(v) && !caChoiceTypeFound {

								caChoiceTypeFound = true
								caChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_TrustedCaUrl{}

								tlsChoiceInt.UseTls.CaChoice = caChoiceInt

								caChoiceInt.TrustedCaUrl = v.(string)

							}

							mtlsChoiceTypeFound := false

							if v, ok := cs["mtls_disabled"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

								mtlsChoiceTypeFound = true

								if v.(bool) {
									mtlsChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_MtlsDisabled{}
									mtlsChoiceInt.MtlsDisabled = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt
								}

							}

							if v, ok := cs["mtls_enable"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

								mtlsChoiceTypeFound = true
								mtlsChoiceInt := &ves_io_schema_global_log_receiver.TLSConfigType_MtlsEnable{}
								mtlsChoiceInt.MtlsEnable = &ves_io_schema_global_log_receiver.TLSClientConfigType{}
								tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["certificate"]; ok && !isIntfNil(v) {

											mtlsChoiceInt.MtlsEnable.Certificate = v.(string)

										}

										if v, ok := cs["key_url"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											keyUrl := &ves_io_schema.SecretType{}
											mtlsChoiceInt.MtlsEnable.KeyUrl = keyUrl
											for _, set := range sl {
												if set != nil {
													keyUrlMapStrToI := set.(map[string]interface{})

													if v, ok := keyUrlMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
														keyUrl.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
														for _, set := range sl {
															if set != nil {
																blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.Location = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.StoreProvider = w.(string)
																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

														keyUrl.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													secretInfoOneofTypeFound := false

													if v, ok := keyUrlMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
														secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																}

																if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
														secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["url"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
														secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["key"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																}

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																}

																if v, ok := cs["version"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																}

															}
														}

													}

													if v, ok := keyUrlMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
														secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
														keyUrl.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																}

															}
														}

													}

												}
											}

										}

									}
								}

							}

							verifyCertificateTypeFound := false

							if v, ok := cs["disable_verify_certificate"]; ok && !isIntfNil(v) && !verifyCertificateTypeFound {

								verifyCertificateTypeFound = true

								if v.(bool) {
									verifyCertificateInt := &ves_io_schema_global_log_receiver.TLSConfigType_DisableVerifyCertificate{}
									verifyCertificateInt.DisableVerifyCertificate = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyCertificate = verifyCertificateInt
								}

							}

							if v, ok := cs["enable_verify_certificate"]; ok && !isIntfNil(v) && !verifyCertificateTypeFound {

								verifyCertificateTypeFound = true

								if v.(bool) {
									verifyCertificateInt := &ves_io_schema_global_log_receiver.TLSConfigType_EnableVerifyCertificate{}
									verifyCertificateInt.EnableVerifyCertificate = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyCertificate = verifyCertificateInt
								}

							}

							verifyHostnameTypeFound := false

							if v, ok := cs["disable_verify_hostname"]; ok && !isIntfNil(v) && !verifyHostnameTypeFound {

								verifyHostnameTypeFound = true

								if v.(bool) {
									verifyHostnameInt := &ves_io_schema_global_log_receiver.TLSConfigType_DisableVerifyHostname{}
									verifyHostnameInt.DisableVerifyHostname = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyHostname = verifyHostnameInt
								}

							}

							if v, ok := cs["enable_verify_hostname"]; ok && !isIntfNil(v) && !verifyHostnameTypeFound {

								verifyHostnameTypeFound = true

								if v.(bool) {
									verifyHostnameInt := &ves_io_schema_global_log_receiver.TLSConfigType_EnableVerifyHostname{}
									verifyHostnameInt.EnableVerifyHostname = &ves_io_schema.Empty{}
									tlsChoiceInt.UseTls.VerifyHostname = verifyHostnameInt
								}

							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("sumo_logic_receiver"); ok && !isIntfNil(v) && !receiverTypeFound {

		receiverTypeFound = true
		receiverInt := &ves_io_schema_global_log_receiver.ReplaceSpecType_SumoLogicReceiver{}
		receiverInt.SumoLogicReceiver = &ves_io_schema_global_log_receiver.SumoLogicConfig{}
		updateSpec.Receiver = receiverInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["url"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					url := &ves_io_schema.SecretType{}
					receiverInt.SumoLogicReceiver.Url = url
					for _, set := range sl {
						if set != nil {
							urlMapStrToI := set.(map[string]interface{})

							if v, ok := urlMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
								url.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
								for _, set := range sl {
									if set != nil {
										blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

										if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.Location = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.StoreProvider = w.(string)
										}

									}
								}

							}

							if v, ok := urlMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

								url.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

							}

							secretInfoOneofTypeFound := false

							if v, ok := urlMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
								secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
								url.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

										}

										if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

										}

									}
								}

							}

							if v, ok := urlMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
								secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
								url.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["url"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

										}

									}
								}

							}

							if v, ok := urlMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
								secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
								url.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["key"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

										}

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										if v, ok := cs["version"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

										}

									}
								}

							}

							if v, ok := urlMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
								secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
								url.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["name"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

										}

									}
								}

							}

						}
					}

				}

			}
		}

	}

	log.Printf("[DEBUG] Updating Volterra GlobalLogReceiver obj with struct: %+v", updateReq)

	err := client.ReplaceObject(context.Background(), ves_io_schema_global_log_receiver.ObjectType, updateReq)
	if err != nil {
		return fmt.Errorf("error updating GlobalLogReceiver: %s", err)
	}

	return resourceVolterraGlobalLogReceiverRead(d, meta)
}

func resourceVolterraGlobalLogReceiverDelete(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	_, err := client.GetObject(context.Background(), ves_io_schema_global_log_receiver.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] GlobalLogReceiver %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra GlobalLogReceiver before deleting %q: %s", d.Id(), err)
	}

	log.Printf("[DEBUG] Deleting Volterra GlobalLogReceiver obj with name %+v in namespace %+v", name, namespace)
	opts := []vesapi.CallOpt{
		vesapi.WithFailIfReferred(),
	}
	return client.DeleteObject(context.Background(), ves_io_schema_global_log_receiver.ObjectType, namespace, name, opts...)
}
