//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-tf-provider. DO NOT EDIT.
//

package volterra

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/helper/schema"
	"gopkg.volterra.us/stdlib/client/vesapi"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_bgp "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/bgp"
	ves_io_schema_fleet "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/fleet"
	ves_io_schema_network_firewall "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/network_firewall"
	ves_io_schema_network_interface "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/network_interface"
	ves_io_schema_site "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/site"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	ves_io_schema_views_voltstack_site "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/voltstack_site"
	ves_io_schema_virtual_network "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/virtual_network"
)

// resourceVolterraVoltstackSite is implementation of Volterra's VoltstackSite resources
func resourceVolterraVoltstackSite() *schema.Resource {
	return &schema.Resource{
		Create: resourceVolterraVoltstackSiteCreate,
		Read:   resourceVolterraVoltstackSiteRead,
		Update: resourceVolterraVoltstackSiteUpdate,
		Delete: resourceVolterraVoltstackSiteDelete,

		Schema: map[string]*schema.Schema{

			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"description": {
				Type:     schema.TypeString,
				Optional: true,
			},

			"disable": {
				Type:     schema.TypeBool,
				Optional: true,
			},

			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"namespace": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"address": {
				Type:     schema.TypeString,
				Optional: true,
			},

			"blocked_services": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"blocked_sevice": {

							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"dns": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"ssh": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"web_user_interface": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"network_type": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"default_blocked_services": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"bond_device_list": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"bond_devices": {

							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"devices": {

										Type: schema.TypeList,

										Required: true,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},

									"active_backup": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"lacp": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"rate": {
													Type:     schema.TypeInt,
													Optional: true,
												},
											},
										},
									},

									"link_polling_interval": {
										Type:     schema.TypeInt,
										Optional: true,
									},

									"link_up_delay": {
										Type:     schema.TypeInt,
										Optional: true,
									},

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"no_bond_devices": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"coordinates": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"latitude": {
							Type:     schema.TypeFloat,
							Optional: true,
						},

						"longitude": {
							Type:     schema.TypeFloat,
							Optional: true,
						},
					},
				},
			},

			"disable_gpu": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"enable_gpu": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"enable_vgpu": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"feature_type": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"server_address": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"server_port": {
							Type:     schema.TypeInt,
							Optional: true,
						},
					},
				},
			},

			"k8s_cluster": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"name": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"namespace": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"tenant": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"no_k8s_cluster": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"local_control_plane": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"bgp_config": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"asn": {
										Type:     schema.TypeInt,
										Optional: true,
									},

									"peers": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{},
										},
									},
								},
							},
						},

						"inside_vn": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"outside_vn": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"no_local_control_plane": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"log_receiver": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"name": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"namespace": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"tenant": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"logs_streaming_disabled": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"master_nodes": {

				Type: schema.TypeList,

				Required: true,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},

			"custom_network_config": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"bgp_peer_address": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"bgp_router_id": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"active_forward_proxy_policies": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"forward_proxy_policies": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"forward_proxy_allow_all": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"no_forward_proxy": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"global_network_list": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"global_network_connections": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"sli_to_global_dr": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"global_vn": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"kind": {
																			Type:     schema.TypeString,
																			Computed: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},

												"slo_to_global_dr": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"global_vn": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"kind": {
																			Type:     schema.TypeString,
																			Computed: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},

												"disable_forward_proxy": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"enable_forward_proxy": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"connection_timeout": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"max_connect_attempts": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"no_interception": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"tls_intercept": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"enable_for_all_domains": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"policy": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interception_rules": {

																						Type:     schema.TypeList,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"domain_match": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"exact_value": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"regex_value": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"suffix_value": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},
																										},
																									},
																								},

																								"disable_interception": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"enable_interception": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"custom_certificate": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"certificate_url": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"description": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"custom_hash_algorithms": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"hash_algorithms": {

																									Type: schema.TypeList,

																									Required: true,
																									Elem: &schema.Schema{
																										Type: schema.TypeString,
																									},
																								},
																							},
																						},
																					},

																					"disable_ocsp_stapling": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{},
																						},
																					},

																					"use_system_defaults": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{},
																						},
																					},

																					"private_key": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"blindfold_secret_info_internal": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"decryption_provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"location": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"store_provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},
																										},
																									},
																								},

																								"secret_encoding_type": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"blindfold_secret_info": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"decryption_provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"location": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"store_provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},
																										},
																									},
																								},

																								"clear_secret_info": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"url": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},
																										},
																									},
																								},

																								"vault_secret_info": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"key": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"location": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"secret_encoding": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"version": {
																												Type:     schema.TypeInt,
																												Optional: true,
																											},
																										},
																									},
																								},

																								"wingman_secret_info": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"name": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"volterra_certificate": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"trusted_ca_url": {

																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"volterra_trusted_ca": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},
																	},
																},
															},

															"white_listed_ports": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeInt,
																},
															},

															"white_listed_prefixes": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"no_global_network": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"default_interface_config": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"interface_list": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"interfaces": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"description": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"dedicated_interface": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"device": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"monitor": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{},
																},
															},

															"monitor_disabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"mtu": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"cluster": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"node": {

																Type:     schema.TypeString,
																Optional: true,
															},

															"is_primary": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"not_primary": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"priority": {
																Type:     schema.TypeInt,
																Optional: true,
															},
														},
													},
												},

												"dedicated_management_interface": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"device": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"mtu": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"cluster": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"node": {

																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"ethernet_interface": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"dhcp_client": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"dhcp_server": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"dhcp_networks": {

																			Type:     schema.TypeList,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"dns_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"same_as_dgw": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"dgw_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"first_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"last_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"network_prefix": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"network_prefix_allocator": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																								"namespace": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																								"tenant": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"pool_settings": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"pools": {

																						Type:     schema.TypeList,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"end_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"exclude": {
																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"start_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"dhcp_option82_tag": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"fixed_ip_map": {
																			Type:     schema.TypeMap,
																			Optional: true,
																		},

																		"automatic_from_end": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"automatic_from_start": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"interface_ip_map": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {
																						Type:     schema.TypeMap,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"static_ip": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"cluster_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																								"value": {
																									Type:     schema.TypeSet,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"default_gw": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"dns_server": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"ip_address": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"fleet_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"network_prefix_allocator": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																								"namespace": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																								"tenant": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"node_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"ip_address": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"device": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"no_ipv6_address": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"static_ipv6_address": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"cluster_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																								"value": {
																									Type:     schema.TypeSet,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"default_gw": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"dns_server": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"ip_address": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"fleet_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"network_prefix_allocator": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																								"namespace": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																								"tenant": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"node_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"ip_address": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"monitor": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{},
																},
															},

															"monitor_disabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"mtu": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"inside_network": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"site_local_inside_network": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"site_local_network": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"srv6_network": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"storage_network": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"cluster": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"node": {

																Type:     schema.TypeString,
																Optional: true,
															},

															"is_primary": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"not_primary": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"priority": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"untagged": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"vlan_id": {

																Type:     schema.TypeInt,
																Optional: true,
															},
														},
													},
												},

												"tunnel_interface": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"mtu": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"inside_network": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"site_local_inside_network": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"site_local_network": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"cluster": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"node": {

																Type:     schema.TypeString,
																Optional: true,
															},

															"priority": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"static_ip": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"cluster_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																								"value": {
																									Type:     schema.TypeSet,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"default_gw": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"dns_server": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"ip_address": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"fleet_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"network_prefix_allocator": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																								"namespace": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																								"tenant": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"node_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"ip_address": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"tunnel": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},

												"labels": {
													Type:     schema.TypeMap,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"active_network_policies": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"network_policies": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"no_network_policy": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"outside_nameserver": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"outside_vip": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"site_to_site_tunnel_ip": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"default_sli_config": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"sli_config": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"no_static_routes": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"static_routes": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"static_routes": {

													Type:     schema.TypeList,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"attrs": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"ip_prefixes": {

																Type: schema.TypeList,

																Required: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"default_gateway": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"ip_address": {

																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"default_config": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"slo_config": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"dc_cluster_group": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},

									"no_dc_cluster_group": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"labels": {
										Type:     schema.TypeMap,
										Optional: true,
									},

									"no_static_routes": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"static_routes": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"static_routes": {

													Type:     schema.TypeList,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"attrs": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"ip_prefixes": {

																Type: schema.TypeList,

																Required: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"default_gateway": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"ip_address": {

																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"tunnel_dead_timeout": {
							Type:     schema.TypeInt,
							Optional: true,
						},

						"vip_vrrp_mode": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"default_network_config": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"os": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"default_os_version": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"operating_system_version": {

							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"custom_storage_config": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"no_static_routes": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"static_routes": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"static_routes": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"attrs": {

													Type: schema.TypeList,

													Optional: true,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},

												"ip_prefixes": {

													Type: schema.TypeList,

													Required: true,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},

												"default_gateway": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"interface": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"name": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"namespace": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"tenant": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"ip_address": {

													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"default_storage_class": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"storage_class_list": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"storage_classes": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"advanced_storage_parameters": {
													Type:     schema.TypeMap,
													Optional: true,
												},

												"allow_volume_expansion": {
													Type:     schema.TypeBool,
													Optional: true,
												},

												"default_storage_class": {
													Type:     schema.TypeBool,
													Optional: true,
												},

												"description": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"custom_storage": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"yaml": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"netapp_trident": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"selector": {
																Type:     schema.TypeMap,
																Optional: true,
															},

															"storage_pools": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"openebs_enterprise": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"protocol": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"replication": {
																Type:     schema.TypeInt,
																Optional: true,
															},
														},
													},
												},

												"pure_service_orchestrator": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"backend": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"bandwidth_limit": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"iops_limit": {
																Type:     schema.TypeInt,
																Optional: true,
															},
														},
													},
												},

												"reclaim_policy": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"storage_class_name": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"storage_device": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"no_storage_device": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"storage_device_list": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"storage_devices": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"advanced_advanced_parameters": {
													Type:     schema.TypeMap,
													Optional: true,
												},

												"custom_storage": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"netapp_trident": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"netapp_backend_ontap_nas": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"auto_export_cidrs": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"prefixes": {

																						Type: schema.TypeList,

																						Required: true,
																						Elem: &schema.Schema{
																							Type: schema.TypeString,
																						},
																					},
																				},
																			},
																		},

																		"auto_export_policy": {
																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"backend_name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"client_certificate": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"client_private_key": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"blindfold_secret_info_internal": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"decryption_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"location": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"store_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"secret_encoding_type": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"blindfold_secret_info": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"decryption_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"location": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"store_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"clear_secret_info": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"url": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"vault_secret_info": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"key": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"location": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"secret_encoding": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"version": {
																									Type:     schema.TypeInt,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"wingman_secret_info": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"data_lif_dns_name": {

																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"data_lif_ip": {

																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"labels": {
																			Type:     schema.TypeMap,
																			Optional: true,
																		},

																		"limit_aggregate_usage": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"limit_volume_size": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"management_lif_dns_name": {

																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"management_lif_ip": {

																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"nfs_mount_options": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"password": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"blindfold_secret_info_internal": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"decryption_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"location": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"store_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"secret_encoding_type": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"blindfold_secret_info": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"decryption_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"location": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"store_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"clear_secret_info": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"url": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"vault_secret_info": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"key": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"location": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"secret_encoding": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"version": {
																									Type:     schema.TypeInt,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"wingman_secret_info": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"region": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"storage": {

																			Type:     schema.TypeList,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"labels": {
																						Type:     schema.TypeMap,
																						Optional: true,
																					},

																					"volume_defaults": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"encryption": {
																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"export_policy": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"adaptive_qos_policy": {

																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"no_qos": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"qos_policy": {

																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"security_style": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"snapshot_dir": {
																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"snapshot_policy": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"snapshot_reserve": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"space_reserve": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"split_on_clone": {
																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"tiering_policy": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"unix_permissions": {
																									Type:     schema.TypeInt,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"zone": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"storage_driver_name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"storage_prefix": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"svm": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"trusted_ca_certificate": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"username": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"volume_defaults": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"encryption": {
																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"export_policy": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"adaptive_qos_policy": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"no_qos": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"qos_policy": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"security_style": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"snapshot_dir": {
																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"snapshot_policy": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"snapshot_reserve": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"space_reserve": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"split_on_clone": {
																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"tiering_policy": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"unix_permissions": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"netapp_backend_ontap_san": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"no_chap": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"use_chap": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"chap_initiator_secret": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"blindfold_secret_info_internal": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"decryption_provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"location": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"store_provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},
																										},
																									},
																								},

																								"secret_encoding_type": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"blindfold_secret_info": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"decryption_provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"location": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"store_provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},
																										},
																									},
																								},

																								"clear_secret_info": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"url": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},
																										},
																									},
																								},

																								"vault_secret_info": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"key": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"location": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"secret_encoding": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"version": {
																												Type:     schema.TypeInt,
																												Optional: true,
																											},
																										},
																									},
																								},

																								"wingman_secret_info": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"name": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},

																					"chap_target_initiator_secret": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"blindfold_secret_info_internal": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"decryption_provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"location": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"store_provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},
																										},
																									},
																								},

																								"secret_encoding_type": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"blindfold_secret_info": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"decryption_provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"location": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"store_provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},
																										},
																									},
																								},

																								"clear_secret_info": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"url": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},
																										},
																									},
																								},

																								"vault_secret_info": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"key": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"location": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"secret_encoding": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"version": {
																												Type:     schema.TypeInt,
																												Optional: true,
																											},
																										},
																									},
																								},

																								"wingman_secret_info": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"name": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},

																					"chap_target_username": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"chap_username": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"client_certificate": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"client_private_key": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"blindfold_secret_info_internal": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"decryption_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"location": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"store_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"secret_encoding_type": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"blindfold_secret_info": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"decryption_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"location": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"store_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"clear_secret_info": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"url": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"vault_secret_info": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"key": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"location": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"secret_encoding": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"version": {
																									Type:     schema.TypeInt,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"wingman_secret_info": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"data_lif_dns_name": {

																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"data_lif_ip": {

																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"igroup_name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"labels": {
																			Type:     schema.TypeMap,
																			Optional: true,
																		},

																		"limit_aggregate_usage": {
																			Type:     schema.TypeInt,
																			Optional: true,
																		},

																		"limit_volume_size": {
																			Type:     schema.TypeInt,
																			Optional: true,
																		},

																		"management_lif_dns_name": {

																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"management_lif_ip": {

																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"password": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"blindfold_secret_info_internal": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"decryption_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"location": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"store_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"secret_encoding_type": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"blindfold_secret_info": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"decryption_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"location": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"store_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"clear_secret_info": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"url": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"vault_secret_info": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"key": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"location": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"secret_encoding": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"version": {
																									Type:     schema.TypeInt,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"wingman_secret_info": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"region": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"storage": {

																			Type:     schema.TypeList,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"labels": {
																						Type:     schema.TypeMap,
																						Optional: true,
																					},

																					"volume_defaults": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"encryption": {
																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"export_policy": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"adaptive_qos_policy": {

																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"no_qos": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"qos_policy": {

																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"security_style": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"snapshot_dir": {
																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"snapshot_policy": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"snapshot_reserve": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"space_reserve": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"split_on_clone": {
																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"tiering_policy": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"unix_permissions": {
																									Type:     schema.TypeInt,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"zone": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"storage_driver_name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"storage_prefix": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"svm": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"trusted_ca_certificate": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"username": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"volume_defaults": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"encryption": {
																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"export_policy": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"adaptive_qos_policy": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"no_qos": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"qos_policy": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"security_style": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"snapshot_dir": {
																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"snapshot_policy": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"snapshot_reserve": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"space_reserve": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"split_on_clone": {
																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"tiering_policy": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"unix_permissions": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},

												"openebs_enterprise": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"mayastor_pools": {

																Type:     schema.TypeList,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"node": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"pool_disk_devices": {

																			Type: schema.TypeList,

																			Required: true,
																			Elem: &schema.Schema{
																				Type: schema.TypeString,
																			},
																		},

																		"pool_name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},

												"pure_service_orchestrator": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"arrays": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"flash_array": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_fs_opt": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"default_fs_type": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"default_mount_opts": {

																						Type: schema.TypeList,

																						Optional: true,
																						Elem: &schema.Schema{
																							Type: schema.TypeString,
																						},
																					},

																					"disable_preempt_attachments": {
																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"flash_arrays": {

																						Type:     schema.TypeList,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"api_token": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"blindfold_secret_info_internal": {

																												Type:     schema.TypeSet,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"decryption_provider": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"location": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"store_provider": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},
																													},
																												},
																											},

																											"secret_encoding_type": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"blindfold_secret_info": {

																												Type:     schema.TypeSet,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"decryption_provider": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"location": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"store_provider": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},
																													},
																												},
																											},

																											"clear_secret_info": {

																												Type:     schema.TypeSet,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"provider": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"url": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},
																													},
																												},
																											},

																											"vault_secret_info": {

																												Type:     schema.TypeSet,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"key": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"location": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"provider": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"secret_encoding": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"version": {
																															Type:     schema.TypeInt,
																															Optional: true,
																														},
																													},
																												},
																											},

																											"wingman_secret_info": {

																												Type:     schema.TypeSet,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"name": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},
																													},
																												},
																											},
																										},
																									},
																								},

																								"labels": {
																									Type:     schema.TypeMap,
																									Optional: true,
																								},

																								"mgmt_dns_name": {

																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"mgmt_ip": {

																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"iscsi_login_timeout": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},

																					"san_type": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"flash_blade": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"enable_snapshot_directory": {
																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"export_rules": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"flash_blades": {

																						Type:     schema.TypeList,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"api_token": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"blindfold_secret_info_internal": {

																												Type:     schema.TypeSet,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"decryption_provider": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"location": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"store_provider": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},
																													},
																												},
																											},

																											"secret_encoding_type": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"blindfold_secret_info": {

																												Type:     schema.TypeSet,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"decryption_provider": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"location": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"store_provider": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},
																													},
																												},
																											},

																											"clear_secret_info": {

																												Type:     schema.TypeSet,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"provider": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"url": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},
																													},
																												},
																											},

																											"vault_secret_info": {

																												Type:     schema.TypeSet,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"key": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"location": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"provider": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"secret_encoding": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"version": {
																															Type:     schema.TypeInt,
																															Optional: true,
																														},
																													},
																												},
																											},

																											"wingman_secret_info": {

																												Type:     schema.TypeSet,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"name": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},
																													},
																												},
																											},
																										},
																									},
																								},

																								"lables": {
																									Type:     schema.TypeMap,
																									Optional: true,
																								},

																								"mgmt_dns_name": {

																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"mgmt_ip": {

																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"nfs_endpoint_dns_name": {

																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"nfs_endpoint_ip": {

																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},

															"cluster_id": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"enable_storage_topology": {
																Type:     schema.TypeBool,
																Optional: true,
															},

															"enable_strict_topology": {
																Type:     schema.TypeBool,
																Optional: true,
															},
														},
													},
												},

												"storage_device": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"no_storage_interfaces": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"storage_interface_list": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"storage_interfaces": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"description": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"labels": {
													Type:     schema.TypeMap,
													Optional: true,
												},

												"storage_interface": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"dhcp_client": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"dhcp_server": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"dhcp_networks": {

																			Type:     schema.TypeList,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"dns_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"same_as_dgw": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"dgw_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"first_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"last_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"network_prefix": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"network_prefix_allocator": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																								"namespace": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																								"tenant": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"pool_settings": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"pools": {

																						Type:     schema.TypeList,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"end_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"exclude": {
																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"start_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"dhcp_option82_tag": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"fixed_ip_map": {
																			Type:     schema.TypeMap,
																			Optional: true,
																		},

																		"automatic_from_end": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"automatic_from_start": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"interface_ip_map": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {
																						Type:     schema.TypeMap,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"static_ip": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"cluster_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																								"value": {
																									Type:     schema.TypeSet,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"default_gw": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"dns_server": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"ip_address": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"fleet_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"network_prefix_allocator": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																								"namespace": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																								"tenant": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"node_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"ip_address": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"device": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"no_ipv6_address": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"static_ipv6_address": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"cluster_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																								"value": {
																									Type:     schema.TypeSet,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"default_gw": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"dns_server": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"ip_address": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"fleet_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"network_prefix_allocator": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																								"namespace": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																								"tenant": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"node_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"ip_address": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"monitor": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{},
																},
															},

															"monitor_disabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"mtu": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"inside_network": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"site_local_inside_network": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"site_local_network": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"srv6_network": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"storage_network": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"cluster": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"node": {

																Type:     schema.TypeString,
																Optional: true,
															},

															"is_primary": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"not_primary": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"priority": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"untagged": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"vlan_id": {

																Type:     schema.TypeInt,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},

			"default_storage_config": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"sw": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"default_sw_version": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"volterra_software_version": {

							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"allow_all_usb": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"deny_all_usb": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"usb_policy": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"name": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"namespace": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"tenant": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"disable_vm": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"enable_vm": {
				Type:     schema.TypeBool,
				Optional: true,
			},

			"volterra_certified_hw": {
				Type:     schema.TypeString,
				Required: true,
			},

			"worker_nodes": {

				Type: schema.TypeList,

				Optional: true,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
		},
	}
}

// resourceVolterraVoltstackSiteCreate creates VoltstackSite resource
func resourceVolterraVoltstackSiteCreate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	createMeta := &ves_io_schema.ObjectCreateMetaType{}
	createSpec := &ves_io_schema_views_voltstack_site.CreateSpecType{}
	createReq := &ves_io_schema_views_voltstack_site.CreateRequest{
		Metadata: createMeta,
		Spec:     createSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		createMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		createMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		createMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		createMeta.Namespace =
			v.(string)
	}

	//address
	if v, ok := d.GetOk("address"); ok && !isIntfNil(v) {

		createSpec.Address =
			v.(string)

	}

	//blocked_services_choice

	blockedServicesChoiceTypeFound := false

	if v, ok := d.GetOk("blocked_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true
		blockedServicesChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_BlockedServices{}
		blockedServicesChoiceInt.BlockedServices = &ves_io_schema_fleet.BlockedServicesListType{}
		createSpec.BlockedServicesChoice = blockedServicesChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["blocked_sevice"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				blockedSevice := make([]*ves_io_schema_fleet.BlockedServices, len(sl))
				blockedServicesChoiceInt.BlockedServices.BlockedSevice = blockedSevice
				for i, set := range sl {
					blockedSevice[i] = &ves_io_schema_fleet.BlockedServices{}
					blockedSeviceMapStrToI := set.(map[string]interface{})

					blockedServicesValueTypeChoiceTypeFound := false

					if v, ok := blockedSeviceMapStrToI["dns"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

						blockedServicesValueTypeChoiceTypeFound = true

						if v.(bool) {
							blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Dns{}
							blockedServicesValueTypeChoiceInt.Dns = &ves_io_schema.Empty{}
							blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
						}

					}

					if v, ok := blockedSeviceMapStrToI["ssh"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

						blockedServicesValueTypeChoiceTypeFound = true

						if v.(bool) {
							blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Ssh{}
							blockedServicesValueTypeChoiceInt.Ssh = &ves_io_schema.Empty{}
							blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
						}

					}

					if v, ok := blockedSeviceMapStrToI["web_user_interface"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

						blockedServicesValueTypeChoiceTypeFound = true

						if v.(bool) {
							blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_WebUserInterface{}
							blockedServicesValueTypeChoiceInt.WebUserInterface = &ves_io_schema.Empty{}
							blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
						}

					}

					if v, ok := blockedSeviceMapStrToI["network_type"]; ok && !isIntfNil(v) {

						blockedSevice[i].NetworkType = ves_io_schema.VirtualNetworkType(ves_io_schema.VirtualNetworkType_value[v.(string)])

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("default_blocked_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true

		if v.(bool) {
			blockedServicesChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_DefaultBlockedServices{}
			blockedServicesChoiceInt.DefaultBlockedServices = &ves_io_schema.Empty{}
			createSpec.BlockedServicesChoice = blockedServicesChoiceInt
		}

	}

	//bond_choice

	bondChoiceTypeFound := false

	if v, ok := d.GetOk("bond_device_list"); ok && !bondChoiceTypeFound {

		bondChoiceTypeFound = true
		bondChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_BondDeviceList{}
		bondChoiceInt.BondDeviceList = &ves_io_schema_fleet.FleetBondDevicesListType{}
		createSpec.BondChoice = bondChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["bond_devices"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				bondDevices := make([]*ves_io_schema_fleet.FleetBondDeviceType, len(sl))
				bondChoiceInt.BondDeviceList.BondDevices = bondDevices
				for i, set := range sl {
					bondDevices[i] = &ves_io_schema_fleet.FleetBondDeviceType{}
					bondDevicesMapStrToI := set.(map[string]interface{})

					if w, ok := bondDevicesMapStrToI["devices"]; ok && !isIntfNil(w) {
						ls := make([]string, len(w.([]interface{})))
						for i, v := range w.([]interface{}) {
							ls[i] = v.(string)
						}
						bondDevices[i].Devices = ls
					}

					lacpChoiceTypeFound := false

					if v, ok := bondDevicesMapStrToI["active_backup"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

						lacpChoiceTypeFound = true

						if v.(bool) {
							lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_ActiveBackup{}
							lacpChoiceInt.ActiveBackup = &ves_io_schema.Empty{}
							bondDevices[i].LacpChoice = lacpChoiceInt
						}

					}

					if v, ok := bondDevicesMapStrToI["lacp"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

						lacpChoiceTypeFound = true
						lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_Lacp{}
						lacpChoiceInt.Lacp = &ves_io_schema_fleet.BondLacpType{}
						bondDevices[i].LacpChoice = lacpChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["rate"]; ok && !isIntfNil(v) {

								lacpChoiceInt.Lacp.Rate = uint32(v.(int))

							}

						}

					}

					if w, ok := bondDevicesMapStrToI["link_polling_interval"]; ok && !isIntfNil(w) {
						bondDevices[i].LinkPollingInterval = uint32(w.(int))
					}

					if w, ok := bondDevicesMapStrToI["link_up_delay"]; ok && !isIntfNil(w) {
						bondDevices[i].LinkUpDelay = uint32(w.(int))
					}

					if w, ok := bondDevicesMapStrToI["name"]; ok && !isIntfNil(w) {
						bondDevices[i].Name = w.(string)
					}

				}

			}

		}

	}

	if v, ok := d.GetOk("no_bond_devices"); ok && !bondChoiceTypeFound {

		bondChoiceTypeFound = true

		if v.(bool) {
			bondChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_NoBondDevices{}
			bondChoiceInt.NoBondDevices = &ves_io_schema.Empty{}
			createSpec.BondChoice = bondChoiceInt
		}

	}

	//coordinates
	if v, ok := d.GetOk("coordinates"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		coordinates := &ves_io_schema_site.Coordinates{}
		createSpec.Coordinates = coordinates
		for _, set := range sl {
			coordinatesMapStrToI := set.(map[string]interface{})

			if w, ok := coordinatesMapStrToI["latitude"]; ok && !isIntfNil(w) {
				coordinates.Latitude = float32(w.(float64))
			}

			if w, ok := coordinatesMapStrToI["longitude"]; ok && !isIntfNil(w) {
				coordinates.Longitude = float32(w.(float64))
			}

		}

	}

	//gpu_choice

	gpuChoiceTypeFound := false

	if v, ok := d.GetOk("disable_gpu"); ok && !gpuChoiceTypeFound {

		gpuChoiceTypeFound = true

		if v.(bool) {
			gpuChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_DisableGpu{}
			gpuChoiceInt.DisableGpu = &ves_io_schema.Empty{}
			createSpec.GpuChoice = gpuChoiceInt
		}

	}

	if v, ok := d.GetOk("enable_gpu"); ok && !gpuChoiceTypeFound {

		gpuChoiceTypeFound = true

		if v.(bool) {
			gpuChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_EnableGpu{}
			gpuChoiceInt.EnableGpu = &ves_io_schema.Empty{}
			createSpec.GpuChoice = gpuChoiceInt
		}

	}

	if v, ok := d.GetOk("enable_vgpu"); ok && !gpuChoiceTypeFound {

		gpuChoiceTypeFound = true
		gpuChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_EnableVgpu{}
		gpuChoiceInt.EnableVgpu = &ves_io_schema_fleet.VGPUConfiguration{}
		createSpec.GpuChoice = gpuChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["feature_type"]; ok && !isIntfNil(v) {

				gpuChoiceInt.EnableVgpu.FeatureType = ves_io_schema_fleet.VGPUFeatureType(ves_io_schema_fleet.VGPUFeatureType_value[v.(string)])

			}

			if v, ok := cs["server_address"]; ok && !isIntfNil(v) {

				gpuChoiceInt.EnableVgpu.ServerAddress = v.(string)

			}

			if v, ok := cs["server_port"]; ok && !isIntfNil(v) {

				gpuChoiceInt.EnableVgpu.ServerPort = uint32(v.(int))

			}

		}

	}

	//k8s_cluster_choice

	k8SClusterChoiceTypeFound := false

	if v, ok := d.GetOk("k8s_cluster"); ok && !k8SClusterChoiceTypeFound {

		k8SClusterChoiceTypeFound = true
		k8SClusterChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_K8SCluster{}
		k8SClusterChoiceInt.K8SCluster = &ves_io_schema_views.ObjectRefType{}
		createSpec.K8SClusterChoice = k8SClusterChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["name"]; ok && !isIntfNil(v) {

				k8SClusterChoiceInt.K8SCluster.Name = v.(string)

			}

			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

				k8SClusterChoiceInt.K8SCluster.Namespace = v.(string)

			}

			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

				k8SClusterChoiceInt.K8SCluster.Tenant = v.(string)

			}

		}

	}

	if v, ok := d.GetOk("no_k8s_cluster"); ok && !k8SClusterChoiceTypeFound {

		k8SClusterChoiceTypeFound = true

		if v.(bool) {
			k8SClusterChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_NoK8SCluster{}
			k8SClusterChoiceInt.NoK8SCluster = &ves_io_schema.Empty{}
			createSpec.K8SClusterChoice = k8SClusterChoiceInt
		}

	}

	//local_control_plane_choice

	localControlPlaneChoiceTypeFound := false

	if v, ok := d.GetOk("local_control_plane"); ok && !localControlPlaneChoiceTypeFound {

		localControlPlaneChoiceTypeFound = true
		localControlPlaneChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_LocalControlPlane{}
		localControlPlaneChoiceInt.LocalControlPlane = &ves_io_schema_fleet.LocalControlPlaneType{}
		createSpec.LocalControlPlaneChoice = localControlPlaneChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["bgp_config"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				bgpConfig := &ves_io_schema_fleet.BGPConfiguration{}
				localControlPlaneChoiceInt.LocalControlPlane.BgpConfig = bgpConfig
				for _, set := range sl {
					bgpConfigMapStrToI := set.(map[string]interface{})

					if w, ok := bgpConfigMapStrToI["asn"]; ok && !isIntfNil(w) {
						bgpConfig.Asn = uint32(w.(int))
					}

					if v, ok := bgpConfigMapStrToI["peers"]; ok && !isIntfNil(v) {

						//sl := v.([]interface{})
						peers := make([]*ves_io_schema_bgp.Peer, len(sl))
						bgpConfig.Peers = peers
						/*
							for i, set := range sl {
								peers[i] = &ves_io_schema_bgp.Peer{}
								peersMapStrToI := set.(map[string]interface{})

							}
						*/

					}

				}

			}

			networkChoiceTypeFound := false

			if v, ok := cs["inside_vn"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

				networkChoiceTypeFound = true

				if v.(bool) {
					networkChoiceInt := &ves_io_schema_fleet.LocalControlPlaneType_InsideVn{}
					networkChoiceInt.InsideVn = &ves_io_schema.Empty{}
					localControlPlaneChoiceInt.LocalControlPlane.NetworkChoice = networkChoiceInt
				}

			}

			if v, ok := cs["outside_vn"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

				networkChoiceTypeFound = true

				if v.(bool) {
					networkChoiceInt := &ves_io_schema_fleet.LocalControlPlaneType_OutsideVn{}
					networkChoiceInt.OutsideVn = &ves_io_schema.Empty{}
					localControlPlaneChoiceInt.LocalControlPlane.NetworkChoice = networkChoiceInt
				}

			}

		}

	}

	if v, ok := d.GetOk("no_local_control_plane"); ok && !localControlPlaneChoiceTypeFound {

		localControlPlaneChoiceTypeFound = true

		if v.(bool) {
			localControlPlaneChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_NoLocalControlPlane{}
			localControlPlaneChoiceInt.NoLocalControlPlane = &ves_io_schema.Empty{}
			createSpec.LocalControlPlaneChoice = localControlPlaneChoiceInt
		}

	}

	//logs_receiver_choice

	logsReceiverChoiceTypeFound := false

	if v, ok := d.GetOk("log_receiver"); ok && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true
		logsReceiverChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_LogReceiver{}
		logsReceiverChoiceInt.LogReceiver = &ves_io_schema_views.ObjectRefType{}
		createSpec.LogsReceiverChoice = logsReceiverChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["name"]; ok && !isIntfNil(v) {

				logsReceiverChoiceInt.LogReceiver.Name = v.(string)

			}

			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

				logsReceiverChoiceInt.LogReceiver.Namespace = v.(string)

			}

			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

				logsReceiverChoiceInt.LogReceiver.Tenant = v.(string)

			}

		}

	}

	if v, ok := d.GetOk("logs_streaming_disabled"); ok && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true

		if v.(bool) {
			logsReceiverChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_LogsStreamingDisabled{}
			logsReceiverChoiceInt.LogsStreamingDisabled = &ves_io_schema.Empty{}
			createSpec.LogsReceiverChoice = logsReceiverChoiceInt
		}

	}

	//master_nodes
	if v, ok := d.GetOk("master_nodes"); ok && !isIntfNil(v) {

		ls := make([]string, len(v.([]interface{})))
		for i, v := range v.([]interface{}) {
			ls[i] = v.(string)
		}
		createSpec.MasterNodes = ls

	}

	//network_cfg_choice

	networkCfgChoiceTypeFound := false

	if v, ok := d.GetOk("custom_network_config"); ok && !networkCfgChoiceTypeFound {

		networkCfgChoiceTypeFound = true
		networkCfgChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_CustomNetworkConfig{}
		networkCfgChoiceInt.CustomNetworkConfig = &ves_io_schema_views_voltstack_site.VssNetworkConfiguration{}
		createSpec.NetworkCfgChoice = networkCfgChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["bgp_peer_address"]; ok && !isIntfNil(v) {

				networkCfgChoiceInt.CustomNetworkConfig.BgpPeerAddress = v.(string)

			}

			if v, ok := cs["bgp_router_id"]; ok && !isIntfNil(v) {

				networkCfgChoiceInt.CustomNetworkConfig.BgpRouterId = v.(string)

			}

			forwardProxyChoiceTypeFound := false

			if v, ok := cs["active_forward_proxy_policies"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

				forwardProxyChoiceTypeFound = true
				forwardProxyChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_ActiveForwardProxyPolicies{}
				forwardProxyChoiceInt.ActiveForwardProxyPolicies = &ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType{}
				networkCfgChoiceInt.CustomNetworkConfig.ForwardProxyChoice = forwardProxyChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["forward_proxy_policies"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						forwardProxyPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						forwardProxyChoiceInt.ActiveForwardProxyPolicies.ForwardProxyPolicies = forwardProxyPoliciesInt
						for i, ps := range sl {

							fppMapToStrVal := ps.(map[string]interface{})
							forwardProxyPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := fppMapToStrVal["name"]; ok && !isIntfNil(v) {
								forwardProxyPoliciesInt[i].Name = v.(string)
							}

							if v, ok := fppMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								forwardProxyPoliciesInt[i].Namespace = v.(string)
							}

							if v, ok := fppMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								forwardProxyPoliciesInt[i].Tenant = v.(string)
							}

						}

					}

				}

			}

			if v, ok := cs["forward_proxy_allow_all"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

				forwardProxyChoiceTypeFound = true

				if v.(bool) {
					forwardProxyChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_ForwardProxyAllowAll{}
					forwardProxyChoiceInt.ForwardProxyAllowAll = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.ForwardProxyChoice = forwardProxyChoiceInt
				}

			}

			if v, ok := cs["no_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

				forwardProxyChoiceTypeFound = true

				if v.(bool) {
					forwardProxyChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_NoForwardProxy{}
					forwardProxyChoiceInt.NoForwardProxy = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.ForwardProxyChoice = forwardProxyChoiceInt
				}

			}

			globalNetworkChoiceTypeFound := false

			if v, ok := cs["global_network_list"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

				globalNetworkChoiceTypeFound = true
				globalNetworkChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_GlobalNetworkList{}
				globalNetworkChoiceInt.GlobalNetworkList = &ves_io_schema_views.GlobalNetworkConnectionListType{}
				networkCfgChoiceInt.CustomNetworkConfig.GlobalNetworkChoice = globalNetworkChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["global_network_connections"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						globalNetworkConnections := make([]*ves_io_schema_views.GlobalNetworkConnectionType, len(sl))
						globalNetworkChoiceInt.GlobalNetworkList.GlobalNetworkConnections = globalNetworkConnections
						for i, set := range sl {
							globalNetworkConnections[i] = &ves_io_schema_views.GlobalNetworkConnectionType{}
							globalNetworkConnectionsMapStrToI := set.(map[string]interface{})

							connectionChoiceTypeFound := false

							if v, ok := globalNetworkConnectionsMapStrToI["sli_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

								connectionChoiceTypeFound = true
								connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SliToGlobalDr{}
								connectionChoiceInt.SliToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
								globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										globalVn := &ves_io_schema_views.ObjectRefType{}
										connectionChoiceInt.SliToGlobalDr.GlobalVn = globalVn
										for _, set := range sl {
											globalVnMapStrToI := set.(map[string]interface{})

											if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
												globalVn.Name = w.(string)
											}

											if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
												globalVn.Namespace = w.(string)
											}

											if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
												globalVn.Tenant = w.(string)
											}

										}

									}

								}

							}

							if v, ok := globalNetworkConnectionsMapStrToI["slo_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

								connectionChoiceTypeFound = true
								connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SloToGlobalDr{}
								connectionChoiceInt.SloToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
								globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										globalVn := &ves_io_schema_views.ObjectRefType{}
										connectionChoiceInt.SloToGlobalDr.GlobalVn = globalVn
										for _, set := range sl {
											globalVnMapStrToI := set.(map[string]interface{})

											if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
												globalVn.Name = w.(string)
											}

											if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
												globalVn.Namespace = w.(string)
											}

											if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
												globalVn.Tenant = w.(string)
											}

										}

									}

								}

							}

							forwardProxyChoiceTypeFound := false

							if v, ok := globalNetworkConnectionsMapStrToI["disable_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

								forwardProxyChoiceTypeFound = true

								if v.(bool) {
									forwardProxyChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_DisableForwardProxy{}
									forwardProxyChoiceInt.DisableForwardProxy = &ves_io_schema.Empty{}
									globalNetworkConnections[i].ForwardProxyChoice = forwardProxyChoiceInt
								}

							}

							if v, ok := globalNetworkConnectionsMapStrToI["enable_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

								forwardProxyChoiceTypeFound = true
								forwardProxyChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_EnableForwardProxy{}
								forwardProxyChoiceInt.EnableForwardProxy = &ves_io_schema.ForwardProxyConfigType{}
								globalNetworkConnections[i].ForwardProxyChoice = forwardProxyChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["connection_timeout"]; ok && !isIntfNil(v) {

										forwardProxyChoiceInt.EnableForwardProxy.ConnectionTimeout = uint32(v.(int))

									}

									if v, ok := cs["max_connect_attempts"]; ok && !isIntfNil(v) {

										forwardProxyChoiceInt.EnableForwardProxy.MaxConnectAttempts = uint32(v.(int))

									}

									tlsInterceptionChoiceTypeFound := false

									if v, ok := cs["no_interception"]; ok && !isIntfNil(v) && !tlsInterceptionChoiceTypeFound {

										tlsInterceptionChoiceTypeFound = true

										if v.(bool) {
											tlsInterceptionChoiceInt := &ves_io_schema.ForwardProxyConfigType_NoInterception{}
											tlsInterceptionChoiceInt.NoInterception = &ves_io_schema.Empty{}
											forwardProxyChoiceInt.EnableForwardProxy.TlsInterceptionChoice = tlsInterceptionChoiceInt
										}

									}

									if v, ok := cs["tls_intercept"]; ok && !isIntfNil(v) && !tlsInterceptionChoiceTypeFound {

										tlsInterceptionChoiceTypeFound = true
										tlsInterceptionChoiceInt := &ves_io_schema.ForwardProxyConfigType_TlsIntercept{}
										tlsInterceptionChoiceInt.TlsIntercept = &ves_io_schema.TlsInterceptionType{}
										forwardProxyChoiceInt.EnableForwardProxy.TlsInterceptionChoice = tlsInterceptionChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											interceptionPolicyChoiceTypeFound := false

											if v, ok := cs["enable_for_all_domains"]; ok && !isIntfNil(v) && !interceptionPolicyChoiceTypeFound {

												interceptionPolicyChoiceTypeFound = true

												if v.(bool) {
													interceptionPolicyChoiceInt := &ves_io_schema.TlsInterceptionType_EnableForAllDomains{}
													interceptionPolicyChoiceInt.EnableForAllDomains = &ves_io_schema.Empty{}
													tlsInterceptionChoiceInt.TlsIntercept.InterceptionPolicyChoice = interceptionPolicyChoiceInt
												}

											}

											if v, ok := cs["policy"]; ok && !isIntfNil(v) && !interceptionPolicyChoiceTypeFound {

												interceptionPolicyChoiceTypeFound = true
												interceptionPolicyChoiceInt := &ves_io_schema.TlsInterceptionType_Policy{}
												interceptionPolicyChoiceInt.Policy = &ves_io_schema.TlsInterceptionPolicy{}
												tlsInterceptionChoiceInt.TlsIntercept.InterceptionPolicyChoice = interceptionPolicyChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interception_rules"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														interceptionRules := make([]*ves_io_schema.TlsInterceptionRule, len(sl))
														interceptionPolicyChoiceInt.Policy.InterceptionRules = interceptionRules
														for i, set := range sl {
															interceptionRules[i] = &ves_io_schema.TlsInterceptionRule{}
															interceptionRulesMapStrToI := set.(map[string]interface{})

															if v, ok := interceptionRulesMapStrToI["domain_match"]; ok && !isIntfNil(v) {

																sl := v.(*schema.Set).List()
																domainMatch := &ves_io_schema.DomainType{}
																interceptionRules[i].DomainMatch = domainMatch
																for _, set := range sl {
																	domainMatchMapStrToI := set.(map[string]interface{})

																	domainChoiceTypeFound := false

																	if v, ok := domainMatchMapStrToI["exact_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																		domainChoiceTypeFound = true
																		domainChoiceInt := &ves_io_schema.DomainType_ExactValue{}

																		domainMatch.DomainChoice = domainChoiceInt

																		domainChoiceInt.ExactValue = v.(string)

																	}

																	if v, ok := domainMatchMapStrToI["regex_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																		domainChoiceTypeFound = true
																		domainChoiceInt := &ves_io_schema.DomainType_RegexValue{}

																		domainMatch.DomainChoice = domainChoiceInt

																		domainChoiceInt.RegexValue = v.(string)

																	}

																	if v, ok := domainMatchMapStrToI["suffix_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																		domainChoiceTypeFound = true
																		domainChoiceInt := &ves_io_schema.DomainType_SuffixValue{}

																		domainMatch.DomainChoice = domainChoiceInt

																		domainChoiceInt.SuffixValue = v.(string)

																	}

																}

															}

															enableDisableChoiceTypeFound := false

															if v, ok := interceptionRulesMapStrToI["disable_interception"]; ok && !isIntfNil(v) && !enableDisableChoiceTypeFound {

																enableDisableChoiceTypeFound = true

																if v.(bool) {
																	enableDisableChoiceInt := &ves_io_schema.TlsInterceptionRule_DisableInterception{}
																	enableDisableChoiceInt.DisableInterception = &ves_io_schema.Empty{}
																	interceptionRules[i].EnableDisableChoice = enableDisableChoiceInt
																}

															}

															if v, ok := interceptionRulesMapStrToI["enable_interception"]; ok && !isIntfNil(v) && !enableDisableChoiceTypeFound {

																enableDisableChoiceTypeFound = true

																if v.(bool) {
																	enableDisableChoiceInt := &ves_io_schema.TlsInterceptionRule_EnableInterception{}
																	enableDisableChoiceInt.EnableInterception = &ves_io_schema.Empty{}
																	interceptionRules[i].EnableDisableChoice = enableDisableChoiceInt
																}

															}

														}

													}

												}

											}

											signingCertChoiceTypeFound := false

											if v, ok := cs["custom_certificate"]; ok && !isIntfNil(v) && !signingCertChoiceTypeFound {

												signingCertChoiceTypeFound = true
												signingCertChoiceInt := &ves_io_schema.TlsInterceptionType_CustomCertificate{}
												signingCertChoiceInt.CustomCertificate = &ves_io_schema.TlsCertificateType{}
												tlsInterceptionChoiceInt.TlsIntercept.SigningCertChoice = signingCertChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["certificate_url"]; ok && !isIntfNil(v) {

														signingCertChoiceInt.CustomCertificate.CertificateUrl = v.(string)

													}

													if v, ok := cs["description"]; ok && !isIntfNil(v) {

														signingCertChoiceInt.CustomCertificate.Description = v.(string)

													}

													ocspStaplingChoiceTypeFound := false

													if v, ok := cs["custom_hash_algorithms"]; ok && !isIntfNil(v) && !ocspStaplingChoiceTypeFound {

														ocspStaplingChoiceTypeFound = true
														ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_CustomHashAlgorithms{}
														ocspStaplingChoiceInt.CustomHashAlgorithms = &ves_io_schema.HashAlgorithms{}
														signingCertChoiceInt.CustomCertificate.OcspStaplingChoice = ocspStaplingChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["hash_algorithms"]; ok && !isIntfNil(v) {

																hash_algorithmsList := []ves_io_schema.HashAlgorithm{}
																for _, j := range v.([]interface{}) {
																	hash_algorithmsList = append(hash_algorithmsList, ves_io_schema.HashAlgorithm(ves_io_schema.HashAlgorithm_value[j.(string)]))
																}
																ocspStaplingChoiceInt.CustomHashAlgorithms.HashAlgorithms = hash_algorithmsList

															}

														}

													}

													if v, ok := cs["disable_ocsp_stapling"]; ok && !isIntfNil(v) && !ocspStaplingChoiceTypeFound {

														ocspStaplingChoiceTypeFound = true
														_ = v
													}

													if v, ok := cs["use_system_defaults"]; ok && !isIntfNil(v) && !ocspStaplingChoiceTypeFound {

														ocspStaplingChoiceTypeFound = true
														_ = v
													}

													if v, ok := cs["private_key"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														privateKey := &ves_io_schema.SecretType{}
														signingCertChoiceInt.CustomCertificate.PrivateKey = privateKey
														for _, set := range sl {
															privateKeyMapStrToI := set.(map[string]interface{})

															if v, ok := privateKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																sl := v.(*schema.Set).List()
																blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																privateKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																for _, set := range sl {
																	blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																	}

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.Location = w.(string)
																	}

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.StoreProvider = w.(string)
																	}

																}

															}

															if v, ok := privateKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																privateKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

															}

															secretInfoOneofTypeFound := false

															if v, ok := privateKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																	}

																	if v, ok := cs["location"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																	}

																	if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																	}

																}

															}

															if v, ok := privateKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																	}

																	if v, ok := cs["url"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																	}

																}

															}

															if v, ok := privateKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["key"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																	}

																	if v, ok := cs["location"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																	}

																	if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																	}

																	if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																	}

																	if v, ok := cs["version"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																	}

																}

															}

															if v, ok := privateKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["name"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																	}

																}

															}

														}

													}

												}

											}

											if v, ok := cs["volterra_certificate"]; ok && !isIntfNil(v) && !signingCertChoiceTypeFound {

												signingCertChoiceTypeFound = true

												if v.(bool) {
													signingCertChoiceInt := &ves_io_schema.TlsInterceptionType_VolterraCertificate{}
													signingCertChoiceInt.VolterraCertificate = &ves_io_schema.Empty{}
													tlsInterceptionChoiceInt.TlsIntercept.SigningCertChoice = signingCertChoiceInt
												}

											}

											trustedCaChoiceTypeFound := false

											if v, ok := cs["trusted_ca_url"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

												trustedCaChoiceTypeFound = true
												trustedCaChoiceInt := &ves_io_schema.TlsInterceptionType_TrustedCaUrl{}

												tlsInterceptionChoiceInt.TlsIntercept.TrustedCaChoice = trustedCaChoiceInt

												trustedCaChoiceInt.TrustedCaUrl = v.(string)

											}

											if v, ok := cs["volterra_trusted_ca"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

												trustedCaChoiceTypeFound = true

												if v.(bool) {
													trustedCaChoiceInt := &ves_io_schema.TlsInterceptionType_VolterraTrustedCa{}
													trustedCaChoiceInt.VolterraTrustedCa = &ves_io_schema.Empty{}
													tlsInterceptionChoiceInt.TlsIntercept.TrustedCaChoice = trustedCaChoiceInt
												}

											}

										}

									}

									if v, ok := cs["white_listed_ports"]; ok && !isIntfNil(v) {

										ls := make([]uint32, len(v.([]interface{})))
										for i, v := range v.([]interface{}) {
											ls[i] = uint32(v.(int))
										}
										forwardProxyChoiceInt.EnableForwardProxy.WhiteListedPorts = ls

									}

									if v, ok := cs["white_listed_prefixes"]; ok && !isIntfNil(v) {

										ls := make([]string, len(v.([]interface{})))
										for i, v := range v.([]interface{}) {
											ls[i] = v.(string)
										}
										forwardProxyChoiceInt.EnableForwardProxy.WhiteListedPrefixes = ls

									}

								}

							}

						}

					}

				}

			}

			if v, ok := cs["no_global_network"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

				globalNetworkChoiceTypeFound = true

				if v.(bool) {
					globalNetworkChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_NoGlobalNetwork{}
					globalNetworkChoiceInt.NoGlobalNetwork = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.GlobalNetworkChoice = globalNetworkChoiceInt
				}

			}

			interfaceChoiceTypeFound := false

			if v, ok := cs["default_interface_config"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

				interfaceChoiceTypeFound = true

				if v.(bool) {
					interfaceChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_DefaultInterfaceConfig{}
					interfaceChoiceInt.DefaultInterfaceConfig = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.InterfaceChoice = interfaceChoiceInt
				}

			}

			if v, ok := cs["interface_list"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

				interfaceChoiceTypeFound = true
				interfaceChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_InterfaceList{}
				interfaceChoiceInt.InterfaceList = &ves_io_schema_views_voltstack_site.InterfaceListType{}
				networkCfgChoiceInt.CustomNetworkConfig.InterfaceChoice = interfaceChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["interfaces"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						interfaces := make([]*ves_io_schema_views_voltstack_site.Interface, len(sl))
						interfaceChoiceInt.InterfaceList.Interfaces = interfaces
						for i, set := range sl {
							interfaces[i] = &ves_io_schema_views_voltstack_site.Interface{}
							interfacesMapStrToI := set.(map[string]interface{})

							if w, ok := interfacesMapStrToI["description"]; ok && !isIntfNil(w) {
								interfaces[i].Description = w.(string)
							}

							interfaceChoiceTypeFound := false

							if v, ok := interfacesMapStrToI["dedicated_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

								interfaceChoiceTypeFound = true
								interfaceChoiceInt := &ves_io_schema_views_voltstack_site.Interface_DedicatedInterface{}
								interfaceChoiceInt.DedicatedInterface = &ves_io_schema_network_interface.DedicatedInterfaceType{}
								interfaces[i].InterfaceChoice = interfaceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["device"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.DedicatedInterface.Device = v.(string)

									}

									monitoringChoiceTypeFound := false

									if v, ok := cs["monitor"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true
										_ = v
									}

									if v, ok := cs["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true

										if v.(bool) {
											monitoringChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_MonitorDisabled{}
											monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
											interfaceChoiceInt.DedicatedInterface.MonitoringChoice = monitoringChoiceInt
										}

									}

									if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.DedicatedInterface.Mtu = uint32(v.(int))

									}

									nodeChoiceTypeFound := false

									if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true

										if v.(bool) {
											nodeChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_Cluster{}
											nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
											interfaceChoiceInt.DedicatedInterface.NodeChoice = nodeChoiceInt
										}

									}

									if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true
										nodeChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_Node{}

										interfaceChoiceInt.DedicatedInterface.NodeChoice = nodeChoiceInt

										nodeChoiceInt.Node = v.(string)

									}

									primaryChoiceTypeFound := false

									if v, ok := cs["is_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

										primaryChoiceTypeFound = true

										if v.(bool) {
											primaryChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_IsPrimary{}
											primaryChoiceInt.IsPrimary = &ves_io_schema.Empty{}
											interfaceChoiceInt.DedicatedInterface.PrimaryChoice = primaryChoiceInt
										}

									}

									if v, ok := cs["not_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

										primaryChoiceTypeFound = true

										if v.(bool) {
											primaryChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_NotPrimary{}
											primaryChoiceInt.NotPrimary = &ves_io_schema.Empty{}
											interfaceChoiceInt.DedicatedInterface.PrimaryChoice = primaryChoiceInt
										}

									}

									if v, ok := cs["priority"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.DedicatedInterface.Priority = uint32(v.(int))

									}

								}

							}

							if v, ok := interfacesMapStrToI["dedicated_management_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

								interfaceChoiceTypeFound = true
								interfaceChoiceInt := &ves_io_schema_views_voltstack_site.Interface_DedicatedManagementInterface{}
								interfaceChoiceInt.DedicatedManagementInterface = &ves_io_schema_network_interface.DedicatedManagementInterfaceType{}
								interfaces[i].InterfaceChoice = interfaceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["device"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.DedicatedManagementInterface.Device = v.(string)

									}

									if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.DedicatedManagementInterface.Mtu = uint32(v.(int))

									}

									nodeChoiceTypeFound := false

									if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true

										if v.(bool) {
											nodeChoiceInt := &ves_io_schema_network_interface.DedicatedManagementInterfaceType_Cluster{}
											nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
											interfaceChoiceInt.DedicatedManagementInterface.NodeChoice = nodeChoiceInt
										}

									}

									if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true
										nodeChoiceInt := &ves_io_schema_network_interface.DedicatedManagementInterfaceType_Node{}

										interfaceChoiceInt.DedicatedManagementInterface.NodeChoice = nodeChoiceInt

										nodeChoiceInt.Node = v.(string)

									}

								}

							}

							if v, ok := interfacesMapStrToI["ethernet_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

								interfaceChoiceTypeFound = true
								interfaceChoiceInt := &ves_io_schema_views_voltstack_site.Interface_EthernetInterface{}
								interfaceChoiceInt.EthernetInterface = &ves_io_schema_network_interface.EthernetInterfaceType{}
								interfaces[i].InterfaceChoice = interfaceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									addressChoiceTypeFound := false

									if v, ok := cs["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_DhcpClient{}
											addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.AddressChoice = addressChoiceInt
										}

									}

									if v, ok := cs["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_DhcpServer{}
										addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
										interfaceChoiceInt.EthernetInterface.AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
												addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
												for i, set := range sl {
													dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
													dhcpNetworksMapStrToI := set.(map[string]interface{})

													dnsChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true
														dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

														dhcpNetworks[i].DnsChoice = dnsChoiceInt

														dnsChoiceInt.DnsAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true

														if v.(bool) {
															dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
															dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
															dhcpNetworks[i].DnsChoice = dnsChoiceInt
														}

													}

													gatewayChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true
														gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

														dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

														gatewayChoiceInt.DgwAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
															gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
															gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													networkPrefixChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														networkPrefixChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
														networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

															}

															if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

															}

															if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

															}

														}

													}

													if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

														dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

													}

													if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
														dhcpNetworks[i].Pools = pools
														for i, set := range sl {
															pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
															poolsMapStrToI := set.(map[string]interface{})

															if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																pools[i].EndIp = w.(string)
															}

															if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																pools[i].Exclude = w.(bool)
															}

															if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																pools[i].StartIp = w.(string)
															}

														}

													}

												}

											}

											if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

												addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

											}

											if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												addressChoiceInt.DhcpServer.FixedIpMap = ms
											}

											interfacesAddressingChoiceTypeFound := false

											if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
													interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
													interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true
												interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
												interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
												addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
													}

												}

											}

										}

									}

									if v, ok := cs["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StaticIp{}
										addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceChoiceInt.EthernetInterface.AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if v, ok := cs["device"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.EthernetInterface.Device = v.(string)

									}

									ipv6AddressChoiceTypeFound := false

									if v, ok := cs["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true

										if v.(bool) {
											ipv6AddressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_NoIpv6Address{}
											ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.Ipv6AddressChoice = ipv6AddressChoiceInt
										}

									}

									if v, ok := cs["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StaticIpv6Address{}
										ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceChoiceInt.EthernetInterface.Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									monitoringChoiceTypeFound := false

									if v, ok := cs["monitor"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true
										_ = v
									}

									if v, ok := cs["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true

										if v.(bool) {
											monitoringChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_MonitorDisabled{}
											monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.MonitoringChoice = monitoringChoiceInt
										}

									}

									if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.EthernetInterface.Mtu = uint32(v.(int))

									}

									networkChoiceTypeFound := false

									if v, ok := cs["inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true
										networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_InsideNetwork{}
										networkChoiceInt.InsideNetwork = &ves_io_schema_views.ObjectRefType{}
										interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												networkChoiceInt.InsideNetwork.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												networkChoiceInt.InsideNetwork.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												networkChoiceInt.InsideNetwork.Tenant = v.(string)

											}

										}

									}

									if v, ok := cs["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SiteLocalInsideNetwork{}
											networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
										}

									}

									if v, ok := cs["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SiteLocalNetwork{}
											networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
										}

									}

									if v, ok := cs["srv6_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true
										networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Srv6Network{}
										networkChoiceInt.Srv6Network = &ves_io_schema_views.ObjectRefType{}
										interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												networkChoiceInt.Srv6Network.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												networkChoiceInt.Srv6Network.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												networkChoiceInt.Srv6Network.Tenant = v.(string)

											}

										}

									}

									if v, ok := cs["storage_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StorageNetwork{}
											networkChoiceInt.StorageNetwork = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
										}

									}

									nodeChoiceTypeFound := false

									if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true

										if v.(bool) {
											nodeChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Cluster{}
											nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.NodeChoice = nodeChoiceInt
										}

									}

									if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true
										nodeChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Node{}

										interfaceChoiceInt.EthernetInterface.NodeChoice = nodeChoiceInt

										nodeChoiceInt.Node = v.(string)

									}

									primaryChoiceTypeFound := false

									if v, ok := cs["is_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

										primaryChoiceTypeFound = true

										if v.(bool) {
											primaryChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_IsPrimary{}
											primaryChoiceInt.IsPrimary = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.PrimaryChoice = primaryChoiceInt
										}

									}

									if v, ok := cs["not_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

										primaryChoiceTypeFound = true

										if v.(bool) {
											primaryChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_NotPrimary{}
											primaryChoiceInt.NotPrimary = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.PrimaryChoice = primaryChoiceInt
										}

									}

									if v, ok := cs["priority"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.EthernetInterface.Priority = uint32(v.(int))

									}

									vlanChoiceTypeFound := false

									if v, ok := cs["untagged"]; ok && !isIntfNil(v) && !vlanChoiceTypeFound {

										vlanChoiceTypeFound = true

										if v.(bool) {
											vlanChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Untagged{}
											vlanChoiceInt.Untagged = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.VlanChoice = vlanChoiceInt
										}

									}

									if v, ok := cs["vlan_id"]; ok && !isIntfNil(v) && !vlanChoiceTypeFound {

										vlanChoiceTypeFound = true
										vlanChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_VlanId{}

										interfaceChoiceInt.EthernetInterface.VlanChoice = vlanChoiceInt

										vlanChoiceInt.VlanId = uint32(v.(int))

									}

								}

							}

							if v, ok := interfacesMapStrToI["tunnel_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

								interfaceChoiceTypeFound = true
								interfaceChoiceInt := &ves_io_schema_views_voltstack_site.Interface_TunnelInterface{}
								interfaceChoiceInt.TunnelInterface = &ves_io_schema_network_interface.TunnelInterfaceType{}
								interfaces[i].InterfaceChoice = interfaceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.TunnelInterface.Mtu = uint32(v.(int))

									}

									networkChoiceTypeFound := false

									if v, ok := cs["inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true
										networkChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_InsideNetwork{}
										networkChoiceInt.InsideNetwork = &ves_io_schema_views.ObjectRefType{}
										interfaceChoiceInt.TunnelInterface.NetworkChoice = networkChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												networkChoiceInt.InsideNetwork.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												networkChoiceInt.InsideNetwork.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												networkChoiceInt.InsideNetwork.Tenant = v.(string)

											}

										}

									}

									if v, ok := cs["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_SiteLocalInsideNetwork{}
											networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
											interfaceChoiceInt.TunnelInterface.NetworkChoice = networkChoiceInt
										}

									}

									if v, ok := cs["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_SiteLocalNetwork{}
											networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
											interfaceChoiceInt.TunnelInterface.NetworkChoice = networkChoiceInt
										}

									}

									nodeChoiceTypeFound := false

									if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true

										if v.(bool) {
											nodeChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_Cluster{}
											nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
											interfaceChoiceInt.TunnelInterface.NodeChoice = nodeChoiceInt
										}

									}

									if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true
										nodeChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_Node{}

										interfaceChoiceInt.TunnelInterface.NodeChoice = nodeChoiceInt

										nodeChoiceInt.Node = v.(string)

									}

									if v, ok := cs["priority"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.TunnelInterface.Priority = uint32(v.(int))

									}

									if v, ok := cs["static_ip"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										staticIp := &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceChoiceInt.TunnelInterface.StaticIp = staticIp
										for _, set := range sl {
											staticIpMapStrToI := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := staticIpMapStrToI["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												staticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := staticIpMapStrToI["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												staticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := staticIpMapStrToI["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												staticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if v, ok := cs["tunnel"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										tunnelInt := &ves_io_schema_views.ObjectRefType{}
										interfaceChoiceInt.TunnelInterface.Tunnel = tunnelInt

										for _, set := range sl {
											tMapToStrVal := set.(map[string]interface{})
											if val, ok := tMapToStrVal["name"]; ok && !isIntfNil(v) {
												tunnelInt.Name = val.(string)
											}
											if val, ok := tMapToStrVal["namespace"]; ok && !isIntfNil(v) {
												tunnelInt.Namespace = val.(string)
											}

											if val, ok := tMapToStrVal["tenant"]; ok && !isIntfNil(v) {
												tunnelInt.Tenant = val.(string)
											}
										}

									}

								}

							}

							if w, ok := interfacesMapStrToI["labels"]; ok && !isIntfNil(w) {
								ms := map[string]string{}
								for k, v := range w.(map[string]interface{}) {
									ms[k] = v.(string)
								}
								interfaces[i].Labels = ms
							}

						}

					}

				}

			}

			networkPolicyChoiceTypeFound := false

			if v, ok := cs["active_network_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

				networkPolicyChoiceTypeFound = true
				networkPolicyChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_ActiveNetworkPolicies{}
				networkPolicyChoiceInt.ActiveNetworkPolicies = &ves_io_schema_network_firewall.ActiveNetworkPoliciesType{}
				networkCfgChoiceInt.CustomNetworkConfig.NetworkPolicyChoice = networkPolicyChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["network_policies"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						networkPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						networkPolicyChoiceInt.ActiveNetworkPolicies.NetworkPolicies = networkPoliciesInt
						for i, ps := range sl {

							npMapToStrVal := ps.(map[string]interface{})
							networkPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := npMapToStrVal["name"]; ok && !isIntfNil(v) {
								networkPoliciesInt[i].Name = v.(string)
							}

							if v, ok := npMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								networkPoliciesInt[i].Namespace = v.(string)
							}

							if v, ok := npMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								networkPoliciesInt[i].Tenant = v.(string)
							}

						}

					}

				}

			}

			if v, ok := cs["no_network_policy"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

				networkPolicyChoiceTypeFound = true

				if v.(bool) {
					networkPolicyChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_NoNetworkPolicy{}
					networkPolicyChoiceInt.NoNetworkPolicy = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.NetworkPolicyChoice = networkPolicyChoiceInt
				}

			}

			if v, ok := cs["outside_nameserver"]; ok && !isIntfNil(v) {

				networkCfgChoiceInt.CustomNetworkConfig.OutsideNameserver = v.(string)

			}

			if v, ok := cs["outside_vip"]; ok && !isIntfNil(v) {

				networkCfgChoiceInt.CustomNetworkConfig.OutsideVip = v.(string)

			}

			if v, ok := cs["site_to_site_tunnel_ip"]; ok && !isIntfNil(v) {

				networkCfgChoiceInt.CustomNetworkConfig.SiteToSiteTunnelIp = v.(string)

			}

			sliChoiceTypeFound := false

			if v, ok := cs["default_sli_config"]; ok && !isIntfNil(v) && !sliChoiceTypeFound {

				sliChoiceTypeFound = true

				if v.(bool) {
					sliChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_DefaultSliConfig{}
					sliChoiceInt.DefaultSliConfig = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.SliChoice = sliChoiceInt
				}

			}

			if v, ok := cs["sli_config"]; ok && !isIntfNil(v) && !sliChoiceTypeFound {

				sliChoiceTypeFound = true
				sliChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_SliConfig{}
				sliChoiceInt.SliConfig = &ves_io_schema_views_voltstack_site.SliVnConfiguration{}
				networkCfgChoiceInt.CustomNetworkConfig.SliChoice = sliChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					staticRouteChoiceTypeFound := false

					if v, ok := cs["no_static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

						staticRouteChoiceTypeFound = true

						if v.(bool) {
							staticRouteChoiceInt := &ves_io_schema_views_voltstack_site.SliVnConfiguration_NoStaticRoutes{}
							staticRouteChoiceInt.NoStaticRoutes = &ves_io_schema.Empty{}
							sliChoiceInt.SliConfig.StaticRouteChoice = staticRouteChoiceInt
						}

					}

					if v, ok := cs["static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

						staticRouteChoiceTypeFound = true
						staticRouteChoiceInt := &ves_io_schema_views_voltstack_site.SliVnConfiguration_StaticRoutes{}
						staticRouteChoiceInt.StaticRoutes = &ves_io_schema_views_voltstack_site.StaticRoutesListType{}
						sliChoiceInt.SliConfig.StaticRouteChoice = staticRouteChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRoutes := make([]*ves_io_schema_virtual_network.StaticRouteViewType, len(sl))
								staticRouteChoiceInt.StaticRoutes.StaticRoutes = staticRoutes
								for i, set := range sl {
									staticRoutes[i] = &ves_io_schema_virtual_network.StaticRouteViewType{}
									staticRoutesMapStrToI := set.(map[string]interface{})

									if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

										attrsList := []ves_io_schema.RouteAttrType{}
										for _, j := range v.([]interface{}) {
											attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
										}
										staticRoutes[i].Attrs = attrsList

									}

									if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
										ls := make([]string, len(w.([]interface{})))
										for i, v := range w.([]interface{}) {
											ls[i] = v.(string)
										}
										staticRoutes[i].IpPrefixes = ls
									}

									nextHopChoiceTypeFound := false

									if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true

										if v.(bool) {
											nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_DefaultGateway{}
											nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
											staticRoutes[i].NextHopChoice = nextHopChoiceInt
										}

									}

									if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_Interface{}
										nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Tenant = v.(string)

											}

										}

									}

									if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_IpAddress{}

										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										nextHopChoiceInt.IpAddress = v.(string)

									}

								}

							}

						}

					}

				}

			}

			sloChoiceTypeFound := false

			if v, ok := cs["default_config"]; ok && !isIntfNil(v) && !sloChoiceTypeFound {

				sloChoiceTypeFound = true

				if v.(bool) {
					sloChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_DefaultConfig{}
					sloChoiceInt.DefaultConfig = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.SloChoice = sloChoiceInt
				}

			}

			if v, ok := cs["slo_config"]; ok && !isIntfNil(v) && !sloChoiceTypeFound {

				sloChoiceTypeFound = true
				sloChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_SloConfig{}
				sloChoiceInt.SloConfig = &ves_io_schema_views_voltstack_site.VnConfiguration{}
				networkCfgChoiceInt.CustomNetworkConfig.SloChoice = sloChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					dcClusterGroupChoiceTypeFound := false

					if v, ok := cs["dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

						dcClusterGroupChoiceTypeFound = true
						dcClusterGroupChoiceInt := &ves_io_schema_views_voltstack_site.VnConfiguration_DcClusterGroup{}
						dcClusterGroupChoiceInt.DcClusterGroup = &ves_io_schema_views.ObjectRefType{}
						sloChoiceInt.SloConfig.DcClusterGroupChoice = dcClusterGroupChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Tenant = v.(string)

							}

						}

					}

					if v, ok := cs["no_dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

						dcClusterGroupChoiceTypeFound = true

						if v.(bool) {
							dcClusterGroupChoiceInt := &ves_io_schema_views_voltstack_site.VnConfiguration_NoDcClusterGroup{}
							dcClusterGroupChoiceInt.NoDcClusterGroup = &ves_io_schema.Empty{}
							sloChoiceInt.SloConfig.DcClusterGroupChoice = dcClusterGroupChoiceInt
						}

					}

					if v, ok := cs["labels"]; ok && !isIntfNil(v) {

						ms := map[string]string{}
						for k, v := range v.(map[string]interface{}) {
							ms[k] = v.(string)
						}
						sloChoiceInt.SloConfig.Labels = ms
					}

					staticRouteChoiceTypeFound := false

					if v, ok := cs["no_static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

						staticRouteChoiceTypeFound = true

						if v.(bool) {
							staticRouteChoiceInt := &ves_io_schema_views_voltstack_site.VnConfiguration_NoStaticRoutes{}
							staticRouteChoiceInt.NoStaticRoutes = &ves_io_schema.Empty{}
							sloChoiceInt.SloConfig.StaticRouteChoice = staticRouteChoiceInt
						}

					}

					if v, ok := cs["static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

						staticRouteChoiceTypeFound = true
						staticRouteChoiceInt := &ves_io_schema_views_voltstack_site.VnConfiguration_StaticRoutes{}
						staticRouteChoiceInt.StaticRoutes = &ves_io_schema_views_voltstack_site.StaticRoutesListType{}
						sloChoiceInt.SloConfig.StaticRouteChoice = staticRouteChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRoutes := make([]*ves_io_schema_virtual_network.StaticRouteViewType, len(sl))
								staticRouteChoiceInt.StaticRoutes.StaticRoutes = staticRoutes
								for i, set := range sl {
									staticRoutes[i] = &ves_io_schema_virtual_network.StaticRouteViewType{}
									staticRoutesMapStrToI := set.(map[string]interface{})

									if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

										attrsList := []ves_io_schema.RouteAttrType{}
										for _, j := range v.([]interface{}) {
											attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
										}
										staticRoutes[i].Attrs = attrsList

									}

									if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
										ls := make([]string, len(w.([]interface{})))
										for i, v := range w.([]interface{}) {
											ls[i] = v.(string)
										}
										staticRoutes[i].IpPrefixes = ls
									}

									nextHopChoiceTypeFound := false

									if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true

										if v.(bool) {
											nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_DefaultGateway{}
											nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
											staticRoutes[i].NextHopChoice = nextHopChoiceInt
										}

									}

									if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_Interface{}
										nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Tenant = v.(string)

											}

										}

									}

									if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_IpAddress{}

										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										nextHopChoiceInt.IpAddress = v.(string)

									}

								}

							}

						}

					}

				}

			}

			if v, ok := cs["tunnel_dead_timeout"]; ok && !isIntfNil(v) {

				networkCfgChoiceInt.CustomNetworkConfig.TunnelDeadTimeout = uint32(v.(int))

			}

			if v, ok := cs["vip_vrrp_mode"]; ok && !isIntfNil(v) {

				networkCfgChoiceInt.CustomNetworkConfig.VipVrrpMode = ves_io_schema.VipVrrpType(ves_io_schema.VipVrrpType_value[v.(string)])

			}

		}

	}

	if v, ok := d.GetOk("default_network_config"); ok && !networkCfgChoiceTypeFound {

		networkCfgChoiceTypeFound = true

		if v.(bool) {
			networkCfgChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_DefaultNetworkConfig{}
			networkCfgChoiceInt.DefaultNetworkConfig = &ves_io_schema.Empty{}
			createSpec.NetworkCfgChoice = networkCfgChoiceInt
		}

	}

	//os
	if v, ok := d.GetOk("os"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		os := &ves_io_schema_views.OperatingSystemType{}
		createSpec.Os = os
		for _, set := range sl {
			osMapStrToI := set.(map[string]interface{})

			operatingSystemVersionChoiceTypeFound := false

			if v, ok := osMapStrToI["default_os_version"]; ok && !isIntfNil(v) && !operatingSystemVersionChoiceTypeFound {

				operatingSystemVersionChoiceTypeFound = true

				if v.(bool) {
					operatingSystemVersionChoiceInt := &ves_io_schema_views.OperatingSystemType_DefaultOsVersion{}
					operatingSystemVersionChoiceInt.DefaultOsVersion = &ves_io_schema.Empty{}
					os.OperatingSystemVersionChoice = operatingSystemVersionChoiceInt
				}

			}

			if v, ok := osMapStrToI["operating_system_version"]; ok && !isIntfNil(v) && !operatingSystemVersionChoiceTypeFound {

				operatingSystemVersionChoiceTypeFound = true
				operatingSystemVersionChoiceInt := &ves_io_schema_views.OperatingSystemType_OperatingSystemVersion{}

				os.OperatingSystemVersionChoice = operatingSystemVersionChoiceInt

				operatingSystemVersionChoiceInt.OperatingSystemVersion = v.(string)

			}

		}

	}

	//storage_cfg_choice

	storageCfgChoiceTypeFound := false

	if v, ok := d.GetOk("custom_storage_config"); ok && !storageCfgChoiceTypeFound {

		storageCfgChoiceTypeFound = true
		storageCfgChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_CustomStorageConfig{}
		storageCfgChoiceInt.CustomStorageConfig = &ves_io_schema_views_voltstack_site.VssStorageConfiguration{}
		createSpec.StorageCfgChoice = storageCfgChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			staticRouteChoiceTypeFound := false

			if v, ok := cs["no_static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

				staticRouteChoiceTypeFound = true

				if v.(bool) {
					staticRouteChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_NoStaticRoutes{}
					staticRouteChoiceInt.NoStaticRoutes = &ves_io_schema.Empty{}
					storageCfgChoiceInt.CustomStorageConfig.StaticRouteChoice = staticRouteChoiceInt
				}

			}

			if v, ok := cs["static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

				staticRouteChoiceTypeFound = true
				staticRouteChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_StaticRoutes{}
				staticRouteChoiceInt.StaticRoutes = &ves_io_schema_views_voltstack_site.StaticRoutesListType{}
				storageCfgChoiceInt.CustomStorageConfig.StaticRouteChoice = staticRouteChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						staticRoutes := make([]*ves_io_schema_virtual_network.StaticRouteViewType, len(sl))
						staticRouteChoiceInt.StaticRoutes.StaticRoutes = staticRoutes
						for i, set := range sl {
							staticRoutes[i] = &ves_io_schema_virtual_network.StaticRouteViewType{}
							staticRoutesMapStrToI := set.(map[string]interface{})

							if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

								attrsList := []ves_io_schema.RouteAttrType{}
								for _, j := range v.([]interface{}) {
									attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
								}
								staticRoutes[i].Attrs = attrsList

							}

							if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
								ls := make([]string, len(w.([]interface{})))
								for i, v := range w.([]interface{}) {
									ls[i] = v.(string)
								}
								staticRoutes[i].IpPrefixes = ls
							}

							nextHopChoiceTypeFound := false

							if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

								nextHopChoiceTypeFound = true

								if v.(bool) {
									nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_DefaultGateway{}
									nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
									staticRoutes[i].NextHopChoice = nextHopChoiceInt
								}

							}

							if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

								nextHopChoiceTypeFound = true
								nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_Interface{}
								nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
								staticRoutes[i].NextHopChoice = nextHopChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["name"]; ok && !isIntfNil(v) {

										nextHopChoiceInt.Interface.Name = v.(string)

									}

									if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

										nextHopChoiceInt.Interface.Namespace = v.(string)

									}

									if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

										nextHopChoiceInt.Interface.Tenant = v.(string)

									}

								}

							}

							if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

								nextHopChoiceTypeFound = true
								nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_IpAddress{}

								staticRoutes[i].NextHopChoice = nextHopChoiceInt

								nextHopChoiceInt.IpAddress = v.(string)

							}

						}

					}

				}

			}

			storageClassChoiceTypeFound := false

			if v, ok := cs["default_storage_class"]; ok && !isIntfNil(v) && !storageClassChoiceTypeFound {

				storageClassChoiceTypeFound = true

				if v.(bool) {
					storageClassChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_DefaultStorageClass{}
					storageClassChoiceInt.DefaultStorageClass = &ves_io_schema.Empty{}
					storageCfgChoiceInt.CustomStorageConfig.StorageClassChoice = storageClassChoiceInt
				}

			}

			if v, ok := cs["storage_class_list"]; ok && !isIntfNil(v) && !storageClassChoiceTypeFound {

				storageClassChoiceTypeFound = true
				storageClassChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_StorageClassList{}
				storageClassChoiceInt.StorageClassList = &ves_io_schema_fleet.FleetStorageClassListType{}
				storageCfgChoiceInt.CustomStorageConfig.StorageClassChoice = storageClassChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["storage_classes"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						storageClasses := make([]*ves_io_schema_fleet.FleetStorageClassType, len(sl))
						storageClassChoiceInt.StorageClassList.StorageClasses = storageClasses
						for i, set := range sl {
							storageClasses[i] = &ves_io_schema_fleet.FleetStorageClassType{}
							storageClassesMapStrToI := set.(map[string]interface{})

							if w, ok := storageClassesMapStrToI["advanced_storage_parameters"]; ok && !isIntfNil(w) {
								ms := map[string]string{}
								for k, v := range w.(map[string]interface{}) {
									ms[k] = v.(string)
								}
								storageClasses[i].AdvancedStorageParameters = ms
							}

							if w, ok := storageClassesMapStrToI["allow_volume_expansion"]; ok && !isIntfNil(w) {
								storageClasses[i].AllowVolumeExpansion = w.(bool)
							}

							if w, ok := storageClassesMapStrToI["default_storage_class"]; ok && !isIntfNil(w) {
								storageClasses[i].DefaultStorageClass = w.(bool)
							}

							if w, ok := storageClassesMapStrToI["description"]; ok && !isIntfNil(w) {
								storageClasses[i].Description = w.(string)
							}

							deviceChoiceTypeFound := false

							if v, ok := storageClassesMapStrToI["custom_storage"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

								deviceChoiceTypeFound = true
								deviceChoiceInt := &ves_io_schema_fleet.FleetStorageClassType_CustomStorage{}
								deviceChoiceInt.CustomStorage = &ves_io_schema_fleet.StorageClassCustomType{}
								storageClasses[i].DeviceChoice = deviceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["yaml"]; ok && !isIntfNil(v) {

										deviceChoiceInt.CustomStorage.Yaml = v.(string)

									}

								}

							}

							if v, ok := storageClassesMapStrToI["netapp_trident"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

								deviceChoiceTypeFound = true
								deviceChoiceInt := &ves_io_schema_fleet.FleetStorageClassType_NetappTrident{}
								deviceChoiceInt.NetappTrident = &ves_io_schema_fleet.StorageClassNetappTridentType{}
								storageClasses[i].DeviceChoice = deviceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["selector"]; ok && !isIntfNil(v) {

										ms := map[string]string{}
										for k, v := range v.(map[string]interface{}) {
											ms[k] = v.(string)
										}
										deviceChoiceInt.NetappTrident.Selector = ms
									}

									if v, ok := cs["storage_pools"]; ok && !isIntfNil(v) {

										deviceChoiceInt.NetappTrident.StoragePools = v.(string)

									}

								}

							}

							if v, ok := storageClassesMapStrToI["openebs_enterprise"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

								deviceChoiceTypeFound = true
								deviceChoiceInt := &ves_io_schema_fleet.FleetStorageClassType_OpenebsEnterprise{}
								deviceChoiceInt.OpenebsEnterprise = &ves_io_schema_fleet.StorageClassOpenebsEnterpriseType{}
								storageClasses[i].DeviceChoice = deviceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["protocol"]; ok && !isIntfNil(v) {

										deviceChoiceInt.OpenebsEnterprise.Protocol = v.(string)

									}

									if v, ok := cs["replication"]; ok && !isIntfNil(v) {

										deviceChoiceInt.OpenebsEnterprise.Replication = int32(v.(int))

									}

								}

							}

							if v, ok := storageClassesMapStrToI["pure_service_orchestrator"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

								deviceChoiceTypeFound = true
								deviceChoiceInt := &ves_io_schema_fleet.FleetStorageClassType_PureServiceOrchestrator{}
								deviceChoiceInt.PureServiceOrchestrator = &ves_io_schema_fleet.StorageClassPureServiceOrchestratorType{}
								storageClasses[i].DeviceChoice = deviceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["backend"]; ok && !isIntfNil(v) {

										deviceChoiceInt.PureServiceOrchestrator.Backend = v.(string)

									}

									if v, ok := cs["bandwidth_limit"]; ok && !isIntfNil(v) {

										deviceChoiceInt.PureServiceOrchestrator.BandwidthLimit = v.(string)

									}

									if v, ok := cs["iops_limit"]; ok && !isIntfNil(v) {

										deviceChoiceInt.PureServiceOrchestrator.IopsLimit = uint32(v.(int))

									}

								}

							}

							if w, ok := storageClassesMapStrToI["reclaim_policy"]; ok && !isIntfNil(w) {
								storageClasses[i].ReclaimPolicy = w.(string)
							}

							if w, ok := storageClassesMapStrToI["storage_class_name"]; ok && !isIntfNil(w) {
								storageClasses[i].StorageClassName = w.(string)
							}

							if w, ok := storageClassesMapStrToI["storage_device"]; ok && !isIntfNil(w) {
								storageClasses[i].StorageDevice = w.(string)
							}

						}

					}

				}

			}

			storageDeviceChoiceTypeFound := false

			if v, ok := cs["no_storage_device"]; ok && !isIntfNil(v) && !storageDeviceChoiceTypeFound {

				storageDeviceChoiceTypeFound = true

				if v.(bool) {
					storageDeviceChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_NoStorageDevice{}
					storageDeviceChoiceInt.NoStorageDevice = &ves_io_schema.Empty{}
					storageCfgChoiceInt.CustomStorageConfig.StorageDeviceChoice = storageDeviceChoiceInt
				}

			}

			if v, ok := cs["storage_device_list"]; ok && !isIntfNil(v) && !storageDeviceChoiceTypeFound {

				storageDeviceChoiceTypeFound = true
				storageDeviceChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_StorageDeviceList{}
				storageDeviceChoiceInt.StorageDeviceList = &ves_io_schema_fleet.FleetStorageDeviceListType{}
				storageCfgChoiceInt.CustomStorageConfig.StorageDeviceChoice = storageDeviceChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["storage_devices"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						storageDevices := make([]*ves_io_schema_fleet.FleetStorageDeviceType, len(sl))
						storageDeviceChoiceInt.StorageDeviceList.StorageDevices = storageDevices
						for i, set := range sl {
							storageDevices[i] = &ves_io_schema_fleet.FleetStorageDeviceType{}
							storageDevicesMapStrToI := set.(map[string]interface{})

							if w, ok := storageDevicesMapStrToI["advanced_advanced_parameters"]; ok && !isIntfNil(w) {
								ms := map[string]string{}
								for k, v := range w.(map[string]interface{}) {
									ms[k] = v.(string)
								}
								storageDevices[i].AdvancedAdvancedParameters = ms
							}

							deviceChoiceTypeFound := false

							if v, ok := storageDevicesMapStrToI["custom_storage"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

								deviceChoiceTypeFound = true

								if v.(bool) {
									deviceChoiceInt := &ves_io_schema_fleet.FleetStorageDeviceType_CustomStorage{}
									deviceChoiceInt.CustomStorage = &ves_io_schema.Empty{}
									storageDevices[i].DeviceChoice = deviceChoiceInt
								}

							}

							if v, ok := storageDevicesMapStrToI["netapp_trident"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

								deviceChoiceTypeFound = true
								deviceChoiceInt := &ves_io_schema_fleet.FleetStorageDeviceType_NetappTrident{}
								deviceChoiceInt.NetappTrident = &ves_io_schema_fleet.StorageDeviceNetappTridentType{}
								storageDevices[i].DeviceChoice = deviceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									backendChoiceTypeFound := false

									if v, ok := cs["netapp_backend_ontap_nas"]; ok && !isIntfNil(v) && !backendChoiceTypeFound {

										backendChoiceTypeFound = true
										backendChoiceInt := &ves_io_schema_fleet.StorageDeviceNetappTridentType_NetappBackendOntapNas{}
										backendChoiceInt.NetappBackendOntapNas = &ves_io_schema_fleet.StorageDeviceNetappBackendOntapNasType{}
										deviceChoiceInt.NetappTrident.BackendChoice = backendChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["auto_export_cidrs"]; ok && !isIntfNil(v) {

												sl := v.(*schema.Set).List()
												autoExportCidrs := &ves_io_schema_views.PrefixStringListType{}
												backendChoiceInt.NetappBackendOntapNas.AutoExportCidrs = autoExportCidrs
												for _, set := range sl {
													autoExportCidrsMapStrToI := set.(map[string]interface{})

													if w, ok := autoExportCidrsMapStrToI["prefixes"]; ok && !isIntfNil(w) {
														ls := make([]string, len(w.([]interface{})))
														for i, v := range w.([]interface{}) {
															ls[i] = v.(string)
														}
														autoExportCidrs.Prefixes = ls
													}

												}

											}

											if v, ok := cs["auto_export_policy"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapNas.AutoExportPolicy = v.(bool)

											}

											if v, ok := cs["backend_name"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapNas.BackendName = v.(string)

											}

											if v, ok := cs["client_certificate"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapNas.ClientCertificate = v.(string)

											}

											if v, ok := cs["client_private_key"]; ok && !isIntfNil(v) {

												sl := v.(*schema.Set).List()
												clientPrivateKey := &ves_io_schema.SecretType{}
												backendChoiceInt.NetappBackendOntapNas.ClientPrivateKey = clientPrivateKey
												for _, set := range sl {
													clientPrivateKeyMapStrToI := set.(map[string]interface{})

													if v, ok := clientPrivateKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
														clientPrivateKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
														for _, set := range sl {
															blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

															if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
															}

															if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																blindfoldSecretInfoInternal.Location = w.(string)
															}

															if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																blindfoldSecretInfoInternal.StoreProvider = w.(string)
															}

														}

													}

													if v, ok := clientPrivateKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

														clientPrivateKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													secretInfoOneofTypeFound := false

													if v, ok := clientPrivateKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
														secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
														clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

															}

															if v, ok := cs["location"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

															}

															if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

															}

														}

													}

													if v, ok := clientPrivateKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
														secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
														clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

															}

															if v, ok := cs["url"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

															}

														}

													}

													if v, ok := clientPrivateKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
														secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
														clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["key"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

															}

															if v, ok := cs["location"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

															}

															if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

															}

															if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

															}

															if v, ok := cs["version"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

															}

														}

													}

													if v, ok := clientPrivateKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
														secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
														clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

															}

														}

													}

												}

											}

											dataLifTypeFound := false

											if v, ok := cs["data_lif_dns_name"]; ok && !isIntfNil(v) && !dataLifTypeFound {

												dataLifTypeFound = true
												dataLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapNasType_DataLifDnsName{}

												backendChoiceInt.NetappBackendOntapNas.DataLif = dataLifInt

												dataLifInt.DataLifDnsName = v.(string)

											}

											if v, ok := cs["data_lif_ip"]; ok && !isIntfNil(v) && !dataLifTypeFound {

												dataLifTypeFound = true
												dataLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapNasType_DataLifIp{}

												backendChoiceInt.NetappBackendOntapNas.DataLif = dataLifInt

												dataLifInt.DataLifIp = v.(string)

											}

											if v, ok := cs["labels"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												backendChoiceInt.NetappBackendOntapNas.Labels = ms
											}

											if v, ok := cs["limit_aggregate_usage"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapNas.LimitAggregateUsage = v.(string)

											}

											if v, ok := cs["limit_volume_size"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapNas.LimitVolumeSize = v.(string)

											}

											managementLifTypeFound := false

											if v, ok := cs["management_lif_dns_name"]; ok && !isIntfNil(v) && !managementLifTypeFound {

												managementLifTypeFound = true
												managementLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName{}

												backendChoiceInt.NetappBackendOntapNas.ManagementLif = managementLifInt

												managementLifInt.ManagementLifDnsName = v.(string)

											}

											if v, ok := cs["management_lif_ip"]; ok && !isIntfNil(v) && !managementLifTypeFound {

												managementLifTypeFound = true
												managementLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapNasType_ManagementLifIp{}

												backendChoiceInt.NetappBackendOntapNas.ManagementLif = managementLifInt

												managementLifInt.ManagementLifIp = v.(string)

											}

											if v, ok := cs["nfs_mount_options"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapNas.NfsMountOptions = v.(string)

											}

											if v, ok := cs["password"]; ok && !isIntfNil(v) {

												sl := v.(*schema.Set).List()
												password := &ves_io_schema.SecretType{}
												backendChoiceInt.NetappBackendOntapNas.Password = password
												for _, set := range sl {
													passwordMapStrToI := set.(map[string]interface{})

													if v, ok := passwordMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
														password.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
														for _, set := range sl {
															blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

															if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
															}

															if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																blindfoldSecretInfoInternal.Location = w.(string)
															}

															if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																blindfoldSecretInfoInternal.StoreProvider = w.(string)
															}

														}

													}

													if v, ok := passwordMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

														password.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													secretInfoOneofTypeFound := false

													if v, ok := passwordMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
														secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
														password.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

															}

															if v, ok := cs["location"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

															}

															if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

															}

														}

													}

													if v, ok := passwordMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
														secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
														password.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

															}

															if v, ok := cs["url"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

															}

														}

													}

													if v, ok := passwordMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
														secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
														password.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["key"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

															}

															if v, ok := cs["location"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

															}

															if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

															}

															if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

															}

															if v, ok := cs["version"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

															}

														}

													}

													if v, ok := passwordMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
														secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
														password.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

															}

														}

													}

												}

											}

											if v, ok := cs["region"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapNas.Region = v.(string)

											}

											if v, ok := cs["storage"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												storage := make([]*ves_io_schema_fleet.OntapVirtualStoragePoolType, len(sl))
												backendChoiceInt.NetappBackendOntapNas.Storage = storage
												for i, set := range sl {
													storage[i] = &ves_io_schema_fleet.OntapVirtualStoragePoolType{}
													storageMapStrToI := set.(map[string]interface{})

													if w, ok := storageMapStrToI["labels"]; ok && !isIntfNil(w) {
														ms := map[string]string{}
														for k, v := range w.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														storage[i].Labels = ms
													}

													if v, ok := storageMapStrToI["volume_defaults"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														volumeDefaults := &ves_io_schema_fleet.OntapVolumeDefaults{}
														storage[i].VolumeDefaults = volumeDefaults
														for _, set := range sl {
															volumeDefaultsMapStrToI := set.(map[string]interface{})

															if w, ok := volumeDefaultsMapStrToI["encryption"]; ok && !isIntfNil(w) {
																volumeDefaults.Encryption = w.(bool)
															}

															if w, ok := volumeDefaultsMapStrToI["export_policy"]; ok && !isIntfNil(w) {
																volumeDefaults.ExportPolicy = w.(string)
															}

															qosPolicyChoiceTypeFound := false

															if v, ok := volumeDefaultsMapStrToI["adaptive_qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																qosPolicyChoiceTypeFound = true
																qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_AdaptiveQosPolicy{}

																volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

																qosPolicyChoiceInt.AdaptiveQosPolicy = v.(string)

															}

															if v, ok := volumeDefaultsMapStrToI["no_qos"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																qosPolicyChoiceTypeFound = true

																if v.(bool) {
																	qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_NoQos{}
																	qosPolicyChoiceInt.NoQos = &ves_io_schema.Empty{}
																	volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt
																}

															}

															if v, ok := volumeDefaultsMapStrToI["qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																qosPolicyChoiceTypeFound = true
																qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_QosPolicy{}

																volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

																qosPolicyChoiceInt.QosPolicy = v.(string)

															}

															if w, ok := volumeDefaultsMapStrToI["security_style"]; ok && !isIntfNil(w) {
																volumeDefaults.SecurityStyle = w.(string)
															}

															if w, ok := volumeDefaultsMapStrToI["snapshot_dir"]; ok && !isIntfNil(w) {
																volumeDefaults.SnapshotDir = w.(bool)
															}

															if w, ok := volumeDefaultsMapStrToI["snapshot_policy"]; ok && !isIntfNil(w) {
																volumeDefaults.SnapshotPolicy = w.(string)
															}

															if w, ok := volumeDefaultsMapStrToI["snapshot_reserve"]; ok && !isIntfNil(w) {
																volumeDefaults.SnapshotReserve = w.(string)
															}

															if w, ok := volumeDefaultsMapStrToI["space_reserve"]; ok && !isIntfNil(w) {
																volumeDefaults.SpaceReserve = w.(string)
															}

															if w, ok := volumeDefaultsMapStrToI["split_on_clone"]; ok && !isIntfNil(w) {
																volumeDefaults.SplitOnClone = w.(bool)
															}

															if w, ok := volumeDefaultsMapStrToI["tiering_policy"]; ok && !isIntfNil(w) {
																volumeDefaults.TieringPolicy = w.(string)
															}

															if w, ok := volumeDefaultsMapStrToI["unix_permissions"]; ok && !isIntfNil(w) {
																volumeDefaults.UnixPermissions = int32(w.(int))
															}

														}

													}

													if w, ok := storageMapStrToI["zone"]; ok && !isIntfNil(w) {
														storage[i].Zone = w.(string)
													}

												}

											}

											if v, ok := cs["storage_driver_name"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapNas.StorageDriverName = v.(string)

											}

											if v, ok := cs["storage_prefix"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapNas.StoragePrefix = v.(string)

											}

											if v, ok := cs["svm"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapNas.Svm = v.(string)

											}

											if v, ok := cs["trusted_ca_certificate"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapNas.TrustedCaCertificate = v.(string)

											}

											if v, ok := cs["username"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapNas.Username = v.(string)

											}

											if v, ok := cs["volume_defaults"]; ok && !isIntfNil(v) {

												sl := v.(*schema.Set).List()
												volumeDefaults := &ves_io_schema_fleet.OntapVolumeDefaults{}
												backendChoiceInt.NetappBackendOntapNas.VolumeDefaults = volumeDefaults
												for _, set := range sl {
													volumeDefaultsMapStrToI := set.(map[string]interface{})

													if w, ok := volumeDefaultsMapStrToI["encryption"]; ok && !isIntfNil(w) {
														volumeDefaults.Encryption = w.(bool)
													}

													if w, ok := volumeDefaultsMapStrToI["export_policy"]; ok && !isIntfNil(w) {
														volumeDefaults.ExportPolicy = w.(string)
													}

													qosPolicyChoiceTypeFound := false

													if v, ok := volumeDefaultsMapStrToI["adaptive_qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

														qosPolicyChoiceTypeFound = true
														qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_AdaptiveQosPolicy{}

														volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

														qosPolicyChoiceInt.AdaptiveQosPolicy = v.(string)

													}

													if v, ok := volumeDefaultsMapStrToI["no_qos"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

														qosPolicyChoiceTypeFound = true

														if v.(bool) {
															qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_NoQos{}
															qosPolicyChoiceInt.NoQos = &ves_io_schema.Empty{}
															volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt
														}

													}

													if v, ok := volumeDefaultsMapStrToI["qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

														qosPolicyChoiceTypeFound = true
														qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_QosPolicy{}

														volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

														qosPolicyChoiceInt.QosPolicy = v.(string)

													}

													if w, ok := volumeDefaultsMapStrToI["security_style"]; ok && !isIntfNil(w) {
														volumeDefaults.SecurityStyle = w.(string)
													}

													if w, ok := volumeDefaultsMapStrToI["snapshot_dir"]; ok && !isIntfNil(w) {
														volumeDefaults.SnapshotDir = w.(bool)
													}

													if w, ok := volumeDefaultsMapStrToI["snapshot_policy"]; ok && !isIntfNil(w) {
														volumeDefaults.SnapshotPolicy = w.(string)
													}

													if w, ok := volumeDefaultsMapStrToI["snapshot_reserve"]; ok && !isIntfNil(w) {
														volumeDefaults.SnapshotReserve = w.(string)
													}

													if w, ok := volumeDefaultsMapStrToI["space_reserve"]; ok && !isIntfNil(w) {
														volumeDefaults.SpaceReserve = w.(string)
													}

													if w, ok := volumeDefaultsMapStrToI["split_on_clone"]; ok && !isIntfNil(w) {
														volumeDefaults.SplitOnClone = w.(bool)
													}

													if w, ok := volumeDefaultsMapStrToI["tiering_policy"]; ok && !isIntfNil(w) {
														volumeDefaults.TieringPolicy = w.(string)
													}

													if w, ok := volumeDefaultsMapStrToI["unix_permissions"]; ok && !isIntfNil(w) {
														volumeDefaults.UnixPermissions = int32(w.(int))
													}

												}

											}

										}

									}

									if v, ok := cs["netapp_backend_ontap_san"]; ok && !isIntfNil(v) && !backendChoiceTypeFound {

										backendChoiceTypeFound = true
										backendChoiceInt := &ves_io_schema_fleet.StorageDeviceNetappTridentType_NetappBackendOntapSan{}
										backendChoiceInt.NetappBackendOntapSan = &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType{}
										deviceChoiceInt.NetappTrident.BackendChoice = backendChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											chapChoiceTypeFound := false

											if v, ok := cs["no_chap"]; ok && !isIntfNil(v) && !chapChoiceTypeFound {

												chapChoiceTypeFound = true

												if v.(bool) {
													chapChoiceInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType_NoChap{}
													chapChoiceInt.NoChap = &ves_io_schema.Empty{}
													backendChoiceInt.NetappBackendOntapSan.ChapChoice = chapChoiceInt
												}

											}

											if v, ok := cs["use_chap"]; ok && !isIntfNil(v) && !chapChoiceTypeFound {

												chapChoiceTypeFound = true
												chapChoiceInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType_UseChap{}
												chapChoiceInt.UseChap = &ves_io_schema_fleet.DeviceNetappBackendOntapSanChapType{}
												backendChoiceInt.NetappBackendOntapSan.ChapChoice = chapChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["chap_initiator_secret"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														chapInitiatorSecret := &ves_io_schema.SecretType{}
														chapChoiceInt.UseChap.ChapInitiatorSecret = chapInitiatorSecret
														for _, set := range sl {
															chapInitiatorSecretMapStrToI := set.(map[string]interface{})

															if v, ok := chapInitiatorSecretMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																sl := v.(*schema.Set).List()
																blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																chapInitiatorSecret.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																for _, set := range sl {
																	blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																	}

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.Location = w.(string)
																	}

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.StoreProvider = w.(string)
																	}

																}

															}

															if v, ok := chapInitiatorSecretMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																chapInitiatorSecret.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

															}

															secretInfoOneofTypeFound := false

															if v, ok := chapInitiatorSecretMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																chapInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																	}

																	if v, ok := cs["location"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																	}

																	if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																	}

																}

															}

															if v, ok := chapInitiatorSecretMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																chapInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																	}

																	if v, ok := cs["url"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																	}

																}

															}

															if v, ok := chapInitiatorSecretMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																chapInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["key"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																	}

																	if v, ok := cs["location"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																	}

																	if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																	}

																	if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																	}

																	if v, ok := cs["version"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																	}

																}

															}

															if v, ok := chapInitiatorSecretMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																chapInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["name"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																	}

																}

															}

														}

													}

													if v, ok := cs["chap_target_initiator_secret"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														chapTargetInitiatorSecret := &ves_io_schema.SecretType{}
														chapChoiceInt.UseChap.ChapTargetInitiatorSecret = chapTargetInitiatorSecret
														for _, set := range sl {
															chapTargetInitiatorSecretMapStrToI := set.(map[string]interface{})

															if v, ok := chapTargetInitiatorSecretMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																sl := v.(*schema.Set).List()
																blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																chapTargetInitiatorSecret.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																for _, set := range sl {
																	blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																	}

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.Location = w.(string)
																	}

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.StoreProvider = w.(string)
																	}

																}

															}

															if v, ok := chapTargetInitiatorSecretMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																chapTargetInitiatorSecret.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

															}

															secretInfoOneofTypeFound := false

															if v, ok := chapTargetInitiatorSecretMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																chapTargetInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																	}

																	if v, ok := cs["location"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																	}

																	if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																	}

																}

															}

															if v, ok := chapTargetInitiatorSecretMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																chapTargetInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																	}

																	if v, ok := cs["url"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																	}

																}

															}

															if v, ok := chapTargetInitiatorSecretMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																chapTargetInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["key"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																	}

																	if v, ok := cs["location"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																	}

																	if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																	}

																	if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																	}

																	if v, ok := cs["version"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																	}

																}

															}

															if v, ok := chapTargetInitiatorSecretMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																chapTargetInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["name"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																	}

																}

															}

														}

													}

													if v, ok := cs["chap_target_username"]; ok && !isIntfNil(v) {

														chapChoiceInt.UseChap.ChapTargetUsername = v.(string)

													}

													if v, ok := cs["chap_username"]; ok && !isIntfNil(v) {

														chapChoiceInt.UseChap.ChapUsername = v.(string)

													}

												}

											}

											if v, ok := cs["client_certificate"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapSan.ClientCertificate = v.(string)

											}

											if v, ok := cs["client_private_key"]; ok && !isIntfNil(v) {

												sl := v.(*schema.Set).List()
												clientPrivateKey := &ves_io_schema.SecretType{}
												backendChoiceInt.NetappBackendOntapSan.ClientPrivateKey = clientPrivateKey
												for _, set := range sl {
													clientPrivateKeyMapStrToI := set.(map[string]interface{})

													if v, ok := clientPrivateKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
														clientPrivateKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
														for _, set := range sl {
															blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

															if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
															}

															if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																blindfoldSecretInfoInternal.Location = w.(string)
															}

															if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																blindfoldSecretInfoInternal.StoreProvider = w.(string)
															}

														}

													}

													if v, ok := clientPrivateKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

														clientPrivateKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													secretInfoOneofTypeFound := false

													if v, ok := clientPrivateKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
														secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
														clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

															}

															if v, ok := cs["location"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

															}

															if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

															}

														}

													}

													if v, ok := clientPrivateKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
														secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
														clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

															}

															if v, ok := cs["url"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

															}

														}

													}

													if v, ok := clientPrivateKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
														secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
														clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["key"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

															}

															if v, ok := cs["location"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

															}

															if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

															}

															if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

															}

															if v, ok := cs["version"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

															}

														}

													}

													if v, ok := clientPrivateKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
														secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
														clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

															}

														}

													}

												}

											}

											dataLifTypeFound := false

											if v, ok := cs["data_lif_dns_name"]; ok && !isIntfNil(v) && !dataLifTypeFound {

												dataLifTypeFound = true
												dataLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType_DataLifDnsName{}

												backendChoiceInt.NetappBackendOntapSan.DataLif = dataLifInt

												dataLifInt.DataLifDnsName = v.(string)

											}

											if v, ok := cs["data_lif_ip"]; ok && !isIntfNil(v) && !dataLifTypeFound {

												dataLifTypeFound = true
												dataLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType_DataLifIp{}

												backendChoiceInt.NetappBackendOntapSan.DataLif = dataLifInt

												dataLifInt.DataLifIp = v.(string)

											}

											if v, ok := cs["igroup_name"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapSan.IgroupName = v.(string)

											}

											if v, ok := cs["labels"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												backendChoiceInt.NetappBackendOntapSan.Labels = ms
											}

											if v, ok := cs["limit_aggregate_usage"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapSan.LimitAggregateUsage = uint32(v.(int))

											}

											if v, ok := cs["limit_volume_size"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapSan.LimitVolumeSize = int32(v.(int))

											}

											managementLifTypeFound := false

											if v, ok := cs["management_lif_dns_name"]; ok && !isIntfNil(v) && !managementLifTypeFound {

												managementLifTypeFound = true
												managementLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName{}

												backendChoiceInt.NetappBackendOntapSan.ManagementLif = managementLifInt

												managementLifInt.ManagementLifDnsName = v.(string)

											}

											if v, ok := cs["management_lif_ip"]; ok && !isIntfNil(v) && !managementLifTypeFound {

												managementLifTypeFound = true
												managementLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType_ManagementLifIp{}

												backendChoiceInt.NetappBackendOntapSan.ManagementLif = managementLifInt

												managementLifInt.ManagementLifIp = v.(string)

											}

											if v, ok := cs["password"]; ok && !isIntfNil(v) {

												sl := v.(*schema.Set).List()
												password := &ves_io_schema.SecretType{}
												backendChoiceInt.NetappBackendOntapSan.Password = password
												for _, set := range sl {
													passwordMapStrToI := set.(map[string]interface{})

													if v, ok := passwordMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
														password.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
														for _, set := range sl {
															blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

															if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
															}

															if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																blindfoldSecretInfoInternal.Location = w.(string)
															}

															if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																blindfoldSecretInfoInternal.StoreProvider = w.(string)
															}

														}

													}

													if v, ok := passwordMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

														password.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													secretInfoOneofTypeFound := false

													if v, ok := passwordMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
														secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
														password.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

															}

															if v, ok := cs["location"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

															}

															if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

															}

														}

													}

													if v, ok := passwordMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
														secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
														password.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

															}

															if v, ok := cs["url"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

															}

														}

													}

													if v, ok := passwordMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
														secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
														password.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["key"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

															}

															if v, ok := cs["location"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

															}

															if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

															}

															if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

															}

															if v, ok := cs["version"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

															}

														}

													}

													if v, ok := passwordMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
														secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
														password.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

															}

														}

													}

												}

											}

											if v, ok := cs["region"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapSan.Region = v.(string)

											}

											if v, ok := cs["storage"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												storage := make([]*ves_io_schema_fleet.OntapVirtualStoragePoolType, len(sl))
												backendChoiceInt.NetappBackendOntapSan.Storage = storage
												for i, set := range sl {
													storage[i] = &ves_io_schema_fleet.OntapVirtualStoragePoolType{}
													storageMapStrToI := set.(map[string]interface{})

													if w, ok := storageMapStrToI["labels"]; ok && !isIntfNil(w) {
														ms := map[string]string{}
														for k, v := range w.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														storage[i].Labels = ms
													}

													if v, ok := storageMapStrToI["volume_defaults"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														volumeDefaults := &ves_io_schema_fleet.OntapVolumeDefaults{}
														storage[i].VolumeDefaults = volumeDefaults
														for _, set := range sl {
															volumeDefaultsMapStrToI := set.(map[string]interface{})

															if w, ok := volumeDefaultsMapStrToI["encryption"]; ok && !isIntfNil(w) {
																volumeDefaults.Encryption = w.(bool)
															}

															if w, ok := volumeDefaultsMapStrToI["export_policy"]; ok && !isIntfNil(w) {
																volumeDefaults.ExportPolicy = w.(string)
															}

															qosPolicyChoiceTypeFound := false

															if v, ok := volumeDefaultsMapStrToI["adaptive_qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																qosPolicyChoiceTypeFound = true
																qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_AdaptiveQosPolicy{}

																volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

																qosPolicyChoiceInt.AdaptiveQosPolicy = v.(string)

															}

															if v, ok := volumeDefaultsMapStrToI["no_qos"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																qosPolicyChoiceTypeFound = true

																if v.(bool) {
																	qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_NoQos{}
																	qosPolicyChoiceInt.NoQos = &ves_io_schema.Empty{}
																	volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt
																}

															}

															if v, ok := volumeDefaultsMapStrToI["qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																qosPolicyChoiceTypeFound = true
																qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_QosPolicy{}

																volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

																qosPolicyChoiceInt.QosPolicy = v.(string)

															}

															if w, ok := volumeDefaultsMapStrToI["security_style"]; ok && !isIntfNil(w) {
																volumeDefaults.SecurityStyle = w.(string)
															}

															if w, ok := volumeDefaultsMapStrToI["snapshot_dir"]; ok && !isIntfNil(w) {
																volumeDefaults.SnapshotDir = w.(bool)
															}

															if w, ok := volumeDefaultsMapStrToI["snapshot_policy"]; ok && !isIntfNil(w) {
																volumeDefaults.SnapshotPolicy = w.(string)
															}

															if w, ok := volumeDefaultsMapStrToI["snapshot_reserve"]; ok && !isIntfNil(w) {
																volumeDefaults.SnapshotReserve = w.(string)
															}

															if w, ok := volumeDefaultsMapStrToI["space_reserve"]; ok && !isIntfNil(w) {
																volumeDefaults.SpaceReserve = w.(string)
															}

															if w, ok := volumeDefaultsMapStrToI["split_on_clone"]; ok && !isIntfNil(w) {
																volumeDefaults.SplitOnClone = w.(bool)
															}

															if w, ok := volumeDefaultsMapStrToI["tiering_policy"]; ok && !isIntfNil(w) {
																volumeDefaults.TieringPolicy = w.(string)
															}

															if w, ok := volumeDefaultsMapStrToI["unix_permissions"]; ok && !isIntfNil(w) {
																volumeDefaults.UnixPermissions = int32(w.(int))
															}

														}

													}

													if w, ok := storageMapStrToI["zone"]; ok && !isIntfNil(w) {
														storage[i].Zone = w.(string)
													}

												}

											}

											if v, ok := cs["storage_driver_name"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapSan.StorageDriverName = v.(string)

											}

											if v, ok := cs["storage_prefix"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapSan.StoragePrefix = v.(string)

											}

											if v, ok := cs["svm"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapSan.Svm = v.(string)

											}

											if v, ok := cs["trusted_ca_certificate"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapSan.TrustedCaCertificate = v.(string)

											}

											if v, ok := cs["username"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapSan.Username = v.(string)

											}

											if v, ok := cs["volume_defaults"]; ok && !isIntfNil(v) {

												sl := v.(*schema.Set).List()
												volumeDefaults := &ves_io_schema_fleet.OntapVolumeDefaults{}
												backendChoiceInt.NetappBackendOntapSan.VolumeDefaults = volumeDefaults
												for _, set := range sl {
													volumeDefaultsMapStrToI := set.(map[string]interface{})

													if w, ok := volumeDefaultsMapStrToI["encryption"]; ok && !isIntfNil(w) {
														volumeDefaults.Encryption = w.(bool)
													}

													if w, ok := volumeDefaultsMapStrToI["export_policy"]; ok && !isIntfNil(w) {
														volumeDefaults.ExportPolicy = w.(string)
													}

													qosPolicyChoiceTypeFound := false

													if v, ok := volumeDefaultsMapStrToI["adaptive_qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

														qosPolicyChoiceTypeFound = true
														qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_AdaptiveQosPolicy{}

														volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

														qosPolicyChoiceInt.AdaptiveQosPolicy = v.(string)

													}

													if v, ok := volumeDefaultsMapStrToI["no_qos"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

														qosPolicyChoiceTypeFound = true

														if v.(bool) {
															qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_NoQos{}
															qosPolicyChoiceInt.NoQos = &ves_io_schema.Empty{}
															volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt
														}

													}

													if v, ok := volumeDefaultsMapStrToI["qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

														qosPolicyChoiceTypeFound = true
														qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_QosPolicy{}

														volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

														qosPolicyChoiceInt.QosPolicy = v.(string)

													}

													if w, ok := volumeDefaultsMapStrToI["security_style"]; ok && !isIntfNil(w) {
														volumeDefaults.SecurityStyle = w.(string)
													}

													if w, ok := volumeDefaultsMapStrToI["snapshot_dir"]; ok && !isIntfNil(w) {
														volumeDefaults.SnapshotDir = w.(bool)
													}

													if w, ok := volumeDefaultsMapStrToI["snapshot_policy"]; ok && !isIntfNil(w) {
														volumeDefaults.SnapshotPolicy = w.(string)
													}

													if w, ok := volumeDefaultsMapStrToI["snapshot_reserve"]; ok && !isIntfNil(w) {
														volumeDefaults.SnapshotReserve = w.(string)
													}

													if w, ok := volumeDefaultsMapStrToI["space_reserve"]; ok && !isIntfNil(w) {
														volumeDefaults.SpaceReserve = w.(string)
													}

													if w, ok := volumeDefaultsMapStrToI["split_on_clone"]; ok && !isIntfNil(w) {
														volumeDefaults.SplitOnClone = w.(bool)
													}

													if w, ok := volumeDefaultsMapStrToI["tiering_policy"]; ok && !isIntfNil(w) {
														volumeDefaults.TieringPolicy = w.(string)
													}

													if w, ok := volumeDefaultsMapStrToI["unix_permissions"]; ok && !isIntfNil(w) {
														volumeDefaults.UnixPermissions = int32(w.(int))
													}

												}

											}

										}

									}

								}

							}

							if v, ok := storageDevicesMapStrToI["openebs_enterprise"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

								deviceChoiceTypeFound = true
								deviceChoiceInt := &ves_io_schema_fleet.FleetStorageDeviceType_OpenebsEnterprise{}
								deviceChoiceInt.OpenebsEnterprise = &ves_io_schema_fleet.StorageDeviceOpenebsEnterpriseType{}
								storageDevices[i].DeviceChoice = deviceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["mayastor_pools"]; ok && !isIntfNil(v) {

										sl := v.([]interface{})
										mayastorPools := make([]*ves_io_schema_fleet.OpenebsMayastorPoolType, len(sl))
										deviceChoiceInt.OpenebsEnterprise.MayastorPools = mayastorPools
										for i, set := range sl {
											mayastorPools[i] = &ves_io_schema_fleet.OpenebsMayastorPoolType{}
											mayastorPoolsMapStrToI := set.(map[string]interface{})

											if w, ok := mayastorPoolsMapStrToI["node"]; ok && !isIntfNil(w) {
												mayastorPools[i].Node = w.(string)
											}

											if w, ok := mayastorPoolsMapStrToI["pool_disk_devices"]; ok && !isIntfNil(w) {
												ls := make([]string, len(w.([]interface{})))
												for i, v := range w.([]interface{}) {
													ls[i] = v.(string)
												}
												mayastorPools[i].PoolDiskDevices = ls
											}

											if w, ok := mayastorPoolsMapStrToI["pool_name"]; ok && !isIntfNil(w) {
												mayastorPools[i].PoolName = w.(string)
											}

										}

									}

								}

							}

							if v, ok := storageDevicesMapStrToI["pure_service_orchestrator"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

								deviceChoiceTypeFound = true
								deviceChoiceInt := &ves_io_schema_fleet.FleetStorageDeviceType_PureServiceOrchestrator{}
								deviceChoiceInt.PureServiceOrchestrator = &ves_io_schema_fleet.StorageDevicePureStorageServiceOrchestratorType{}
								storageDevices[i].DeviceChoice = deviceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["arrays"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										arrays := &ves_io_schema_fleet.PsoArrayConfiguration{}
										deviceChoiceInt.PureServiceOrchestrator.Arrays = arrays
										for _, set := range sl {
											arraysMapStrToI := set.(map[string]interface{})

											if v, ok := arraysMapStrToI["flash_array"]; ok && !isIntfNil(v) {

												sl := v.(*schema.Set).List()
												flashArray := &ves_io_schema_fleet.FlashArrayType{}
												arrays.FlashArray = flashArray
												for _, set := range sl {
													flashArrayMapStrToI := set.(map[string]interface{})

													if w, ok := flashArrayMapStrToI["default_fs_opt"]; ok && !isIntfNil(w) {
														flashArray.DefaultFsOpt = w.(string)
													}

													if w, ok := flashArrayMapStrToI["default_fs_type"]; ok && !isIntfNil(w) {
														flashArray.DefaultFsType = w.(string)
													}

													if w, ok := flashArrayMapStrToI["default_mount_opts"]; ok && !isIntfNil(w) {
														ls := make([]string, len(w.([]interface{})))
														for i, v := range w.([]interface{}) {
															ls[i] = v.(string)
														}
														flashArray.DefaultMountOpts = ls
													}

													if w, ok := flashArrayMapStrToI["disable_preempt_attachments"]; ok && !isIntfNil(w) {
														flashArray.DisablePreemptAttachments = w.(bool)
													}

													if v, ok := flashArrayMapStrToI["flash_arrays"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														flashArrays := make([]*ves_io_schema_fleet.FlashArrayEndpoint, len(sl))
														flashArray.FlashArrays = flashArrays
														for i, set := range sl {
															flashArrays[i] = &ves_io_schema_fleet.FlashArrayEndpoint{}
															flashArraysMapStrToI := set.(map[string]interface{})

															if v, ok := flashArraysMapStrToI["api_token"]; ok && !isIntfNil(v) {

																sl := v.(*schema.Set).List()
																apiToken := &ves_io_schema.SecretType{}
																flashArrays[i].ApiToken = apiToken
																for _, set := range sl {
																	apiTokenMapStrToI := set.(map[string]interface{})

																	if v, ok := apiTokenMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																		sl := v.(*schema.Set).List()
																		blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																		apiToken.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																		for _, set := range sl {
																			blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																			if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																				blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																			}

																			if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																				blindfoldSecretInfoInternal.Location = w.(string)
																			}

																			if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																				blindfoldSecretInfoInternal.StoreProvider = w.(string)
																			}

																		}

																	}

																	if v, ok := apiTokenMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																		apiToken.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																	}

																	secretInfoOneofTypeFound := false

																	if v, ok := apiTokenMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																		secretInfoOneofTypeFound = true
																		secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																		secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																		apiToken.SecretInfoOneof = secretInfoOneofInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																			}

																			if v, ok := cs["location"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																			}

																			if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																			}

																		}

																	}

																	if v, ok := apiTokenMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																		secretInfoOneofTypeFound = true
																		secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																		secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																		apiToken.SecretInfoOneof = secretInfoOneofInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																			}

																			if v, ok := cs["url"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																			}

																		}

																	}

																	if v, ok := apiTokenMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																		secretInfoOneofTypeFound = true
																		secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																		secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																		apiToken.SecretInfoOneof = secretInfoOneofInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["key"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																			}

																			if v, ok := cs["location"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																			}

																			if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																			}

																			if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																			}

																			if v, ok := cs["version"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																			}

																		}

																	}

																	if v, ok := apiTokenMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																		secretInfoOneofTypeFound = true
																		secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																		secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																		apiToken.SecretInfoOneof = secretInfoOneofInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["name"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																			}

																		}

																	}

																}

															}

															if w, ok := flashArraysMapStrToI["labels"]; ok && !isIntfNil(w) {
																ms := map[string]string{}
																for k, v := range w.(map[string]interface{}) {
																	ms[k] = v.(string)
																}
																flashArrays[i].Labels = ms
															}

															mgmtEndpointTypeFound := false

															if v, ok := flashArraysMapStrToI["mgmt_dns_name"]; ok && !isIntfNil(v) && !mgmtEndpointTypeFound {

																mgmtEndpointTypeFound = true
																mgmtEndpointInt := &ves_io_schema_fleet.FlashArrayEndpoint_MgmtDnsName{}

																flashArrays[i].MgmtEndpoint = mgmtEndpointInt

																mgmtEndpointInt.MgmtDnsName = v.(string)

															}

															if v, ok := flashArraysMapStrToI["mgmt_ip"]; ok && !isIntfNil(v) && !mgmtEndpointTypeFound {

																mgmtEndpointTypeFound = true
																mgmtEndpointInt := &ves_io_schema_fleet.FlashArrayEndpoint_MgmtIp{}

																flashArrays[i].MgmtEndpoint = mgmtEndpointInt

																mgmtEndpointInt.MgmtIp = v.(string)

															}

														}

													}

													if w, ok := flashArrayMapStrToI["iscsi_login_timeout"]; ok && !isIntfNil(w) {
														flashArray.IscsiLoginTimeout = int32(w.(int))
													}

													if w, ok := flashArrayMapStrToI["san_type"]; ok && !isIntfNil(w) {
														flashArray.SanType = w.(string)
													}

												}

											}

											if v, ok := arraysMapStrToI["flash_blade"]; ok && !isIntfNil(v) {

												sl := v.(*schema.Set).List()
												flashBlade := &ves_io_schema_fleet.FlashBladeType{}
												arrays.FlashBlade = flashBlade
												for _, set := range sl {
													flashBladeMapStrToI := set.(map[string]interface{})

													if w, ok := flashBladeMapStrToI["enable_snapshot_directory"]; ok && !isIntfNil(w) {
														flashBlade.EnableSnapshotDirectory = w.(bool)
													}

													if w, ok := flashBladeMapStrToI["export_rules"]; ok && !isIntfNil(w) {
														flashBlade.ExportRules = w.(string)
													}

													if v, ok := flashBladeMapStrToI["flash_blades"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														flashBlades := make([]*ves_io_schema_fleet.FlashBladeEndpoint, len(sl))
														flashBlade.FlashBlades = flashBlades
														for i, set := range sl {
															flashBlades[i] = &ves_io_schema_fleet.FlashBladeEndpoint{}
															flashBladesMapStrToI := set.(map[string]interface{})

															if v, ok := flashBladesMapStrToI["api_token"]; ok && !isIntfNil(v) {

																sl := v.(*schema.Set).List()
																apiToken := &ves_io_schema.SecretType{}
																flashBlades[i].ApiToken = apiToken
																for _, set := range sl {
																	apiTokenMapStrToI := set.(map[string]interface{})

																	if v, ok := apiTokenMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																		sl := v.(*schema.Set).List()
																		blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																		apiToken.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																		for _, set := range sl {
																			blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																			if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																				blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																			}

																			if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																				blindfoldSecretInfoInternal.Location = w.(string)
																			}

																			if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																				blindfoldSecretInfoInternal.StoreProvider = w.(string)
																			}

																		}

																	}

																	if v, ok := apiTokenMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																		apiToken.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																	}

																	secretInfoOneofTypeFound := false

																	if v, ok := apiTokenMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																		secretInfoOneofTypeFound = true
																		secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																		secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																		apiToken.SecretInfoOneof = secretInfoOneofInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																			}

																			if v, ok := cs["location"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																			}

																			if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																			}

																		}

																	}

																	if v, ok := apiTokenMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																		secretInfoOneofTypeFound = true
																		secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																		secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																		apiToken.SecretInfoOneof = secretInfoOneofInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																			}

																			if v, ok := cs["url"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																			}

																		}

																	}

																	if v, ok := apiTokenMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																		secretInfoOneofTypeFound = true
																		secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																		secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																		apiToken.SecretInfoOneof = secretInfoOneofInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["key"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																			}

																			if v, ok := cs["location"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																			}

																			if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																			}

																			if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																			}

																			if v, ok := cs["version"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																			}

																		}

																	}

																	if v, ok := apiTokenMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																		secretInfoOneofTypeFound = true
																		secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																		secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																		apiToken.SecretInfoOneof = secretInfoOneofInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["name"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																			}

																		}

																	}

																}

															}

															if w, ok := flashBladesMapStrToI["lables"]; ok && !isIntfNil(w) {
																ms := map[string]string{}
																for k, v := range w.(map[string]interface{}) {
																	ms[k] = v.(string)
																}
																flashBlades[i].Lables = ms
															}

															mgmtEndpointTypeFound := false

															if v, ok := flashBladesMapStrToI["mgmt_dns_name"]; ok && !isIntfNil(v) && !mgmtEndpointTypeFound {

																mgmtEndpointTypeFound = true
																mgmtEndpointInt := &ves_io_schema_fleet.FlashBladeEndpoint_MgmtDnsName{}

																flashBlades[i].MgmtEndpoint = mgmtEndpointInt

																mgmtEndpointInt.MgmtDnsName = v.(string)

															}

															if v, ok := flashBladesMapStrToI["mgmt_ip"]; ok && !isIntfNil(v) && !mgmtEndpointTypeFound {

																mgmtEndpointTypeFound = true
																mgmtEndpointInt := &ves_io_schema_fleet.FlashBladeEndpoint_MgmtIp{}

																flashBlades[i].MgmtEndpoint = mgmtEndpointInt

																mgmtEndpointInt.MgmtIp = v.(string)

															}

															nfsEndpointTypeFound := false

															if v, ok := flashBladesMapStrToI["nfs_endpoint_dns_name"]; ok && !isIntfNil(v) && !nfsEndpointTypeFound {

																nfsEndpointTypeFound = true
																nfsEndpointInt := &ves_io_schema_fleet.FlashBladeEndpoint_NfsEndpointDnsName{}

																flashBlades[i].NfsEndpoint = nfsEndpointInt

																nfsEndpointInt.NfsEndpointDnsName = v.(string)

															}

															if v, ok := flashBladesMapStrToI["nfs_endpoint_ip"]; ok && !isIntfNil(v) && !nfsEndpointTypeFound {

																nfsEndpointTypeFound = true
																nfsEndpointInt := &ves_io_schema_fleet.FlashBladeEndpoint_NfsEndpointIp{}

																flashBlades[i].NfsEndpoint = nfsEndpointInt

																nfsEndpointInt.NfsEndpointIp = v.(string)

															}

														}

													}

												}

											}

										}

									}

									if v, ok := cs["cluster_id"]; ok && !isIntfNil(v) {

										deviceChoiceInt.PureServiceOrchestrator.ClusterId = v.(string)

									}

									if v, ok := cs["enable_storage_topology"]; ok && !isIntfNil(v) {

										deviceChoiceInt.PureServiceOrchestrator.EnableStorageTopology = v.(bool)

									}

									if v, ok := cs["enable_strict_topology"]; ok && !isIntfNil(v) {

										deviceChoiceInt.PureServiceOrchestrator.EnableStrictTopology = v.(bool)

									}

								}

							}

							if w, ok := storageDevicesMapStrToI["storage_device"]; ok && !isIntfNil(w) {
								storageDevices[i].StorageDevice = w.(string)
							}

						}

					}

				}

			}

			storageInterfaceChoiceTypeFound := false

			if v, ok := cs["no_storage_interfaces"]; ok && !isIntfNil(v) && !storageInterfaceChoiceTypeFound {

				storageInterfaceChoiceTypeFound = true

				if v.(bool) {
					storageInterfaceChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_NoStorageInterfaces{}
					storageInterfaceChoiceInt.NoStorageInterfaces = &ves_io_schema.Empty{}
					storageCfgChoiceInt.CustomStorageConfig.StorageInterfaceChoice = storageInterfaceChoiceInt
				}

			}

			if v, ok := cs["storage_interface_list"]; ok && !isIntfNil(v) && !storageInterfaceChoiceTypeFound {

				storageInterfaceChoiceTypeFound = true
				storageInterfaceChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_StorageInterfaceList{}
				storageInterfaceChoiceInt.StorageInterfaceList = &ves_io_schema_views_voltstack_site.StorageInterfaceListType{}
				storageCfgChoiceInt.CustomStorageConfig.StorageInterfaceChoice = storageInterfaceChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["storage_interfaces"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						storageInterfaces := make([]*ves_io_schema_views_voltstack_site.StorageInterfaceType, len(sl))
						storageInterfaceChoiceInt.StorageInterfaceList.StorageInterfaces = storageInterfaces
						for i, set := range sl {
							storageInterfaces[i] = &ves_io_schema_views_voltstack_site.StorageInterfaceType{}
							storageInterfacesMapStrToI := set.(map[string]interface{})

							if w, ok := storageInterfacesMapStrToI["description"]; ok && !isIntfNil(w) {
								storageInterfaces[i].Description = w.(string)
							}

							if w, ok := storageInterfacesMapStrToI["labels"]; ok && !isIntfNil(w) {
								ms := map[string]string{}
								for k, v := range w.(map[string]interface{}) {
									ms[k] = v.(string)
								}
								storageInterfaces[i].Labels = ms
							}

							if v, ok := storageInterfacesMapStrToI["storage_interface"]; ok && !isIntfNil(v) {

								sl := v.(*schema.Set).List()
								storageInterface := &ves_io_schema_network_interface.EthernetInterfaceType{}
								storageInterfaces[i].StorageInterface = storageInterface
								for _, set := range sl {
									storageInterfaceMapStrToI := set.(map[string]interface{})

									addressChoiceTypeFound := false

									if v, ok := storageInterfaceMapStrToI["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_DhcpClient{}
											addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
											storageInterface.AddressChoice = addressChoiceInt
										}

									}

									if v, ok := storageInterfaceMapStrToI["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_DhcpServer{}
										addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
										storageInterface.AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
												addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
												for i, set := range sl {
													dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
													dhcpNetworksMapStrToI := set.(map[string]interface{})

													dnsChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true
														dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

														dhcpNetworks[i].DnsChoice = dnsChoiceInt

														dnsChoiceInt.DnsAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true

														if v.(bool) {
															dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
															dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
															dhcpNetworks[i].DnsChoice = dnsChoiceInt
														}

													}

													gatewayChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true
														gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

														dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

														gatewayChoiceInt.DgwAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
															gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
															gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													networkPrefixChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														networkPrefixChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
														networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

															}

															if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

															}

															if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

															}

														}

													}

													if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

														dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

													}

													if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
														dhcpNetworks[i].Pools = pools
														for i, set := range sl {
															pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
															poolsMapStrToI := set.(map[string]interface{})

															if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																pools[i].EndIp = w.(string)
															}

															if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																pools[i].Exclude = w.(bool)
															}

															if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																pools[i].StartIp = w.(string)
															}

														}

													}

												}

											}

											if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

												addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

											}

											if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												addressChoiceInt.DhcpServer.FixedIpMap = ms
											}

											interfacesAddressingChoiceTypeFound := false

											if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
													interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
													interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true
												interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
												interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
												addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
													}

												}

											}

										}

									}

									if v, ok := storageInterfaceMapStrToI["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StaticIp{}
										addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIPParametersType{}
										storageInterface.AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if w, ok := storageInterfaceMapStrToI["device"]; ok && !isIntfNil(w) {
										storageInterface.Device = w.(string)
									}

									ipv6AddressChoiceTypeFound := false

									if v, ok := storageInterfaceMapStrToI["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true

										if v.(bool) {
											ipv6AddressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_NoIpv6Address{}
											ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
											storageInterface.Ipv6AddressChoice = ipv6AddressChoiceInt
										}

									}

									if v, ok := storageInterfaceMapStrToI["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StaticIpv6Address{}
										ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
										storageInterface.Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									monitoringChoiceTypeFound := false

									if v, ok := storageInterfaceMapStrToI["monitor"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true
										_ = v
									}

									if v, ok := storageInterfaceMapStrToI["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true

										if v.(bool) {
											monitoringChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_MonitorDisabled{}
											monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
											storageInterface.MonitoringChoice = monitoringChoiceInt
										}

									}

									if w, ok := storageInterfaceMapStrToI["mtu"]; ok && !isIntfNil(w) {
										storageInterface.Mtu = uint32(w.(int))
									}

									networkChoiceTypeFound := false

									if v, ok := storageInterfaceMapStrToI["inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true
										networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_InsideNetwork{}
										networkChoiceInt.InsideNetwork = &ves_io_schema_views.ObjectRefType{}
										storageInterface.NetworkChoice = networkChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												networkChoiceInt.InsideNetwork.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												networkChoiceInt.InsideNetwork.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												networkChoiceInt.InsideNetwork.Tenant = v.(string)

											}

										}

									}

									if v, ok := storageInterfaceMapStrToI["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SiteLocalInsideNetwork{}
											networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
											storageInterface.NetworkChoice = networkChoiceInt
										}

									}

									if v, ok := storageInterfaceMapStrToI["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SiteLocalNetwork{}
											networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
											storageInterface.NetworkChoice = networkChoiceInt
										}

									}

									if v, ok := storageInterfaceMapStrToI["srv6_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true
										networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Srv6Network{}
										networkChoiceInt.Srv6Network = &ves_io_schema_views.ObjectRefType{}
										storageInterface.NetworkChoice = networkChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												networkChoiceInt.Srv6Network.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												networkChoiceInt.Srv6Network.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												networkChoiceInt.Srv6Network.Tenant = v.(string)

											}

										}

									}

									if v, ok := storageInterfaceMapStrToI["storage_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StorageNetwork{}
											networkChoiceInt.StorageNetwork = &ves_io_schema.Empty{}
											storageInterface.NetworkChoice = networkChoiceInt
										}

									}

									nodeChoiceTypeFound := false

									if v, ok := storageInterfaceMapStrToI["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true

										if v.(bool) {
											nodeChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Cluster{}
											nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
											storageInterface.NodeChoice = nodeChoiceInt
										}

									}

									if v, ok := storageInterfaceMapStrToI["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true
										nodeChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Node{}

										storageInterface.NodeChoice = nodeChoiceInt

										nodeChoiceInt.Node = v.(string)

									}

									primaryChoiceTypeFound := false

									if v, ok := storageInterfaceMapStrToI["is_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

										primaryChoiceTypeFound = true

										if v.(bool) {
											primaryChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_IsPrimary{}
											primaryChoiceInt.IsPrimary = &ves_io_schema.Empty{}
											storageInterface.PrimaryChoice = primaryChoiceInt
										}

									}

									if v, ok := storageInterfaceMapStrToI["not_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

										primaryChoiceTypeFound = true

										if v.(bool) {
											primaryChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_NotPrimary{}
											primaryChoiceInt.NotPrimary = &ves_io_schema.Empty{}
											storageInterface.PrimaryChoice = primaryChoiceInt
										}

									}

									if w, ok := storageInterfaceMapStrToI["priority"]; ok && !isIntfNil(w) {
										storageInterface.Priority = uint32(w.(int))
									}

									vlanChoiceTypeFound := false

									if v, ok := storageInterfaceMapStrToI["untagged"]; ok && !isIntfNil(v) && !vlanChoiceTypeFound {

										vlanChoiceTypeFound = true

										if v.(bool) {
											vlanChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Untagged{}
											vlanChoiceInt.Untagged = &ves_io_schema.Empty{}
											storageInterface.VlanChoice = vlanChoiceInt
										}

									}

									if v, ok := storageInterfaceMapStrToI["vlan_id"]; ok && !isIntfNil(v) && !vlanChoiceTypeFound {

										vlanChoiceTypeFound = true
										vlanChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_VlanId{}

										storageInterface.VlanChoice = vlanChoiceInt

										vlanChoiceInt.VlanId = uint32(v.(int))

									}

								}

							}

						}

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("default_storage_config"); ok && !storageCfgChoiceTypeFound {

		storageCfgChoiceTypeFound = true

		if v.(bool) {
			storageCfgChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_DefaultStorageConfig{}
			storageCfgChoiceInt.DefaultStorageConfig = &ves_io_schema.Empty{}
			createSpec.StorageCfgChoice = storageCfgChoiceInt
		}

	}

	//sw
	if v, ok := d.GetOk("sw"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		sw := &ves_io_schema_views.VolterraSoftwareType{}
		createSpec.Sw = sw
		for _, set := range sl {
			swMapStrToI := set.(map[string]interface{})

			volterraSwVersionChoiceTypeFound := false

			if v, ok := swMapStrToI["default_sw_version"]; ok && !isIntfNil(v) && !volterraSwVersionChoiceTypeFound {

				volterraSwVersionChoiceTypeFound = true

				if v.(bool) {
					volterraSwVersionChoiceInt := &ves_io_schema_views.VolterraSoftwareType_DefaultSwVersion{}
					volterraSwVersionChoiceInt.DefaultSwVersion = &ves_io_schema.Empty{}
					sw.VolterraSwVersionChoice = volterraSwVersionChoiceInt
				}

			}

			if v, ok := swMapStrToI["volterra_software_version"]; ok && !isIntfNil(v) && !volterraSwVersionChoiceTypeFound {

				volterraSwVersionChoiceTypeFound = true
				volterraSwVersionChoiceInt := &ves_io_schema_views.VolterraSoftwareType_VolterraSoftwareVersion{}

				sw.VolterraSwVersionChoice = volterraSwVersionChoiceInt

				volterraSwVersionChoiceInt.VolterraSoftwareVersion = v.(string)

			}

		}

	}

	//usb_policy_choice

	usbPolicyChoiceTypeFound := false

	if v, ok := d.GetOk("allow_all_usb"); ok && !usbPolicyChoiceTypeFound {

		usbPolicyChoiceTypeFound = true

		if v.(bool) {
			usbPolicyChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_AllowAllUsb{}
			usbPolicyChoiceInt.AllowAllUsb = &ves_io_schema.Empty{}
			createSpec.UsbPolicyChoice = usbPolicyChoiceInt
		}

	}

	if v, ok := d.GetOk("deny_all_usb"); ok && !usbPolicyChoiceTypeFound {

		usbPolicyChoiceTypeFound = true

		if v.(bool) {
			usbPolicyChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_DenyAllUsb{}
			usbPolicyChoiceInt.DenyAllUsb = &ves_io_schema.Empty{}
			createSpec.UsbPolicyChoice = usbPolicyChoiceInt
		}

	}

	if v, ok := d.GetOk("usb_policy"); ok && !usbPolicyChoiceTypeFound {

		usbPolicyChoiceTypeFound = true
		usbPolicyChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_UsbPolicy{}
		usbPolicyChoiceInt.UsbPolicy = &ves_io_schema_views.ObjectRefType{}
		createSpec.UsbPolicyChoice = usbPolicyChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["name"]; ok && !isIntfNil(v) {

				usbPolicyChoiceInt.UsbPolicy.Name = v.(string)

			}

			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

				usbPolicyChoiceInt.UsbPolicy.Namespace = v.(string)

			}

			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

				usbPolicyChoiceInt.UsbPolicy.Tenant = v.(string)

			}

		}

	}

	//vm_choice

	vmChoiceTypeFound := false

	if v, ok := d.GetOk("disable_vm"); ok && !vmChoiceTypeFound {

		vmChoiceTypeFound = true

		if v.(bool) {
			vmChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_DisableVm{}
			vmChoiceInt.DisableVm = &ves_io_schema.Empty{}
			createSpec.VmChoice = vmChoiceInt
		}

	}

	// manually edited the config, should be fixed by next releas
	if v, ok := d.GetOk("enable_vm"); ok && !vmChoiceTypeFound {

		vmChoiceTypeFound = true
		if v.(bool) {
			vmChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_EnableVm{}
			vmChoiceInt.EnableVm = &ves_io_schema_fleet.VMConfiguration{}
			createSpec.VmChoice = vmChoiceInt
		}
	}

	//volterra_certified_hw
	if v, ok := d.GetOk("volterra_certified_hw"); ok && !isIntfNil(v) {

		createSpec.VolterraCertifiedHw =
			v.(string)

	}

	//worker_nodes
	if v, ok := d.GetOk("worker_nodes"); ok && !isIntfNil(v) {

		ls := make([]string, len(v.([]interface{})))
		for i, v := range v.([]interface{}) {
			ls[i] = v.(string)
		}
		createSpec.WorkerNodes = ls

	}

	log.Printf("[DEBUG] Creating Volterra VoltstackSite object with struct: %+v", createReq)

	createVoltstackSiteResp, err := client.CreateObject(context.Background(), ves_io_schema_views_voltstack_site.ObjectType, createReq)
	if err != nil {
		return fmt.Errorf("error creating VoltstackSite: %s", err)
	}
	d.SetId(createVoltstackSiteResp.GetObjSystemMetadata().GetUid())

	return resourceVolterraVoltstackSiteRead(d, meta)
}

func resourceVolterraVoltstackSiteRead(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	resp, err := client.GetObject(context.Background(), ves_io_schema_views_voltstack_site.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] VoltstackSite %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra VoltstackSite %q: %s", d.Id(), err)
	}
	return setVoltstackSiteFields(client, d, resp)
}

func setVoltstackSiteFields(client *APIClient, d *schema.ResourceData, resp vesapi.GetObjectResponse) error {
	metadata := resp.GetObjMetadata()

	d.Set("annotations", metadata.GetAnnotations())

	d.Set("description", metadata.GetDescription())

	d.Set("disable", metadata.GetDisable())

	d.Set("labels", metadata.GetLabels())

	d.Set("name", metadata.GetName())

	d.Set("namespace", metadata.GetNamespace())

	return nil
}

// resourceVolterraVoltstackSiteUpdate updates VoltstackSite resource
func resourceVolterraVoltstackSiteUpdate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	updateMeta := &ves_io_schema.ObjectReplaceMetaType{}
	updateSpec := &ves_io_schema_views_voltstack_site.ReplaceSpecType{}
	updateReq := &ves_io_schema_views_voltstack_site.ReplaceRequest{
		Metadata: updateMeta,
		Spec:     updateSpec,
	}
	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		updateMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		updateMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		updateMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		updateMeta.Namespace =
			v.(string)
	}

	if v, ok := d.GetOk("address"); ok && !isIntfNil(v) {

		updateSpec.Address =
			v.(string)

	}

	blockedServicesChoiceTypeFound := false

	if v, ok := d.GetOk("blocked_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true
		blockedServicesChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_BlockedServices{}
		blockedServicesChoiceInt.BlockedServices = &ves_io_schema_fleet.BlockedServicesListType{}
		updateSpec.BlockedServicesChoice = blockedServicesChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["blocked_sevice"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				blockedSevice := make([]*ves_io_schema_fleet.BlockedServices, len(sl))
				blockedServicesChoiceInt.BlockedServices.BlockedSevice = blockedSevice
				for i, set := range sl {
					blockedSevice[i] = &ves_io_schema_fleet.BlockedServices{}
					blockedSeviceMapStrToI := set.(map[string]interface{})

					blockedServicesValueTypeChoiceTypeFound := false

					if v, ok := blockedSeviceMapStrToI["dns"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

						blockedServicesValueTypeChoiceTypeFound = true

						if v.(bool) {
							blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Dns{}
							blockedServicesValueTypeChoiceInt.Dns = &ves_io_schema.Empty{}
							blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
						}

					}

					if v, ok := blockedSeviceMapStrToI["ssh"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

						blockedServicesValueTypeChoiceTypeFound = true

						if v.(bool) {
							blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Ssh{}
							blockedServicesValueTypeChoiceInt.Ssh = &ves_io_schema.Empty{}
							blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
						}

					}

					if v, ok := blockedSeviceMapStrToI["web_user_interface"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

						blockedServicesValueTypeChoiceTypeFound = true

						if v.(bool) {
							blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_WebUserInterface{}
							blockedServicesValueTypeChoiceInt.WebUserInterface = &ves_io_schema.Empty{}
							blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
						}

					}

					if v, ok := blockedSeviceMapStrToI["network_type"]; ok && !isIntfNil(v) {

						blockedSevice[i].NetworkType = ves_io_schema.VirtualNetworkType(ves_io_schema.VirtualNetworkType_value[v.(string)])

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("default_blocked_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true

		if v.(bool) {
			blockedServicesChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_DefaultBlockedServices{}
			blockedServicesChoiceInt.DefaultBlockedServices = &ves_io_schema.Empty{}
			updateSpec.BlockedServicesChoice = blockedServicesChoiceInt
		}

	}

	bondChoiceTypeFound := false

	if v, ok := d.GetOk("bond_device_list"); ok && !bondChoiceTypeFound {

		bondChoiceTypeFound = true
		bondChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_BondDeviceList{}
		bondChoiceInt.BondDeviceList = &ves_io_schema_fleet.FleetBondDevicesListType{}
		updateSpec.BondChoice = bondChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["bond_devices"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				bondDevices := make([]*ves_io_schema_fleet.FleetBondDeviceType, len(sl))
				bondChoiceInt.BondDeviceList.BondDevices = bondDevices
				for i, set := range sl {
					bondDevices[i] = &ves_io_schema_fleet.FleetBondDeviceType{}
					bondDevicesMapStrToI := set.(map[string]interface{})

					if w, ok := bondDevicesMapStrToI["devices"]; ok && !isIntfNil(w) {
						ls := make([]string, len(w.([]interface{})))
						for i, v := range w.([]interface{}) {
							ls[i] = v.(string)
						}
						bondDevices[i].Devices = ls
					}

					lacpChoiceTypeFound := false

					if v, ok := bondDevicesMapStrToI["active_backup"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

						lacpChoiceTypeFound = true

						if v.(bool) {
							lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_ActiveBackup{}
							lacpChoiceInt.ActiveBackup = &ves_io_schema.Empty{}
							bondDevices[i].LacpChoice = lacpChoiceInt
						}

					}

					if v, ok := bondDevicesMapStrToI["lacp"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

						lacpChoiceTypeFound = true
						lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_Lacp{}
						lacpChoiceInt.Lacp = &ves_io_schema_fleet.BondLacpType{}
						bondDevices[i].LacpChoice = lacpChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["rate"]; ok && !isIntfNil(v) {

								lacpChoiceInt.Lacp.Rate = uint32(v.(int))

							}

						}

					}

					if w, ok := bondDevicesMapStrToI["link_polling_interval"]; ok && !isIntfNil(w) {
						bondDevices[i].LinkPollingInterval = uint32(w.(int))
					}

					if w, ok := bondDevicesMapStrToI["link_up_delay"]; ok && !isIntfNil(w) {
						bondDevices[i].LinkUpDelay = uint32(w.(int))
					}

					if w, ok := bondDevicesMapStrToI["name"]; ok && !isIntfNil(w) {
						bondDevices[i].Name = w.(string)
					}

				}

			}

		}

	}

	if v, ok := d.GetOk("no_bond_devices"); ok && !bondChoiceTypeFound {

		bondChoiceTypeFound = true

		if v.(bool) {
			bondChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_NoBondDevices{}
			bondChoiceInt.NoBondDevices = &ves_io_schema.Empty{}
			updateSpec.BondChoice = bondChoiceInt
		}

	}

	if v, ok := d.GetOk("coordinates"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		coordinates := &ves_io_schema_site.Coordinates{}
		updateSpec.Coordinates = coordinates
		for _, set := range sl {
			coordinatesMapStrToI := set.(map[string]interface{})

			if w, ok := coordinatesMapStrToI["latitude"]; ok && !isIntfNil(w) {
				coordinates.Latitude = float32(w.(float64))
			}

			if w, ok := coordinatesMapStrToI["longitude"]; ok && !isIntfNil(w) {
				coordinates.Longitude = float32(w.(float64))
			}

		}

	}

	gpuChoiceTypeFound := false

	if v, ok := d.GetOk("disable_gpu"); ok && !gpuChoiceTypeFound {

		gpuChoiceTypeFound = true

		if v.(bool) {
			gpuChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_DisableGpu{}
			gpuChoiceInt.DisableGpu = &ves_io_schema.Empty{}
			updateSpec.GpuChoice = gpuChoiceInt
		}

	}

	if v, ok := d.GetOk("enable_gpu"); ok && !gpuChoiceTypeFound {

		gpuChoiceTypeFound = true

		if v.(bool) {
			gpuChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_EnableGpu{}
			gpuChoiceInt.EnableGpu = &ves_io_schema.Empty{}
			updateSpec.GpuChoice = gpuChoiceInt
		}

	}

	if v, ok := d.GetOk("enable_vgpu"); ok && !gpuChoiceTypeFound {

		gpuChoiceTypeFound = true
		gpuChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_EnableVgpu{}
		gpuChoiceInt.EnableVgpu = &ves_io_schema_fleet.VGPUConfiguration{}
		updateSpec.GpuChoice = gpuChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["feature_type"]; ok && !isIntfNil(v) {

				gpuChoiceInt.EnableVgpu.FeatureType = ves_io_schema_fleet.VGPUFeatureType(ves_io_schema_fleet.VGPUFeatureType_value[v.(string)])

			}

			if v, ok := cs["server_address"]; ok && !isIntfNil(v) {

				gpuChoiceInt.EnableVgpu.ServerAddress = v.(string)

			}

			if v, ok := cs["server_port"]; ok && !isIntfNil(v) {

				gpuChoiceInt.EnableVgpu.ServerPort = uint32(v.(int))

			}

		}

	}

	k8SClusterChoiceTypeFound := false

	if v, ok := d.GetOk("k8s_cluster"); ok && !k8SClusterChoiceTypeFound {

		k8SClusterChoiceTypeFound = true
		k8SClusterChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_K8SCluster{}
		k8SClusterChoiceInt.K8SCluster = &ves_io_schema_views.ObjectRefType{}
		updateSpec.K8SClusterChoice = k8SClusterChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["name"]; ok && !isIntfNil(v) {

				k8SClusterChoiceInt.K8SCluster.Name = v.(string)

			}

			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

				k8SClusterChoiceInt.K8SCluster.Namespace = v.(string)

			}

			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

				k8SClusterChoiceInt.K8SCluster.Tenant = v.(string)

			}

		}

	}

	if v, ok := d.GetOk("no_k8s_cluster"); ok && !k8SClusterChoiceTypeFound {

		k8SClusterChoiceTypeFound = true

		if v.(bool) {
			k8SClusterChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_NoK8SCluster{}
			k8SClusterChoiceInt.NoK8SCluster = &ves_io_schema.Empty{}
			updateSpec.K8SClusterChoice = k8SClusterChoiceInt
		}

	}

	localControlPlaneChoiceTypeFound := false

	if v, ok := d.GetOk("local_control_plane"); ok && !localControlPlaneChoiceTypeFound {

		localControlPlaneChoiceTypeFound = true
		localControlPlaneChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_LocalControlPlane{}
		localControlPlaneChoiceInt.LocalControlPlane = &ves_io_schema_fleet.LocalControlPlaneType{}
		updateSpec.LocalControlPlaneChoice = localControlPlaneChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["bgp_config"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				bgpConfig := &ves_io_schema_fleet.BGPConfiguration{}
				localControlPlaneChoiceInt.LocalControlPlane.BgpConfig = bgpConfig
				for _, set := range sl {
					bgpConfigMapStrToI := set.(map[string]interface{})

					if w, ok := bgpConfigMapStrToI["asn"]; ok && !isIntfNil(w) {
						bgpConfig.Asn = uint32(w.(int))
					}

					if v, ok := bgpConfigMapStrToI["peers"]; ok && !isIntfNil(v) {

						//sl := v.([]interface{})
						peers := make([]*ves_io_schema_bgp.Peer, len(sl))
						bgpConfig.Peers = peers
						/*
							for i, set := range sl {
								peers[i] = &ves_io_schema_bgp.Peer{}
								peersMapStrToI := set.(map[string]interface{})

							}
						*/

					}

				}

			}

			networkChoiceTypeFound := false

			if v, ok := cs["inside_vn"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

				networkChoiceTypeFound = true

				if v.(bool) {
					networkChoiceInt := &ves_io_schema_fleet.LocalControlPlaneType_InsideVn{}
					networkChoiceInt.InsideVn = &ves_io_schema.Empty{}
					localControlPlaneChoiceInt.LocalControlPlane.NetworkChoice = networkChoiceInt
				}

			}

			if v, ok := cs["outside_vn"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

				networkChoiceTypeFound = true

				if v.(bool) {
					networkChoiceInt := &ves_io_schema_fleet.LocalControlPlaneType_OutsideVn{}
					networkChoiceInt.OutsideVn = &ves_io_schema.Empty{}
					localControlPlaneChoiceInt.LocalControlPlane.NetworkChoice = networkChoiceInt
				}

			}

		}

	}

	if v, ok := d.GetOk("no_local_control_plane"); ok && !localControlPlaneChoiceTypeFound {

		localControlPlaneChoiceTypeFound = true

		if v.(bool) {
			localControlPlaneChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_NoLocalControlPlane{}
			localControlPlaneChoiceInt.NoLocalControlPlane = &ves_io_schema.Empty{}
			updateSpec.LocalControlPlaneChoice = localControlPlaneChoiceInt
		}

	}

	logsReceiverChoiceTypeFound := false

	if v, ok := d.GetOk("log_receiver"); ok && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true
		logsReceiverChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_LogReceiver{}
		logsReceiverChoiceInt.LogReceiver = &ves_io_schema_views.ObjectRefType{}
		updateSpec.LogsReceiverChoice = logsReceiverChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["name"]; ok && !isIntfNil(v) {

				logsReceiverChoiceInt.LogReceiver.Name = v.(string)

			}

			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

				logsReceiverChoiceInt.LogReceiver.Namespace = v.(string)

			}

			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

				logsReceiverChoiceInt.LogReceiver.Tenant = v.(string)

			}

		}

	}

	if v, ok := d.GetOk("logs_streaming_disabled"); ok && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true

		if v.(bool) {
			logsReceiverChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_LogsStreamingDisabled{}
			logsReceiverChoiceInt.LogsStreamingDisabled = &ves_io_schema.Empty{}
			updateSpec.LogsReceiverChoice = logsReceiverChoiceInt
		}

	}

	if v, ok := d.GetOk("master_nodes"); ok && !isIntfNil(v) {

		ls := make([]string, len(v.([]interface{})))
		for i, v := range v.([]interface{}) {
			ls[i] = v.(string)
		}
		updateSpec.MasterNodes = ls

	}

	networkCfgChoiceTypeFound := false

	if v, ok := d.GetOk("custom_network_config"); ok && !networkCfgChoiceTypeFound {

		networkCfgChoiceTypeFound = true
		networkCfgChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_CustomNetworkConfig{}
		networkCfgChoiceInt.CustomNetworkConfig = &ves_io_schema_views_voltstack_site.VssNetworkConfiguration{}
		updateSpec.NetworkCfgChoice = networkCfgChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["bgp_peer_address"]; ok && !isIntfNil(v) {

				networkCfgChoiceInt.CustomNetworkConfig.BgpPeerAddress = v.(string)

			}

			if v, ok := cs["bgp_router_id"]; ok && !isIntfNil(v) {

				networkCfgChoiceInt.CustomNetworkConfig.BgpRouterId = v.(string)

			}

			forwardProxyChoiceTypeFound := false

			if v, ok := cs["active_forward_proxy_policies"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

				forwardProxyChoiceTypeFound = true
				forwardProxyChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_ActiveForwardProxyPolicies{}
				forwardProxyChoiceInt.ActiveForwardProxyPolicies = &ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType{}
				networkCfgChoiceInt.CustomNetworkConfig.ForwardProxyChoice = forwardProxyChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["forward_proxy_policies"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						forwardProxyPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						forwardProxyChoiceInt.ActiveForwardProxyPolicies.ForwardProxyPolicies = forwardProxyPoliciesInt
						for i, ps := range sl {

							fppMapToStrVal := ps.(map[string]interface{})
							forwardProxyPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := fppMapToStrVal["name"]; ok && !isIntfNil(v) {
								forwardProxyPoliciesInt[i].Name = v.(string)
							}

							if v, ok := fppMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								forwardProxyPoliciesInt[i].Namespace = v.(string)
							}

							if v, ok := fppMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								forwardProxyPoliciesInt[i].Tenant = v.(string)
							}

						}

					}

				}

			}

			if v, ok := cs["forward_proxy_allow_all"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

				forwardProxyChoiceTypeFound = true

				if v.(bool) {
					forwardProxyChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_ForwardProxyAllowAll{}
					forwardProxyChoiceInt.ForwardProxyAllowAll = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.ForwardProxyChoice = forwardProxyChoiceInt
				}

			}

			if v, ok := cs["no_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

				forwardProxyChoiceTypeFound = true

				if v.(bool) {
					forwardProxyChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_NoForwardProxy{}
					forwardProxyChoiceInt.NoForwardProxy = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.ForwardProxyChoice = forwardProxyChoiceInt
				}

			}

			globalNetworkChoiceTypeFound := false

			if v, ok := cs["global_network_list"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

				globalNetworkChoiceTypeFound = true
				globalNetworkChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_GlobalNetworkList{}
				globalNetworkChoiceInt.GlobalNetworkList = &ves_io_schema_views.GlobalNetworkConnectionListType{}
				networkCfgChoiceInt.CustomNetworkConfig.GlobalNetworkChoice = globalNetworkChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["global_network_connections"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						globalNetworkConnections := make([]*ves_io_schema_views.GlobalNetworkConnectionType, len(sl))
						globalNetworkChoiceInt.GlobalNetworkList.GlobalNetworkConnections = globalNetworkConnections
						for i, set := range sl {
							globalNetworkConnections[i] = &ves_io_schema_views.GlobalNetworkConnectionType{}
							globalNetworkConnectionsMapStrToI := set.(map[string]interface{})

							connectionChoiceTypeFound := false

							if v, ok := globalNetworkConnectionsMapStrToI["sli_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

								connectionChoiceTypeFound = true
								connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SliToGlobalDr{}
								connectionChoiceInt.SliToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
								globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										globalVn := &ves_io_schema_views.ObjectRefType{}
										connectionChoiceInt.SliToGlobalDr.GlobalVn = globalVn
										for _, set := range sl {
											globalVnMapStrToI := set.(map[string]interface{})

											if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
												globalVn.Name = w.(string)
											}

											if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
												globalVn.Namespace = w.(string)
											}

											if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
												globalVn.Tenant = w.(string)
											}

										}

									}

								}

							}

							if v, ok := globalNetworkConnectionsMapStrToI["slo_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

								connectionChoiceTypeFound = true
								connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SloToGlobalDr{}
								connectionChoiceInt.SloToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
								globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										globalVn := &ves_io_schema_views.ObjectRefType{}
										connectionChoiceInt.SloToGlobalDr.GlobalVn = globalVn
										for _, set := range sl {
											globalVnMapStrToI := set.(map[string]interface{})

											if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
												globalVn.Name = w.(string)
											}

											if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
												globalVn.Namespace = w.(string)
											}

											if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
												globalVn.Tenant = w.(string)
											}

										}

									}

								}

							}

							forwardProxyChoiceTypeFound := false

							if v, ok := globalNetworkConnectionsMapStrToI["disable_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

								forwardProxyChoiceTypeFound = true

								if v.(bool) {
									forwardProxyChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_DisableForwardProxy{}
									forwardProxyChoiceInt.DisableForwardProxy = &ves_io_schema.Empty{}
									globalNetworkConnections[i].ForwardProxyChoice = forwardProxyChoiceInt
								}

							}

							if v, ok := globalNetworkConnectionsMapStrToI["enable_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

								forwardProxyChoiceTypeFound = true
								forwardProxyChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_EnableForwardProxy{}
								forwardProxyChoiceInt.EnableForwardProxy = &ves_io_schema.ForwardProxyConfigType{}
								globalNetworkConnections[i].ForwardProxyChoice = forwardProxyChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["connection_timeout"]; ok && !isIntfNil(v) {

										forwardProxyChoiceInt.EnableForwardProxy.ConnectionTimeout = uint32(v.(int))

									}

									if v, ok := cs["max_connect_attempts"]; ok && !isIntfNil(v) {

										forwardProxyChoiceInt.EnableForwardProxy.MaxConnectAttempts = uint32(v.(int))

									}

									tlsInterceptionChoiceTypeFound := false

									if v, ok := cs["no_interception"]; ok && !isIntfNil(v) && !tlsInterceptionChoiceTypeFound {

										tlsInterceptionChoiceTypeFound = true

										if v.(bool) {
											tlsInterceptionChoiceInt := &ves_io_schema.ForwardProxyConfigType_NoInterception{}
											tlsInterceptionChoiceInt.NoInterception = &ves_io_schema.Empty{}
											forwardProxyChoiceInt.EnableForwardProxy.TlsInterceptionChoice = tlsInterceptionChoiceInt
										}

									}

									if v, ok := cs["tls_intercept"]; ok && !isIntfNil(v) && !tlsInterceptionChoiceTypeFound {

										tlsInterceptionChoiceTypeFound = true
										tlsInterceptionChoiceInt := &ves_io_schema.ForwardProxyConfigType_TlsIntercept{}
										tlsInterceptionChoiceInt.TlsIntercept = &ves_io_schema.TlsInterceptionType{}
										forwardProxyChoiceInt.EnableForwardProxy.TlsInterceptionChoice = tlsInterceptionChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											interceptionPolicyChoiceTypeFound := false

											if v, ok := cs["enable_for_all_domains"]; ok && !isIntfNil(v) && !interceptionPolicyChoiceTypeFound {

												interceptionPolicyChoiceTypeFound = true

												if v.(bool) {
													interceptionPolicyChoiceInt := &ves_io_schema.TlsInterceptionType_EnableForAllDomains{}
													interceptionPolicyChoiceInt.EnableForAllDomains = &ves_io_schema.Empty{}
													tlsInterceptionChoiceInt.TlsIntercept.InterceptionPolicyChoice = interceptionPolicyChoiceInt
												}

											}

											if v, ok := cs["policy"]; ok && !isIntfNil(v) && !interceptionPolicyChoiceTypeFound {

												interceptionPolicyChoiceTypeFound = true
												interceptionPolicyChoiceInt := &ves_io_schema.TlsInterceptionType_Policy{}
												interceptionPolicyChoiceInt.Policy = &ves_io_schema.TlsInterceptionPolicy{}
												tlsInterceptionChoiceInt.TlsIntercept.InterceptionPolicyChoice = interceptionPolicyChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interception_rules"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														interceptionRules := make([]*ves_io_schema.TlsInterceptionRule, len(sl))
														interceptionPolicyChoiceInt.Policy.InterceptionRules = interceptionRules
														for i, set := range sl {
															interceptionRules[i] = &ves_io_schema.TlsInterceptionRule{}
															interceptionRulesMapStrToI := set.(map[string]interface{})

															if v, ok := interceptionRulesMapStrToI["domain_match"]; ok && !isIntfNil(v) {

																sl := v.(*schema.Set).List()
																domainMatch := &ves_io_schema.DomainType{}
																interceptionRules[i].DomainMatch = domainMatch
																for _, set := range sl {
																	domainMatchMapStrToI := set.(map[string]interface{})

																	domainChoiceTypeFound := false

																	if v, ok := domainMatchMapStrToI["exact_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																		domainChoiceTypeFound = true
																		domainChoiceInt := &ves_io_schema.DomainType_ExactValue{}

																		domainMatch.DomainChoice = domainChoiceInt

																		domainChoiceInt.ExactValue = v.(string)

																	}

																	if v, ok := domainMatchMapStrToI["regex_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																		domainChoiceTypeFound = true
																		domainChoiceInt := &ves_io_schema.DomainType_RegexValue{}

																		domainMatch.DomainChoice = domainChoiceInt

																		domainChoiceInt.RegexValue = v.(string)

																	}

																	if v, ok := domainMatchMapStrToI["suffix_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																		domainChoiceTypeFound = true
																		domainChoiceInt := &ves_io_schema.DomainType_SuffixValue{}

																		domainMatch.DomainChoice = domainChoiceInt

																		domainChoiceInt.SuffixValue = v.(string)

																	}

																}

															}

															enableDisableChoiceTypeFound := false

															if v, ok := interceptionRulesMapStrToI["disable_interception"]; ok && !isIntfNil(v) && !enableDisableChoiceTypeFound {

																enableDisableChoiceTypeFound = true

																if v.(bool) {
																	enableDisableChoiceInt := &ves_io_schema.TlsInterceptionRule_DisableInterception{}
																	enableDisableChoiceInt.DisableInterception = &ves_io_schema.Empty{}
																	interceptionRules[i].EnableDisableChoice = enableDisableChoiceInt
																}

															}

															if v, ok := interceptionRulesMapStrToI["enable_interception"]; ok && !isIntfNil(v) && !enableDisableChoiceTypeFound {

																enableDisableChoiceTypeFound = true

																if v.(bool) {
																	enableDisableChoiceInt := &ves_io_schema.TlsInterceptionRule_EnableInterception{}
																	enableDisableChoiceInt.EnableInterception = &ves_io_schema.Empty{}
																	interceptionRules[i].EnableDisableChoice = enableDisableChoiceInt
																}

															}

														}

													}

												}

											}

											signingCertChoiceTypeFound := false

											if v, ok := cs["custom_certificate"]; ok && !isIntfNil(v) && !signingCertChoiceTypeFound {

												signingCertChoiceTypeFound = true
												signingCertChoiceInt := &ves_io_schema.TlsInterceptionType_CustomCertificate{}
												signingCertChoiceInt.CustomCertificate = &ves_io_schema.TlsCertificateType{}
												tlsInterceptionChoiceInt.TlsIntercept.SigningCertChoice = signingCertChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["certificate_url"]; ok && !isIntfNil(v) {

														signingCertChoiceInt.CustomCertificate.CertificateUrl = v.(string)

													}

													if v, ok := cs["description"]; ok && !isIntfNil(v) {

														signingCertChoiceInt.CustomCertificate.Description = v.(string)

													}

													ocspStaplingChoiceTypeFound := false

													if v, ok := cs["custom_hash_algorithms"]; ok && !isIntfNil(v) && !ocspStaplingChoiceTypeFound {

														ocspStaplingChoiceTypeFound = true
														ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_CustomHashAlgorithms{}
														ocspStaplingChoiceInt.CustomHashAlgorithms = &ves_io_schema.HashAlgorithms{}
														signingCertChoiceInt.CustomCertificate.OcspStaplingChoice = ocspStaplingChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["hash_algorithms"]; ok && !isIntfNil(v) {

																hash_algorithmsList := []ves_io_schema.HashAlgorithm{}
																for _, j := range v.([]interface{}) {
																	hash_algorithmsList = append(hash_algorithmsList, ves_io_schema.HashAlgorithm(ves_io_schema.HashAlgorithm_value[j.(string)]))
																}
																ocspStaplingChoiceInt.CustomHashAlgorithms.HashAlgorithms = hash_algorithmsList

															}

														}

													}

													if v, ok := cs["disable_ocsp_stapling"]; ok && !isIntfNil(v) && !ocspStaplingChoiceTypeFound {

														ocspStaplingChoiceTypeFound = true
														_ = v
													}

													if v, ok := cs["use_system_defaults"]; ok && !isIntfNil(v) && !ocspStaplingChoiceTypeFound {

														ocspStaplingChoiceTypeFound = true
														_ = v
													}

													if v, ok := cs["private_key"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														privateKey := &ves_io_schema.SecretType{}
														signingCertChoiceInt.CustomCertificate.PrivateKey = privateKey
														for _, set := range sl {
															privateKeyMapStrToI := set.(map[string]interface{})

															if v, ok := privateKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																sl := v.(*schema.Set).List()
																blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																privateKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																for _, set := range sl {
																	blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																	}

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.Location = w.(string)
																	}

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.StoreProvider = w.(string)
																	}

																}

															}

															if v, ok := privateKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																privateKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

															}

															secretInfoOneofTypeFound := false

															if v, ok := privateKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																	}

																	if v, ok := cs["location"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																	}

																	if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																	}

																}

															}

															if v, ok := privateKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																	}

																	if v, ok := cs["url"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																	}

																}

															}

															if v, ok := privateKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["key"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																	}

																	if v, ok := cs["location"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																	}

																	if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																	}

																	if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																	}

																	if v, ok := cs["version"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																	}

																}

															}

															if v, ok := privateKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["name"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																	}

																}

															}

														}

													}

												}

											}

											if v, ok := cs["volterra_certificate"]; ok && !isIntfNil(v) && !signingCertChoiceTypeFound {

												signingCertChoiceTypeFound = true

												if v.(bool) {
													signingCertChoiceInt := &ves_io_schema.TlsInterceptionType_VolterraCertificate{}
													signingCertChoiceInt.VolterraCertificate = &ves_io_schema.Empty{}
													tlsInterceptionChoiceInt.TlsIntercept.SigningCertChoice = signingCertChoiceInt
												}

											}

											trustedCaChoiceTypeFound := false

											if v, ok := cs["trusted_ca_url"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

												trustedCaChoiceTypeFound = true
												trustedCaChoiceInt := &ves_io_schema.TlsInterceptionType_TrustedCaUrl{}

												tlsInterceptionChoiceInt.TlsIntercept.TrustedCaChoice = trustedCaChoiceInt

												trustedCaChoiceInt.TrustedCaUrl = v.(string)

											}

											if v, ok := cs["volterra_trusted_ca"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

												trustedCaChoiceTypeFound = true

												if v.(bool) {
													trustedCaChoiceInt := &ves_io_schema.TlsInterceptionType_VolterraTrustedCa{}
													trustedCaChoiceInt.VolterraTrustedCa = &ves_io_schema.Empty{}
													tlsInterceptionChoiceInt.TlsIntercept.TrustedCaChoice = trustedCaChoiceInt
												}

											}

										}

									}

									if v, ok := cs["white_listed_ports"]; ok && !isIntfNil(v) {

										ls := make([]uint32, len(v.([]interface{})))
										for i, v := range v.([]interface{}) {
											ls[i] = uint32(v.(int))
										}
										forwardProxyChoiceInt.EnableForwardProxy.WhiteListedPorts = ls

									}

									if v, ok := cs["white_listed_prefixes"]; ok && !isIntfNil(v) {

										ls := make([]string, len(v.([]interface{})))
										for i, v := range v.([]interface{}) {
											ls[i] = v.(string)
										}
										forwardProxyChoiceInt.EnableForwardProxy.WhiteListedPrefixes = ls

									}

								}

							}

						}

					}

				}

			}

			if v, ok := cs["no_global_network"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

				globalNetworkChoiceTypeFound = true

				if v.(bool) {
					globalNetworkChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_NoGlobalNetwork{}
					globalNetworkChoiceInt.NoGlobalNetwork = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.GlobalNetworkChoice = globalNetworkChoiceInt
				}

			}

			interfaceChoiceTypeFound := false

			if v, ok := cs["default_interface_config"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

				interfaceChoiceTypeFound = true

				if v.(bool) {
					interfaceChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_DefaultInterfaceConfig{}
					interfaceChoiceInt.DefaultInterfaceConfig = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.InterfaceChoice = interfaceChoiceInt
				}

			}

			if v, ok := cs["interface_list"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

				interfaceChoiceTypeFound = true
				interfaceChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_InterfaceList{}
				interfaceChoiceInt.InterfaceList = &ves_io_schema_views_voltstack_site.InterfaceListType{}
				networkCfgChoiceInt.CustomNetworkConfig.InterfaceChoice = interfaceChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["interfaces"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						interfaces := make([]*ves_io_schema_views_voltstack_site.Interface, len(sl))
						interfaceChoiceInt.InterfaceList.Interfaces = interfaces
						for i, set := range sl {
							interfaces[i] = &ves_io_schema_views_voltstack_site.Interface{}
							interfacesMapStrToI := set.(map[string]interface{})

							if w, ok := interfacesMapStrToI["description"]; ok && !isIntfNil(w) {
								interfaces[i].Description = w.(string)
							}

							interfaceChoiceTypeFound := false

							if v, ok := interfacesMapStrToI["dedicated_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

								interfaceChoiceTypeFound = true
								interfaceChoiceInt := &ves_io_schema_views_voltstack_site.Interface_DedicatedInterface{}
								interfaceChoiceInt.DedicatedInterface = &ves_io_schema_network_interface.DedicatedInterfaceType{}
								interfaces[i].InterfaceChoice = interfaceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["device"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.DedicatedInterface.Device = v.(string)

									}

									monitoringChoiceTypeFound := false

									if v, ok := cs["monitor"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true
										_ = v
									}

									if v, ok := cs["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true

										if v.(bool) {
											monitoringChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_MonitorDisabled{}
											monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
											interfaceChoiceInt.DedicatedInterface.MonitoringChoice = monitoringChoiceInt
										}

									}

									if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.DedicatedInterface.Mtu = uint32(v.(int))

									}

									nodeChoiceTypeFound := false

									if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true

										if v.(bool) {
											nodeChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_Cluster{}
											nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
											interfaceChoiceInt.DedicatedInterface.NodeChoice = nodeChoiceInt
										}

									}

									if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true
										nodeChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_Node{}

										interfaceChoiceInt.DedicatedInterface.NodeChoice = nodeChoiceInt

										nodeChoiceInt.Node = v.(string)

									}

									primaryChoiceTypeFound := false

									if v, ok := cs["is_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

										primaryChoiceTypeFound = true

										if v.(bool) {
											primaryChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_IsPrimary{}
											primaryChoiceInt.IsPrimary = &ves_io_schema.Empty{}
											interfaceChoiceInt.DedicatedInterface.PrimaryChoice = primaryChoiceInt
										}

									}

									if v, ok := cs["not_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

										primaryChoiceTypeFound = true

										if v.(bool) {
											primaryChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_NotPrimary{}
											primaryChoiceInt.NotPrimary = &ves_io_schema.Empty{}
											interfaceChoiceInt.DedicatedInterface.PrimaryChoice = primaryChoiceInt
										}

									}

									if v, ok := cs["priority"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.DedicatedInterface.Priority = uint32(v.(int))

									}

								}

							}

							if v, ok := interfacesMapStrToI["dedicated_management_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

								interfaceChoiceTypeFound = true
								interfaceChoiceInt := &ves_io_schema_views_voltstack_site.Interface_DedicatedManagementInterface{}
								interfaceChoiceInt.DedicatedManagementInterface = &ves_io_schema_network_interface.DedicatedManagementInterfaceType{}
								interfaces[i].InterfaceChoice = interfaceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["device"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.DedicatedManagementInterface.Device = v.(string)

									}

									if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.DedicatedManagementInterface.Mtu = uint32(v.(int))

									}

									nodeChoiceTypeFound := false

									if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true

										if v.(bool) {
											nodeChoiceInt := &ves_io_schema_network_interface.DedicatedManagementInterfaceType_Cluster{}
											nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
											interfaceChoiceInt.DedicatedManagementInterface.NodeChoice = nodeChoiceInt
										}

									}

									if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true
										nodeChoiceInt := &ves_io_schema_network_interface.DedicatedManagementInterfaceType_Node{}

										interfaceChoiceInt.DedicatedManagementInterface.NodeChoice = nodeChoiceInt

										nodeChoiceInt.Node = v.(string)

									}

								}

							}

							if v, ok := interfacesMapStrToI["ethernet_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

								interfaceChoiceTypeFound = true
								interfaceChoiceInt := &ves_io_schema_views_voltstack_site.Interface_EthernetInterface{}
								interfaceChoiceInt.EthernetInterface = &ves_io_schema_network_interface.EthernetInterfaceType{}
								interfaces[i].InterfaceChoice = interfaceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									addressChoiceTypeFound := false

									if v, ok := cs["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_DhcpClient{}
											addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.AddressChoice = addressChoiceInt
										}

									}

									if v, ok := cs["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_DhcpServer{}
										addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
										interfaceChoiceInt.EthernetInterface.AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
												addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
												for i, set := range sl {
													dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
													dhcpNetworksMapStrToI := set.(map[string]interface{})

													dnsChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true
														dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

														dhcpNetworks[i].DnsChoice = dnsChoiceInt

														dnsChoiceInt.DnsAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true

														if v.(bool) {
															dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
															dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
															dhcpNetworks[i].DnsChoice = dnsChoiceInt
														}

													}

													gatewayChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true
														gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

														dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

														gatewayChoiceInt.DgwAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
															gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
															gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													networkPrefixChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														networkPrefixChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
														networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

															}

															if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

															}

															if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

															}

														}

													}

													if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

														dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

													}

													if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
														dhcpNetworks[i].Pools = pools
														for i, set := range sl {
															pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
															poolsMapStrToI := set.(map[string]interface{})

															if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																pools[i].EndIp = w.(string)
															}

															if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																pools[i].Exclude = w.(bool)
															}

															if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																pools[i].StartIp = w.(string)
															}

														}

													}

												}

											}

											if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

												addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

											}

											if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												addressChoiceInt.DhcpServer.FixedIpMap = ms
											}

											interfacesAddressingChoiceTypeFound := false

											if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
													interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
													interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true
												interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
												interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
												addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
													}

												}

											}

										}

									}

									if v, ok := cs["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StaticIp{}
										addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceChoiceInt.EthernetInterface.AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if v, ok := cs["device"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.EthernetInterface.Device = v.(string)

									}

									ipv6AddressChoiceTypeFound := false

									if v, ok := cs["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true

										if v.(bool) {
											ipv6AddressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_NoIpv6Address{}
											ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.Ipv6AddressChoice = ipv6AddressChoiceInt
										}

									}

									if v, ok := cs["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StaticIpv6Address{}
										ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceChoiceInt.EthernetInterface.Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									monitoringChoiceTypeFound := false

									if v, ok := cs["monitor"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true
										_ = v
									}

									if v, ok := cs["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true

										if v.(bool) {
											monitoringChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_MonitorDisabled{}
											monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.MonitoringChoice = monitoringChoiceInt
										}

									}

									if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.EthernetInterface.Mtu = uint32(v.(int))

									}

									networkChoiceTypeFound := false

									if v, ok := cs["inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true
										networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_InsideNetwork{}
										networkChoiceInt.InsideNetwork = &ves_io_schema_views.ObjectRefType{}
										interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												networkChoiceInt.InsideNetwork.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												networkChoiceInt.InsideNetwork.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												networkChoiceInt.InsideNetwork.Tenant = v.(string)

											}

										}

									}

									if v, ok := cs["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SiteLocalInsideNetwork{}
											networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
										}

									}

									if v, ok := cs["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SiteLocalNetwork{}
											networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
										}

									}

									if v, ok := cs["srv6_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true
										networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Srv6Network{}
										networkChoiceInt.Srv6Network = &ves_io_schema_views.ObjectRefType{}
										interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												networkChoiceInt.Srv6Network.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												networkChoiceInt.Srv6Network.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												networkChoiceInt.Srv6Network.Tenant = v.(string)

											}

										}

									}

									if v, ok := cs["storage_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StorageNetwork{}
											networkChoiceInt.StorageNetwork = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
										}

									}

									nodeChoiceTypeFound := false

									if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true

										if v.(bool) {
											nodeChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Cluster{}
											nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.NodeChoice = nodeChoiceInt
										}

									}

									if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true
										nodeChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Node{}

										interfaceChoiceInt.EthernetInterface.NodeChoice = nodeChoiceInt

										nodeChoiceInt.Node = v.(string)

									}

									primaryChoiceTypeFound := false

									if v, ok := cs["is_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

										primaryChoiceTypeFound = true

										if v.(bool) {
											primaryChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_IsPrimary{}
											primaryChoiceInt.IsPrimary = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.PrimaryChoice = primaryChoiceInt
										}

									}

									if v, ok := cs["not_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

										primaryChoiceTypeFound = true

										if v.(bool) {
											primaryChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_NotPrimary{}
											primaryChoiceInt.NotPrimary = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.PrimaryChoice = primaryChoiceInt
										}

									}

									if v, ok := cs["priority"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.EthernetInterface.Priority = uint32(v.(int))

									}

									vlanChoiceTypeFound := false

									if v, ok := cs["untagged"]; ok && !isIntfNil(v) && !vlanChoiceTypeFound {

										vlanChoiceTypeFound = true

										if v.(bool) {
											vlanChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Untagged{}
											vlanChoiceInt.Untagged = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.VlanChoice = vlanChoiceInt
										}

									}

									if v, ok := cs["vlan_id"]; ok && !isIntfNil(v) && !vlanChoiceTypeFound {

										vlanChoiceTypeFound = true
										vlanChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_VlanId{}

										interfaceChoiceInt.EthernetInterface.VlanChoice = vlanChoiceInt

										vlanChoiceInt.VlanId = uint32(v.(int))

									}

								}

							}

							if v, ok := interfacesMapStrToI["tunnel_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

								interfaceChoiceTypeFound = true
								interfaceChoiceInt := &ves_io_schema_views_voltstack_site.Interface_TunnelInterface{}
								interfaceChoiceInt.TunnelInterface = &ves_io_schema_network_interface.TunnelInterfaceType{}
								interfaces[i].InterfaceChoice = interfaceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.TunnelInterface.Mtu = uint32(v.(int))

									}

									networkChoiceTypeFound := false

									if v, ok := cs["inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true
										networkChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_InsideNetwork{}
										networkChoiceInt.InsideNetwork = &ves_io_schema_views.ObjectRefType{}
										interfaceChoiceInt.TunnelInterface.NetworkChoice = networkChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												networkChoiceInt.InsideNetwork.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												networkChoiceInt.InsideNetwork.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												networkChoiceInt.InsideNetwork.Tenant = v.(string)

											}

										}

									}

									if v, ok := cs["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_SiteLocalInsideNetwork{}
											networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
											interfaceChoiceInt.TunnelInterface.NetworkChoice = networkChoiceInt
										}

									}

									if v, ok := cs["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_SiteLocalNetwork{}
											networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
											interfaceChoiceInt.TunnelInterface.NetworkChoice = networkChoiceInt
										}

									}

									nodeChoiceTypeFound := false

									if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true

										if v.(bool) {
											nodeChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_Cluster{}
											nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
											interfaceChoiceInt.TunnelInterface.NodeChoice = nodeChoiceInt
										}

									}

									if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true
										nodeChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_Node{}

										interfaceChoiceInt.TunnelInterface.NodeChoice = nodeChoiceInt

										nodeChoiceInt.Node = v.(string)

									}

									if v, ok := cs["priority"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.TunnelInterface.Priority = uint32(v.(int))

									}

									if v, ok := cs["static_ip"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										staticIp := &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceChoiceInt.TunnelInterface.StaticIp = staticIp
										for _, set := range sl {
											staticIpMapStrToI := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := staticIpMapStrToI["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												staticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := staticIpMapStrToI["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												staticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := staticIpMapStrToI["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												staticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if v, ok := cs["tunnel"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										tunnelInt := &ves_io_schema_views.ObjectRefType{}
										interfaceChoiceInt.TunnelInterface.Tunnel = tunnelInt

										for _, set := range sl {
											tMapToStrVal := set.(map[string]interface{})
											if val, ok := tMapToStrVal["name"]; ok && !isIntfNil(v) {
												tunnelInt.Name = val.(string)
											}
											if val, ok := tMapToStrVal["namespace"]; ok && !isIntfNil(v) {
												tunnelInt.Namespace = val.(string)
											}

											if val, ok := tMapToStrVal["tenant"]; ok && !isIntfNil(v) {
												tunnelInt.Tenant = val.(string)
											}
										}

									}

								}

							}

							if w, ok := interfacesMapStrToI["labels"]; ok && !isIntfNil(w) {
								ms := map[string]string{}
								for k, v := range w.(map[string]interface{}) {
									ms[k] = v.(string)
								}
								interfaces[i].Labels = ms
							}

						}

					}

				}

			}

			networkPolicyChoiceTypeFound := false

			if v, ok := cs["active_network_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

				networkPolicyChoiceTypeFound = true
				networkPolicyChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_ActiveNetworkPolicies{}
				networkPolicyChoiceInt.ActiveNetworkPolicies = &ves_io_schema_network_firewall.ActiveNetworkPoliciesType{}
				networkCfgChoiceInt.CustomNetworkConfig.NetworkPolicyChoice = networkPolicyChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["network_policies"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						networkPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						networkPolicyChoiceInt.ActiveNetworkPolicies.NetworkPolicies = networkPoliciesInt
						for i, ps := range sl {

							npMapToStrVal := ps.(map[string]interface{})
							networkPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := npMapToStrVal["name"]; ok && !isIntfNil(v) {
								networkPoliciesInt[i].Name = v.(string)
							}

							if v, ok := npMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								networkPoliciesInt[i].Namespace = v.(string)
							}

							if v, ok := npMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								networkPoliciesInt[i].Tenant = v.(string)
							}

						}

					}

				}

			}

			if v, ok := cs["no_network_policy"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

				networkPolicyChoiceTypeFound = true

				if v.(bool) {
					networkPolicyChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_NoNetworkPolicy{}
					networkPolicyChoiceInt.NoNetworkPolicy = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.NetworkPolicyChoice = networkPolicyChoiceInt
				}

			}

			if v, ok := cs["outside_nameserver"]; ok && !isIntfNil(v) {

				networkCfgChoiceInt.CustomNetworkConfig.OutsideNameserver = v.(string)

			}

			if v, ok := cs["outside_vip"]; ok && !isIntfNil(v) {

				networkCfgChoiceInt.CustomNetworkConfig.OutsideVip = v.(string)

			}

			if v, ok := cs["site_to_site_tunnel_ip"]; ok && !isIntfNil(v) {

				networkCfgChoiceInt.CustomNetworkConfig.SiteToSiteTunnelIp = v.(string)

			}

			sliChoiceTypeFound := false

			if v, ok := cs["default_sli_config"]; ok && !isIntfNil(v) && !sliChoiceTypeFound {

				sliChoiceTypeFound = true

				if v.(bool) {
					sliChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_DefaultSliConfig{}
					sliChoiceInt.DefaultSliConfig = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.SliChoice = sliChoiceInt
				}

			}

			if v, ok := cs["sli_config"]; ok && !isIntfNil(v) && !sliChoiceTypeFound {

				sliChoiceTypeFound = true
				sliChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_SliConfig{}
				sliChoiceInt.SliConfig = &ves_io_schema_views_voltstack_site.SliVnConfiguration{}
				networkCfgChoiceInt.CustomNetworkConfig.SliChoice = sliChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					staticRouteChoiceTypeFound := false

					if v, ok := cs["no_static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

						staticRouteChoiceTypeFound = true

						if v.(bool) {
							staticRouteChoiceInt := &ves_io_schema_views_voltstack_site.SliVnConfiguration_NoStaticRoutes{}
							staticRouteChoiceInt.NoStaticRoutes = &ves_io_schema.Empty{}
							sliChoiceInt.SliConfig.StaticRouteChoice = staticRouteChoiceInt
						}

					}

					if v, ok := cs["static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

						staticRouteChoiceTypeFound = true
						staticRouteChoiceInt := &ves_io_schema_views_voltstack_site.SliVnConfiguration_StaticRoutes{}
						staticRouteChoiceInt.StaticRoutes = &ves_io_schema_views_voltstack_site.StaticRoutesListType{}
						sliChoiceInt.SliConfig.StaticRouteChoice = staticRouteChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRoutes := make([]*ves_io_schema_virtual_network.StaticRouteViewType, len(sl))
								staticRouteChoiceInt.StaticRoutes.StaticRoutes = staticRoutes
								for i, set := range sl {
									staticRoutes[i] = &ves_io_schema_virtual_network.StaticRouteViewType{}
									staticRoutesMapStrToI := set.(map[string]interface{})

									if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

										attrsList := []ves_io_schema.RouteAttrType{}
										for _, j := range v.([]interface{}) {
											attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
										}
										staticRoutes[i].Attrs = attrsList

									}

									if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
										ls := make([]string, len(w.([]interface{})))
										for i, v := range w.([]interface{}) {
											ls[i] = v.(string)
										}
										staticRoutes[i].IpPrefixes = ls
									}

									nextHopChoiceTypeFound := false

									if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true

										if v.(bool) {
											nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_DefaultGateway{}
											nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
											staticRoutes[i].NextHopChoice = nextHopChoiceInt
										}

									}

									if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_Interface{}
										nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Tenant = v.(string)

											}

										}

									}

									if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_IpAddress{}

										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										nextHopChoiceInt.IpAddress = v.(string)

									}

								}

							}

						}

					}

				}

			}

			sloChoiceTypeFound := false

			if v, ok := cs["default_config"]; ok && !isIntfNil(v) && !sloChoiceTypeFound {

				sloChoiceTypeFound = true

				if v.(bool) {
					sloChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_DefaultConfig{}
					sloChoiceInt.DefaultConfig = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.SloChoice = sloChoiceInt
				}

			}

			if v, ok := cs["slo_config"]; ok && !isIntfNil(v) && !sloChoiceTypeFound {

				sloChoiceTypeFound = true
				sloChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_SloConfig{}
				sloChoiceInt.SloConfig = &ves_io_schema_views_voltstack_site.VnConfiguration{}
				networkCfgChoiceInt.CustomNetworkConfig.SloChoice = sloChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					dcClusterGroupChoiceTypeFound := false

					if v, ok := cs["dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

						dcClusterGroupChoiceTypeFound = true
						dcClusterGroupChoiceInt := &ves_io_schema_views_voltstack_site.VnConfiguration_DcClusterGroup{}
						dcClusterGroupChoiceInt.DcClusterGroup = &ves_io_schema_views.ObjectRefType{}
						sloChoiceInt.SloConfig.DcClusterGroupChoice = dcClusterGroupChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Tenant = v.(string)

							}

						}

					}

					if v, ok := cs["no_dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

						dcClusterGroupChoiceTypeFound = true

						if v.(bool) {
							dcClusterGroupChoiceInt := &ves_io_schema_views_voltstack_site.VnConfiguration_NoDcClusterGroup{}
							dcClusterGroupChoiceInt.NoDcClusterGroup = &ves_io_schema.Empty{}
							sloChoiceInt.SloConfig.DcClusterGroupChoice = dcClusterGroupChoiceInt
						}

					}

					if v, ok := cs["labels"]; ok && !isIntfNil(v) {

						ms := map[string]string{}
						for k, v := range v.(map[string]interface{}) {
							ms[k] = v.(string)
						}
						sloChoiceInt.SloConfig.Labels = ms
					}

					staticRouteChoiceTypeFound := false

					if v, ok := cs["no_static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

						staticRouteChoiceTypeFound = true

						if v.(bool) {
							staticRouteChoiceInt := &ves_io_schema_views_voltstack_site.VnConfiguration_NoStaticRoutes{}
							staticRouteChoiceInt.NoStaticRoutes = &ves_io_schema.Empty{}
							sloChoiceInt.SloConfig.StaticRouteChoice = staticRouteChoiceInt
						}

					}

					if v, ok := cs["static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

						staticRouteChoiceTypeFound = true
						staticRouteChoiceInt := &ves_io_schema_views_voltstack_site.VnConfiguration_StaticRoutes{}
						staticRouteChoiceInt.StaticRoutes = &ves_io_schema_views_voltstack_site.StaticRoutesListType{}
						sloChoiceInt.SloConfig.StaticRouteChoice = staticRouteChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRoutes := make([]*ves_io_schema_virtual_network.StaticRouteViewType, len(sl))
								staticRouteChoiceInt.StaticRoutes.StaticRoutes = staticRoutes
								for i, set := range sl {
									staticRoutes[i] = &ves_io_schema_virtual_network.StaticRouteViewType{}
									staticRoutesMapStrToI := set.(map[string]interface{})

									if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

										attrsList := []ves_io_schema.RouteAttrType{}
										for _, j := range v.([]interface{}) {
											attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
										}
										staticRoutes[i].Attrs = attrsList

									}

									if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
										ls := make([]string, len(w.([]interface{})))
										for i, v := range w.([]interface{}) {
											ls[i] = v.(string)
										}
										staticRoutes[i].IpPrefixes = ls
									}

									nextHopChoiceTypeFound := false

									if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true

										if v.(bool) {
											nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_DefaultGateway{}
											nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
											staticRoutes[i].NextHopChoice = nextHopChoiceInt
										}

									}

									if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_Interface{}
										nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Tenant = v.(string)

											}

										}

									}

									if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_IpAddress{}

										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										nextHopChoiceInt.IpAddress = v.(string)

									}

								}

							}

						}

					}

				}

			}

			if v, ok := cs["tunnel_dead_timeout"]; ok && !isIntfNil(v) {

				networkCfgChoiceInt.CustomNetworkConfig.TunnelDeadTimeout = uint32(v.(int))

			}

			if v, ok := cs["vip_vrrp_mode"]; ok && !isIntfNil(v) {

				networkCfgChoiceInt.CustomNetworkConfig.VipVrrpMode = ves_io_schema.VipVrrpType(ves_io_schema.VipVrrpType_value[v.(string)])

			}

		}

	}

	if v, ok := d.GetOk("default_network_config"); ok && !networkCfgChoiceTypeFound {

		networkCfgChoiceTypeFound = true

		if v.(bool) {
			networkCfgChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_DefaultNetworkConfig{}
			networkCfgChoiceInt.DefaultNetworkConfig = &ves_io_schema.Empty{}
			updateSpec.NetworkCfgChoice = networkCfgChoiceInt
		}

	}

	storageCfgChoiceTypeFound := false

	if v, ok := d.GetOk("custom_storage_config"); ok && !storageCfgChoiceTypeFound {

		storageCfgChoiceTypeFound = true
		storageCfgChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_CustomStorageConfig{}
		storageCfgChoiceInt.CustomStorageConfig = &ves_io_schema_views_voltstack_site.VssStorageConfiguration{}
		updateSpec.StorageCfgChoice = storageCfgChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			staticRouteChoiceTypeFound := false

			if v, ok := cs["no_static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

				staticRouteChoiceTypeFound = true

				if v.(bool) {
					staticRouteChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_NoStaticRoutes{}
					staticRouteChoiceInt.NoStaticRoutes = &ves_io_schema.Empty{}
					storageCfgChoiceInt.CustomStorageConfig.StaticRouteChoice = staticRouteChoiceInt
				}

			}

			if v, ok := cs["static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

				staticRouteChoiceTypeFound = true
				staticRouteChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_StaticRoutes{}
				staticRouteChoiceInt.StaticRoutes = &ves_io_schema_views_voltstack_site.StaticRoutesListType{}
				storageCfgChoiceInt.CustomStorageConfig.StaticRouteChoice = staticRouteChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						staticRoutes := make([]*ves_io_schema_virtual_network.StaticRouteViewType, len(sl))
						staticRouteChoiceInt.StaticRoutes.StaticRoutes = staticRoutes
						for i, set := range sl {
							staticRoutes[i] = &ves_io_schema_virtual_network.StaticRouteViewType{}
							staticRoutesMapStrToI := set.(map[string]interface{})

							if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

								attrsList := []ves_io_schema.RouteAttrType{}
								for _, j := range v.([]interface{}) {
									attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
								}
								staticRoutes[i].Attrs = attrsList

							}

							if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
								ls := make([]string, len(w.([]interface{})))
								for i, v := range w.([]interface{}) {
									ls[i] = v.(string)
								}
								staticRoutes[i].IpPrefixes = ls
							}

							nextHopChoiceTypeFound := false

							if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

								nextHopChoiceTypeFound = true

								if v.(bool) {
									nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_DefaultGateway{}
									nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
									staticRoutes[i].NextHopChoice = nextHopChoiceInt
								}

							}

							if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

								nextHopChoiceTypeFound = true
								nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_Interface{}
								nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
								staticRoutes[i].NextHopChoice = nextHopChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["name"]; ok && !isIntfNil(v) {

										nextHopChoiceInt.Interface.Name = v.(string)

									}

									if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

										nextHopChoiceInt.Interface.Namespace = v.(string)

									}

									if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

										nextHopChoiceInt.Interface.Tenant = v.(string)

									}

								}

							}

							if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

								nextHopChoiceTypeFound = true
								nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_IpAddress{}

								staticRoutes[i].NextHopChoice = nextHopChoiceInt

								nextHopChoiceInt.IpAddress = v.(string)

							}

						}

					}

				}

			}

			storageClassChoiceTypeFound := false

			if v, ok := cs["default_storage_class"]; ok && !isIntfNil(v) && !storageClassChoiceTypeFound {

				storageClassChoiceTypeFound = true

				if v.(bool) {
					storageClassChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_DefaultStorageClass{}
					storageClassChoiceInt.DefaultStorageClass = &ves_io_schema.Empty{}
					storageCfgChoiceInt.CustomStorageConfig.StorageClassChoice = storageClassChoiceInt
				}

			}

			if v, ok := cs["storage_class_list"]; ok && !isIntfNil(v) && !storageClassChoiceTypeFound {

				storageClassChoiceTypeFound = true
				storageClassChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_StorageClassList{}
				storageClassChoiceInt.StorageClassList = &ves_io_schema_fleet.FleetStorageClassListType{}
				storageCfgChoiceInt.CustomStorageConfig.StorageClassChoice = storageClassChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["storage_classes"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						storageClasses := make([]*ves_io_schema_fleet.FleetStorageClassType, len(sl))
						storageClassChoiceInt.StorageClassList.StorageClasses = storageClasses
						for i, set := range sl {
							storageClasses[i] = &ves_io_schema_fleet.FleetStorageClassType{}
							storageClassesMapStrToI := set.(map[string]interface{})

							if w, ok := storageClassesMapStrToI["advanced_storage_parameters"]; ok && !isIntfNil(w) {
								ms := map[string]string{}
								for k, v := range w.(map[string]interface{}) {
									ms[k] = v.(string)
								}
								storageClasses[i].AdvancedStorageParameters = ms
							}

							if w, ok := storageClassesMapStrToI["allow_volume_expansion"]; ok && !isIntfNil(w) {
								storageClasses[i].AllowVolumeExpansion = w.(bool)
							}

							if w, ok := storageClassesMapStrToI["default_storage_class"]; ok && !isIntfNil(w) {
								storageClasses[i].DefaultStorageClass = w.(bool)
							}

							if w, ok := storageClassesMapStrToI["description"]; ok && !isIntfNil(w) {
								storageClasses[i].Description = w.(string)
							}

							deviceChoiceTypeFound := false

							if v, ok := storageClassesMapStrToI["custom_storage"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

								deviceChoiceTypeFound = true
								deviceChoiceInt := &ves_io_schema_fleet.FleetStorageClassType_CustomStorage{}
								deviceChoiceInt.CustomStorage = &ves_io_schema_fleet.StorageClassCustomType{}
								storageClasses[i].DeviceChoice = deviceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["yaml"]; ok && !isIntfNil(v) {

										deviceChoiceInt.CustomStorage.Yaml = v.(string)

									}

								}

							}

							if v, ok := storageClassesMapStrToI["netapp_trident"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

								deviceChoiceTypeFound = true
								deviceChoiceInt := &ves_io_schema_fleet.FleetStorageClassType_NetappTrident{}
								deviceChoiceInt.NetappTrident = &ves_io_schema_fleet.StorageClassNetappTridentType{}
								storageClasses[i].DeviceChoice = deviceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["selector"]; ok && !isIntfNil(v) {

										ms := map[string]string{}
										for k, v := range v.(map[string]interface{}) {
											ms[k] = v.(string)
										}
										deviceChoiceInt.NetappTrident.Selector = ms
									}

									if v, ok := cs["storage_pools"]; ok && !isIntfNil(v) {

										deviceChoiceInt.NetappTrident.StoragePools = v.(string)

									}

								}

							}

							if v, ok := storageClassesMapStrToI["openebs_enterprise"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

								deviceChoiceTypeFound = true
								deviceChoiceInt := &ves_io_schema_fleet.FleetStorageClassType_OpenebsEnterprise{}
								deviceChoiceInt.OpenebsEnterprise = &ves_io_schema_fleet.StorageClassOpenebsEnterpriseType{}
								storageClasses[i].DeviceChoice = deviceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["protocol"]; ok && !isIntfNil(v) {

										deviceChoiceInt.OpenebsEnterprise.Protocol = v.(string)

									}

									if v, ok := cs["replication"]; ok && !isIntfNil(v) {

										deviceChoiceInt.OpenebsEnterprise.Replication = int32(v.(int))

									}

								}

							}

							if v, ok := storageClassesMapStrToI["pure_service_orchestrator"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

								deviceChoiceTypeFound = true
								deviceChoiceInt := &ves_io_schema_fleet.FleetStorageClassType_PureServiceOrchestrator{}
								deviceChoiceInt.PureServiceOrchestrator = &ves_io_schema_fleet.StorageClassPureServiceOrchestratorType{}
								storageClasses[i].DeviceChoice = deviceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["backend"]; ok && !isIntfNil(v) {

										deviceChoiceInt.PureServiceOrchestrator.Backend = v.(string)

									}

									if v, ok := cs["bandwidth_limit"]; ok && !isIntfNil(v) {

										deviceChoiceInt.PureServiceOrchestrator.BandwidthLimit = v.(string)

									}

									if v, ok := cs["iops_limit"]; ok && !isIntfNil(v) {

										deviceChoiceInt.PureServiceOrchestrator.IopsLimit = uint32(v.(int))

									}

								}

							}

							if w, ok := storageClassesMapStrToI["reclaim_policy"]; ok && !isIntfNil(w) {
								storageClasses[i].ReclaimPolicy = w.(string)
							}

							if w, ok := storageClassesMapStrToI["storage_class_name"]; ok && !isIntfNil(w) {
								storageClasses[i].StorageClassName = w.(string)
							}

							if w, ok := storageClassesMapStrToI["storage_device"]; ok && !isIntfNil(w) {
								storageClasses[i].StorageDevice = w.(string)
							}

						}

					}

				}

			}

			storageDeviceChoiceTypeFound := false

			if v, ok := cs["no_storage_device"]; ok && !isIntfNil(v) && !storageDeviceChoiceTypeFound {

				storageDeviceChoiceTypeFound = true

				if v.(bool) {
					storageDeviceChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_NoStorageDevice{}
					storageDeviceChoiceInt.NoStorageDevice = &ves_io_schema.Empty{}
					storageCfgChoiceInt.CustomStorageConfig.StorageDeviceChoice = storageDeviceChoiceInt
				}

			}

			if v, ok := cs["storage_device_list"]; ok && !isIntfNil(v) && !storageDeviceChoiceTypeFound {

				storageDeviceChoiceTypeFound = true
				storageDeviceChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_StorageDeviceList{}
				storageDeviceChoiceInt.StorageDeviceList = &ves_io_schema_fleet.FleetStorageDeviceListType{}
				storageCfgChoiceInt.CustomStorageConfig.StorageDeviceChoice = storageDeviceChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["storage_devices"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						storageDevices := make([]*ves_io_schema_fleet.FleetStorageDeviceType, len(sl))
						storageDeviceChoiceInt.StorageDeviceList.StorageDevices = storageDevices
						for i, set := range sl {
							storageDevices[i] = &ves_io_schema_fleet.FleetStorageDeviceType{}
							storageDevicesMapStrToI := set.(map[string]interface{})

							if w, ok := storageDevicesMapStrToI["advanced_advanced_parameters"]; ok && !isIntfNil(w) {
								ms := map[string]string{}
								for k, v := range w.(map[string]interface{}) {
									ms[k] = v.(string)
								}
								storageDevices[i].AdvancedAdvancedParameters = ms
							}

							deviceChoiceTypeFound := false

							if v, ok := storageDevicesMapStrToI["custom_storage"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

								deviceChoiceTypeFound = true

								if v.(bool) {
									deviceChoiceInt := &ves_io_schema_fleet.FleetStorageDeviceType_CustomStorage{}
									deviceChoiceInt.CustomStorage = &ves_io_schema.Empty{}
									storageDevices[i].DeviceChoice = deviceChoiceInt
								}

							}

							if v, ok := storageDevicesMapStrToI["netapp_trident"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

								deviceChoiceTypeFound = true
								deviceChoiceInt := &ves_io_schema_fleet.FleetStorageDeviceType_NetappTrident{}
								deviceChoiceInt.NetappTrident = &ves_io_schema_fleet.StorageDeviceNetappTridentType{}
								storageDevices[i].DeviceChoice = deviceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									backendChoiceTypeFound := false

									if v, ok := cs["netapp_backend_ontap_nas"]; ok && !isIntfNil(v) && !backendChoiceTypeFound {

										backendChoiceTypeFound = true
										backendChoiceInt := &ves_io_schema_fleet.StorageDeviceNetappTridentType_NetappBackendOntapNas{}
										backendChoiceInt.NetappBackendOntapNas = &ves_io_schema_fleet.StorageDeviceNetappBackendOntapNasType{}
										deviceChoiceInt.NetappTrident.BackendChoice = backendChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["auto_export_cidrs"]; ok && !isIntfNil(v) {

												sl := v.(*schema.Set).List()
												autoExportCidrs := &ves_io_schema_views.PrefixStringListType{}
												backendChoiceInt.NetappBackendOntapNas.AutoExportCidrs = autoExportCidrs
												for _, set := range sl {
													autoExportCidrsMapStrToI := set.(map[string]interface{})

													if w, ok := autoExportCidrsMapStrToI["prefixes"]; ok && !isIntfNil(w) {
														ls := make([]string, len(w.([]interface{})))
														for i, v := range w.([]interface{}) {
															ls[i] = v.(string)
														}
														autoExportCidrs.Prefixes = ls
													}

												}

											}

											if v, ok := cs["auto_export_policy"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapNas.AutoExportPolicy = v.(bool)

											}

											if v, ok := cs["backend_name"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapNas.BackendName = v.(string)

											}

											if v, ok := cs["client_certificate"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapNas.ClientCertificate = v.(string)

											}

											if v, ok := cs["client_private_key"]; ok && !isIntfNil(v) {

												sl := v.(*schema.Set).List()
												clientPrivateKey := &ves_io_schema.SecretType{}
												backendChoiceInt.NetappBackendOntapNas.ClientPrivateKey = clientPrivateKey
												for _, set := range sl {
													clientPrivateKeyMapStrToI := set.(map[string]interface{})

													if v, ok := clientPrivateKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
														clientPrivateKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
														for _, set := range sl {
															blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

															if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
															}

															if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																blindfoldSecretInfoInternal.Location = w.(string)
															}

															if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																blindfoldSecretInfoInternal.StoreProvider = w.(string)
															}

														}

													}

													if v, ok := clientPrivateKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

														clientPrivateKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													secretInfoOneofTypeFound := false

													if v, ok := clientPrivateKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
														secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
														clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

															}

															if v, ok := cs["location"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

															}

															if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

															}

														}

													}

													if v, ok := clientPrivateKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
														secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
														clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

															}

															if v, ok := cs["url"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

															}

														}

													}

													if v, ok := clientPrivateKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
														secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
														clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["key"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

															}

															if v, ok := cs["location"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

															}

															if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

															}

															if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

															}

															if v, ok := cs["version"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

															}

														}

													}

													if v, ok := clientPrivateKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
														secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
														clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

															}

														}

													}

												}

											}

											dataLifTypeFound := false

											if v, ok := cs["data_lif_dns_name"]; ok && !isIntfNil(v) && !dataLifTypeFound {

												dataLifTypeFound = true
												dataLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapNasType_DataLifDnsName{}

												backendChoiceInt.NetappBackendOntapNas.DataLif = dataLifInt

												dataLifInt.DataLifDnsName = v.(string)

											}

											if v, ok := cs["data_lif_ip"]; ok && !isIntfNil(v) && !dataLifTypeFound {

												dataLifTypeFound = true
												dataLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapNasType_DataLifIp{}

												backendChoiceInt.NetappBackendOntapNas.DataLif = dataLifInt

												dataLifInt.DataLifIp = v.(string)

											}

											if v, ok := cs["labels"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												backendChoiceInt.NetappBackendOntapNas.Labels = ms
											}

											if v, ok := cs["limit_aggregate_usage"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapNas.LimitAggregateUsage = v.(string)

											}

											if v, ok := cs["limit_volume_size"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapNas.LimitVolumeSize = v.(string)

											}

											managementLifTypeFound := false

											if v, ok := cs["management_lif_dns_name"]; ok && !isIntfNil(v) && !managementLifTypeFound {

												managementLifTypeFound = true
												managementLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName{}

												backendChoiceInt.NetappBackendOntapNas.ManagementLif = managementLifInt

												managementLifInt.ManagementLifDnsName = v.(string)

											}

											if v, ok := cs["management_lif_ip"]; ok && !isIntfNil(v) && !managementLifTypeFound {

												managementLifTypeFound = true
												managementLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapNasType_ManagementLifIp{}

												backendChoiceInt.NetappBackendOntapNas.ManagementLif = managementLifInt

												managementLifInt.ManagementLifIp = v.(string)

											}

											if v, ok := cs["nfs_mount_options"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapNas.NfsMountOptions = v.(string)

											}

											if v, ok := cs["password"]; ok && !isIntfNil(v) {

												sl := v.(*schema.Set).List()
												password := &ves_io_schema.SecretType{}
												backendChoiceInt.NetappBackendOntapNas.Password = password
												for _, set := range sl {
													passwordMapStrToI := set.(map[string]interface{})

													if v, ok := passwordMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
														password.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
														for _, set := range sl {
															blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

															if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
															}

															if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																blindfoldSecretInfoInternal.Location = w.(string)
															}

															if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																blindfoldSecretInfoInternal.StoreProvider = w.(string)
															}

														}

													}

													if v, ok := passwordMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

														password.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													secretInfoOneofTypeFound := false

													if v, ok := passwordMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
														secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
														password.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

															}

															if v, ok := cs["location"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

															}

															if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

															}

														}

													}

													if v, ok := passwordMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
														secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
														password.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

															}

															if v, ok := cs["url"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

															}

														}

													}

													if v, ok := passwordMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
														secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
														password.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["key"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

															}

															if v, ok := cs["location"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

															}

															if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

															}

															if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

															}

															if v, ok := cs["version"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

															}

														}

													}

													if v, ok := passwordMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
														secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
														password.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

															}

														}

													}

												}

											}

											if v, ok := cs["region"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapNas.Region = v.(string)

											}

											if v, ok := cs["storage"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												storage := make([]*ves_io_schema_fleet.OntapVirtualStoragePoolType, len(sl))
												backendChoiceInt.NetappBackendOntapNas.Storage = storage
												for i, set := range sl {
													storage[i] = &ves_io_schema_fleet.OntapVirtualStoragePoolType{}
													storageMapStrToI := set.(map[string]interface{})

													if w, ok := storageMapStrToI["labels"]; ok && !isIntfNil(w) {
														ms := map[string]string{}
														for k, v := range w.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														storage[i].Labels = ms
													}

													if v, ok := storageMapStrToI["volume_defaults"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														volumeDefaults := &ves_io_schema_fleet.OntapVolumeDefaults{}
														storage[i].VolumeDefaults = volumeDefaults
														for _, set := range sl {
															volumeDefaultsMapStrToI := set.(map[string]interface{})

															if w, ok := volumeDefaultsMapStrToI["encryption"]; ok && !isIntfNil(w) {
																volumeDefaults.Encryption = w.(bool)
															}

															if w, ok := volumeDefaultsMapStrToI["export_policy"]; ok && !isIntfNil(w) {
																volumeDefaults.ExportPolicy = w.(string)
															}

															qosPolicyChoiceTypeFound := false

															if v, ok := volumeDefaultsMapStrToI["adaptive_qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																qosPolicyChoiceTypeFound = true
																qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_AdaptiveQosPolicy{}

																volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

																qosPolicyChoiceInt.AdaptiveQosPolicy = v.(string)

															}

															if v, ok := volumeDefaultsMapStrToI["no_qos"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																qosPolicyChoiceTypeFound = true

																if v.(bool) {
																	qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_NoQos{}
																	qosPolicyChoiceInt.NoQos = &ves_io_schema.Empty{}
																	volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt
																}

															}

															if v, ok := volumeDefaultsMapStrToI["qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																qosPolicyChoiceTypeFound = true
																qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_QosPolicy{}

																volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

																qosPolicyChoiceInt.QosPolicy = v.(string)

															}

															if w, ok := volumeDefaultsMapStrToI["security_style"]; ok && !isIntfNil(w) {
																volumeDefaults.SecurityStyle = w.(string)
															}

															if w, ok := volumeDefaultsMapStrToI["snapshot_dir"]; ok && !isIntfNil(w) {
																volumeDefaults.SnapshotDir = w.(bool)
															}

															if w, ok := volumeDefaultsMapStrToI["snapshot_policy"]; ok && !isIntfNil(w) {
																volumeDefaults.SnapshotPolicy = w.(string)
															}

															if w, ok := volumeDefaultsMapStrToI["snapshot_reserve"]; ok && !isIntfNil(w) {
																volumeDefaults.SnapshotReserve = w.(string)
															}

															if w, ok := volumeDefaultsMapStrToI["space_reserve"]; ok && !isIntfNil(w) {
																volumeDefaults.SpaceReserve = w.(string)
															}

															if w, ok := volumeDefaultsMapStrToI["split_on_clone"]; ok && !isIntfNil(w) {
																volumeDefaults.SplitOnClone = w.(bool)
															}

															if w, ok := volumeDefaultsMapStrToI["tiering_policy"]; ok && !isIntfNil(w) {
																volumeDefaults.TieringPolicy = w.(string)
															}

															if w, ok := volumeDefaultsMapStrToI["unix_permissions"]; ok && !isIntfNil(w) {
																volumeDefaults.UnixPermissions = int32(w.(int))
															}

														}

													}

													if w, ok := storageMapStrToI["zone"]; ok && !isIntfNil(w) {
														storage[i].Zone = w.(string)
													}

												}

											}

											if v, ok := cs["storage_driver_name"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapNas.StorageDriverName = v.(string)

											}

											if v, ok := cs["storage_prefix"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapNas.StoragePrefix = v.(string)

											}

											if v, ok := cs["svm"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapNas.Svm = v.(string)

											}

											if v, ok := cs["trusted_ca_certificate"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapNas.TrustedCaCertificate = v.(string)

											}

											if v, ok := cs["username"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapNas.Username = v.(string)

											}

											if v, ok := cs["volume_defaults"]; ok && !isIntfNil(v) {

												sl := v.(*schema.Set).List()
												volumeDefaults := &ves_io_schema_fleet.OntapVolumeDefaults{}
												backendChoiceInt.NetappBackendOntapNas.VolumeDefaults = volumeDefaults
												for _, set := range sl {
													volumeDefaultsMapStrToI := set.(map[string]interface{})

													if w, ok := volumeDefaultsMapStrToI["encryption"]; ok && !isIntfNil(w) {
														volumeDefaults.Encryption = w.(bool)
													}

													if w, ok := volumeDefaultsMapStrToI["export_policy"]; ok && !isIntfNil(w) {
														volumeDefaults.ExportPolicy = w.(string)
													}

													qosPolicyChoiceTypeFound := false

													if v, ok := volumeDefaultsMapStrToI["adaptive_qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

														qosPolicyChoiceTypeFound = true
														qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_AdaptiveQosPolicy{}

														volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

														qosPolicyChoiceInt.AdaptiveQosPolicy = v.(string)

													}

													if v, ok := volumeDefaultsMapStrToI["no_qos"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

														qosPolicyChoiceTypeFound = true

														if v.(bool) {
															qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_NoQos{}
															qosPolicyChoiceInt.NoQos = &ves_io_schema.Empty{}
															volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt
														}

													}

													if v, ok := volumeDefaultsMapStrToI["qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

														qosPolicyChoiceTypeFound = true
														qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_QosPolicy{}

														volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

														qosPolicyChoiceInt.QosPolicy = v.(string)

													}

													if w, ok := volumeDefaultsMapStrToI["security_style"]; ok && !isIntfNil(w) {
														volumeDefaults.SecurityStyle = w.(string)
													}

													if w, ok := volumeDefaultsMapStrToI["snapshot_dir"]; ok && !isIntfNil(w) {
														volumeDefaults.SnapshotDir = w.(bool)
													}

													if w, ok := volumeDefaultsMapStrToI["snapshot_policy"]; ok && !isIntfNil(w) {
														volumeDefaults.SnapshotPolicy = w.(string)
													}

													if w, ok := volumeDefaultsMapStrToI["snapshot_reserve"]; ok && !isIntfNil(w) {
														volumeDefaults.SnapshotReserve = w.(string)
													}

													if w, ok := volumeDefaultsMapStrToI["space_reserve"]; ok && !isIntfNil(w) {
														volumeDefaults.SpaceReserve = w.(string)
													}

													if w, ok := volumeDefaultsMapStrToI["split_on_clone"]; ok && !isIntfNil(w) {
														volumeDefaults.SplitOnClone = w.(bool)
													}

													if w, ok := volumeDefaultsMapStrToI["tiering_policy"]; ok && !isIntfNil(w) {
														volumeDefaults.TieringPolicy = w.(string)
													}

													if w, ok := volumeDefaultsMapStrToI["unix_permissions"]; ok && !isIntfNil(w) {
														volumeDefaults.UnixPermissions = int32(w.(int))
													}

												}

											}

										}

									}

									if v, ok := cs["netapp_backend_ontap_san"]; ok && !isIntfNil(v) && !backendChoiceTypeFound {

										backendChoiceTypeFound = true
										backendChoiceInt := &ves_io_schema_fleet.StorageDeviceNetappTridentType_NetappBackendOntapSan{}
										backendChoiceInt.NetappBackendOntapSan = &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType{}
										deviceChoiceInt.NetappTrident.BackendChoice = backendChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											chapChoiceTypeFound := false

											if v, ok := cs["no_chap"]; ok && !isIntfNil(v) && !chapChoiceTypeFound {

												chapChoiceTypeFound = true

												if v.(bool) {
													chapChoiceInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType_NoChap{}
													chapChoiceInt.NoChap = &ves_io_schema.Empty{}
													backendChoiceInt.NetappBackendOntapSan.ChapChoice = chapChoiceInt
												}

											}

											if v, ok := cs["use_chap"]; ok && !isIntfNil(v) && !chapChoiceTypeFound {

												chapChoiceTypeFound = true
												chapChoiceInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType_UseChap{}
												chapChoiceInt.UseChap = &ves_io_schema_fleet.DeviceNetappBackendOntapSanChapType{}
												backendChoiceInt.NetappBackendOntapSan.ChapChoice = chapChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["chap_initiator_secret"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														chapInitiatorSecret := &ves_io_schema.SecretType{}
														chapChoiceInt.UseChap.ChapInitiatorSecret = chapInitiatorSecret
														for _, set := range sl {
															chapInitiatorSecretMapStrToI := set.(map[string]interface{})

															if v, ok := chapInitiatorSecretMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																sl := v.(*schema.Set).List()
																blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																chapInitiatorSecret.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																for _, set := range sl {
																	blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																	}

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.Location = w.(string)
																	}

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.StoreProvider = w.(string)
																	}

																}

															}

															if v, ok := chapInitiatorSecretMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																chapInitiatorSecret.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

															}

															secretInfoOneofTypeFound := false

															if v, ok := chapInitiatorSecretMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																chapInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																	}

																	if v, ok := cs["location"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																	}

																	if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																	}

																}

															}

															if v, ok := chapInitiatorSecretMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																chapInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																	}

																	if v, ok := cs["url"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																	}

																}

															}

															if v, ok := chapInitiatorSecretMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																chapInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["key"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																	}

																	if v, ok := cs["location"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																	}

																	if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																	}

																	if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																	}

																	if v, ok := cs["version"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																	}

																}

															}

															if v, ok := chapInitiatorSecretMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																chapInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["name"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																	}

																}

															}

														}

													}

													if v, ok := cs["chap_target_initiator_secret"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														chapTargetInitiatorSecret := &ves_io_schema.SecretType{}
														chapChoiceInt.UseChap.ChapTargetInitiatorSecret = chapTargetInitiatorSecret
														for _, set := range sl {
															chapTargetInitiatorSecretMapStrToI := set.(map[string]interface{})

															if v, ok := chapTargetInitiatorSecretMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																sl := v.(*schema.Set).List()
																blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																chapTargetInitiatorSecret.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																for _, set := range sl {
																	blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																	}

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.Location = w.(string)
																	}

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.StoreProvider = w.(string)
																	}

																}

															}

															if v, ok := chapTargetInitiatorSecretMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																chapTargetInitiatorSecret.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

															}

															secretInfoOneofTypeFound := false

															if v, ok := chapTargetInitiatorSecretMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																chapTargetInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																	}

																	if v, ok := cs["location"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																	}

																	if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																	}

																}

															}

															if v, ok := chapTargetInitiatorSecretMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																chapTargetInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																	}

																	if v, ok := cs["url"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																	}

																}

															}

															if v, ok := chapTargetInitiatorSecretMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																chapTargetInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["key"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																	}

																	if v, ok := cs["location"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																	}

																	if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																	}

																	if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																	}

																	if v, ok := cs["version"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																	}

																}

															}

															if v, ok := chapTargetInitiatorSecretMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																chapTargetInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["name"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																	}

																}

															}

														}

													}

													if v, ok := cs["chap_target_username"]; ok && !isIntfNil(v) {

														chapChoiceInt.UseChap.ChapTargetUsername = v.(string)

													}

													if v, ok := cs["chap_username"]; ok && !isIntfNil(v) {

														chapChoiceInt.UseChap.ChapUsername = v.(string)

													}

												}

											}

											if v, ok := cs["client_certificate"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapSan.ClientCertificate = v.(string)

											}

											if v, ok := cs["client_private_key"]; ok && !isIntfNil(v) {

												sl := v.(*schema.Set).List()
												clientPrivateKey := &ves_io_schema.SecretType{}
												backendChoiceInt.NetappBackendOntapSan.ClientPrivateKey = clientPrivateKey
												for _, set := range sl {
													clientPrivateKeyMapStrToI := set.(map[string]interface{})

													if v, ok := clientPrivateKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
														clientPrivateKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
														for _, set := range sl {
															blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

															if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
															}

															if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																blindfoldSecretInfoInternal.Location = w.(string)
															}

															if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																blindfoldSecretInfoInternal.StoreProvider = w.(string)
															}

														}

													}

													if v, ok := clientPrivateKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

														clientPrivateKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													secretInfoOneofTypeFound := false

													if v, ok := clientPrivateKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
														secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
														clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

															}

															if v, ok := cs["location"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

															}

															if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

															}

														}

													}

													if v, ok := clientPrivateKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
														secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
														clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

															}

															if v, ok := cs["url"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

															}

														}

													}

													if v, ok := clientPrivateKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
														secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
														clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["key"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

															}

															if v, ok := cs["location"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

															}

															if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

															}

															if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

															}

															if v, ok := cs["version"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

															}

														}

													}

													if v, ok := clientPrivateKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
														secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
														clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

															}

														}

													}

												}

											}

											dataLifTypeFound := false

											if v, ok := cs["data_lif_dns_name"]; ok && !isIntfNil(v) && !dataLifTypeFound {

												dataLifTypeFound = true
												dataLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType_DataLifDnsName{}

												backendChoiceInt.NetappBackendOntapSan.DataLif = dataLifInt

												dataLifInt.DataLifDnsName = v.(string)

											}

											if v, ok := cs["data_lif_ip"]; ok && !isIntfNil(v) && !dataLifTypeFound {

												dataLifTypeFound = true
												dataLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType_DataLifIp{}

												backendChoiceInt.NetappBackendOntapSan.DataLif = dataLifInt

												dataLifInt.DataLifIp = v.(string)

											}

											if v, ok := cs["igroup_name"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapSan.IgroupName = v.(string)

											}

											if v, ok := cs["labels"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												backendChoiceInt.NetappBackendOntapSan.Labels = ms
											}

											if v, ok := cs["limit_aggregate_usage"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapSan.LimitAggregateUsage = uint32(v.(int))

											}

											if v, ok := cs["limit_volume_size"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapSan.LimitVolumeSize = int32(v.(int))

											}

											managementLifTypeFound := false

											if v, ok := cs["management_lif_dns_name"]; ok && !isIntfNil(v) && !managementLifTypeFound {

												managementLifTypeFound = true
												managementLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName{}

												backendChoiceInt.NetappBackendOntapSan.ManagementLif = managementLifInt

												managementLifInt.ManagementLifDnsName = v.(string)

											}

											if v, ok := cs["management_lif_ip"]; ok && !isIntfNil(v) && !managementLifTypeFound {

												managementLifTypeFound = true
												managementLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType_ManagementLifIp{}

												backendChoiceInt.NetappBackendOntapSan.ManagementLif = managementLifInt

												managementLifInt.ManagementLifIp = v.(string)

											}

											if v, ok := cs["password"]; ok && !isIntfNil(v) {

												sl := v.(*schema.Set).List()
												password := &ves_io_schema.SecretType{}
												backendChoiceInt.NetappBackendOntapSan.Password = password
												for _, set := range sl {
													passwordMapStrToI := set.(map[string]interface{})

													if v, ok := passwordMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
														password.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
														for _, set := range sl {
															blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

															if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
															}

															if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																blindfoldSecretInfoInternal.Location = w.(string)
															}

															if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																blindfoldSecretInfoInternal.StoreProvider = w.(string)
															}

														}

													}

													if v, ok := passwordMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

														password.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													secretInfoOneofTypeFound := false

													if v, ok := passwordMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
														secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
														password.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

															}

															if v, ok := cs["location"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

															}

															if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

															}

														}

													}

													if v, ok := passwordMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
														secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
														password.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

															}

															if v, ok := cs["url"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

															}

														}

													}

													if v, ok := passwordMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
														secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
														password.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["key"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

															}

															if v, ok := cs["location"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

															}

															if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

															}

															if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

															}

															if v, ok := cs["version"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

															}

														}

													}

													if v, ok := passwordMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
														secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
														password.SecretInfoOneof = secretInfoOneofInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

															}

														}

													}

												}

											}

											if v, ok := cs["region"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapSan.Region = v.(string)

											}

											if v, ok := cs["storage"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												storage := make([]*ves_io_schema_fleet.OntapVirtualStoragePoolType, len(sl))
												backendChoiceInt.NetappBackendOntapSan.Storage = storage
												for i, set := range sl {
													storage[i] = &ves_io_schema_fleet.OntapVirtualStoragePoolType{}
													storageMapStrToI := set.(map[string]interface{})

													if w, ok := storageMapStrToI["labels"]; ok && !isIntfNil(w) {
														ms := map[string]string{}
														for k, v := range w.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														storage[i].Labels = ms
													}

													if v, ok := storageMapStrToI["volume_defaults"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														volumeDefaults := &ves_io_schema_fleet.OntapVolumeDefaults{}
														storage[i].VolumeDefaults = volumeDefaults
														for _, set := range sl {
															volumeDefaultsMapStrToI := set.(map[string]interface{})

															if w, ok := volumeDefaultsMapStrToI["encryption"]; ok && !isIntfNil(w) {
																volumeDefaults.Encryption = w.(bool)
															}

															if w, ok := volumeDefaultsMapStrToI["export_policy"]; ok && !isIntfNil(w) {
																volumeDefaults.ExportPolicy = w.(string)
															}

															qosPolicyChoiceTypeFound := false

															if v, ok := volumeDefaultsMapStrToI["adaptive_qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																qosPolicyChoiceTypeFound = true
																qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_AdaptiveQosPolicy{}

																volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

																qosPolicyChoiceInt.AdaptiveQosPolicy = v.(string)

															}

															if v, ok := volumeDefaultsMapStrToI["no_qos"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																qosPolicyChoiceTypeFound = true

																if v.(bool) {
																	qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_NoQos{}
																	qosPolicyChoiceInt.NoQos = &ves_io_schema.Empty{}
																	volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt
																}

															}

															if v, ok := volumeDefaultsMapStrToI["qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																qosPolicyChoiceTypeFound = true
																qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_QosPolicy{}

																volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

																qosPolicyChoiceInt.QosPolicy = v.(string)

															}

															if w, ok := volumeDefaultsMapStrToI["security_style"]; ok && !isIntfNil(w) {
																volumeDefaults.SecurityStyle = w.(string)
															}

															if w, ok := volumeDefaultsMapStrToI["snapshot_dir"]; ok && !isIntfNil(w) {
																volumeDefaults.SnapshotDir = w.(bool)
															}

															if w, ok := volumeDefaultsMapStrToI["snapshot_policy"]; ok && !isIntfNil(w) {
																volumeDefaults.SnapshotPolicy = w.(string)
															}

															if w, ok := volumeDefaultsMapStrToI["snapshot_reserve"]; ok && !isIntfNil(w) {
																volumeDefaults.SnapshotReserve = w.(string)
															}

															if w, ok := volumeDefaultsMapStrToI["space_reserve"]; ok && !isIntfNil(w) {
																volumeDefaults.SpaceReserve = w.(string)
															}

															if w, ok := volumeDefaultsMapStrToI["split_on_clone"]; ok && !isIntfNil(w) {
																volumeDefaults.SplitOnClone = w.(bool)
															}

															if w, ok := volumeDefaultsMapStrToI["tiering_policy"]; ok && !isIntfNil(w) {
																volumeDefaults.TieringPolicy = w.(string)
															}

															if w, ok := volumeDefaultsMapStrToI["unix_permissions"]; ok && !isIntfNil(w) {
																volumeDefaults.UnixPermissions = int32(w.(int))
															}

														}

													}

													if w, ok := storageMapStrToI["zone"]; ok && !isIntfNil(w) {
														storage[i].Zone = w.(string)
													}

												}

											}

											if v, ok := cs["storage_driver_name"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapSan.StorageDriverName = v.(string)

											}

											if v, ok := cs["storage_prefix"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapSan.StoragePrefix = v.(string)

											}

											if v, ok := cs["svm"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapSan.Svm = v.(string)

											}

											if v, ok := cs["trusted_ca_certificate"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapSan.TrustedCaCertificate = v.(string)

											}

											if v, ok := cs["username"]; ok && !isIntfNil(v) {

												backendChoiceInt.NetappBackendOntapSan.Username = v.(string)

											}

											if v, ok := cs["volume_defaults"]; ok && !isIntfNil(v) {

												sl := v.(*schema.Set).List()
												volumeDefaults := &ves_io_schema_fleet.OntapVolumeDefaults{}
												backendChoiceInt.NetappBackendOntapSan.VolumeDefaults = volumeDefaults
												for _, set := range sl {
													volumeDefaultsMapStrToI := set.(map[string]interface{})

													if w, ok := volumeDefaultsMapStrToI["encryption"]; ok && !isIntfNil(w) {
														volumeDefaults.Encryption = w.(bool)
													}

													if w, ok := volumeDefaultsMapStrToI["export_policy"]; ok && !isIntfNil(w) {
														volumeDefaults.ExportPolicy = w.(string)
													}

													qosPolicyChoiceTypeFound := false

													if v, ok := volumeDefaultsMapStrToI["adaptive_qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

														qosPolicyChoiceTypeFound = true
														qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_AdaptiveQosPolicy{}

														volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

														qosPolicyChoiceInt.AdaptiveQosPolicy = v.(string)

													}

													if v, ok := volumeDefaultsMapStrToI["no_qos"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

														qosPolicyChoiceTypeFound = true

														if v.(bool) {
															qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_NoQos{}
															qosPolicyChoiceInt.NoQos = &ves_io_schema.Empty{}
															volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt
														}

													}

													if v, ok := volumeDefaultsMapStrToI["qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

														qosPolicyChoiceTypeFound = true
														qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_QosPolicy{}

														volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

														qosPolicyChoiceInt.QosPolicy = v.(string)

													}

													if w, ok := volumeDefaultsMapStrToI["security_style"]; ok && !isIntfNil(w) {
														volumeDefaults.SecurityStyle = w.(string)
													}

													if w, ok := volumeDefaultsMapStrToI["snapshot_dir"]; ok && !isIntfNil(w) {
														volumeDefaults.SnapshotDir = w.(bool)
													}

													if w, ok := volumeDefaultsMapStrToI["snapshot_policy"]; ok && !isIntfNil(w) {
														volumeDefaults.SnapshotPolicy = w.(string)
													}

													if w, ok := volumeDefaultsMapStrToI["snapshot_reserve"]; ok && !isIntfNil(w) {
														volumeDefaults.SnapshotReserve = w.(string)
													}

													if w, ok := volumeDefaultsMapStrToI["space_reserve"]; ok && !isIntfNil(w) {
														volumeDefaults.SpaceReserve = w.(string)
													}

													if w, ok := volumeDefaultsMapStrToI["split_on_clone"]; ok && !isIntfNil(w) {
														volumeDefaults.SplitOnClone = w.(bool)
													}

													if w, ok := volumeDefaultsMapStrToI["tiering_policy"]; ok && !isIntfNil(w) {
														volumeDefaults.TieringPolicy = w.(string)
													}

													if w, ok := volumeDefaultsMapStrToI["unix_permissions"]; ok && !isIntfNil(w) {
														volumeDefaults.UnixPermissions = int32(w.(int))
													}

												}

											}

										}

									}

								}

							}

							if v, ok := storageDevicesMapStrToI["openebs_enterprise"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

								deviceChoiceTypeFound = true
								deviceChoiceInt := &ves_io_schema_fleet.FleetStorageDeviceType_OpenebsEnterprise{}
								deviceChoiceInt.OpenebsEnterprise = &ves_io_schema_fleet.StorageDeviceOpenebsEnterpriseType{}
								storageDevices[i].DeviceChoice = deviceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["mayastor_pools"]; ok && !isIntfNil(v) {

										sl := v.([]interface{})
										mayastorPools := make([]*ves_io_schema_fleet.OpenebsMayastorPoolType, len(sl))
										deviceChoiceInt.OpenebsEnterprise.MayastorPools = mayastorPools
										for i, set := range sl {
											mayastorPools[i] = &ves_io_schema_fleet.OpenebsMayastorPoolType{}
											mayastorPoolsMapStrToI := set.(map[string]interface{})

											if w, ok := mayastorPoolsMapStrToI["node"]; ok && !isIntfNil(w) {
												mayastorPools[i].Node = w.(string)
											}

											if w, ok := mayastorPoolsMapStrToI["pool_disk_devices"]; ok && !isIntfNil(w) {
												ls := make([]string, len(w.([]interface{})))
												for i, v := range w.([]interface{}) {
													ls[i] = v.(string)
												}
												mayastorPools[i].PoolDiskDevices = ls
											}

											if w, ok := mayastorPoolsMapStrToI["pool_name"]; ok && !isIntfNil(w) {
												mayastorPools[i].PoolName = w.(string)
											}

										}

									}

								}

							}

							if v, ok := storageDevicesMapStrToI["pure_service_orchestrator"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

								deviceChoiceTypeFound = true
								deviceChoiceInt := &ves_io_schema_fleet.FleetStorageDeviceType_PureServiceOrchestrator{}
								deviceChoiceInt.PureServiceOrchestrator = &ves_io_schema_fleet.StorageDevicePureStorageServiceOrchestratorType{}
								storageDevices[i].DeviceChoice = deviceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["arrays"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										arrays := &ves_io_schema_fleet.PsoArrayConfiguration{}
										deviceChoiceInt.PureServiceOrchestrator.Arrays = arrays
										for _, set := range sl {
											arraysMapStrToI := set.(map[string]interface{})

											if v, ok := arraysMapStrToI["flash_array"]; ok && !isIntfNil(v) {

												sl := v.(*schema.Set).List()
												flashArray := &ves_io_schema_fleet.FlashArrayType{}
												arrays.FlashArray = flashArray
												for _, set := range sl {
													flashArrayMapStrToI := set.(map[string]interface{})

													if w, ok := flashArrayMapStrToI["default_fs_opt"]; ok && !isIntfNil(w) {
														flashArray.DefaultFsOpt = w.(string)
													}

													if w, ok := flashArrayMapStrToI["default_fs_type"]; ok && !isIntfNil(w) {
														flashArray.DefaultFsType = w.(string)
													}

													if w, ok := flashArrayMapStrToI["default_mount_opts"]; ok && !isIntfNil(w) {
														ls := make([]string, len(w.([]interface{})))
														for i, v := range w.([]interface{}) {
															ls[i] = v.(string)
														}
														flashArray.DefaultMountOpts = ls
													}

													if w, ok := flashArrayMapStrToI["disable_preempt_attachments"]; ok && !isIntfNil(w) {
														flashArray.DisablePreemptAttachments = w.(bool)
													}

													if v, ok := flashArrayMapStrToI["flash_arrays"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														flashArrays := make([]*ves_io_schema_fleet.FlashArrayEndpoint, len(sl))
														flashArray.FlashArrays = flashArrays
														for i, set := range sl {
															flashArrays[i] = &ves_io_schema_fleet.FlashArrayEndpoint{}
															flashArraysMapStrToI := set.(map[string]interface{})

															if v, ok := flashArraysMapStrToI["api_token"]; ok && !isIntfNil(v) {

																sl := v.(*schema.Set).List()
																apiToken := &ves_io_schema.SecretType{}
																flashArrays[i].ApiToken = apiToken
																for _, set := range sl {
																	apiTokenMapStrToI := set.(map[string]interface{})

																	if v, ok := apiTokenMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																		sl := v.(*schema.Set).List()
																		blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																		apiToken.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																		for _, set := range sl {
																			blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																			if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																				blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																			}

																			if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																				blindfoldSecretInfoInternal.Location = w.(string)
																			}

																			if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																				blindfoldSecretInfoInternal.StoreProvider = w.(string)
																			}

																		}

																	}

																	if v, ok := apiTokenMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																		apiToken.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																	}

																	secretInfoOneofTypeFound := false

																	if v, ok := apiTokenMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																		secretInfoOneofTypeFound = true
																		secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																		secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																		apiToken.SecretInfoOneof = secretInfoOneofInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																			}

																			if v, ok := cs["location"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																			}

																			if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																			}

																		}

																	}

																	if v, ok := apiTokenMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																		secretInfoOneofTypeFound = true
																		secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																		secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																		apiToken.SecretInfoOneof = secretInfoOneofInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																			}

																			if v, ok := cs["url"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																			}

																		}

																	}

																	if v, ok := apiTokenMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																		secretInfoOneofTypeFound = true
																		secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																		secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																		apiToken.SecretInfoOneof = secretInfoOneofInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["key"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																			}

																			if v, ok := cs["location"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																			}

																			if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																			}

																			if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																			}

																			if v, ok := cs["version"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																			}

																		}

																	}

																	if v, ok := apiTokenMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																		secretInfoOneofTypeFound = true
																		secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																		secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																		apiToken.SecretInfoOneof = secretInfoOneofInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["name"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																			}

																		}

																	}

																}

															}

															if w, ok := flashArraysMapStrToI["labels"]; ok && !isIntfNil(w) {
																ms := map[string]string{}
																for k, v := range w.(map[string]interface{}) {
																	ms[k] = v.(string)
																}
																flashArrays[i].Labels = ms
															}

															mgmtEndpointTypeFound := false

															if v, ok := flashArraysMapStrToI["mgmt_dns_name"]; ok && !isIntfNil(v) && !mgmtEndpointTypeFound {

																mgmtEndpointTypeFound = true
																mgmtEndpointInt := &ves_io_schema_fleet.FlashArrayEndpoint_MgmtDnsName{}

																flashArrays[i].MgmtEndpoint = mgmtEndpointInt

																mgmtEndpointInt.MgmtDnsName = v.(string)

															}

															if v, ok := flashArraysMapStrToI["mgmt_ip"]; ok && !isIntfNil(v) && !mgmtEndpointTypeFound {

																mgmtEndpointTypeFound = true
																mgmtEndpointInt := &ves_io_schema_fleet.FlashArrayEndpoint_MgmtIp{}

																flashArrays[i].MgmtEndpoint = mgmtEndpointInt

																mgmtEndpointInt.MgmtIp = v.(string)

															}

														}

													}

													if w, ok := flashArrayMapStrToI["iscsi_login_timeout"]; ok && !isIntfNil(w) {
														flashArray.IscsiLoginTimeout = int32(w.(int))
													}

													if w, ok := flashArrayMapStrToI["san_type"]; ok && !isIntfNil(w) {
														flashArray.SanType = w.(string)
													}

												}

											}

											if v, ok := arraysMapStrToI["flash_blade"]; ok && !isIntfNil(v) {

												sl := v.(*schema.Set).List()
												flashBlade := &ves_io_schema_fleet.FlashBladeType{}
												arrays.FlashBlade = flashBlade
												for _, set := range sl {
													flashBladeMapStrToI := set.(map[string]interface{})

													if w, ok := flashBladeMapStrToI["enable_snapshot_directory"]; ok && !isIntfNil(w) {
														flashBlade.EnableSnapshotDirectory = w.(bool)
													}

													if w, ok := flashBladeMapStrToI["export_rules"]; ok && !isIntfNil(w) {
														flashBlade.ExportRules = w.(string)
													}

													if v, ok := flashBladeMapStrToI["flash_blades"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														flashBlades := make([]*ves_io_schema_fleet.FlashBladeEndpoint, len(sl))
														flashBlade.FlashBlades = flashBlades
														for i, set := range sl {
															flashBlades[i] = &ves_io_schema_fleet.FlashBladeEndpoint{}
															flashBladesMapStrToI := set.(map[string]interface{})

															if v, ok := flashBladesMapStrToI["api_token"]; ok && !isIntfNil(v) {

																sl := v.(*schema.Set).List()
																apiToken := &ves_io_schema.SecretType{}
																flashBlades[i].ApiToken = apiToken
																for _, set := range sl {
																	apiTokenMapStrToI := set.(map[string]interface{})

																	if v, ok := apiTokenMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																		sl := v.(*schema.Set).List()
																		blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																		apiToken.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																		for _, set := range sl {
																			blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																			if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																				blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																			}

																			if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																				blindfoldSecretInfoInternal.Location = w.(string)
																			}

																			if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																				blindfoldSecretInfoInternal.StoreProvider = w.(string)
																			}

																		}

																	}

																	if v, ok := apiTokenMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																		apiToken.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																	}

																	secretInfoOneofTypeFound := false

																	if v, ok := apiTokenMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																		secretInfoOneofTypeFound = true
																		secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																		secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																		apiToken.SecretInfoOneof = secretInfoOneofInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																			}

																			if v, ok := cs["location"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																			}

																			if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																			}

																		}

																	}

																	if v, ok := apiTokenMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																		secretInfoOneofTypeFound = true
																		secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																		secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																		apiToken.SecretInfoOneof = secretInfoOneofInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																			}

																			if v, ok := cs["url"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																			}

																		}

																	}

																	if v, ok := apiTokenMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																		secretInfoOneofTypeFound = true
																		secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																		secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																		apiToken.SecretInfoOneof = secretInfoOneofInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["key"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																			}

																			if v, ok := cs["location"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																			}

																			if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																			}

																			if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																			}

																			if v, ok := cs["version"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																			}

																		}

																	}

																	if v, ok := apiTokenMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																		secretInfoOneofTypeFound = true
																		secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																		secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																		apiToken.SecretInfoOneof = secretInfoOneofInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["name"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																			}

																		}

																	}

																}

															}

															if w, ok := flashBladesMapStrToI["lables"]; ok && !isIntfNil(w) {
																ms := map[string]string{}
																for k, v := range w.(map[string]interface{}) {
																	ms[k] = v.(string)
																}
																flashBlades[i].Lables = ms
															}

															mgmtEndpointTypeFound := false

															if v, ok := flashBladesMapStrToI["mgmt_dns_name"]; ok && !isIntfNil(v) && !mgmtEndpointTypeFound {

																mgmtEndpointTypeFound = true
																mgmtEndpointInt := &ves_io_schema_fleet.FlashBladeEndpoint_MgmtDnsName{}

																flashBlades[i].MgmtEndpoint = mgmtEndpointInt

																mgmtEndpointInt.MgmtDnsName = v.(string)

															}

															if v, ok := flashBladesMapStrToI["mgmt_ip"]; ok && !isIntfNil(v) && !mgmtEndpointTypeFound {

																mgmtEndpointTypeFound = true
																mgmtEndpointInt := &ves_io_schema_fleet.FlashBladeEndpoint_MgmtIp{}

																flashBlades[i].MgmtEndpoint = mgmtEndpointInt

																mgmtEndpointInt.MgmtIp = v.(string)

															}

															nfsEndpointTypeFound := false

															if v, ok := flashBladesMapStrToI["nfs_endpoint_dns_name"]; ok && !isIntfNil(v) && !nfsEndpointTypeFound {

																nfsEndpointTypeFound = true
																nfsEndpointInt := &ves_io_schema_fleet.FlashBladeEndpoint_NfsEndpointDnsName{}

																flashBlades[i].NfsEndpoint = nfsEndpointInt

																nfsEndpointInt.NfsEndpointDnsName = v.(string)

															}

															if v, ok := flashBladesMapStrToI["nfs_endpoint_ip"]; ok && !isIntfNil(v) && !nfsEndpointTypeFound {

																nfsEndpointTypeFound = true
																nfsEndpointInt := &ves_io_schema_fleet.FlashBladeEndpoint_NfsEndpointIp{}

																flashBlades[i].NfsEndpoint = nfsEndpointInt

																nfsEndpointInt.NfsEndpointIp = v.(string)

															}

														}

													}

												}

											}

										}

									}

									if v, ok := cs["cluster_id"]; ok && !isIntfNil(v) {

										deviceChoiceInt.PureServiceOrchestrator.ClusterId = v.(string)

									}

									if v, ok := cs["enable_storage_topology"]; ok && !isIntfNil(v) {

										deviceChoiceInt.PureServiceOrchestrator.EnableStorageTopology = v.(bool)

									}

									if v, ok := cs["enable_strict_topology"]; ok && !isIntfNil(v) {

										deviceChoiceInt.PureServiceOrchestrator.EnableStrictTopology = v.(bool)

									}

								}

							}

							if w, ok := storageDevicesMapStrToI["storage_device"]; ok && !isIntfNil(w) {
								storageDevices[i].StorageDevice = w.(string)
							}

						}

					}

				}

			}

			storageInterfaceChoiceTypeFound := false

			if v, ok := cs["no_storage_interfaces"]; ok && !isIntfNil(v) && !storageInterfaceChoiceTypeFound {

				storageInterfaceChoiceTypeFound = true

				if v.(bool) {
					storageInterfaceChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_NoStorageInterfaces{}
					storageInterfaceChoiceInt.NoStorageInterfaces = &ves_io_schema.Empty{}
					storageCfgChoiceInt.CustomStorageConfig.StorageInterfaceChoice = storageInterfaceChoiceInt
				}

			}

			if v, ok := cs["storage_interface_list"]; ok && !isIntfNil(v) && !storageInterfaceChoiceTypeFound {

				storageInterfaceChoiceTypeFound = true
				storageInterfaceChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_StorageInterfaceList{}
				storageInterfaceChoiceInt.StorageInterfaceList = &ves_io_schema_views_voltstack_site.StorageInterfaceListType{}
				storageCfgChoiceInt.CustomStorageConfig.StorageInterfaceChoice = storageInterfaceChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["storage_interfaces"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						storageInterfaces := make([]*ves_io_schema_views_voltstack_site.StorageInterfaceType, len(sl))
						storageInterfaceChoiceInt.StorageInterfaceList.StorageInterfaces = storageInterfaces
						for i, set := range sl {
							storageInterfaces[i] = &ves_io_schema_views_voltstack_site.StorageInterfaceType{}
							storageInterfacesMapStrToI := set.(map[string]interface{})

							if w, ok := storageInterfacesMapStrToI["description"]; ok && !isIntfNil(w) {
								storageInterfaces[i].Description = w.(string)
							}

							if w, ok := storageInterfacesMapStrToI["labels"]; ok && !isIntfNil(w) {
								ms := map[string]string{}
								for k, v := range w.(map[string]interface{}) {
									ms[k] = v.(string)
								}
								storageInterfaces[i].Labels = ms
							}

							if v, ok := storageInterfacesMapStrToI["storage_interface"]; ok && !isIntfNil(v) {

								sl := v.(*schema.Set).List()
								storageInterface := &ves_io_schema_network_interface.EthernetInterfaceType{}
								storageInterfaces[i].StorageInterface = storageInterface
								for _, set := range sl {
									storageInterfaceMapStrToI := set.(map[string]interface{})

									addressChoiceTypeFound := false

									if v, ok := storageInterfaceMapStrToI["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_DhcpClient{}
											addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
											storageInterface.AddressChoice = addressChoiceInt
										}

									}

									if v, ok := storageInterfaceMapStrToI["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_DhcpServer{}
										addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
										storageInterface.AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
												addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
												for i, set := range sl {
													dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
													dhcpNetworksMapStrToI := set.(map[string]interface{})

													dnsChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true
														dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

														dhcpNetworks[i].DnsChoice = dnsChoiceInt

														dnsChoiceInt.DnsAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true

														if v.(bool) {
															dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
															dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
															dhcpNetworks[i].DnsChoice = dnsChoiceInt
														}

													}

													gatewayChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true
														gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

														dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

														gatewayChoiceInt.DgwAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
															gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
															gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													networkPrefixChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														networkPrefixChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
														networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

															}

															if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

															}

															if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

															}

														}

													}

													if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

														dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

													}

													if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
														dhcpNetworks[i].Pools = pools
														for i, set := range sl {
															pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
															poolsMapStrToI := set.(map[string]interface{})

															if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																pools[i].EndIp = w.(string)
															}

															if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																pools[i].Exclude = w.(bool)
															}

															if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																pools[i].StartIp = w.(string)
															}

														}

													}

												}

											}

											if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

												addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

											}

											if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												addressChoiceInt.DhcpServer.FixedIpMap = ms
											}

											interfacesAddressingChoiceTypeFound := false

											if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
													interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
													interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true
												interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
												interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
												addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
													}

												}

											}

										}

									}

									if v, ok := storageInterfaceMapStrToI["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StaticIp{}
										addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIPParametersType{}
										storageInterface.AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if w, ok := storageInterfaceMapStrToI["device"]; ok && !isIntfNil(w) {
										storageInterface.Device = w.(string)
									}

									ipv6AddressChoiceTypeFound := false

									if v, ok := storageInterfaceMapStrToI["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true

										if v.(bool) {
											ipv6AddressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_NoIpv6Address{}
											ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
											storageInterface.Ipv6AddressChoice = ipv6AddressChoiceInt
										}

									}

									if v, ok := storageInterfaceMapStrToI["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StaticIpv6Address{}
										ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
										storageInterface.Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									monitoringChoiceTypeFound := false

									if v, ok := storageInterfaceMapStrToI["monitor"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true
										_ = v
									}

									if v, ok := storageInterfaceMapStrToI["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true

										if v.(bool) {
											monitoringChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_MonitorDisabled{}
											monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
											storageInterface.MonitoringChoice = monitoringChoiceInt
										}

									}

									if w, ok := storageInterfaceMapStrToI["mtu"]; ok && !isIntfNil(w) {
										storageInterface.Mtu = uint32(w.(int))
									}

									networkChoiceTypeFound := false

									if v, ok := storageInterfaceMapStrToI["inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true
										networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_InsideNetwork{}
										networkChoiceInt.InsideNetwork = &ves_io_schema_views.ObjectRefType{}
										storageInterface.NetworkChoice = networkChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												networkChoiceInt.InsideNetwork.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												networkChoiceInt.InsideNetwork.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												networkChoiceInt.InsideNetwork.Tenant = v.(string)

											}

										}

									}

									if v, ok := storageInterfaceMapStrToI["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SiteLocalInsideNetwork{}
											networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
											storageInterface.NetworkChoice = networkChoiceInt
										}

									}

									if v, ok := storageInterfaceMapStrToI["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SiteLocalNetwork{}
											networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
											storageInterface.NetworkChoice = networkChoiceInt
										}

									}

									if v, ok := storageInterfaceMapStrToI["srv6_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true
										networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Srv6Network{}
										networkChoiceInt.Srv6Network = &ves_io_schema_views.ObjectRefType{}
										storageInterface.NetworkChoice = networkChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												networkChoiceInt.Srv6Network.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												networkChoiceInt.Srv6Network.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												networkChoiceInt.Srv6Network.Tenant = v.(string)

											}

										}

									}

									if v, ok := storageInterfaceMapStrToI["storage_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StorageNetwork{}
											networkChoiceInt.StorageNetwork = &ves_io_schema.Empty{}
											storageInterface.NetworkChoice = networkChoiceInt
										}

									}

									nodeChoiceTypeFound := false

									if v, ok := storageInterfaceMapStrToI["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true

										if v.(bool) {
											nodeChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Cluster{}
											nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
											storageInterface.NodeChoice = nodeChoiceInt
										}

									}

									if v, ok := storageInterfaceMapStrToI["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true
										nodeChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Node{}

										storageInterface.NodeChoice = nodeChoiceInt

										nodeChoiceInt.Node = v.(string)

									}

									primaryChoiceTypeFound := false

									if v, ok := storageInterfaceMapStrToI["is_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

										primaryChoiceTypeFound = true

										if v.(bool) {
											primaryChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_IsPrimary{}
											primaryChoiceInt.IsPrimary = &ves_io_schema.Empty{}
											storageInterface.PrimaryChoice = primaryChoiceInt
										}

									}

									if v, ok := storageInterfaceMapStrToI["not_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

										primaryChoiceTypeFound = true

										if v.(bool) {
											primaryChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_NotPrimary{}
											primaryChoiceInt.NotPrimary = &ves_io_schema.Empty{}
											storageInterface.PrimaryChoice = primaryChoiceInt
										}

									}

									if w, ok := storageInterfaceMapStrToI["priority"]; ok && !isIntfNil(w) {
										storageInterface.Priority = uint32(w.(int))
									}

									vlanChoiceTypeFound := false

									if v, ok := storageInterfaceMapStrToI["untagged"]; ok && !isIntfNil(v) && !vlanChoiceTypeFound {

										vlanChoiceTypeFound = true

										if v.(bool) {
											vlanChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Untagged{}
											vlanChoiceInt.Untagged = &ves_io_schema.Empty{}
											storageInterface.VlanChoice = vlanChoiceInt
										}

									}

									if v, ok := storageInterfaceMapStrToI["vlan_id"]; ok && !isIntfNil(v) && !vlanChoiceTypeFound {

										vlanChoiceTypeFound = true
										vlanChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_VlanId{}

										storageInterface.VlanChoice = vlanChoiceInt

										vlanChoiceInt.VlanId = uint32(v.(int))

									}

								}

							}

						}

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("default_storage_config"); ok && !storageCfgChoiceTypeFound {

		storageCfgChoiceTypeFound = true

		if v.(bool) {
			storageCfgChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_DefaultStorageConfig{}
			storageCfgChoiceInt.DefaultStorageConfig = &ves_io_schema.Empty{}
			updateSpec.StorageCfgChoice = storageCfgChoiceInt
		}

	}

	usbPolicyChoiceTypeFound := false

	if v, ok := d.GetOk("allow_all_usb"); ok && !usbPolicyChoiceTypeFound {

		usbPolicyChoiceTypeFound = true

		if v.(bool) {
			usbPolicyChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_AllowAllUsb{}
			usbPolicyChoiceInt.AllowAllUsb = &ves_io_schema.Empty{}
			updateSpec.UsbPolicyChoice = usbPolicyChoiceInt
		}

	}

	if v, ok := d.GetOk("deny_all_usb"); ok && !usbPolicyChoiceTypeFound {

		usbPolicyChoiceTypeFound = true

		if v.(bool) {
			usbPolicyChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_DenyAllUsb{}
			usbPolicyChoiceInt.DenyAllUsb = &ves_io_schema.Empty{}
			updateSpec.UsbPolicyChoice = usbPolicyChoiceInt
		}

	}

	if v, ok := d.GetOk("usb_policy"); ok && !usbPolicyChoiceTypeFound {

		usbPolicyChoiceTypeFound = true
		usbPolicyChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_UsbPolicy{}
		usbPolicyChoiceInt.UsbPolicy = &ves_io_schema_views.ObjectRefType{}
		updateSpec.UsbPolicyChoice = usbPolicyChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["name"]; ok && !isIntfNil(v) {

				usbPolicyChoiceInt.UsbPolicy.Name = v.(string)

			}

			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

				usbPolicyChoiceInt.UsbPolicy.Namespace = v.(string)

			}

			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

				usbPolicyChoiceInt.UsbPolicy.Tenant = v.(string)

			}

		}

	}

	vmChoiceTypeFound := false

	if v, ok := d.GetOk("disable_vm"); ok && !vmChoiceTypeFound {

		vmChoiceTypeFound = true

		if v.(bool) {
			vmChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_DisableVm{}
			vmChoiceInt.DisableVm = &ves_io_schema.Empty{}
			updateSpec.VmChoice = vmChoiceInt
		}

	}

	// manually edited the config, should be fixed by next releas
	if v, ok := d.GetOk("enable_vm"); ok && !vmChoiceTypeFound {

		vmChoiceTypeFound = true
		if v.(bool) {
			vmChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_EnableVm{}
			vmChoiceInt.EnableVm = &ves_io_schema_fleet.VMConfiguration{}
			updateSpec.VmChoice = vmChoiceInt
		}
	}

	if v, ok := d.GetOk("volterra_certified_hw"); ok && !isIntfNil(v) {

		updateSpec.VolterraCertifiedHw =
			v.(string)

	}

	if v, ok := d.GetOk("worker_nodes"); ok && !isIntfNil(v) {

		ls := make([]string, len(v.([]interface{})))
		for i, v := range v.([]interface{}) {
			ls[i] = v.(string)
		}
		updateSpec.WorkerNodes = ls

	}

	log.Printf("[DEBUG] Updating Volterra VoltstackSite obj with struct: %+v", updateReq)

	err := client.ReplaceObject(context.Background(), ves_io_schema_views_voltstack_site.ObjectType, updateReq)
	if err != nil {
		return fmt.Errorf("error updating VoltstackSite: %s", err)
	}

	return resourceVolterraVoltstackSiteRead(d, meta)
}

func resourceVolterraVoltstackSiteDelete(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	_, err := client.GetObject(context.Background(), ves_io_schema_views_voltstack_site.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] VoltstackSite %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra VoltstackSite before deleting %q: %s", d.Id(), err)
	}

	log.Printf("[DEBUG] Deleting Volterra VoltstackSite obj with name %+v in namespace %+v", name, namespace)
	return client.DeleteObject(context.Background(), ves_io_schema_views_voltstack_site.ObjectType, namespace, name)
}
