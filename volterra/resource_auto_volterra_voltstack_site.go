//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-tf-provider. DO NOT EDIT.
//

package volterra

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"gopkg.volterra.us/stdlib/client/vesapi"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_bgp "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/bgp"
	ves_io_schema_fleet "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/fleet"
	ves_io_schema_network_firewall "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/network_firewall"
	ves_io_schema_network_interface "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/network_interface"
	ves_io_schema_site "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/site"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	ves_io_schema_views_voltstack_site "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/voltstack_site"
	ves_io_schema_virtual_network "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/virtual_network"
)

// resourceVolterraVoltstackSite is implementation of Volterra's VoltstackSite resources
func resourceVolterraVoltstackSite() *schema.Resource {
	return &schema.Resource{
		Create: resourceVolterraVoltstackSiteCreate,
		Read:   resourceVolterraVoltstackSiteRead,
		Update: resourceVolterraVoltstackSiteUpdate,
		Delete: resourceVolterraVoltstackSiteDelete,

		Schema: map[string]*schema.Schema{

			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"description": {
				Type:     schema.TypeString,
				Optional: true,
			},

			"disable": {
				Type:     schema.TypeBool,
				Optional: true,
			},

			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"namespace": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"address": {
				Type:     schema.TypeString,
				Optional: true,
			},

			"blocked_services": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"blocked_sevice": {

							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"dns": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"ssh": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"web_user_interface": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"network_type": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"default_blocked_services": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"bond_device_list": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"bond_devices": {

							Type:     schema.TypeList,
							Required: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"devices": {

										Type: schema.TypeList,

										Required: true,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},

									"active_backup": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"lacp": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"rate": {
													Type:     schema.TypeInt,
													Optional: true,
												},
											},
										},
									},

									"link_polling_interval": {
										Type:     schema.TypeInt,
										Required: true,
									},

									"link_up_delay": {
										Type:     schema.TypeInt,
										Required: true,
									},

									"name": {
										Type:     schema.TypeString,
										Required: true,
									},
								},
							},
						},
					},
				},
			},

			"no_bond_devices": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"coordinates": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"latitude": {
							Type:     schema.TypeFloat,
							Optional: true,
						},

						"longitude": {
							Type:     schema.TypeFloat,
							Optional: true,
						},
					},
				},
			},

			"custom_dns": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"inside_nameserver": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"inside_nameserver_v6": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"outside_nameserver": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"outside_nameserver_v6": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"disable_gpu": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"enable_gpu": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"enable_vgpu": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"feature_type": {
							Type:     schema.TypeString,
							Required: true,
						},

						"server_address": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"server_port": {
							Type:     schema.TypeInt,
							Optional: true,
						},
					},
				},
			},

			"k8s_cluster": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"name": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"namespace": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"tenant": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"no_k8s_cluster": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"kubernetes_upgrade_drain": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"disable_upgrade_drain": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"enable_upgrade_drain": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"drain_max_unavailable_node_count": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"drain_max_unavailable_node_percentage": {

										Type:       schema.TypeInt,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"drain_node_timeout": {
										Type:     schema.TypeInt,
										Required: true,
									},

									"disable_vega_upgrade_mode": {

										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"enable_vega_upgrade_mode": {

										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
								},
							},
						},
					},
				},
			},

			"local_control_plane": {

				Type:       schema.TypeList,
				MaxItems:   1,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"bgp_config": {

							Type:       schema.TypeList,
							MaxItems:   1,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"asn": {
										Type:       schema.TypeInt,
										Required:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"peers": {

										Type:       schema.TypeList,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{},
										},
									},
								},
							},
						},

						"inside_vn": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"outside_vn": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},
					},
				},
			},

			"no_local_control_plane": {

				Type:       schema.TypeBool,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
			},

			"log_receiver": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"name": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"namespace": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"tenant": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"logs_streaming_disabled": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"master_node_configuration": {

				Type:     schema.TypeList,
				Required: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"name": {
							Type:     schema.TypeString,
							Required: true,
						},

						"public_ip": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"master_nodes": {

				Type: schema.TypeList,

				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},

			"custom_network_config": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"bgp_peer_address": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"bgp_peer_address_v6": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"bgp_router_id": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"active_forward_proxy_policies": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"forward_proxy_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"forward_proxy_allow_all": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"no_forward_proxy": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"global_network_list": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"global_network_connections": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"sli_to_global_dr": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"global_vn": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"kind": {
																			Type:     schema.TypeString,
																			Computed: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},

												"slo_to_global_dr": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"global_vn": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"kind": {
																			Type:     schema.TypeString,
																			Computed: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},

												"disable_forward_proxy": {

													Type:       schema.TypeBool,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"enable_forward_proxy": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"connection_timeout": {
																Type:       schema.TypeInt,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"max_connect_attempts": {
																Type:       schema.TypeInt,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"no_interception": {

																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"tls_intercept": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"enable_for_all_domains": {

																			Type:       schema.TypeBool,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"policy": {

																			Type:       schema.TypeList,
																			MaxItems:   1,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interception_rules": {

																						Type:       schema.TypeList,
																						Required:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"domain_match": {

																									Type:       schema.TypeList,
																									MaxItems:   1,
																									Required:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"exact_value": {

																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"regex_value": {

																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"suffix_value": {

																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},
																										},
																									},
																								},

																								"disable_interception": {

																									Type:       schema.TypeBool,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"enable_interception": {

																									Type:       schema.TypeBool,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"custom_certificate": {

																			Type:       schema.TypeList,
																			MaxItems:   1,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"certificate_url": {
																						Type:       schema.TypeString,
																						Required:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"description": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"custom_hash_algorithms": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"hash_algorithms": {

																									Type: schema.TypeList,

																									Required:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Schema{
																										Type: schema.TypeString,
																									},
																								},
																							},
																						},
																					},

																					"disable_ocsp_stapling": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{},
																						},
																					},

																					"use_system_defaults": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{},
																						},
																					},

																					"private_key": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Required:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"blindfold_secret_info_internal": {

																									Type:       schema.TypeList,
																									MaxItems:   1,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"decryption_provider": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"location": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"store_provider": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},
																										},
																									},
																								},

																								"secret_encoding_type": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"blindfold_secret_info": {

																									Type:       schema.TypeList,
																									MaxItems:   1,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"decryption_provider": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"location": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"store_provider": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},
																										},
																									},
																								},

																								"clear_secret_info": {

																									Type:       schema.TypeList,
																									MaxItems:   1,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"provider": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"url": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},
																										},
																									},
																								},

																								"vault_secret_info": {

																									Type:       schema.TypeList,
																									MaxItems:   1,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"key": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"location": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"provider": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"secret_encoding": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"version": {
																												Type:       schema.TypeInt,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},
																										},
																									},
																								},

																								"wingman_secret_info": {

																									Type:       schema.TypeList,
																									MaxItems:   1,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"name": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"volterra_certificate": {

																			Type:       schema.TypeBool,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"trusted_ca_url": {

																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"volterra_trusted_ca": {

																			Type:       schema.TypeBool,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"white_listed_ports": {

																Type: schema.TypeList,

																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Schema{
																	Type: schema.TypeInt,
																},
															},

															"white_listed_prefixes": {

																Type: schema.TypeList,

																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"no_global_network": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"default_interface_config": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"interface_list": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"interfaces": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"dc_cluster_group_connectivity_interface_disabled": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"dc_cluster_group_connectivity_interface_enabled": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"description": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"dedicated_interface": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"device": {
																Type:     schema.TypeString,
																Required: true,
															},

															"monitor": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{},
																},
															},

															"monitor_disabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"mtu": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"cluster": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"node": {

																Type:     schema.TypeString,
																Optional: true,
															},

															"is_primary": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"not_primary": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"priority": {
																Type:     schema.TypeInt,
																Optional: true,
															},
														},
													},
												},

												"dedicated_management_interface": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"device": {
																Type:     schema.TypeString,
																Required: true,
															},

															"mtu": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"cluster": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"node": {

																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"ethernet_interface": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"dhcp_client": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"dhcp_server": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"dhcp_networks": {

																			Type:     schema.TypeList,
																			Required: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"dns_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"same_as_dgw": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"dgw_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"first_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"last_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"network_prefix": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"network_prefix_allocator": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"namespace": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"tenant": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},

																					"pool_settings": {
																						Type:     schema.TypeString,
																						Required: true,
																					},

																					"pools": {

																						Type:     schema.TypeList,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"end_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"exclude": {
																									Type:       schema.TypeBool,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"start_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"dhcp_option82_tag": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"fixed_ip_map": {
																			Type:     schema.TypeMap,
																			Optional: true,
																		},

																		"automatic_from_end": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"automatic_from_start": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"interface_ip_map": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {
																						Type:     schema.TypeMap,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"static_ip": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"cluster_static_ip": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																								"value": {

																									Type:     schema.TypeList,
																									MaxItems: 1,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"default_gw": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"dns_server": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"ip_address": {
																												Type:     schema.TypeString,
																												Required: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"fleet_static_ip": {

																			Type:       schema.TypeList,
																			MaxItems:   1,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"network_prefix_allocator": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"namespace": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"tenant": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"node_static_ip": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"ip_address": {
																						Type:     schema.TypeString,
																						Required: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"device": {
																Type:     schema.TypeString,
																Required: true,
															},

															"ipv6_auto_config": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"host": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"router": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"network_prefix": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"stateful": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"dhcp_networks": {

																									Type:     schema.TypeList,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"network_prefix": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"network_prefix_allocator": {

																												Type:       schema.TypeList,
																												MaxItems:   1,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"name": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																														"namespace": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																														"tenant": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																													},
																												},
																											},

																											"pool_settings": {
																												Type:     schema.TypeString,
																												Required: true,
																											},

																											"pools": {

																												Type:     schema.TypeList,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"end_ip": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"exclude": {
																															Type:       schema.TypeBool,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},

																														"start_ip": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},
																													},
																												},
																											},
																										},
																									},
																								},

																								"fixed_ip_map": {
																									Type:     schema.TypeMap,
																									Optional: true,
																								},

																								"automatic_from_end": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"automatic_from_start": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"interface_ip_map": {

																									Type:     schema.TypeList,
																									MaxItems: 1,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"interface_ip_map": {
																												Type:     schema.TypeMap,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},

																					"dns_config": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"configured_list": {

																									Type:     schema.TypeList,
																									MaxItems: 1,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"dns_list": {

																												Type: schema.TypeList,

																												Required: true,
																												Elem: &schema.Schema{
																													Type: schema.TypeString,
																												},
																											},
																										},
																									},
																								},

																								"local_dns": {

																									Type:     schema.TypeList,
																									MaxItems: 1,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"configured_address": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"first_address": {

																												Type:     schema.TypeBool,
																												Optional: true,
																											},

																											"last_address": {

																												Type:     schema.TypeBool,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},

															"no_ipv6_address": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"static_ipv6_address": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"cluster_static_ip": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																								"value": {

																									Type:     schema.TypeList,
																									MaxItems: 1,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"default_gw": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"dns_server": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"ip_address": {
																												Type:     schema.TypeString,
																												Required: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"fleet_static_ip": {

																			Type:       schema.TypeList,
																			MaxItems:   1,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"network_prefix_allocator": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"namespace": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"tenant": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"node_static_ip": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"ip_address": {
																						Type:     schema.TypeString,
																						Required: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"monitor": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{},
																},
															},

															"monitor_disabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"mtu": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"inside_network": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																		"namespace": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																		"tenant": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"ip_fabric_network": {

																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"segment_network": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"site_local_inside_network": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"site_local_network": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"srv6_network": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																		"namespace": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																		"tenant": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"storage_network": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"cluster": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"node": {

																Type:     schema.TypeString,
																Optional: true,
															},

															"is_primary": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"not_primary": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"priority": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"untagged": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"vlan_id": {

																Type:     schema.TypeInt,
																Optional: true,
															},
														},
													},
												},

												"loopback_interface": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"dhcp_client": {

																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"dhcp_server": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"dhcp_networks": {

																			Type:       schema.TypeList,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"dns_address": {

																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"same_as_dgw": {

																						Type:       schema.TypeBool,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"dgw_address": {

																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"first_address": {

																						Type:       schema.TypeBool,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"last_address": {

																						Type:       schema.TypeBool,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"network_prefix": {

																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"network_prefix_allocator": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"namespace": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"tenant": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},

																					"pool_settings": {
																						Type:       schema.TypeString,
																						Required:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"pools": {

																						Type:       schema.TypeList,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"end_ip": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"exclude": {
																									Type:       schema.TypeBool,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"start_ip": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"dhcp_option82_tag": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"fixed_ip_map": {
																			Type:       schema.TypeMap,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"automatic_from_end": {

																			Type:       schema.TypeBool,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"automatic_from_start": {

																			Type:       schema.TypeBool,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"interface_ip_map": {

																			Type:       schema.TypeList,
																			MaxItems:   1,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {
																						Type:       schema.TypeMap,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},
																				},
																			},
																		},
																	},
																},
															},

															"static_ip": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"cluster_static_ip": {

																			Type:       schema.TypeList,
																			MaxItems:   1,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Required:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"value": {

																									Type:       schema.TypeList,
																									MaxItems:   1,
																									Required:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"default_gw": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"dns_server": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"ip_address": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"fleet_static_ip": {

																			Type:       schema.TypeList,
																			MaxItems:   1,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"network_prefix_allocator": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"namespace": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"tenant": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"node_static_ip": {

																			Type:       schema.TypeList,
																			MaxItems:   1,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"ip_address": {
																						Type:       schema.TypeString,
																						Required:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},
																				},
																			},
																		},
																	},
																},
															},

															"device": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"no_ipv6_address": {

																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"static_ipv6_address": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"cluster_static_ip": {

																			Type:       schema.TypeList,
																			MaxItems:   1,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Required:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"value": {

																									Type:       schema.TypeList,
																									MaxItems:   1,
																									Required:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"default_gw": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"dns_server": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"ip_address": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"fleet_static_ip": {

																			Type:       schema.TypeList,
																			MaxItems:   1,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"network_prefix_allocator": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"namespace": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"tenant": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"node_static_ip": {

																			Type:       schema.TypeList,
																			MaxItems:   1,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"ip_address": {
																						Type:       schema.TypeString,
																						Required:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},
																				},
																			},
																		},
																	},
																},
															},

															"mtu": {
																Type:       schema.TypeInt,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"ip_fabric_network": {

																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"site_local_inside_network": {

																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"site_local_network": {

																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"cluster": {

																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"node": {

																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},

												"tunnel_interface": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"cloud_connect": {

																Type:       schema.TypeList,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"kind": {
																			Type:       schema.TypeString,
																			Computed:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"name": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																		"namespace": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																		"tenant": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"mtu": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"inside_network": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																		"namespace": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																		"tenant": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"site_local_inside_network": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"site_local_network": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"cluster": {

																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"node": {

																Type:     schema.TypeString,
																Optional: true,
															},

															"priority": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"static_ip": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"cluster_static_ip": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																								"value": {

																									Type:     schema.TypeList,
																									MaxItems: 1,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"default_gw": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"dns_server": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"ip_address": {
																												Type:     schema.TypeString,
																												Required: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"fleet_static_ip": {

																			Type:       schema.TypeList,
																			MaxItems:   1,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"network_prefix_allocator": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"namespace": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"tenant": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"node_static_ip": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"ip_address": {
																						Type:     schema.TypeString,
																						Required: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"tunnel": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},

												"labels": {
													Type:     schema.TypeMap,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"active_enhanced_firewall_policies": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"enhanced_firewall_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"active_network_policies": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"network_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"no_network_policy": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"outside_nameserver": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"outside_nameserver_v6": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"outside_vip": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"outside_vip_v6": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"site_to_site_tunnel_ip": {

							Type:     schema.TypeString,
							Optional: true,
						},

						"sm_connection_public_ip": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"sm_connection_pvt_ip": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"default_sli_config": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"sli_config": {

							Type:       schema.TypeList,
							MaxItems:   1,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"no_static_routes": {

										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"static_routes": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"static_routes": {

													Type:       schema.TypeList,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"attrs": {

																Type: schema.TypeList,

																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"ip_prefixes": {

																Type: schema.TypeList,

																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"default_gateway": {

																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"interface": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																		"namespace": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																		"tenant": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"ip_address": {

																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},
											},
										},
									},

									"no_v6_static_routes": {

										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"static_v6_routes": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"static_routes": {

													Type:       schema.TypeList,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"attrs": {

																Type: schema.TypeList,

																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"ip_prefixes": {

																Type: schema.TypeList,

																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"default_gateway": {

																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"interface": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																		"namespace": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																		"tenant": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"ip_address": {

																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"default_config": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"slo_config": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"dc_cluster_group": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},

									"no_dc_cluster_group": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"dc_cluster_group_interface": {

										Type:       schema.TypeList,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
												"namespace": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
												"tenant": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},

									"labels": {
										Type:     schema.TypeMap,
										Optional: true,
									},

									"no_static_routes": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"static_routes": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"static_routes": {

													Type:     schema.TypeList,
													Required: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"attrs": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"ip_prefixes": {

																Type: schema.TypeList,

																Required: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"default_gateway": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"interface": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"ip_address": {

																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},

									"no_static_v6_routes": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"static_v6_routes": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"static_routes": {

													Type:     schema.TypeList,
													Required: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"attrs": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"ip_prefixes": {

																Type: schema.TypeList,

																Required: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"default_gateway": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"interface": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"ip_address": {

																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"tunnel_dead_timeout": {
							Type:     schema.TypeInt,
							Optional: true,
						},

						"vip_vrrp_mode": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"default_network_config": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"offline_survivability_mode": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"enable_offline_survivability_mode": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"no_offline_survivability_mode": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"os": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"default_os_version": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"operating_system_version": {

							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"default_sriov_interface": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"sriov_interfaces": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"sriov_interface": {

							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"interface_name": {
										Type:     schema.TypeString,
										Required: true,
									},

									"number_of_vfio_vfs": {
										Type:     schema.TypeInt,
										Optional: true,
									},

									"number_of_vfs": {
										Type:     schema.TypeInt,
										Required: true,
									},
								},
							},
						},
					},
				},
			},

			"custom_storage_config": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"no_static_routes": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"static_routes": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"static_routes": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"attrs": {

													Type: schema.TypeList,

													Optional: true,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},

												"ip_prefixes": {

													Type: schema.TypeList,

													Required: true,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},

												"default_gateway": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"interface": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"name": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"namespace": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"tenant": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"ip_address": {

													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"default_storage_class": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"storage_class_list": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"storage_classes": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"advanced_storage_parameters": {
													Type:     schema.TypeMap,
													Optional: true,
												},

												"allow_volume_expansion": {
													Type:     schema.TypeBool,
													Optional: true,
												},

												"default_storage_class": {
													Type:     schema.TypeBool,
													Optional: true,
												},

												"description": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"custom_storage": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"yaml": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"hpe_storage": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"allow_mutations": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"allow_overrides": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"dedupe_enabled": {
																Type:     schema.TypeBool,
																Optional: true,
															},

															"description": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"destroy_on_delete": {
																Type:     schema.TypeBool,
																Optional: true,
															},

															"encrypted": {
																Type:     schema.TypeBool,
																Optional: true,
															},

															"folder": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"limit_iops": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"limit_mbps": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"performance_policy": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"pool": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"protection_template": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"secret_name": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"secret_namespace": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"sync_on_detach": {
																Type:     schema.TypeBool,
																Optional: true,
															},

															"thick": {
																Type:     schema.TypeBool,
																Optional: true,
															},
														},
													},
												},

												"netapp_trident": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"selector": {
																Type:     schema.TypeMap,
																Optional: true,
															},

															"storage_pools": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"pure_service_orchestrator": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"backend": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"bandwidth_limit": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"iops_limit": {
																Type:     schema.TypeInt,
																Optional: true,
															},
														},
													},
												},

												"reclaim_policy": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"storage_class_name": {
													Type:     schema.TypeString,
													Required: true,
												},

												"storage_device": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},
								},
							},
						},

						"no_storage_device": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"storage_device_list": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"storage_devices": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"advanced_advanced_parameters": {
													Type:     schema.TypeMap,
													Optional: true,
												},

												"custom_storage": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"hpe_storage": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"api_server_port": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"csi_version": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"iscsi_chap_password": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"blindfold_secret_info_internal": {

																			Type:       schema.TypeList,
																			MaxItems:   1,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"decryption_provider": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"location": {
																						Type:       schema.TypeString,
																						Required:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"store_provider": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},
																				},
																			},
																		},

																		"secret_encoding_type": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"blindfold_secret_info": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"decryption_provider": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"location": {
																						Type:     schema.TypeString,
																						Required: true,
																					},

																					"store_provider": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"clear_secret_info": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"provider": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"url": {
																						Type:     schema.TypeString,
																						Required: true,
																					},
																				},
																			},
																		},

																		"vault_secret_info": {

																			Type:       schema.TypeList,
																			MaxItems:   1,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"key": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"location": {
																						Type:       schema.TypeString,
																						Required:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"provider": {
																						Type:       schema.TypeString,
																						Required:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"secret_encoding": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"version": {
																						Type:       schema.TypeInt,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},
																				},
																			},
																		},

																		"wingman_secret_info": {

																			Type:       schema.TypeList,
																			MaxItems:   1,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"name": {
																						Type:       schema.TypeString,
																						Required:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},
																				},
																			},
																		},
																	},
																},
															},

															"iscsi_chap_user": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"log_level": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"password": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"blindfold_secret_info_internal": {

																			Type:       schema.TypeList,
																			MaxItems:   1,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"decryption_provider": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"location": {
																						Type:       schema.TypeString,
																						Required:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"store_provider": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},
																				},
																			},
																		},

																		"secret_encoding_type": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"blindfold_secret_info": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"decryption_provider": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"location": {
																						Type:     schema.TypeString,
																						Required: true,
																					},

																					"store_provider": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"clear_secret_info": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"provider": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"url": {
																						Type:     schema.TypeString,
																						Required: true,
																					},
																				},
																			},
																		},

																		"vault_secret_info": {

																			Type:       schema.TypeList,
																			MaxItems:   1,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"key": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"location": {
																						Type:       schema.TypeString,
																						Required:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"provider": {
																						Type:       schema.TypeString,
																						Required:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"secret_encoding": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"version": {
																						Type:       schema.TypeInt,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},
																				},
																			},
																		},

																		"wingman_secret_info": {

																			Type:       schema.TypeList,
																			MaxItems:   1,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"name": {
																						Type:       schema.TypeString,
																						Required:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},
																				},
																			},
																		},
																	},
																},
															},

															"storage_server_ip_address": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"storage_server_name": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"username": {
																Type:     schema.TypeString,
																Required: true,
															},
														},
													},
												},

												"netapp_trident": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"netapp_backend_ontap_nas": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"auto_export_cidrs": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"ipv6_prefixes": {

																						Type: schema.TypeList,

																						Optional: true,
																						Elem: &schema.Schema{
																							Type: schema.TypeString,
																						},
																					},

																					"prefixes": {

																						Type: schema.TypeList,

																						Optional: true,
																						Elem: &schema.Schema{
																							Type: schema.TypeString,
																						},
																					},
																				},
																			},
																		},

																		"auto_export_policy": {
																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"backend_name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"client_certificate": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"client_private_key": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"blindfold_secret_info_internal": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"decryption_provider": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"location": {
																									Type:       schema.TypeString,
																									Required:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"store_provider": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},

																					"secret_encoding_type": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"blindfold_secret_info": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"decryption_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"location": {
																									Type:     schema.TypeString,
																									Required: true,
																								},

																								"store_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"clear_secret_info": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"url": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																							},
																						},
																					},

																					"vault_secret_info": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"key": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"location": {
																									Type:       schema.TypeString,
																									Required:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"provider": {
																									Type:       schema.TypeString,
																									Required:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"secret_encoding": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"version": {
																									Type:       schema.TypeInt,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},

																					"wingman_secret_info": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Required:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"data_lif_dns_name": {

																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"data_lif_ip": {

																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"labels": {
																			Type:     schema.TypeMap,
																			Optional: true,
																		},

																		"limit_aggregate_usage": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"limit_volume_size": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"management_lif_dns_name": {

																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"management_lif_ip": {

																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"nfs_mount_options": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"password": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"blindfold_secret_info_internal": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"decryption_provider": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"location": {
																									Type:       schema.TypeString,
																									Required:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"store_provider": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},

																					"secret_encoding_type": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"blindfold_secret_info": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"decryption_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"location": {
																									Type:     schema.TypeString,
																									Required: true,
																								},

																								"store_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"clear_secret_info": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"url": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																							},
																						},
																					},

																					"vault_secret_info": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"key": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"location": {
																									Type:       schema.TypeString,
																									Required:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"provider": {
																									Type:       schema.TypeString,
																									Required:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"secret_encoding": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"version": {
																									Type:       schema.TypeInt,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},

																					"wingman_secret_info": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Required:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"region": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"storage": {

																			Type:     schema.TypeList,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"labels": {
																						Type:     schema.TypeMap,
																						Optional: true,
																					},

																					"volume_defaults": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"encryption": {
																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"export_policy": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"adaptive_qos_policy": {

																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"no_qos": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"qos_policy": {

																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"security_style": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"snapshot_dir": {
																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"snapshot_policy": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"snapshot_reserve": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"space_reserve": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"split_on_clone": {
																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"tiering_policy": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"unix_permissions": {
																									Type:     schema.TypeInt,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"zone": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"storage_driver_name": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"storage_prefix": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"svm": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"trusted_ca_certificate": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"username": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"volume_defaults": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"encryption": {
																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"export_policy": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"adaptive_qos_policy": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"no_qos": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"qos_policy": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"security_style": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"snapshot_dir": {
																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"snapshot_policy": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"snapshot_reserve": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"space_reserve": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"split_on_clone": {
																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"tiering_policy": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"unix_permissions": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"netapp_backend_ontap_san": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"no_chap": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"use_chap": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"chap_initiator_secret": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"blindfold_secret_info_internal": {

																									Type:       schema.TypeList,
																									MaxItems:   1,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"decryption_provider": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"location": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"store_provider": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},
																										},
																									},
																								},

																								"secret_encoding_type": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"blindfold_secret_info": {

																									Type:     schema.TypeList,
																									MaxItems: 1,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"decryption_provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"location": {
																												Type:     schema.TypeString,
																												Required: true,
																											},

																											"store_provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},
																										},
																									},
																								},

																								"clear_secret_info": {

																									Type:     schema.TypeList,
																									MaxItems: 1,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"url": {
																												Type:     schema.TypeString,
																												Required: true,
																											},
																										},
																									},
																								},

																								"vault_secret_info": {

																									Type:       schema.TypeList,
																									MaxItems:   1,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"key": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"location": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"provider": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"secret_encoding": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"version": {
																												Type:       schema.TypeInt,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},
																										},
																									},
																								},

																								"wingman_secret_info": {

																									Type:       schema.TypeList,
																									MaxItems:   1,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"name": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},
																										},
																									},
																								},
																							},
																						},
																					},

																					"chap_target_initiator_secret": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"blindfold_secret_info_internal": {

																									Type:       schema.TypeList,
																									MaxItems:   1,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"decryption_provider": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"location": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"store_provider": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},
																										},
																									},
																								},

																								"secret_encoding_type": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"blindfold_secret_info": {

																									Type:     schema.TypeList,
																									MaxItems: 1,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"decryption_provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"location": {
																												Type:     schema.TypeString,
																												Required: true,
																											},

																											"store_provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},
																										},
																									},
																								},

																								"clear_secret_info": {

																									Type:     schema.TypeList,
																									MaxItems: 1,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"url": {
																												Type:     schema.TypeString,
																												Required: true,
																											},
																										},
																									},
																								},

																								"vault_secret_info": {

																									Type:       schema.TypeList,
																									MaxItems:   1,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"key": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"location": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"provider": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"secret_encoding": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"version": {
																												Type:       schema.TypeInt,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},
																										},
																									},
																								},

																								"wingman_secret_info": {

																									Type:       schema.TypeList,
																									MaxItems:   1,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"name": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},
																										},
																									},
																								},
																							},
																						},
																					},

																					"chap_target_username": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"chap_username": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"client_certificate": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"client_private_key": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"blindfold_secret_info_internal": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"decryption_provider": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"location": {
																									Type:       schema.TypeString,
																									Required:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"store_provider": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},

																					"secret_encoding_type": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"blindfold_secret_info": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"decryption_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"location": {
																									Type:     schema.TypeString,
																									Required: true,
																								},

																								"store_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"clear_secret_info": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"url": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																							},
																						},
																					},

																					"vault_secret_info": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"key": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"location": {
																									Type:       schema.TypeString,
																									Required:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"provider": {
																									Type:       schema.TypeString,
																									Required:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"secret_encoding": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"version": {
																									Type:       schema.TypeInt,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},

																					"wingman_secret_info": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Required:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"data_lif_dns_name": {

																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"data_lif_ip": {

																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"igroup_name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"labels": {
																			Type:     schema.TypeMap,
																			Optional: true,
																		},

																		"limit_aggregate_usage": {
																			Type:     schema.TypeInt,
																			Optional: true,
																		},

																		"limit_volume_size": {
																			Type:     schema.TypeInt,
																			Optional: true,
																		},

																		"management_lif_dns_name": {

																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"management_lif_ip": {

																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"password": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"blindfold_secret_info_internal": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"decryption_provider": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"location": {
																									Type:       schema.TypeString,
																									Required:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"store_provider": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},

																					"secret_encoding_type": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"blindfold_secret_info": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"decryption_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"location": {
																									Type:     schema.TypeString,
																									Required: true,
																								},

																								"store_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"clear_secret_info": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"url": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																							},
																						},
																					},

																					"vault_secret_info": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"key": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"location": {
																									Type:       schema.TypeString,
																									Required:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"provider": {
																									Type:       schema.TypeString,
																									Required:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"secret_encoding": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"version": {
																									Type:       schema.TypeInt,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},

																					"wingman_secret_info": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Required:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"region": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"storage": {

																			Type:     schema.TypeList,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"labels": {
																						Type:     schema.TypeMap,
																						Optional: true,
																					},

																					"volume_defaults": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"encryption": {
																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"export_policy": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"adaptive_qos_policy": {

																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"no_qos": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"qos_policy": {

																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"security_style": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"snapshot_dir": {
																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"snapshot_policy": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"snapshot_reserve": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"space_reserve": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"split_on_clone": {
																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"tiering_policy": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"unix_permissions": {
																									Type:     schema.TypeInt,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"zone": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"storage_driver_name": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"storage_prefix": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"svm": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"trusted_ca_certificate": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"username": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"volume_defaults": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"encryption": {
																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"export_policy": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"adaptive_qos_policy": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"no_qos": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"qos_policy": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"security_style": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"snapshot_dir": {
																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"snapshot_policy": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"snapshot_reserve": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"space_reserve": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"split_on_clone": {
																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"tiering_policy": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"unix_permissions": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},

												"pure_service_orchestrator": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"arrays": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"flash_array": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_fs_opt": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"default_fs_type": {
																						Type:     schema.TypeString,
																						Required: true,
																					},

																					"default_mount_opts": {

																						Type: schema.TypeList,

																						Optional: true,
																						Elem: &schema.Schema{
																							Type: schema.TypeString,
																						},
																					},

																					"disable_preempt_attachments": {
																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"flash_arrays": {

																						Type:     schema.TypeList,
																						Required: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"api_token": {

																									Type:     schema.TypeList,
																									MaxItems: 1,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"blindfold_secret_info_internal": {

																												Type:       schema.TypeList,
																												MaxItems:   1,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"decryption_provider": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},

																														"location": {
																															Type:       schema.TypeString,
																															Required:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},

																														"store_provider": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																													},
																												},
																											},

																											"secret_encoding_type": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"blindfold_secret_info": {

																												Type:     schema.TypeList,
																												MaxItems: 1,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"decryption_provider": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"location": {
																															Type:     schema.TypeString,
																															Required: true,
																														},

																														"store_provider": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},
																													},
																												},
																											},

																											"clear_secret_info": {

																												Type:     schema.TypeList,
																												MaxItems: 1,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"provider": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"url": {
																															Type:     schema.TypeString,
																															Required: true,
																														},
																													},
																												},
																											},

																											"vault_secret_info": {

																												Type:       schema.TypeList,
																												MaxItems:   1,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"key": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},

																														"location": {
																															Type:       schema.TypeString,
																															Required:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},

																														"provider": {
																															Type:       schema.TypeString,
																															Required:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},

																														"secret_encoding": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},

																														"version": {
																															Type:       schema.TypeInt,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																													},
																												},
																											},

																											"wingman_secret_info": {

																												Type:       schema.TypeList,
																												MaxItems:   1,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"name": {
																															Type:       schema.TypeString,
																															Required:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																													},
																												},
																											},
																										},
																									},
																								},

																								"labels": {
																									Type:     schema.TypeMap,
																									Optional: true,
																								},

																								"mgmt_dns_name": {

																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"mgmt_ip": {

																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"iscsi_login_timeout": {
																						Type:     schema.TypeInt,
																						Required: true,
																					},

																					"san_type": {
																						Type:     schema.TypeString,
																						Required: true,
																					},
																				},
																			},
																		},

																		"flash_blade": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"enable_snapshot_directory": {
																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"export_rules": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"flash_blades": {

																						Type:     schema.TypeList,
																						Required: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"api_token": {

																									Type:     schema.TypeList,
																									MaxItems: 1,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"blindfold_secret_info_internal": {

																												Type:       schema.TypeList,
																												MaxItems:   1,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"decryption_provider": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},

																														"location": {
																															Type:       schema.TypeString,
																															Required:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},

																														"store_provider": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																													},
																												},
																											},

																											"secret_encoding_type": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"blindfold_secret_info": {

																												Type:     schema.TypeList,
																												MaxItems: 1,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"decryption_provider": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"location": {
																															Type:     schema.TypeString,
																															Required: true,
																														},

																														"store_provider": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},
																													},
																												},
																											},

																											"clear_secret_info": {

																												Type:     schema.TypeList,
																												MaxItems: 1,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"provider": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"url": {
																															Type:     schema.TypeString,
																															Required: true,
																														},
																													},
																												},
																											},

																											"vault_secret_info": {

																												Type:       schema.TypeList,
																												MaxItems:   1,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"key": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},

																														"location": {
																															Type:       schema.TypeString,
																															Required:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},

																														"provider": {
																															Type:       schema.TypeString,
																															Required:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},

																														"secret_encoding": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},

																														"version": {
																															Type:       schema.TypeInt,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																													},
																												},
																											},

																											"wingman_secret_info": {

																												Type:       schema.TypeList,
																												MaxItems:   1,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"name": {
																															Type:       schema.TypeString,
																															Required:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																													},
																												},
																											},
																										},
																									},
																								},

																								"lables": {
																									Type:     schema.TypeMap,
																									Optional: true,
																								},

																								"mgmt_dns_name": {

																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"mgmt_ip": {

																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"nfs_endpoint_dns_name": {

																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"nfs_endpoint_ip": {

																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},

															"cluster_id": {
																Type:     schema.TypeString,
																Required: true,
															},

															"enable_storage_topology": {
																Type:     schema.TypeBool,
																Optional: true,
															},

															"enable_strict_topology": {
																Type:     schema.TypeBool,
																Optional: true,
															},
														},
													},
												},

												"storage_device": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},
								},
							},
						},

						"no_storage_interfaces": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"storage_interface_list": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"storage_interfaces": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"description": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"labels": {
													Type:     schema.TypeMap,
													Optional: true,
												},

												"storage_interface": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Required: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"dhcp_client": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"dhcp_server": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"dhcp_networks": {

																			Type:     schema.TypeList,
																			Required: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"dns_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"same_as_dgw": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"dgw_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"first_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"last_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"network_prefix": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"network_prefix_allocator": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"namespace": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"tenant": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},

																					"pool_settings": {
																						Type:     schema.TypeString,
																						Required: true,
																					},

																					"pools": {

																						Type:     schema.TypeList,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"end_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"exclude": {
																									Type:       schema.TypeBool,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"start_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"dhcp_option82_tag": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"fixed_ip_map": {
																			Type:     schema.TypeMap,
																			Optional: true,
																		},

																		"automatic_from_end": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"automatic_from_start": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"interface_ip_map": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {
																						Type:     schema.TypeMap,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"static_ip": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"cluster_static_ip": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																								"value": {

																									Type:     schema.TypeList,
																									MaxItems: 1,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"default_gw": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"dns_server": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"ip_address": {
																												Type:     schema.TypeString,
																												Required: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"fleet_static_ip": {

																			Type:       schema.TypeList,
																			MaxItems:   1,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"network_prefix_allocator": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"namespace": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"tenant": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"node_static_ip": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"ip_address": {
																						Type:     schema.TypeString,
																						Required: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"device": {
																Type:     schema.TypeString,
																Required: true,
															},

															"ipv6_auto_config": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"host": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"router": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"network_prefix": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"stateful": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"dhcp_networks": {

																									Type:     schema.TypeList,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"network_prefix": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"network_prefix_allocator": {

																												Type:       schema.TypeList,
																												MaxItems:   1,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"name": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																														"namespace": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																														"tenant": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																													},
																												},
																											},

																											"pool_settings": {
																												Type:     schema.TypeString,
																												Required: true,
																											},

																											"pools": {

																												Type:     schema.TypeList,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"end_ip": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"exclude": {
																															Type:       schema.TypeBool,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},

																														"start_ip": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},
																													},
																												},
																											},
																										},
																									},
																								},

																								"fixed_ip_map": {
																									Type:     schema.TypeMap,
																									Optional: true,
																								},

																								"automatic_from_end": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"automatic_from_start": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"interface_ip_map": {

																									Type:     schema.TypeList,
																									MaxItems: 1,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"interface_ip_map": {
																												Type:     schema.TypeMap,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},

																					"dns_config": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"configured_list": {

																									Type:     schema.TypeList,
																									MaxItems: 1,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"dns_list": {

																												Type: schema.TypeList,

																												Required: true,
																												Elem: &schema.Schema{
																													Type: schema.TypeString,
																												},
																											},
																										},
																									},
																								},

																								"local_dns": {

																									Type:     schema.TypeList,
																									MaxItems: 1,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"configured_address": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"first_address": {

																												Type:     schema.TypeBool,
																												Optional: true,
																											},

																											"last_address": {

																												Type:     schema.TypeBool,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},

															"no_ipv6_address": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"static_ipv6_address": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"cluster_static_ip": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																								"value": {

																									Type:     schema.TypeList,
																									MaxItems: 1,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"default_gw": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"dns_server": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"ip_address": {
																												Type:     schema.TypeString,
																												Required: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"fleet_static_ip": {

																			Type:       schema.TypeList,
																			MaxItems:   1,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"network_prefix_allocator": {

																						Type:       schema.TypeList,
																						MaxItems:   1,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"namespace": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"tenant": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"node_static_ip": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"ip_address": {
																						Type:     schema.TypeString,
																						Required: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"monitor": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{},
																},
															},

															"monitor_disabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"mtu": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"inside_network": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																		"namespace": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																		"tenant": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"ip_fabric_network": {

																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"segment_network": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"site_local_inside_network": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"site_local_network": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"srv6_network": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																		"namespace": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																		"tenant": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"storage_network": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"cluster": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"node": {

																Type:     schema.TypeString,
																Optional: true,
															},

															"is_primary": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"not_primary": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"priority": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"untagged": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"vlan_id": {

																Type:     schema.TypeInt,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},

			"default_storage_config": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"sw": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"default_sw_version": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"volterra_software_version": {

							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"allow_all_usb": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"deny_all_usb": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"usb_policy": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"name": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"namespace": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"tenant": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"disable_vm": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"enable_vm": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{},
				},
			},

			"volterra_certified_hw": {
				Type:     schema.TypeString,
				Required: true,
			},

			"worker_nodes": {

				Type: schema.TypeList,

				Optional: true,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
		},
	}
}

// resourceVolterraVoltstackSiteCreate creates VoltstackSite resource
func resourceVolterraVoltstackSiteCreate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	createMeta := &ves_io_schema.ObjectCreateMetaType{}
	createSpec := &ves_io_schema_views_voltstack_site.CreateSpecType{}
	createReq := &ves_io_schema_views_voltstack_site.CreateRequest{
		Metadata: createMeta,
		Spec:     createSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		createMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		createMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		createMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		createMeta.Namespace =
			v.(string)
	}

	//address
	if v, ok := d.GetOk("address"); ok && !isIntfNil(v) {

		createSpec.Address =
			v.(string)

	}

	//blocked_services_choice

	blockedServicesChoiceTypeFound := false

	if v, ok := d.GetOk("blocked_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true
		blockedServicesChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_BlockedServices{}
		blockedServicesChoiceInt.BlockedServices = &ves_io_schema_fleet.BlockedServicesListType{}
		createSpec.BlockedServicesChoice = blockedServicesChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["blocked_sevice"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					blockedSevice := make([]*ves_io_schema_fleet.BlockedServices, len(sl))
					blockedServicesChoiceInt.BlockedServices.BlockedSevice = blockedSevice
					for i, set := range sl {
						if set != nil {
							blockedSevice[i] = &ves_io_schema_fleet.BlockedServices{}
							blockedSeviceMapStrToI := set.(map[string]interface{})

							blockedServicesValueTypeChoiceTypeFound := false

							if v, ok := blockedSeviceMapStrToI["dns"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

								blockedServicesValueTypeChoiceTypeFound = true

								if v.(bool) {
									blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Dns{}
									blockedServicesValueTypeChoiceInt.Dns = &ves_io_schema.Empty{}
									blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
								}

							}

							if v, ok := blockedSeviceMapStrToI["ssh"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

								blockedServicesValueTypeChoiceTypeFound = true

								if v.(bool) {
									blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Ssh{}
									blockedServicesValueTypeChoiceInt.Ssh = &ves_io_schema.Empty{}
									blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
								}

							}

							if v, ok := blockedSeviceMapStrToI["web_user_interface"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

								blockedServicesValueTypeChoiceTypeFound = true

								if v.(bool) {
									blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_WebUserInterface{}
									blockedServicesValueTypeChoiceInt.WebUserInterface = &ves_io_schema.Empty{}
									blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
								}

							}

							if v, ok := blockedSeviceMapStrToI["network_type"]; ok && !isIntfNil(v) {

								blockedSevice[i].NetworkType = ves_io_schema.VirtualNetworkType(ves_io_schema.VirtualNetworkType_value[v.(string)])

							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("default_blocked_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true

		if v.(bool) {
			blockedServicesChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_DefaultBlockedServices{}
			blockedServicesChoiceInt.DefaultBlockedServices = &ves_io_schema.Empty{}
			createSpec.BlockedServicesChoice = blockedServicesChoiceInt
		}

	}

	//bond_choice

	bondChoiceTypeFound := false

	if v, ok := d.GetOk("bond_device_list"); ok && !bondChoiceTypeFound {

		bondChoiceTypeFound = true
		bondChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_BondDeviceList{}
		bondChoiceInt.BondDeviceList = &ves_io_schema_fleet.FleetBondDevicesListType{}
		createSpec.BondChoice = bondChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["bond_devices"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					bondDevices := make([]*ves_io_schema_fleet.FleetBondDeviceType, len(sl))
					bondChoiceInt.BondDeviceList.BondDevices = bondDevices
					for i, set := range sl {
						if set != nil {
							bondDevices[i] = &ves_io_schema_fleet.FleetBondDeviceType{}
							bondDevicesMapStrToI := set.(map[string]interface{})

							if w, ok := bondDevicesMapStrToI["devices"]; ok && !isIntfNil(w) {
								ls := make([]string, len(w.([]interface{})))
								for i, v := range w.([]interface{}) {
									ls[i] = v.(string)
								}
								bondDevices[i].Devices = ls
							}

							lacpChoiceTypeFound := false

							if v, ok := bondDevicesMapStrToI["active_backup"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

								lacpChoiceTypeFound = true

								if v.(bool) {
									lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_ActiveBackup{}
									lacpChoiceInt.ActiveBackup = &ves_io_schema.Empty{}
									bondDevices[i].LacpChoice = lacpChoiceInt
								}

							}

							if v, ok := bondDevicesMapStrToI["lacp"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

								lacpChoiceTypeFound = true
								lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_Lacp{}
								lacpChoiceInt.Lacp = &ves_io_schema_fleet.BondLacpType{}
								bondDevices[i].LacpChoice = lacpChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["rate"]; ok && !isIntfNil(v) {

											lacpChoiceInt.Lacp.Rate = uint32(v.(int))

										}

									}
								}

							}

							if w, ok := bondDevicesMapStrToI["link_polling_interval"]; ok && !isIntfNil(w) {
								bondDevices[i].LinkPollingInterval = uint32(w.(int))
							}

							if w, ok := bondDevicesMapStrToI["link_up_delay"]; ok && !isIntfNil(w) {
								bondDevices[i].LinkUpDelay = uint32(w.(int))
							}

							if w, ok := bondDevicesMapStrToI["name"]; ok && !isIntfNil(w) {
								bondDevices[i].Name = w.(string)
							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("no_bond_devices"); ok && !bondChoiceTypeFound {

		bondChoiceTypeFound = true

		if v.(bool) {
			bondChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_NoBondDevices{}
			bondChoiceInt.NoBondDevices = &ves_io_schema.Empty{}
			createSpec.BondChoice = bondChoiceInt
		}

	}

	//coordinates
	if v, ok := d.GetOk("coordinates"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		coordinates := &ves_io_schema_site.Coordinates{}
		createSpec.Coordinates = coordinates
		for _, set := range sl {
			if set != nil {
				coordinatesMapStrToI := set.(map[string]interface{})

				if w, ok := coordinatesMapStrToI["latitude"]; ok && !isIntfNil(w) {
					coordinates.Latitude = float32(w.(float64))
				}

				if w, ok := coordinatesMapStrToI["longitude"]; ok && !isIntfNil(w) {
					coordinates.Longitude = float32(w.(float64))
				}

			}
		}

	}

	//custom_dns
	if v, ok := d.GetOk("custom_dns"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		customDns := &ves_io_schema_views.CustomDNS{}
		createSpec.CustomDns = customDns
		for _, set := range sl {
			if set != nil {
				customDnsMapStrToI := set.(map[string]interface{})

				if w, ok := customDnsMapStrToI["inside_nameserver"]; ok && !isIntfNil(w) {
					customDns.InsideNameserver = w.(string)
				}

				if w, ok := customDnsMapStrToI["inside_nameserver_v6"]; ok && !isIntfNil(w) {
					customDns.InsideNameserverV6 = w.(string)
				}

				if w, ok := customDnsMapStrToI["outside_nameserver"]; ok && !isIntfNil(w) {
					customDns.OutsideNameserver = w.(string)
				}

				if w, ok := customDnsMapStrToI["outside_nameserver_v6"]; ok && !isIntfNil(w) {
					customDns.OutsideNameserverV6 = w.(string)
				}

			}
		}

	}

	//gpu_choice

	gpuChoiceTypeFound := false

	if v, ok := d.GetOk("disable_gpu"); ok && !gpuChoiceTypeFound {

		gpuChoiceTypeFound = true

		if v.(bool) {
			gpuChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_DisableGpu{}
			gpuChoiceInt.DisableGpu = &ves_io_schema.Empty{}
			createSpec.GpuChoice = gpuChoiceInt
		}

	}

	if v, ok := d.GetOk("enable_gpu"); ok && !gpuChoiceTypeFound {

		gpuChoiceTypeFound = true

		if v.(bool) {
			gpuChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_EnableGpu{}
			gpuChoiceInt.EnableGpu = &ves_io_schema.Empty{}
			createSpec.GpuChoice = gpuChoiceInt
		}

	}

	if v, ok := d.GetOk("enable_vgpu"); ok && !gpuChoiceTypeFound {

		gpuChoiceTypeFound = true
		gpuChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_EnableVgpu{}
		gpuChoiceInt.EnableVgpu = &ves_io_schema_fleet.VGPUConfiguration{}
		createSpec.GpuChoice = gpuChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["feature_type"]; ok && !isIntfNil(v) {

					gpuChoiceInt.EnableVgpu.FeatureType = ves_io_schema_fleet.VGPUFeatureType(ves_io_schema_fleet.VGPUFeatureType_value[v.(string)])

				}

				if v, ok := cs["server_address"]; ok && !isIntfNil(v) {

					gpuChoiceInt.EnableVgpu.ServerAddress = v.(string)

				}

				if v, ok := cs["server_port"]; ok && !isIntfNil(v) {

					gpuChoiceInt.EnableVgpu.ServerPort = uint32(v.(int))

				}

			}
		}

	}

	//k8s_cluster_choice

	k8SClusterChoiceTypeFound := false

	if v, ok := d.GetOk("k8s_cluster"); ok && !k8SClusterChoiceTypeFound {

		k8SClusterChoiceTypeFound = true
		k8SClusterChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_K8SCluster{}
		k8SClusterChoiceInt.K8SCluster = &ves_io_schema_views.ObjectRefType{}
		createSpec.K8SClusterChoice = k8SClusterChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["name"]; ok && !isIntfNil(v) {

					k8SClusterChoiceInt.K8SCluster.Name = v.(string)

				}

				if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

					k8SClusterChoiceInt.K8SCluster.Namespace = v.(string)

				}

				if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

					k8SClusterChoiceInt.K8SCluster.Tenant = v.(string)

				}

			}
		}

	}

	if v, ok := d.GetOk("no_k8s_cluster"); ok && !k8SClusterChoiceTypeFound {

		k8SClusterChoiceTypeFound = true

		if v.(bool) {
			k8SClusterChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_NoK8SCluster{}
			k8SClusterChoiceInt.NoK8SCluster = &ves_io_schema.Empty{}
			createSpec.K8SClusterChoice = k8SClusterChoiceInt
		}

	}

	//kubernetes_upgrade_drain
	if v, ok := d.GetOk("kubernetes_upgrade_drain"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		kubernetesUpgradeDrain := &ves_io_schema_views.KubernetesUpgradeDrain{}
		createSpec.KubernetesUpgradeDrain = kubernetesUpgradeDrain
		for _, set := range sl {
			if set != nil {
				kubernetesUpgradeDrainMapStrToI := set.(map[string]interface{})

				kubernetesUpgradeDrainEnableChoiceTypeFound := false

				if v, ok := kubernetesUpgradeDrainMapStrToI["disable_upgrade_drain"]; ok && !isIntfNil(v) && !kubernetesUpgradeDrainEnableChoiceTypeFound {

					kubernetesUpgradeDrainEnableChoiceTypeFound = true

					if v.(bool) {
						kubernetesUpgradeDrainEnableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrain_DisableUpgradeDrain{}
						kubernetesUpgradeDrainEnableChoiceInt.DisableUpgradeDrain = &ves_io_schema.Empty{}
						kubernetesUpgradeDrain.KubernetesUpgradeDrainEnableChoice = kubernetesUpgradeDrainEnableChoiceInt
					}

				}

				if v, ok := kubernetesUpgradeDrainMapStrToI["enable_upgrade_drain"]; ok && !isIntfNil(v) && !kubernetesUpgradeDrainEnableChoiceTypeFound {

					kubernetesUpgradeDrainEnableChoiceTypeFound = true
					kubernetesUpgradeDrainEnableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrain_EnableUpgradeDrain{}
					kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain = &ves_io_schema_views.KubernetesUpgradeDrainConfig{}
					kubernetesUpgradeDrain.KubernetesUpgradeDrainEnableChoice = kubernetesUpgradeDrainEnableChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							drainMaxUnavailableChoiceTypeFound := false

							if v, ok := cs["drain_max_unavailable_node_count"]; ok && !isIntfNil(v) && !drainMaxUnavailableChoiceTypeFound {

								drainMaxUnavailableChoiceTypeFound = true
								drainMaxUnavailableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrainConfig_DrainMaxUnavailableNodeCount{}

								kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.DrainMaxUnavailableChoice = drainMaxUnavailableChoiceInt

								drainMaxUnavailableChoiceInt.DrainMaxUnavailableNodeCount = uint32(v.(int))

							}

							if v, ok := cs["drain_max_unavailable_node_percentage"]; ok && !isIntfNil(v) && !drainMaxUnavailableChoiceTypeFound {

								drainMaxUnavailableChoiceTypeFound = true
								drainMaxUnavailableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrainConfig_DrainMaxUnavailableNodePercentage{}

								kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.DrainMaxUnavailableChoice = drainMaxUnavailableChoiceInt

								drainMaxUnavailableChoiceInt.DrainMaxUnavailableNodePercentage = uint32(v.(int))

							}

							if v, ok := cs["drain_node_timeout"]; ok && !isIntfNil(v) {

								kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.DrainNodeTimeout = uint32(v.(int))

							}

							vegaUpgradeModeToggleChoiceTypeFound := false

							if v, ok := cs["disable_vega_upgrade_mode"]; ok && !isIntfNil(v) && !vegaUpgradeModeToggleChoiceTypeFound {

								vegaUpgradeModeToggleChoiceTypeFound = true

								if v.(bool) {
									vegaUpgradeModeToggleChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrainConfig_DisableVegaUpgradeMode{}
									vegaUpgradeModeToggleChoiceInt.DisableVegaUpgradeMode = &ves_io_schema.Empty{}
									kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.VegaUpgradeModeToggleChoice = vegaUpgradeModeToggleChoiceInt
								}

							}

							if v, ok := cs["enable_vega_upgrade_mode"]; ok && !isIntfNil(v) && !vegaUpgradeModeToggleChoiceTypeFound {

								vegaUpgradeModeToggleChoiceTypeFound = true

								if v.(bool) {
									vegaUpgradeModeToggleChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrainConfig_EnableVegaUpgradeMode{}
									vegaUpgradeModeToggleChoiceInt.EnableVegaUpgradeMode = &ves_io_schema.Empty{}
									kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.VegaUpgradeModeToggleChoice = vegaUpgradeModeToggleChoiceInt
								}

							}

						}
					}

				}

			}
		}

	}

	//local_control_plane_choice

	localControlPlaneChoiceTypeFound := false

	if v, ok := d.GetOk("local_control_plane"); ok && !localControlPlaneChoiceTypeFound {

		localControlPlaneChoiceTypeFound = true
		localControlPlaneChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_LocalControlPlane{}
		localControlPlaneChoiceInt.LocalControlPlane = &ves_io_schema_fleet.LocalControlPlaneType{}
		createSpec.LocalControlPlaneChoice = localControlPlaneChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["bgp_config"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					bgpConfig := &ves_io_schema_fleet.BGPConfiguration{}
					localControlPlaneChoiceInt.LocalControlPlane.BgpConfig = bgpConfig
					for _, set := range sl {
						if set != nil {
							bgpConfigMapStrToI := set.(map[string]interface{})

							if w, ok := bgpConfigMapStrToI["asn"]; ok && !isIntfNil(w) {
								bgpConfig.Asn = uint32(w.(int))
							}

							if v, ok := bgpConfigMapStrToI["peers"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								peers := make([]*ves_io_schema_bgp.Peer, len(sl))
								bgpConfig.Peers = peers
								for i, set := range sl {
									if set != nil {
										peers[i] = &ves_io_schema_bgp.Peer{}
										_ = set.(map[string]interface{})

									}
								}

							}

						}
					}

				}

				networkChoiceTypeFound := false

				if v, ok := cs["inside_vn"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

					networkChoiceTypeFound = true

					if v.(bool) {
						networkChoiceInt := &ves_io_schema_fleet.LocalControlPlaneType_InsideVn{}
						networkChoiceInt.InsideVn = &ves_io_schema.Empty{}
						localControlPlaneChoiceInt.LocalControlPlane.NetworkChoice = networkChoiceInt
					}

				}

				if v, ok := cs["outside_vn"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

					networkChoiceTypeFound = true

					if v.(bool) {
						networkChoiceInt := &ves_io_schema_fleet.LocalControlPlaneType_OutsideVn{}
						networkChoiceInt.OutsideVn = &ves_io_schema.Empty{}
						localControlPlaneChoiceInt.LocalControlPlane.NetworkChoice = networkChoiceInt
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("no_local_control_plane"); ok && !localControlPlaneChoiceTypeFound {

		localControlPlaneChoiceTypeFound = true

		if v.(bool) {
			localControlPlaneChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_NoLocalControlPlane{}
			localControlPlaneChoiceInt.NoLocalControlPlane = &ves_io_schema.Empty{}
			createSpec.LocalControlPlaneChoice = localControlPlaneChoiceInt
		}

	}

	//logs_receiver_choice

	logsReceiverChoiceTypeFound := false

	if v, ok := d.GetOk("log_receiver"); ok && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true
		logsReceiverChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_LogReceiver{}
		logsReceiverChoiceInt.LogReceiver = &ves_io_schema_views.ObjectRefType{}
		createSpec.LogsReceiverChoice = logsReceiverChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["name"]; ok && !isIntfNil(v) {

					logsReceiverChoiceInt.LogReceiver.Name = v.(string)

				}

				if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

					logsReceiverChoiceInt.LogReceiver.Namespace = v.(string)

				}

				if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

					logsReceiverChoiceInt.LogReceiver.Tenant = v.(string)

				}

			}
		}

	}

	if v, ok := d.GetOk("logs_streaming_disabled"); ok && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true

		if v.(bool) {
			logsReceiverChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_LogsStreamingDisabled{}
			logsReceiverChoiceInt.LogsStreamingDisabled = &ves_io_schema.Empty{}
			createSpec.LogsReceiverChoice = logsReceiverChoiceInt
		}

	}

	//master_node_configuration
	if v, ok := d.GetOk("master_node_configuration"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		masterNodeConfiguration := make([]*ves_io_schema_views.MasterNode, len(sl))
		createSpec.MasterNodeConfiguration = masterNodeConfiguration
		for i, set := range sl {
			if set != nil {
				masterNodeConfiguration[i] = &ves_io_schema_views.MasterNode{}
				masterNodeConfigurationMapStrToI := set.(map[string]interface{})

				if w, ok := masterNodeConfigurationMapStrToI["name"]; ok && !isIntfNil(w) {
					masterNodeConfiguration[i].Name = w.(string)
				}

				if w, ok := masterNodeConfigurationMapStrToI["public_ip"]; ok && !isIntfNil(w) {
					masterNodeConfiguration[i].PublicIp = w.(string)
				}

			}
		}

	}

	//master_nodes
	if v, ok := d.GetOk("master_nodes"); ok && !isIntfNil(v) {

		ls := make([]string, len(v.([]interface{})))
		for i, v := range v.([]interface{}) {
			ls[i] = v.(string)
		}
		createSpec.MasterNodes = ls

	}

	//network_cfg_choice

	networkCfgChoiceTypeFound := false

	if v, ok := d.GetOk("custom_network_config"); ok && !networkCfgChoiceTypeFound {

		networkCfgChoiceTypeFound = true
		networkCfgChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_CustomNetworkConfig{}
		networkCfgChoiceInt.CustomNetworkConfig = &ves_io_schema_views_voltstack_site.VssNetworkConfiguration{}
		createSpec.NetworkCfgChoice = networkCfgChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["bgp_peer_address"]; ok && !isIntfNil(v) {

					networkCfgChoiceInt.CustomNetworkConfig.BgpPeerAddress = v.(string)

				}

				if v, ok := cs["bgp_peer_address_v6"]; ok && !isIntfNil(v) {

					networkCfgChoiceInt.CustomNetworkConfig.BgpPeerAddressV6 = v.(string)

				}

				if v, ok := cs["bgp_router_id"]; ok && !isIntfNil(v) {

					networkCfgChoiceInt.CustomNetworkConfig.BgpRouterId = v.(string)

				}

				forwardProxyChoiceTypeFound := false

				if v, ok := cs["active_forward_proxy_policies"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true
					forwardProxyChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_ActiveForwardProxyPolicies{}
					forwardProxyChoiceInt.ActiveForwardProxyPolicies = &ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType{}
					networkCfgChoiceInt.CustomNetworkConfig.ForwardProxyChoice = forwardProxyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["forward_proxy_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								forwardProxyPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								forwardProxyChoiceInt.ActiveForwardProxyPolicies.ForwardProxyPolicies = forwardProxyPoliciesInt
								for i, ps := range sl {

									fppMapToStrVal := ps.(map[string]interface{})
									forwardProxyPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := fppMapToStrVal["name"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Name = v.(string)
									}

									if v, ok := fppMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := fppMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["forward_proxy_allow_all"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true

					if v.(bool) {
						forwardProxyChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_ForwardProxyAllowAll{}
						forwardProxyChoiceInt.ForwardProxyAllowAll = &ves_io_schema.Empty{}
						networkCfgChoiceInt.CustomNetworkConfig.ForwardProxyChoice = forwardProxyChoiceInt
					}

				}

				if v, ok := cs["no_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true

					if v.(bool) {
						forwardProxyChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_NoForwardProxy{}
						forwardProxyChoiceInt.NoForwardProxy = &ves_io_schema.Empty{}
						networkCfgChoiceInt.CustomNetworkConfig.ForwardProxyChoice = forwardProxyChoiceInt
					}

				}

				globalNetworkChoiceTypeFound := false

				if v, ok := cs["global_network_list"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

					globalNetworkChoiceTypeFound = true
					globalNetworkChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_GlobalNetworkList{}
					globalNetworkChoiceInt.GlobalNetworkList = &ves_io_schema_views.GlobalNetworkConnectionListType{}
					networkCfgChoiceInt.CustomNetworkConfig.GlobalNetworkChoice = globalNetworkChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["global_network_connections"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								globalNetworkConnections := make([]*ves_io_schema_views.GlobalNetworkConnectionType, len(sl))
								globalNetworkChoiceInt.GlobalNetworkList.GlobalNetworkConnections = globalNetworkConnections
								for i, set := range sl {
									if set != nil {
										globalNetworkConnections[i] = &ves_io_schema_views.GlobalNetworkConnectionType{}
										globalNetworkConnectionsMapStrToI := set.(map[string]interface{})

										connectionChoiceTypeFound := false

										if v, ok := globalNetworkConnectionsMapStrToI["sli_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

											connectionChoiceTypeFound = true
											connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SliToGlobalDr{}
											connectionChoiceInt.SliToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
											globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														globalVn := &ves_io_schema_views.ObjectRefType{}
														connectionChoiceInt.SliToGlobalDr.GlobalVn = globalVn
														for _, set := range sl {
															if set != nil {
																globalVnMapStrToI := set.(map[string]interface{})

																if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
																	globalVn.Name = w.(string)
																}

																if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
																	globalVn.Namespace = w.(string)
																}

																if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
																	globalVn.Tenant = w.(string)
																}

															}
														}

													}

												}
											}

										}

										if v, ok := globalNetworkConnectionsMapStrToI["slo_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

											connectionChoiceTypeFound = true
											connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SloToGlobalDr{}
											connectionChoiceInt.SloToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
											globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														globalVn := &ves_io_schema_views.ObjectRefType{}
														connectionChoiceInt.SloToGlobalDr.GlobalVn = globalVn
														for _, set := range sl {
															if set != nil {
																globalVnMapStrToI := set.(map[string]interface{})

																if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
																	globalVn.Name = w.(string)
																}

																if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
																	globalVn.Namespace = w.(string)
																}

																if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
																	globalVn.Tenant = w.(string)
																}

															}
														}

													}

												}
											}

										}

										forwardProxyChoiceTypeFound := false

										if v, ok := globalNetworkConnectionsMapStrToI["disable_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

											forwardProxyChoiceTypeFound = true

											if v.(bool) {
												forwardProxyChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_DisableForwardProxy{}
												forwardProxyChoiceInt.DisableForwardProxy = &ves_io_schema.Empty{}
												globalNetworkConnections[i].ForwardProxyChoice = forwardProxyChoiceInt
											}

										}

										if v, ok := globalNetworkConnectionsMapStrToI["enable_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

											forwardProxyChoiceTypeFound = true
											forwardProxyChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_EnableForwardProxy{}
											forwardProxyChoiceInt.EnableForwardProxy = &ves_io_schema.ForwardProxyConfigType{}
											globalNetworkConnections[i].ForwardProxyChoice = forwardProxyChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["connection_timeout"]; ok && !isIntfNil(v) {

														forwardProxyChoiceInt.EnableForwardProxy.ConnectionTimeout = uint32(v.(int))

													}

													if v, ok := cs["max_connect_attempts"]; ok && !isIntfNil(v) {

														forwardProxyChoiceInt.EnableForwardProxy.MaxConnectAttempts = uint32(v.(int))

													}

													tlsInterceptionChoiceTypeFound := false

													if v, ok := cs["no_interception"]; ok && !isIntfNil(v) && !tlsInterceptionChoiceTypeFound {

														tlsInterceptionChoiceTypeFound = true

														if v.(bool) {
															tlsInterceptionChoiceInt := &ves_io_schema.ForwardProxyConfigType_NoInterception{}
															tlsInterceptionChoiceInt.NoInterception = &ves_io_schema.Empty{}
															forwardProxyChoiceInt.EnableForwardProxy.TlsInterceptionChoice = tlsInterceptionChoiceInt
														}

													}

													if v, ok := cs["tls_intercept"]; ok && !isIntfNil(v) && !tlsInterceptionChoiceTypeFound {

														tlsInterceptionChoiceTypeFound = true
														tlsInterceptionChoiceInt := &ves_io_schema.ForwardProxyConfigType_TlsIntercept{}
														tlsInterceptionChoiceInt.TlsIntercept = &ves_io_schema.TlsInterceptionType{}
														forwardProxyChoiceInt.EnableForwardProxy.TlsInterceptionChoice = tlsInterceptionChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																interceptionPolicyChoiceTypeFound := false

																if v, ok := cs["enable_for_all_domains"]; ok && !isIntfNil(v) && !interceptionPolicyChoiceTypeFound {

																	interceptionPolicyChoiceTypeFound = true

																	if v.(bool) {
																		interceptionPolicyChoiceInt := &ves_io_schema.TlsInterceptionType_EnableForAllDomains{}
																		interceptionPolicyChoiceInt.EnableForAllDomains = &ves_io_schema.Empty{}
																		tlsInterceptionChoiceInt.TlsIntercept.InterceptionPolicyChoice = interceptionPolicyChoiceInt
																	}

																}

																if v, ok := cs["policy"]; ok && !isIntfNil(v) && !interceptionPolicyChoiceTypeFound {

																	interceptionPolicyChoiceTypeFound = true
																	interceptionPolicyChoiceInt := &ves_io_schema.TlsInterceptionType_Policy{}
																	interceptionPolicyChoiceInt.Policy = &ves_io_schema.TlsInterceptionPolicy{}
																	tlsInterceptionChoiceInt.TlsIntercept.InterceptionPolicyChoice = interceptionPolicyChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["interception_rules"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				interceptionRules := make([]*ves_io_schema.TlsInterceptionRule, len(sl))
																				interceptionPolicyChoiceInt.Policy.InterceptionRules = interceptionRules
																				for i, set := range sl {
																					if set != nil {
																						interceptionRules[i] = &ves_io_schema.TlsInterceptionRule{}
																						interceptionRulesMapStrToI := set.(map[string]interface{})

																						if v, ok := interceptionRulesMapStrToI["domain_match"]; ok && !isIntfNil(v) {

																							sl := v.([]interface{})
																							domainMatch := &ves_io_schema.DomainType{}
																							interceptionRules[i].DomainMatch = domainMatch
																							for _, set := range sl {
																								if set != nil {
																									domainMatchMapStrToI := set.(map[string]interface{})

																									domainChoiceTypeFound := false

																									if v, ok := domainMatchMapStrToI["exact_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																										domainChoiceTypeFound = true
																										domainChoiceInt := &ves_io_schema.DomainType_ExactValue{}

																										domainMatch.DomainChoice = domainChoiceInt

																										domainChoiceInt.ExactValue = v.(string)

																									}

																									if v, ok := domainMatchMapStrToI["regex_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																										domainChoiceTypeFound = true
																										domainChoiceInt := &ves_io_schema.DomainType_RegexValue{}

																										domainMatch.DomainChoice = domainChoiceInt

																										domainChoiceInt.RegexValue = v.(string)

																									}

																									if v, ok := domainMatchMapStrToI["suffix_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																										domainChoiceTypeFound = true
																										domainChoiceInt := &ves_io_schema.DomainType_SuffixValue{}

																										domainMatch.DomainChoice = domainChoiceInt

																										domainChoiceInt.SuffixValue = v.(string)

																									}

																								}
																							}

																						}

																						enableDisableChoiceTypeFound := false

																						if v, ok := interceptionRulesMapStrToI["disable_interception"]; ok && !isIntfNil(v) && !enableDisableChoiceTypeFound {

																							enableDisableChoiceTypeFound = true

																							if v.(bool) {
																								enableDisableChoiceInt := &ves_io_schema.TlsInterceptionRule_DisableInterception{}
																								enableDisableChoiceInt.DisableInterception = &ves_io_schema.Empty{}
																								interceptionRules[i].EnableDisableChoice = enableDisableChoiceInt
																							}

																						}

																						if v, ok := interceptionRulesMapStrToI["enable_interception"]; ok && !isIntfNil(v) && !enableDisableChoiceTypeFound {

																							enableDisableChoiceTypeFound = true

																							if v.(bool) {
																								enableDisableChoiceInt := &ves_io_schema.TlsInterceptionRule_EnableInterception{}
																								enableDisableChoiceInt.EnableInterception = &ves_io_schema.Empty{}
																								interceptionRules[i].EnableDisableChoice = enableDisableChoiceInt
																							}

																						}

																					}
																				}

																			}

																		}
																	}

																}

																signingCertChoiceTypeFound := false

																if v, ok := cs["custom_certificate"]; ok && !isIntfNil(v) && !signingCertChoiceTypeFound {

																	signingCertChoiceTypeFound = true
																	signingCertChoiceInt := &ves_io_schema.TlsInterceptionType_CustomCertificate{}
																	signingCertChoiceInt.CustomCertificate = &ves_io_schema.TlsCertificateType{}
																	tlsInterceptionChoiceInt.TlsIntercept.SigningCertChoice = signingCertChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["certificate_url"]; ok && !isIntfNil(v) {

																				signingCertChoiceInt.CustomCertificate.CertificateUrl = v.(string)

																			}

																			if v, ok := cs["description"]; ok && !isIntfNil(v) {

																				signingCertChoiceInt.CustomCertificate.Description = v.(string)

																			}

																			ocspStaplingChoiceTypeFound := false

																			if v, ok := cs["custom_hash_algorithms"]; ok && !isIntfNil(v) && !ocspStaplingChoiceTypeFound {

																				ocspStaplingChoiceTypeFound = true
																				ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_CustomHashAlgorithms{}
																				ocspStaplingChoiceInt.CustomHashAlgorithms = &ves_io_schema.HashAlgorithms{}
																				signingCertChoiceInt.CustomCertificate.OcspStaplingChoice = ocspStaplingChoiceInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["hash_algorithms"]; ok && !isIntfNil(v) {

																							hash_algorithmsList := []ves_io_schema.HashAlgorithm{}
																							for _, j := range v.([]interface{}) {
																								hash_algorithmsList = append(hash_algorithmsList, ves_io_schema.HashAlgorithm(ves_io_schema.HashAlgorithm_value[j.(string)]))
																							}
																							ocspStaplingChoiceInt.CustomHashAlgorithms.HashAlgorithms = hash_algorithmsList

																						}

																					}
																				}

																			}

																			if _, ok := cs["disable_ocsp_stapling"]; ok && !ocspStaplingChoiceTypeFound {

																				ocspStaplingChoiceTypeFound = true
																				ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_DisableOcspStapling{}
																				ocspStaplingChoiceInt.DisableOcspStapling = &ves_io_schema.Empty{}
																				signingCertChoiceInt.CustomCertificate.OcspStaplingChoice = ocspStaplingChoiceInt

																			}

																			if _, ok := cs["use_system_defaults"]; ok && !ocspStaplingChoiceTypeFound {

																				ocspStaplingChoiceTypeFound = true
																				ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_UseSystemDefaults{}
																				ocspStaplingChoiceInt.UseSystemDefaults = &ves_io_schema.Empty{}
																				signingCertChoiceInt.CustomCertificate.OcspStaplingChoice = ocspStaplingChoiceInt

																			}

																			if v, ok := cs["private_key"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				privateKey := &ves_io_schema.SecretType{}
																				signingCertChoiceInt.CustomCertificate.PrivateKey = privateKey
																				for _, set := range sl {
																					if set != nil {
																						privateKeyMapStrToI := set.(map[string]interface{})

																						if v, ok := privateKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																							sl := v.([]interface{})
																							blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																							privateKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																							for _, set := range sl {
																								if set != nil {
																									blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																									if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																										blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																									}

																									if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																										blindfoldSecretInfoInternal.Location = w.(string)
																									}

																									if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																										blindfoldSecretInfoInternal.StoreProvider = w.(string)
																									}

																								}
																							}

																						}

																						if v, ok := privateKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																							privateKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																						}

																						secretInfoOneofTypeFound := false

																						if v, ok := privateKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																							secretInfoOneofTypeFound = true
																							secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																							secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																							privateKey.SecretInfoOneof = secretInfoOneofInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																									}

																									if v, ok := cs["location"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																									}

																									if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																									}

																								}
																							}

																						}

																						if v, ok := privateKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																							secretInfoOneofTypeFound = true
																							secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																							secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																							privateKey.SecretInfoOneof = secretInfoOneofInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																									}

																									if v, ok := cs["url"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																									}

																								}
																							}

																						}

																						if v, ok := privateKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																							secretInfoOneofTypeFound = true
																							secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																							secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																							privateKey.SecretInfoOneof = secretInfoOneofInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["key"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																									}

																									if v, ok := cs["location"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																									}

																									if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																									}

																									if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																									}

																									if v, ok := cs["version"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																									}

																								}
																							}

																						}

																						if v, ok := privateKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																							secretInfoOneofTypeFound = true
																							secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																							secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																							privateKey.SecretInfoOneof = secretInfoOneofInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["name"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																									}

																								}
																							}

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["volterra_certificate"]; ok && !isIntfNil(v) && !signingCertChoiceTypeFound {

																	signingCertChoiceTypeFound = true

																	if v.(bool) {
																		signingCertChoiceInt := &ves_io_schema.TlsInterceptionType_VolterraCertificate{}
																		signingCertChoiceInt.VolterraCertificate = &ves_io_schema.Empty{}
																		tlsInterceptionChoiceInt.TlsIntercept.SigningCertChoice = signingCertChoiceInt
																	}

																}

																trustedCaChoiceTypeFound := false

																if v, ok := cs["trusted_ca_url"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

																	trustedCaChoiceTypeFound = true
																	trustedCaChoiceInt := &ves_io_schema.TlsInterceptionType_TrustedCaUrl{}

																	tlsInterceptionChoiceInt.TlsIntercept.TrustedCaChoice = trustedCaChoiceInt

																	trustedCaChoiceInt.TrustedCaUrl = v.(string)

																}

																if v, ok := cs["volterra_trusted_ca"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

																	trustedCaChoiceTypeFound = true

																	if v.(bool) {
																		trustedCaChoiceInt := &ves_io_schema.TlsInterceptionType_VolterraTrustedCa{}
																		trustedCaChoiceInt.VolterraTrustedCa = &ves_io_schema.Empty{}
																		tlsInterceptionChoiceInt.TlsIntercept.TrustedCaChoice = trustedCaChoiceInt
																	}

																}

															}
														}

													}

													if v, ok := cs["white_listed_ports"]; ok && !isIntfNil(v) {

														ls := make([]uint32, len(v.([]interface{})))
														for i, v := range v.([]interface{}) {
															ls[i] = uint32(v.(int))
														}
														forwardProxyChoiceInt.EnableForwardProxy.WhiteListedPorts = ls

													}

													if v, ok := cs["white_listed_prefixes"]; ok && !isIntfNil(v) {

														ls := make([]string, len(v.([]interface{})))
														for i, v := range v.([]interface{}) {
															ls[i] = v.(string)
														}
														forwardProxyChoiceInt.EnableForwardProxy.WhiteListedPrefixes = ls

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["no_global_network"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

					globalNetworkChoiceTypeFound = true

					if v.(bool) {
						globalNetworkChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_NoGlobalNetwork{}
						globalNetworkChoiceInt.NoGlobalNetwork = &ves_io_schema.Empty{}
						networkCfgChoiceInt.CustomNetworkConfig.GlobalNetworkChoice = globalNetworkChoiceInt
					}

				}

				interfaceChoiceTypeFound := false

				if v, ok := cs["default_interface_config"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

					interfaceChoiceTypeFound = true

					if v.(bool) {
						interfaceChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_DefaultInterfaceConfig{}
						interfaceChoiceInt.DefaultInterfaceConfig = &ves_io_schema.Empty{}
						networkCfgChoiceInt.CustomNetworkConfig.InterfaceChoice = interfaceChoiceInt
					}

				}

				if v, ok := cs["interface_list"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

					interfaceChoiceTypeFound = true
					interfaceChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_InterfaceList{}
					interfaceChoiceInt.InterfaceList = &ves_io_schema_views_voltstack_site.InterfaceListType{}
					networkCfgChoiceInt.CustomNetworkConfig.InterfaceChoice = interfaceChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["interfaces"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								interfaces := make([]*ves_io_schema_views_voltstack_site.Interface, len(sl))
								interfaceChoiceInt.InterfaceList.Interfaces = interfaces
								for i, set := range sl {
									if set != nil {
										interfaces[i] = &ves_io_schema_views_voltstack_site.Interface{}
										interfacesMapStrToI := set.(map[string]interface{})

										dcClusterGroupConnectivityInterfaceChoiceTypeFound := false

										if v, ok := interfacesMapStrToI["dc_cluster_group_connectivity_interface_disabled"]; ok && !isIntfNil(v) && !dcClusterGroupConnectivityInterfaceChoiceTypeFound {

											dcClusterGroupConnectivityInterfaceChoiceTypeFound = true

											if v.(bool) {
												dcClusterGroupConnectivityInterfaceChoiceInt := &ves_io_schema_views_voltstack_site.Interface_DcClusterGroupConnectivityInterfaceDisabled{}
												dcClusterGroupConnectivityInterfaceChoiceInt.DcClusterGroupConnectivityInterfaceDisabled = &ves_io_schema.Empty{}
												interfaces[i].DcClusterGroupConnectivityInterfaceChoice = dcClusterGroupConnectivityInterfaceChoiceInt
											}

										}

										if v, ok := interfacesMapStrToI["dc_cluster_group_connectivity_interface_enabled"]; ok && !isIntfNil(v) && !dcClusterGroupConnectivityInterfaceChoiceTypeFound {

											dcClusterGroupConnectivityInterfaceChoiceTypeFound = true

											if v.(bool) {
												dcClusterGroupConnectivityInterfaceChoiceInt := &ves_io_schema_views_voltstack_site.Interface_DcClusterGroupConnectivityInterfaceEnabled{}
												dcClusterGroupConnectivityInterfaceChoiceInt.DcClusterGroupConnectivityInterfaceEnabled = &ves_io_schema.Empty{}
												interfaces[i].DcClusterGroupConnectivityInterfaceChoice = dcClusterGroupConnectivityInterfaceChoiceInt
											}

										}

										if w, ok := interfacesMapStrToI["description"]; ok && !isIntfNil(w) {
											interfaces[i].Description = w.(string)
										}

										interfaceChoiceTypeFound := false

										if v, ok := interfacesMapStrToI["dedicated_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

											interfaceChoiceTypeFound = true
											interfaceChoiceInt := &ves_io_schema_views_voltstack_site.Interface_DedicatedInterface{}
											interfaceChoiceInt.DedicatedInterface = &ves_io_schema_network_interface.DedicatedInterfaceType{}
											interfaces[i].InterfaceChoice = interfaceChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["device"]; ok && !isIntfNil(v) {

														interfaceChoiceInt.DedicatedInterface.Device = v.(string)

													}

													monitoringChoiceTypeFound := false

													if _, ok := cs["monitor"]; ok && !monitoringChoiceTypeFound {

														monitoringChoiceTypeFound = true
														monitoringChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_Monitor{}
														monitoringChoiceInt.Monitor = &ves_io_schema_network_interface.LinkQualityMonitorConfig{}
														interfaceChoiceInt.DedicatedInterface.MonitoringChoice = monitoringChoiceInt

													}

													if v, ok := cs["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

														monitoringChoiceTypeFound = true

														if v.(bool) {
															monitoringChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_MonitorDisabled{}
															monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
															interfaceChoiceInt.DedicatedInterface.MonitoringChoice = monitoringChoiceInt
														}

													}

													if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

														interfaceChoiceInt.DedicatedInterface.Mtu = uint32(v.(int))

													}

													nodeChoiceTypeFound := false

													if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

														nodeChoiceTypeFound = true

														if v.(bool) {
															nodeChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_Cluster{}
															nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
															interfaceChoiceInt.DedicatedInterface.NodeChoice = nodeChoiceInt
														}

													}

													if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

														nodeChoiceTypeFound = true
														nodeChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_Node{}

														interfaceChoiceInt.DedicatedInterface.NodeChoice = nodeChoiceInt

														nodeChoiceInt.Node = v.(string)

													}

													primaryChoiceTypeFound := false

													if v, ok := cs["is_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

														primaryChoiceTypeFound = true

														if v.(bool) {
															primaryChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_IsPrimary{}
															primaryChoiceInt.IsPrimary = &ves_io_schema.Empty{}
															interfaceChoiceInt.DedicatedInterface.PrimaryChoice = primaryChoiceInt
														}

													}

													if v, ok := cs["not_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

														primaryChoiceTypeFound = true

														if v.(bool) {
															primaryChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_NotPrimary{}
															primaryChoiceInt.NotPrimary = &ves_io_schema.Empty{}
															interfaceChoiceInt.DedicatedInterface.PrimaryChoice = primaryChoiceInt
														}

													}

													if v, ok := cs["priority"]; ok && !isIntfNil(v) {

														interfaceChoiceInt.DedicatedInterface.Priority = uint32(v.(int))

													}

												}
											}

										}

										if v, ok := interfacesMapStrToI["dedicated_management_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

											interfaceChoiceTypeFound = true
											interfaceChoiceInt := &ves_io_schema_views_voltstack_site.Interface_DedicatedManagementInterface{}
											interfaceChoiceInt.DedicatedManagementInterface = &ves_io_schema_network_interface.DedicatedManagementInterfaceType{}
											interfaces[i].InterfaceChoice = interfaceChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["device"]; ok && !isIntfNil(v) {

														interfaceChoiceInt.DedicatedManagementInterface.Device = v.(string)

													}

													if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

														interfaceChoiceInt.DedicatedManagementInterface.Mtu = uint32(v.(int))

													}

													nodeChoiceTypeFound := false

													if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

														nodeChoiceTypeFound = true

														if v.(bool) {
															nodeChoiceInt := &ves_io_schema_network_interface.DedicatedManagementInterfaceType_Cluster{}
															nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
															interfaceChoiceInt.DedicatedManagementInterface.NodeChoice = nodeChoiceInt
														}

													}

													if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

														nodeChoiceTypeFound = true
														nodeChoiceInt := &ves_io_schema_network_interface.DedicatedManagementInterfaceType_Node{}

														interfaceChoiceInt.DedicatedManagementInterface.NodeChoice = nodeChoiceInt

														nodeChoiceInt.Node = v.(string)

													}

												}
											}

										}

										if v, ok := interfacesMapStrToI["ethernet_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

											interfaceChoiceTypeFound = true
											interfaceChoiceInt := &ves_io_schema_views_voltstack_site.Interface_EthernetInterface{}
											interfaceChoiceInt.EthernetInterface = &ves_io_schema_network_interface.EthernetInterfaceType{}
											interfaces[i].InterfaceChoice = interfaceChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													addressChoiceTypeFound := false

													if v, ok := cs["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true

														if v.(bool) {
															addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_DhcpClient{}
															addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
															interfaceChoiceInt.EthernetInterface.AddressChoice = addressChoiceInt
														}

													}

													if v, ok := cs["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_DhcpServer{}
														addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
														interfaceChoiceInt.EthernetInterface.AddressChoice = addressChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
																	addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
																	for i, set := range sl {
																		if set != nil {
																			dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
																			dhcpNetworksMapStrToI := set.(map[string]interface{})

																			dnsChoiceTypeFound := false

																			if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																				dnsChoiceTypeFound = true
																				dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

																				dhcpNetworks[i].DnsChoice = dnsChoiceInt

																				dnsChoiceInt.DnsAddress = v.(string)

																			}

																			if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																				dnsChoiceTypeFound = true

																				if v.(bool) {
																					dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
																					dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
																					dhcpNetworks[i].DnsChoice = dnsChoiceInt
																				}

																			}

																			gatewayChoiceTypeFound := false

																			if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

																				gatewayChoiceTypeFound = true
																				gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

																				dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

																				gatewayChoiceInt.DgwAddress = v.(string)

																			}

																			if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

																				gatewayChoiceTypeFound = true

																				if v.(bool) {
																					gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
																					gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																					dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
																				}

																			}

																			if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

																				gatewayChoiceTypeFound = true

																				if v.(bool) {
																					gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
																					gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
																					dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
																				}

																			}

																			networkPrefixChoiceTypeFound := false

																			if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																				networkPrefixChoiceTypeFound = true
																				networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

																				dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																				networkPrefixChoiceInt.NetworkPrefix = v.(string)

																			}

																			if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																				networkPrefixChoiceTypeFound = true
																				networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
																				networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																				dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["name"]; ok && !isIntfNil(v) {

																							networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																						}

																						if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																							networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																						}

																						if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																							networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

																				dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

																			}

																			if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
																				dhcpNetworks[i].Pools = pools
																				for i, set := range sl {
																					if set != nil {
																						pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
																						poolsMapStrToI := set.(map[string]interface{})

																						if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																							pools[i].EndIp = w.(string)
																						}

																						if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																							pools[i].Exclude = w.(bool)
																						}

																						if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																							pools[i].StartIp = w.(string)
																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

																	addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

																}

																if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																	ms := map[string]string{}
																	for k, v := range v.(map[string]interface{}) {
																		ms[k] = v.(string)
																	}
																	addressChoiceInt.DhcpServer.FixedIpMap = ms
																}

																interfacesAddressingChoiceTypeFound := false

																if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																	interfacesAddressingChoiceTypeFound = true

																	if v.(bool) {
																		interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
																		interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																		addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																	}

																}

																if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																	interfacesAddressingChoiceTypeFound = true

																	if v.(bool) {
																		interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
																		interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																		addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																	}

																}

																if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																	interfacesAddressingChoiceTypeFound = true
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
																	interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
																	addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																				ms := map[string]string{}
																				for k, v := range v.(map[string]interface{}) {
																					ms[k] = v.(string)
																				}
																				interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := cs["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StaticIp{}
														addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIPParametersType{}
														interfaceChoiceInt.EthernetInterface.AddressChoice = addressChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																networkPrefixChoiceTypeFound := false

																if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
																	networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
																	addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
																				networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
																				for _, set := range sl {
																					if set != nil {
																						interfaceIpMapMapStrToI := set.(map[string]interface{})
																						key, ok := interfaceIpMapMapStrToI["name"]
																						if ok && !isIntfNil(key) {
																							interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																							val, _ := interfaceIpMapMapStrToI["value"]

																							interfaceIpMapVals := val.([]interface{})
																							for _, intVal := range interfaceIpMapVals {
																								if intVal != nil {

																									interfaceIpMapStaticMap := intVal.(map[string]interface{})

																									if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DefaultGw = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DnsServer = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].IpAddress = w.(string)
																									}

																									// break after one loop
																									break
																								}
																							}
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
																	networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
																	addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
																				networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

																				for _, set := range sl {
																					if set != nil {
																						npaMapToStrVal := set.(map[string]interface{})
																						if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Name = val.(string)
																						}
																						if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Namespace = val.(string)
																						}

																						if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Tenant = val.(string)
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
																	networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																	addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := cs["device"]; ok && !isIntfNil(v) {

														interfaceChoiceInt.EthernetInterface.Device = v.(string)

													}

													ipv6AddressChoiceTypeFound := false

													if v, ok := cs["ipv6_auto_config"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

														ipv6AddressChoiceTypeFound = true
														ipv6AddressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Ipv6AutoConfig{}
														ipv6AddressChoiceInt.Ipv6AutoConfig = &ves_io_schema_network_interface.IPV6AutoConfigType{}
														interfaceChoiceInt.EthernetInterface.Ipv6AddressChoice = ipv6AddressChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																autoconfigChoiceTypeFound := false

																if v, ok := cs["host"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

																	autoconfigChoiceTypeFound = true

																	if v.(bool) {
																		autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Host{}
																		autoconfigChoiceInt.Host = &ves_io_schema.Empty{}
																		ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt
																	}

																}

																if v, ok := cs["router"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

																	autoconfigChoiceTypeFound = true
																	autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Router{}
																	autoconfigChoiceInt.Router = &ves_io_schema_network_interface.IPV6AutoConfigRouterType{}
																	ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			addressChoiceTypeFound := false

																			if v, ok := cs["network_prefix"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

																				addressChoiceTypeFound = true
																				addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_NetworkPrefix{}

																				autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

																				addressChoiceInt.NetworkPrefix = v.(string)

																			}

																			if v, ok := cs["stateful"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

																				addressChoiceTypeFound = true
																				addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_Stateful{}
																				addressChoiceInt.Stateful = &ves_io_schema_network_interface.DHCPIPV6StatefulServer{}
																				autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																							sl := v.([]interface{})
																							dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPIPV6NetworkType, len(sl))
																							addressChoiceInt.Stateful.DhcpNetworks = dhcpNetworks
																							for i, set := range sl {
																								if set != nil {
																									dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPIPV6NetworkType{}
																									dhcpNetworksMapStrToI := set.(map[string]interface{})

																									networkPrefixChoiceTypeFound := false

																									if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																										networkPrefixChoiceTypeFound = true
																										networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefix{}

																										dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																										networkPrefixChoiceInt.NetworkPrefix = v.(string)

																									}

																									if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																										networkPrefixChoiceTypeFound = true
																										networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefixAllocator{}
																										networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																										dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																										sl := v.([]interface{})
																										for _, set := range sl {
																											if set != nil {
																												cs := set.(map[string]interface{})

																												if v, ok := cs["name"]; ok && !isIntfNil(v) {

																													networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																												}

																												if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																													networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																												}

																												if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																													networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																												}

																											}
																										}

																									}

																									if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

																										dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

																									}

																									if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																										sl := v.([]interface{})
																										pools := make([]*ves_io_schema_network_interface.DHCPIPV6PoolType, len(sl))
																										dhcpNetworks[i].Pools = pools
																										for i, set := range sl {
																											if set != nil {
																												pools[i] = &ves_io_schema_network_interface.DHCPIPV6PoolType{}
																												poolsMapStrToI := set.(map[string]interface{})

																												if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																													pools[i].EndIp = w.(string)
																												}

																												if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																													pools[i].Exclude = w.(bool)
																												}

																												if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																													pools[i].StartIp = w.(string)
																												}

																											}
																										}

																									}

																								}
																							}

																						}

																						if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																							ms := map[string]string{}
																							for k, v := range v.(map[string]interface{}) {
																								ms[k] = v.(string)
																							}
																							addressChoiceInt.Stateful.FixedIpMap = ms
																						}

																						interfacesAddressingChoiceTypeFound := false

																						if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																							interfacesAddressingChoiceTypeFound = true

																							if v.(bool) {
																								interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromEnd{}
																								interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																								addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																							}

																						}

																						if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																							interfacesAddressingChoiceTypeFound = true

																							if v.(bool) {
																								interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromStart{}
																								interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																								addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																							}

																						}

																						if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																							interfacesAddressingChoiceTypeFound = true
																							interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_InterfaceIpMap{}
																							interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPV6Type{}
																							addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																										ms := map[string]string{}
																										for k, v := range v.(map[string]interface{}) {
																											ms[k] = v.(string)
																										}
																										interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																									}

																								}
																							}

																						}

																					}
																				}

																			}

																			if v, ok := cs["dns_config"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				dnsConfig := &ves_io_schema_network_interface.IPV6DnsConfig{}
																				autoconfigChoiceInt.Router.DnsConfig = dnsConfig
																				for _, set := range sl {
																					if set != nil {
																						dnsConfigMapStrToI := set.(map[string]interface{})

																						dnsChoiceTypeFound := false

																						if v, ok := dnsConfigMapStrToI["configured_list"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																							dnsChoiceTypeFound = true
																							dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_ConfiguredList{}
																							dnsChoiceInt.ConfiguredList = &ves_io_schema_network_interface.IPV6DnsList{}
																							dnsConfig.DnsChoice = dnsChoiceInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["dns_list"]; ok && !isIntfNil(v) {

																										ls := make([]string, len(v.([]interface{})))
																										for i, v := range v.([]interface{}) {
																											ls[i] = v.(string)
																										}
																										dnsChoiceInt.ConfiguredList.DnsList = ls

																									}

																								}
																							}

																						}

																						if v, ok := dnsConfigMapStrToI["local_dns"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																							dnsChoiceTypeFound = true
																							dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_LocalDns{}
																							dnsChoiceInt.LocalDns = &ves_io_schema_network_interface.IPV6LocalDnsAddress{}
																							dnsConfig.DnsChoice = dnsChoiceInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									localDnsChoiceTypeFound := false

																									if v, ok := cs["configured_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																										localDnsChoiceTypeFound = true
																										localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_ConfiguredAddress{}

																										dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt

																										localDnsChoiceInt.ConfiguredAddress = v.(string)

																									}

																									if v, ok := cs["first_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																										localDnsChoiceTypeFound = true

																										if v.(bool) {
																											localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_FirstAddress{}
																											localDnsChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																											dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																										}

																									}

																									if v, ok := cs["last_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																										localDnsChoiceTypeFound = true

																										if v.(bool) {
																											localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_LastAddress{}
																											localDnsChoiceInt.LastAddress = &ves_io_schema.Empty{}
																											dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																										}

																									}

																								}
																							}

																						}

																					}
																				}

																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := cs["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

														ipv6AddressChoiceTypeFound = true

														if v.(bool) {
															ipv6AddressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_NoIpv6Address{}
															ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
															interfaceChoiceInt.EthernetInterface.Ipv6AddressChoice = ipv6AddressChoiceInt
														}

													}

													if v, ok := cs["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

														ipv6AddressChoiceTypeFound = true
														ipv6AddressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StaticIpv6Address{}
														ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
														interfaceChoiceInt.EthernetInterface.Ipv6AddressChoice = ipv6AddressChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																networkPrefixChoiceTypeFound := false

																if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
																	networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
																	ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
																				networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
																				for _, set := range sl {
																					if set != nil {
																						interfaceIpMapMapStrToI := set.(map[string]interface{})
																						key, ok := interfaceIpMapMapStrToI["name"]
																						if ok && !isIntfNil(key) {
																							interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																							val, _ := interfaceIpMapMapStrToI["value"]

																							interfaceIpMapVals := val.([]interface{})
																							for _, intVal := range interfaceIpMapVals {
																								if intVal != nil {

																									interfaceIpMapStaticMap := intVal.(map[string]interface{})

																									if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DefaultGw = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DnsServer = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].IpAddress = w.(string)
																									}

																									// break after one loop
																									break
																								}
																							}
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
																	networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
																	ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
																				networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

																				for _, set := range sl {
																					if set != nil {
																						npaMapToStrVal := set.(map[string]interface{})
																						if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Name = val.(string)
																						}
																						if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Namespace = val.(string)
																						}

																						if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Tenant = val.(string)
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
																	networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																	ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

													monitoringChoiceTypeFound := false

													if _, ok := cs["monitor"]; ok && !monitoringChoiceTypeFound {

														monitoringChoiceTypeFound = true
														monitoringChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Monitor{}
														monitoringChoiceInt.Monitor = &ves_io_schema_network_interface.LinkQualityMonitorConfig{}
														interfaceChoiceInt.EthernetInterface.MonitoringChoice = monitoringChoiceInt

													}

													if v, ok := cs["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

														monitoringChoiceTypeFound = true

														if v.(bool) {
															monitoringChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_MonitorDisabled{}
															monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
															interfaceChoiceInt.EthernetInterface.MonitoringChoice = monitoringChoiceInt
														}

													}

													if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

														interfaceChoiceInt.EthernetInterface.Mtu = uint32(v.(int))

													}

													networkChoiceTypeFound := false

													if v, ok := cs["inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true
														networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_InsideNetwork{}
														networkChoiceInt.InsideNetwork = &ves_io_schema_views.ObjectRefType{}
														interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	networkChoiceInt.InsideNetwork.Name = v.(string)

																}

																if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																	networkChoiceInt.InsideNetwork.Namespace = v.(string)

																}

																if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																	networkChoiceInt.InsideNetwork.Tenant = v.(string)

																}

															}
														}

													}

													if v, ok := cs["ip_fabric_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true

														if v.(bool) {
															networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_IpFabricNetwork{}
															networkChoiceInt.IpFabricNetwork = &ves_io_schema.Empty{}
															interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
														}

													}

													if v, ok := cs["segment_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true
														networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SegmentNetwork{}
														networkChoiceInt.SegmentNetwork = &ves_io_schema_views.ObjectRefType{}
														interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	networkChoiceInt.SegmentNetwork.Name = v.(string)

																}

																if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																	networkChoiceInt.SegmentNetwork.Namespace = v.(string)

																}

																if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																	networkChoiceInt.SegmentNetwork.Tenant = v.(string)

																}

															}
														}

													}

													if v, ok := cs["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true

														if v.(bool) {
															networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SiteLocalInsideNetwork{}
															networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
															interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
														}

													}

													if v, ok := cs["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true

														if v.(bool) {
															networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SiteLocalNetwork{}
															networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
															interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
														}

													}

													if v, ok := cs["srv6_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true
														networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Srv6Network{}
														networkChoiceInt.Srv6Network = &ves_io_schema_views.ObjectRefType{}
														interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	networkChoiceInt.Srv6Network.Name = v.(string)

																}

																if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																	networkChoiceInt.Srv6Network.Namespace = v.(string)

																}

																if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																	networkChoiceInt.Srv6Network.Tenant = v.(string)

																}

															}
														}

													}

													if v, ok := cs["storage_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true

														if v.(bool) {
															networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StorageNetwork{}
															networkChoiceInt.StorageNetwork = &ves_io_schema.Empty{}
															interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
														}

													}

													nodeChoiceTypeFound := false

													if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

														nodeChoiceTypeFound = true

														if v.(bool) {
															nodeChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Cluster{}
															nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
															interfaceChoiceInt.EthernetInterface.NodeChoice = nodeChoiceInt
														}

													}

													if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

														nodeChoiceTypeFound = true
														nodeChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Node{}

														interfaceChoiceInt.EthernetInterface.NodeChoice = nodeChoiceInt

														nodeChoiceInt.Node = v.(string)

													}

													primaryChoiceTypeFound := false

													if v, ok := cs["is_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

														primaryChoiceTypeFound = true

														if v.(bool) {
															primaryChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_IsPrimary{}
															primaryChoiceInt.IsPrimary = &ves_io_schema.Empty{}
															interfaceChoiceInt.EthernetInterface.PrimaryChoice = primaryChoiceInt
														}

													}

													if v, ok := cs["not_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

														primaryChoiceTypeFound = true

														if v.(bool) {
															primaryChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_NotPrimary{}
															primaryChoiceInt.NotPrimary = &ves_io_schema.Empty{}
															interfaceChoiceInt.EthernetInterface.PrimaryChoice = primaryChoiceInt
														}

													}

													if v, ok := cs["priority"]; ok && !isIntfNil(v) {

														interfaceChoiceInt.EthernetInterface.Priority = uint32(v.(int))

													}

													vlanChoiceTypeFound := false

													if v, ok := cs["untagged"]; ok && !isIntfNil(v) && !vlanChoiceTypeFound {

														vlanChoiceTypeFound = true

														if v.(bool) {
															vlanChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Untagged{}
															vlanChoiceInt.Untagged = &ves_io_schema.Empty{}
															interfaceChoiceInt.EthernetInterface.VlanChoice = vlanChoiceInt
														}

													}

													if v, ok := cs["vlan_id"]; ok && !isIntfNil(v) && !vlanChoiceTypeFound {

														vlanChoiceTypeFound = true
														vlanChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_VlanId{}

														interfaceChoiceInt.EthernetInterface.VlanChoice = vlanChoiceInt

														vlanChoiceInt.VlanId = uint32(v.(int))

													}

												}
											}

										}

										if v, ok := interfacesMapStrToI["loopback_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

											interfaceChoiceTypeFound = true
											interfaceChoiceInt := &ves_io_schema_views_voltstack_site.Interface_LoopbackInterface{}
											interfaceChoiceInt.LoopbackInterface = &ves_io_schema_network_interface.LoopbackInterfaceType{}
											interfaces[i].InterfaceChoice = interfaceChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													addressChoiceTypeFound := false

													if v, ok := cs["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true

														if v.(bool) {
															addressChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_DhcpClient{}
															addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
															interfaceChoiceInt.LoopbackInterface.AddressChoice = addressChoiceInt
														}

													}

													if v, ok := cs["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_DhcpServer{}
														addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
														interfaceChoiceInt.LoopbackInterface.AddressChoice = addressChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
																	addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
																	for i, set := range sl {
																		if set != nil {
																			dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
																			dhcpNetworksMapStrToI := set.(map[string]interface{})

																			dnsChoiceTypeFound := false

																			if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																				dnsChoiceTypeFound = true
																				dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

																				dhcpNetworks[i].DnsChoice = dnsChoiceInt

																				dnsChoiceInt.DnsAddress = v.(string)

																			}

																			if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																				dnsChoiceTypeFound = true

																				if v.(bool) {
																					dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
																					dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
																					dhcpNetworks[i].DnsChoice = dnsChoiceInt
																				}

																			}

																			gatewayChoiceTypeFound := false

																			if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

																				gatewayChoiceTypeFound = true
																				gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

																				dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

																				gatewayChoiceInt.DgwAddress = v.(string)

																			}

																			if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

																				gatewayChoiceTypeFound = true

																				if v.(bool) {
																					gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
																					gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																					dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
																				}

																			}

																			if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

																				gatewayChoiceTypeFound = true

																				if v.(bool) {
																					gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
																					gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
																					dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
																				}

																			}

																			networkPrefixChoiceTypeFound := false

																			if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																				networkPrefixChoiceTypeFound = true
																				networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

																				dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																				networkPrefixChoiceInt.NetworkPrefix = v.(string)

																			}

																			if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																				networkPrefixChoiceTypeFound = true
																				networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
																				networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																				dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["name"]; ok && !isIntfNil(v) {

																							networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																						}

																						if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																							networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																						}

																						if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																							networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

																				dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

																			}

																			if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
																				dhcpNetworks[i].Pools = pools
																				for i, set := range sl {
																					if set != nil {
																						pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
																						poolsMapStrToI := set.(map[string]interface{})

																						if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																							pools[i].EndIp = w.(string)
																						}

																						if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																							pools[i].Exclude = w.(bool)
																						}

																						if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																							pools[i].StartIp = w.(string)
																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

																	addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

																}

																if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																	ms := map[string]string{}
																	for k, v := range v.(map[string]interface{}) {
																		ms[k] = v.(string)
																	}
																	addressChoiceInt.DhcpServer.FixedIpMap = ms
																}

																interfacesAddressingChoiceTypeFound := false

																if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																	interfacesAddressingChoiceTypeFound = true

																	if v.(bool) {
																		interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
																		interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																		addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																	}

																}

																if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																	interfacesAddressingChoiceTypeFound = true

																	if v.(bool) {
																		interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
																		interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																		addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																	}

																}

																if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																	interfacesAddressingChoiceTypeFound = true
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
																	interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
																	addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																				ms := map[string]string{}
																				for k, v := range v.(map[string]interface{}) {
																					ms[k] = v.(string)
																				}
																				interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := cs["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_StaticIp{}
														addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIPParametersType{}
														interfaceChoiceInt.LoopbackInterface.AddressChoice = addressChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																networkPrefixChoiceTypeFound := false

																if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
																	networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
																	addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
																				networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
																				for _, set := range sl {
																					if set != nil {
																						interfaceIpMapMapStrToI := set.(map[string]interface{})
																						key, ok := interfaceIpMapMapStrToI["name"]
																						if ok && !isIntfNil(key) {
																							interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																							val, _ := interfaceIpMapMapStrToI["value"]

																							interfaceIpMapVals := val.([]interface{})
																							for _, intVal := range interfaceIpMapVals {
																								if intVal != nil {

																									interfaceIpMapStaticMap := intVal.(map[string]interface{})

																									if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DefaultGw = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DnsServer = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].IpAddress = w.(string)
																									}

																									// break after one loop
																									break
																								}
																							}
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
																	networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
																	addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
																				networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

																				for _, set := range sl {
																					if set != nil {
																						npaMapToStrVal := set.(map[string]interface{})
																						if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Name = val.(string)
																						}
																						if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Namespace = val.(string)
																						}

																						if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Tenant = val.(string)
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
																	networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																	addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := cs["device"]; ok && !isIntfNil(v) {

														interfaceChoiceInt.LoopbackInterface.Device = v.(string)

													}

													ipv6AddressChoiceTypeFound := false

													if v, ok := cs["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

														ipv6AddressChoiceTypeFound = true

														if v.(bool) {
															ipv6AddressChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_NoIpv6Address{}
															ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
															interfaceChoiceInt.LoopbackInterface.Ipv6AddressChoice = ipv6AddressChoiceInt
														}

													}

													if v, ok := cs["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

														ipv6AddressChoiceTypeFound = true
														ipv6AddressChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_StaticIpv6Address{}
														ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
														interfaceChoiceInt.LoopbackInterface.Ipv6AddressChoice = ipv6AddressChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																networkPrefixChoiceTypeFound := false

																if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
																	networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
																	ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
																				networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
																				for _, set := range sl {
																					if set != nil {
																						interfaceIpMapMapStrToI := set.(map[string]interface{})
																						key, ok := interfaceIpMapMapStrToI["name"]
																						if ok && !isIntfNil(key) {
																							interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																							val, _ := interfaceIpMapMapStrToI["value"]

																							interfaceIpMapVals := val.([]interface{})
																							for _, intVal := range interfaceIpMapVals {
																								if intVal != nil {

																									interfaceIpMapStaticMap := intVal.(map[string]interface{})

																									if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DefaultGw = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DnsServer = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].IpAddress = w.(string)
																									}

																									// break after one loop
																									break
																								}
																							}
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
																	networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
																	ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
																				networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

																				for _, set := range sl {
																					if set != nil {
																						npaMapToStrVal := set.(map[string]interface{})
																						if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Name = val.(string)
																						}
																						if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Namespace = val.(string)
																						}

																						if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Tenant = val.(string)
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
																	networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																	ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

														interfaceChoiceInt.LoopbackInterface.Mtu = uint32(v.(int))

													}

													networkChoiceTypeFound := false

													if v, ok := cs["ip_fabric_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true

														if v.(bool) {
															networkChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_IpFabricNetwork{}
															networkChoiceInt.IpFabricNetwork = &ves_io_schema.Empty{}
															interfaceChoiceInt.LoopbackInterface.NetworkChoice = networkChoiceInt
														}

													}

													if v, ok := cs["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true

														if v.(bool) {
															networkChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_SiteLocalInsideNetwork{}
															networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
															interfaceChoiceInt.LoopbackInterface.NetworkChoice = networkChoiceInt
														}

													}

													if v, ok := cs["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true

														if v.(bool) {
															networkChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_SiteLocalNetwork{}
															networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
															interfaceChoiceInt.LoopbackInterface.NetworkChoice = networkChoiceInt
														}

													}

													nodeChoiceTypeFound := false

													if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

														nodeChoiceTypeFound = true

														if v.(bool) {
															nodeChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_Cluster{}
															nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
															interfaceChoiceInt.LoopbackInterface.NodeChoice = nodeChoiceInt
														}

													}

													if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

														nodeChoiceTypeFound = true
														nodeChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_Node{}

														interfaceChoiceInt.LoopbackInterface.NodeChoice = nodeChoiceInt

														nodeChoiceInt.Node = v.(string)

													}

												}
											}

										}

										if v, ok := interfacesMapStrToI["tunnel_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

											interfaceChoiceTypeFound = true
											interfaceChoiceInt := &ves_io_schema_views_voltstack_site.Interface_TunnelInterface{}
											interfaceChoiceInt.TunnelInterface = &ves_io_schema_network_interface.TunnelInterfaceType{}
											interfaces[i].InterfaceChoice = interfaceChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["cloud_connect"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														cloudConnectInt := make([]*ves_io_schema.ObjectRefType, len(sl))
														interfaceChoiceInt.TunnelInterface.CloudConnect = cloudConnectInt
														for i, ps := range sl {

															ccMapToStrVal := ps.(map[string]interface{})
															cloudConnectInt[i] = &ves_io_schema.ObjectRefType{}

															cloudConnectInt[i].Kind = "cloud_connect"

															if v, ok := ccMapToStrVal["name"]; ok && !isIntfNil(v) {
																cloudConnectInt[i].Name = v.(string)
															}

															if v, ok := ccMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																cloudConnectInt[i].Namespace = v.(string)
															}

															if v, ok := ccMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																cloudConnectInt[i].Tenant = v.(string)
															}

															if v, ok := ccMapToStrVal["uid"]; ok && !isIntfNil(v) {
																cloudConnectInt[i].Uid = v.(string)
															}

														}

													}

													if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

														interfaceChoiceInt.TunnelInterface.Mtu = uint32(v.(int))

													}

													networkChoiceTypeFound := false

													if v, ok := cs["inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true
														networkChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_InsideNetwork{}
														networkChoiceInt.InsideNetwork = &ves_io_schema_views.ObjectRefType{}
														interfaceChoiceInt.TunnelInterface.NetworkChoice = networkChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	networkChoiceInt.InsideNetwork.Name = v.(string)

																}

																if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																	networkChoiceInt.InsideNetwork.Namespace = v.(string)

																}

																if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																	networkChoiceInt.InsideNetwork.Tenant = v.(string)

																}

															}
														}

													}

													if v, ok := cs["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true

														if v.(bool) {
															networkChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_SiteLocalInsideNetwork{}
															networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
															interfaceChoiceInt.TunnelInterface.NetworkChoice = networkChoiceInt
														}

													}

													if v, ok := cs["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true

														if v.(bool) {
															networkChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_SiteLocalNetwork{}
															networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
															interfaceChoiceInt.TunnelInterface.NetworkChoice = networkChoiceInt
														}

													}

													nodeChoiceTypeFound := false

													if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

														nodeChoiceTypeFound = true

														if v.(bool) {
															nodeChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_Cluster{}
															nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
															interfaceChoiceInt.TunnelInterface.NodeChoice = nodeChoiceInt
														}

													}

													if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

														nodeChoiceTypeFound = true
														nodeChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_Node{}

														interfaceChoiceInt.TunnelInterface.NodeChoice = nodeChoiceInt

														nodeChoiceInt.Node = v.(string)

													}

													if v, ok := cs["priority"]; ok && !isIntfNil(v) {

														interfaceChoiceInt.TunnelInterface.Priority = uint32(v.(int))

													}

													if v, ok := cs["static_ip"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														staticIp := &ves_io_schema_network_interface.StaticIPParametersType{}
														interfaceChoiceInt.TunnelInterface.StaticIp = staticIp
														for _, set := range sl {
															if set != nil {
																staticIpMapStrToI := set.(map[string]interface{})

																networkPrefixChoiceTypeFound := false

																if v, ok := staticIpMapStrToI["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
																	networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
																	staticIp.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
																				networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
																				for _, set := range sl {
																					if set != nil {
																						interfaceIpMapMapStrToI := set.(map[string]interface{})
																						key, ok := interfaceIpMapMapStrToI["name"]
																						if ok && !isIntfNil(key) {
																							interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																							val, _ := interfaceIpMapMapStrToI["value"]

																							interfaceIpMapVals := val.([]interface{})
																							for _, intVal := range interfaceIpMapVals {
																								if intVal != nil {

																									interfaceIpMapStaticMap := intVal.(map[string]interface{})

																									if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DefaultGw = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DnsServer = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].IpAddress = w.(string)
																									}

																									// break after one loop
																									break
																								}
																							}
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := staticIpMapStrToI["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
																	networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
																	staticIp.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
																				networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

																				for _, set := range sl {
																					if set != nil {
																						npaMapToStrVal := set.(map[string]interface{})
																						if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Name = val.(string)
																						}
																						if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Namespace = val.(string)
																						}

																						if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Tenant = val.(string)
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := staticIpMapStrToI["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
																	networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																	staticIp.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := cs["tunnel"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														tunnelInt := &ves_io_schema_views.ObjectRefType{}
														interfaceChoiceInt.TunnelInterface.Tunnel = tunnelInt

														for _, set := range sl {
															if set != nil {
																tMapToStrVal := set.(map[string]interface{})
																if val, ok := tMapToStrVal["name"]; ok && !isIntfNil(v) {
																	tunnelInt.Name = val.(string)
																}
																if val, ok := tMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																	tunnelInt.Namespace = val.(string)
																}

																if val, ok := tMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																	tunnelInt.Tenant = val.(string)
																}
															}
														}

													}

												}
											}

										}

										if w, ok := interfacesMapStrToI["labels"]; ok && !isIntfNil(w) {
											ms := map[string]string{}
											for k, v := range w.(map[string]interface{}) {
												ms[k] = v.(string)
											}
											interfaces[i].Labels = ms
										}

									}
								}

							}

						}
					}

				}

				networkPolicyChoiceTypeFound := false

				if v, ok := cs["active_enhanced_firewall_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true
					networkPolicyChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_ActiveEnhancedFirewallPolicies{}
					networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies = &ves_io_schema_network_firewall.ActiveEnhancedFirewallPoliciesType{}
					networkCfgChoiceInt.CustomNetworkConfig.NetworkPolicyChoice = networkPolicyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["enhanced_firewall_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								enhancedFirewallPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies.EnhancedFirewallPolicies = enhancedFirewallPoliciesInt
								for i, ps := range sl {

									efpMapToStrVal := ps.(map[string]interface{})
									enhancedFirewallPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := efpMapToStrVal["name"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Name = v.(string)
									}

									if v, ok := efpMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := efpMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["active_network_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true
					networkPolicyChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_ActiveNetworkPolicies{}
					networkPolicyChoiceInt.ActiveNetworkPolicies = &ves_io_schema_network_firewall.ActiveNetworkPoliciesType{}
					networkCfgChoiceInt.CustomNetworkConfig.NetworkPolicyChoice = networkPolicyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["network_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								networkPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								networkPolicyChoiceInt.ActiveNetworkPolicies.NetworkPolicies = networkPoliciesInt
								for i, ps := range sl {

									npMapToStrVal := ps.(map[string]interface{})
									networkPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := npMapToStrVal["name"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Name = v.(string)
									}

									if v, ok := npMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := npMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["no_network_policy"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true

					if v.(bool) {
						networkPolicyChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_NoNetworkPolicy{}
						networkPolicyChoiceInt.NoNetworkPolicy = &ves_io_schema.Empty{}
						networkCfgChoiceInt.CustomNetworkConfig.NetworkPolicyChoice = networkPolicyChoiceInt
					}

				}

				if v, ok := cs["outside_nameserver"]; ok && !isIntfNil(v) {

					networkCfgChoiceInt.CustomNetworkConfig.OutsideNameserver = v.(string)

				}

				if v, ok := cs["outside_nameserver_v6"]; ok && !isIntfNil(v) {

					networkCfgChoiceInt.CustomNetworkConfig.OutsideNameserverV6 = v.(string)

				}

				if v, ok := cs["outside_vip"]; ok && !isIntfNil(v) {

					networkCfgChoiceInt.CustomNetworkConfig.OutsideVip = v.(string)

				}

				if v, ok := cs["outside_vip_v6"]; ok && !isIntfNil(v) {

					networkCfgChoiceInt.CustomNetworkConfig.OutsideVipV6 = v.(string)

				}

				siteMeshGroupChoiceTypeFound := false

				if v, ok := cs["site_to_site_tunnel_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

					siteMeshGroupChoiceTypeFound = true
					siteMeshGroupChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_SiteToSiteTunnelIp{}

					networkCfgChoiceInt.CustomNetworkConfig.SiteMeshGroupChoice = siteMeshGroupChoiceInt

					siteMeshGroupChoiceInt.SiteToSiteTunnelIp = v.(string)

				}

				if v, ok := cs["sm_connection_public_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

					siteMeshGroupChoiceTypeFound = true

					if v.(bool) {
						siteMeshGroupChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_SmConnectionPublicIp{}
						siteMeshGroupChoiceInt.SmConnectionPublicIp = &ves_io_schema.Empty{}
						networkCfgChoiceInt.CustomNetworkConfig.SiteMeshGroupChoice = siteMeshGroupChoiceInt
					}

				}

				if v, ok := cs["sm_connection_pvt_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

					siteMeshGroupChoiceTypeFound = true

					if v.(bool) {
						siteMeshGroupChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_SmConnectionPvtIp{}
						siteMeshGroupChoiceInt.SmConnectionPvtIp = &ves_io_schema.Empty{}
						networkCfgChoiceInt.CustomNetworkConfig.SiteMeshGroupChoice = siteMeshGroupChoiceInt
					}

				}

				sliChoiceTypeFound := false

				if v, ok := cs["default_sli_config"]; ok && !isIntfNil(v) && !sliChoiceTypeFound {

					sliChoiceTypeFound = true

					if v.(bool) {
						sliChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_DefaultSliConfig{}
						sliChoiceInt.DefaultSliConfig = &ves_io_schema.Empty{}
						networkCfgChoiceInt.CustomNetworkConfig.SliChoice = sliChoiceInt
					}

				}

				if v, ok := cs["sli_config"]; ok && !isIntfNil(v) && !sliChoiceTypeFound {

					sliChoiceTypeFound = true
					sliChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_SliConfig{}
					sliChoiceInt.SliConfig = &ves_io_schema_views_voltstack_site.SliVnConfiguration{}
					networkCfgChoiceInt.CustomNetworkConfig.SliChoice = sliChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							staticRouteChoiceTypeFound := false

							if v, ok := cs["no_static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

								staticRouteChoiceTypeFound = true

								if v.(bool) {
									staticRouteChoiceInt := &ves_io_schema_views_voltstack_site.SliVnConfiguration_NoStaticRoutes{}
									staticRouteChoiceInt.NoStaticRoutes = &ves_io_schema.Empty{}
									sliChoiceInt.SliConfig.StaticRouteChoice = staticRouteChoiceInt
								}

							}

							if v, ok := cs["static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

								staticRouteChoiceTypeFound = true
								staticRouteChoiceInt := &ves_io_schema_views_voltstack_site.SliVnConfiguration_StaticRoutes{}
								staticRouteChoiceInt.StaticRoutes = &ves_io_schema_views_voltstack_site.StaticRoutesListType{}
								sliChoiceInt.SliConfig.StaticRouteChoice = staticRouteChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											staticRoutes := make([]*ves_io_schema_virtual_network.StaticRouteViewType, len(sl))
											staticRouteChoiceInt.StaticRoutes.StaticRoutes = staticRoutes
											for i, set := range sl {
												if set != nil {
													staticRoutes[i] = &ves_io_schema_virtual_network.StaticRouteViewType{}
													staticRoutesMapStrToI := set.(map[string]interface{})

													if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

														attrsList := []ves_io_schema.RouteAttrType{}
														for _, j := range v.([]interface{}) {
															attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
														}
														staticRoutes[i].Attrs = attrsList

													}

													if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
														ls := make([]string, len(w.([]interface{})))
														for i, v := range w.([]interface{}) {
															ls[i] = v.(string)
														}
														staticRoutes[i].IpPrefixes = ls
													}

													nextHopChoiceTypeFound := false

													if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

														nextHopChoiceTypeFound = true

														if v.(bool) {
															nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_DefaultGateway{}
															nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
															staticRoutes[i].NextHopChoice = nextHopChoiceInt
														}

													}

													if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

														nextHopChoiceTypeFound = true
														nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_Interface{}
														nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
														staticRoutes[i].NextHopChoice = nextHopChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	nextHopChoiceInt.Interface.Name = v.(string)

																}

																if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																	nextHopChoiceInt.Interface.Namespace = v.(string)

																}

																if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																	nextHopChoiceInt.Interface.Tenant = v.(string)

																}

															}
														}

													}

													if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

														nextHopChoiceTypeFound = true
														nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_IpAddress{}

														staticRoutes[i].NextHopChoice = nextHopChoiceInt

														nextHopChoiceInt.IpAddress = v.(string)

													}

												}
											}

										}

									}
								}

							}

							staticV6RouteChoiceTypeFound := false

							if v, ok := cs["no_v6_static_routes"]; ok && !isIntfNil(v) && !staticV6RouteChoiceTypeFound {

								staticV6RouteChoiceTypeFound = true

								if v.(bool) {
									staticV6RouteChoiceInt := &ves_io_schema_views_voltstack_site.SliVnConfiguration_NoV6StaticRoutes{}
									staticV6RouteChoiceInt.NoV6StaticRoutes = &ves_io_schema.Empty{}
									sliChoiceInt.SliConfig.StaticV6RouteChoice = staticV6RouteChoiceInt
								}

							}

							if v, ok := cs["static_v6_routes"]; ok && !isIntfNil(v) && !staticV6RouteChoiceTypeFound {

								staticV6RouteChoiceTypeFound = true
								staticV6RouteChoiceInt := &ves_io_schema_views_voltstack_site.SliVnConfiguration_StaticV6Routes{}
								staticV6RouteChoiceInt.StaticV6Routes = &ves_io_schema_virtual_network.StaticV6RoutesListType{}
								sliChoiceInt.SliConfig.StaticV6RouteChoice = staticV6RouteChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											staticRoutes := make([]*ves_io_schema_virtual_network.StaticV6RouteViewType, len(sl))
											staticV6RouteChoiceInt.StaticV6Routes.StaticRoutes = staticRoutes
											for i, set := range sl {
												if set != nil {
													staticRoutes[i] = &ves_io_schema_virtual_network.StaticV6RouteViewType{}
													staticRoutesMapStrToI := set.(map[string]interface{})

													if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

														attrsList := []ves_io_schema.RouteAttrType{}
														for _, j := range v.([]interface{}) {
															attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
														}
														staticRoutes[i].Attrs = attrsList

													}

													if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
														ls := make([]string, len(w.([]interface{})))
														for i, v := range w.([]interface{}) {
															ls[i] = v.(string)
														}
														staticRoutes[i].IpPrefixes = ls
													}

													nextHopChoiceTypeFound := false

													if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

														nextHopChoiceTypeFound = true

														if v.(bool) {
															nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_DefaultGateway{}
															nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
															staticRoutes[i].NextHopChoice = nextHopChoiceInt
														}

													}

													if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

														nextHopChoiceTypeFound = true
														nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_Interface{}
														nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
														staticRoutes[i].NextHopChoice = nextHopChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	nextHopChoiceInt.Interface.Name = v.(string)

																}

																if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																	nextHopChoiceInt.Interface.Namespace = v.(string)

																}

																if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																	nextHopChoiceInt.Interface.Tenant = v.(string)

																}

															}
														}

													}

													if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

														nextHopChoiceTypeFound = true
														nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_IpAddress{}

														staticRoutes[i].NextHopChoice = nextHopChoiceInt

														nextHopChoiceInt.IpAddress = v.(string)

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				sloChoiceTypeFound := false

				if v, ok := cs["default_config"]; ok && !isIntfNil(v) && !sloChoiceTypeFound {

					sloChoiceTypeFound = true

					if v.(bool) {
						sloChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_DefaultConfig{}
						sloChoiceInt.DefaultConfig = &ves_io_schema.Empty{}
						networkCfgChoiceInt.CustomNetworkConfig.SloChoice = sloChoiceInt
					}

				}

				if v, ok := cs["slo_config"]; ok && !isIntfNil(v) && !sloChoiceTypeFound {

					sloChoiceTypeFound = true
					sloChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_SloConfig{}
					sloChoiceInt.SloConfig = &ves_io_schema_views_voltstack_site.VnConfiguration{}
					networkCfgChoiceInt.CustomNetworkConfig.SloChoice = sloChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							dcClusterGroupChoiceTypeFound := false

							if v, ok := cs["dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

								dcClusterGroupChoiceTypeFound = true
								dcClusterGroupChoiceInt := &ves_io_schema_views_voltstack_site.VnConfiguration_DcClusterGroup{}
								dcClusterGroupChoiceInt.DcClusterGroup = &ves_io_schema_views.ObjectRefType{}
								sloChoiceInt.SloConfig.DcClusterGroupChoice = dcClusterGroupChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["name"]; ok && !isIntfNil(v) {

											dcClusterGroupChoiceInt.DcClusterGroup.Name = v.(string)

										}

										if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

											dcClusterGroupChoiceInt.DcClusterGroup.Namespace = v.(string)

										}

										if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

											dcClusterGroupChoiceInt.DcClusterGroup.Tenant = v.(string)

										}

									}
								}

							}

							if v, ok := cs["no_dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

								dcClusterGroupChoiceTypeFound = true

								if v.(bool) {
									dcClusterGroupChoiceInt := &ves_io_schema_views_voltstack_site.VnConfiguration_NoDcClusterGroup{}
									dcClusterGroupChoiceInt.NoDcClusterGroup = &ves_io_schema.Empty{}
									sloChoiceInt.SloConfig.DcClusterGroupChoice = dcClusterGroupChoiceInt
								}

							}

							if v, ok := cs["dc_cluster_group_interface"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								dcClusterGroupInterfaceInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								sloChoiceInt.SloConfig.DcClusterGroupInterface = dcClusterGroupInterfaceInt
								for i, ps := range sl {

									dcgiMapToStrVal := ps.(map[string]interface{})
									dcClusterGroupInterfaceInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := dcgiMapToStrVal["name"]; ok && !isIntfNil(v) {
										dcClusterGroupInterfaceInt[i].Name = v.(string)
									}

									if v, ok := dcgiMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										dcClusterGroupInterfaceInt[i].Namespace = v.(string)
									}

									if v, ok := dcgiMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										dcClusterGroupInterfaceInt[i].Tenant = v.(string)
									}

								}

							}

							if v, ok := cs["labels"]; ok && !isIntfNil(v) {

								ms := map[string]string{}
								for k, v := range v.(map[string]interface{}) {
									ms[k] = v.(string)
								}
								sloChoiceInt.SloConfig.Labels = ms
							}

							staticRouteChoiceTypeFound := false

							if v, ok := cs["no_static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

								staticRouteChoiceTypeFound = true

								if v.(bool) {
									staticRouteChoiceInt := &ves_io_schema_views_voltstack_site.VnConfiguration_NoStaticRoutes{}
									staticRouteChoiceInt.NoStaticRoutes = &ves_io_schema.Empty{}
									sloChoiceInt.SloConfig.StaticRouteChoice = staticRouteChoiceInt
								}

							}

							if v, ok := cs["static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

								staticRouteChoiceTypeFound = true
								staticRouteChoiceInt := &ves_io_schema_views_voltstack_site.VnConfiguration_StaticRoutes{}
								staticRouteChoiceInt.StaticRoutes = &ves_io_schema_views_voltstack_site.StaticRoutesListType{}
								sloChoiceInt.SloConfig.StaticRouteChoice = staticRouteChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											staticRoutes := make([]*ves_io_schema_virtual_network.StaticRouteViewType, len(sl))
											staticRouteChoiceInt.StaticRoutes.StaticRoutes = staticRoutes
											for i, set := range sl {
												if set != nil {
													staticRoutes[i] = &ves_io_schema_virtual_network.StaticRouteViewType{}
													staticRoutesMapStrToI := set.(map[string]interface{})

													if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

														attrsList := []ves_io_schema.RouteAttrType{}
														for _, j := range v.([]interface{}) {
															attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
														}
														staticRoutes[i].Attrs = attrsList

													}

													if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
														ls := make([]string, len(w.([]interface{})))
														for i, v := range w.([]interface{}) {
															ls[i] = v.(string)
														}
														staticRoutes[i].IpPrefixes = ls
													}

													nextHopChoiceTypeFound := false

													if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

														nextHopChoiceTypeFound = true

														if v.(bool) {
															nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_DefaultGateway{}
															nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
															staticRoutes[i].NextHopChoice = nextHopChoiceInt
														}

													}

													if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

														nextHopChoiceTypeFound = true
														nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_Interface{}
														nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
														staticRoutes[i].NextHopChoice = nextHopChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	nextHopChoiceInt.Interface.Name = v.(string)

																}

																if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																	nextHopChoiceInt.Interface.Namespace = v.(string)

																}

																if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																	nextHopChoiceInt.Interface.Tenant = v.(string)

																}

															}
														}

													}

													if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

														nextHopChoiceTypeFound = true
														nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_IpAddress{}

														staticRoutes[i].NextHopChoice = nextHopChoiceInt

														nextHopChoiceInt.IpAddress = v.(string)

													}

												}
											}

										}

									}
								}

							}

							staticV6RouteChoiceTypeFound := false

							if v, ok := cs["no_static_v6_routes"]; ok && !isIntfNil(v) && !staticV6RouteChoiceTypeFound {

								staticV6RouteChoiceTypeFound = true

								if v.(bool) {
									staticV6RouteChoiceInt := &ves_io_schema_views_voltstack_site.VnConfiguration_NoStaticV6Routes{}
									staticV6RouteChoiceInt.NoStaticV6Routes = &ves_io_schema.Empty{}
									sloChoiceInt.SloConfig.StaticV6RouteChoice = staticV6RouteChoiceInt
								}

							}

							if v, ok := cs["static_v6_routes"]; ok && !isIntfNil(v) && !staticV6RouteChoiceTypeFound {

								staticV6RouteChoiceTypeFound = true
								staticV6RouteChoiceInt := &ves_io_schema_views_voltstack_site.VnConfiguration_StaticV6Routes{}
								staticV6RouteChoiceInt.StaticV6Routes = &ves_io_schema_virtual_network.StaticV6RoutesListType{}
								sloChoiceInt.SloConfig.StaticV6RouteChoice = staticV6RouteChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											staticRoutes := make([]*ves_io_schema_virtual_network.StaticV6RouteViewType, len(sl))
											staticV6RouteChoiceInt.StaticV6Routes.StaticRoutes = staticRoutes
											for i, set := range sl {
												if set != nil {
													staticRoutes[i] = &ves_io_schema_virtual_network.StaticV6RouteViewType{}
													staticRoutesMapStrToI := set.(map[string]interface{})

													if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

														attrsList := []ves_io_schema.RouteAttrType{}
														for _, j := range v.([]interface{}) {
															attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
														}
														staticRoutes[i].Attrs = attrsList

													}

													if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
														ls := make([]string, len(w.([]interface{})))
														for i, v := range w.([]interface{}) {
															ls[i] = v.(string)
														}
														staticRoutes[i].IpPrefixes = ls
													}

													nextHopChoiceTypeFound := false

													if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

														nextHopChoiceTypeFound = true

														if v.(bool) {
															nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_DefaultGateway{}
															nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
															staticRoutes[i].NextHopChoice = nextHopChoiceInt
														}

													}

													if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

														nextHopChoiceTypeFound = true
														nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_Interface{}
														nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
														staticRoutes[i].NextHopChoice = nextHopChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	nextHopChoiceInt.Interface.Name = v.(string)

																}

																if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																	nextHopChoiceInt.Interface.Namespace = v.(string)

																}

																if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																	nextHopChoiceInt.Interface.Tenant = v.(string)

																}

															}
														}

													}

													if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

														nextHopChoiceTypeFound = true
														nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_IpAddress{}

														staticRoutes[i].NextHopChoice = nextHopChoiceInt

														nextHopChoiceInt.IpAddress = v.(string)

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["tunnel_dead_timeout"]; ok && !isIntfNil(v) {

					networkCfgChoiceInt.CustomNetworkConfig.TunnelDeadTimeout = uint32(v.(int))

				}

				if v, ok := cs["vip_vrrp_mode"]; ok && !isIntfNil(v) {

					networkCfgChoiceInt.CustomNetworkConfig.VipVrrpMode = ves_io_schema.VipVrrpType(ves_io_schema.VipVrrpType_value[v.(string)])

				}

			}
		}

	}

	if v, ok := d.GetOk("default_network_config"); ok && !networkCfgChoiceTypeFound {

		networkCfgChoiceTypeFound = true

		if v.(bool) {
			networkCfgChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_DefaultNetworkConfig{}
			networkCfgChoiceInt.DefaultNetworkConfig = &ves_io_schema.Empty{}
			createSpec.NetworkCfgChoice = networkCfgChoiceInt
		}

	}

	//offline_survivability_mode
	if v, ok := d.GetOk("offline_survivability_mode"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		offlineSurvivabilityMode := &ves_io_schema_views.OfflineSurvivabilityModeType{}
		createSpec.OfflineSurvivabilityMode = offlineSurvivabilityMode
		for _, set := range sl {
			if set != nil {
				offlineSurvivabilityModeMapStrToI := set.(map[string]interface{})

				offlineSurvivabilityModeChoiceTypeFound := false

				if v, ok := offlineSurvivabilityModeMapStrToI["enable_offline_survivability_mode"]; ok && !isIntfNil(v) && !offlineSurvivabilityModeChoiceTypeFound {

					offlineSurvivabilityModeChoiceTypeFound = true

					if v.(bool) {
						offlineSurvivabilityModeChoiceInt := &ves_io_schema_views.OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode{}
						offlineSurvivabilityModeChoiceInt.EnableOfflineSurvivabilityMode = &ves_io_schema.Empty{}
						offlineSurvivabilityMode.OfflineSurvivabilityModeChoice = offlineSurvivabilityModeChoiceInt
					}

				}

				if v, ok := offlineSurvivabilityModeMapStrToI["no_offline_survivability_mode"]; ok && !isIntfNil(v) && !offlineSurvivabilityModeChoiceTypeFound {

					offlineSurvivabilityModeChoiceTypeFound = true

					if v.(bool) {
						offlineSurvivabilityModeChoiceInt := &ves_io_schema_views.OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode{}
						offlineSurvivabilityModeChoiceInt.NoOfflineSurvivabilityMode = &ves_io_schema.Empty{}
						offlineSurvivabilityMode.OfflineSurvivabilityModeChoice = offlineSurvivabilityModeChoiceInt
					}

				}

			}
		}

	}

	//os
	if v, ok := d.GetOk("os"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		os := &ves_io_schema_views.OperatingSystemType{}
		createSpec.Os = os
		for _, set := range sl {
			if set != nil {
				osMapStrToI := set.(map[string]interface{})

				operatingSystemVersionChoiceTypeFound := false

				if v, ok := osMapStrToI["default_os_version"]; ok && !isIntfNil(v) && !operatingSystemVersionChoiceTypeFound {

					operatingSystemVersionChoiceTypeFound = true

					if v.(bool) {
						operatingSystemVersionChoiceInt := &ves_io_schema_views.OperatingSystemType_DefaultOsVersion{}
						operatingSystemVersionChoiceInt.DefaultOsVersion = &ves_io_schema.Empty{}
						os.OperatingSystemVersionChoice = operatingSystemVersionChoiceInt
					}

				}

				if v, ok := osMapStrToI["operating_system_version"]; ok && !isIntfNil(v) && !operatingSystemVersionChoiceTypeFound {

					operatingSystemVersionChoiceTypeFound = true
					operatingSystemVersionChoiceInt := &ves_io_schema_views.OperatingSystemType_OperatingSystemVersion{}

					os.OperatingSystemVersionChoice = operatingSystemVersionChoiceInt

					operatingSystemVersionChoiceInt.OperatingSystemVersion = v.(string)

				}

			}
		}

	}

	//sriov_interface_choice

	sriovInterfaceChoiceTypeFound := false

	if v, ok := d.GetOk("default_sriov_interface"); ok && !sriovInterfaceChoiceTypeFound {

		sriovInterfaceChoiceTypeFound = true

		if v.(bool) {
			sriovInterfaceChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_DefaultSriovInterface{}
			sriovInterfaceChoiceInt.DefaultSriovInterface = &ves_io_schema.Empty{}
			createSpec.SriovInterfaceChoice = sriovInterfaceChoiceInt
		}

	}

	if v, ok := d.GetOk("sriov_interfaces"); ok && !sriovInterfaceChoiceTypeFound {

		sriovInterfaceChoiceTypeFound = true
		sriovInterfaceChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_SriovInterfaces{}
		sriovInterfaceChoiceInt.SriovInterfaces = &ves_io_schema_fleet.SriovInterfacesListType{}
		createSpec.SriovInterfaceChoice = sriovInterfaceChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["sriov_interface"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					sriovInterface := make([]*ves_io_schema_fleet.SriovInterface, len(sl))
					sriovInterfaceChoiceInt.SriovInterfaces.SriovInterface = sriovInterface
					for i, set := range sl {
						if set != nil {
							sriovInterface[i] = &ves_io_schema_fleet.SriovInterface{}
							sriovInterfaceMapStrToI := set.(map[string]interface{})

							if w, ok := sriovInterfaceMapStrToI["interface_name"]; ok && !isIntfNil(w) {
								sriovInterface[i].InterfaceName = w.(string)
							}

							if w, ok := sriovInterfaceMapStrToI["number_of_vfio_vfs"]; ok && !isIntfNil(w) {
								sriovInterface[i].NumberOfVfioVfs = uint32(w.(int))
							}

							if w, ok := sriovInterfaceMapStrToI["number_of_vfs"]; ok && !isIntfNil(w) {
								sriovInterface[i].NumberOfVfs = uint32(w.(int))
							}

						}
					}

				}

			}
		}

	}

	//storage_cfg_choice

	storageCfgChoiceTypeFound := false

	if v, ok := d.GetOk("custom_storage_config"); ok && !storageCfgChoiceTypeFound {

		storageCfgChoiceTypeFound = true
		storageCfgChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_CustomStorageConfig{}
		storageCfgChoiceInt.CustomStorageConfig = &ves_io_schema_views_voltstack_site.VssStorageConfiguration{}
		createSpec.StorageCfgChoice = storageCfgChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				staticRouteChoiceTypeFound := false

				if v, ok := cs["no_static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

					staticRouteChoiceTypeFound = true

					if v.(bool) {
						staticRouteChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_NoStaticRoutes{}
						staticRouteChoiceInt.NoStaticRoutes = &ves_io_schema.Empty{}
						storageCfgChoiceInt.CustomStorageConfig.StaticRouteChoice = staticRouteChoiceInt
					}

				}

				if v, ok := cs["static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

					staticRouteChoiceTypeFound = true
					staticRouteChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_StaticRoutes{}
					staticRouteChoiceInt.StaticRoutes = &ves_io_schema_views_voltstack_site.StaticRoutesListType{}
					storageCfgChoiceInt.CustomStorageConfig.StaticRouteChoice = staticRouteChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRoutes := make([]*ves_io_schema_virtual_network.StaticRouteViewType, len(sl))
								staticRouteChoiceInt.StaticRoutes.StaticRoutes = staticRoutes
								for i, set := range sl {
									if set != nil {
										staticRoutes[i] = &ves_io_schema_virtual_network.StaticRouteViewType{}
										staticRoutesMapStrToI := set.(map[string]interface{})

										if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

											attrsList := []ves_io_schema.RouteAttrType{}
											for _, j := range v.([]interface{}) {
												attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
											}
											staticRoutes[i].Attrs = attrsList

										}

										if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
											ls := make([]string, len(w.([]interface{})))
											for i, v := range w.([]interface{}) {
												ls[i] = v.(string)
											}
											staticRoutes[i].IpPrefixes = ls
										}

										nextHopChoiceTypeFound := false

										if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

											nextHopChoiceTypeFound = true

											if v.(bool) {
												nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_DefaultGateway{}
												nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
												staticRoutes[i].NextHopChoice = nextHopChoiceInt
											}

										}

										if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

											nextHopChoiceTypeFound = true
											nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_Interface{}
											nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
											staticRoutes[i].NextHopChoice = nextHopChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														nextHopChoiceInt.Interface.Name = v.(string)

													}

													if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

														nextHopChoiceInt.Interface.Namespace = v.(string)

													}

													if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

														nextHopChoiceInt.Interface.Tenant = v.(string)

													}

												}
											}

										}

										if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

											nextHopChoiceTypeFound = true
											nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_IpAddress{}

											staticRoutes[i].NextHopChoice = nextHopChoiceInt

											nextHopChoiceInt.IpAddress = v.(string)

										}

									}
								}

							}

						}
					}

				}

				storageClassChoiceTypeFound := false

				if v, ok := cs["default_storage_class"]; ok && !isIntfNil(v) && !storageClassChoiceTypeFound {

					storageClassChoiceTypeFound = true

					if v.(bool) {
						storageClassChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_DefaultStorageClass{}
						storageClassChoiceInt.DefaultStorageClass = &ves_io_schema.Empty{}
						storageCfgChoiceInt.CustomStorageConfig.StorageClassChoice = storageClassChoiceInt
					}

				}

				if v, ok := cs["storage_class_list"]; ok && !isIntfNil(v) && !storageClassChoiceTypeFound {

					storageClassChoiceTypeFound = true
					storageClassChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_StorageClassList{}
					storageClassChoiceInt.StorageClassList = &ves_io_schema_fleet.FleetStorageClassListType{}
					storageCfgChoiceInt.CustomStorageConfig.StorageClassChoice = storageClassChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["storage_classes"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								storageClasses := make([]*ves_io_schema_fleet.FleetStorageClassType, len(sl))
								storageClassChoiceInt.StorageClassList.StorageClasses = storageClasses
								for i, set := range sl {
									if set != nil {
										storageClasses[i] = &ves_io_schema_fleet.FleetStorageClassType{}
										storageClassesMapStrToI := set.(map[string]interface{})

										if w, ok := storageClassesMapStrToI["advanced_storage_parameters"]; ok && !isIntfNil(w) {
											ms := map[string]string{}
											for k, v := range w.(map[string]interface{}) {
												ms[k] = v.(string)
											}
											storageClasses[i].AdvancedStorageParameters = ms
										}

										if w, ok := storageClassesMapStrToI["allow_volume_expansion"]; ok && !isIntfNil(w) {
											storageClasses[i].AllowVolumeExpansion = w.(bool)
										}

										if w, ok := storageClassesMapStrToI["default_storage_class"]; ok && !isIntfNil(w) {
											storageClasses[i].DefaultStorageClass = w.(bool)
										}

										if w, ok := storageClassesMapStrToI["description"]; ok && !isIntfNil(w) {
											storageClasses[i].Description = w.(string)
										}

										deviceChoiceTypeFound := false

										if v, ok := storageClassesMapStrToI["custom_storage"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

											deviceChoiceTypeFound = true
											deviceChoiceInt := &ves_io_schema_fleet.FleetStorageClassType_CustomStorage{}
											deviceChoiceInt.CustomStorage = &ves_io_schema_fleet.StorageClassCustomType{}
											storageClasses[i].DeviceChoice = deviceChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["yaml"]; ok && !isIntfNil(v) {

														deviceChoiceInt.CustomStorage.Yaml = v.(string)

													}

												}
											}

										}

										if v, ok := storageClassesMapStrToI["hpe_storage"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

											deviceChoiceTypeFound = true
											deviceChoiceInt := &ves_io_schema_fleet.FleetStorageClassType_HpeStorage{}
											deviceChoiceInt.HpeStorage = &ves_io_schema_fleet.StorageClassHpeStorageType{}
											storageClasses[i].DeviceChoice = deviceChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["allow_mutations"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.AllowMutations = v.(string)

													}

													if v, ok := cs["allow_overrides"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.AllowOverrides = v.(string)

													}

													if v, ok := cs["dedupe_enabled"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.DedupeEnabled = v.(bool)

													}

													if v, ok := cs["description"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.Description = v.(string)

													}

													if v, ok := cs["destroy_on_delete"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.DestroyOnDelete = v.(bool)

													}

													if v, ok := cs["encrypted"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.Encrypted = v.(bool)

													}

													if v, ok := cs["folder"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.Folder = v.(string)

													}

													if v, ok := cs["limit_iops"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.LimitIops = int64(v.(int))

													}

													if v, ok := cs["limit_mbps"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.LimitMbps = int64(v.(int))

													}

													if v, ok := cs["performance_policy"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.PerformancePolicy = v.(string)

													}

													if v, ok := cs["pool"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.Pool = v.(string)

													}

													if v, ok := cs["protection_template"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.ProtectionTemplate = v.(string)

													}

													if v, ok := cs["secret_name"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.SecretName = v.(string)

													}

													if v, ok := cs["secret_namespace"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.SecretNamespace = v.(string)

													}

													if v, ok := cs["sync_on_detach"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.SyncOnDetach = v.(bool)

													}

													if v, ok := cs["thick"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.Thick = v.(bool)

													}

												}
											}

										}

										if v, ok := storageClassesMapStrToI["netapp_trident"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

											deviceChoiceTypeFound = true
											deviceChoiceInt := &ves_io_schema_fleet.FleetStorageClassType_NetappTrident{}
											deviceChoiceInt.NetappTrident = &ves_io_schema_fleet.StorageClassNetappTridentType{}
											storageClasses[i].DeviceChoice = deviceChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["selector"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														deviceChoiceInt.NetappTrident.Selector = ms
													}

													if v, ok := cs["storage_pools"]; ok && !isIntfNil(v) {

														deviceChoiceInt.NetappTrident.StoragePools = v.(string)

													}

												}
											}

										}

										if v, ok := storageClassesMapStrToI["pure_service_orchestrator"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

											deviceChoiceTypeFound = true
											deviceChoiceInt := &ves_io_schema_fleet.FleetStorageClassType_PureServiceOrchestrator{}
											deviceChoiceInt.PureServiceOrchestrator = &ves_io_schema_fleet.StorageClassPureServiceOrchestratorType{}
											storageClasses[i].DeviceChoice = deviceChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["backend"]; ok && !isIntfNil(v) {

														deviceChoiceInt.PureServiceOrchestrator.Backend = v.(string)

													}

													if v, ok := cs["bandwidth_limit"]; ok && !isIntfNil(v) {

														deviceChoiceInt.PureServiceOrchestrator.BandwidthLimit = v.(string)

													}

													if v, ok := cs["iops_limit"]; ok && !isIntfNil(v) {

														deviceChoiceInt.PureServiceOrchestrator.IopsLimit = uint32(v.(int))

													}

												}
											}

										}

										if w, ok := storageClassesMapStrToI["reclaim_policy"]; ok && !isIntfNil(w) {
											storageClasses[i].ReclaimPolicy = w.(string)
										}

										if w, ok := storageClassesMapStrToI["storage_class_name"]; ok && !isIntfNil(w) {
											storageClasses[i].StorageClassName = w.(string)
										}

										if w, ok := storageClassesMapStrToI["storage_device"]; ok && !isIntfNil(w) {
											storageClasses[i].StorageDevice = w.(string)
										}

									}
								}

							}

						}
					}

				}

				storageDeviceChoiceTypeFound := false

				if v, ok := cs["no_storage_device"]; ok && !isIntfNil(v) && !storageDeviceChoiceTypeFound {

					storageDeviceChoiceTypeFound = true

					if v.(bool) {
						storageDeviceChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_NoStorageDevice{}
						storageDeviceChoiceInt.NoStorageDevice = &ves_io_schema.Empty{}
						storageCfgChoiceInt.CustomStorageConfig.StorageDeviceChoice = storageDeviceChoiceInt
					}

				}

				if v, ok := cs["storage_device_list"]; ok && !isIntfNil(v) && !storageDeviceChoiceTypeFound {

					storageDeviceChoiceTypeFound = true
					storageDeviceChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_StorageDeviceList{}
					storageDeviceChoiceInt.StorageDeviceList = &ves_io_schema_fleet.FleetStorageDeviceListType{}
					storageCfgChoiceInt.CustomStorageConfig.StorageDeviceChoice = storageDeviceChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["storage_devices"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								storageDevices := make([]*ves_io_schema_fleet.FleetStorageDeviceType, len(sl))
								storageDeviceChoiceInt.StorageDeviceList.StorageDevices = storageDevices
								for i, set := range sl {
									if set != nil {
										storageDevices[i] = &ves_io_schema_fleet.FleetStorageDeviceType{}
										storageDevicesMapStrToI := set.(map[string]interface{})

										if w, ok := storageDevicesMapStrToI["advanced_advanced_parameters"]; ok && !isIntfNil(w) {
											ms := map[string]string{}
											for k, v := range w.(map[string]interface{}) {
												ms[k] = v.(string)
											}
											storageDevices[i].AdvancedAdvancedParameters = ms
										}

										deviceChoiceTypeFound := false

										if v, ok := storageDevicesMapStrToI["custom_storage"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

											deviceChoiceTypeFound = true

											if v.(bool) {
												deviceChoiceInt := &ves_io_schema_fleet.FleetStorageDeviceType_CustomStorage{}
												deviceChoiceInt.CustomStorage = &ves_io_schema.Empty{}
												storageDevices[i].DeviceChoice = deviceChoiceInt
											}

										}

										if v, ok := storageDevicesMapStrToI["hpe_storage"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

											deviceChoiceTypeFound = true
											deviceChoiceInt := &ves_io_schema_fleet.FleetStorageDeviceType_HpeStorage{}
											deviceChoiceInt.HpeStorage = &ves_io_schema_fleet.StorageDeviceHpeStorageType{}
											storageDevices[i].DeviceChoice = deviceChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["api_server_port"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.ApiServerPort = uint32(v.(int))

													}

													if v, ok := cs["csi_version"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.CsiVersion = v.(string)

													}

													if v, ok := cs["iscsi_chap_password"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														iscsiChapPassword := &ves_io_schema.SecretType{}
														deviceChoiceInt.HpeStorage.IscsiChapPassword = iscsiChapPassword
														for _, set := range sl {
															if set != nil {
																iscsiChapPasswordMapStrToI := set.(map[string]interface{})

																if v, ok := iscsiChapPasswordMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																	iscsiChapPassword.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																	for _, set := range sl {
																		if set != nil {
																			blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																			if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																				blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																			}

																			if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																				blindfoldSecretInfoInternal.Location = w.(string)
																			}

																			if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																				blindfoldSecretInfoInternal.StoreProvider = w.(string)
																			}

																		}
																	}

																}

																if v, ok := iscsiChapPasswordMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																	iscsiChapPassword.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																}

																secretInfoOneofTypeFound := false

																if v, ok := iscsiChapPasswordMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																	secretInfoOneofTypeFound = true
																	secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																	secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																	iscsiChapPassword.SecretInfoOneof = secretInfoOneofInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																			}

																			if v, ok := cs["location"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																			}

																			if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																			}

																		}
																	}

																}

																if v, ok := iscsiChapPasswordMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																	secretInfoOneofTypeFound = true
																	secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																	secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																	iscsiChapPassword.SecretInfoOneof = secretInfoOneofInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																			}

																			if v, ok := cs["url"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																			}

																		}
																	}

																}

																if v, ok := iscsiChapPasswordMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																	secretInfoOneofTypeFound = true
																	secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																	secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																	iscsiChapPassword.SecretInfoOneof = secretInfoOneofInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["key"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																			}

																			if v, ok := cs["location"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																			}

																			if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																			}

																			if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																			}

																			if v, ok := cs["version"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																			}

																		}
																	}

																}

																if v, ok := iscsiChapPasswordMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																	secretInfoOneofTypeFound = true
																	secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																	secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																	iscsiChapPassword.SecretInfoOneof = secretInfoOneofInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["name"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := cs["iscsi_chap_user"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.IscsiChapUser = v.(string)

													}

													if v, ok := cs["log_level"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.LogLevel = v.(string)

													}

													if v, ok := cs["password"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														password := &ves_io_schema.SecretType{}
														deviceChoiceInt.HpeStorage.Password = password
														for _, set := range sl {
															if set != nil {
																passwordMapStrToI := set.(map[string]interface{})

																if v, ok := passwordMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																	password.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																	for _, set := range sl {
																		if set != nil {
																			blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																			if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																				blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																			}

																			if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																				blindfoldSecretInfoInternal.Location = w.(string)
																			}

																			if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																				blindfoldSecretInfoInternal.StoreProvider = w.(string)
																			}

																		}
																	}

																}

																if v, ok := passwordMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																	password.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																}

																secretInfoOneofTypeFound := false

																if v, ok := passwordMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																	secretInfoOneofTypeFound = true
																	secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																	secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																	password.SecretInfoOneof = secretInfoOneofInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																			}

																			if v, ok := cs["location"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																			}

																			if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																			}

																		}
																	}

																}

																if v, ok := passwordMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																	secretInfoOneofTypeFound = true
																	secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																	secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																	password.SecretInfoOneof = secretInfoOneofInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																			}

																			if v, ok := cs["url"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																			}

																		}
																	}

																}

																if v, ok := passwordMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																	secretInfoOneofTypeFound = true
																	secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																	secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																	password.SecretInfoOneof = secretInfoOneofInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["key"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																			}

																			if v, ok := cs["location"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																			}

																			if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																			}

																			if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																			}

																			if v, ok := cs["version"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																			}

																		}
																	}

																}

																if v, ok := passwordMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																	secretInfoOneofTypeFound = true
																	secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																	secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																	password.SecretInfoOneof = secretInfoOneofInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["name"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := cs["storage_server_ip_address"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.StorageServerIpAddress = v.(string)

													}

													if v, ok := cs["storage_server_name"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.StorageServerName = v.(string)

													}

													if v, ok := cs["username"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.Username = v.(string)

													}

												}
											}

										}

										if v, ok := storageDevicesMapStrToI["netapp_trident"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

											deviceChoiceTypeFound = true
											deviceChoiceInt := &ves_io_schema_fleet.FleetStorageDeviceType_NetappTrident{}
											deviceChoiceInt.NetappTrident = &ves_io_schema_fleet.StorageDeviceNetappTridentType{}
											storageDevices[i].DeviceChoice = deviceChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													backendChoiceTypeFound := false

													if v, ok := cs["netapp_backend_ontap_nas"]; ok && !isIntfNil(v) && !backendChoiceTypeFound {

														backendChoiceTypeFound = true
														backendChoiceInt := &ves_io_schema_fleet.StorageDeviceNetappTridentType_NetappBackendOntapNas{}
														backendChoiceInt.NetappBackendOntapNas = &ves_io_schema_fleet.StorageDeviceNetappBackendOntapNasType{}
														deviceChoiceInt.NetappTrident.BackendChoice = backendChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["auto_export_cidrs"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	autoExportCidrs := &ves_io_schema_views.PrefixStringListType{}
																	backendChoiceInt.NetappBackendOntapNas.AutoExportCidrs = autoExportCidrs
																	for _, set := range sl {
																		if set != nil {
																			autoExportCidrsMapStrToI := set.(map[string]interface{})

																			if w, ok := autoExportCidrsMapStrToI["ipv6_prefixes"]; ok && !isIntfNil(w) {
																				ls := make([]string, len(w.([]interface{})))
																				for i, v := range w.([]interface{}) {
																					ls[i] = v.(string)
																				}
																				autoExportCidrs.Ipv6Prefixes = ls
																			}

																			if w, ok := autoExportCidrsMapStrToI["prefixes"]; ok && !isIntfNil(w) {
																				ls := make([]string, len(w.([]interface{})))
																				for i, v := range w.([]interface{}) {
																					ls[i] = v.(string)
																				}
																				autoExportCidrs.Prefixes = ls
																			}

																		}
																	}

																}

																if v, ok := cs["auto_export_policy"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapNas.AutoExportPolicy = v.(bool)

																}

																if v, ok := cs["backend_name"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapNas.BackendName = v.(string)

																}

																if v, ok := cs["client_certificate"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapNas.ClientCertificate = v.(string)

																}

																if v, ok := cs["client_private_key"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	clientPrivateKey := &ves_io_schema.SecretType{}
																	backendChoiceInt.NetappBackendOntapNas.ClientPrivateKey = clientPrivateKey
																	for _, set := range sl {
																		if set != nil {
																			clientPrivateKeyMapStrToI := set.(map[string]interface{})

																			if v, ok := clientPrivateKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																				clientPrivateKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																				for _, set := range sl {
																					if set != nil {
																						blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																						if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																							blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																						}

																						if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																							blindfoldSecretInfoInternal.Location = w.(string)
																						}

																						if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																							blindfoldSecretInfoInternal.StoreProvider = w.(string)
																						}

																					}
																				}

																			}

																			if v, ok := clientPrivateKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																				clientPrivateKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																			}

																			secretInfoOneofTypeFound := false

																			if v, ok := clientPrivateKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																				secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																				clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																						}

																						if v, ok := cs["location"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																						}

																						if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := clientPrivateKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																				secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																				clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																						}

																						if v, ok := cs["url"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := clientPrivateKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																				secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																				clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["key"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																						}

																						if v, ok := cs["location"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																						}

																						if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																						}

																						if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																						}

																						if v, ok := cs["version"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																						}

																					}
																				}

																			}

																			if v, ok := clientPrivateKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																				secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																				clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["name"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																dataLifTypeFound := false

																if v, ok := cs["data_lif_dns_name"]; ok && !isIntfNil(v) && !dataLifTypeFound {

																	dataLifTypeFound = true
																	dataLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapNasType_DataLifDnsName{}

																	backendChoiceInt.NetappBackendOntapNas.DataLif = dataLifInt

																	dataLifInt.DataLifDnsName = v.(string)

																}

																if v, ok := cs["data_lif_ip"]; ok && !isIntfNil(v) && !dataLifTypeFound {

																	dataLifTypeFound = true
																	dataLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapNasType_DataLifIp{}

																	backendChoiceInt.NetappBackendOntapNas.DataLif = dataLifInt

																	dataLifInt.DataLifIp = v.(string)

																}

																if v, ok := cs["labels"]; ok && !isIntfNil(v) {

																	ms := map[string]string{}
																	for k, v := range v.(map[string]interface{}) {
																		ms[k] = v.(string)
																	}
																	backendChoiceInt.NetappBackendOntapNas.Labels = ms
																}

																if v, ok := cs["limit_aggregate_usage"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapNas.LimitAggregateUsage = v.(string)

																}

																if v, ok := cs["limit_volume_size"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapNas.LimitVolumeSize = v.(string)

																}

																managementLifTypeFound := false

																if v, ok := cs["management_lif_dns_name"]; ok && !isIntfNil(v) && !managementLifTypeFound {

																	managementLifTypeFound = true
																	managementLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName{}

																	backendChoiceInt.NetappBackendOntapNas.ManagementLif = managementLifInt

																	managementLifInt.ManagementLifDnsName = v.(string)

																}

																if v, ok := cs["management_lif_ip"]; ok && !isIntfNil(v) && !managementLifTypeFound {

																	managementLifTypeFound = true
																	managementLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapNasType_ManagementLifIp{}

																	backendChoiceInt.NetappBackendOntapNas.ManagementLif = managementLifInt

																	managementLifInt.ManagementLifIp = v.(string)

																}

																if v, ok := cs["nfs_mount_options"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapNas.NfsMountOptions = v.(string)

																}

																if v, ok := cs["password"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	password := &ves_io_schema.SecretType{}
																	backendChoiceInt.NetappBackendOntapNas.Password = password
																	for _, set := range sl {
																		if set != nil {
																			passwordMapStrToI := set.(map[string]interface{})

																			if v, ok := passwordMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																				password.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																				for _, set := range sl {
																					if set != nil {
																						blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																						if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																							blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																						}

																						if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																							blindfoldSecretInfoInternal.Location = w.(string)
																						}

																						if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																							blindfoldSecretInfoInternal.StoreProvider = w.(string)
																						}

																					}
																				}

																			}

																			if v, ok := passwordMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																				password.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																			}

																			secretInfoOneofTypeFound := false

																			if v, ok := passwordMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																				secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																				password.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																						}

																						if v, ok := cs["location"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																						}

																						if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := passwordMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																				secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																				password.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																						}

																						if v, ok := cs["url"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := passwordMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																				secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																				password.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["key"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																						}

																						if v, ok := cs["location"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																						}

																						if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																						}

																						if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																						}

																						if v, ok := cs["version"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																						}

																					}
																				}

																			}

																			if v, ok := passwordMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																				secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																				password.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["name"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["region"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapNas.Region = v.(string)

																}

																if v, ok := cs["storage"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	storage := make([]*ves_io_schema_fleet.OntapVirtualStoragePoolType, len(sl))
																	backendChoiceInt.NetappBackendOntapNas.Storage = storage
																	for i, set := range sl {
																		if set != nil {
																			storage[i] = &ves_io_schema_fleet.OntapVirtualStoragePoolType{}
																			storageMapStrToI := set.(map[string]interface{})

																			if w, ok := storageMapStrToI["labels"]; ok && !isIntfNil(w) {
																				ms := map[string]string{}
																				for k, v := range w.(map[string]interface{}) {
																					ms[k] = v.(string)
																				}
																				storage[i].Labels = ms
																			}

																			if v, ok := storageMapStrToI["volume_defaults"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				volumeDefaults := &ves_io_schema_fleet.OntapVolumeDefaults{}
																				storage[i].VolumeDefaults = volumeDefaults
																				for _, set := range sl {
																					if set != nil {
																						volumeDefaultsMapStrToI := set.(map[string]interface{})

																						if w, ok := volumeDefaultsMapStrToI["encryption"]; ok && !isIntfNil(w) {
																							volumeDefaults.Encryption = w.(bool)
																						}

																						if w, ok := volumeDefaultsMapStrToI["export_policy"]; ok && !isIntfNil(w) {
																							volumeDefaults.ExportPolicy = w.(string)
																						}

																						qosPolicyChoiceTypeFound := false

																						if v, ok := volumeDefaultsMapStrToI["adaptive_qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																							qosPolicyChoiceTypeFound = true
																							qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_AdaptiveQosPolicy{}

																							volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

																							qosPolicyChoiceInt.AdaptiveQosPolicy = v.(string)

																						}

																						if v, ok := volumeDefaultsMapStrToI["no_qos"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																							qosPolicyChoiceTypeFound = true

																							if v.(bool) {
																								qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_NoQos{}
																								qosPolicyChoiceInt.NoQos = &ves_io_schema.Empty{}
																								volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt
																							}

																						}

																						if v, ok := volumeDefaultsMapStrToI["qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																							qosPolicyChoiceTypeFound = true
																							qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_QosPolicy{}

																							volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

																							qosPolicyChoiceInt.QosPolicy = v.(string)

																						}

																						if w, ok := volumeDefaultsMapStrToI["security_style"]; ok && !isIntfNil(w) {
																							volumeDefaults.SecurityStyle = w.(string)
																						}

																						if w, ok := volumeDefaultsMapStrToI["snapshot_dir"]; ok && !isIntfNil(w) {
																							volumeDefaults.SnapshotDir = w.(bool)
																						}

																						if w, ok := volumeDefaultsMapStrToI["snapshot_policy"]; ok && !isIntfNil(w) {
																							volumeDefaults.SnapshotPolicy = w.(string)
																						}

																						if w, ok := volumeDefaultsMapStrToI["snapshot_reserve"]; ok && !isIntfNil(w) {
																							volumeDefaults.SnapshotReserve = w.(string)
																						}

																						if w, ok := volumeDefaultsMapStrToI["space_reserve"]; ok && !isIntfNil(w) {
																							volumeDefaults.SpaceReserve = w.(string)
																						}

																						if w, ok := volumeDefaultsMapStrToI["split_on_clone"]; ok && !isIntfNil(w) {
																							volumeDefaults.SplitOnClone = w.(bool)
																						}

																						if w, ok := volumeDefaultsMapStrToI["tiering_policy"]; ok && !isIntfNil(w) {
																							volumeDefaults.TieringPolicy = w.(string)
																						}

																						if w, ok := volumeDefaultsMapStrToI["unix_permissions"]; ok && !isIntfNil(w) {
																							volumeDefaults.UnixPermissions = int32(w.(int))
																						}

																					}
																				}

																			}

																			if w, ok := storageMapStrToI["zone"]; ok && !isIntfNil(w) {
																				storage[i].Zone = w.(string)
																			}

																		}
																	}

																}

																if v, ok := cs["storage_driver_name"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapNas.StorageDriverName = v.(string)

																}

																if v, ok := cs["storage_prefix"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapNas.StoragePrefix = v.(string)

																}

																if v, ok := cs["svm"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapNas.Svm = v.(string)

																}

																if v, ok := cs["trusted_ca_certificate"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapNas.TrustedCaCertificate = v.(string)

																}

																if v, ok := cs["username"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapNas.Username = v.(string)

																}

																if v, ok := cs["volume_defaults"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	volumeDefaults := &ves_io_schema_fleet.OntapVolumeDefaults{}
																	backendChoiceInt.NetappBackendOntapNas.VolumeDefaults = volumeDefaults
																	for _, set := range sl {
																		if set != nil {
																			volumeDefaultsMapStrToI := set.(map[string]interface{})

																			if w, ok := volumeDefaultsMapStrToI["encryption"]; ok && !isIntfNil(w) {
																				volumeDefaults.Encryption = w.(bool)
																			}

																			if w, ok := volumeDefaultsMapStrToI["export_policy"]; ok && !isIntfNil(w) {
																				volumeDefaults.ExportPolicy = w.(string)
																			}

																			qosPolicyChoiceTypeFound := false

																			if v, ok := volumeDefaultsMapStrToI["adaptive_qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																				qosPolicyChoiceTypeFound = true
																				qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_AdaptiveQosPolicy{}

																				volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

																				qosPolicyChoiceInt.AdaptiveQosPolicy = v.(string)

																			}

																			if v, ok := volumeDefaultsMapStrToI["no_qos"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																				qosPolicyChoiceTypeFound = true

																				if v.(bool) {
																					qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_NoQos{}
																					qosPolicyChoiceInt.NoQos = &ves_io_schema.Empty{}
																					volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt
																				}

																			}

																			if v, ok := volumeDefaultsMapStrToI["qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																				qosPolicyChoiceTypeFound = true
																				qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_QosPolicy{}

																				volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

																				qosPolicyChoiceInt.QosPolicy = v.(string)

																			}

																			if w, ok := volumeDefaultsMapStrToI["security_style"]; ok && !isIntfNil(w) {
																				volumeDefaults.SecurityStyle = w.(string)
																			}

																			if w, ok := volumeDefaultsMapStrToI["snapshot_dir"]; ok && !isIntfNil(w) {
																				volumeDefaults.SnapshotDir = w.(bool)
																			}

																			if w, ok := volumeDefaultsMapStrToI["snapshot_policy"]; ok && !isIntfNil(w) {
																				volumeDefaults.SnapshotPolicy = w.(string)
																			}

																			if w, ok := volumeDefaultsMapStrToI["snapshot_reserve"]; ok && !isIntfNil(w) {
																				volumeDefaults.SnapshotReserve = w.(string)
																			}

																			if w, ok := volumeDefaultsMapStrToI["space_reserve"]; ok && !isIntfNil(w) {
																				volumeDefaults.SpaceReserve = w.(string)
																			}

																			if w, ok := volumeDefaultsMapStrToI["split_on_clone"]; ok && !isIntfNil(w) {
																				volumeDefaults.SplitOnClone = w.(bool)
																			}

																			if w, ok := volumeDefaultsMapStrToI["tiering_policy"]; ok && !isIntfNil(w) {
																				volumeDefaults.TieringPolicy = w.(string)
																			}

																			if w, ok := volumeDefaultsMapStrToI["unix_permissions"]; ok && !isIntfNil(w) {
																				volumeDefaults.UnixPermissions = int32(w.(int))
																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := cs["netapp_backend_ontap_san"]; ok && !isIntfNil(v) && !backendChoiceTypeFound {

														backendChoiceTypeFound = true
														backendChoiceInt := &ves_io_schema_fleet.StorageDeviceNetappTridentType_NetappBackendOntapSan{}
														backendChoiceInt.NetappBackendOntapSan = &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType{}
														deviceChoiceInt.NetappTrident.BackendChoice = backendChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																chapChoiceTypeFound := false

																if v, ok := cs["no_chap"]; ok && !isIntfNil(v) && !chapChoiceTypeFound {

																	chapChoiceTypeFound = true

																	if v.(bool) {
																		chapChoiceInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType_NoChap{}
																		chapChoiceInt.NoChap = &ves_io_schema.Empty{}
																		backendChoiceInt.NetappBackendOntapSan.ChapChoice = chapChoiceInt
																	}

																}

																if v, ok := cs["use_chap"]; ok && !isIntfNil(v) && !chapChoiceTypeFound {

																	chapChoiceTypeFound = true
																	chapChoiceInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType_UseChap{}
																	chapChoiceInt.UseChap = &ves_io_schema_fleet.DeviceNetappBackendOntapSanChapType{}
																	backendChoiceInt.NetappBackendOntapSan.ChapChoice = chapChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["chap_initiator_secret"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				chapInitiatorSecret := &ves_io_schema.SecretType{}
																				chapChoiceInt.UseChap.ChapInitiatorSecret = chapInitiatorSecret
																				for _, set := range sl {
																					if set != nil {
																						chapInitiatorSecretMapStrToI := set.(map[string]interface{})

																						if v, ok := chapInitiatorSecretMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																							sl := v.([]interface{})
																							blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																							chapInitiatorSecret.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																							for _, set := range sl {
																								if set != nil {
																									blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																									if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																										blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																									}

																									if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																										blindfoldSecretInfoInternal.Location = w.(string)
																									}

																									if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																										blindfoldSecretInfoInternal.StoreProvider = w.(string)
																									}

																								}
																							}

																						}

																						if v, ok := chapInitiatorSecretMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																							chapInitiatorSecret.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																						}

																						secretInfoOneofTypeFound := false

																						if v, ok := chapInitiatorSecretMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																							secretInfoOneofTypeFound = true
																							secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																							secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																							chapInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																									}

																									if v, ok := cs["location"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																									}

																									if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																									}

																								}
																							}

																						}

																						if v, ok := chapInitiatorSecretMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																							secretInfoOneofTypeFound = true
																							secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																							secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																							chapInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																									}

																									if v, ok := cs["url"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																									}

																								}
																							}

																						}

																						if v, ok := chapInitiatorSecretMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																							secretInfoOneofTypeFound = true
																							secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																							secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																							chapInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["key"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																									}

																									if v, ok := cs["location"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																									}

																									if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																									}

																									if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																									}

																									if v, ok := cs["version"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																									}

																								}
																							}

																						}

																						if v, ok := chapInitiatorSecretMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																							secretInfoOneofTypeFound = true
																							secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																							secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																							chapInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["name"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																									}

																								}
																							}

																						}

																					}
																				}

																			}

																			if v, ok := cs["chap_target_initiator_secret"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				chapTargetInitiatorSecret := &ves_io_schema.SecretType{}
																				chapChoiceInt.UseChap.ChapTargetInitiatorSecret = chapTargetInitiatorSecret
																				for _, set := range sl {
																					if set != nil {
																						chapTargetInitiatorSecretMapStrToI := set.(map[string]interface{})

																						if v, ok := chapTargetInitiatorSecretMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																							sl := v.([]interface{})
																							blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																							chapTargetInitiatorSecret.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																							for _, set := range sl {
																								if set != nil {
																									blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																									if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																										blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																									}

																									if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																										blindfoldSecretInfoInternal.Location = w.(string)
																									}

																									if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																										blindfoldSecretInfoInternal.StoreProvider = w.(string)
																									}

																								}
																							}

																						}

																						if v, ok := chapTargetInitiatorSecretMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																							chapTargetInitiatorSecret.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																						}

																						secretInfoOneofTypeFound := false

																						if v, ok := chapTargetInitiatorSecretMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																							secretInfoOneofTypeFound = true
																							secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																							secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																							chapTargetInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																									}

																									if v, ok := cs["location"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																									}

																									if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																									}

																								}
																							}

																						}

																						if v, ok := chapTargetInitiatorSecretMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																							secretInfoOneofTypeFound = true
																							secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																							secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																							chapTargetInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																									}

																									if v, ok := cs["url"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																									}

																								}
																							}

																						}

																						if v, ok := chapTargetInitiatorSecretMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																							secretInfoOneofTypeFound = true
																							secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																							secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																							chapTargetInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["key"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																									}

																									if v, ok := cs["location"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																									}

																									if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																									}

																									if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																									}

																									if v, ok := cs["version"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																									}

																								}
																							}

																						}

																						if v, ok := chapTargetInitiatorSecretMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																							secretInfoOneofTypeFound = true
																							secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																							secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																							chapTargetInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["name"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																									}

																								}
																							}

																						}

																					}
																				}

																			}

																			if v, ok := cs["chap_target_username"]; ok && !isIntfNil(v) {

																				chapChoiceInt.UseChap.ChapTargetUsername = v.(string)

																			}

																			if v, ok := cs["chap_username"]; ok && !isIntfNil(v) {

																				chapChoiceInt.UseChap.ChapUsername = v.(string)

																			}

																		}
																	}

																}

																if v, ok := cs["client_certificate"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapSan.ClientCertificate = v.(string)

																}

																if v, ok := cs["client_private_key"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	clientPrivateKey := &ves_io_schema.SecretType{}
																	backendChoiceInt.NetappBackendOntapSan.ClientPrivateKey = clientPrivateKey
																	for _, set := range sl {
																		if set != nil {
																			clientPrivateKeyMapStrToI := set.(map[string]interface{})

																			if v, ok := clientPrivateKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																				clientPrivateKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																				for _, set := range sl {
																					if set != nil {
																						blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																						if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																							blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																						}

																						if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																							blindfoldSecretInfoInternal.Location = w.(string)
																						}

																						if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																							blindfoldSecretInfoInternal.StoreProvider = w.(string)
																						}

																					}
																				}

																			}

																			if v, ok := clientPrivateKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																				clientPrivateKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																			}

																			secretInfoOneofTypeFound := false

																			if v, ok := clientPrivateKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																				secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																				clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																						}

																						if v, ok := cs["location"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																						}

																						if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := clientPrivateKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																				secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																				clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																						}

																						if v, ok := cs["url"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := clientPrivateKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																				secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																				clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["key"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																						}

																						if v, ok := cs["location"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																						}

																						if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																						}

																						if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																						}

																						if v, ok := cs["version"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																						}

																					}
																				}

																			}

																			if v, ok := clientPrivateKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																				secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																				clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["name"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																dataLifTypeFound := false

																if v, ok := cs["data_lif_dns_name"]; ok && !isIntfNil(v) && !dataLifTypeFound {

																	dataLifTypeFound = true
																	dataLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType_DataLifDnsName{}

																	backendChoiceInt.NetappBackendOntapSan.DataLif = dataLifInt

																	dataLifInt.DataLifDnsName = v.(string)

																}

																if v, ok := cs["data_lif_ip"]; ok && !isIntfNil(v) && !dataLifTypeFound {

																	dataLifTypeFound = true
																	dataLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType_DataLifIp{}

																	backendChoiceInt.NetappBackendOntapSan.DataLif = dataLifInt

																	dataLifInt.DataLifIp = v.(string)

																}

																if v, ok := cs["igroup_name"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapSan.IgroupName = v.(string)

																}

																if v, ok := cs["labels"]; ok && !isIntfNil(v) {

																	ms := map[string]string{}
																	for k, v := range v.(map[string]interface{}) {
																		ms[k] = v.(string)
																	}
																	backendChoiceInt.NetappBackendOntapSan.Labels = ms
																}

																if v, ok := cs["limit_aggregate_usage"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapSan.LimitAggregateUsage = uint32(v.(int))

																}

																if v, ok := cs["limit_volume_size"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapSan.LimitVolumeSize = int32(v.(int))

																}

																managementLifTypeFound := false

																if v, ok := cs["management_lif_dns_name"]; ok && !isIntfNil(v) && !managementLifTypeFound {

																	managementLifTypeFound = true
																	managementLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName{}

																	backendChoiceInt.NetappBackendOntapSan.ManagementLif = managementLifInt

																	managementLifInt.ManagementLifDnsName = v.(string)

																}

																if v, ok := cs["management_lif_ip"]; ok && !isIntfNil(v) && !managementLifTypeFound {

																	managementLifTypeFound = true
																	managementLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType_ManagementLifIp{}

																	backendChoiceInt.NetappBackendOntapSan.ManagementLif = managementLifInt

																	managementLifInt.ManagementLifIp = v.(string)

																}

																if v, ok := cs["password"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	password := &ves_io_schema.SecretType{}
																	backendChoiceInt.NetappBackendOntapSan.Password = password
																	for _, set := range sl {
																		if set != nil {
																			passwordMapStrToI := set.(map[string]interface{})

																			if v, ok := passwordMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																				password.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																				for _, set := range sl {
																					if set != nil {
																						blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																						if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																							blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																						}

																						if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																							blindfoldSecretInfoInternal.Location = w.(string)
																						}

																						if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																							blindfoldSecretInfoInternal.StoreProvider = w.(string)
																						}

																					}
																				}

																			}

																			if v, ok := passwordMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																				password.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																			}

																			secretInfoOneofTypeFound := false

																			if v, ok := passwordMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																				secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																				password.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																						}

																						if v, ok := cs["location"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																						}

																						if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := passwordMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																				secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																				password.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																						}

																						if v, ok := cs["url"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := passwordMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																				secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																				password.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["key"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																						}

																						if v, ok := cs["location"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																						}

																						if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																						}

																						if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																						}

																						if v, ok := cs["version"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																						}

																					}
																				}

																			}

																			if v, ok := passwordMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																				secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																				password.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["name"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["region"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapSan.Region = v.(string)

																}

																if v, ok := cs["storage"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	storage := make([]*ves_io_schema_fleet.OntapVirtualStoragePoolType, len(sl))
																	backendChoiceInt.NetappBackendOntapSan.Storage = storage
																	for i, set := range sl {
																		if set != nil {
																			storage[i] = &ves_io_schema_fleet.OntapVirtualStoragePoolType{}
																			storageMapStrToI := set.(map[string]interface{})

																			if w, ok := storageMapStrToI["labels"]; ok && !isIntfNil(w) {
																				ms := map[string]string{}
																				for k, v := range w.(map[string]interface{}) {
																					ms[k] = v.(string)
																				}
																				storage[i].Labels = ms
																			}

																			if v, ok := storageMapStrToI["volume_defaults"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				volumeDefaults := &ves_io_schema_fleet.OntapVolumeDefaults{}
																				storage[i].VolumeDefaults = volumeDefaults
																				for _, set := range sl {
																					if set != nil {
																						volumeDefaultsMapStrToI := set.(map[string]interface{})

																						if w, ok := volumeDefaultsMapStrToI["encryption"]; ok && !isIntfNil(w) {
																							volumeDefaults.Encryption = w.(bool)
																						}

																						if w, ok := volumeDefaultsMapStrToI["export_policy"]; ok && !isIntfNil(w) {
																							volumeDefaults.ExportPolicy = w.(string)
																						}

																						qosPolicyChoiceTypeFound := false

																						if v, ok := volumeDefaultsMapStrToI["adaptive_qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																							qosPolicyChoiceTypeFound = true
																							qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_AdaptiveQosPolicy{}

																							volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

																							qosPolicyChoiceInt.AdaptiveQosPolicy = v.(string)

																						}

																						if v, ok := volumeDefaultsMapStrToI["no_qos"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																							qosPolicyChoiceTypeFound = true

																							if v.(bool) {
																								qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_NoQos{}
																								qosPolicyChoiceInt.NoQos = &ves_io_schema.Empty{}
																								volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt
																							}

																						}

																						if v, ok := volumeDefaultsMapStrToI["qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																							qosPolicyChoiceTypeFound = true
																							qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_QosPolicy{}

																							volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

																							qosPolicyChoiceInt.QosPolicy = v.(string)

																						}

																						if w, ok := volumeDefaultsMapStrToI["security_style"]; ok && !isIntfNil(w) {
																							volumeDefaults.SecurityStyle = w.(string)
																						}

																						if w, ok := volumeDefaultsMapStrToI["snapshot_dir"]; ok && !isIntfNil(w) {
																							volumeDefaults.SnapshotDir = w.(bool)
																						}

																						if w, ok := volumeDefaultsMapStrToI["snapshot_policy"]; ok && !isIntfNil(w) {
																							volumeDefaults.SnapshotPolicy = w.(string)
																						}

																						if w, ok := volumeDefaultsMapStrToI["snapshot_reserve"]; ok && !isIntfNil(w) {
																							volumeDefaults.SnapshotReserve = w.(string)
																						}

																						if w, ok := volumeDefaultsMapStrToI["space_reserve"]; ok && !isIntfNil(w) {
																							volumeDefaults.SpaceReserve = w.(string)
																						}

																						if w, ok := volumeDefaultsMapStrToI["split_on_clone"]; ok && !isIntfNil(w) {
																							volumeDefaults.SplitOnClone = w.(bool)
																						}

																						if w, ok := volumeDefaultsMapStrToI["tiering_policy"]; ok && !isIntfNil(w) {
																							volumeDefaults.TieringPolicy = w.(string)
																						}

																						if w, ok := volumeDefaultsMapStrToI["unix_permissions"]; ok && !isIntfNil(w) {
																							volumeDefaults.UnixPermissions = int32(w.(int))
																						}

																					}
																				}

																			}

																			if w, ok := storageMapStrToI["zone"]; ok && !isIntfNil(w) {
																				storage[i].Zone = w.(string)
																			}

																		}
																	}

																}

																if v, ok := cs["storage_driver_name"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapSan.StorageDriverName = v.(string)

																}

																if v, ok := cs["storage_prefix"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapSan.StoragePrefix = v.(string)

																}

																if v, ok := cs["svm"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapSan.Svm = v.(string)

																}

																if v, ok := cs["trusted_ca_certificate"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapSan.TrustedCaCertificate = v.(string)

																}

																if v, ok := cs["username"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapSan.Username = v.(string)

																}

																if v, ok := cs["volume_defaults"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	volumeDefaults := &ves_io_schema_fleet.OntapVolumeDefaults{}
																	backendChoiceInt.NetappBackendOntapSan.VolumeDefaults = volumeDefaults
																	for _, set := range sl {
																		if set != nil {
																			volumeDefaultsMapStrToI := set.(map[string]interface{})

																			if w, ok := volumeDefaultsMapStrToI["encryption"]; ok && !isIntfNil(w) {
																				volumeDefaults.Encryption = w.(bool)
																			}

																			if w, ok := volumeDefaultsMapStrToI["export_policy"]; ok && !isIntfNil(w) {
																				volumeDefaults.ExportPolicy = w.(string)
																			}

																			qosPolicyChoiceTypeFound := false

																			if v, ok := volumeDefaultsMapStrToI["adaptive_qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																				qosPolicyChoiceTypeFound = true
																				qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_AdaptiveQosPolicy{}

																				volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

																				qosPolicyChoiceInt.AdaptiveQosPolicy = v.(string)

																			}

																			if v, ok := volumeDefaultsMapStrToI["no_qos"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																				qosPolicyChoiceTypeFound = true

																				if v.(bool) {
																					qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_NoQos{}
																					qosPolicyChoiceInt.NoQos = &ves_io_schema.Empty{}
																					volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt
																				}

																			}

																			if v, ok := volumeDefaultsMapStrToI["qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																				qosPolicyChoiceTypeFound = true
																				qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_QosPolicy{}

																				volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

																				qosPolicyChoiceInt.QosPolicy = v.(string)

																			}

																			if w, ok := volumeDefaultsMapStrToI["security_style"]; ok && !isIntfNil(w) {
																				volumeDefaults.SecurityStyle = w.(string)
																			}

																			if w, ok := volumeDefaultsMapStrToI["snapshot_dir"]; ok && !isIntfNil(w) {
																				volumeDefaults.SnapshotDir = w.(bool)
																			}

																			if w, ok := volumeDefaultsMapStrToI["snapshot_policy"]; ok && !isIntfNil(w) {
																				volumeDefaults.SnapshotPolicy = w.(string)
																			}

																			if w, ok := volumeDefaultsMapStrToI["snapshot_reserve"]; ok && !isIntfNil(w) {
																				volumeDefaults.SnapshotReserve = w.(string)
																			}

																			if w, ok := volumeDefaultsMapStrToI["space_reserve"]; ok && !isIntfNil(w) {
																				volumeDefaults.SpaceReserve = w.(string)
																			}

																			if w, ok := volumeDefaultsMapStrToI["split_on_clone"]; ok && !isIntfNil(w) {
																				volumeDefaults.SplitOnClone = w.(bool)
																			}

																			if w, ok := volumeDefaultsMapStrToI["tiering_policy"]; ok && !isIntfNil(w) {
																				volumeDefaults.TieringPolicy = w.(string)
																			}

																			if w, ok := volumeDefaultsMapStrToI["unix_permissions"]; ok && !isIntfNil(w) {
																				volumeDefaults.UnixPermissions = int32(w.(int))
																			}

																		}
																	}

																}

															}
														}

													}

												}
											}

										}

										if v, ok := storageDevicesMapStrToI["pure_service_orchestrator"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

											deviceChoiceTypeFound = true
											deviceChoiceInt := &ves_io_schema_fleet.FleetStorageDeviceType_PureServiceOrchestrator{}
											deviceChoiceInt.PureServiceOrchestrator = &ves_io_schema_fleet.StorageDevicePureStorageServiceOrchestratorType{}
											storageDevices[i].DeviceChoice = deviceChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["arrays"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														arrays := &ves_io_schema_fleet.PsoArrayConfiguration{}
														deviceChoiceInt.PureServiceOrchestrator.Arrays = arrays
														for _, set := range sl {
															if set != nil {
																arraysMapStrToI := set.(map[string]interface{})

																if v, ok := arraysMapStrToI["flash_array"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	flashArray := &ves_io_schema_fleet.FlashArrayType{}
																	arrays.FlashArray = flashArray
																	for _, set := range sl {
																		if set != nil {
																			flashArrayMapStrToI := set.(map[string]interface{})

																			if w, ok := flashArrayMapStrToI["default_fs_opt"]; ok && !isIntfNil(w) {
																				flashArray.DefaultFsOpt = w.(string)
																			}

																			if w, ok := flashArrayMapStrToI["default_fs_type"]; ok && !isIntfNil(w) {
																				flashArray.DefaultFsType = w.(string)
																			}

																			if w, ok := flashArrayMapStrToI["default_mount_opts"]; ok && !isIntfNil(w) {
																				ls := make([]string, len(w.([]interface{})))
																				for i, v := range w.([]interface{}) {
																					ls[i] = v.(string)
																				}
																				flashArray.DefaultMountOpts = ls
																			}

																			if w, ok := flashArrayMapStrToI["disable_preempt_attachments"]; ok && !isIntfNil(w) {
																				flashArray.DisablePreemptAttachments = w.(bool)
																			}

																			if v, ok := flashArrayMapStrToI["flash_arrays"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				flashArrays := make([]*ves_io_schema_fleet.FlashArrayEndpoint, len(sl))
																				flashArray.FlashArrays = flashArrays
																				for i, set := range sl {
																					if set != nil {
																						flashArrays[i] = &ves_io_schema_fleet.FlashArrayEndpoint{}
																						flashArraysMapStrToI := set.(map[string]interface{})

																						if v, ok := flashArraysMapStrToI["api_token"]; ok && !isIntfNil(v) {

																							sl := v.([]interface{})
																							apiToken := &ves_io_schema.SecretType{}
																							flashArrays[i].ApiToken = apiToken
																							for _, set := range sl {
																								if set != nil {
																									apiTokenMapStrToI := set.(map[string]interface{})

																									if v, ok := apiTokenMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																										sl := v.([]interface{})
																										blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																										apiToken.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																										for _, set := range sl {
																											if set != nil {
																												blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																												if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																													blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																												}

																												if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																													blindfoldSecretInfoInternal.Location = w.(string)
																												}

																												if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																													blindfoldSecretInfoInternal.StoreProvider = w.(string)
																												}

																											}
																										}

																									}

																									if v, ok := apiTokenMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																										apiToken.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																									}

																									secretInfoOneofTypeFound := false

																									if v, ok := apiTokenMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																										secretInfoOneofTypeFound = true
																										secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																										secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																										apiToken.SecretInfoOneof = secretInfoOneofInt

																										sl := v.([]interface{})
																										for _, set := range sl {
																											if set != nil {
																												cs := set.(map[string]interface{})

																												if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																												}

																												if v, ok := cs["location"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																												}

																												if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																												}

																											}
																										}

																									}

																									if v, ok := apiTokenMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																										secretInfoOneofTypeFound = true
																										secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																										secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																										apiToken.SecretInfoOneof = secretInfoOneofInt

																										sl := v.([]interface{})
																										for _, set := range sl {
																											if set != nil {
																												cs := set.(map[string]interface{})

																												if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																												}

																												if v, ok := cs["url"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																												}

																											}
																										}

																									}

																									if v, ok := apiTokenMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																										secretInfoOneofTypeFound = true
																										secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																										secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																										apiToken.SecretInfoOneof = secretInfoOneofInt

																										sl := v.([]interface{})
																										for _, set := range sl {
																											if set != nil {
																												cs := set.(map[string]interface{})

																												if v, ok := cs["key"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																												}

																												if v, ok := cs["location"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																												}

																												if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																												}

																												if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																												}

																												if v, ok := cs["version"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																												}

																											}
																										}

																									}

																									if v, ok := apiTokenMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																										secretInfoOneofTypeFound = true
																										secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																										secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																										apiToken.SecretInfoOneof = secretInfoOneofInt

																										sl := v.([]interface{})
																										for _, set := range sl {
																											if set != nil {
																												cs := set.(map[string]interface{})

																												if v, ok := cs["name"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																												}

																											}
																										}

																									}

																								}
																							}

																						}

																						if w, ok := flashArraysMapStrToI["labels"]; ok && !isIntfNil(w) {
																							ms := map[string]string{}
																							for k, v := range w.(map[string]interface{}) {
																								ms[k] = v.(string)
																							}
																							flashArrays[i].Labels = ms
																						}

																						mgmtEndpointTypeFound := false

																						if v, ok := flashArraysMapStrToI["mgmt_dns_name"]; ok && !isIntfNil(v) && !mgmtEndpointTypeFound {

																							mgmtEndpointTypeFound = true
																							mgmtEndpointInt := &ves_io_schema_fleet.FlashArrayEndpoint_MgmtDnsName{}

																							flashArrays[i].MgmtEndpoint = mgmtEndpointInt

																							mgmtEndpointInt.MgmtDnsName = v.(string)

																						}

																						if v, ok := flashArraysMapStrToI["mgmt_ip"]; ok && !isIntfNil(v) && !mgmtEndpointTypeFound {

																							mgmtEndpointTypeFound = true
																							mgmtEndpointInt := &ves_io_schema_fleet.FlashArrayEndpoint_MgmtIp{}

																							flashArrays[i].MgmtEndpoint = mgmtEndpointInt

																							mgmtEndpointInt.MgmtIp = v.(string)

																						}

																					}
																				}

																			}

																			if w, ok := flashArrayMapStrToI["iscsi_login_timeout"]; ok && !isIntfNil(w) {
																				flashArray.IscsiLoginTimeout = int32(w.(int))
																			}

																			if w, ok := flashArrayMapStrToI["san_type"]; ok && !isIntfNil(w) {
																				flashArray.SanType = w.(string)
																			}

																		}
																	}

																}

																if v, ok := arraysMapStrToI["flash_blade"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	flashBlade := &ves_io_schema_fleet.FlashBladeType{}
																	arrays.FlashBlade = flashBlade
																	for _, set := range sl {
																		if set != nil {
																			flashBladeMapStrToI := set.(map[string]interface{})

																			if w, ok := flashBladeMapStrToI["enable_snapshot_directory"]; ok && !isIntfNil(w) {
																				flashBlade.EnableSnapshotDirectory = w.(bool)
																			}

																			if w, ok := flashBladeMapStrToI["export_rules"]; ok && !isIntfNil(w) {
																				flashBlade.ExportRules = w.(string)
																			}

																			if v, ok := flashBladeMapStrToI["flash_blades"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				flashBlades := make([]*ves_io_schema_fleet.FlashBladeEndpoint, len(sl))
																				flashBlade.FlashBlades = flashBlades
																				for i, set := range sl {
																					if set != nil {
																						flashBlades[i] = &ves_io_schema_fleet.FlashBladeEndpoint{}
																						flashBladesMapStrToI := set.(map[string]interface{})

																						if v, ok := flashBladesMapStrToI["api_token"]; ok && !isIntfNil(v) {

																							sl := v.([]interface{})
																							apiToken := &ves_io_schema.SecretType{}
																							flashBlades[i].ApiToken = apiToken
																							for _, set := range sl {
																								if set != nil {
																									apiTokenMapStrToI := set.(map[string]interface{})

																									if v, ok := apiTokenMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																										sl := v.([]interface{})
																										blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																										apiToken.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																										for _, set := range sl {
																											if set != nil {
																												blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																												if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																													blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																												}

																												if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																													blindfoldSecretInfoInternal.Location = w.(string)
																												}

																												if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																													blindfoldSecretInfoInternal.StoreProvider = w.(string)
																												}

																											}
																										}

																									}

																									if v, ok := apiTokenMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																										apiToken.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																									}

																									secretInfoOneofTypeFound := false

																									if v, ok := apiTokenMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																										secretInfoOneofTypeFound = true
																										secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																										secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																										apiToken.SecretInfoOneof = secretInfoOneofInt

																										sl := v.([]interface{})
																										for _, set := range sl {
																											if set != nil {
																												cs := set.(map[string]interface{})

																												if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																												}

																												if v, ok := cs["location"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																												}

																												if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																												}

																											}
																										}

																									}

																									if v, ok := apiTokenMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																										secretInfoOneofTypeFound = true
																										secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																										secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																										apiToken.SecretInfoOneof = secretInfoOneofInt

																										sl := v.([]interface{})
																										for _, set := range sl {
																											if set != nil {
																												cs := set.(map[string]interface{})

																												if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																												}

																												if v, ok := cs["url"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																												}

																											}
																										}

																									}

																									if v, ok := apiTokenMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																										secretInfoOneofTypeFound = true
																										secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																										secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																										apiToken.SecretInfoOneof = secretInfoOneofInt

																										sl := v.([]interface{})
																										for _, set := range sl {
																											if set != nil {
																												cs := set.(map[string]interface{})

																												if v, ok := cs["key"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																												}

																												if v, ok := cs["location"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																												}

																												if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																												}

																												if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																												}

																												if v, ok := cs["version"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																												}

																											}
																										}

																									}

																									if v, ok := apiTokenMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																										secretInfoOneofTypeFound = true
																										secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																										secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																										apiToken.SecretInfoOneof = secretInfoOneofInt

																										sl := v.([]interface{})
																										for _, set := range sl {
																											if set != nil {
																												cs := set.(map[string]interface{})

																												if v, ok := cs["name"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																												}

																											}
																										}

																									}

																								}
																							}

																						}

																						if w, ok := flashBladesMapStrToI["lables"]; ok && !isIntfNil(w) {
																							ms := map[string]string{}
																							for k, v := range w.(map[string]interface{}) {
																								ms[k] = v.(string)
																							}
																							flashBlades[i].Lables = ms
																						}

																						mgmtEndpointTypeFound := false

																						if v, ok := flashBladesMapStrToI["mgmt_dns_name"]; ok && !isIntfNil(v) && !mgmtEndpointTypeFound {

																							mgmtEndpointTypeFound = true
																							mgmtEndpointInt := &ves_io_schema_fleet.FlashBladeEndpoint_MgmtDnsName{}

																							flashBlades[i].MgmtEndpoint = mgmtEndpointInt

																							mgmtEndpointInt.MgmtDnsName = v.(string)

																						}

																						if v, ok := flashBladesMapStrToI["mgmt_ip"]; ok && !isIntfNil(v) && !mgmtEndpointTypeFound {

																							mgmtEndpointTypeFound = true
																							mgmtEndpointInt := &ves_io_schema_fleet.FlashBladeEndpoint_MgmtIp{}

																							flashBlades[i].MgmtEndpoint = mgmtEndpointInt

																							mgmtEndpointInt.MgmtIp = v.(string)

																						}

																						nfsEndpointTypeFound := false

																						if v, ok := flashBladesMapStrToI["nfs_endpoint_dns_name"]; ok && !isIntfNil(v) && !nfsEndpointTypeFound {

																							nfsEndpointTypeFound = true
																							nfsEndpointInt := &ves_io_schema_fleet.FlashBladeEndpoint_NfsEndpointDnsName{}

																							flashBlades[i].NfsEndpoint = nfsEndpointInt

																							nfsEndpointInt.NfsEndpointDnsName = v.(string)

																						}

																						if v, ok := flashBladesMapStrToI["nfs_endpoint_ip"]; ok && !isIntfNil(v) && !nfsEndpointTypeFound {

																							nfsEndpointTypeFound = true
																							nfsEndpointInt := &ves_io_schema_fleet.FlashBladeEndpoint_NfsEndpointIp{}

																							flashBlades[i].NfsEndpoint = nfsEndpointInt

																							nfsEndpointInt.NfsEndpointIp = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := cs["cluster_id"]; ok && !isIntfNil(v) {

														deviceChoiceInt.PureServiceOrchestrator.ClusterId = v.(string)

													}

													if v, ok := cs["enable_storage_topology"]; ok && !isIntfNil(v) {

														deviceChoiceInt.PureServiceOrchestrator.EnableStorageTopology = v.(bool)

													}

													if v, ok := cs["enable_strict_topology"]; ok && !isIntfNil(v) {

														deviceChoiceInt.PureServiceOrchestrator.EnableStrictTopology = v.(bool)

													}

												}
											}

										}

										if w, ok := storageDevicesMapStrToI["storage_device"]; ok && !isIntfNil(w) {
											storageDevices[i].StorageDevice = w.(string)
										}

									}
								}

							}

						}
					}

				}

				storageInterfaceChoiceTypeFound := false

				if v, ok := cs["no_storage_interfaces"]; ok && !isIntfNil(v) && !storageInterfaceChoiceTypeFound {

					storageInterfaceChoiceTypeFound = true

					if v.(bool) {
						storageInterfaceChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_NoStorageInterfaces{}
						storageInterfaceChoiceInt.NoStorageInterfaces = &ves_io_schema.Empty{}
						storageCfgChoiceInt.CustomStorageConfig.StorageInterfaceChoice = storageInterfaceChoiceInt
					}

				}

				if v, ok := cs["storage_interface_list"]; ok && !isIntfNil(v) && !storageInterfaceChoiceTypeFound {

					storageInterfaceChoiceTypeFound = true
					storageInterfaceChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_StorageInterfaceList{}
					storageInterfaceChoiceInt.StorageInterfaceList = &ves_io_schema_views_voltstack_site.StorageInterfaceListType{}
					storageCfgChoiceInt.CustomStorageConfig.StorageInterfaceChoice = storageInterfaceChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["storage_interfaces"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								storageInterfaces := make([]*ves_io_schema_views_voltstack_site.StorageInterfaceType, len(sl))
								storageInterfaceChoiceInt.StorageInterfaceList.StorageInterfaces = storageInterfaces
								for i, set := range sl {
									if set != nil {
										storageInterfaces[i] = &ves_io_schema_views_voltstack_site.StorageInterfaceType{}
										storageInterfacesMapStrToI := set.(map[string]interface{})

										if w, ok := storageInterfacesMapStrToI["description"]; ok && !isIntfNil(w) {
											storageInterfaces[i].Description = w.(string)
										}

										if w, ok := storageInterfacesMapStrToI["labels"]; ok && !isIntfNil(w) {
											ms := map[string]string{}
											for k, v := range w.(map[string]interface{}) {
												ms[k] = v.(string)
											}
											storageInterfaces[i].Labels = ms
										}

										if v, ok := storageInterfacesMapStrToI["storage_interface"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											storageInterface := &ves_io_schema_network_interface.EthernetInterfaceType{}
											storageInterfaces[i].StorageInterface = storageInterface
											for _, set := range sl {
												if set != nil {
													storageInterfaceMapStrToI := set.(map[string]interface{})

													addressChoiceTypeFound := false

													if v, ok := storageInterfaceMapStrToI["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true

														if v.(bool) {
															addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_DhcpClient{}
															addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
															storageInterface.AddressChoice = addressChoiceInt
														}

													}

													if v, ok := storageInterfaceMapStrToI["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_DhcpServer{}
														addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
														storageInterface.AddressChoice = addressChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
																	addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
																	for i, set := range sl {
																		if set != nil {
																			dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
																			dhcpNetworksMapStrToI := set.(map[string]interface{})

																			dnsChoiceTypeFound := false

																			if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																				dnsChoiceTypeFound = true
																				dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

																				dhcpNetworks[i].DnsChoice = dnsChoiceInt

																				dnsChoiceInt.DnsAddress = v.(string)

																			}

																			if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																				dnsChoiceTypeFound = true

																				if v.(bool) {
																					dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
																					dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
																					dhcpNetworks[i].DnsChoice = dnsChoiceInt
																				}

																			}

																			gatewayChoiceTypeFound := false

																			if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

																				gatewayChoiceTypeFound = true
																				gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

																				dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

																				gatewayChoiceInt.DgwAddress = v.(string)

																			}

																			if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

																				gatewayChoiceTypeFound = true

																				if v.(bool) {
																					gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
																					gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																					dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
																				}

																			}

																			if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

																				gatewayChoiceTypeFound = true

																				if v.(bool) {
																					gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
																					gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
																					dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
																				}

																			}

																			networkPrefixChoiceTypeFound := false

																			if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																				networkPrefixChoiceTypeFound = true
																				networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

																				dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																				networkPrefixChoiceInt.NetworkPrefix = v.(string)

																			}

																			if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																				networkPrefixChoiceTypeFound = true
																				networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
																				networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																				dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["name"]; ok && !isIntfNil(v) {

																							networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																						}

																						if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																							networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																						}

																						if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																							networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

																				dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

																			}

																			if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
																				dhcpNetworks[i].Pools = pools
																				for i, set := range sl {
																					if set != nil {
																						pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
																						poolsMapStrToI := set.(map[string]interface{})

																						if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																							pools[i].EndIp = w.(string)
																						}

																						if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																							pools[i].Exclude = w.(bool)
																						}

																						if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																							pools[i].StartIp = w.(string)
																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

																	addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

																}

																if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																	ms := map[string]string{}
																	for k, v := range v.(map[string]interface{}) {
																		ms[k] = v.(string)
																	}
																	addressChoiceInt.DhcpServer.FixedIpMap = ms
																}

																interfacesAddressingChoiceTypeFound := false

																if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																	interfacesAddressingChoiceTypeFound = true

																	if v.(bool) {
																		interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
																		interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																		addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																	}

																}

																if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																	interfacesAddressingChoiceTypeFound = true

																	if v.(bool) {
																		interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
																		interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																		addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																	}

																}

																if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																	interfacesAddressingChoiceTypeFound = true
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
																	interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
																	addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																				ms := map[string]string{}
																				for k, v := range v.(map[string]interface{}) {
																					ms[k] = v.(string)
																				}
																				interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := storageInterfaceMapStrToI["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StaticIp{}
														addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIPParametersType{}
														storageInterface.AddressChoice = addressChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																networkPrefixChoiceTypeFound := false

																if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
																	networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
																	addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
																				networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
																				for _, set := range sl {
																					if set != nil {
																						interfaceIpMapMapStrToI := set.(map[string]interface{})
																						key, ok := interfaceIpMapMapStrToI["name"]
																						if ok && !isIntfNil(key) {
																							interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																							val, _ := interfaceIpMapMapStrToI["value"]

																							interfaceIpMapVals := val.([]interface{})
																							for _, intVal := range interfaceIpMapVals {
																								if intVal != nil {

																									interfaceIpMapStaticMap := intVal.(map[string]interface{})

																									if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DefaultGw = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DnsServer = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].IpAddress = w.(string)
																									}

																									// break after one loop
																									break
																								}
																							}
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
																	networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
																	addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
																				networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

																				for _, set := range sl {
																					if set != nil {
																						npaMapToStrVal := set.(map[string]interface{})
																						if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Name = val.(string)
																						}
																						if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Namespace = val.(string)
																						}

																						if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Tenant = val.(string)
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
																	networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																	addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

													if w, ok := storageInterfaceMapStrToI["device"]; ok && !isIntfNil(w) {
														storageInterface.Device = w.(string)
													}

													ipv6AddressChoiceTypeFound := false

													if v, ok := storageInterfaceMapStrToI["ipv6_auto_config"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

														ipv6AddressChoiceTypeFound = true
														ipv6AddressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Ipv6AutoConfig{}
														ipv6AddressChoiceInt.Ipv6AutoConfig = &ves_io_schema_network_interface.IPV6AutoConfigType{}
														storageInterface.Ipv6AddressChoice = ipv6AddressChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																autoconfigChoiceTypeFound := false

																if v, ok := cs["host"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

																	autoconfigChoiceTypeFound = true

																	if v.(bool) {
																		autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Host{}
																		autoconfigChoiceInt.Host = &ves_io_schema.Empty{}
																		ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt
																	}

																}

																if v, ok := cs["router"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

																	autoconfigChoiceTypeFound = true
																	autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Router{}
																	autoconfigChoiceInt.Router = &ves_io_schema_network_interface.IPV6AutoConfigRouterType{}
																	ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			addressChoiceTypeFound := false

																			if v, ok := cs["network_prefix"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

																				addressChoiceTypeFound = true
																				addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_NetworkPrefix{}

																				autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

																				addressChoiceInt.NetworkPrefix = v.(string)

																			}

																			if v, ok := cs["stateful"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

																				addressChoiceTypeFound = true
																				addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_Stateful{}
																				addressChoiceInt.Stateful = &ves_io_schema_network_interface.DHCPIPV6StatefulServer{}
																				autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																							sl := v.([]interface{})
																							dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPIPV6NetworkType, len(sl))
																							addressChoiceInt.Stateful.DhcpNetworks = dhcpNetworks
																							for i, set := range sl {
																								if set != nil {
																									dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPIPV6NetworkType{}
																									dhcpNetworksMapStrToI := set.(map[string]interface{})

																									networkPrefixChoiceTypeFound := false

																									if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																										networkPrefixChoiceTypeFound = true
																										networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefix{}

																										dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																										networkPrefixChoiceInt.NetworkPrefix = v.(string)

																									}

																									if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																										networkPrefixChoiceTypeFound = true
																										networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefixAllocator{}
																										networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																										dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																										sl := v.([]interface{})
																										for _, set := range sl {
																											if set != nil {
																												cs := set.(map[string]interface{})

																												if v, ok := cs["name"]; ok && !isIntfNil(v) {

																													networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																												}

																												if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																													networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																												}

																												if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																													networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																												}

																											}
																										}

																									}

																									if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

																										dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

																									}

																									if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																										sl := v.([]interface{})
																										pools := make([]*ves_io_schema_network_interface.DHCPIPV6PoolType, len(sl))
																										dhcpNetworks[i].Pools = pools
																										for i, set := range sl {
																											if set != nil {
																												pools[i] = &ves_io_schema_network_interface.DHCPIPV6PoolType{}
																												poolsMapStrToI := set.(map[string]interface{})

																												if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																													pools[i].EndIp = w.(string)
																												}

																												if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																													pools[i].Exclude = w.(bool)
																												}

																												if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																													pools[i].StartIp = w.(string)
																												}

																											}
																										}

																									}

																								}
																							}

																						}

																						if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																							ms := map[string]string{}
																							for k, v := range v.(map[string]interface{}) {
																								ms[k] = v.(string)
																							}
																							addressChoiceInt.Stateful.FixedIpMap = ms
																						}

																						interfacesAddressingChoiceTypeFound := false

																						if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																							interfacesAddressingChoiceTypeFound = true

																							if v.(bool) {
																								interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromEnd{}
																								interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																								addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																							}

																						}

																						if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																							interfacesAddressingChoiceTypeFound = true

																							if v.(bool) {
																								interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromStart{}
																								interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																								addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																							}

																						}

																						if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																							interfacesAddressingChoiceTypeFound = true
																							interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_InterfaceIpMap{}
																							interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPV6Type{}
																							addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																										ms := map[string]string{}
																										for k, v := range v.(map[string]interface{}) {
																											ms[k] = v.(string)
																										}
																										interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																									}

																								}
																							}

																						}

																					}
																				}

																			}

																			if v, ok := cs["dns_config"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				dnsConfig := &ves_io_schema_network_interface.IPV6DnsConfig{}
																				autoconfigChoiceInt.Router.DnsConfig = dnsConfig
																				for _, set := range sl {
																					if set != nil {
																						dnsConfigMapStrToI := set.(map[string]interface{})

																						dnsChoiceTypeFound := false

																						if v, ok := dnsConfigMapStrToI["configured_list"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																							dnsChoiceTypeFound = true
																							dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_ConfiguredList{}
																							dnsChoiceInt.ConfiguredList = &ves_io_schema_network_interface.IPV6DnsList{}
																							dnsConfig.DnsChoice = dnsChoiceInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["dns_list"]; ok && !isIntfNil(v) {

																										ls := make([]string, len(v.([]interface{})))
																										for i, v := range v.([]interface{}) {
																											ls[i] = v.(string)
																										}
																										dnsChoiceInt.ConfiguredList.DnsList = ls

																									}

																								}
																							}

																						}

																						if v, ok := dnsConfigMapStrToI["local_dns"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																							dnsChoiceTypeFound = true
																							dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_LocalDns{}
																							dnsChoiceInt.LocalDns = &ves_io_schema_network_interface.IPV6LocalDnsAddress{}
																							dnsConfig.DnsChoice = dnsChoiceInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									localDnsChoiceTypeFound := false

																									if v, ok := cs["configured_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																										localDnsChoiceTypeFound = true
																										localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_ConfiguredAddress{}

																										dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt

																										localDnsChoiceInt.ConfiguredAddress = v.(string)

																									}

																									if v, ok := cs["first_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																										localDnsChoiceTypeFound = true

																										if v.(bool) {
																											localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_FirstAddress{}
																											localDnsChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																											dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																										}

																									}

																									if v, ok := cs["last_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																										localDnsChoiceTypeFound = true

																										if v.(bool) {
																											localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_LastAddress{}
																											localDnsChoiceInt.LastAddress = &ves_io_schema.Empty{}
																											dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																										}

																									}

																								}
																							}

																						}

																					}
																				}

																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := storageInterfaceMapStrToI["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

														ipv6AddressChoiceTypeFound = true

														if v.(bool) {
															ipv6AddressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_NoIpv6Address{}
															ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
															storageInterface.Ipv6AddressChoice = ipv6AddressChoiceInt
														}

													}

													if v, ok := storageInterfaceMapStrToI["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

														ipv6AddressChoiceTypeFound = true
														ipv6AddressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StaticIpv6Address{}
														ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
														storageInterface.Ipv6AddressChoice = ipv6AddressChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																networkPrefixChoiceTypeFound := false

																if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
																	networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
																	ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
																				networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
																				for _, set := range sl {
																					if set != nil {
																						interfaceIpMapMapStrToI := set.(map[string]interface{})
																						key, ok := interfaceIpMapMapStrToI["name"]
																						if ok && !isIntfNil(key) {
																							interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																							val, _ := interfaceIpMapMapStrToI["value"]

																							interfaceIpMapVals := val.([]interface{})
																							for _, intVal := range interfaceIpMapVals {
																								if intVal != nil {

																									interfaceIpMapStaticMap := intVal.(map[string]interface{})

																									if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DefaultGw = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DnsServer = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].IpAddress = w.(string)
																									}

																									// break after one loop
																									break
																								}
																							}
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
																	networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
																	ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
																				networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

																				for _, set := range sl {
																					if set != nil {
																						npaMapToStrVal := set.(map[string]interface{})
																						if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Name = val.(string)
																						}
																						if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Namespace = val.(string)
																						}

																						if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Tenant = val.(string)
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
																	networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																	ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

													monitoringChoiceTypeFound := false

													if _, ok := storageInterfaceMapStrToI["monitor"]; ok && !monitoringChoiceTypeFound {

														monitoringChoiceTypeFound = true
														monitoringChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Monitor{}
														monitoringChoiceInt.Monitor = &ves_io_schema_network_interface.LinkQualityMonitorConfig{}
														storageInterface.MonitoringChoice = monitoringChoiceInt

													}

													if v, ok := storageInterfaceMapStrToI["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

														monitoringChoiceTypeFound = true

														if v.(bool) {
															monitoringChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_MonitorDisabled{}
															monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
															storageInterface.MonitoringChoice = monitoringChoiceInt
														}

													}

													if w, ok := storageInterfaceMapStrToI["mtu"]; ok && !isIntfNil(w) {
														storageInterface.Mtu = uint32(w.(int))
													}

													networkChoiceTypeFound := false

													if v, ok := storageInterfaceMapStrToI["inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true
														networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_InsideNetwork{}
														networkChoiceInt.InsideNetwork = &ves_io_schema_views.ObjectRefType{}
														storageInterface.NetworkChoice = networkChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	networkChoiceInt.InsideNetwork.Name = v.(string)

																}

																if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																	networkChoiceInt.InsideNetwork.Namespace = v.(string)

																}

																if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																	networkChoiceInt.InsideNetwork.Tenant = v.(string)

																}

															}
														}

													}

													if v, ok := storageInterfaceMapStrToI["ip_fabric_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true

														if v.(bool) {
															networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_IpFabricNetwork{}
															networkChoiceInt.IpFabricNetwork = &ves_io_schema.Empty{}
															storageInterface.NetworkChoice = networkChoiceInt
														}

													}

													if v, ok := storageInterfaceMapStrToI["segment_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true
														networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SegmentNetwork{}
														networkChoiceInt.SegmentNetwork = &ves_io_schema_views.ObjectRefType{}
														storageInterface.NetworkChoice = networkChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	networkChoiceInt.SegmentNetwork.Name = v.(string)

																}

																if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																	networkChoiceInt.SegmentNetwork.Namespace = v.(string)

																}

																if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																	networkChoiceInt.SegmentNetwork.Tenant = v.(string)

																}

															}
														}

													}

													if v, ok := storageInterfaceMapStrToI["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true

														if v.(bool) {
															networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SiteLocalInsideNetwork{}
															networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
															storageInterface.NetworkChoice = networkChoiceInt
														}

													}

													if v, ok := storageInterfaceMapStrToI["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true

														if v.(bool) {
															networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SiteLocalNetwork{}
															networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
															storageInterface.NetworkChoice = networkChoiceInt
														}

													}

													if v, ok := storageInterfaceMapStrToI["srv6_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true
														networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Srv6Network{}
														networkChoiceInt.Srv6Network = &ves_io_schema_views.ObjectRefType{}
														storageInterface.NetworkChoice = networkChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	networkChoiceInt.Srv6Network.Name = v.(string)

																}

																if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																	networkChoiceInt.Srv6Network.Namespace = v.(string)

																}

																if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																	networkChoiceInt.Srv6Network.Tenant = v.(string)

																}

															}
														}

													}

													if v, ok := storageInterfaceMapStrToI["storage_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true

														if v.(bool) {
															networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StorageNetwork{}
															networkChoiceInt.StorageNetwork = &ves_io_schema.Empty{}
															storageInterface.NetworkChoice = networkChoiceInt
														}

													}

													nodeChoiceTypeFound := false

													if v, ok := storageInterfaceMapStrToI["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

														nodeChoiceTypeFound = true

														if v.(bool) {
															nodeChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Cluster{}
															nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
															storageInterface.NodeChoice = nodeChoiceInt
														}

													}

													if v, ok := storageInterfaceMapStrToI["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

														nodeChoiceTypeFound = true
														nodeChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Node{}

														storageInterface.NodeChoice = nodeChoiceInt

														nodeChoiceInt.Node = v.(string)

													}

													primaryChoiceTypeFound := false

													if v, ok := storageInterfaceMapStrToI["is_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

														primaryChoiceTypeFound = true

														if v.(bool) {
															primaryChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_IsPrimary{}
															primaryChoiceInt.IsPrimary = &ves_io_schema.Empty{}
															storageInterface.PrimaryChoice = primaryChoiceInt
														}

													}

													if v, ok := storageInterfaceMapStrToI["not_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

														primaryChoiceTypeFound = true

														if v.(bool) {
															primaryChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_NotPrimary{}
															primaryChoiceInt.NotPrimary = &ves_io_schema.Empty{}
															storageInterface.PrimaryChoice = primaryChoiceInt
														}

													}

													if w, ok := storageInterfaceMapStrToI["priority"]; ok && !isIntfNil(w) {
														storageInterface.Priority = uint32(w.(int))
													}

													vlanChoiceTypeFound := false

													if v, ok := storageInterfaceMapStrToI["untagged"]; ok && !isIntfNil(v) && !vlanChoiceTypeFound {

														vlanChoiceTypeFound = true

														if v.(bool) {
															vlanChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Untagged{}
															vlanChoiceInt.Untagged = &ves_io_schema.Empty{}
															storageInterface.VlanChoice = vlanChoiceInt
														}

													}

													if v, ok := storageInterfaceMapStrToI["vlan_id"]; ok && !isIntfNil(v) && !vlanChoiceTypeFound {

														vlanChoiceTypeFound = true
														vlanChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_VlanId{}

														storageInterface.VlanChoice = vlanChoiceInt

														vlanChoiceInt.VlanId = uint32(v.(int))

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("default_storage_config"); ok && !storageCfgChoiceTypeFound {

		storageCfgChoiceTypeFound = true

		if v.(bool) {
			storageCfgChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_DefaultStorageConfig{}
			storageCfgChoiceInt.DefaultStorageConfig = &ves_io_schema.Empty{}
			createSpec.StorageCfgChoice = storageCfgChoiceInt
		}

	}

	//sw
	if v, ok := d.GetOk("sw"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		sw := &ves_io_schema_views.VolterraSoftwareType{}
		createSpec.Sw = sw
		for _, set := range sl {
			if set != nil {
				swMapStrToI := set.(map[string]interface{})

				volterraSwVersionChoiceTypeFound := false

				if v, ok := swMapStrToI["default_sw_version"]; ok && !isIntfNil(v) && !volterraSwVersionChoiceTypeFound {

					volterraSwVersionChoiceTypeFound = true

					if v.(bool) {
						volterraSwVersionChoiceInt := &ves_io_schema_views.VolterraSoftwareType_DefaultSwVersion{}
						volterraSwVersionChoiceInt.DefaultSwVersion = &ves_io_schema.Empty{}
						sw.VolterraSwVersionChoice = volterraSwVersionChoiceInt
					}

				}

				if v, ok := swMapStrToI["volterra_software_version"]; ok && !isIntfNil(v) && !volterraSwVersionChoiceTypeFound {

					volterraSwVersionChoiceTypeFound = true
					volterraSwVersionChoiceInt := &ves_io_schema_views.VolterraSoftwareType_VolterraSoftwareVersion{}

					sw.VolterraSwVersionChoice = volterraSwVersionChoiceInt

					volterraSwVersionChoiceInt.VolterraSoftwareVersion = v.(string)

				}

			}
		}

	}

	//usb_policy_choice

	usbPolicyChoiceTypeFound := false

	if v, ok := d.GetOk("allow_all_usb"); ok && !usbPolicyChoiceTypeFound {

		usbPolicyChoiceTypeFound = true

		if v.(bool) {
			usbPolicyChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_AllowAllUsb{}
			usbPolicyChoiceInt.AllowAllUsb = &ves_io_schema.Empty{}
			createSpec.UsbPolicyChoice = usbPolicyChoiceInt
		}

	}

	if v, ok := d.GetOk("deny_all_usb"); ok && !usbPolicyChoiceTypeFound {

		usbPolicyChoiceTypeFound = true

		if v.(bool) {
			usbPolicyChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_DenyAllUsb{}
			usbPolicyChoiceInt.DenyAllUsb = &ves_io_schema.Empty{}
			createSpec.UsbPolicyChoice = usbPolicyChoiceInt
		}

	}

	if v, ok := d.GetOk("usb_policy"); ok && !usbPolicyChoiceTypeFound {

		usbPolicyChoiceTypeFound = true
		usbPolicyChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_UsbPolicy{}
		usbPolicyChoiceInt.UsbPolicy = &ves_io_schema_views.ObjectRefType{}
		createSpec.UsbPolicyChoice = usbPolicyChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["name"]; ok && !isIntfNil(v) {

					usbPolicyChoiceInt.UsbPolicy.Name = v.(string)

				}

				if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

					usbPolicyChoiceInt.UsbPolicy.Namespace = v.(string)

				}

				if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

					usbPolicyChoiceInt.UsbPolicy.Tenant = v.(string)

				}

			}
		}

	}

	//vm_choice

	vmChoiceTypeFound := false

	if v, ok := d.GetOk("disable_vm"); ok && !vmChoiceTypeFound {

		vmChoiceTypeFound = true

		if v.(bool) {
			vmChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_DisableVm{}
			vmChoiceInt.DisableVm = &ves_io_schema.Empty{}
			createSpec.VmChoice = vmChoiceInt
		}

	}

	if _, ok := d.GetOk("enable_vm"); ok && !vmChoiceTypeFound {

		vmChoiceTypeFound = true
		vmChoiceInt := &ves_io_schema_views_voltstack_site.CreateSpecType_EnableVm{}
		vmChoiceInt.EnableVm = &ves_io_schema_fleet.VMConfiguration{}
		createSpec.VmChoice = vmChoiceInt

	}

	//volterra_certified_hw
	if v, ok := d.GetOk("volterra_certified_hw"); ok && !isIntfNil(v) {

		createSpec.VolterraCertifiedHw =
			v.(string)

	}

	//worker_nodes
	if v, ok := d.GetOk("worker_nodes"); ok && !isIntfNil(v) {

		ls := make([]string, len(v.([]interface{})))
		for i, v := range v.([]interface{}) {
			ls[i] = v.(string)
		}
		createSpec.WorkerNodes = ls

	}

	log.Printf("[DEBUG] Creating Volterra VoltstackSite object with struct: %+v", createReq)

	createVoltstackSiteResp, err := client.CreateObject(context.Background(), ves_io_schema_views_voltstack_site.ObjectType, createReq)
	if err != nil {
		return fmt.Errorf("error creating VoltstackSite: %s", err)
	}
	d.SetId(createVoltstackSiteResp.GetObjSystemMetadata().GetUid())

	return resourceVolterraVoltstackSiteRead(d, meta)
}

func resourceVolterraVoltstackSiteRead(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	resp, err := client.GetObject(context.Background(), ves_io_schema_views_voltstack_site.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] VoltstackSite %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra VoltstackSite %q: %s", d.Id(), err)
	}
	return setVoltstackSiteFields(client, d, resp)
}

func setVoltstackSiteFields(client *APIClient, d *schema.ResourceData, resp vesapi.GetObjectResponse) error {
	metadata := resp.GetObjMetadata()

	d.Set("annotations", metadata.GetAnnotations())

	d.Set("description", metadata.GetDescription())

	d.Set("disable", metadata.GetDisable())

	d.Set("labels", metadata.GetLabels())

	d.Set("name", metadata.GetName())

	d.Set("namespace", metadata.GetNamespace())

	return nil
}

// resourceVolterraVoltstackSiteUpdate updates VoltstackSite resource
func resourceVolterraVoltstackSiteUpdate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	updateMeta := &ves_io_schema.ObjectReplaceMetaType{}
	updateSpec := &ves_io_schema_views_voltstack_site.ReplaceSpecType{}
	updateReq := &ves_io_schema_views_voltstack_site.ReplaceRequest{
		Metadata: updateMeta,
		Spec:     updateSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		updateMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		updateMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		updateMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		updateMeta.Namespace =
			v.(string)
	}

	if v, ok := d.GetOk("address"); ok && !isIntfNil(v) {

		updateSpec.Address =
			v.(string)

	}

	blockedServicesChoiceTypeFound := false

	if v, ok := d.GetOk("blocked_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true
		blockedServicesChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_BlockedServices{}
		blockedServicesChoiceInt.BlockedServices = &ves_io_schema_fleet.BlockedServicesListType{}
		updateSpec.BlockedServicesChoice = blockedServicesChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["blocked_sevice"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					blockedSevice := make([]*ves_io_schema_fleet.BlockedServices, len(sl))
					blockedServicesChoiceInt.BlockedServices.BlockedSevice = blockedSevice
					for i, set := range sl {
						if set != nil {
							blockedSevice[i] = &ves_io_schema_fleet.BlockedServices{}
							blockedSeviceMapStrToI := set.(map[string]interface{})

							blockedServicesValueTypeChoiceTypeFound := false

							if v, ok := blockedSeviceMapStrToI["dns"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

								blockedServicesValueTypeChoiceTypeFound = true

								if v.(bool) {
									blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Dns{}
									blockedServicesValueTypeChoiceInt.Dns = &ves_io_schema.Empty{}
									blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
								}

							}

							if v, ok := blockedSeviceMapStrToI["ssh"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

								blockedServicesValueTypeChoiceTypeFound = true

								if v.(bool) {
									blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Ssh{}
									blockedServicesValueTypeChoiceInt.Ssh = &ves_io_schema.Empty{}
									blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
								}

							}

							if v, ok := blockedSeviceMapStrToI["web_user_interface"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

								blockedServicesValueTypeChoiceTypeFound = true

								if v.(bool) {
									blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_WebUserInterface{}
									blockedServicesValueTypeChoiceInt.WebUserInterface = &ves_io_schema.Empty{}
									blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
								}

							}

							if v, ok := blockedSeviceMapStrToI["network_type"]; ok && !isIntfNil(v) {

								blockedSevice[i].NetworkType = ves_io_schema.VirtualNetworkType(ves_io_schema.VirtualNetworkType_value[v.(string)])

							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("default_blocked_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true

		if v.(bool) {
			blockedServicesChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_DefaultBlockedServices{}
			blockedServicesChoiceInt.DefaultBlockedServices = &ves_io_schema.Empty{}
			updateSpec.BlockedServicesChoice = blockedServicesChoiceInt
		}

	}

	bondChoiceTypeFound := false

	if v, ok := d.GetOk("bond_device_list"); ok && !bondChoiceTypeFound {

		bondChoiceTypeFound = true
		bondChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_BondDeviceList{}
		bondChoiceInt.BondDeviceList = &ves_io_schema_fleet.FleetBondDevicesListType{}
		updateSpec.BondChoice = bondChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["bond_devices"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					bondDevices := make([]*ves_io_schema_fleet.FleetBondDeviceType, len(sl))
					bondChoiceInt.BondDeviceList.BondDevices = bondDevices
					for i, set := range sl {
						if set != nil {
							bondDevices[i] = &ves_io_schema_fleet.FleetBondDeviceType{}
							bondDevicesMapStrToI := set.(map[string]interface{})

							if w, ok := bondDevicesMapStrToI["devices"]; ok && !isIntfNil(w) {
								ls := make([]string, len(w.([]interface{})))
								for i, v := range w.([]interface{}) {
									ls[i] = v.(string)
								}
								bondDevices[i].Devices = ls
							}

							lacpChoiceTypeFound := false

							if v, ok := bondDevicesMapStrToI["active_backup"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

								lacpChoiceTypeFound = true

								if v.(bool) {
									lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_ActiveBackup{}
									lacpChoiceInt.ActiveBackup = &ves_io_schema.Empty{}
									bondDevices[i].LacpChoice = lacpChoiceInt
								}

							}

							if v, ok := bondDevicesMapStrToI["lacp"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

								lacpChoiceTypeFound = true
								lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_Lacp{}
								lacpChoiceInt.Lacp = &ves_io_schema_fleet.BondLacpType{}
								bondDevices[i].LacpChoice = lacpChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["rate"]; ok && !isIntfNil(v) {

											lacpChoiceInt.Lacp.Rate = uint32(v.(int))

										}

									}
								}

							}

							if w, ok := bondDevicesMapStrToI["link_polling_interval"]; ok && !isIntfNil(w) {
								bondDevices[i].LinkPollingInterval = uint32(w.(int))
							}

							if w, ok := bondDevicesMapStrToI["link_up_delay"]; ok && !isIntfNil(w) {
								bondDevices[i].LinkUpDelay = uint32(w.(int))
							}

							if w, ok := bondDevicesMapStrToI["name"]; ok && !isIntfNil(w) {
								bondDevices[i].Name = w.(string)
							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("no_bond_devices"); ok && !bondChoiceTypeFound {

		bondChoiceTypeFound = true

		if v.(bool) {
			bondChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_NoBondDevices{}
			bondChoiceInt.NoBondDevices = &ves_io_schema.Empty{}
			updateSpec.BondChoice = bondChoiceInt
		}

	}

	if v, ok := d.GetOk("coordinates"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		coordinates := &ves_io_schema_site.Coordinates{}
		updateSpec.Coordinates = coordinates
		for _, set := range sl {
			if set != nil {
				coordinatesMapStrToI := set.(map[string]interface{})

				if w, ok := coordinatesMapStrToI["latitude"]; ok && !isIntfNil(w) {
					coordinates.Latitude = float32(w.(float64))
				}

				if w, ok := coordinatesMapStrToI["longitude"]; ok && !isIntfNil(w) {
					coordinates.Longitude = float32(w.(float64))
				}

			}
		}

	}

	if v, ok := d.GetOk("custom_dns"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		customDns := &ves_io_schema_views.CustomDNS{}
		updateSpec.CustomDns = customDns
		for _, set := range sl {
			if set != nil {
				customDnsMapStrToI := set.(map[string]interface{})

				if w, ok := customDnsMapStrToI["inside_nameserver"]; ok && !isIntfNil(w) {
					customDns.InsideNameserver = w.(string)
				}

				if w, ok := customDnsMapStrToI["inside_nameserver_v6"]; ok && !isIntfNil(w) {
					customDns.InsideNameserverV6 = w.(string)
				}

				if w, ok := customDnsMapStrToI["outside_nameserver"]; ok && !isIntfNil(w) {
					customDns.OutsideNameserver = w.(string)
				}

				if w, ok := customDnsMapStrToI["outside_nameserver_v6"]; ok && !isIntfNil(w) {
					customDns.OutsideNameserverV6 = w.(string)
				}

			}
		}

	}

	gpuChoiceTypeFound := false

	if v, ok := d.GetOk("disable_gpu"); ok && !gpuChoiceTypeFound {

		gpuChoiceTypeFound = true

		if v.(bool) {
			gpuChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_DisableGpu{}
			gpuChoiceInt.DisableGpu = &ves_io_schema.Empty{}
			updateSpec.GpuChoice = gpuChoiceInt
		}

	}

	if v, ok := d.GetOk("enable_gpu"); ok && !gpuChoiceTypeFound {

		gpuChoiceTypeFound = true

		if v.(bool) {
			gpuChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_EnableGpu{}
			gpuChoiceInt.EnableGpu = &ves_io_schema.Empty{}
			updateSpec.GpuChoice = gpuChoiceInt
		}

	}

	if v, ok := d.GetOk("enable_vgpu"); ok && !gpuChoiceTypeFound {

		gpuChoiceTypeFound = true
		gpuChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_EnableVgpu{}
		gpuChoiceInt.EnableVgpu = &ves_io_schema_fleet.VGPUConfiguration{}
		updateSpec.GpuChoice = gpuChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["feature_type"]; ok && !isIntfNil(v) {

					gpuChoiceInt.EnableVgpu.FeatureType = ves_io_schema_fleet.VGPUFeatureType(ves_io_schema_fleet.VGPUFeatureType_value[v.(string)])

				}

				if v, ok := cs["server_address"]; ok && !isIntfNil(v) {

					gpuChoiceInt.EnableVgpu.ServerAddress = v.(string)

				}

				if v, ok := cs["server_port"]; ok && !isIntfNil(v) {

					gpuChoiceInt.EnableVgpu.ServerPort = uint32(v.(int))

				}

			}
		}

	}

	k8SClusterChoiceTypeFound := false

	if v, ok := d.GetOk("k8s_cluster"); ok && !k8SClusterChoiceTypeFound {

		k8SClusterChoiceTypeFound = true
		k8SClusterChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_K8SCluster{}
		k8SClusterChoiceInt.K8SCluster = &ves_io_schema_views.ObjectRefType{}
		updateSpec.K8SClusterChoice = k8SClusterChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["name"]; ok && !isIntfNil(v) {

					k8SClusterChoiceInt.K8SCluster.Name = v.(string)

				}

				if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

					k8SClusterChoiceInt.K8SCluster.Namespace = v.(string)

				}

				if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

					k8SClusterChoiceInt.K8SCluster.Tenant = v.(string)

				}

			}
		}

	}

	if v, ok := d.GetOk("no_k8s_cluster"); ok && !k8SClusterChoiceTypeFound {

		k8SClusterChoiceTypeFound = true

		if v.(bool) {
			k8SClusterChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_NoK8SCluster{}
			k8SClusterChoiceInt.NoK8SCluster = &ves_io_schema.Empty{}
			updateSpec.K8SClusterChoice = k8SClusterChoiceInt
		}

	}

	if v, ok := d.GetOk("kubernetes_upgrade_drain"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		kubernetesUpgradeDrain := &ves_io_schema_views.KubernetesUpgradeDrain{}
		updateSpec.KubernetesUpgradeDrain = kubernetesUpgradeDrain
		for _, set := range sl {
			if set != nil {
				kubernetesUpgradeDrainMapStrToI := set.(map[string]interface{})

				kubernetesUpgradeDrainEnableChoiceTypeFound := false

				if v, ok := kubernetesUpgradeDrainMapStrToI["disable_upgrade_drain"]; ok && !isIntfNil(v) && !kubernetesUpgradeDrainEnableChoiceTypeFound {

					kubernetesUpgradeDrainEnableChoiceTypeFound = true

					if v.(bool) {
						kubernetesUpgradeDrainEnableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrain_DisableUpgradeDrain{}
						kubernetesUpgradeDrainEnableChoiceInt.DisableUpgradeDrain = &ves_io_schema.Empty{}
						kubernetesUpgradeDrain.KubernetesUpgradeDrainEnableChoice = kubernetesUpgradeDrainEnableChoiceInt
					}

				}

				if v, ok := kubernetesUpgradeDrainMapStrToI["enable_upgrade_drain"]; ok && !isIntfNil(v) && !kubernetesUpgradeDrainEnableChoiceTypeFound {

					kubernetesUpgradeDrainEnableChoiceTypeFound = true
					kubernetesUpgradeDrainEnableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrain_EnableUpgradeDrain{}
					kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain = &ves_io_schema_views.KubernetesUpgradeDrainConfig{}
					kubernetesUpgradeDrain.KubernetesUpgradeDrainEnableChoice = kubernetesUpgradeDrainEnableChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							drainMaxUnavailableChoiceTypeFound := false

							if v, ok := cs["drain_max_unavailable_node_count"]; ok && !isIntfNil(v) && !drainMaxUnavailableChoiceTypeFound {

								drainMaxUnavailableChoiceTypeFound = true
								drainMaxUnavailableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrainConfig_DrainMaxUnavailableNodeCount{}

								kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.DrainMaxUnavailableChoice = drainMaxUnavailableChoiceInt

								drainMaxUnavailableChoiceInt.DrainMaxUnavailableNodeCount = uint32(v.(int))

							}

							if v, ok := cs["drain_max_unavailable_node_percentage"]; ok && !isIntfNil(v) && !drainMaxUnavailableChoiceTypeFound {

								drainMaxUnavailableChoiceTypeFound = true
								drainMaxUnavailableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrainConfig_DrainMaxUnavailableNodePercentage{}

								kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.DrainMaxUnavailableChoice = drainMaxUnavailableChoiceInt

								drainMaxUnavailableChoiceInt.DrainMaxUnavailableNodePercentage = uint32(v.(int))

							}

							if v, ok := cs["drain_node_timeout"]; ok && !isIntfNil(v) {

								kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.DrainNodeTimeout = uint32(v.(int))

							}

							vegaUpgradeModeToggleChoiceTypeFound := false

							if v, ok := cs["disable_vega_upgrade_mode"]; ok && !isIntfNil(v) && !vegaUpgradeModeToggleChoiceTypeFound {

								vegaUpgradeModeToggleChoiceTypeFound = true

								if v.(bool) {
									vegaUpgradeModeToggleChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrainConfig_DisableVegaUpgradeMode{}
									vegaUpgradeModeToggleChoiceInt.DisableVegaUpgradeMode = &ves_io_schema.Empty{}
									kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.VegaUpgradeModeToggleChoice = vegaUpgradeModeToggleChoiceInt
								}

							}

							if v, ok := cs["enable_vega_upgrade_mode"]; ok && !isIntfNil(v) && !vegaUpgradeModeToggleChoiceTypeFound {

								vegaUpgradeModeToggleChoiceTypeFound = true

								if v.(bool) {
									vegaUpgradeModeToggleChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrainConfig_EnableVegaUpgradeMode{}
									vegaUpgradeModeToggleChoiceInt.EnableVegaUpgradeMode = &ves_io_schema.Empty{}
									kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.VegaUpgradeModeToggleChoice = vegaUpgradeModeToggleChoiceInt
								}

							}

						}
					}

				}

			}
		}

	}

	localControlPlaneChoiceTypeFound := false

	if v, ok := d.GetOk("local_control_plane"); ok && !localControlPlaneChoiceTypeFound {

		localControlPlaneChoiceTypeFound = true
		localControlPlaneChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_LocalControlPlane{}
		localControlPlaneChoiceInt.LocalControlPlane = &ves_io_schema_fleet.LocalControlPlaneType{}
		updateSpec.LocalControlPlaneChoice = localControlPlaneChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["bgp_config"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					bgpConfig := &ves_io_schema_fleet.BGPConfiguration{}
					localControlPlaneChoiceInt.LocalControlPlane.BgpConfig = bgpConfig
					for _, set := range sl {
						if set != nil {
							bgpConfigMapStrToI := set.(map[string]interface{})

							if w, ok := bgpConfigMapStrToI["asn"]; ok && !isIntfNil(w) {
								bgpConfig.Asn = uint32(w.(int))
							}

							if v, ok := bgpConfigMapStrToI["peers"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								peers := make([]*ves_io_schema_bgp.Peer, len(sl))
								bgpConfig.Peers = peers
								for i, set := range sl {
									if set != nil {
										peers[i] = &ves_io_schema_bgp.Peer{}
										_ = set.(map[string]interface{})

									}
								}

							}

						}
					}

				}

				networkChoiceTypeFound := false

				if v, ok := cs["inside_vn"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

					networkChoiceTypeFound = true

					if v.(bool) {
						networkChoiceInt := &ves_io_schema_fleet.LocalControlPlaneType_InsideVn{}
						networkChoiceInt.InsideVn = &ves_io_schema.Empty{}
						localControlPlaneChoiceInt.LocalControlPlane.NetworkChoice = networkChoiceInt
					}

				}

				if v, ok := cs["outside_vn"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

					networkChoiceTypeFound = true

					if v.(bool) {
						networkChoiceInt := &ves_io_schema_fleet.LocalControlPlaneType_OutsideVn{}
						networkChoiceInt.OutsideVn = &ves_io_schema.Empty{}
						localControlPlaneChoiceInt.LocalControlPlane.NetworkChoice = networkChoiceInt
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("no_local_control_plane"); ok && !localControlPlaneChoiceTypeFound {

		localControlPlaneChoiceTypeFound = true

		if v.(bool) {
			localControlPlaneChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_NoLocalControlPlane{}
			localControlPlaneChoiceInt.NoLocalControlPlane = &ves_io_schema.Empty{}
			updateSpec.LocalControlPlaneChoice = localControlPlaneChoiceInt
		}

	}

	logsReceiverChoiceTypeFound := false

	if v, ok := d.GetOk("log_receiver"); ok && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true
		logsReceiverChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_LogReceiver{}
		logsReceiverChoiceInt.LogReceiver = &ves_io_schema_views.ObjectRefType{}
		updateSpec.LogsReceiverChoice = logsReceiverChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["name"]; ok && !isIntfNil(v) {

					logsReceiverChoiceInt.LogReceiver.Name = v.(string)

				}

				if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

					logsReceiverChoiceInt.LogReceiver.Namespace = v.(string)

				}

				if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

					logsReceiverChoiceInt.LogReceiver.Tenant = v.(string)

				}

			}
		}

	}

	if v, ok := d.GetOk("logs_streaming_disabled"); ok && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true

		if v.(bool) {
			logsReceiverChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_LogsStreamingDisabled{}
			logsReceiverChoiceInt.LogsStreamingDisabled = &ves_io_schema.Empty{}
			updateSpec.LogsReceiverChoice = logsReceiverChoiceInt
		}

	}

	if v, ok := d.GetOk("master_node_configuration"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		masterNodeConfiguration := make([]*ves_io_schema_views.MasterNode, len(sl))
		updateSpec.MasterNodeConfiguration = masterNodeConfiguration
		for i, set := range sl {
			if set != nil {
				masterNodeConfiguration[i] = &ves_io_schema_views.MasterNode{}
				masterNodeConfigurationMapStrToI := set.(map[string]interface{})

				if w, ok := masterNodeConfigurationMapStrToI["name"]; ok && !isIntfNil(w) {
					masterNodeConfiguration[i].Name = w.(string)
				}

				if w, ok := masterNodeConfigurationMapStrToI["public_ip"]; ok && !isIntfNil(w) {
					masterNodeConfiguration[i].PublicIp = w.(string)
				}

			}
		}

	}

	if v, ok := d.GetOk("master_nodes"); ok && !isIntfNil(v) {

		ls := make([]string, len(v.([]interface{})))
		for i, v := range v.([]interface{}) {
			ls[i] = v.(string)
		}
		updateSpec.MasterNodes = ls

	}

	networkCfgChoiceTypeFound := false

	if v, ok := d.GetOk("custom_network_config"); ok && !networkCfgChoiceTypeFound {

		networkCfgChoiceTypeFound = true
		networkCfgChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_CustomNetworkConfig{}
		networkCfgChoiceInt.CustomNetworkConfig = &ves_io_schema_views_voltstack_site.VssNetworkConfiguration{}
		updateSpec.NetworkCfgChoice = networkCfgChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["bgp_peer_address"]; ok && !isIntfNil(v) {

					networkCfgChoiceInt.CustomNetworkConfig.BgpPeerAddress = v.(string)

				}

				if v, ok := cs["bgp_peer_address_v6"]; ok && !isIntfNil(v) {

					networkCfgChoiceInt.CustomNetworkConfig.BgpPeerAddressV6 = v.(string)

				}

				if v, ok := cs["bgp_router_id"]; ok && !isIntfNil(v) {

					networkCfgChoiceInt.CustomNetworkConfig.BgpRouterId = v.(string)

				}

				forwardProxyChoiceTypeFound := false

				if v, ok := cs["active_forward_proxy_policies"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true
					forwardProxyChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_ActiveForwardProxyPolicies{}
					forwardProxyChoiceInt.ActiveForwardProxyPolicies = &ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType{}
					networkCfgChoiceInt.CustomNetworkConfig.ForwardProxyChoice = forwardProxyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["forward_proxy_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								forwardProxyPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								forwardProxyChoiceInt.ActiveForwardProxyPolicies.ForwardProxyPolicies = forwardProxyPoliciesInt
								for i, ps := range sl {

									fppMapToStrVal := ps.(map[string]interface{})
									forwardProxyPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := fppMapToStrVal["name"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Name = v.(string)
									}

									if v, ok := fppMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := fppMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["forward_proxy_allow_all"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true

					if v.(bool) {
						forwardProxyChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_ForwardProxyAllowAll{}
						forwardProxyChoiceInt.ForwardProxyAllowAll = &ves_io_schema.Empty{}
						networkCfgChoiceInt.CustomNetworkConfig.ForwardProxyChoice = forwardProxyChoiceInt
					}

				}

				if v, ok := cs["no_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true

					if v.(bool) {
						forwardProxyChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_NoForwardProxy{}
						forwardProxyChoiceInt.NoForwardProxy = &ves_io_schema.Empty{}
						networkCfgChoiceInt.CustomNetworkConfig.ForwardProxyChoice = forwardProxyChoiceInt
					}

				}

				globalNetworkChoiceTypeFound := false

				if v, ok := cs["global_network_list"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

					globalNetworkChoiceTypeFound = true
					globalNetworkChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_GlobalNetworkList{}
					globalNetworkChoiceInt.GlobalNetworkList = &ves_io_schema_views.GlobalNetworkConnectionListType{}
					networkCfgChoiceInt.CustomNetworkConfig.GlobalNetworkChoice = globalNetworkChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["global_network_connections"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								globalNetworkConnections := make([]*ves_io_schema_views.GlobalNetworkConnectionType, len(sl))
								globalNetworkChoiceInt.GlobalNetworkList.GlobalNetworkConnections = globalNetworkConnections
								for i, set := range sl {
									if set != nil {
										globalNetworkConnections[i] = &ves_io_schema_views.GlobalNetworkConnectionType{}
										globalNetworkConnectionsMapStrToI := set.(map[string]interface{})

										connectionChoiceTypeFound := false

										if v, ok := globalNetworkConnectionsMapStrToI["sli_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

											connectionChoiceTypeFound = true
											connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SliToGlobalDr{}
											connectionChoiceInt.SliToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
											globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														globalVn := &ves_io_schema_views.ObjectRefType{}
														connectionChoiceInt.SliToGlobalDr.GlobalVn = globalVn
														for _, set := range sl {
															if set != nil {
																globalVnMapStrToI := set.(map[string]interface{})

																if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
																	globalVn.Name = w.(string)
																}

																if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
																	globalVn.Namespace = w.(string)
																}

																if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
																	globalVn.Tenant = w.(string)
																}

															}
														}

													}

												}
											}

										}

										if v, ok := globalNetworkConnectionsMapStrToI["slo_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

											connectionChoiceTypeFound = true
											connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SloToGlobalDr{}
											connectionChoiceInt.SloToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
											globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														globalVn := &ves_io_schema_views.ObjectRefType{}
														connectionChoiceInt.SloToGlobalDr.GlobalVn = globalVn
														for _, set := range sl {
															if set != nil {
																globalVnMapStrToI := set.(map[string]interface{})

																if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
																	globalVn.Name = w.(string)
																}

																if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
																	globalVn.Namespace = w.(string)
																}

																if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
																	globalVn.Tenant = w.(string)
																}

															}
														}

													}

												}
											}

										}

										forwardProxyChoiceTypeFound := false

										if v, ok := globalNetworkConnectionsMapStrToI["disable_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

											forwardProxyChoiceTypeFound = true

											if v.(bool) {
												forwardProxyChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_DisableForwardProxy{}
												forwardProxyChoiceInt.DisableForwardProxy = &ves_io_schema.Empty{}
												globalNetworkConnections[i].ForwardProxyChoice = forwardProxyChoiceInt
											}

										}

										if v, ok := globalNetworkConnectionsMapStrToI["enable_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

											forwardProxyChoiceTypeFound = true
											forwardProxyChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_EnableForwardProxy{}
											forwardProxyChoiceInt.EnableForwardProxy = &ves_io_schema.ForwardProxyConfigType{}
											globalNetworkConnections[i].ForwardProxyChoice = forwardProxyChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["connection_timeout"]; ok && !isIntfNil(v) {

														forwardProxyChoiceInt.EnableForwardProxy.ConnectionTimeout = uint32(v.(int))

													}

													if v, ok := cs["max_connect_attempts"]; ok && !isIntfNil(v) {

														forwardProxyChoiceInt.EnableForwardProxy.MaxConnectAttempts = uint32(v.(int))

													}

													tlsInterceptionChoiceTypeFound := false

													if v, ok := cs["no_interception"]; ok && !isIntfNil(v) && !tlsInterceptionChoiceTypeFound {

														tlsInterceptionChoiceTypeFound = true

														if v.(bool) {
															tlsInterceptionChoiceInt := &ves_io_schema.ForwardProxyConfigType_NoInterception{}
															tlsInterceptionChoiceInt.NoInterception = &ves_io_schema.Empty{}
															forwardProxyChoiceInt.EnableForwardProxy.TlsInterceptionChoice = tlsInterceptionChoiceInt
														}

													}

													if v, ok := cs["tls_intercept"]; ok && !isIntfNil(v) && !tlsInterceptionChoiceTypeFound {

														tlsInterceptionChoiceTypeFound = true
														tlsInterceptionChoiceInt := &ves_io_schema.ForwardProxyConfigType_TlsIntercept{}
														tlsInterceptionChoiceInt.TlsIntercept = &ves_io_schema.TlsInterceptionType{}
														forwardProxyChoiceInt.EnableForwardProxy.TlsInterceptionChoice = tlsInterceptionChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																interceptionPolicyChoiceTypeFound := false

																if v, ok := cs["enable_for_all_domains"]; ok && !isIntfNil(v) && !interceptionPolicyChoiceTypeFound {

																	interceptionPolicyChoiceTypeFound = true

																	if v.(bool) {
																		interceptionPolicyChoiceInt := &ves_io_schema.TlsInterceptionType_EnableForAllDomains{}
																		interceptionPolicyChoiceInt.EnableForAllDomains = &ves_io_schema.Empty{}
																		tlsInterceptionChoiceInt.TlsIntercept.InterceptionPolicyChoice = interceptionPolicyChoiceInt
																	}

																}

																if v, ok := cs["policy"]; ok && !isIntfNil(v) && !interceptionPolicyChoiceTypeFound {

																	interceptionPolicyChoiceTypeFound = true
																	interceptionPolicyChoiceInt := &ves_io_schema.TlsInterceptionType_Policy{}
																	interceptionPolicyChoiceInt.Policy = &ves_io_schema.TlsInterceptionPolicy{}
																	tlsInterceptionChoiceInt.TlsIntercept.InterceptionPolicyChoice = interceptionPolicyChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["interception_rules"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				interceptionRules := make([]*ves_io_schema.TlsInterceptionRule, len(sl))
																				interceptionPolicyChoiceInt.Policy.InterceptionRules = interceptionRules
																				for i, set := range sl {
																					if set != nil {
																						interceptionRules[i] = &ves_io_schema.TlsInterceptionRule{}
																						interceptionRulesMapStrToI := set.(map[string]interface{})

																						if v, ok := interceptionRulesMapStrToI["domain_match"]; ok && !isIntfNil(v) {

																							sl := v.([]interface{})
																							domainMatch := &ves_io_schema.DomainType{}
																							interceptionRules[i].DomainMatch = domainMatch
																							for _, set := range sl {
																								if set != nil {
																									domainMatchMapStrToI := set.(map[string]interface{})

																									domainChoiceTypeFound := false

																									if v, ok := domainMatchMapStrToI["exact_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																										domainChoiceTypeFound = true
																										domainChoiceInt := &ves_io_schema.DomainType_ExactValue{}

																										domainMatch.DomainChoice = domainChoiceInt

																										domainChoiceInt.ExactValue = v.(string)

																									}

																									if v, ok := domainMatchMapStrToI["regex_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																										domainChoiceTypeFound = true
																										domainChoiceInt := &ves_io_schema.DomainType_RegexValue{}

																										domainMatch.DomainChoice = domainChoiceInt

																										domainChoiceInt.RegexValue = v.(string)

																									}

																									if v, ok := domainMatchMapStrToI["suffix_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																										domainChoiceTypeFound = true
																										domainChoiceInt := &ves_io_schema.DomainType_SuffixValue{}

																										domainMatch.DomainChoice = domainChoiceInt

																										domainChoiceInt.SuffixValue = v.(string)

																									}

																								}
																							}

																						}

																						enableDisableChoiceTypeFound := false

																						if v, ok := interceptionRulesMapStrToI["disable_interception"]; ok && !isIntfNil(v) && !enableDisableChoiceTypeFound {

																							enableDisableChoiceTypeFound = true

																							if v.(bool) {
																								enableDisableChoiceInt := &ves_io_schema.TlsInterceptionRule_DisableInterception{}
																								enableDisableChoiceInt.DisableInterception = &ves_io_schema.Empty{}
																								interceptionRules[i].EnableDisableChoice = enableDisableChoiceInt
																							}

																						}

																						if v, ok := interceptionRulesMapStrToI["enable_interception"]; ok && !isIntfNil(v) && !enableDisableChoiceTypeFound {

																							enableDisableChoiceTypeFound = true

																							if v.(bool) {
																								enableDisableChoiceInt := &ves_io_schema.TlsInterceptionRule_EnableInterception{}
																								enableDisableChoiceInt.EnableInterception = &ves_io_schema.Empty{}
																								interceptionRules[i].EnableDisableChoice = enableDisableChoiceInt
																							}

																						}

																					}
																				}

																			}

																		}
																	}

																}

																signingCertChoiceTypeFound := false

																if v, ok := cs["custom_certificate"]; ok && !isIntfNil(v) && !signingCertChoiceTypeFound {

																	signingCertChoiceTypeFound = true
																	signingCertChoiceInt := &ves_io_schema.TlsInterceptionType_CustomCertificate{}
																	signingCertChoiceInt.CustomCertificate = &ves_io_schema.TlsCertificateType{}
																	tlsInterceptionChoiceInt.TlsIntercept.SigningCertChoice = signingCertChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["certificate_url"]; ok && !isIntfNil(v) {

																				signingCertChoiceInt.CustomCertificate.CertificateUrl = v.(string)

																			}

																			if v, ok := cs["description"]; ok && !isIntfNil(v) {

																				signingCertChoiceInt.CustomCertificate.Description = v.(string)

																			}

																			ocspStaplingChoiceTypeFound := false

																			if v, ok := cs["custom_hash_algorithms"]; ok && !isIntfNil(v) && !ocspStaplingChoiceTypeFound {

																				ocspStaplingChoiceTypeFound = true
																				ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_CustomHashAlgorithms{}
																				ocspStaplingChoiceInt.CustomHashAlgorithms = &ves_io_schema.HashAlgorithms{}
																				signingCertChoiceInt.CustomCertificate.OcspStaplingChoice = ocspStaplingChoiceInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["hash_algorithms"]; ok && !isIntfNil(v) {

																							hash_algorithmsList := []ves_io_schema.HashAlgorithm{}
																							for _, j := range v.([]interface{}) {
																								hash_algorithmsList = append(hash_algorithmsList, ves_io_schema.HashAlgorithm(ves_io_schema.HashAlgorithm_value[j.(string)]))
																							}
																							ocspStaplingChoiceInt.CustomHashAlgorithms.HashAlgorithms = hash_algorithmsList

																						}

																					}
																				}

																			}

																			if _, ok := cs["disable_ocsp_stapling"]; ok && !ocspStaplingChoiceTypeFound {

																				ocspStaplingChoiceTypeFound = true
																				ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_DisableOcspStapling{}
																				ocspStaplingChoiceInt.DisableOcspStapling = &ves_io_schema.Empty{}
																				signingCertChoiceInt.CustomCertificate.OcspStaplingChoice = ocspStaplingChoiceInt

																			}

																			if _, ok := cs["use_system_defaults"]; ok && !ocspStaplingChoiceTypeFound {

																				ocspStaplingChoiceTypeFound = true
																				ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_UseSystemDefaults{}
																				ocspStaplingChoiceInt.UseSystemDefaults = &ves_io_schema.Empty{}
																				signingCertChoiceInt.CustomCertificate.OcspStaplingChoice = ocspStaplingChoiceInt

																			}

																			if v, ok := cs["private_key"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				privateKey := &ves_io_schema.SecretType{}
																				signingCertChoiceInt.CustomCertificate.PrivateKey = privateKey
																				for _, set := range sl {
																					if set != nil {
																						privateKeyMapStrToI := set.(map[string]interface{})

																						if v, ok := privateKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																							sl := v.([]interface{})
																							blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																							privateKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																							for _, set := range sl {
																								if set != nil {
																									blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																									if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																										blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																									}

																									if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																										blindfoldSecretInfoInternal.Location = w.(string)
																									}

																									if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																										blindfoldSecretInfoInternal.StoreProvider = w.(string)
																									}

																								}
																							}

																						}

																						if v, ok := privateKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																							privateKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																						}

																						secretInfoOneofTypeFound := false

																						if v, ok := privateKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																							secretInfoOneofTypeFound = true
																							secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																							secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																							privateKey.SecretInfoOneof = secretInfoOneofInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																									}

																									if v, ok := cs["location"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																									}

																									if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																									}

																								}
																							}

																						}

																						if v, ok := privateKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																							secretInfoOneofTypeFound = true
																							secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																							secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																							privateKey.SecretInfoOneof = secretInfoOneofInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																									}

																									if v, ok := cs["url"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																									}

																								}
																							}

																						}

																						if v, ok := privateKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																							secretInfoOneofTypeFound = true
																							secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																							secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																							privateKey.SecretInfoOneof = secretInfoOneofInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["key"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																									}

																									if v, ok := cs["location"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																									}

																									if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																									}

																									if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																									}

																									if v, ok := cs["version"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																									}

																								}
																							}

																						}

																						if v, ok := privateKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																							secretInfoOneofTypeFound = true
																							secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																							secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																							privateKey.SecretInfoOneof = secretInfoOneofInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["name"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																									}

																								}
																							}

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["volterra_certificate"]; ok && !isIntfNil(v) && !signingCertChoiceTypeFound {

																	signingCertChoiceTypeFound = true

																	if v.(bool) {
																		signingCertChoiceInt := &ves_io_schema.TlsInterceptionType_VolterraCertificate{}
																		signingCertChoiceInt.VolterraCertificate = &ves_io_schema.Empty{}
																		tlsInterceptionChoiceInt.TlsIntercept.SigningCertChoice = signingCertChoiceInt
																	}

																}

																trustedCaChoiceTypeFound := false

																if v, ok := cs["trusted_ca_url"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

																	trustedCaChoiceTypeFound = true
																	trustedCaChoiceInt := &ves_io_schema.TlsInterceptionType_TrustedCaUrl{}

																	tlsInterceptionChoiceInt.TlsIntercept.TrustedCaChoice = trustedCaChoiceInt

																	trustedCaChoiceInt.TrustedCaUrl = v.(string)

																}

																if v, ok := cs["volterra_trusted_ca"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

																	trustedCaChoiceTypeFound = true

																	if v.(bool) {
																		trustedCaChoiceInt := &ves_io_schema.TlsInterceptionType_VolterraTrustedCa{}
																		trustedCaChoiceInt.VolterraTrustedCa = &ves_io_schema.Empty{}
																		tlsInterceptionChoiceInt.TlsIntercept.TrustedCaChoice = trustedCaChoiceInt
																	}

																}

															}
														}

													}

													if v, ok := cs["white_listed_ports"]; ok && !isIntfNil(v) {

														ls := make([]uint32, len(v.([]interface{})))
														for i, v := range v.([]interface{}) {
															ls[i] = uint32(v.(int))
														}
														forwardProxyChoiceInt.EnableForwardProxy.WhiteListedPorts = ls

													}

													if v, ok := cs["white_listed_prefixes"]; ok && !isIntfNil(v) {

														ls := make([]string, len(v.([]interface{})))
														for i, v := range v.([]interface{}) {
															ls[i] = v.(string)
														}
														forwardProxyChoiceInt.EnableForwardProxy.WhiteListedPrefixes = ls

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["no_global_network"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

					globalNetworkChoiceTypeFound = true

					if v.(bool) {
						globalNetworkChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_NoGlobalNetwork{}
						globalNetworkChoiceInt.NoGlobalNetwork = &ves_io_schema.Empty{}
						networkCfgChoiceInt.CustomNetworkConfig.GlobalNetworkChoice = globalNetworkChoiceInt
					}

				}

				interfaceChoiceTypeFound := false

				if v, ok := cs["default_interface_config"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

					interfaceChoiceTypeFound = true

					if v.(bool) {
						interfaceChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_DefaultInterfaceConfig{}
						interfaceChoiceInt.DefaultInterfaceConfig = &ves_io_schema.Empty{}
						networkCfgChoiceInt.CustomNetworkConfig.InterfaceChoice = interfaceChoiceInt
					}

				}

				if v, ok := cs["interface_list"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

					interfaceChoiceTypeFound = true
					interfaceChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_InterfaceList{}
					interfaceChoiceInt.InterfaceList = &ves_io_schema_views_voltstack_site.InterfaceListType{}
					networkCfgChoiceInt.CustomNetworkConfig.InterfaceChoice = interfaceChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["interfaces"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								interfaces := make([]*ves_io_schema_views_voltstack_site.Interface, len(sl))
								interfaceChoiceInt.InterfaceList.Interfaces = interfaces
								for i, set := range sl {
									if set != nil {
										interfaces[i] = &ves_io_schema_views_voltstack_site.Interface{}
										interfacesMapStrToI := set.(map[string]interface{})

										dcClusterGroupConnectivityInterfaceChoiceTypeFound := false

										if v, ok := interfacesMapStrToI["dc_cluster_group_connectivity_interface_disabled"]; ok && !isIntfNil(v) && !dcClusterGroupConnectivityInterfaceChoiceTypeFound {

											dcClusterGroupConnectivityInterfaceChoiceTypeFound = true

											if v.(bool) {
												dcClusterGroupConnectivityInterfaceChoiceInt := &ves_io_schema_views_voltstack_site.Interface_DcClusterGroupConnectivityInterfaceDisabled{}
												dcClusterGroupConnectivityInterfaceChoiceInt.DcClusterGroupConnectivityInterfaceDisabled = &ves_io_schema.Empty{}
												interfaces[i].DcClusterGroupConnectivityInterfaceChoice = dcClusterGroupConnectivityInterfaceChoiceInt
											}

										}

										if v, ok := interfacesMapStrToI["dc_cluster_group_connectivity_interface_enabled"]; ok && !isIntfNil(v) && !dcClusterGroupConnectivityInterfaceChoiceTypeFound {

											dcClusterGroupConnectivityInterfaceChoiceTypeFound = true

											if v.(bool) {
												dcClusterGroupConnectivityInterfaceChoiceInt := &ves_io_schema_views_voltstack_site.Interface_DcClusterGroupConnectivityInterfaceEnabled{}
												dcClusterGroupConnectivityInterfaceChoiceInt.DcClusterGroupConnectivityInterfaceEnabled = &ves_io_schema.Empty{}
												interfaces[i].DcClusterGroupConnectivityInterfaceChoice = dcClusterGroupConnectivityInterfaceChoiceInt
											}

										}

										if w, ok := interfacesMapStrToI["description"]; ok && !isIntfNil(w) {
											interfaces[i].Description = w.(string)
										}

										interfaceChoiceTypeFound := false

										if v, ok := interfacesMapStrToI["dedicated_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

											interfaceChoiceTypeFound = true
											interfaceChoiceInt := &ves_io_schema_views_voltstack_site.Interface_DedicatedInterface{}
											interfaceChoiceInt.DedicatedInterface = &ves_io_schema_network_interface.DedicatedInterfaceType{}
											interfaces[i].InterfaceChoice = interfaceChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["device"]; ok && !isIntfNil(v) {

														interfaceChoiceInt.DedicatedInterface.Device = v.(string)

													}

													monitoringChoiceTypeFound := false

													if _, ok := cs["monitor"]; ok && !monitoringChoiceTypeFound {

														monitoringChoiceTypeFound = true
														monitoringChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_Monitor{}
														monitoringChoiceInt.Monitor = &ves_io_schema_network_interface.LinkQualityMonitorConfig{}
														interfaceChoiceInt.DedicatedInterface.MonitoringChoice = monitoringChoiceInt

													}

													if v, ok := cs["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

														monitoringChoiceTypeFound = true

														if v.(bool) {
															monitoringChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_MonitorDisabled{}
															monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
															interfaceChoiceInt.DedicatedInterface.MonitoringChoice = monitoringChoiceInt
														}

													}

													if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

														interfaceChoiceInt.DedicatedInterface.Mtu = uint32(v.(int))

													}

													nodeChoiceTypeFound := false

													if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

														nodeChoiceTypeFound = true

														if v.(bool) {
															nodeChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_Cluster{}
															nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
															interfaceChoiceInt.DedicatedInterface.NodeChoice = nodeChoiceInt
														}

													}

													if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

														nodeChoiceTypeFound = true
														nodeChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_Node{}

														interfaceChoiceInt.DedicatedInterface.NodeChoice = nodeChoiceInt

														nodeChoiceInt.Node = v.(string)

													}

													primaryChoiceTypeFound := false

													if v, ok := cs["is_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

														primaryChoiceTypeFound = true

														if v.(bool) {
															primaryChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_IsPrimary{}
															primaryChoiceInt.IsPrimary = &ves_io_schema.Empty{}
															interfaceChoiceInt.DedicatedInterface.PrimaryChoice = primaryChoiceInt
														}

													}

													if v, ok := cs["not_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

														primaryChoiceTypeFound = true

														if v.(bool) {
															primaryChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_NotPrimary{}
															primaryChoiceInt.NotPrimary = &ves_io_schema.Empty{}
															interfaceChoiceInt.DedicatedInterface.PrimaryChoice = primaryChoiceInt
														}

													}

													if v, ok := cs["priority"]; ok && !isIntfNil(v) {

														interfaceChoiceInt.DedicatedInterface.Priority = uint32(v.(int))

													}

												}
											}

										}

										if v, ok := interfacesMapStrToI["dedicated_management_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

											interfaceChoiceTypeFound = true
											interfaceChoiceInt := &ves_io_schema_views_voltstack_site.Interface_DedicatedManagementInterface{}
											interfaceChoiceInt.DedicatedManagementInterface = &ves_io_schema_network_interface.DedicatedManagementInterfaceType{}
											interfaces[i].InterfaceChoice = interfaceChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["device"]; ok && !isIntfNil(v) {

														interfaceChoiceInt.DedicatedManagementInterface.Device = v.(string)

													}

													if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

														interfaceChoiceInt.DedicatedManagementInterface.Mtu = uint32(v.(int))

													}

													nodeChoiceTypeFound := false

													if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

														nodeChoiceTypeFound = true

														if v.(bool) {
															nodeChoiceInt := &ves_io_schema_network_interface.DedicatedManagementInterfaceType_Cluster{}
															nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
															interfaceChoiceInt.DedicatedManagementInterface.NodeChoice = nodeChoiceInt
														}

													}

													if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

														nodeChoiceTypeFound = true
														nodeChoiceInt := &ves_io_schema_network_interface.DedicatedManagementInterfaceType_Node{}

														interfaceChoiceInt.DedicatedManagementInterface.NodeChoice = nodeChoiceInt

														nodeChoiceInt.Node = v.(string)

													}

												}
											}

										}

										if v, ok := interfacesMapStrToI["ethernet_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

											interfaceChoiceTypeFound = true
											interfaceChoiceInt := &ves_io_schema_views_voltstack_site.Interface_EthernetInterface{}
											interfaceChoiceInt.EthernetInterface = &ves_io_schema_network_interface.EthernetInterfaceType{}
											interfaces[i].InterfaceChoice = interfaceChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													addressChoiceTypeFound := false

													if v, ok := cs["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true

														if v.(bool) {
															addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_DhcpClient{}
															addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
															interfaceChoiceInt.EthernetInterface.AddressChoice = addressChoiceInt
														}

													}

													if v, ok := cs["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_DhcpServer{}
														addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
														interfaceChoiceInt.EthernetInterface.AddressChoice = addressChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
																	addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
																	for i, set := range sl {
																		if set != nil {
																			dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
																			dhcpNetworksMapStrToI := set.(map[string]interface{})

																			dnsChoiceTypeFound := false

																			if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																				dnsChoiceTypeFound = true
																				dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

																				dhcpNetworks[i].DnsChoice = dnsChoiceInt

																				dnsChoiceInt.DnsAddress = v.(string)

																			}

																			if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																				dnsChoiceTypeFound = true

																				if v.(bool) {
																					dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
																					dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
																					dhcpNetworks[i].DnsChoice = dnsChoiceInt
																				}

																			}

																			gatewayChoiceTypeFound := false

																			if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

																				gatewayChoiceTypeFound = true
																				gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

																				dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

																				gatewayChoiceInt.DgwAddress = v.(string)

																			}

																			if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

																				gatewayChoiceTypeFound = true

																				if v.(bool) {
																					gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
																					gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																					dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
																				}

																			}

																			if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

																				gatewayChoiceTypeFound = true

																				if v.(bool) {
																					gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
																					gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
																					dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
																				}

																			}

																			networkPrefixChoiceTypeFound := false

																			if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																				networkPrefixChoiceTypeFound = true
																				networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

																				dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																				networkPrefixChoiceInt.NetworkPrefix = v.(string)

																			}

																			if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																				networkPrefixChoiceTypeFound = true
																				networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
																				networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																				dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["name"]; ok && !isIntfNil(v) {

																							networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																						}

																						if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																							networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																						}

																						if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																							networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

																				dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

																			}

																			if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
																				dhcpNetworks[i].Pools = pools
																				for i, set := range sl {
																					if set != nil {
																						pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
																						poolsMapStrToI := set.(map[string]interface{})

																						if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																							pools[i].EndIp = w.(string)
																						}

																						if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																							pools[i].Exclude = w.(bool)
																						}

																						if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																							pools[i].StartIp = w.(string)
																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

																	addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

																}

																if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																	ms := map[string]string{}
																	for k, v := range v.(map[string]interface{}) {
																		ms[k] = v.(string)
																	}
																	addressChoiceInt.DhcpServer.FixedIpMap = ms
																}

																interfacesAddressingChoiceTypeFound := false

																if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																	interfacesAddressingChoiceTypeFound = true

																	if v.(bool) {
																		interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
																		interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																		addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																	}

																}

																if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																	interfacesAddressingChoiceTypeFound = true

																	if v.(bool) {
																		interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
																		interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																		addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																	}

																}

																if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																	interfacesAddressingChoiceTypeFound = true
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
																	interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
																	addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																				ms := map[string]string{}
																				for k, v := range v.(map[string]interface{}) {
																					ms[k] = v.(string)
																				}
																				interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := cs["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StaticIp{}
														addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIPParametersType{}
														interfaceChoiceInt.EthernetInterface.AddressChoice = addressChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																networkPrefixChoiceTypeFound := false

																if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
																	networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
																	addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
																				networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
																				for _, set := range sl {
																					if set != nil {
																						interfaceIpMapMapStrToI := set.(map[string]interface{})
																						key, ok := interfaceIpMapMapStrToI["name"]
																						if ok && !isIntfNil(key) {
																							interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																							val, _ := interfaceIpMapMapStrToI["value"]

																							interfaceIpMapVals := val.([]interface{})
																							for _, intVal := range interfaceIpMapVals {
																								if intVal != nil {

																									interfaceIpMapStaticMap := intVal.(map[string]interface{})

																									if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DefaultGw = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DnsServer = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].IpAddress = w.(string)
																									}

																									// break after one loop
																									break
																								}
																							}
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
																	networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
																	addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
																				networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

																				for _, set := range sl {
																					if set != nil {
																						npaMapToStrVal := set.(map[string]interface{})
																						if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Name = val.(string)
																						}
																						if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Namespace = val.(string)
																						}

																						if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Tenant = val.(string)
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
																	networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																	addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := cs["device"]; ok && !isIntfNil(v) {

														interfaceChoiceInt.EthernetInterface.Device = v.(string)

													}

													ipv6AddressChoiceTypeFound := false

													if v, ok := cs["ipv6_auto_config"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

														ipv6AddressChoiceTypeFound = true
														ipv6AddressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Ipv6AutoConfig{}
														ipv6AddressChoiceInt.Ipv6AutoConfig = &ves_io_schema_network_interface.IPV6AutoConfigType{}
														interfaceChoiceInt.EthernetInterface.Ipv6AddressChoice = ipv6AddressChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																autoconfigChoiceTypeFound := false

																if v, ok := cs["host"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

																	autoconfigChoiceTypeFound = true

																	if v.(bool) {
																		autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Host{}
																		autoconfigChoiceInt.Host = &ves_io_schema.Empty{}
																		ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt
																	}

																}

																if v, ok := cs["router"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

																	autoconfigChoiceTypeFound = true
																	autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Router{}
																	autoconfigChoiceInt.Router = &ves_io_schema_network_interface.IPV6AutoConfigRouterType{}
																	ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			addressChoiceTypeFound := false

																			if v, ok := cs["network_prefix"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

																				addressChoiceTypeFound = true
																				addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_NetworkPrefix{}

																				autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

																				addressChoiceInt.NetworkPrefix = v.(string)

																			}

																			if v, ok := cs["stateful"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

																				addressChoiceTypeFound = true
																				addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_Stateful{}
																				addressChoiceInt.Stateful = &ves_io_schema_network_interface.DHCPIPV6StatefulServer{}
																				autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																							sl := v.([]interface{})
																							dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPIPV6NetworkType, len(sl))
																							addressChoiceInt.Stateful.DhcpNetworks = dhcpNetworks
																							for i, set := range sl {
																								if set != nil {
																									dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPIPV6NetworkType{}
																									dhcpNetworksMapStrToI := set.(map[string]interface{})

																									networkPrefixChoiceTypeFound := false

																									if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																										networkPrefixChoiceTypeFound = true
																										networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefix{}

																										dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																										networkPrefixChoiceInt.NetworkPrefix = v.(string)

																									}

																									if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																										networkPrefixChoiceTypeFound = true
																										networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefixAllocator{}
																										networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																										dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																										sl := v.([]interface{})
																										for _, set := range sl {
																											if set != nil {
																												cs := set.(map[string]interface{})

																												if v, ok := cs["name"]; ok && !isIntfNil(v) {

																													networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																												}

																												if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																													networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																												}

																												if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																													networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																												}

																											}
																										}

																									}

																									if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

																										dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

																									}

																									if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																										sl := v.([]interface{})
																										pools := make([]*ves_io_schema_network_interface.DHCPIPV6PoolType, len(sl))
																										dhcpNetworks[i].Pools = pools
																										for i, set := range sl {
																											if set != nil {
																												pools[i] = &ves_io_schema_network_interface.DHCPIPV6PoolType{}
																												poolsMapStrToI := set.(map[string]interface{})

																												if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																													pools[i].EndIp = w.(string)
																												}

																												if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																													pools[i].Exclude = w.(bool)
																												}

																												if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																													pools[i].StartIp = w.(string)
																												}

																											}
																										}

																									}

																								}
																							}

																						}

																						if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																							ms := map[string]string{}
																							for k, v := range v.(map[string]interface{}) {
																								ms[k] = v.(string)
																							}
																							addressChoiceInt.Stateful.FixedIpMap = ms
																						}

																						interfacesAddressingChoiceTypeFound := false

																						if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																							interfacesAddressingChoiceTypeFound = true

																							if v.(bool) {
																								interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromEnd{}
																								interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																								addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																							}

																						}

																						if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																							interfacesAddressingChoiceTypeFound = true

																							if v.(bool) {
																								interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromStart{}
																								interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																								addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																							}

																						}

																						if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																							interfacesAddressingChoiceTypeFound = true
																							interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_InterfaceIpMap{}
																							interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPV6Type{}
																							addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																										ms := map[string]string{}
																										for k, v := range v.(map[string]interface{}) {
																											ms[k] = v.(string)
																										}
																										interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																									}

																								}
																							}

																						}

																					}
																				}

																			}

																			if v, ok := cs["dns_config"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				dnsConfig := &ves_io_schema_network_interface.IPV6DnsConfig{}
																				autoconfigChoiceInt.Router.DnsConfig = dnsConfig
																				for _, set := range sl {
																					if set != nil {
																						dnsConfigMapStrToI := set.(map[string]interface{})

																						dnsChoiceTypeFound := false

																						if v, ok := dnsConfigMapStrToI["configured_list"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																							dnsChoiceTypeFound = true
																							dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_ConfiguredList{}
																							dnsChoiceInt.ConfiguredList = &ves_io_schema_network_interface.IPV6DnsList{}
																							dnsConfig.DnsChoice = dnsChoiceInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["dns_list"]; ok && !isIntfNil(v) {

																										ls := make([]string, len(v.([]interface{})))
																										for i, v := range v.([]interface{}) {
																											ls[i] = v.(string)
																										}
																										dnsChoiceInt.ConfiguredList.DnsList = ls

																									}

																								}
																							}

																						}

																						if v, ok := dnsConfigMapStrToI["local_dns"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																							dnsChoiceTypeFound = true
																							dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_LocalDns{}
																							dnsChoiceInt.LocalDns = &ves_io_schema_network_interface.IPV6LocalDnsAddress{}
																							dnsConfig.DnsChoice = dnsChoiceInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									localDnsChoiceTypeFound := false

																									if v, ok := cs["configured_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																										localDnsChoiceTypeFound = true
																										localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_ConfiguredAddress{}

																										dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt

																										localDnsChoiceInt.ConfiguredAddress = v.(string)

																									}

																									if v, ok := cs["first_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																										localDnsChoiceTypeFound = true

																										if v.(bool) {
																											localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_FirstAddress{}
																											localDnsChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																											dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																										}

																									}

																									if v, ok := cs["last_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																										localDnsChoiceTypeFound = true

																										if v.(bool) {
																											localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_LastAddress{}
																											localDnsChoiceInt.LastAddress = &ves_io_schema.Empty{}
																											dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																										}

																									}

																								}
																							}

																						}

																					}
																				}

																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := cs["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

														ipv6AddressChoiceTypeFound = true

														if v.(bool) {
															ipv6AddressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_NoIpv6Address{}
															ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
															interfaceChoiceInt.EthernetInterface.Ipv6AddressChoice = ipv6AddressChoiceInt
														}

													}

													if v, ok := cs["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

														ipv6AddressChoiceTypeFound = true
														ipv6AddressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StaticIpv6Address{}
														ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
														interfaceChoiceInt.EthernetInterface.Ipv6AddressChoice = ipv6AddressChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																networkPrefixChoiceTypeFound := false

																if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
																	networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
																	ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
																				networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
																				for _, set := range sl {
																					if set != nil {
																						interfaceIpMapMapStrToI := set.(map[string]interface{})
																						key, ok := interfaceIpMapMapStrToI["name"]
																						if ok && !isIntfNil(key) {
																							interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																							val, _ := interfaceIpMapMapStrToI["value"]

																							interfaceIpMapVals := val.([]interface{})
																							for _, intVal := range interfaceIpMapVals {
																								if intVal != nil {

																									interfaceIpMapStaticMap := intVal.(map[string]interface{})

																									if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DefaultGw = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DnsServer = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].IpAddress = w.(string)
																									}

																									// break after one loop
																									break
																								}
																							}
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
																	networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
																	ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
																				networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

																				for _, set := range sl {
																					if set != nil {
																						npaMapToStrVal := set.(map[string]interface{})
																						if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Name = val.(string)
																						}
																						if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Namespace = val.(string)
																						}

																						if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Tenant = val.(string)
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
																	networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																	ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

													monitoringChoiceTypeFound := false

													if _, ok := cs["monitor"]; ok && !monitoringChoiceTypeFound {

														monitoringChoiceTypeFound = true
														monitoringChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Monitor{}
														monitoringChoiceInt.Monitor = &ves_io_schema_network_interface.LinkQualityMonitorConfig{}
														interfaceChoiceInt.EthernetInterface.MonitoringChoice = monitoringChoiceInt

													}

													if v, ok := cs["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

														monitoringChoiceTypeFound = true

														if v.(bool) {
															monitoringChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_MonitorDisabled{}
															monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
															interfaceChoiceInt.EthernetInterface.MonitoringChoice = monitoringChoiceInt
														}

													}

													if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

														interfaceChoiceInt.EthernetInterface.Mtu = uint32(v.(int))

													}

													networkChoiceTypeFound := false

													if v, ok := cs["inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true
														networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_InsideNetwork{}
														networkChoiceInt.InsideNetwork = &ves_io_schema_views.ObjectRefType{}
														interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	networkChoiceInt.InsideNetwork.Name = v.(string)

																}

																if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																	networkChoiceInt.InsideNetwork.Namespace = v.(string)

																}

																if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																	networkChoiceInt.InsideNetwork.Tenant = v.(string)

																}

															}
														}

													}

													if v, ok := cs["ip_fabric_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true

														if v.(bool) {
															networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_IpFabricNetwork{}
															networkChoiceInt.IpFabricNetwork = &ves_io_schema.Empty{}
															interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
														}

													}

													if v, ok := cs["segment_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true
														networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SegmentNetwork{}
														networkChoiceInt.SegmentNetwork = &ves_io_schema_views.ObjectRefType{}
														interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	networkChoiceInt.SegmentNetwork.Name = v.(string)

																}

																if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																	networkChoiceInt.SegmentNetwork.Namespace = v.(string)

																}

																if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																	networkChoiceInt.SegmentNetwork.Tenant = v.(string)

																}

															}
														}

													}

													if v, ok := cs["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true

														if v.(bool) {
															networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SiteLocalInsideNetwork{}
															networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
															interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
														}

													}

													if v, ok := cs["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true

														if v.(bool) {
															networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SiteLocalNetwork{}
															networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
															interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
														}

													}

													if v, ok := cs["srv6_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true
														networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Srv6Network{}
														networkChoiceInt.Srv6Network = &ves_io_schema_views.ObjectRefType{}
														interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	networkChoiceInt.Srv6Network.Name = v.(string)

																}

																if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																	networkChoiceInt.Srv6Network.Namespace = v.(string)

																}

																if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																	networkChoiceInt.Srv6Network.Tenant = v.(string)

																}

															}
														}

													}

													if v, ok := cs["storage_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true

														if v.(bool) {
															networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StorageNetwork{}
															networkChoiceInt.StorageNetwork = &ves_io_schema.Empty{}
															interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
														}

													}

													nodeChoiceTypeFound := false

													if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

														nodeChoiceTypeFound = true

														if v.(bool) {
															nodeChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Cluster{}
															nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
															interfaceChoiceInt.EthernetInterface.NodeChoice = nodeChoiceInt
														}

													}

													if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

														nodeChoiceTypeFound = true
														nodeChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Node{}

														interfaceChoiceInt.EthernetInterface.NodeChoice = nodeChoiceInt

														nodeChoiceInt.Node = v.(string)

													}

													primaryChoiceTypeFound := false

													if v, ok := cs["is_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

														primaryChoiceTypeFound = true

														if v.(bool) {
															primaryChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_IsPrimary{}
															primaryChoiceInt.IsPrimary = &ves_io_schema.Empty{}
															interfaceChoiceInt.EthernetInterface.PrimaryChoice = primaryChoiceInt
														}

													}

													if v, ok := cs["not_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

														primaryChoiceTypeFound = true

														if v.(bool) {
															primaryChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_NotPrimary{}
															primaryChoiceInt.NotPrimary = &ves_io_schema.Empty{}
															interfaceChoiceInt.EthernetInterface.PrimaryChoice = primaryChoiceInt
														}

													}

													if v, ok := cs["priority"]; ok && !isIntfNil(v) {

														interfaceChoiceInt.EthernetInterface.Priority = uint32(v.(int))

													}

													vlanChoiceTypeFound := false

													if v, ok := cs["untagged"]; ok && !isIntfNil(v) && !vlanChoiceTypeFound {

														vlanChoiceTypeFound = true

														if v.(bool) {
															vlanChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Untagged{}
															vlanChoiceInt.Untagged = &ves_io_schema.Empty{}
															interfaceChoiceInt.EthernetInterface.VlanChoice = vlanChoiceInt
														}

													}

													if v, ok := cs["vlan_id"]; ok && !isIntfNil(v) && !vlanChoiceTypeFound {

														vlanChoiceTypeFound = true
														vlanChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_VlanId{}

														interfaceChoiceInt.EthernetInterface.VlanChoice = vlanChoiceInt

														vlanChoiceInt.VlanId = uint32(v.(int))

													}

												}
											}

										}

										if v, ok := interfacesMapStrToI["loopback_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

											interfaceChoiceTypeFound = true
											interfaceChoiceInt := &ves_io_schema_views_voltstack_site.Interface_LoopbackInterface{}
											interfaceChoiceInt.LoopbackInterface = &ves_io_schema_network_interface.LoopbackInterfaceType{}
											interfaces[i].InterfaceChoice = interfaceChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													addressChoiceTypeFound := false

													if v, ok := cs["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true

														if v.(bool) {
															addressChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_DhcpClient{}
															addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
															interfaceChoiceInt.LoopbackInterface.AddressChoice = addressChoiceInt
														}

													}

													if v, ok := cs["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_DhcpServer{}
														addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
														interfaceChoiceInt.LoopbackInterface.AddressChoice = addressChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
																	addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
																	for i, set := range sl {
																		if set != nil {
																			dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
																			dhcpNetworksMapStrToI := set.(map[string]interface{})

																			dnsChoiceTypeFound := false

																			if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																				dnsChoiceTypeFound = true
																				dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

																				dhcpNetworks[i].DnsChoice = dnsChoiceInt

																				dnsChoiceInt.DnsAddress = v.(string)

																			}

																			if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																				dnsChoiceTypeFound = true

																				if v.(bool) {
																					dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
																					dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
																					dhcpNetworks[i].DnsChoice = dnsChoiceInt
																				}

																			}

																			gatewayChoiceTypeFound := false

																			if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

																				gatewayChoiceTypeFound = true
																				gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

																				dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

																				gatewayChoiceInt.DgwAddress = v.(string)

																			}

																			if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

																				gatewayChoiceTypeFound = true

																				if v.(bool) {
																					gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
																					gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																					dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
																				}

																			}

																			if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

																				gatewayChoiceTypeFound = true

																				if v.(bool) {
																					gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
																					gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
																					dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
																				}

																			}

																			networkPrefixChoiceTypeFound := false

																			if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																				networkPrefixChoiceTypeFound = true
																				networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

																				dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																				networkPrefixChoiceInt.NetworkPrefix = v.(string)

																			}

																			if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																				networkPrefixChoiceTypeFound = true
																				networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
																				networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																				dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["name"]; ok && !isIntfNil(v) {

																							networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																						}

																						if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																							networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																						}

																						if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																							networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

																				dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

																			}

																			if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
																				dhcpNetworks[i].Pools = pools
																				for i, set := range sl {
																					if set != nil {
																						pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
																						poolsMapStrToI := set.(map[string]interface{})

																						if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																							pools[i].EndIp = w.(string)
																						}

																						if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																							pools[i].Exclude = w.(bool)
																						}

																						if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																							pools[i].StartIp = w.(string)
																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

																	addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

																}

																if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																	ms := map[string]string{}
																	for k, v := range v.(map[string]interface{}) {
																		ms[k] = v.(string)
																	}
																	addressChoiceInt.DhcpServer.FixedIpMap = ms
																}

																interfacesAddressingChoiceTypeFound := false

																if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																	interfacesAddressingChoiceTypeFound = true

																	if v.(bool) {
																		interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
																		interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																		addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																	}

																}

																if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																	interfacesAddressingChoiceTypeFound = true

																	if v.(bool) {
																		interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
																		interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																		addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																	}

																}

																if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																	interfacesAddressingChoiceTypeFound = true
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
																	interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
																	addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																				ms := map[string]string{}
																				for k, v := range v.(map[string]interface{}) {
																					ms[k] = v.(string)
																				}
																				interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := cs["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_StaticIp{}
														addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIPParametersType{}
														interfaceChoiceInt.LoopbackInterface.AddressChoice = addressChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																networkPrefixChoiceTypeFound := false

																if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
																	networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
																	addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
																				networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
																				for _, set := range sl {
																					if set != nil {
																						interfaceIpMapMapStrToI := set.(map[string]interface{})
																						key, ok := interfaceIpMapMapStrToI["name"]
																						if ok && !isIntfNil(key) {
																							interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																							val, _ := interfaceIpMapMapStrToI["value"]

																							interfaceIpMapVals := val.([]interface{})
																							for _, intVal := range interfaceIpMapVals {
																								if intVal != nil {

																									interfaceIpMapStaticMap := intVal.(map[string]interface{})

																									if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DefaultGw = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DnsServer = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].IpAddress = w.(string)
																									}

																									// break after one loop
																									break
																								}
																							}
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
																	networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
																	addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
																				networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

																				for _, set := range sl {
																					if set != nil {
																						npaMapToStrVal := set.(map[string]interface{})
																						if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Name = val.(string)
																						}
																						if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Namespace = val.(string)
																						}

																						if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Tenant = val.(string)
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
																	networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																	addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := cs["device"]; ok && !isIntfNil(v) {

														interfaceChoiceInt.LoopbackInterface.Device = v.(string)

													}

													ipv6AddressChoiceTypeFound := false

													if v, ok := cs["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

														ipv6AddressChoiceTypeFound = true

														if v.(bool) {
															ipv6AddressChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_NoIpv6Address{}
															ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
															interfaceChoiceInt.LoopbackInterface.Ipv6AddressChoice = ipv6AddressChoiceInt
														}

													}

													if v, ok := cs["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

														ipv6AddressChoiceTypeFound = true
														ipv6AddressChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_StaticIpv6Address{}
														ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
														interfaceChoiceInt.LoopbackInterface.Ipv6AddressChoice = ipv6AddressChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																networkPrefixChoiceTypeFound := false

																if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
																	networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
																	ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
																				networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
																				for _, set := range sl {
																					if set != nil {
																						interfaceIpMapMapStrToI := set.(map[string]interface{})
																						key, ok := interfaceIpMapMapStrToI["name"]
																						if ok && !isIntfNil(key) {
																							interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																							val, _ := interfaceIpMapMapStrToI["value"]

																							interfaceIpMapVals := val.([]interface{})
																							for _, intVal := range interfaceIpMapVals {
																								if intVal != nil {

																									interfaceIpMapStaticMap := intVal.(map[string]interface{})

																									if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DefaultGw = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DnsServer = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].IpAddress = w.(string)
																									}

																									// break after one loop
																									break
																								}
																							}
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
																	networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
																	ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
																				networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

																				for _, set := range sl {
																					if set != nil {
																						npaMapToStrVal := set.(map[string]interface{})
																						if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Name = val.(string)
																						}
																						if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Namespace = val.(string)
																						}

																						if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Tenant = val.(string)
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
																	networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																	ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

														interfaceChoiceInt.LoopbackInterface.Mtu = uint32(v.(int))

													}

													networkChoiceTypeFound := false

													if v, ok := cs["ip_fabric_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true

														if v.(bool) {
															networkChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_IpFabricNetwork{}
															networkChoiceInt.IpFabricNetwork = &ves_io_schema.Empty{}
															interfaceChoiceInt.LoopbackInterface.NetworkChoice = networkChoiceInt
														}

													}

													if v, ok := cs["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true

														if v.(bool) {
															networkChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_SiteLocalInsideNetwork{}
															networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
															interfaceChoiceInt.LoopbackInterface.NetworkChoice = networkChoiceInt
														}

													}

													if v, ok := cs["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true

														if v.(bool) {
															networkChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_SiteLocalNetwork{}
															networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
															interfaceChoiceInt.LoopbackInterface.NetworkChoice = networkChoiceInt
														}

													}

													nodeChoiceTypeFound := false

													if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

														nodeChoiceTypeFound = true

														if v.(bool) {
															nodeChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_Cluster{}
															nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
															interfaceChoiceInt.LoopbackInterface.NodeChoice = nodeChoiceInt
														}

													}

													if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

														nodeChoiceTypeFound = true
														nodeChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_Node{}

														interfaceChoiceInt.LoopbackInterface.NodeChoice = nodeChoiceInt

														nodeChoiceInt.Node = v.(string)

													}

												}
											}

										}

										if v, ok := interfacesMapStrToI["tunnel_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

											interfaceChoiceTypeFound = true
											interfaceChoiceInt := &ves_io_schema_views_voltstack_site.Interface_TunnelInterface{}
											interfaceChoiceInt.TunnelInterface = &ves_io_schema_network_interface.TunnelInterfaceType{}
											interfaces[i].InterfaceChoice = interfaceChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["cloud_connect"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														cloudConnectInt := make([]*ves_io_schema.ObjectRefType, len(sl))
														interfaceChoiceInt.TunnelInterface.CloudConnect = cloudConnectInt
														for i, ps := range sl {

															ccMapToStrVal := ps.(map[string]interface{})
															cloudConnectInt[i] = &ves_io_schema.ObjectRefType{}

															cloudConnectInt[i].Kind = "cloud_connect"

															if v, ok := ccMapToStrVal["name"]; ok && !isIntfNil(v) {
																cloudConnectInt[i].Name = v.(string)
															}

															if v, ok := ccMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																cloudConnectInt[i].Namespace = v.(string)
															}

															if v, ok := ccMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																cloudConnectInt[i].Tenant = v.(string)
															}

															if v, ok := ccMapToStrVal["uid"]; ok && !isIntfNil(v) {
																cloudConnectInt[i].Uid = v.(string)
															}

														}

													}

													if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

														interfaceChoiceInt.TunnelInterface.Mtu = uint32(v.(int))

													}

													networkChoiceTypeFound := false

													if v, ok := cs["inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true
														networkChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_InsideNetwork{}
														networkChoiceInt.InsideNetwork = &ves_io_schema_views.ObjectRefType{}
														interfaceChoiceInt.TunnelInterface.NetworkChoice = networkChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	networkChoiceInt.InsideNetwork.Name = v.(string)

																}

																if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																	networkChoiceInt.InsideNetwork.Namespace = v.(string)

																}

																if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																	networkChoiceInt.InsideNetwork.Tenant = v.(string)

																}

															}
														}

													}

													if v, ok := cs["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true

														if v.(bool) {
															networkChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_SiteLocalInsideNetwork{}
															networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
															interfaceChoiceInt.TunnelInterface.NetworkChoice = networkChoiceInt
														}

													}

													if v, ok := cs["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true

														if v.(bool) {
															networkChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_SiteLocalNetwork{}
															networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
															interfaceChoiceInt.TunnelInterface.NetworkChoice = networkChoiceInt
														}

													}

													nodeChoiceTypeFound := false

													if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

														nodeChoiceTypeFound = true

														if v.(bool) {
															nodeChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_Cluster{}
															nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
															interfaceChoiceInt.TunnelInterface.NodeChoice = nodeChoiceInt
														}

													}

													if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

														nodeChoiceTypeFound = true
														nodeChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_Node{}

														interfaceChoiceInt.TunnelInterface.NodeChoice = nodeChoiceInt

														nodeChoiceInt.Node = v.(string)

													}

													if v, ok := cs["priority"]; ok && !isIntfNil(v) {

														interfaceChoiceInt.TunnelInterface.Priority = uint32(v.(int))

													}

													if v, ok := cs["static_ip"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														staticIp := &ves_io_schema_network_interface.StaticIPParametersType{}
														interfaceChoiceInt.TunnelInterface.StaticIp = staticIp
														for _, set := range sl {
															if set != nil {
																staticIpMapStrToI := set.(map[string]interface{})

																networkPrefixChoiceTypeFound := false

																if v, ok := staticIpMapStrToI["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
																	networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
																	staticIp.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
																				networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
																				for _, set := range sl {
																					if set != nil {
																						interfaceIpMapMapStrToI := set.(map[string]interface{})
																						key, ok := interfaceIpMapMapStrToI["name"]
																						if ok && !isIntfNil(key) {
																							interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																							val, _ := interfaceIpMapMapStrToI["value"]

																							interfaceIpMapVals := val.([]interface{})
																							for _, intVal := range interfaceIpMapVals {
																								if intVal != nil {

																									interfaceIpMapStaticMap := intVal.(map[string]interface{})

																									if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DefaultGw = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DnsServer = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].IpAddress = w.(string)
																									}

																									// break after one loop
																									break
																								}
																							}
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := staticIpMapStrToI["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
																	networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
																	staticIp.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
																				networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

																				for _, set := range sl {
																					if set != nil {
																						npaMapToStrVal := set.(map[string]interface{})
																						if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Name = val.(string)
																						}
																						if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Namespace = val.(string)
																						}

																						if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Tenant = val.(string)
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := staticIpMapStrToI["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
																	networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																	staticIp.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := cs["tunnel"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														tunnelInt := &ves_io_schema_views.ObjectRefType{}
														interfaceChoiceInt.TunnelInterface.Tunnel = tunnelInt

														for _, set := range sl {
															if set != nil {
																tMapToStrVal := set.(map[string]interface{})
																if val, ok := tMapToStrVal["name"]; ok && !isIntfNil(v) {
																	tunnelInt.Name = val.(string)
																}
																if val, ok := tMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																	tunnelInt.Namespace = val.(string)
																}

																if val, ok := tMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																	tunnelInt.Tenant = val.(string)
																}
															}
														}

													}

												}
											}

										}

										if w, ok := interfacesMapStrToI["labels"]; ok && !isIntfNil(w) {
											ms := map[string]string{}
											for k, v := range w.(map[string]interface{}) {
												ms[k] = v.(string)
											}
											interfaces[i].Labels = ms
										}

									}
								}

							}

						}
					}

				}

				networkPolicyChoiceTypeFound := false

				if v, ok := cs["active_enhanced_firewall_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true
					networkPolicyChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_ActiveEnhancedFirewallPolicies{}
					networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies = &ves_io_schema_network_firewall.ActiveEnhancedFirewallPoliciesType{}
					networkCfgChoiceInt.CustomNetworkConfig.NetworkPolicyChoice = networkPolicyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["enhanced_firewall_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								enhancedFirewallPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies.EnhancedFirewallPolicies = enhancedFirewallPoliciesInt
								for i, ps := range sl {

									efpMapToStrVal := ps.(map[string]interface{})
									enhancedFirewallPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := efpMapToStrVal["name"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Name = v.(string)
									}

									if v, ok := efpMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := efpMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["active_network_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true
					networkPolicyChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_ActiveNetworkPolicies{}
					networkPolicyChoiceInt.ActiveNetworkPolicies = &ves_io_schema_network_firewall.ActiveNetworkPoliciesType{}
					networkCfgChoiceInt.CustomNetworkConfig.NetworkPolicyChoice = networkPolicyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["network_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								networkPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								networkPolicyChoiceInt.ActiveNetworkPolicies.NetworkPolicies = networkPoliciesInt
								for i, ps := range sl {

									npMapToStrVal := ps.(map[string]interface{})
									networkPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := npMapToStrVal["name"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Name = v.(string)
									}

									if v, ok := npMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := npMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["no_network_policy"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true

					if v.(bool) {
						networkPolicyChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_NoNetworkPolicy{}
						networkPolicyChoiceInt.NoNetworkPolicy = &ves_io_schema.Empty{}
						networkCfgChoiceInt.CustomNetworkConfig.NetworkPolicyChoice = networkPolicyChoiceInt
					}

				}

				if v, ok := cs["outside_nameserver"]; ok && !isIntfNil(v) {

					networkCfgChoiceInt.CustomNetworkConfig.OutsideNameserver = v.(string)

				}

				if v, ok := cs["outside_nameserver_v6"]; ok && !isIntfNil(v) {

					networkCfgChoiceInt.CustomNetworkConfig.OutsideNameserverV6 = v.(string)

				}

				if v, ok := cs["outside_vip"]; ok && !isIntfNil(v) {

					networkCfgChoiceInt.CustomNetworkConfig.OutsideVip = v.(string)

				}

				if v, ok := cs["outside_vip_v6"]; ok && !isIntfNil(v) {

					networkCfgChoiceInt.CustomNetworkConfig.OutsideVipV6 = v.(string)

				}

				siteMeshGroupChoiceTypeFound := false

				if v, ok := cs["site_to_site_tunnel_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

					siteMeshGroupChoiceTypeFound = true
					siteMeshGroupChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_SiteToSiteTunnelIp{}

					networkCfgChoiceInt.CustomNetworkConfig.SiteMeshGroupChoice = siteMeshGroupChoiceInt

					siteMeshGroupChoiceInt.SiteToSiteTunnelIp = v.(string)

				}

				if v, ok := cs["sm_connection_public_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

					siteMeshGroupChoiceTypeFound = true

					if v.(bool) {
						siteMeshGroupChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_SmConnectionPublicIp{}
						siteMeshGroupChoiceInt.SmConnectionPublicIp = &ves_io_schema.Empty{}
						networkCfgChoiceInt.CustomNetworkConfig.SiteMeshGroupChoice = siteMeshGroupChoiceInt
					}

				}

				if v, ok := cs["sm_connection_pvt_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

					siteMeshGroupChoiceTypeFound = true

					if v.(bool) {
						siteMeshGroupChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_SmConnectionPvtIp{}
						siteMeshGroupChoiceInt.SmConnectionPvtIp = &ves_io_schema.Empty{}
						networkCfgChoiceInt.CustomNetworkConfig.SiteMeshGroupChoice = siteMeshGroupChoiceInt
					}

				}

				sliChoiceTypeFound := false

				if v, ok := cs["default_sli_config"]; ok && !isIntfNil(v) && !sliChoiceTypeFound {

					sliChoiceTypeFound = true

					if v.(bool) {
						sliChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_DefaultSliConfig{}
						sliChoiceInt.DefaultSliConfig = &ves_io_schema.Empty{}
						networkCfgChoiceInt.CustomNetworkConfig.SliChoice = sliChoiceInt
					}

				}

				if v, ok := cs["sli_config"]; ok && !isIntfNil(v) && !sliChoiceTypeFound {

					sliChoiceTypeFound = true
					sliChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_SliConfig{}
					sliChoiceInt.SliConfig = &ves_io_schema_views_voltstack_site.SliVnConfiguration{}
					networkCfgChoiceInt.CustomNetworkConfig.SliChoice = sliChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							staticRouteChoiceTypeFound := false

							if v, ok := cs["no_static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

								staticRouteChoiceTypeFound = true

								if v.(bool) {
									staticRouteChoiceInt := &ves_io_schema_views_voltstack_site.SliVnConfiguration_NoStaticRoutes{}
									staticRouteChoiceInt.NoStaticRoutes = &ves_io_schema.Empty{}
									sliChoiceInt.SliConfig.StaticRouteChoice = staticRouteChoiceInt
								}

							}

							if v, ok := cs["static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

								staticRouteChoiceTypeFound = true
								staticRouteChoiceInt := &ves_io_schema_views_voltstack_site.SliVnConfiguration_StaticRoutes{}
								staticRouteChoiceInt.StaticRoutes = &ves_io_schema_views_voltstack_site.StaticRoutesListType{}
								sliChoiceInt.SliConfig.StaticRouteChoice = staticRouteChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											staticRoutes := make([]*ves_io_schema_virtual_network.StaticRouteViewType, len(sl))
											staticRouteChoiceInt.StaticRoutes.StaticRoutes = staticRoutes
											for i, set := range sl {
												if set != nil {
													staticRoutes[i] = &ves_io_schema_virtual_network.StaticRouteViewType{}
													staticRoutesMapStrToI := set.(map[string]interface{})

													if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

														attrsList := []ves_io_schema.RouteAttrType{}
														for _, j := range v.([]interface{}) {
															attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
														}
														staticRoutes[i].Attrs = attrsList

													}

													if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
														ls := make([]string, len(w.([]interface{})))
														for i, v := range w.([]interface{}) {
															ls[i] = v.(string)
														}
														staticRoutes[i].IpPrefixes = ls
													}

													nextHopChoiceTypeFound := false

													if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

														nextHopChoiceTypeFound = true

														if v.(bool) {
															nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_DefaultGateway{}
															nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
															staticRoutes[i].NextHopChoice = nextHopChoiceInt
														}

													}

													if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

														nextHopChoiceTypeFound = true
														nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_Interface{}
														nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
														staticRoutes[i].NextHopChoice = nextHopChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	nextHopChoiceInt.Interface.Name = v.(string)

																}

																if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																	nextHopChoiceInt.Interface.Namespace = v.(string)

																}

																if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																	nextHopChoiceInt.Interface.Tenant = v.(string)

																}

															}
														}

													}

													if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

														nextHopChoiceTypeFound = true
														nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_IpAddress{}

														staticRoutes[i].NextHopChoice = nextHopChoiceInt

														nextHopChoiceInt.IpAddress = v.(string)

													}

												}
											}

										}

									}
								}

							}

							staticV6RouteChoiceTypeFound := false

							if v, ok := cs["no_v6_static_routes"]; ok && !isIntfNil(v) && !staticV6RouteChoiceTypeFound {

								staticV6RouteChoiceTypeFound = true

								if v.(bool) {
									staticV6RouteChoiceInt := &ves_io_schema_views_voltstack_site.SliVnConfiguration_NoV6StaticRoutes{}
									staticV6RouteChoiceInt.NoV6StaticRoutes = &ves_io_schema.Empty{}
									sliChoiceInt.SliConfig.StaticV6RouteChoice = staticV6RouteChoiceInt
								}

							}

							if v, ok := cs["static_v6_routes"]; ok && !isIntfNil(v) && !staticV6RouteChoiceTypeFound {

								staticV6RouteChoiceTypeFound = true
								staticV6RouteChoiceInt := &ves_io_schema_views_voltstack_site.SliVnConfiguration_StaticV6Routes{}
								staticV6RouteChoiceInt.StaticV6Routes = &ves_io_schema_virtual_network.StaticV6RoutesListType{}
								sliChoiceInt.SliConfig.StaticV6RouteChoice = staticV6RouteChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											staticRoutes := make([]*ves_io_schema_virtual_network.StaticV6RouteViewType, len(sl))
											staticV6RouteChoiceInt.StaticV6Routes.StaticRoutes = staticRoutes
											for i, set := range sl {
												if set != nil {
													staticRoutes[i] = &ves_io_schema_virtual_network.StaticV6RouteViewType{}
													staticRoutesMapStrToI := set.(map[string]interface{})

													if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

														attrsList := []ves_io_schema.RouteAttrType{}
														for _, j := range v.([]interface{}) {
															attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
														}
														staticRoutes[i].Attrs = attrsList

													}

													if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
														ls := make([]string, len(w.([]interface{})))
														for i, v := range w.([]interface{}) {
															ls[i] = v.(string)
														}
														staticRoutes[i].IpPrefixes = ls
													}

													nextHopChoiceTypeFound := false

													if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

														nextHopChoiceTypeFound = true

														if v.(bool) {
															nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_DefaultGateway{}
															nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
															staticRoutes[i].NextHopChoice = nextHopChoiceInt
														}

													}

													if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

														nextHopChoiceTypeFound = true
														nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_Interface{}
														nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
														staticRoutes[i].NextHopChoice = nextHopChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	nextHopChoiceInt.Interface.Name = v.(string)

																}

																if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																	nextHopChoiceInt.Interface.Namespace = v.(string)

																}

																if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																	nextHopChoiceInt.Interface.Tenant = v.(string)

																}

															}
														}

													}

													if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

														nextHopChoiceTypeFound = true
														nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_IpAddress{}

														staticRoutes[i].NextHopChoice = nextHopChoiceInt

														nextHopChoiceInt.IpAddress = v.(string)

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				sloChoiceTypeFound := false

				if v, ok := cs["default_config"]; ok && !isIntfNil(v) && !sloChoiceTypeFound {

					sloChoiceTypeFound = true

					if v.(bool) {
						sloChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_DefaultConfig{}
						sloChoiceInt.DefaultConfig = &ves_io_schema.Empty{}
						networkCfgChoiceInt.CustomNetworkConfig.SloChoice = sloChoiceInt
					}

				}

				if v, ok := cs["slo_config"]; ok && !isIntfNil(v) && !sloChoiceTypeFound {

					sloChoiceTypeFound = true
					sloChoiceInt := &ves_io_schema_views_voltstack_site.VssNetworkConfiguration_SloConfig{}
					sloChoiceInt.SloConfig = &ves_io_schema_views_voltstack_site.VnConfiguration{}
					networkCfgChoiceInt.CustomNetworkConfig.SloChoice = sloChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							dcClusterGroupChoiceTypeFound := false

							if v, ok := cs["dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

								dcClusterGroupChoiceTypeFound = true
								dcClusterGroupChoiceInt := &ves_io_schema_views_voltstack_site.VnConfiguration_DcClusterGroup{}
								dcClusterGroupChoiceInt.DcClusterGroup = &ves_io_schema_views.ObjectRefType{}
								sloChoiceInt.SloConfig.DcClusterGroupChoice = dcClusterGroupChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["name"]; ok && !isIntfNil(v) {

											dcClusterGroupChoiceInt.DcClusterGroup.Name = v.(string)

										}

										if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

											dcClusterGroupChoiceInt.DcClusterGroup.Namespace = v.(string)

										}

										if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

											dcClusterGroupChoiceInt.DcClusterGroup.Tenant = v.(string)

										}

									}
								}

							}

							if v, ok := cs["no_dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

								dcClusterGroupChoiceTypeFound = true

								if v.(bool) {
									dcClusterGroupChoiceInt := &ves_io_schema_views_voltstack_site.VnConfiguration_NoDcClusterGroup{}
									dcClusterGroupChoiceInt.NoDcClusterGroup = &ves_io_schema.Empty{}
									sloChoiceInt.SloConfig.DcClusterGroupChoice = dcClusterGroupChoiceInt
								}

							}

							if v, ok := cs["dc_cluster_group_interface"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								dcClusterGroupInterfaceInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								sloChoiceInt.SloConfig.DcClusterGroupInterface = dcClusterGroupInterfaceInt
								for i, ps := range sl {

									dcgiMapToStrVal := ps.(map[string]interface{})
									dcClusterGroupInterfaceInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := dcgiMapToStrVal["name"]; ok && !isIntfNil(v) {
										dcClusterGroupInterfaceInt[i].Name = v.(string)
									}

									if v, ok := dcgiMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										dcClusterGroupInterfaceInt[i].Namespace = v.(string)
									}

									if v, ok := dcgiMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										dcClusterGroupInterfaceInt[i].Tenant = v.(string)
									}

								}

							}

							if v, ok := cs["labels"]; ok && !isIntfNil(v) {

								ms := map[string]string{}
								for k, v := range v.(map[string]interface{}) {
									ms[k] = v.(string)
								}
								sloChoiceInt.SloConfig.Labels = ms
							}

							staticRouteChoiceTypeFound := false

							if v, ok := cs["no_static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

								staticRouteChoiceTypeFound = true

								if v.(bool) {
									staticRouteChoiceInt := &ves_io_schema_views_voltstack_site.VnConfiguration_NoStaticRoutes{}
									staticRouteChoiceInt.NoStaticRoutes = &ves_io_schema.Empty{}
									sloChoiceInt.SloConfig.StaticRouteChoice = staticRouteChoiceInt
								}

							}

							if v, ok := cs["static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

								staticRouteChoiceTypeFound = true
								staticRouteChoiceInt := &ves_io_schema_views_voltstack_site.VnConfiguration_StaticRoutes{}
								staticRouteChoiceInt.StaticRoutes = &ves_io_schema_views_voltstack_site.StaticRoutesListType{}
								sloChoiceInt.SloConfig.StaticRouteChoice = staticRouteChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											staticRoutes := make([]*ves_io_schema_virtual_network.StaticRouteViewType, len(sl))
											staticRouteChoiceInt.StaticRoutes.StaticRoutes = staticRoutes
											for i, set := range sl {
												if set != nil {
													staticRoutes[i] = &ves_io_schema_virtual_network.StaticRouteViewType{}
													staticRoutesMapStrToI := set.(map[string]interface{})

													if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

														attrsList := []ves_io_schema.RouteAttrType{}
														for _, j := range v.([]interface{}) {
															attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
														}
														staticRoutes[i].Attrs = attrsList

													}

													if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
														ls := make([]string, len(w.([]interface{})))
														for i, v := range w.([]interface{}) {
															ls[i] = v.(string)
														}
														staticRoutes[i].IpPrefixes = ls
													}

													nextHopChoiceTypeFound := false

													if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

														nextHopChoiceTypeFound = true

														if v.(bool) {
															nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_DefaultGateway{}
															nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
															staticRoutes[i].NextHopChoice = nextHopChoiceInt
														}

													}

													if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

														nextHopChoiceTypeFound = true
														nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_Interface{}
														nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
														staticRoutes[i].NextHopChoice = nextHopChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	nextHopChoiceInt.Interface.Name = v.(string)

																}

																if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																	nextHopChoiceInt.Interface.Namespace = v.(string)

																}

																if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																	nextHopChoiceInt.Interface.Tenant = v.(string)

																}

															}
														}

													}

													if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

														nextHopChoiceTypeFound = true
														nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_IpAddress{}

														staticRoutes[i].NextHopChoice = nextHopChoiceInt

														nextHopChoiceInt.IpAddress = v.(string)

													}

												}
											}

										}

									}
								}

							}

							staticV6RouteChoiceTypeFound := false

							if v, ok := cs["no_static_v6_routes"]; ok && !isIntfNil(v) && !staticV6RouteChoiceTypeFound {

								staticV6RouteChoiceTypeFound = true

								if v.(bool) {
									staticV6RouteChoiceInt := &ves_io_schema_views_voltstack_site.VnConfiguration_NoStaticV6Routes{}
									staticV6RouteChoiceInt.NoStaticV6Routes = &ves_io_schema.Empty{}
									sloChoiceInt.SloConfig.StaticV6RouteChoice = staticV6RouteChoiceInt
								}

							}

							if v, ok := cs["static_v6_routes"]; ok && !isIntfNil(v) && !staticV6RouteChoiceTypeFound {

								staticV6RouteChoiceTypeFound = true
								staticV6RouteChoiceInt := &ves_io_schema_views_voltstack_site.VnConfiguration_StaticV6Routes{}
								staticV6RouteChoiceInt.StaticV6Routes = &ves_io_schema_virtual_network.StaticV6RoutesListType{}
								sloChoiceInt.SloConfig.StaticV6RouteChoice = staticV6RouteChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											staticRoutes := make([]*ves_io_schema_virtual_network.StaticV6RouteViewType, len(sl))
											staticV6RouteChoiceInt.StaticV6Routes.StaticRoutes = staticRoutes
											for i, set := range sl {
												if set != nil {
													staticRoutes[i] = &ves_io_schema_virtual_network.StaticV6RouteViewType{}
													staticRoutesMapStrToI := set.(map[string]interface{})

													if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

														attrsList := []ves_io_schema.RouteAttrType{}
														for _, j := range v.([]interface{}) {
															attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
														}
														staticRoutes[i].Attrs = attrsList

													}

													if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
														ls := make([]string, len(w.([]interface{})))
														for i, v := range w.([]interface{}) {
															ls[i] = v.(string)
														}
														staticRoutes[i].IpPrefixes = ls
													}

													nextHopChoiceTypeFound := false

													if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

														nextHopChoiceTypeFound = true

														if v.(bool) {
															nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_DefaultGateway{}
															nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
															staticRoutes[i].NextHopChoice = nextHopChoiceInt
														}

													}

													if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

														nextHopChoiceTypeFound = true
														nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_Interface{}
														nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
														staticRoutes[i].NextHopChoice = nextHopChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	nextHopChoiceInt.Interface.Name = v.(string)

																}

																if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																	nextHopChoiceInt.Interface.Namespace = v.(string)

																}

																if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																	nextHopChoiceInt.Interface.Tenant = v.(string)

																}

															}
														}

													}

													if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

														nextHopChoiceTypeFound = true
														nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_IpAddress{}

														staticRoutes[i].NextHopChoice = nextHopChoiceInt

														nextHopChoiceInt.IpAddress = v.(string)

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["tunnel_dead_timeout"]; ok && !isIntfNil(v) {

					networkCfgChoiceInt.CustomNetworkConfig.TunnelDeadTimeout = uint32(v.(int))

				}

				if v, ok := cs["vip_vrrp_mode"]; ok && !isIntfNil(v) {

					networkCfgChoiceInt.CustomNetworkConfig.VipVrrpMode = ves_io_schema.VipVrrpType(ves_io_schema.VipVrrpType_value[v.(string)])

				}

			}
		}

	}

	if v, ok := d.GetOk("default_network_config"); ok && !networkCfgChoiceTypeFound {

		networkCfgChoiceTypeFound = true

		if v.(bool) {
			networkCfgChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_DefaultNetworkConfig{}
			networkCfgChoiceInt.DefaultNetworkConfig = &ves_io_schema.Empty{}
			updateSpec.NetworkCfgChoice = networkCfgChoiceInt
		}

	}

	if v, ok := d.GetOk("offline_survivability_mode"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		offlineSurvivabilityMode := &ves_io_schema_views.OfflineSurvivabilityModeType{}
		updateSpec.OfflineSurvivabilityMode = offlineSurvivabilityMode
		for _, set := range sl {
			if set != nil {
				offlineSurvivabilityModeMapStrToI := set.(map[string]interface{})

				offlineSurvivabilityModeChoiceTypeFound := false

				if v, ok := offlineSurvivabilityModeMapStrToI["enable_offline_survivability_mode"]; ok && !isIntfNil(v) && !offlineSurvivabilityModeChoiceTypeFound {

					offlineSurvivabilityModeChoiceTypeFound = true

					if v.(bool) {
						offlineSurvivabilityModeChoiceInt := &ves_io_schema_views.OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode{}
						offlineSurvivabilityModeChoiceInt.EnableOfflineSurvivabilityMode = &ves_io_schema.Empty{}
						offlineSurvivabilityMode.OfflineSurvivabilityModeChoice = offlineSurvivabilityModeChoiceInt
					}

				}

				if v, ok := offlineSurvivabilityModeMapStrToI["no_offline_survivability_mode"]; ok && !isIntfNil(v) && !offlineSurvivabilityModeChoiceTypeFound {

					offlineSurvivabilityModeChoiceTypeFound = true

					if v.(bool) {
						offlineSurvivabilityModeChoiceInt := &ves_io_schema_views.OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode{}
						offlineSurvivabilityModeChoiceInt.NoOfflineSurvivabilityMode = &ves_io_schema.Empty{}
						offlineSurvivabilityMode.OfflineSurvivabilityModeChoice = offlineSurvivabilityModeChoiceInt
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("os"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		os := &ves_io_schema_views.OperatingSystemType{}
		updateSpec.Os = os
		for _, set := range sl {
			if set != nil {
				osMapStrToI := set.(map[string]interface{})

				operatingSystemVersionChoiceTypeFound := false

				if v, ok := osMapStrToI["default_os_version"]; ok && !isIntfNil(v) && !operatingSystemVersionChoiceTypeFound {

					operatingSystemVersionChoiceTypeFound = true

					if v.(bool) {
						operatingSystemVersionChoiceInt := &ves_io_schema_views.OperatingSystemType_DefaultOsVersion{}
						operatingSystemVersionChoiceInt.DefaultOsVersion = &ves_io_schema.Empty{}
						os.OperatingSystemVersionChoice = operatingSystemVersionChoiceInt
					}

				}

				if v, ok := osMapStrToI["operating_system_version"]; ok && !isIntfNil(v) && !operatingSystemVersionChoiceTypeFound {

					operatingSystemVersionChoiceTypeFound = true
					operatingSystemVersionChoiceInt := &ves_io_schema_views.OperatingSystemType_OperatingSystemVersion{}

					os.OperatingSystemVersionChoice = operatingSystemVersionChoiceInt

					operatingSystemVersionChoiceInt.OperatingSystemVersion = v.(string)

				}

			}
		}

	}

	sriovInterfaceChoiceTypeFound := false

	if v, ok := d.GetOk("default_sriov_interface"); ok && !sriovInterfaceChoiceTypeFound {

		sriovInterfaceChoiceTypeFound = true

		if v.(bool) {
			sriovInterfaceChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_DefaultSriovInterface{}
			sriovInterfaceChoiceInt.DefaultSriovInterface = &ves_io_schema.Empty{}
			updateSpec.SriovInterfaceChoice = sriovInterfaceChoiceInt
		}

	}

	if v, ok := d.GetOk("sriov_interfaces"); ok && !sriovInterfaceChoiceTypeFound {

		sriovInterfaceChoiceTypeFound = true
		sriovInterfaceChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_SriovInterfaces{}
		sriovInterfaceChoiceInt.SriovInterfaces = &ves_io_schema_fleet.SriovInterfacesListType{}
		updateSpec.SriovInterfaceChoice = sriovInterfaceChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["sriov_interface"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					sriovInterface := make([]*ves_io_schema_fleet.SriovInterface, len(sl))
					sriovInterfaceChoiceInt.SriovInterfaces.SriovInterface = sriovInterface
					for i, set := range sl {
						if set != nil {
							sriovInterface[i] = &ves_io_schema_fleet.SriovInterface{}
							sriovInterfaceMapStrToI := set.(map[string]interface{})

							if w, ok := sriovInterfaceMapStrToI["interface_name"]; ok && !isIntfNil(w) {
								sriovInterface[i].InterfaceName = w.(string)
							}

							if w, ok := sriovInterfaceMapStrToI["number_of_vfio_vfs"]; ok && !isIntfNil(w) {
								sriovInterface[i].NumberOfVfioVfs = uint32(w.(int))
							}

							if w, ok := sriovInterfaceMapStrToI["number_of_vfs"]; ok && !isIntfNil(w) {
								sriovInterface[i].NumberOfVfs = uint32(w.(int))
							}

						}
					}

				}

			}
		}

	}

	storageCfgChoiceTypeFound := false

	if v, ok := d.GetOk("custom_storage_config"); ok && !storageCfgChoiceTypeFound {

		storageCfgChoiceTypeFound = true
		storageCfgChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_CustomStorageConfig{}
		storageCfgChoiceInt.CustomStorageConfig = &ves_io_schema_views_voltstack_site.VssStorageConfiguration{}
		updateSpec.StorageCfgChoice = storageCfgChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				staticRouteChoiceTypeFound := false

				if v, ok := cs["no_static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

					staticRouteChoiceTypeFound = true

					if v.(bool) {
						staticRouteChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_NoStaticRoutes{}
						staticRouteChoiceInt.NoStaticRoutes = &ves_io_schema.Empty{}
						storageCfgChoiceInt.CustomStorageConfig.StaticRouteChoice = staticRouteChoiceInt
					}

				}

				if v, ok := cs["static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

					staticRouteChoiceTypeFound = true
					staticRouteChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_StaticRoutes{}
					staticRouteChoiceInt.StaticRoutes = &ves_io_schema_views_voltstack_site.StaticRoutesListType{}
					storageCfgChoiceInt.CustomStorageConfig.StaticRouteChoice = staticRouteChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRoutes := make([]*ves_io_schema_virtual_network.StaticRouteViewType, len(sl))
								staticRouteChoiceInt.StaticRoutes.StaticRoutes = staticRoutes
								for i, set := range sl {
									if set != nil {
										staticRoutes[i] = &ves_io_schema_virtual_network.StaticRouteViewType{}
										staticRoutesMapStrToI := set.(map[string]interface{})

										if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

											attrsList := []ves_io_schema.RouteAttrType{}
											for _, j := range v.([]interface{}) {
												attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
											}
											staticRoutes[i].Attrs = attrsList

										}

										if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
											ls := make([]string, len(w.([]interface{})))
											for i, v := range w.([]interface{}) {
												ls[i] = v.(string)
											}
											staticRoutes[i].IpPrefixes = ls
										}

										nextHopChoiceTypeFound := false

										if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

											nextHopChoiceTypeFound = true

											if v.(bool) {
												nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_DefaultGateway{}
												nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
												staticRoutes[i].NextHopChoice = nextHopChoiceInt
											}

										}

										if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

											nextHopChoiceTypeFound = true
											nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_Interface{}
											nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
											staticRoutes[i].NextHopChoice = nextHopChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														nextHopChoiceInt.Interface.Name = v.(string)

													}

													if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

														nextHopChoiceInt.Interface.Namespace = v.(string)

													}

													if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

														nextHopChoiceInt.Interface.Tenant = v.(string)

													}

												}
											}

										}

										if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

											nextHopChoiceTypeFound = true
											nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_IpAddress{}

											staticRoutes[i].NextHopChoice = nextHopChoiceInt

											nextHopChoiceInt.IpAddress = v.(string)

										}

									}
								}

							}

						}
					}

				}

				storageClassChoiceTypeFound := false

				if v, ok := cs["default_storage_class"]; ok && !isIntfNil(v) && !storageClassChoiceTypeFound {

					storageClassChoiceTypeFound = true

					if v.(bool) {
						storageClassChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_DefaultStorageClass{}
						storageClassChoiceInt.DefaultStorageClass = &ves_io_schema.Empty{}
						storageCfgChoiceInt.CustomStorageConfig.StorageClassChoice = storageClassChoiceInt
					}

				}

				if v, ok := cs["storage_class_list"]; ok && !isIntfNil(v) && !storageClassChoiceTypeFound {

					storageClassChoiceTypeFound = true
					storageClassChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_StorageClassList{}
					storageClassChoiceInt.StorageClassList = &ves_io_schema_fleet.FleetStorageClassListType{}
					storageCfgChoiceInt.CustomStorageConfig.StorageClassChoice = storageClassChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["storage_classes"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								storageClasses := make([]*ves_io_schema_fleet.FleetStorageClassType, len(sl))
								storageClassChoiceInt.StorageClassList.StorageClasses = storageClasses
								for i, set := range sl {
									if set != nil {
										storageClasses[i] = &ves_io_schema_fleet.FleetStorageClassType{}
										storageClassesMapStrToI := set.(map[string]interface{})

										if w, ok := storageClassesMapStrToI["advanced_storage_parameters"]; ok && !isIntfNil(w) {
											ms := map[string]string{}
											for k, v := range w.(map[string]interface{}) {
												ms[k] = v.(string)
											}
											storageClasses[i].AdvancedStorageParameters = ms
										}

										if w, ok := storageClassesMapStrToI["allow_volume_expansion"]; ok && !isIntfNil(w) {
											storageClasses[i].AllowVolumeExpansion = w.(bool)
										}

										if w, ok := storageClassesMapStrToI["default_storage_class"]; ok && !isIntfNil(w) {
											storageClasses[i].DefaultStorageClass = w.(bool)
										}

										if w, ok := storageClassesMapStrToI["description"]; ok && !isIntfNil(w) {
											storageClasses[i].Description = w.(string)
										}

										deviceChoiceTypeFound := false

										if v, ok := storageClassesMapStrToI["custom_storage"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

											deviceChoiceTypeFound = true
											deviceChoiceInt := &ves_io_schema_fleet.FleetStorageClassType_CustomStorage{}
											deviceChoiceInt.CustomStorage = &ves_io_schema_fleet.StorageClassCustomType{}
											storageClasses[i].DeviceChoice = deviceChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["yaml"]; ok && !isIntfNil(v) {

														deviceChoiceInt.CustomStorage.Yaml = v.(string)

													}

												}
											}

										}

										if v, ok := storageClassesMapStrToI["hpe_storage"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

											deviceChoiceTypeFound = true
											deviceChoiceInt := &ves_io_schema_fleet.FleetStorageClassType_HpeStorage{}
											deviceChoiceInt.HpeStorage = &ves_io_schema_fleet.StorageClassHpeStorageType{}
											storageClasses[i].DeviceChoice = deviceChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["allow_mutations"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.AllowMutations = v.(string)

													}

													if v, ok := cs["allow_overrides"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.AllowOverrides = v.(string)

													}

													if v, ok := cs["dedupe_enabled"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.DedupeEnabled = v.(bool)

													}

													if v, ok := cs["description"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.Description = v.(string)

													}

													if v, ok := cs["destroy_on_delete"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.DestroyOnDelete = v.(bool)

													}

													if v, ok := cs["encrypted"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.Encrypted = v.(bool)

													}

													if v, ok := cs["folder"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.Folder = v.(string)

													}

													if v, ok := cs["limit_iops"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.LimitIops = int64(v.(int))

													}

													if v, ok := cs["limit_mbps"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.LimitMbps = int64(v.(int))

													}

													if v, ok := cs["performance_policy"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.PerformancePolicy = v.(string)

													}

													if v, ok := cs["pool"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.Pool = v.(string)

													}

													if v, ok := cs["protection_template"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.ProtectionTemplate = v.(string)

													}

													if v, ok := cs["secret_name"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.SecretName = v.(string)

													}

													if v, ok := cs["secret_namespace"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.SecretNamespace = v.(string)

													}

													if v, ok := cs["sync_on_detach"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.SyncOnDetach = v.(bool)

													}

													if v, ok := cs["thick"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.Thick = v.(bool)

													}

												}
											}

										}

										if v, ok := storageClassesMapStrToI["netapp_trident"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

											deviceChoiceTypeFound = true
											deviceChoiceInt := &ves_io_schema_fleet.FleetStorageClassType_NetappTrident{}
											deviceChoiceInt.NetappTrident = &ves_io_schema_fleet.StorageClassNetappTridentType{}
											storageClasses[i].DeviceChoice = deviceChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["selector"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														deviceChoiceInt.NetappTrident.Selector = ms
													}

													if v, ok := cs["storage_pools"]; ok && !isIntfNil(v) {

														deviceChoiceInt.NetappTrident.StoragePools = v.(string)

													}

												}
											}

										}

										if v, ok := storageClassesMapStrToI["pure_service_orchestrator"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

											deviceChoiceTypeFound = true
											deviceChoiceInt := &ves_io_schema_fleet.FleetStorageClassType_PureServiceOrchestrator{}
											deviceChoiceInt.PureServiceOrchestrator = &ves_io_schema_fleet.StorageClassPureServiceOrchestratorType{}
											storageClasses[i].DeviceChoice = deviceChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["backend"]; ok && !isIntfNil(v) {

														deviceChoiceInt.PureServiceOrchestrator.Backend = v.(string)

													}

													if v, ok := cs["bandwidth_limit"]; ok && !isIntfNil(v) {

														deviceChoiceInt.PureServiceOrchestrator.BandwidthLimit = v.(string)

													}

													if v, ok := cs["iops_limit"]; ok && !isIntfNil(v) {

														deviceChoiceInt.PureServiceOrchestrator.IopsLimit = uint32(v.(int))

													}

												}
											}

										}

										if w, ok := storageClassesMapStrToI["reclaim_policy"]; ok && !isIntfNil(w) {
											storageClasses[i].ReclaimPolicy = w.(string)
										}

										if w, ok := storageClassesMapStrToI["storage_class_name"]; ok && !isIntfNil(w) {
											storageClasses[i].StorageClassName = w.(string)
										}

										if w, ok := storageClassesMapStrToI["storage_device"]; ok && !isIntfNil(w) {
											storageClasses[i].StorageDevice = w.(string)
										}

									}
								}

							}

						}
					}

				}

				storageDeviceChoiceTypeFound := false

				if v, ok := cs["no_storage_device"]; ok && !isIntfNil(v) && !storageDeviceChoiceTypeFound {

					storageDeviceChoiceTypeFound = true

					if v.(bool) {
						storageDeviceChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_NoStorageDevice{}
						storageDeviceChoiceInt.NoStorageDevice = &ves_io_schema.Empty{}
						storageCfgChoiceInt.CustomStorageConfig.StorageDeviceChoice = storageDeviceChoiceInt
					}

				}

				if v, ok := cs["storage_device_list"]; ok && !isIntfNil(v) && !storageDeviceChoiceTypeFound {

					storageDeviceChoiceTypeFound = true
					storageDeviceChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_StorageDeviceList{}
					storageDeviceChoiceInt.StorageDeviceList = &ves_io_schema_fleet.FleetStorageDeviceListType{}
					storageCfgChoiceInt.CustomStorageConfig.StorageDeviceChoice = storageDeviceChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["storage_devices"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								storageDevices := make([]*ves_io_schema_fleet.FleetStorageDeviceType, len(sl))
								storageDeviceChoiceInt.StorageDeviceList.StorageDevices = storageDevices
								for i, set := range sl {
									if set != nil {
										storageDevices[i] = &ves_io_schema_fleet.FleetStorageDeviceType{}
										storageDevicesMapStrToI := set.(map[string]interface{})

										if w, ok := storageDevicesMapStrToI["advanced_advanced_parameters"]; ok && !isIntfNil(w) {
											ms := map[string]string{}
											for k, v := range w.(map[string]interface{}) {
												ms[k] = v.(string)
											}
											storageDevices[i].AdvancedAdvancedParameters = ms
										}

										deviceChoiceTypeFound := false

										if v, ok := storageDevicesMapStrToI["custom_storage"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

											deviceChoiceTypeFound = true

											if v.(bool) {
												deviceChoiceInt := &ves_io_schema_fleet.FleetStorageDeviceType_CustomStorage{}
												deviceChoiceInt.CustomStorage = &ves_io_schema.Empty{}
												storageDevices[i].DeviceChoice = deviceChoiceInt
											}

										}

										if v, ok := storageDevicesMapStrToI["hpe_storage"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

											deviceChoiceTypeFound = true
											deviceChoiceInt := &ves_io_schema_fleet.FleetStorageDeviceType_HpeStorage{}
											deviceChoiceInt.HpeStorage = &ves_io_schema_fleet.StorageDeviceHpeStorageType{}
											storageDevices[i].DeviceChoice = deviceChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["api_server_port"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.ApiServerPort = uint32(v.(int))

													}

													if v, ok := cs["csi_version"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.CsiVersion = v.(string)

													}

													if v, ok := cs["iscsi_chap_password"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														iscsiChapPassword := &ves_io_schema.SecretType{}
														deviceChoiceInt.HpeStorage.IscsiChapPassword = iscsiChapPassword
														for _, set := range sl {
															if set != nil {
																iscsiChapPasswordMapStrToI := set.(map[string]interface{})

																if v, ok := iscsiChapPasswordMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																	iscsiChapPassword.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																	for _, set := range sl {
																		if set != nil {
																			blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																			if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																				blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																			}

																			if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																				blindfoldSecretInfoInternal.Location = w.(string)
																			}

																			if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																				blindfoldSecretInfoInternal.StoreProvider = w.(string)
																			}

																		}
																	}

																}

																if v, ok := iscsiChapPasswordMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																	iscsiChapPassword.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																}

																secretInfoOneofTypeFound := false

																if v, ok := iscsiChapPasswordMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																	secretInfoOneofTypeFound = true
																	secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																	secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																	iscsiChapPassword.SecretInfoOneof = secretInfoOneofInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																			}

																			if v, ok := cs["location"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																			}

																			if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																			}

																		}
																	}

																}

																if v, ok := iscsiChapPasswordMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																	secretInfoOneofTypeFound = true
																	secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																	secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																	iscsiChapPassword.SecretInfoOneof = secretInfoOneofInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																			}

																			if v, ok := cs["url"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																			}

																		}
																	}

																}

																if v, ok := iscsiChapPasswordMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																	secretInfoOneofTypeFound = true
																	secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																	secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																	iscsiChapPassword.SecretInfoOneof = secretInfoOneofInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["key"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																			}

																			if v, ok := cs["location"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																			}

																			if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																			}

																			if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																			}

																			if v, ok := cs["version"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																			}

																		}
																	}

																}

																if v, ok := iscsiChapPasswordMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																	secretInfoOneofTypeFound = true
																	secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																	secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																	iscsiChapPassword.SecretInfoOneof = secretInfoOneofInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["name"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := cs["iscsi_chap_user"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.IscsiChapUser = v.(string)

													}

													if v, ok := cs["log_level"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.LogLevel = v.(string)

													}

													if v, ok := cs["password"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														password := &ves_io_schema.SecretType{}
														deviceChoiceInt.HpeStorage.Password = password
														for _, set := range sl {
															if set != nil {
																passwordMapStrToI := set.(map[string]interface{})

																if v, ok := passwordMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																	password.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																	for _, set := range sl {
																		if set != nil {
																			blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																			if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																				blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																			}

																			if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																				blindfoldSecretInfoInternal.Location = w.(string)
																			}

																			if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																				blindfoldSecretInfoInternal.StoreProvider = w.(string)
																			}

																		}
																	}

																}

																if v, ok := passwordMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																	password.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																}

																secretInfoOneofTypeFound := false

																if v, ok := passwordMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																	secretInfoOneofTypeFound = true
																	secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																	secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																	password.SecretInfoOneof = secretInfoOneofInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																			}

																			if v, ok := cs["location"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																			}

																			if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																			}

																		}
																	}

																}

																if v, ok := passwordMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																	secretInfoOneofTypeFound = true
																	secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																	secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																	password.SecretInfoOneof = secretInfoOneofInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																			}

																			if v, ok := cs["url"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																			}

																		}
																	}

																}

																if v, ok := passwordMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																	secretInfoOneofTypeFound = true
																	secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																	secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																	password.SecretInfoOneof = secretInfoOneofInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["key"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																			}

																			if v, ok := cs["location"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																			}

																			if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																			}

																			if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																			}

																			if v, ok := cs["version"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																			}

																		}
																	}

																}

																if v, ok := passwordMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																	secretInfoOneofTypeFound = true
																	secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																	secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																	password.SecretInfoOneof = secretInfoOneofInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["name"]; ok && !isIntfNil(v) {

																				secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := cs["storage_server_ip_address"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.StorageServerIpAddress = v.(string)

													}

													if v, ok := cs["storage_server_name"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.StorageServerName = v.(string)

													}

													if v, ok := cs["username"]; ok && !isIntfNil(v) {

														deviceChoiceInt.HpeStorage.Username = v.(string)

													}

												}
											}

										}

										if v, ok := storageDevicesMapStrToI["netapp_trident"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

											deviceChoiceTypeFound = true
											deviceChoiceInt := &ves_io_schema_fleet.FleetStorageDeviceType_NetappTrident{}
											deviceChoiceInt.NetappTrident = &ves_io_schema_fleet.StorageDeviceNetappTridentType{}
											storageDevices[i].DeviceChoice = deviceChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													backendChoiceTypeFound := false

													if v, ok := cs["netapp_backend_ontap_nas"]; ok && !isIntfNil(v) && !backendChoiceTypeFound {

														backendChoiceTypeFound = true
														backendChoiceInt := &ves_io_schema_fleet.StorageDeviceNetappTridentType_NetappBackendOntapNas{}
														backendChoiceInt.NetappBackendOntapNas = &ves_io_schema_fleet.StorageDeviceNetappBackendOntapNasType{}
														deviceChoiceInt.NetappTrident.BackendChoice = backendChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["auto_export_cidrs"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	autoExportCidrs := &ves_io_schema_views.PrefixStringListType{}
																	backendChoiceInt.NetappBackendOntapNas.AutoExportCidrs = autoExportCidrs
																	for _, set := range sl {
																		if set != nil {
																			autoExportCidrsMapStrToI := set.(map[string]interface{})

																			if w, ok := autoExportCidrsMapStrToI["ipv6_prefixes"]; ok && !isIntfNil(w) {
																				ls := make([]string, len(w.([]interface{})))
																				for i, v := range w.([]interface{}) {
																					ls[i] = v.(string)
																				}
																				autoExportCidrs.Ipv6Prefixes = ls
																			}

																			if w, ok := autoExportCidrsMapStrToI["prefixes"]; ok && !isIntfNil(w) {
																				ls := make([]string, len(w.([]interface{})))
																				for i, v := range w.([]interface{}) {
																					ls[i] = v.(string)
																				}
																				autoExportCidrs.Prefixes = ls
																			}

																		}
																	}

																}

																if v, ok := cs["auto_export_policy"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapNas.AutoExportPolicy = v.(bool)

																}

																if v, ok := cs["backend_name"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapNas.BackendName = v.(string)

																}

																if v, ok := cs["client_certificate"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapNas.ClientCertificate = v.(string)

																}

																if v, ok := cs["client_private_key"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	clientPrivateKey := &ves_io_schema.SecretType{}
																	backendChoiceInt.NetappBackendOntapNas.ClientPrivateKey = clientPrivateKey
																	for _, set := range sl {
																		if set != nil {
																			clientPrivateKeyMapStrToI := set.(map[string]interface{})

																			if v, ok := clientPrivateKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																				clientPrivateKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																				for _, set := range sl {
																					if set != nil {
																						blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																						if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																							blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																						}

																						if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																							blindfoldSecretInfoInternal.Location = w.(string)
																						}

																						if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																							blindfoldSecretInfoInternal.StoreProvider = w.(string)
																						}

																					}
																				}

																			}

																			if v, ok := clientPrivateKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																				clientPrivateKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																			}

																			secretInfoOneofTypeFound := false

																			if v, ok := clientPrivateKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																				secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																				clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																						}

																						if v, ok := cs["location"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																						}

																						if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := clientPrivateKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																				secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																				clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																						}

																						if v, ok := cs["url"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := clientPrivateKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																				secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																				clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["key"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																						}

																						if v, ok := cs["location"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																						}

																						if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																						}

																						if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																						}

																						if v, ok := cs["version"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																						}

																					}
																				}

																			}

																			if v, ok := clientPrivateKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																				secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																				clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["name"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																dataLifTypeFound := false

																if v, ok := cs["data_lif_dns_name"]; ok && !isIntfNil(v) && !dataLifTypeFound {

																	dataLifTypeFound = true
																	dataLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapNasType_DataLifDnsName{}

																	backendChoiceInt.NetappBackendOntapNas.DataLif = dataLifInt

																	dataLifInt.DataLifDnsName = v.(string)

																}

																if v, ok := cs["data_lif_ip"]; ok && !isIntfNil(v) && !dataLifTypeFound {

																	dataLifTypeFound = true
																	dataLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapNasType_DataLifIp{}

																	backendChoiceInt.NetappBackendOntapNas.DataLif = dataLifInt

																	dataLifInt.DataLifIp = v.(string)

																}

																if v, ok := cs["labels"]; ok && !isIntfNil(v) {

																	ms := map[string]string{}
																	for k, v := range v.(map[string]interface{}) {
																		ms[k] = v.(string)
																	}
																	backendChoiceInt.NetappBackendOntapNas.Labels = ms
																}

																if v, ok := cs["limit_aggregate_usage"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapNas.LimitAggregateUsage = v.(string)

																}

																if v, ok := cs["limit_volume_size"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapNas.LimitVolumeSize = v.(string)

																}

																managementLifTypeFound := false

																if v, ok := cs["management_lif_dns_name"]; ok && !isIntfNil(v) && !managementLifTypeFound {

																	managementLifTypeFound = true
																	managementLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName{}

																	backendChoiceInt.NetappBackendOntapNas.ManagementLif = managementLifInt

																	managementLifInt.ManagementLifDnsName = v.(string)

																}

																if v, ok := cs["management_lif_ip"]; ok && !isIntfNil(v) && !managementLifTypeFound {

																	managementLifTypeFound = true
																	managementLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapNasType_ManagementLifIp{}

																	backendChoiceInt.NetappBackendOntapNas.ManagementLif = managementLifInt

																	managementLifInt.ManagementLifIp = v.(string)

																}

																if v, ok := cs["nfs_mount_options"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapNas.NfsMountOptions = v.(string)

																}

																if v, ok := cs["password"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	password := &ves_io_schema.SecretType{}
																	backendChoiceInt.NetappBackendOntapNas.Password = password
																	for _, set := range sl {
																		if set != nil {
																			passwordMapStrToI := set.(map[string]interface{})

																			if v, ok := passwordMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																				password.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																				for _, set := range sl {
																					if set != nil {
																						blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																						if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																							blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																						}

																						if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																							blindfoldSecretInfoInternal.Location = w.(string)
																						}

																						if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																							blindfoldSecretInfoInternal.StoreProvider = w.(string)
																						}

																					}
																				}

																			}

																			if v, ok := passwordMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																				password.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																			}

																			secretInfoOneofTypeFound := false

																			if v, ok := passwordMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																				secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																				password.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																						}

																						if v, ok := cs["location"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																						}

																						if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := passwordMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																				secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																				password.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																						}

																						if v, ok := cs["url"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := passwordMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																				secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																				password.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["key"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																						}

																						if v, ok := cs["location"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																						}

																						if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																						}

																						if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																						}

																						if v, ok := cs["version"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																						}

																					}
																				}

																			}

																			if v, ok := passwordMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																				secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																				password.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["name"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["region"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapNas.Region = v.(string)

																}

																if v, ok := cs["storage"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	storage := make([]*ves_io_schema_fleet.OntapVirtualStoragePoolType, len(sl))
																	backendChoiceInt.NetappBackendOntapNas.Storage = storage
																	for i, set := range sl {
																		if set != nil {
																			storage[i] = &ves_io_schema_fleet.OntapVirtualStoragePoolType{}
																			storageMapStrToI := set.(map[string]interface{})

																			if w, ok := storageMapStrToI["labels"]; ok && !isIntfNil(w) {
																				ms := map[string]string{}
																				for k, v := range w.(map[string]interface{}) {
																					ms[k] = v.(string)
																				}
																				storage[i].Labels = ms
																			}

																			if v, ok := storageMapStrToI["volume_defaults"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				volumeDefaults := &ves_io_schema_fleet.OntapVolumeDefaults{}
																				storage[i].VolumeDefaults = volumeDefaults
																				for _, set := range sl {
																					if set != nil {
																						volumeDefaultsMapStrToI := set.(map[string]interface{})

																						if w, ok := volumeDefaultsMapStrToI["encryption"]; ok && !isIntfNil(w) {
																							volumeDefaults.Encryption = w.(bool)
																						}

																						if w, ok := volumeDefaultsMapStrToI["export_policy"]; ok && !isIntfNil(w) {
																							volumeDefaults.ExportPolicy = w.(string)
																						}

																						qosPolicyChoiceTypeFound := false

																						if v, ok := volumeDefaultsMapStrToI["adaptive_qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																							qosPolicyChoiceTypeFound = true
																							qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_AdaptiveQosPolicy{}

																							volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

																							qosPolicyChoiceInt.AdaptiveQosPolicy = v.(string)

																						}

																						if v, ok := volumeDefaultsMapStrToI["no_qos"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																							qosPolicyChoiceTypeFound = true

																							if v.(bool) {
																								qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_NoQos{}
																								qosPolicyChoiceInt.NoQos = &ves_io_schema.Empty{}
																								volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt
																							}

																						}

																						if v, ok := volumeDefaultsMapStrToI["qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																							qosPolicyChoiceTypeFound = true
																							qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_QosPolicy{}

																							volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

																							qosPolicyChoiceInt.QosPolicy = v.(string)

																						}

																						if w, ok := volumeDefaultsMapStrToI["security_style"]; ok && !isIntfNil(w) {
																							volumeDefaults.SecurityStyle = w.(string)
																						}

																						if w, ok := volumeDefaultsMapStrToI["snapshot_dir"]; ok && !isIntfNil(w) {
																							volumeDefaults.SnapshotDir = w.(bool)
																						}

																						if w, ok := volumeDefaultsMapStrToI["snapshot_policy"]; ok && !isIntfNil(w) {
																							volumeDefaults.SnapshotPolicy = w.(string)
																						}

																						if w, ok := volumeDefaultsMapStrToI["snapshot_reserve"]; ok && !isIntfNil(w) {
																							volumeDefaults.SnapshotReserve = w.(string)
																						}

																						if w, ok := volumeDefaultsMapStrToI["space_reserve"]; ok && !isIntfNil(w) {
																							volumeDefaults.SpaceReserve = w.(string)
																						}

																						if w, ok := volumeDefaultsMapStrToI["split_on_clone"]; ok && !isIntfNil(w) {
																							volumeDefaults.SplitOnClone = w.(bool)
																						}

																						if w, ok := volumeDefaultsMapStrToI["tiering_policy"]; ok && !isIntfNil(w) {
																							volumeDefaults.TieringPolicy = w.(string)
																						}

																						if w, ok := volumeDefaultsMapStrToI["unix_permissions"]; ok && !isIntfNil(w) {
																							volumeDefaults.UnixPermissions = int32(w.(int))
																						}

																					}
																				}

																			}

																			if w, ok := storageMapStrToI["zone"]; ok && !isIntfNil(w) {
																				storage[i].Zone = w.(string)
																			}

																		}
																	}

																}

																if v, ok := cs["storage_driver_name"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapNas.StorageDriverName = v.(string)

																}

																if v, ok := cs["storage_prefix"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapNas.StoragePrefix = v.(string)

																}

																if v, ok := cs["svm"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapNas.Svm = v.(string)

																}

																if v, ok := cs["trusted_ca_certificate"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapNas.TrustedCaCertificate = v.(string)

																}

																if v, ok := cs["username"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapNas.Username = v.(string)

																}

																if v, ok := cs["volume_defaults"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	volumeDefaults := &ves_io_schema_fleet.OntapVolumeDefaults{}
																	backendChoiceInt.NetappBackendOntapNas.VolumeDefaults = volumeDefaults
																	for _, set := range sl {
																		if set != nil {
																			volumeDefaultsMapStrToI := set.(map[string]interface{})

																			if w, ok := volumeDefaultsMapStrToI["encryption"]; ok && !isIntfNil(w) {
																				volumeDefaults.Encryption = w.(bool)
																			}

																			if w, ok := volumeDefaultsMapStrToI["export_policy"]; ok && !isIntfNil(w) {
																				volumeDefaults.ExportPolicy = w.(string)
																			}

																			qosPolicyChoiceTypeFound := false

																			if v, ok := volumeDefaultsMapStrToI["adaptive_qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																				qosPolicyChoiceTypeFound = true
																				qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_AdaptiveQosPolicy{}

																				volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

																				qosPolicyChoiceInt.AdaptiveQosPolicy = v.(string)

																			}

																			if v, ok := volumeDefaultsMapStrToI["no_qos"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																				qosPolicyChoiceTypeFound = true

																				if v.(bool) {
																					qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_NoQos{}
																					qosPolicyChoiceInt.NoQos = &ves_io_schema.Empty{}
																					volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt
																				}

																			}

																			if v, ok := volumeDefaultsMapStrToI["qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																				qosPolicyChoiceTypeFound = true
																				qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_QosPolicy{}

																				volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

																				qosPolicyChoiceInt.QosPolicy = v.(string)

																			}

																			if w, ok := volumeDefaultsMapStrToI["security_style"]; ok && !isIntfNil(w) {
																				volumeDefaults.SecurityStyle = w.(string)
																			}

																			if w, ok := volumeDefaultsMapStrToI["snapshot_dir"]; ok && !isIntfNil(w) {
																				volumeDefaults.SnapshotDir = w.(bool)
																			}

																			if w, ok := volumeDefaultsMapStrToI["snapshot_policy"]; ok && !isIntfNil(w) {
																				volumeDefaults.SnapshotPolicy = w.(string)
																			}

																			if w, ok := volumeDefaultsMapStrToI["snapshot_reserve"]; ok && !isIntfNil(w) {
																				volumeDefaults.SnapshotReserve = w.(string)
																			}

																			if w, ok := volumeDefaultsMapStrToI["space_reserve"]; ok && !isIntfNil(w) {
																				volumeDefaults.SpaceReserve = w.(string)
																			}

																			if w, ok := volumeDefaultsMapStrToI["split_on_clone"]; ok && !isIntfNil(w) {
																				volumeDefaults.SplitOnClone = w.(bool)
																			}

																			if w, ok := volumeDefaultsMapStrToI["tiering_policy"]; ok && !isIntfNil(w) {
																				volumeDefaults.TieringPolicy = w.(string)
																			}

																			if w, ok := volumeDefaultsMapStrToI["unix_permissions"]; ok && !isIntfNil(w) {
																				volumeDefaults.UnixPermissions = int32(w.(int))
																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := cs["netapp_backend_ontap_san"]; ok && !isIntfNil(v) && !backendChoiceTypeFound {

														backendChoiceTypeFound = true
														backendChoiceInt := &ves_io_schema_fleet.StorageDeviceNetappTridentType_NetappBackendOntapSan{}
														backendChoiceInt.NetappBackendOntapSan = &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType{}
														deviceChoiceInt.NetappTrident.BackendChoice = backendChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																chapChoiceTypeFound := false

																if v, ok := cs["no_chap"]; ok && !isIntfNil(v) && !chapChoiceTypeFound {

																	chapChoiceTypeFound = true

																	if v.(bool) {
																		chapChoiceInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType_NoChap{}
																		chapChoiceInt.NoChap = &ves_io_schema.Empty{}
																		backendChoiceInt.NetappBackendOntapSan.ChapChoice = chapChoiceInt
																	}

																}

																if v, ok := cs["use_chap"]; ok && !isIntfNil(v) && !chapChoiceTypeFound {

																	chapChoiceTypeFound = true
																	chapChoiceInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType_UseChap{}
																	chapChoiceInt.UseChap = &ves_io_schema_fleet.DeviceNetappBackendOntapSanChapType{}
																	backendChoiceInt.NetappBackendOntapSan.ChapChoice = chapChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["chap_initiator_secret"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				chapInitiatorSecret := &ves_io_schema.SecretType{}
																				chapChoiceInt.UseChap.ChapInitiatorSecret = chapInitiatorSecret
																				for _, set := range sl {
																					if set != nil {
																						chapInitiatorSecretMapStrToI := set.(map[string]interface{})

																						if v, ok := chapInitiatorSecretMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																							sl := v.([]interface{})
																							blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																							chapInitiatorSecret.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																							for _, set := range sl {
																								if set != nil {
																									blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																									if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																										blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																									}

																									if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																										blindfoldSecretInfoInternal.Location = w.(string)
																									}

																									if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																										blindfoldSecretInfoInternal.StoreProvider = w.(string)
																									}

																								}
																							}

																						}

																						if v, ok := chapInitiatorSecretMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																							chapInitiatorSecret.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																						}

																						secretInfoOneofTypeFound := false

																						if v, ok := chapInitiatorSecretMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																							secretInfoOneofTypeFound = true
																							secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																							secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																							chapInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																									}

																									if v, ok := cs["location"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																									}

																									if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																									}

																								}
																							}

																						}

																						if v, ok := chapInitiatorSecretMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																							secretInfoOneofTypeFound = true
																							secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																							secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																							chapInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																									}

																									if v, ok := cs["url"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																									}

																								}
																							}

																						}

																						if v, ok := chapInitiatorSecretMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																							secretInfoOneofTypeFound = true
																							secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																							secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																							chapInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["key"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																									}

																									if v, ok := cs["location"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																									}

																									if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																									}

																									if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																									}

																									if v, ok := cs["version"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																									}

																								}
																							}

																						}

																						if v, ok := chapInitiatorSecretMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																							secretInfoOneofTypeFound = true
																							secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																							secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																							chapInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["name"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																									}

																								}
																							}

																						}

																					}
																				}

																			}

																			if v, ok := cs["chap_target_initiator_secret"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				chapTargetInitiatorSecret := &ves_io_schema.SecretType{}
																				chapChoiceInt.UseChap.ChapTargetInitiatorSecret = chapTargetInitiatorSecret
																				for _, set := range sl {
																					if set != nil {
																						chapTargetInitiatorSecretMapStrToI := set.(map[string]interface{})

																						if v, ok := chapTargetInitiatorSecretMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																							sl := v.([]interface{})
																							blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																							chapTargetInitiatorSecret.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																							for _, set := range sl {
																								if set != nil {
																									blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																									if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																										blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																									}

																									if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																										blindfoldSecretInfoInternal.Location = w.(string)
																									}

																									if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																										blindfoldSecretInfoInternal.StoreProvider = w.(string)
																									}

																								}
																							}

																						}

																						if v, ok := chapTargetInitiatorSecretMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																							chapTargetInitiatorSecret.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																						}

																						secretInfoOneofTypeFound := false

																						if v, ok := chapTargetInitiatorSecretMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																							secretInfoOneofTypeFound = true
																							secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																							secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																							chapTargetInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																									}

																									if v, ok := cs["location"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																									}

																									if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																									}

																								}
																							}

																						}

																						if v, ok := chapTargetInitiatorSecretMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																							secretInfoOneofTypeFound = true
																							secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																							secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																							chapTargetInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																									}

																									if v, ok := cs["url"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																									}

																								}
																							}

																						}

																						if v, ok := chapTargetInitiatorSecretMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																							secretInfoOneofTypeFound = true
																							secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																							secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																							chapTargetInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["key"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																									}

																									if v, ok := cs["location"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																									}

																									if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																									}

																									if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																									}

																									if v, ok := cs["version"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																									}

																								}
																							}

																						}

																						if v, ok := chapTargetInitiatorSecretMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																							secretInfoOneofTypeFound = true
																							secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																							secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																							chapTargetInitiatorSecret.SecretInfoOneof = secretInfoOneofInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["name"]; ok && !isIntfNil(v) {

																										secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																									}

																								}
																							}

																						}

																					}
																				}

																			}

																			if v, ok := cs["chap_target_username"]; ok && !isIntfNil(v) {

																				chapChoiceInt.UseChap.ChapTargetUsername = v.(string)

																			}

																			if v, ok := cs["chap_username"]; ok && !isIntfNil(v) {

																				chapChoiceInt.UseChap.ChapUsername = v.(string)

																			}

																		}
																	}

																}

																if v, ok := cs["client_certificate"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapSan.ClientCertificate = v.(string)

																}

																if v, ok := cs["client_private_key"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	clientPrivateKey := &ves_io_schema.SecretType{}
																	backendChoiceInt.NetappBackendOntapSan.ClientPrivateKey = clientPrivateKey
																	for _, set := range sl {
																		if set != nil {
																			clientPrivateKeyMapStrToI := set.(map[string]interface{})

																			if v, ok := clientPrivateKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																				clientPrivateKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																				for _, set := range sl {
																					if set != nil {
																						blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																						if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																							blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																						}

																						if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																							blindfoldSecretInfoInternal.Location = w.(string)
																						}

																						if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																							blindfoldSecretInfoInternal.StoreProvider = w.(string)
																						}

																					}
																				}

																			}

																			if v, ok := clientPrivateKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																				clientPrivateKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																			}

																			secretInfoOneofTypeFound := false

																			if v, ok := clientPrivateKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																				secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																				clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																						}

																						if v, ok := cs["location"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																						}

																						if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := clientPrivateKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																				secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																				clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																						}

																						if v, ok := cs["url"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := clientPrivateKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																				secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																				clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["key"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																						}

																						if v, ok := cs["location"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																						}

																						if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																						}

																						if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																						}

																						if v, ok := cs["version"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																						}

																					}
																				}

																			}

																			if v, ok := clientPrivateKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																				secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																				clientPrivateKey.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["name"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																dataLifTypeFound := false

																if v, ok := cs["data_lif_dns_name"]; ok && !isIntfNil(v) && !dataLifTypeFound {

																	dataLifTypeFound = true
																	dataLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType_DataLifDnsName{}

																	backendChoiceInt.NetappBackendOntapSan.DataLif = dataLifInt

																	dataLifInt.DataLifDnsName = v.(string)

																}

																if v, ok := cs["data_lif_ip"]; ok && !isIntfNil(v) && !dataLifTypeFound {

																	dataLifTypeFound = true
																	dataLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType_DataLifIp{}

																	backendChoiceInt.NetappBackendOntapSan.DataLif = dataLifInt

																	dataLifInt.DataLifIp = v.(string)

																}

																if v, ok := cs["igroup_name"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapSan.IgroupName = v.(string)

																}

																if v, ok := cs["labels"]; ok && !isIntfNil(v) {

																	ms := map[string]string{}
																	for k, v := range v.(map[string]interface{}) {
																		ms[k] = v.(string)
																	}
																	backendChoiceInt.NetappBackendOntapSan.Labels = ms
																}

																if v, ok := cs["limit_aggregate_usage"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapSan.LimitAggregateUsage = uint32(v.(int))

																}

																if v, ok := cs["limit_volume_size"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapSan.LimitVolumeSize = int32(v.(int))

																}

																managementLifTypeFound := false

																if v, ok := cs["management_lif_dns_name"]; ok && !isIntfNil(v) && !managementLifTypeFound {

																	managementLifTypeFound = true
																	managementLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName{}

																	backendChoiceInt.NetappBackendOntapSan.ManagementLif = managementLifInt

																	managementLifInt.ManagementLifDnsName = v.(string)

																}

																if v, ok := cs["management_lif_ip"]; ok && !isIntfNil(v) && !managementLifTypeFound {

																	managementLifTypeFound = true
																	managementLifInt := &ves_io_schema_fleet.StorageDeviceNetappBackendOntapSanType_ManagementLifIp{}

																	backendChoiceInt.NetappBackendOntapSan.ManagementLif = managementLifInt

																	managementLifInt.ManagementLifIp = v.(string)

																}

																if v, ok := cs["password"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	password := &ves_io_schema.SecretType{}
																	backendChoiceInt.NetappBackendOntapSan.Password = password
																	for _, set := range sl {
																		if set != nil {
																			passwordMapStrToI := set.(map[string]interface{})

																			if v, ok := passwordMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																				password.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																				for _, set := range sl {
																					if set != nil {
																						blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																						if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																							blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																						}

																						if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																							blindfoldSecretInfoInternal.Location = w.(string)
																						}

																						if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																							blindfoldSecretInfoInternal.StoreProvider = w.(string)
																						}

																					}
																				}

																			}

																			if v, ok := passwordMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																				password.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																			}

																			secretInfoOneofTypeFound := false

																			if v, ok := passwordMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																				secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																				password.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																						}

																						if v, ok := cs["location"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																						}

																						if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := passwordMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																				secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																				password.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																						}

																						if v, ok := cs["url"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := passwordMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																				secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																				password.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["key"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																						}

																						if v, ok := cs["location"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																						}

																						if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																						}

																						if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																						}

																						if v, ok := cs["version"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																						}

																					}
																				}

																			}

																			if v, ok := passwordMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																				secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																				password.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["name"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["region"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapSan.Region = v.(string)

																}

																if v, ok := cs["storage"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	storage := make([]*ves_io_schema_fleet.OntapVirtualStoragePoolType, len(sl))
																	backendChoiceInt.NetappBackendOntapSan.Storage = storage
																	for i, set := range sl {
																		if set != nil {
																			storage[i] = &ves_io_schema_fleet.OntapVirtualStoragePoolType{}
																			storageMapStrToI := set.(map[string]interface{})

																			if w, ok := storageMapStrToI["labels"]; ok && !isIntfNil(w) {
																				ms := map[string]string{}
																				for k, v := range w.(map[string]interface{}) {
																					ms[k] = v.(string)
																				}
																				storage[i].Labels = ms
																			}

																			if v, ok := storageMapStrToI["volume_defaults"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				volumeDefaults := &ves_io_schema_fleet.OntapVolumeDefaults{}
																				storage[i].VolumeDefaults = volumeDefaults
																				for _, set := range sl {
																					if set != nil {
																						volumeDefaultsMapStrToI := set.(map[string]interface{})

																						if w, ok := volumeDefaultsMapStrToI["encryption"]; ok && !isIntfNil(w) {
																							volumeDefaults.Encryption = w.(bool)
																						}

																						if w, ok := volumeDefaultsMapStrToI["export_policy"]; ok && !isIntfNil(w) {
																							volumeDefaults.ExportPolicy = w.(string)
																						}

																						qosPolicyChoiceTypeFound := false

																						if v, ok := volumeDefaultsMapStrToI["adaptive_qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																							qosPolicyChoiceTypeFound = true
																							qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_AdaptiveQosPolicy{}

																							volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

																							qosPolicyChoiceInt.AdaptiveQosPolicy = v.(string)

																						}

																						if v, ok := volumeDefaultsMapStrToI["no_qos"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																							qosPolicyChoiceTypeFound = true

																							if v.(bool) {
																								qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_NoQos{}
																								qosPolicyChoiceInt.NoQos = &ves_io_schema.Empty{}
																								volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt
																							}

																						}

																						if v, ok := volumeDefaultsMapStrToI["qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																							qosPolicyChoiceTypeFound = true
																							qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_QosPolicy{}

																							volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

																							qosPolicyChoiceInt.QosPolicy = v.(string)

																						}

																						if w, ok := volumeDefaultsMapStrToI["security_style"]; ok && !isIntfNil(w) {
																							volumeDefaults.SecurityStyle = w.(string)
																						}

																						if w, ok := volumeDefaultsMapStrToI["snapshot_dir"]; ok && !isIntfNil(w) {
																							volumeDefaults.SnapshotDir = w.(bool)
																						}

																						if w, ok := volumeDefaultsMapStrToI["snapshot_policy"]; ok && !isIntfNil(w) {
																							volumeDefaults.SnapshotPolicy = w.(string)
																						}

																						if w, ok := volumeDefaultsMapStrToI["snapshot_reserve"]; ok && !isIntfNil(w) {
																							volumeDefaults.SnapshotReserve = w.(string)
																						}

																						if w, ok := volumeDefaultsMapStrToI["space_reserve"]; ok && !isIntfNil(w) {
																							volumeDefaults.SpaceReserve = w.(string)
																						}

																						if w, ok := volumeDefaultsMapStrToI["split_on_clone"]; ok && !isIntfNil(w) {
																							volumeDefaults.SplitOnClone = w.(bool)
																						}

																						if w, ok := volumeDefaultsMapStrToI["tiering_policy"]; ok && !isIntfNil(w) {
																							volumeDefaults.TieringPolicy = w.(string)
																						}

																						if w, ok := volumeDefaultsMapStrToI["unix_permissions"]; ok && !isIntfNil(w) {
																							volumeDefaults.UnixPermissions = int32(w.(int))
																						}

																					}
																				}

																			}

																			if w, ok := storageMapStrToI["zone"]; ok && !isIntfNil(w) {
																				storage[i].Zone = w.(string)
																			}

																		}
																	}

																}

																if v, ok := cs["storage_driver_name"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapSan.StorageDriverName = v.(string)

																}

																if v, ok := cs["storage_prefix"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapSan.StoragePrefix = v.(string)

																}

																if v, ok := cs["svm"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapSan.Svm = v.(string)

																}

																if v, ok := cs["trusted_ca_certificate"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapSan.TrustedCaCertificate = v.(string)

																}

																if v, ok := cs["username"]; ok && !isIntfNil(v) {

																	backendChoiceInt.NetappBackendOntapSan.Username = v.(string)

																}

																if v, ok := cs["volume_defaults"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	volumeDefaults := &ves_io_schema_fleet.OntapVolumeDefaults{}
																	backendChoiceInt.NetappBackendOntapSan.VolumeDefaults = volumeDefaults
																	for _, set := range sl {
																		if set != nil {
																			volumeDefaultsMapStrToI := set.(map[string]interface{})

																			if w, ok := volumeDefaultsMapStrToI["encryption"]; ok && !isIntfNil(w) {
																				volumeDefaults.Encryption = w.(bool)
																			}

																			if w, ok := volumeDefaultsMapStrToI["export_policy"]; ok && !isIntfNil(w) {
																				volumeDefaults.ExportPolicy = w.(string)
																			}

																			qosPolicyChoiceTypeFound := false

																			if v, ok := volumeDefaultsMapStrToI["adaptive_qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																				qosPolicyChoiceTypeFound = true
																				qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_AdaptiveQosPolicy{}

																				volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

																				qosPolicyChoiceInt.AdaptiveQosPolicy = v.(string)

																			}

																			if v, ok := volumeDefaultsMapStrToI["no_qos"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																				qosPolicyChoiceTypeFound = true

																				if v.(bool) {
																					qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_NoQos{}
																					qosPolicyChoiceInt.NoQos = &ves_io_schema.Empty{}
																					volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt
																				}

																			}

																			if v, ok := volumeDefaultsMapStrToI["qos_policy"]; ok && !isIntfNil(v) && !qosPolicyChoiceTypeFound {

																				qosPolicyChoiceTypeFound = true
																				qosPolicyChoiceInt := &ves_io_schema_fleet.OntapVolumeDefaults_QosPolicy{}

																				volumeDefaults.QosPolicyChoice = qosPolicyChoiceInt

																				qosPolicyChoiceInt.QosPolicy = v.(string)

																			}

																			if w, ok := volumeDefaultsMapStrToI["security_style"]; ok && !isIntfNil(w) {
																				volumeDefaults.SecurityStyle = w.(string)
																			}

																			if w, ok := volumeDefaultsMapStrToI["snapshot_dir"]; ok && !isIntfNil(w) {
																				volumeDefaults.SnapshotDir = w.(bool)
																			}

																			if w, ok := volumeDefaultsMapStrToI["snapshot_policy"]; ok && !isIntfNil(w) {
																				volumeDefaults.SnapshotPolicy = w.(string)
																			}

																			if w, ok := volumeDefaultsMapStrToI["snapshot_reserve"]; ok && !isIntfNil(w) {
																				volumeDefaults.SnapshotReserve = w.(string)
																			}

																			if w, ok := volumeDefaultsMapStrToI["space_reserve"]; ok && !isIntfNil(w) {
																				volumeDefaults.SpaceReserve = w.(string)
																			}

																			if w, ok := volumeDefaultsMapStrToI["split_on_clone"]; ok && !isIntfNil(w) {
																				volumeDefaults.SplitOnClone = w.(bool)
																			}

																			if w, ok := volumeDefaultsMapStrToI["tiering_policy"]; ok && !isIntfNil(w) {
																				volumeDefaults.TieringPolicy = w.(string)
																			}

																			if w, ok := volumeDefaultsMapStrToI["unix_permissions"]; ok && !isIntfNil(w) {
																				volumeDefaults.UnixPermissions = int32(w.(int))
																			}

																		}
																	}

																}

															}
														}

													}

												}
											}

										}

										if v, ok := storageDevicesMapStrToI["pure_service_orchestrator"]; ok && !isIntfNil(v) && !deviceChoiceTypeFound {

											deviceChoiceTypeFound = true
											deviceChoiceInt := &ves_io_schema_fleet.FleetStorageDeviceType_PureServiceOrchestrator{}
											deviceChoiceInt.PureServiceOrchestrator = &ves_io_schema_fleet.StorageDevicePureStorageServiceOrchestratorType{}
											storageDevices[i].DeviceChoice = deviceChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["arrays"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														arrays := &ves_io_schema_fleet.PsoArrayConfiguration{}
														deviceChoiceInt.PureServiceOrchestrator.Arrays = arrays
														for _, set := range sl {
															if set != nil {
																arraysMapStrToI := set.(map[string]interface{})

																if v, ok := arraysMapStrToI["flash_array"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	flashArray := &ves_io_schema_fleet.FlashArrayType{}
																	arrays.FlashArray = flashArray
																	for _, set := range sl {
																		if set != nil {
																			flashArrayMapStrToI := set.(map[string]interface{})

																			if w, ok := flashArrayMapStrToI["default_fs_opt"]; ok && !isIntfNil(w) {
																				flashArray.DefaultFsOpt = w.(string)
																			}

																			if w, ok := flashArrayMapStrToI["default_fs_type"]; ok && !isIntfNil(w) {
																				flashArray.DefaultFsType = w.(string)
																			}

																			if w, ok := flashArrayMapStrToI["default_mount_opts"]; ok && !isIntfNil(w) {
																				ls := make([]string, len(w.([]interface{})))
																				for i, v := range w.([]interface{}) {
																					ls[i] = v.(string)
																				}
																				flashArray.DefaultMountOpts = ls
																			}

																			if w, ok := flashArrayMapStrToI["disable_preempt_attachments"]; ok && !isIntfNil(w) {
																				flashArray.DisablePreemptAttachments = w.(bool)
																			}

																			if v, ok := flashArrayMapStrToI["flash_arrays"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				flashArrays := make([]*ves_io_schema_fleet.FlashArrayEndpoint, len(sl))
																				flashArray.FlashArrays = flashArrays
																				for i, set := range sl {
																					if set != nil {
																						flashArrays[i] = &ves_io_schema_fleet.FlashArrayEndpoint{}
																						flashArraysMapStrToI := set.(map[string]interface{})

																						if v, ok := flashArraysMapStrToI["api_token"]; ok && !isIntfNil(v) {

																							sl := v.([]interface{})
																							apiToken := &ves_io_schema.SecretType{}
																							flashArrays[i].ApiToken = apiToken
																							for _, set := range sl {
																								if set != nil {
																									apiTokenMapStrToI := set.(map[string]interface{})

																									if v, ok := apiTokenMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																										sl := v.([]interface{})
																										blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																										apiToken.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																										for _, set := range sl {
																											if set != nil {
																												blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																												if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																													blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																												}

																												if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																													blindfoldSecretInfoInternal.Location = w.(string)
																												}

																												if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																													blindfoldSecretInfoInternal.StoreProvider = w.(string)
																												}

																											}
																										}

																									}

																									if v, ok := apiTokenMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																										apiToken.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																									}

																									secretInfoOneofTypeFound := false

																									if v, ok := apiTokenMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																										secretInfoOneofTypeFound = true
																										secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																										secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																										apiToken.SecretInfoOneof = secretInfoOneofInt

																										sl := v.([]interface{})
																										for _, set := range sl {
																											if set != nil {
																												cs := set.(map[string]interface{})

																												if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																												}

																												if v, ok := cs["location"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																												}

																												if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																												}

																											}
																										}

																									}

																									if v, ok := apiTokenMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																										secretInfoOneofTypeFound = true
																										secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																										secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																										apiToken.SecretInfoOneof = secretInfoOneofInt

																										sl := v.([]interface{})
																										for _, set := range sl {
																											if set != nil {
																												cs := set.(map[string]interface{})

																												if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																												}

																												if v, ok := cs["url"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																												}

																											}
																										}

																									}

																									if v, ok := apiTokenMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																										secretInfoOneofTypeFound = true
																										secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																										secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																										apiToken.SecretInfoOneof = secretInfoOneofInt

																										sl := v.([]interface{})
																										for _, set := range sl {
																											if set != nil {
																												cs := set.(map[string]interface{})

																												if v, ok := cs["key"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																												}

																												if v, ok := cs["location"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																												}

																												if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																												}

																												if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																												}

																												if v, ok := cs["version"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																												}

																											}
																										}

																									}

																									if v, ok := apiTokenMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																										secretInfoOneofTypeFound = true
																										secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																										secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																										apiToken.SecretInfoOneof = secretInfoOneofInt

																										sl := v.([]interface{})
																										for _, set := range sl {
																											if set != nil {
																												cs := set.(map[string]interface{})

																												if v, ok := cs["name"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																												}

																											}
																										}

																									}

																								}
																							}

																						}

																						if w, ok := flashArraysMapStrToI["labels"]; ok && !isIntfNil(w) {
																							ms := map[string]string{}
																							for k, v := range w.(map[string]interface{}) {
																								ms[k] = v.(string)
																							}
																							flashArrays[i].Labels = ms
																						}

																						mgmtEndpointTypeFound := false

																						if v, ok := flashArraysMapStrToI["mgmt_dns_name"]; ok && !isIntfNil(v) && !mgmtEndpointTypeFound {

																							mgmtEndpointTypeFound = true
																							mgmtEndpointInt := &ves_io_schema_fleet.FlashArrayEndpoint_MgmtDnsName{}

																							flashArrays[i].MgmtEndpoint = mgmtEndpointInt

																							mgmtEndpointInt.MgmtDnsName = v.(string)

																						}

																						if v, ok := flashArraysMapStrToI["mgmt_ip"]; ok && !isIntfNil(v) && !mgmtEndpointTypeFound {

																							mgmtEndpointTypeFound = true
																							mgmtEndpointInt := &ves_io_schema_fleet.FlashArrayEndpoint_MgmtIp{}

																							flashArrays[i].MgmtEndpoint = mgmtEndpointInt

																							mgmtEndpointInt.MgmtIp = v.(string)

																						}

																					}
																				}

																			}

																			if w, ok := flashArrayMapStrToI["iscsi_login_timeout"]; ok && !isIntfNil(w) {
																				flashArray.IscsiLoginTimeout = int32(w.(int))
																			}

																			if w, ok := flashArrayMapStrToI["san_type"]; ok && !isIntfNil(w) {
																				flashArray.SanType = w.(string)
																			}

																		}
																	}

																}

																if v, ok := arraysMapStrToI["flash_blade"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	flashBlade := &ves_io_schema_fleet.FlashBladeType{}
																	arrays.FlashBlade = flashBlade
																	for _, set := range sl {
																		if set != nil {
																			flashBladeMapStrToI := set.(map[string]interface{})

																			if w, ok := flashBladeMapStrToI["enable_snapshot_directory"]; ok && !isIntfNil(w) {
																				flashBlade.EnableSnapshotDirectory = w.(bool)
																			}

																			if w, ok := flashBladeMapStrToI["export_rules"]; ok && !isIntfNil(w) {
																				flashBlade.ExportRules = w.(string)
																			}

																			if v, ok := flashBladeMapStrToI["flash_blades"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				flashBlades := make([]*ves_io_schema_fleet.FlashBladeEndpoint, len(sl))
																				flashBlade.FlashBlades = flashBlades
																				for i, set := range sl {
																					if set != nil {
																						flashBlades[i] = &ves_io_schema_fleet.FlashBladeEndpoint{}
																						flashBladesMapStrToI := set.(map[string]interface{})

																						if v, ok := flashBladesMapStrToI["api_token"]; ok && !isIntfNil(v) {

																							sl := v.([]interface{})
																							apiToken := &ves_io_schema.SecretType{}
																							flashBlades[i].ApiToken = apiToken
																							for _, set := range sl {
																								if set != nil {
																									apiTokenMapStrToI := set.(map[string]interface{})

																									if v, ok := apiTokenMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																										sl := v.([]interface{})
																										blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																										apiToken.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																										for _, set := range sl {
																											if set != nil {
																												blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																												if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																													blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																												}

																												if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																													blindfoldSecretInfoInternal.Location = w.(string)
																												}

																												if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																													blindfoldSecretInfoInternal.StoreProvider = w.(string)
																												}

																											}
																										}

																									}

																									if v, ok := apiTokenMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																										apiToken.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																									}

																									secretInfoOneofTypeFound := false

																									if v, ok := apiTokenMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																										secretInfoOneofTypeFound = true
																										secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																										secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																										apiToken.SecretInfoOneof = secretInfoOneofInt

																										sl := v.([]interface{})
																										for _, set := range sl {
																											if set != nil {
																												cs := set.(map[string]interface{})

																												if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																												}

																												if v, ok := cs["location"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																												}

																												if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																												}

																											}
																										}

																									}

																									if v, ok := apiTokenMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																										secretInfoOneofTypeFound = true
																										secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																										secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																										apiToken.SecretInfoOneof = secretInfoOneofInt

																										sl := v.([]interface{})
																										for _, set := range sl {
																											if set != nil {
																												cs := set.(map[string]interface{})

																												if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																												}

																												if v, ok := cs["url"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																												}

																											}
																										}

																									}

																									if v, ok := apiTokenMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																										secretInfoOneofTypeFound = true
																										secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																										secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																										apiToken.SecretInfoOneof = secretInfoOneofInt

																										sl := v.([]interface{})
																										for _, set := range sl {
																											if set != nil {
																												cs := set.(map[string]interface{})

																												if v, ok := cs["key"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																												}

																												if v, ok := cs["location"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																												}

																												if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																												}

																												if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																												}

																												if v, ok := cs["version"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																												}

																											}
																										}

																									}

																									if v, ok := apiTokenMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																										secretInfoOneofTypeFound = true
																										secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																										secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																										apiToken.SecretInfoOneof = secretInfoOneofInt

																										sl := v.([]interface{})
																										for _, set := range sl {
																											if set != nil {
																												cs := set.(map[string]interface{})

																												if v, ok := cs["name"]; ok && !isIntfNil(v) {

																													secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																												}

																											}
																										}

																									}

																								}
																							}

																						}

																						if w, ok := flashBladesMapStrToI["lables"]; ok && !isIntfNil(w) {
																							ms := map[string]string{}
																							for k, v := range w.(map[string]interface{}) {
																								ms[k] = v.(string)
																							}
																							flashBlades[i].Lables = ms
																						}

																						mgmtEndpointTypeFound := false

																						if v, ok := flashBladesMapStrToI["mgmt_dns_name"]; ok && !isIntfNil(v) && !mgmtEndpointTypeFound {

																							mgmtEndpointTypeFound = true
																							mgmtEndpointInt := &ves_io_schema_fleet.FlashBladeEndpoint_MgmtDnsName{}

																							flashBlades[i].MgmtEndpoint = mgmtEndpointInt

																							mgmtEndpointInt.MgmtDnsName = v.(string)

																						}

																						if v, ok := flashBladesMapStrToI["mgmt_ip"]; ok && !isIntfNil(v) && !mgmtEndpointTypeFound {

																							mgmtEndpointTypeFound = true
																							mgmtEndpointInt := &ves_io_schema_fleet.FlashBladeEndpoint_MgmtIp{}

																							flashBlades[i].MgmtEndpoint = mgmtEndpointInt

																							mgmtEndpointInt.MgmtIp = v.(string)

																						}

																						nfsEndpointTypeFound := false

																						if v, ok := flashBladesMapStrToI["nfs_endpoint_dns_name"]; ok && !isIntfNil(v) && !nfsEndpointTypeFound {

																							nfsEndpointTypeFound = true
																							nfsEndpointInt := &ves_io_schema_fleet.FlashBladeEndpoint_NfsEndpointDnsName{}

																							flashBlades[i].NfsEndpoint = nfsEndpointInt

																							nfsEndpointInt.NfsEndpointDnsName = v.(string)

																						}

																						if v, ok := flashBladesMapStrToI["nfs_endpoint_ip"]; ok && !isIntfNil(v) && !nfsEndpointTypeFound {

																							nfsEndpointTypeFound = true
																							nfsEndpointInt := &ves_io_schema_fleet.FlashBladeEndpoint_NfsEndpointIp{}

																							flashBlades[i].NfsEndpoint = nfsEndpointInt

																							nfsEndpointInt.NfsEndpointIp = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := cs["cluster_id"]; ok && !isIntfNil(v) {

														deviceChoiceInt.PureServiceOrchestrator.ClusterId = v.(string)

													}

													if v, ok := cs["enable_storage_topology"]; ok && !isIntfNil(v) {

														deviceChoiceInt.PureServiceOrchestrator.EnableStorageTopology = v.(bool)

													}

													if v, ok := cs["enable_strict_topology"]; ok && !isIntfNil(v) {

														deviceChoiceInt.PureServiceOrchestrator.EnableStrictTopology = v.(bool)

													}

												}
											}

										}

										if w, ok := storageDevicesMapStrToI["storage_device"]; ok && !isIntfNil(w) {
											storageDevices[i].StorageDevice = w.(string)
										}

									}
								}

							}

						}
					}

				}

				storageInterfaceChoiceTypeFound := false

				if v, ok := cs["no_storage_interfaces"]; ok && !isIntfNil(v) && !storageInterfaceChoiceTypeFound {

					storageInterfaceChoiceTypeFound = true

					if v.(bool) {
						storageInterfaceChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_NoStorageInterfaces{}
						storageInterfaceChoiceInt.NoStorageInterfaces = &ves_io_schema.Empty{}
						storageCfgChoiceInt.CustomStorageConfig.StorageInterfaceChoice = storageInterfaceChoiceInt
					}

				}

				if v, ok := cs["storage_interface_list"]; ok && !isIntfNil(v) && !storageInterfaceChoiceTypeFound {

					storageInterfaceChoiceTypeFound = true
					storageInterfaceChoiceInt := &ves_io_schema_views_voltstack_site.VssStorageConfiguration_StorageInterfaceList{}
					storageInterfaceChoiceInt.StorageInterfaceList = &ves_io_schema_views_voltstack_site.StorageInterfaceListType{}
					storageCfgChoiceInt.CustomStorageConfig.StorageInterfaceChoice = storageInterfaceChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["storage_interfaces"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								storageInterfaces := make([]*ves_io_schema_views_voltstack_site.StorageInterfaceType, len(sl))
								storageInterfaceChoiceInt.StorageInterfaceList.StorageInterfaces = storageInterfaces
								for i, set := range sl {
									if set != nil {
										storageInterfaces[i] = &ves_io_schema_views_voltstack_site.StorageInterfaceType{}
										storageInterfacesMapStrToI := set.(map[string]interface{})

										if w, ok := storageInterfacesMapStrToI["description"]; ok && !isIntfNil(w) {
											storageInterfaces[i].Description = w.(string)
										}

										if w, ok := storageInterfacesMapStrToI["labels"]; ok && !isIntfNil(w) {
											ms := map[string]string{}
											for k, v := range w.(map[string]interface{}) {
												ms[k] = v.(string)
											}
											storageInterfaces[i].Labels = ms
										}

										if v, ok := storageInterfacesMapStrToI["storage_interface"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											storageInterface := &ves_io_schema_network_interface.EthernetInterfaceType{}
											storageInterfaces[i].StorageInterface = storageInterface
											for _, set := range sl {
												if set != nil {
													storageInterfaceMapStrToI := set.(map[string]interface{})

													addressChoiceTypeFound := false

													if v, ok := storageInterfaceMapStrToI["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true

														if v.(bool) {
															addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_DhcpClient{}
															addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
															storageInterface.AddressChoice = addressChoiceInt
														}

													}

													if v, ok := storageInterfaceMapStrToI["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_DhcpServer{}
														addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
														storageInterface.AddressChoice = addressChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
																	addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
																	for i, set := range sl {
																		if set != nil {
																			dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
																			dhcpNetworksMapStrToI := set.(map[string]interface{})

																			dnsChoiceTypeFound := false

																			if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																				dnsChoiceTypeFound = true
																				dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

																				dhcpNetworks[i].DnsChoice = dnsChoiceInt

																				dnsChoiceInt.DnsAddress = v.(string)

																			}

																			if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																				dnsChoiceTypeFound = true

																				if v.(bool) {
																					dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
																					dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
																					dhcpNetworks[i].DnsChoice = dnsChoiceInt
																				}

																			}

																			gatewayChoiceTypeFound := false

																			if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

																				gatewayChoiceTypeFound = true
																				gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

																				dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

																				gatewayChoiceInt.DgwAddress = v.(string)

																			}

																			if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

																				gatewayChoiceTypeFound = true

																				if v.(bool) {
																					gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
																					gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																					dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
																				}

																			}

																			if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

																				gatewayChoiceTypeFound = true

																				if v.(bool) {
																					gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
																					gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
																					dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
																				}

																			}

																			networkPrefixChoiceTypeFound := false

																			if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																				networkPrefixChoiceTypeFound = true
																				networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

																				dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																				networkPrefixChoiceInt.NetworkPrefix = v.(string)

																			}

																			if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																				networkPrefixChoiceTypeFound = true
																				networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
																				networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																				dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["name"]; ok && !isIntfNil(v) {

																							networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																						}

																						if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																							networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																						}

																						if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																							networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

																				dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

																			}

																			if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
																				dhcpNetworks[i].Pools = pools
																				for i, set := range sl {
																					if set != nil {
																						pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
																						poolsMapStrToI := set.(map[string]interface{})

																						if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																							pools[i].EndIp = w.(string)
																						}

																						if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																							pools[i].Exclude = w.(bool)
																						}

																						if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																							pools[i].StartIp = w.(string)
																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

																	addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

																}

																if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																	ms := map[string]string{}
																	for k, v := range v.(map[string]interface{}) {
																		ms[k] = v.(string)
																	}
																	addressChoiceInt.DhcpServer.FixedIpMap = ms
																}

																interfacesAddressingChoiceTypeFound := false

																if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																	interfacesAddressingChoiceTypeFound = true

																	if v.(bool) {
																		interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
																		interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																		addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																	}

																}

																if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																	interfacesAddressingChoiceTypeFound = true

																	if v.(bool) {
																		interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
																		interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																		addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																	}

																}

																if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																	interfacesAddressingChoiceTypeFound = true
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
																	interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
																	addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																				ms := map[string]string{}
																				for k, v := range v.(map[string]interface{}) {
																					ms[k] = v.(string)
																				}
																				interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := storageInterfaceMapStrToI["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StaticIp{}
														addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIPParametersType{}
														storageInterface.AddressChoice = addressChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																networkPrefixChoiceTypeFound := false

																if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
																	networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
																	addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
																				networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
																				for _, set := range sl {
																					if set != nil {
																						interfaceIpMapMapStrToI := set.(map[string]interface{})
																						key, ok := interfaceIpMapMapStrToI["name"]
																						if ok && !isIntfNil(key) {
																							interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																							val, _ := interfaceIpMapMapStrToI["value"]

																							interfaceIpMapVals := val.([]interface{})
																							for _, intVal := range interfaceIpMapVals {
																								if intVal != nil {

																									interfaceIpMapStaticMap := intVal.(map[string]interface{})

																									if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DefaultGw = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DnsServer = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].IpAddress = w.(string)
																									}

																									// break after one loop
																									break
																								}
																							}
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
																	networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
																	addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
																				networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

																				for _, set := range sl {
																					if set != nil {
																						npaMapToStrVal := set.(map[string]interface{})
																						if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Name = val.(string)
																						}
																						if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Namespace = val.(string)
																						}

																						if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Tenant = val.(string)
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
																	networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																	addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

													if w, ok := storageInterfaceMapStrToI["device"]; ok && !isIntfNil(w) {
														storageInterface.Device = w.(string)
													}

													ipv6AddressChoiceTypeFound := false

													if v, ok := storageInterfaceMapStrToI["ipv6_auto_config"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

														ipv6AddressChoiceTypeFound = true
														ipv6AddressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Ipv6AutoConfig{}
														ipv6AddressChoiceInt.Ipv6AutoConfig = &ves_io_schema_network_interface.IPV6AutoConfigType{}
														storageInterface.Ipv6AddressChoice = ipv6AddressChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																autoconfigChoiceTypeFound := false

																if v, ok := cs["host"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

																	autoconfigChoiceTypeFound = true

																	if v.(bool) {
																		autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Host{}
																		autoconfigChoiceInt.Host = &ves_io_schema.Empty{}
																		ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt
																	}

																}

																if v, ok := cs["router"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

																	autoconfigChoiceTypeFound = true
																	autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Router{}
																	autoconfigChoiceInt.Router = &ves_io_schema_network_interface.IPV6AutoConfigRouterType{}
																	ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			addressChoiceTypeFound := false

																			if v, ok := cs["network_prefix"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

																				addressChoiceTypeFound = true
																				addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_NetworkPrefix{}

																				autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

																				addressChoiceInt.NetworkPrefix = v.(string)

																			}

																			if v, ok := cs["stateful"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

																				addressChoiceTypeFound = true
																				addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_Stateful{}
																				addressChoiceInt.Stateful = &ves_io_schema_network_interface.DHCPIPV6StatefulServer{}
																				autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																							sl := v.([]interface{})
																							dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPIPV6NetworkType, len(sl))
																							addressChoiceInt.Stateful.DhcpNetworks = dhcpNetworks
																							for i, set := range sl {
																								if set != nil {
																									dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPIPV6NetworkType{}
																									dhcpNetworksMapStrToI := set.(map[string]interface{})

																									networkPrefixChoiceTypeFound := false

																									if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																										networkPrefixChoiceTypeFound = true
																										networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefix{}

																										dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																										networkPrefixChoiceInt.NetworkPrefix = v.(string)

																									}

																									if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																										networkPrefixChoiceTypeFound = true
																										networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefixAllocator{}
																										networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																										dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																										sl := v.([]interface{})
																										for _, set := range sl {
																											if set != nil {
																												cs := set.(map[string]interface{})

																												if v, ok := cs["name"]; ok && !isIntfNil(v) {

																													networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																												}

																												if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																													networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																												}

																												if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																													networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																												}

																											}
																										}

																									}

																									if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

																										dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

																									}

																									if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																										sl := v.([]interface{})
																										pools := make([]*ves_io_schema_network_interface.DHCPIPV6PoolType, len(sl))
																										dhcpNetworks[i].Pools = pools
																										for i, set := range sl {
																											if set != nil {
																												pools[i] = &ves_io_schema_network_interface.DHCPIPV6PoolType{}
																												poolsMapStrToI := set.(map[string]interface{})

																												if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																													pools[i].EndIp = w.(string)
																												}

																												if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																													pools[i].Exclude = w.(bool)
																												}

																												if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																													pools[i].StartIp = w.(string)
																												}

																											}
																										}

																									}

																								}
																							}

																						}

																						if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																							ms := map[string]string{}
																							for k, v := range v.(map[string]interface{}) {
																								ms[k] = v.(string)
																							}
																							addressChoiceInt.Stateful.FixedIpMap = ms
																						}

																						interfacesAddressingChoiceTypeFound := false

																						if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																							interfacesAddressingChoiceTypeFound = true

																							if v.(bool) {
																								interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromEnd{}
																								interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																								addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																							}

																						}

																						if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																							interfacesAddressingChoiceTypeFound = true

																							if v.(bool) {
																								interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromStart{}
																								interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																								addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																							}

																						}

																						if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																							interfacesAddressingChoiceTypeFound = true
																							interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_InterfaceIpMap{}
																							interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPV6Type{}
																							addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																										ms := map[string]string{}
																										for k, v := range v.(map[string]interface{}) {
																											ms[k] = v.(string)
																										}
																										interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																									}

																								}
																							}

																						}

																					}
																				}

																			}

																			if v, ok := cs["dns_config"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				dnsConfig := &ves_io_schema_network_interface.IPV6DnsConfig{}
																				autoconfigChoiceInt.Router.DnsConfig = dnsConfig
																				for _, set := range sl {
																					if set != nil {
																						dnsConfigMapStrToI := set.(map[string]interface{})

																						dnsChoiceTypeFound := false

																						if v, ok := dnsConfigMapStrToI["configured_list"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																							dnsChoiceTypeFound = true
																							dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_ConfiguredList{}
																							dnsChoiceInt.ConfiguredList = &ves_io_schema_network_interface.IPV6DnsList{}
																							dnsConfig.DnsChoice = dnsChoiceInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									if v, ok := cs["dns_list"]; ok && !isIntfNil(v) {

																										ls := make([]string, len(v.([]interface{})))
																										for i, v := range v.([]interface{}) {
																											ls[i] = v.(string)
																										}
																										dnsChoiceInt.ConfiguredList.DnsList = ls

																									}

																								}
																							}

																						}

																						if v, ok := dnsConfigMapStrToI["local_dns"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																							dnsChoiceTypeFound = true
																							dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_LocalDns{}
																							dnsChoiceInt.LocalDns = &ves_io_schema_network_interface.IPV6LocalDnsAddress{}
																							dnsConfig.DnsChoice = dnsChoiceInt

																							sl := v.([]interface{})
																							for _, set := range sl {
																								if set != nil {
																									cs := set.(map[string]interface{})

																									localDnsChoiceTypeFound := false

																									if v, ok := cs["configured_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																										localDnsChoiceTypeFound = true
																										localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_ConfiguredAddress{}

																										dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt

																										localDnsChoiceInt.ConfiguredAddress = v.(string)

																									}

																									if v, ok := cs["first_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																										localDnsChoiceTypeFound = true

																										if v.(bool) {
																											localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_FirstAddress{}
																											localDnsChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																											dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																										}

																									}

																									if v, ok := cs["last_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																										localDnsChoiceTypeFound = true

																										if v.(bool) {
																											localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_LastAddress{}
																											localDnsChoiceInt.LastAddress = &ves_io_schema.Empty{}
																											dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																										}

																									}

																								}
																							}

																						}

																					}
																				}

																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := storageInterfaceMapStrToI["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

														ipv6AddressChoiceTypeFound = true

														if v.(bool) {
															ipv6AddressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_NoIpv6Address{}
															ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
															storageInterface.Ipv6AddressChoice = ipv6AddressChoiceInt
														}

													}

													if v, ok := storageInterfaceMapStrToI["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

														ipv6AddressChoiceTypeFound = true
														ipv6AddressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StaticIpv6Address{}
														ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
														storageInterface.Ipv6AddressChoice = ipv6AddressChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																networkPrefixChoiceTypeFound := false

																if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
																	networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
																	ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
																				networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
																				for _, set := range sl {
																					if set != nil {
																						interfaceIpMapMapStrToI := set.(map[string]interface{})
																						key, ok := interfaceIpMapMapStrToI["name"]
																						if ok && !isIntfNil(key) {
																							interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																							val, _ := interfaceIpMapMapStrToI["value"]

																							interfaceIpMapVals := val.([]interface{})
																							for _, intVal := range interfaceIpMapVals {
																								if intVal != nil {

																									interfaceIpMapStaticMap := intVal.(map[string]interface{})

																									if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DefaultGw = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].DnsServer = w.(string)
																									}

																									if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																										interfaceIpMap[key.(string)].IpAddress = w.(string)
																									}

																									// break after one loop
																									break
																								}
																							}
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
																	networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
																	ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
																				networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

																				for _, set := range sl {
																					if set != nil {
																						npaMapToStrVal := set.(map[string]interface{})
																						if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Name = val.(string)
																						}
																						if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Namespace = val.(string)
																						}

																						if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																							networkPrefixAllocatorInt.Tenant = val.(string)
																						}
																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																	networkPrefixChoiceTypeFound = true
																	networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
																	networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																	ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

																			}

																			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

																			}

																			if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

													monitoringChoiceTypeFound := false

													if _, ok := storageInterfaceMapStrToI["monitor"]; ok && !monitoringChoiceTypeFound {

														monitoringChoiceTypeFound = true
														monitoringChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Monitor{}
														monitoringChoiceInt.Monitor = &ves_io_schema_network_interface.LinkQualityMonitorConfig{}
														storageInterface.MonitoringChoice = monitoringChoiceInt

													}

													if v, ok := storageInterfaceMapStrToI["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

														monitoringChoiceTypeFound = true

														if v.(bool) {
															monitoringChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_MonitorDisabled{}
															monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
															storageInterface.MonitoringChoice = monitoringChoiceInt
														}

													}

													if w, ok := storageInterfaceMapStrToI["mtu"]; ok && !isIntfNil(w) {
														storageInterface.Mtu = uint32(w.(int))
													}

													networkChoiceTypeFound := false

													if v, ok := storageInterfaceMapStrToI["inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true
														networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_InsideNetwork{}
														networkChoiceInt.InsideNetwork = &ves_io_schema_views.ObjectRefType{}
														storageInterface.NetworkChoice = networkChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	networkChoiceInt.InsideNetwork.Name = v.(string)

																}

																if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																	networkChoiceInt.InsideNetwork.Namespace = v.(string)

																}

																if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																	networkChoiceInt.InsideNetwork.Tenant = v.(string)

																}

															}
														}

													}

													if v, ok := storageInterfaceMapStrToI["ip_fabric_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true

														if v.(bool) {
															networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_IpFabricNetwork{}
															networkChoiceInt.IpFabricNetwork = &ves_io_schema.Empty{}
															storageInterface.NetworkChoice = networkChoiceInt
														}

													}

													if v, ok := storageInterfaceMapStrToI["segment_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true
														networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SegmentNetwork{}
														networkChoiceInt.SegmentNetwork = &ves_io_schema_views.ObjectRefType{}
														storageInterface.NetworkChoice = networkChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	networkChoiceInt.SegmentNetwork.Name = v.(string)

																}

																if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																	networkChoiceInt.SegmentNetwork.Namespace = v.(string)

																}

																if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																	networkChoiceInt.SegmentNetwork.Tenant = v.(string)

																}

															}
														}

													}

													if v, ok := storageInterfaceMapStrToI["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true

														if v.(bool) {
															networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SiteLocalInsideNetwork{}
															networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
															storageInterface.NetworkChoice = networkChoiceInt
														}

													}

													if v, ok := storageInterfaceMapStrToI["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true

														if v.(bool) {
															networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SiteLocalNetwork{}
															networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
															storageInterface.NetworkChoice = networkChoiceInt
														}

													}

													if v, ok := storageInterfaceMapStrToI["srv6_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true
														networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Srv6Network{}
														networkChoiceInt.Srv6Network = &ves_io_schema_views.ObjectRefType{}
														storageInterface.NetworkChoice = networkChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	networkChoiceInt.Srv6Network.Name = v.(string)

																}

																if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																	networkChoiceInt.Srv6Network.Namespace = v.(string)

																}

																if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																	networkChoiceInt.Srv6Network.Tenant = v.(string)

																}

															}
														}

													}

													if v, ok := storageInterfaceMapStrToI["storage_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

														networkChoiceTypeFound = true

														if v.(bool) {
															networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StorageNetwork{}
															networkChoiceInt.StorageNetwork = &ves_io_schema.Empty{}
															storageInterface.NetworkChoice = networkChoiceInt
														}

													}

													nodeChoiceTypeFound := false

													if v, ok := storageInterfaceMapStrToI["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

														nodeChoiceTypeFound = true

														if v.(bool) {
															nodeChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Cluster{}
															nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
															storageInterface.NodeChoice = nodeChoiceInt
														}

													}

													if v, ok := storageInterfaceMapStrToI["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

														nodeChoiceTypeFound = true
														nodeChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Node{}

														storageInterface.NodeChoice = nodeChoiceInt

														nodeChoiceInt.Node = v.(string)

													}

													primaryChoiceTypeFound := false

													if v, ok := storageInterfaceMapStrToI["is_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

														primaryChoiceTypeFound = true

														if v.(bool) {
															primaryChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_IsPrimary{}
															primaryChoiceInt.IsPrimary = &ves_io_schema.Empty{}
															storageInterface.PrimaryChoice = primaryChoiceInt
														}

													}

													if v, ok := storageInterfaceMapStrToI["not_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

														primaryChoiceTypeFound = true

														if v.(bool) {
															primaryChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_NotPrimary{}
															primaryChoiceInt.NotPrimary = &ves_io_schema.Empty{}
															storageInterface.PrimaryChoice = primaryChoiceInt
														}

													}

													if w, ok := storageInterfaceMapStrToI["priority"]; ok && !isIntfNil(w) {
														storageInterface.Priority = uint32(w.(int))
													}

													vlanChoiceTypeFound := false

													if v, ok := storageInterfaceMapStrToI["untagged"]; ok && !isIntfNil(v) && !vlanChoiceTypeFound {

														vlanChoiceTypeFound = true

														if v.(bool) {
															vlanChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Untagged{}
															vlanChoiceInt.Untagged = &ves_io_schema.Empty{}
															storageInterface.VlanChoice = vlanChoiceInt
														}

													}

													if v, ok := storageInterfaceMapStrToI["vlan_id"]; ok && !isIntfNil(v) && !vlanChoiceTypeFound {

														vlanChoiceTypeFound = true
														vlanChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_VlanId{}

														storageInterface.VlanChoice = vlanChoiceInt

														vlanChoiceInt.VlanId = uint32(v.(int))

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("default_storage_config"); ok && !storageCfgChoiceTypeFound {

		storageCfgChoiceTypeFound = true

		if v.(bool) {
			storageCfgChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_DefaultStorageConfig{}
			storageCfgChoiceInt.DefaultStorageConfig = &ves_io_schema.Empty{}
			updateSpec.StorageCfgChoice = storageCfgChoiceInt
		}

	}

	if v, ok := d.GetOk("sw"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		sw := &ves_io_schema_views.VolterraSoftwareType{}
		updateSpec.Sw = sw
		for _, set := range sl {
			if set != nil {
				swMapStrToI := set.(map[string]interface{})

				volterraSwVersionChoiceTypeFound := false

				if v, ok := swMapStrToI["default_sw_version"]; ok && !isIntfNil(v) && !volterraSwVersionChoiceTypeFound {

					volterraSwVersionChoiceTypeFound = true

					if v.(bool) {
						volterraSwVersionChoiceInt := &ves_io_schema_views.VolterraSoftwareType_DefaultSwVersion{}
						volterraSwVersionChoiceInt.DefaultSwVersion = &ves_io_schema.Empty{}
						sw.VolterraSwVersionChoice = volterraSwVersionChoiceInt
					}

				}

				if v, ok := swMapStrToI["volterra_software_version"]; ok && !isIntfNil(v) && !volterraSwVersionChoiceTypeFound {

					volterraSwVersionChoiceTypeFound = true
					volterraSwVersionChoiceInt := &ves_io_schema_views.VolterraSoftwareType_VolterraSoftwareVersion{}

					sw.VolterraSwVersionChoice = volterraSwVersionChoiceInt

					volterraSwVersionChoiceInt.VolterraSoftwareVersion = v.(string)

				}

			}
		}

	}

	usbPolicyChoiceTypeFound := false

	if v, ok := d.GetOk("allow_all_usb"); ok && !usbPolicyChoiceTypeFound {

		usbPolicyChoiceTypeFound = true

		if v.(bool) {
			usbPolicyChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_AllowAllUsb{}
			usbPolicyChoiceInt.AllowAllUsb = &ves_io_schema.Empty{}
			updateSpec.UsbPolicyChoice = usbPolicyChoiceInt
		}

	}

	if v, ok := d.GetOk("deny_all_usb"); ok && !usbPolicyChoiceTypeFound {

		usbPolicyChoiceTypeFound = true

		if v.(bool) {
			usbPolicyChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_DenyAllUsb{}
			usbPolicyChoiceInt.DenyAllUsb = &ves_io_schema.Empty{}
			updateSpec.UsbPolicyChoice = usbPolicyChoiceInt
		}

	}

	if v, ok := d.GetOk("usb_policy"); ok && !usbPolicyChoiceTypeFound {

		usbPolicyChoiceTypeFound = true
		usbPolicyChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_UsbPolicy{}
		usbPolicyChoiceInt.UsbPolicy = &ves_io_schema_views.ObjectRefType{}
		updateSpec.UsbPolicyChoice = usbPolicyChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["name"]; ok && !isIntfNil(v) {

					usbPolicyChoiceInt.UsbPolicy.Name = v.(string)

				}

				if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

					usbPolicyChoiceInt.UsbPolicy.Namespace = v.(string)

				}

				if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

					usbPolicyChoiceInt.UsbPolicy.Tenant = v.(string)

				}

			}
		}

	}

	vmChoiceTypeFound := false

	if v, ok := d.GetOk("disable_vm"); ok && !vmChoiceTypeFound {

		vmChoiceTypeFound = true

		if v.(bool) {
			vmChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_DisableVm{}
			vmChoiceInt.DisableVm = &ves_io_schema.Empty{}
			updateSpec.VmChoice = vmChoiceInt
		}

	}

	if _, ok := d.GetOk("enable_vm"); ok && !vmChoiceTypeFound {

		vmChoiceTypeFound = true
		vmChoiceInt := &ves_io_schema_views_voltstack_site.ReplaceSpecType_EnableVm{}
		vmChoiceInt.EnableVm = &ves_io_schema_fleet.VMConfiguration{}
		updateSpec.VmChoice = vmChoiceInt

	}

	if v, ok := d.GetOk("volterra_certified_hw"); ok && !isIntfNil(v) {

		updateSpec.VolterraCertifiedHw =
			v.(string)

	}

	if v, ok := d.GetOk("worker_nodes"); ok && !isIntfNil(v) {

		ls := make([]string, len(v.([]interface{})))
		for i, v := range v.([]interface{}) {
			ls[i] = v.(string)
		}
		updateSpec.WorkerNodes = ls

	}

	log.Printf("[DEBUG] Updating Volterra VoltstackSite obj with struct: %+v", updateReq)

	err := client.ReplaceObject(context.Background(), ves_io_schema_views_voltstack_site.ObjectType, updateReq)
	if err != nil {
		return fmt.Errorf("error updating VoltstackSite: %s", err)
	}

	return resourceVolterraVoltstackSiteRead(d, meta)
}

func resourceVolterraVoltstackSiteDelete(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	_, err := client.GetObject(context.Background(), ves_io_schema_views_voltstack_site.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] VoltstackSite %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra VoltstackSite before deleting %q: %s", d.Id(), err)
	}

	log.Printf("[DEBUG] Deleting Volterra VoltstackSite obj with name %+v in namespace %+v", name, namespace)
	return client.DeleteObject(context.Background(), ves_io_schema_views_voltstack_site.ObjectType, namespace, name)
}
