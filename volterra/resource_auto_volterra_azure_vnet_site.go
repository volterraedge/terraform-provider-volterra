//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-tf-provider. DO NOT EDIT.
//

package volterra

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"gopkg.volterra.us/stdlib/client/vesapi"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_fleet "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/fleet"
	ves_io_schema_network_firewall "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/network_firewall"
	ves_io_schema_site "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/site"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	ves_io_schema_views_azure_vnet_site "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/azure_vnet_site"
)

// resourceVolterraAzureVnetSite is implementation of Volterra's AzureVnetSite resources
func resourceVolterraAzureVnetSite() *schema.Resource {
	return &schema.Resource{
		Create: resourceVolterraAzureVnetSiteCreate,
		Read:   resourceVolterraAzureVnetSiteRead,
		Update: resourceVolterraAzureVnetSiteUpdate,
		Delete: resourceVolterraAzureVnetSiteDelete,

		Schema: map[string]*schema.Schema{

			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"description": {
				Type:     schema.TypeString,
				Optional: true,
			},

			"disable": {
				Type:     schema.TypeBool,
				Optional: true,
			},

			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"namespace": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"address": {
				Type:     schema.TypeString,
				Optional: true,
			},

			"admin_password": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"blindfold_secret_info": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"decryption_provider": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"location": {
										Type:     schema.TypeString,
										Required: true,
									},

									"store_provider": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"clear_secret_info": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"provider": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"url": {
										Type:     schema.TypeString,
										Required: true,
									},
								},
							},
						},
					},
				},
			},

			"block_all_services": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"blocked_services": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"blocked_sevice": {

							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"dns": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"ssh": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"web_user_interface": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"network_type": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"default_blocked_services": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"coordinates": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"latitude": {
							Type:     schema.TypeFloat,
							Optional: true,
						},

						"longitude": {
							Type:     schema.TypeFloat,
							Optional: true,
						},
					},
				},
			},

			"custom_dns": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"inside_nameserver": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"inside_nameserver_v6": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"outside_nameserver": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"outside_nameserver_v6": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"azure_cred": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"name": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"namespace": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"tenant": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"disk_size": {
				Type:     schema.TypeInt,
				Optional: true,
			},

			"kubernetes_upgrade_drain": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"disable_upgrade_drain": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"enable_upgrade_drain": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"drain_max_unavailable_node_count": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"drain_node_timeout": {
										Type:     schema.TypeInt,
										Required: true,
									},
								},
							},
						},
					},
				},
			},

			"log_receiver": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"name": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"namespace": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"tenant": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"logs_streaming_disabled": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"machine_type": {
				Type:     schema.TypeString,
				Required: true,
			},

			"offline_survivability_mode": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"enable_offline_survivability_mode": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"no_offline_survivability_mode": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"os": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"default_os_version": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"operating_system_version": {

							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"alternate_region": {

				Type:     schema.TypeString,
				Optional: true,
			},

			"azure_region": {

				Type:     schema.TypeString,
				Optional: true,
			},

			"resource_group": {
				Type:     schema.TypeString,
				Required: true,
			},

			"ingress_egress_gw": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"accelerated_networking": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"disable": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"enable": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"az_nodes": {

							Type:     schema.TypeList,
							Required: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"azure_az": {
										Type:     schema.TypeString,
										Required: true,
									},

									"inside_subnet": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"subnet": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"subnet_resource_grp": {

																Type:     schema.TypeString,
																Optional: true,
															},

															"vnet_resource_group": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"subnet_name": {
																Type:     schema.TypeString,
																Required: true,
															},
														},
													},
												},

												"subnet_param": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"ipv4": {
																Type:     schema.TypeString,
																Required: true,
															},

															"ipv6": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},

									"outside_subnet": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"subnet": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"subnet_resource_grp": {

																Type:     schema.TypeString,
																Optional: true,
															},

															"vnet_resource_group": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"subnet_name": {
																Type:     schema.TypeString,
																Required: true,
															},
														},
													},
												},

												"subnet_param": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"ipv4": {
																Type:     schema.TypeString,
																Required: true,
															},

															"ipv6": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"azure_certified_hw": {
							Type:     schema.TypeString,
							Required: true,
						},

						"dc_cluster_group_inside_vn": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"dc_cluster_group_outside_vn": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"no_dc_cluster_group": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"active_forward_proxy_policies": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"forward_proxy_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"forward_proxy_allow_all": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"no_forward_proxy": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"global_network_list": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"global_network_connections": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"sli_to_global_dr": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"global_vn": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"kind": {
																			Type:     schema.TypeString,
																			Computed: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},

												"slo_to_global_dr": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"global_vn": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"kind": {
																			Type:     schema.TypeString,
																			Computed: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"no_global_network": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"hub": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"express_route_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"express_route_enabled": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"auto_asn": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"custom_asn": {

													Type:     schema.TypeInt,
													Optional: true,
												},

												"connections": {

													Type:     schema.TypeList,
													Required: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"metadata": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"description": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																	},
																},
															},

															"circuit_id": {

																Type:     schema.TypeString,
																Optional: true,
															},

															"other_subscription": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"authorized_key": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"blindfold_secret_info": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"decryption_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"location": {
																									Type:     schema.TypeString,
																									Required: true,
																								},

																								"store_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"clear_secret_info": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"url": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"circuit_id": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"weight": {
																Type:     schema.TypeInt,
																Optional: true,
															},
														},
													},
												},

												"site_registration_over_express_route": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"cloudlink_network_name": {
																Type:     schema.TypeString,
																Required: true,
															},
														},
													},
												},

												"site_registration_over_internet": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"gateway_subnet": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"auto": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"subnet": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"subnet_resource_grp": {

																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"vnet_resource_group": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},
																	},
																},
															},

															"subnet_param": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"ipv4": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"ipv6": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},

												"route_server_subnet": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"auto": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"subnet": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"subnet_resource_grp": {

																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"vnet_resource_group": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},
																	},
																},
															},

															"subnet_param": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"ipv4": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"ipv6": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},

												"sku_ergw1az": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"sku_ergw2az": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"sku_high_perf": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"sku_standard": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"advertise_to_route_server": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"do_not_advertise_to_route_server": {

													Type:     schema.TypeBool,
													Optional: true,
												},
											},
										},
									},

									"spoke_vnets": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"labels": {
													Type:     schema.TypeMap,
													Optional: true,
												},

												"auto": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"manual": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"vnet": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"resource_group": {
																Type:     schema.TypeString,
																Required: true,
															},

															"f5_orchestrated_routing": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"manual_routing": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"vnet_name": {
																Type:     schema.TypeString,
																Required: true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"not_hub": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"inside_static_routes": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"static_route_list": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"custom_static_route": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"attrs": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"labels": {
																Type:     schema.TypeMap,
																Optional: true,
															},

															"nexthop": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"interface": {

																			Type:     schema.TypeList,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"kind": {
																						Type:     schema.TypeString,
																						Computed: true,
																					},

																					"name": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"namespace": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"tenant": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"nexthop_address": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"ipv4": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"addr": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"ipv6": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"addr": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"type": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"subnets": {

																Type:     schema.TypeList,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"ipv4": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"plen": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},

																					"prefix": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"ipv6": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"plen": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},

																					"prefix": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},

												"simple_static_route": {

													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"no_inside_static_routes": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"active_enhanced_firewall_policies": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"enhanced_firewall_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"active_network_policies": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"network_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"no_network_policy": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"no_outside_static_routes": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"outside_static_routes": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"static_route_list": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"custom_static_route": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"attrs": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"labels": {
																Type:     schema.TypeMap,
																Optional: true,
															},

															"nexthop": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"interface": {

																			Type:     schema.TypeList,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"kind": {
																						Type:     schema.TypeString,
																						Computed: true,
																					},

																					"name": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"namespace": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"tenant": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"nexthop_address": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"ipv4": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"addr": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"ipv6": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"addr": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"type": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"subnets": {

																Type:     schema.TypeList,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"ipv4": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"plen": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},

																					"prefix": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"ipv6": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"plen": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},

																					"prefix": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},

												"simple_static_route": {

													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"performance_enhancement_mode": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"perf_mode_l3_enhanced": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"jumbo": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"no_jumbo": {

													Type:     schema.TypeBool,
													Optional: true,
												},
											},
										},
									},

									"perf_mode_l7_enhanced": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"sm_connection_public_ip": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"sm_connection_pvt_ip": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"ingress_egress_gw_ar": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"accelerated_networking": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"disable": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"enable": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"azure_certified_hw": {
							Type:     schema.TypeString,
							Required: true,
						},

						"dc_cluster_group_inside_vn": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"dc_cluster_group_outside_vn": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"no_dc_cluster_group": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"active_forward_proxy_policies": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"forward_proxy_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"forward_proxy_allow_all": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"no_forward_proxy": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"global_network_list": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"global_network_connections": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"sli_to_global_dr": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"global_vn": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"kind": {
																			Type:     schema.TypeString,
																			Computed: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},

												"slo_to_global_dr": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"global_vn": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"kind": {
																			Type:     schema.TypeString,
																			Computed: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"no_global_network": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"hub": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"express_route_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"express_route_enabled": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"auto_asn": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"custom_asn": {

													Type:     schema.TypeInt,
													Optional: true,
												},

												"connections": {

													Type:     schema.TypeList,
													Required: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"metadata": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"description": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																	},
																},
															},

															"circuit_id": {

																Type:     schema.TypeString,
																Optional: true,
															},

															"other_subscription": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"authorized_key": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"blindfold_secret_info": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"decryption_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"location": {
																									Type:     schema.TypeString,
																									Required: true,
																								},

																								"store_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"clear_secret_info": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"url": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"circuit_id": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"weight": {
																Type:     schema.TypeInt,
																Optional: true,
															},
														},
													},
												},

												"site_registration_over_express_route": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"cloudlink_network_name": {
																Type:     schema.TypeString,
																Required: true,
															},
														},
													},
												},

												"site_registration_over_internet": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"gateway_subnet": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"auto": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"subnet": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"subnet_resource_grp": {

																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"vnet_resource_group": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},
																	},
																},
															},

															"subnet_param": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"ipv4": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"ipv6": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},

												"route_server_subnet": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"auto": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"subnet": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"subnet_resource_grp": {

																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"vnet_resource_group": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},
																	},
																},
															},

															"subnet_param": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"ipv4": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"ipv6": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},

												"sku_ergw1az": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"sku_ergw2az": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"sku_high_perf": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"sku_standard": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"advertise_to_route_server": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"do_not_advertise_to_route_server": {

													Type:     schema.TypeBool,
													Optional: true,
												},
											},
										},
									},

									"spoke_vnets": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"labels": {
													Type:     schema.TypeMap,
													Optional: true,
												},

												"auto": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"manual": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"vnet": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"resource_group": {
																Type:     schema.TypeString,
																Required: true,
															},

															"f5_orchestrated_routing": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"manual_routing": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"vnet_name": {
																Type:     schema.TypeString,
																Required: true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"not_hub": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"inside_static_routes": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"static_route_list": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"custom_static_route": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"attrs": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"labels": {
																Type:     schema.TypeMap,
																Optional: true,
															},

															"nexthop": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"interface": {

																			Type:     schema.TypeList,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"kind": {
																						Type:     schema.TypeString,
																						Computed: true,
																					},

																					"name": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"namespace": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"tenant": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"nexthop_address": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"ipv4": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"addr": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"ipv6": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"addr": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"type": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"subnets": {

																Type:     schema.TypeList,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"ipv4": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"plen": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},

																					"prefix": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"ipv6": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"plen": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},

																					"prefix": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},

												"simple_static_route": {

													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"no_inside_static_routes": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"active_enhanced_firewall_policies": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"enhanced_firewall_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"active_network_policies": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"network_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"no_network_policy": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"node": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"fault_domain": {
										Type:     schema.TypeInt,
										Optional: true,
									},

									"inside_subnet": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"subnet": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"subnet_resource_grp": {

																Type:     schema.TypeString,
																Optional: true,
															},

															"vnet_resource_group": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"subnet_name": {
																Type:     schema.TypeString,
																Required: true,
															},
														},
													},
												},

												"subnet_param": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"ipv4": {
																Type:     schema.TypeString,
																Required: true,
															},

															"ipv6": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},

									"node_number": {
										Type:     schema.TypeInt,
										Required: true,
									},

									"outside_subnet": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"subnet": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"subnet_resource_grp": {

																Type:     schema.TypeString,
																Optional: true,
															},

															"vnet_resource_group": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"subnet_name": {
																Type:     schema.TypeString,
																Required: true,
															},
														},
													},
												},

												"subnet_param": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"ipv4": {
																Type:     schema.TypeString,
																Required: true,
															},

															"ipv6": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},

									"update_domain": {
										Type:     schema.TypeInt,
										Optional: true,
									},
								},
							},
						},

						"no_outside_static_routes": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"outside_static_routes": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"static_route_list": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"custom_static_route": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"attrs": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"labels": {
																Type:     schema.TypeMap,
																Optional: true,
															},

															"nexthop": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"interface": {

																			Type:     schema.TypeList,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"kind": {
																						Type:     schema.TypeString,
																						Computed: true,
																					},

																					"name": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"namespace": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"tenant": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"nexthop_address": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"ipv4": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"addr": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"ipv6": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"addr": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"type": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"subnets": {

																Type:     schema.TypeList,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"ipv4": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"plen": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},

																					"prefix": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"ipv6": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"plen": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},

																					"prefix": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},

												"simple_static_route": {

													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"performance_enhancement_mode": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"perf_mode_l3_enhanced": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"jumbo": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"no_jumbo": {

													Type:     schema.TypeBool,
													Optional: true,
												},
											},
										},
									},

									"perf_mode_l7_enhanced": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"sm_connection_public_ip": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"sm_connection_pvt_ip": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"ingress_gw": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"accelerated_networking": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"disable": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"enable": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"az_nodes": {

							Type:     schema.TypeList,
							Required: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"azure_az": {
										Type:     schema.TypeString,
										Required: true,
									},

									"local_subnet": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"subnet": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"subnet_resource_grp": {

																Type:     schema.TypeString,
																Optional: true,
															},

															"vnet_resource_group": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"subnet_name": {
																Type:     schema.TypeString,
																Required: true,
															},
														},
													},
												},

												"subnet_param": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"ipv4": {
																Type:     schema.TypeString,
																Required: true,
															},

															"ipv6": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"azure_certified_hw": {
							Type:     schema.TypeString,
							Required: true,
						},

						"performance_enhancement_mode": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"perf_mode_l3_enhanced": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"jumbo": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"no_jumbo": {

													Type:     schema.TypeBool,
													Optional: true,
												},
											},
										},
									},

									"perf_mode_l7_enhanced": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"ingress_gw_ar": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"accelerated_networking": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"disable": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"enable": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"azure_certified_hw": {
							Type:     schema.TypeString,
							Required: true,
						},

						"node": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"fault_domain": {
										Type:     schema.TypeInt,
										Optional: true,
									},

									"local_subnet": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"subnet": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"subnet_resource_grp": {

																Type:     schema.TypeString,
																Optional: true,
															},

															"vnet_resource_group": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"subnet_name": {
																Type:     schema.TypeString,
																Required: true,
															},
														},
													},
												},

												"subnet_param": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"ipv4": {
																Type:     schema.TypeString,
																Required: true,
															},

															"ipv6": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},

									"node_number": {
										Type:     schema.TypeInt,
										Required: true,
									},

									"update_domain": {
										Type:     schema.TypeInt,
										Optional: true,
									},
								},
							},
						},

						"performance_enhancement_mode": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"perf_mode_l3_enhanced": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"jumbo": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"no_jumbo": {

													Type:     schema.TypeBool,
													Optional: true,
												},
											},
										},
									},

									"perf_mode_l7_enhanced": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"voltstack_cluster": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"accelerated_networking": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"disable": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"enable": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"az_nodes": {

							Type:     schema.TypeList,
							Required: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"azure_az": {
										Type:     schema.TypeString,
										Required: true,
									},

									"local_subnet": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"subnet": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"subnet_resource_grp": {

																Type:     schema.TypeString,
																Optional: true,
															},

															"vnet_resource_group": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"subnet_name": {
																Type:     schema.TypeString,
																Required: true,
															},
														},
													},
												},

												"subnet_param": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"ipv4": {
																Type:     schema.TypeString,
																Required: true,
															},

															"ipv6": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"azure_certified_hw": {
							Type:     schema.TypeString,
							Required: true,
						},

						"dc_cluster_group": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"no_dc_cluster_group": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"active_forward_proxy_policies": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"forward_proxy_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"forward_proxy_allow_all": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"no_forward_proxy": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"global_network_list": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"global_network_connections": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"sli_to_global_dr": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"global_vn": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"kind": {
																			Type:     schema.TypeString,
																			Computed: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},

												"slo_to_global_dr": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"global_vn": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"kind": {
																			Type:     schema.TypeString,
																			Computed: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"no_global_network": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"k8s_cluster": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"no_k8s_cluster": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"active_enhanced_firewall_policies": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"enhanced_firewall_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"active_network_policies": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"network_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"no_network_policy": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"no_outside_static_routes": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"outside_static_routes": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"static_route_list": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"custom_static_route": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"attrs": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"labels": {
																Type:     schema.TypeMap,
																Optional: true,
															},

															"nexthop": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"interface": {

																			Type:     schema.TypeList,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"kind": {
																						Type:     schema.TypeString,
																						Computed: true,
																					},

																					"name": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"namespace": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"tenant": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"nexthop_address": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"ipv4": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"addr": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"ipv6": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"addr": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"type": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"subnets": {

																Type:     schema.TypeList,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"ipv4": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"plen": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},

																					"prefix": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"ipv6": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"plen": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},

																					"prefix": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},

												"simple_static_route": {

													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"sm_connection_public_ip": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"sm_connection_pvt_ip": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"default_storage": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"storage_class_list": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"storage_classes": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"default_storage_class": {
													Type:     schema.TypeBool,
													Optional: true,
												},

												"storage_class_name": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},

			"voltstack_cluster_ar": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"accelerated_networking": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"disable": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"enable": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"azure_certified_hw": {
							Type:     schema.TypeString,
							Required: true,
						},

						"dc_cluster_group": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"no_dc_cluster_group": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"active_forward_proxy_policies": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"forward_proxy_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"forward_proxy_allow_all": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"no_forward_proxy": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"global_network_list": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"global_network_connections": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"sli_to_global_dr": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"global_vn": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"kind": {
																			Type:     schema.TypeString,
																			Computed: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},

												"slo_to_global_dr": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"global_vn": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"kind": {
																			Type:     schema.TypeString,
																			Computed: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"no_global_network": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"k8s_cluster": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"no_k8s_cluster": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"active_enhanced_firewall_policies": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"enhanced_firewall_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"active_network_policies": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"network_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"no_network_policy": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"node": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"fault_domain": {
										Type:     schema.TypeInt,
										Optional: true,
									},

									"local_subnet": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"subnet": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"subnet_resource_grp": {

																Type:     schema.TypeString,
																Optional: true,
															},

															"vnet_resource_group": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"subnet_name": {
																Type:     schema.TypeString,
																Required: true,
															},
														},
													},
												},

												"subnet_param": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"ipv4": {
																Type:     schema.TypeString,
																Required: true,
															},

															"ipv6": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},

									"node_number": {
										Type:     schema.TypeInt,
										Required: true,
									},

									"update_domain": {
										Type:     schema.TypeInt,
										Optional: true,
									},
								},
							},
						},

						"no_outside_static_routes": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"outside_static_routes": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"static_route_list": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"custom_static_route": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"attrs": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"labels": {
																Type:     schema.TypeMap,
																Optional: true,
															},

															"nexthop": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"interface": {

																			Type:     schema.TypeList,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"kind": {
																						Type:     schema.TypeString,
																						Computed: true,
																					},

																					"name": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"namespace": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"tenant": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"nexthop_address": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"ipv4": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"addr": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"ipv6": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"addr": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"type": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"subnets": {

																Type:     schema.TypeList,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"ipv4": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"plen": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},

																					"prefix": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"ipv6": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"plen": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},

																					"prefix": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},

												"simple_static_route": {

													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"sm_connection_public_ip": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"sm_connection_pvt_ip": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"default_storage": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"storage_class_list": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"storage_classes": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"default_storage_class": {
													Type:     schema.TypeBool,
													Optional: true,
												},

												"storage_class_name": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},

			"ssh_key": {
				Type:     schema.TypeString,
				Required: true,
			},

			"sw": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"default_sw_version": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"volterra_software_version": {

							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"tags": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"vnet": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Required: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"existing_vnet": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"resource_group": {
										Type:     schema.TypeString,
										Required: true,
									},

									"f5_orchestrated_routing": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"manual_routing": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"vnet_name": {
										Type:     schema.TypeString,
										Required: true,
									},
								},
							},
						},

						"new_vnet": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"autogenerate": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"name": {

										Type:     schema.TypeString,
										Optional: true,
									},

									"primary_ipv4": {
										Type:     schema.TypeString,
										Required: true,
									},
								},
							},
						},
					},
				},
			},

			"no_worker_nodes": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"nodes_per_az": {

				Type:     schema.TypeInt,
				Optional: true,
			},

			"total_nodes": {

				Type:     schema.TypeInt,
				Optional: true,
			},
		},
	}
}

// resourceVolterraAzureVnetSiteCreate creates AzureVnetSite resource
func resourceVolterraAzureVnetSiteCreate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	createMeta := &ves_io_schema.ObjectCreateMetaType{}
	createSpec := &ves_io_schema_views_azure_vnet_site.CreateSpecType{}
	createReq := &ves_io_schema_views_azure_vnet_site.CreateRequest{
		Metadata: createMeta,
		Spec:     createSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		createMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		createMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		createMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		createMeta.Namespace =
			v.(string)
	}

	//address
	if v, ok := d.GetOk("address"); ok && !isIntfNil(v) {

		createSpec.Address =
			v.(string)

	}

	//admin_password
	if v, ok := d.GetOk("admin_password"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		adminPassword := &ves_io_schema.SecretType{}
		createSpec.AdminPassword = adminPassword
		for _, set := range sl {
			if set != nil {
				adminPasswordMapStrToI := set.(map[string]interface{})

				secretInfoOneofTypeFound := false

				if v, ok := adminPasswordMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

					secretInfoOneofTypeFound = true
					secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
					secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
					adminPassword.SecretInfoOneof = secretInfoOneofInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

								secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

							}

							if v, ok := cs["location"]; ok && !isIntfNil(v) {

								secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

							}

							if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

								secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

							}

						}
					}

				}

				if v, ok := adminPasswordMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

					secretInfoOneofTypeFound = true
					secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
					secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
					adminPassword.SecretInfoOneof = secretInfoOneofInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["provider"]; ok && !isIntfNil(v) {

								secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

							}

							if v, ok := cs["url"]; ok && !isIntfNil(v) {

								secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

							}

						}
					}

				}

			}
		}

	}

	//blocked_services_choice

	blockedServicesChoiceTypeFound := false

	if v, ok := d.GetOk("block_all_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true

		if v.(bool) {
			blockedServicesChoiceInt := &ves_io_schema_views_azure_vnet_site.CreateSpecType_BlockAllServices{}
			blockedServicesChoiceInt.BlockAllServices = &ves_io_schema.Empty{}
			createSpec.BlockedServicesChoice = blockedServicesChoiceInt
		}

	}

	if v, ok := d.GetOk("blocked_services"); ok && !isIntfNil(v) && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true
		blockedServicesChoiceInt := &ves_io_schema_views_azure_vnet_site.CreateSpecType_BlockedServices{}
		blockedServicesChoiceInt.BlockedServices = &ves_io_schema_fleet.BlockedServicesListType{}
		createSpec.BlockedServicesChoice = blockedServicesChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["blocked_sevice"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					blockedSevice := make([]*ves_io_schema_fleet.BlockedServices, len(sl))
					blockedServicesChoiceInt.BlockedServices.BlockedSevice = blockedSevice
					for i, set := range sl {
						if set != nil {
							blockedSevice[i] = &ves_io_schema_fleet.BlockedServices{}
							blockedSeviceMapStrToI := set.(map[string]interface{})

							blockedServicesValueTypeChoiceTypeFound := false

							if v, ok := blockedSeviceMapStrToI["dns"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

								blockedServicesValueTypeChoiceTypeFound = true

								if v.(bool) {
									blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Dns{}
									blockedServicesValueTypeChoiceInt.Dns = &ves_io_schema.Empty{}
									blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
								}

							}

							if v, ok := blockedSeviceMapStrToI["ssh"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

								blockedServicesValueTypeChoiceTypeFound = true

								if v.(bool) {
									blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Ssh{}
									blockedServicesValueTypeChoiceInt.Ssh = &ves_io_schema.Empty{}
									blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
								}

							}

							if v, ok := blockedSeviceMapStrToI["web_user_interface"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

								blockedServicesValueTypeChoiceTypeFound = true

								if v.(bool) {
									blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_WebUserInterface{}
									blockedServicesValueTypeChoiceInt.WebUserInterface = &ves_io_schema.Empty{}
									blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
								}

							}

							if v, ok := blockedSeviceMapStrToI["network_type"]; ok && !isIntfNil(v) {

								blockedSevice[i].NetworkType = ves_io_schema.VirtualNetworkType(ves_io_schema.VirtualNetworkType_value[v.(string)])

							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("default_blocked_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true

		if v.(bool) {
			blockedServicesChoiceInt := &ves_io_schema_views_azure_vnet_site.CreateSpecType_DefaultBlockedServices{}
			blockedServicesChoiceInt.DefaultBlockedServices = &ves_io_schema.Empty{}
			createSpec.BlockedServicesChoice = blockedServicesChoiceInt
		}

	}

	//coordinates
	if v, ok := d.GetOk("coordinates"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		coordinates := &ves_io_schema_site.Coordinates{}
		createSpec.Coordinates = coordinates
		for _, set := range sl {
			if set != nil {
				coordinatesMapStrToI := set.(map[string]interface{})

				if w, ok := coordinatesMapStrToI["latitude"]; ok && !isIntfNil(w) {
					coordinates.Latitude = float32(w.(float64))
				}

				if w, ok := coordinatesMapStrToI["longitude"]; ok && !isIntfNil(w) {
					coordinates.Longitude = float32(w.(float64))
				}

			}
		}

	}

	//custom_dns
	if v, ok := d.GetOk("custom_dns"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		customDns := &ves_io_schema_views.CustomDNS{}
		createSpec.CustomDns = customDns
		for _, set := range sl {
			if set != nil {
				customDnsMapStrToI := set.(map[string]interface{})

				if w, ok := customDnsMapStrToI["inside_nameserver"]; ok && !isIntfNil(w) {
					customDns.InsideNameserver = w.(string)
				}

				if w, ok := customDnsMapStrToI["inside_nameserver_v6"]; ok && !isIntfNil(w) {
					customDns.InsideNameserverV6 = w.(string)
				}

				if w, ok := customDnsMapStrToI["outside_nameserver"]; ok && !isIntfNil(w) {
					customDns.OutsideNameserver = w.(string)
				}

				if w, ok := customDnsMapStrToI["outside_nameserver_v6"]; ok && !isIntfNil(w) {
					customDns.OutsideNameserverV6 = w.(string)
				}

			}
		}

	}

	//deployment

	deploymentTypeFound := false

	if v, ok := d.GetOk("azure_cred"); ok && !isIntfNil(v) && !deploymentTypeFound {

		deploymentTypeFound = true
		deploymentInt := &ves_io_schema_views_azure_vnet_site.CreateSpecType_AzureCred{}
		deploymentInt.AzureCred = &ves_io_schema_views.ObjectRefType{}
		createSpec.Deployment = deploymentInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["name"]; ok && !isIntfNil(v) {

					deploymentInt.AzureCred.Name = v.(string)

				}

				if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

					deploymentInt.AzureCred.Namespace = v.(string)

				}

				if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

					deploymentInt.AzureCred.Tenant = v.(string)

				}

			}
		}

	}

	//disk_size
	if v, ok := d.GetOk("disk_size"); ok && !isIntfNil(v) {

		createSpec.DiskSize =
			uint32(v.(int))

	}

	//kubernetes_upgrade_drain
	if v, ok := d.GetOk("kubernetes_upgrade_drain"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		kubernetesUpgradeDrain := &ves_io_schema_views.KubernetesUpgradeDrain{}
		createSpec.KubernetesUpgradeDrain = kubernetesUpgradeDrain
		for _, set := range sl {
			if set != nil {
				kubernetesUpgradeDrainMapStrToI := set.(map[string]interface{})

				kubernetesUpgradeDrainEnableChoiceTypeFound := false

				if v, ok := kubernetesUpgradeDrainMapStrToI["disable_upgrade_drain"]; ok && !isIntfNil(v) && !kubernetesUpgradeDrainEnableChoiceTypeFound {

					kubernetesUpgradeDrainEnableChoiceTypeFound = true

					if v.(bool) {
						kubernetesUpgradeDrainEnableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrain_DisableUpgradeDrain{}
						kubernetesUpgradeDrainEnableChoiceInt.DisableUpgradeDrain = &ves_io_schema.Empty{}
						kubernetesUpgradeDrain.KubernetesUpgradeDrainEnableChoice = kubernetesUpgradeDrainEnableChoiceInt
					}

				}

				if v, ok := kubernetesUpgradeDrainMapStrToI["enable_upgrade_drain"]; ok && !isIntfNil(v) && !kubernetesUpgradeDrainEnableChoiceTypeFound {

					kubernetesUpgradeDrainEnableChoiceTypeFound = true
					kubernetesUpgradeDrainEnableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrain_EnableUpgradeDrain{}
					kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain = &ves_io_schema_views.KubernetesUpgradeDrainConfig{}
					kubernetesUpgradeDrain.KubernetesUpgradeDrainEnableChoice = kubernetesUpgradeDrainEnableChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							drainMaxUnavailableChoiceTypeFound := false

							if v, ok := cs["drain_max_unavailable_node_count"]; ok && !isIntfNil(v) && !drainMaxUnavailableChoiceTypeFound {

								drainMaxUnavailableChoiceTypeFound = true
								drainMaxUnavailableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrainConfig_DrainMaxUnavailableNodeCount{}

								kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.DrainMaxUnavailableChoice = drainMaxUnavailableChoiceInt

								drainMaxUnavailableChoiceInt.DrainMaxUnavailableNodeCount = uint32(v.(int))

							}

							if v, ok := cs["drain_node_timeout"]; ok && !isIntfNil(v) {

								kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.DrainNodeTimeout = uint32(v.(int))

							}

						}
					}

				}

			}
		}

	}

	//logs_receiver_choice

	logsReceiverChoiceTypeFound := false

	if v, ok := d.GetOk("log_receiver"); ok && !isIntfNil(v) && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true
		logsReceiverChoiceInt := &ves_io_schema_views_azure_vnet_site.CreateSpecType_LogReceiver{}
		logsReceiverChoiceInt.LogReceiver = &ves_io_schema_views.ObjectRefType{}
		createSpec.LogsReceiverChoice = logsReceiverChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["name"]; ok && !isIntfNil(v) {

					logsReceiverChoiceInt.LogReceiver.Name = v.(string)

				}

				if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

					logsReceiverChoiceInt.LogReceiver.Namespace = v.(string)

				}

				if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

					logsReceiverChoiceInt.LogReceiver.Tenant = v.(string)

				}

			}
		}

	}

	if v, ok := d.GetOk("logs_streaming_disabled"); ok && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true

		if v.(bool) {
			logsReceiverChoiceInt := &ves_io_schema_views_azure_vnet_site.CreateSpecType_LogsStreamingDisabled{}
			logsReceiverChoiceInt.LogsStreamingDisabled = &ves_io_schema.Empty{}
			createSpec.LogsReceiverChoice = logsReceiverChoiceInt
		}

	}

	//machine_type
	if v, ok := d.GetOk("machine_type"); ok && !isIntfNil(v) {

		createSpec.MachineType =
			v.(string)

	}

	//offline_survivability_mode
	if v, ok := d.GetOk("offline_survivability_mode"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		offlineSurvivabilityMode := &ves_io_schema_views.OfflineSurvivabilityModeType{}
		createSpec.OfflineSurvivabilityMode = offlineSurvivabilityMode
		for _, set := range sl {
			if set != nil {
				offlineSurvivabilityModeMapStrToI := set.(map[string]interface{})

				offlineSurvivabilityModeChoiceTypeFound := false

				if v, ok := offlineSurvivabilityModeMapStrToI["enable_offline_survivability_mode"]; ok && !isIntfNil(v) && !offlineSurvivabilityModeChoiceTypeFound {

					offlineSurvivabilityModeChoiceTypeFound = true

					if v.(bool) {
						offlineSurvivabilityModeChoiceInt := &ves_io_schema_views.OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode{}
						offlineSurvivabilityModeChoiceInt.EnableOfflineSurvivabilityMode = &ves_io_schema.Empty{}
						offlineSurvivabilityMode.OfflineSurvivabilityModeChoice = offlineSurvivabilityModeChoiceInt
					}

				}

				if v, ok := offlineSurvivabilityModeMapStrToI["no_offline_survivability_mode"]; ok && !isIntfNil(v) && !offlineSurvivabilityModeChoiceTypeFound {

					offlineSurvivabilityModeChoiceTypeFound = true

					if v.(bool) {
						offlineSurvivabilityModeChoiceInt := &ves_io_schema_views.OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode{}
						offlineSurvivabilityModeChoiceInt.NoOfflineSurvivabilityMode = &ves_io_schema.Empty{}
						offlineSurvivabilityMode.OfflineSurvivabilityModeChoice = offlineSurvivabilityModeChoiceInt
					}

				}

			}
		}

	}

	//os
	if v, ok := d.GetOk("os"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		os := &ves_io_schema_views.OperatingSystemType{}
		createSpec.Os = os
		for _, set := range sl {
			if set != nil {
				osMapStrToI := set.(map[string]interface{})

				operatingSystemVersionChoiceTypeFound := false

				if v, ok := osMapStrToI["default_os_version"]; ok && !isIntfNil(v) && !operatingSystemVersionChoiceTypeFound {

					operatingSystemVersionChoiceTypeFound = true

					if v.(bool) {
						operatingSystemVersionChoiceInt := &ves_io_schema_views.OperatingSystemType_DefaultOsVersion{}
						operatingSystemVersionChoiceInt.DefaultOsVersion = &ves_io_schema.Empty{}
						os.OperatingSystemVersionChoice = operatingSystemVersionChoiceInt
					}

				}

				if v, ok := osMapStrToI["operating_system_version"]; ok && !isIntfNil(v) && !operatingSystemVersionChoiceTypeFound {

					operatingSystemVersionChoiceTypeFound = true
					operatingSystemVersionChoiceInt := &ves_io_schema_views.OperatingSystemType_OperatingSystemVersion{}

					os.OperatingSystemVersionChoice = operatingSystemVersionChoiceInt

					operatingSystemVersionChoiceInt.OperatingSystemVersion = v.(string)

				}

			}
		}

	}

	//region_choice

	regionChoiceTypeFound := false

	if v, ok := d.GetOk("alternate_region"); ok && !isIntfNil(v) && !regionChoiceTypeFound {

		regionChoiceTypeFound = true
		regionChoiceInt := &ves_io_schema_views_azure_vnet_site.CreateSpecType_AlternateRegion{}

		createSpec.RegionChoice = regionChoiceInt

		regionChoiceInt.AlternateRegion = v.(string)

	}

	if v, ok := d.GetOk("azure_region"); ok && !isIntfNil(v) && !regionChoiceTypeFound {

		regionChoiceTypeFound = true
		regionChoiceInt := &ves_io_schema_views_azure_vnet_site.CreateSpecType_AzureRegion{}

		createSpec.RegionChoice = regionChoiceInt

		regionChoiceInt.AzureRegion = v.(string)

	}

	//resource_group
	if v, ok := d.GetOk("resource_group"); ok && !isIntfNil(v) {

		createSpec.ResourceGroup =
			v.(string)

	}

	//site_type

	siteTypeTypeFound := false

	if v, ok := d.GetOk("ingress_egress_gw"); ok && !isIntfNil(v) && !siteTypeTypeFound {

		siteTypeTypeFound = true
		siteTypeInt := &ves_io_schema_views_azure_vnet_site.CreateSpecType_IngressEgressGw{}
		siteTypeInt.IngressEgressGw = &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwType{}
		createSpec.SiteType = siteTypeInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["accelerated_networking"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					acceleratedNetworking := &ves_io_schema_views.AcceleratedNetworkingType{}
					siteTypeInt.IngressEgressGw.AcceleratedNetworking = acceleratedNetworking
					for _, set := range sl {
						if set != nil {
							acceleratedNetworkingMapStrToI := set.(map[string]interface{})

							acceleratedNetworkingTypeFound := false

							if v, ok := acceleratedNetworkingMapStrToI["disable"]; ok && !isIntfNil(v) && !acceleratedNetworkingTypeFound {

								acceleratedNetworkingTypeFound = true

								if v.(bool) {
									acceleratedNetworkingInt := &ves_io_schema_views.AcceleratedNetworkingType_Disable{}
									acceleratedNetworkingInt.Disable = &ves_io_schema.Empty{}
									acceleratedNetworking.AcceleratedNetworking = acceleratedNetworkingInt
								}

							}

							if v, ok := acceleratedNetworkingMapStrToI["enable"]; ok && !isIntfNil(v) && !acceleratedNetworkingTypeFound {

								acceleratedNetworkingTypeFound = true

								if v.(bool) {
									acceleratedNetworkingInt := &ves_io_schema_views.AcceleratedNetworkingType_Enable{}
									acceleratedNetworkingInt.Enable = &ves_io_schema.Empty{}
									acceleratedNetworking.AcceleratedNetworking = acceleratedNetworkingInt
								}

							}

						}
					}

				}

				if v, ok := cs["az_nodes"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					azNodes := make([]*ves_io_schema_views.AzureVnetTwoInterfaceNodeType, len(sl))
					siteTypeInt.IngressEgressGw.AzNodes = azNodes
					for i, set := range sl {
						if set != nil {
							azNodes[i] = &ves_io_schema_views.AzureVnetTwoInterfaceNodeType{}
							azNodesMapStrToI := set.(map[string]interface{})

							if w, ok := azNodesMapStrToI["azure_az"]; ok && !isIntfNil(w) {
								azNodes[i].AzureAz = w.(string)
							}

							if v, ok := azNodesMapStrToI["inside_subnet"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								insideSubnet := &ves_io_schema_views.AzureSubnetChoiceType{}
								azNodes[i].InsideSubnet = insideSubnet
								for _, set := range sl {
									if set != nil {
										insideSubnetMapStrToI := set.(map[string]interface{})

										choiceTypeFound := false

										if v, ok := insideSubnetMapStrToI["subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_Subnet{}
											choiceInt.Subnet = &ves_io_schema_views.AzureSubnetType{}
											insideSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													resourceGroupChoiceTypeFound := false

													if v, ok := cs["subnet_resource_grp"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true
														resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_SubnetResourceGrp{}

														choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt

														resourceGroupChoiceInt.SubnetResourceGrp = v.(string)

													}

													if v, ok := cs["vnet_resource_group"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true

														if v.(bool) {
															resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_VnetResourceGroup{}
															resourceGroupChoiceInt.VnetResourceGroup = &ves_io_schema.Empty{}
															choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt
														}

													}

													if v, ok := cs["subnet_name"]; ok && !isIntfNil(v) {

														choiceInt.Subnet.SubnetName = v.(string)

													}

												}
											}

										}

										if v, ok := insideSubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_SubnetParam{}
											choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
											insideSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv4 = v.(string)

													}

													if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv6 = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if v, ok := azNodesMapStrToI["outside_subnet"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								outsideSubnet := &ves_io_schema_views.AzureSubnetChoiceType{}
								azNodes[i].OutsideSubnet = outsideSubnet
								for _, set := range sl {
									if set != nil {
										outsideSubnetMapStrToI := set.(map[string]interface{})

										choiceTypeFound := false

										if v, ok := outsideSubnetMapStrToI["subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_Subnet{}
											choiceInt.Subnet = &ves_io_schema_views.AzureSubnetType{}
											outsideSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													resourceGroupChoiceTypeFound := false

													if v, ok := cs["subnet_resource_grp"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true
														resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_SubnetResourceGrp{}

														choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt

														resourceGroupChoiceInt.SubnetResourceGrp = v.(string)

													}

													if v, ok := cs["vnet_resource_group"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true

														if v.(bool) {
															resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_VnetResourceGroup{}
															resourceGroupChoiceInt.VnetResourceGroup = &ves_io_schema.Empty{}
															choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt
														}

													}

													if v, ok := cs["subnet_name"]; ok && !isIntfNil(v) {

														choiceInt.Subnet.SubnetName = v.(string)

													}

												}
											}

										}

										if v, ok := outsideSubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_SubnetParam{}
											choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
											outsideSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv4 = v.(string)

													}

													if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv6 = v.(string)

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["azure_certified_hw"]; ok && !isIntfNil(v) {

					siteTypeInt.IngressEgressGw.AzureCertifiedHw = v.(string)

				}

				dcClusterGroupChoiceTypeFound := false

				if v, ok := cs["dc_cluster_group_inside_vn"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

					dcClusterGroupChoiceTypeFound = true
					dcClusterGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwType_DcClusterGroupInsideVn{}
					dcClusterGroupChoiceInt.DcClusterGroupInsideVn = &ves_io_schema_views.ObjectRefType{}
					siteTypeInt.IngressEgressGw.DcClusterGroupChoice = dcClusterGroupChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupInsideVn.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupInsideVn.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupInsideVn.Tenant = v.(string)

							}

						}
					}

				}

				if v, ok := cs["dc_cluster_group_outside_vn"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

					dcClusterGroupChoiceTypeFound = true
					dcClusterGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwType_DcClusterGroupOutsideVn{}
					dcClusterGroupChoiceInt.DcClusterGroupOutsideVn = &ves_io_schema_views.ObjectRefType{}
					siteTypeInt.IngressEgressGw.DcClusterGroupChoice = dcClusterGroupChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupOutsideVn.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupOutsideVn.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupOutsideVn.Tenant = v.(string)

							}

						}
					}

				}

				if v, ok := cs["no_dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

					dcClusterGroupChoiceTypeFound = true

					if v.(bool) {
						dcClusterGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwType_NoDcClusterGroup{}
						dcClusterGroupChoiceInt.NoDcClusterGroup = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGw.DcClusterGroupChoice = dcClusterGroupChoiceInt
					}

				}

				forwardProxyChoiceTypeFound := false

				if v, ok := cs["active_forward_proxy_policies"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true
					forwardProxyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwType_ActiveForwardProxyPolicies{}
					forwardProxyChoiceInt.ActiveForwardProxyPolicies = &ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType{}
					siteTypeInt.IngressEgressGw.ForwardProxyChoice = forwardProxyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["forward_proxy_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								forwardProxyPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								forwardProxyChoiceInt.ActiveForwardProxyPolicies.ForwardProxyPolicies = forwardProxyPoliciesInt
								for i, ps := range sl {

									fppMapToStrVal := ps.(map[string]interface{})
									forwardProxyPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := fppMapToStrVal["name"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Name = v.(string)
									}

									if v, ok := fppMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := fppMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["forward_proxy_allow_all"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true

					if v.(bool) {
						forwardProxyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwType_ForwardProxyAllowAll{}
						forwardProxyChoiceInt.ForwardProxyAllowAll = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGw.ForwardProxyChoice = forwardProxyChoiceInt
					}

				}

				if v, ok := cs["no_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true

					if v.(bool) {
						forwardProxyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwType_NoForwardProxy{}
						forwardProxyChoiceInt.NoForwardProxy = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGw.ForwardProxyChoice = forwardProxyChoiceInt
					}

				}

				globalNetworkChoiceTypeFound := false

				if v, ok := cs["global_network_list"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

					globalNetworkChoiceTypeFound = true
					globalNetworkChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwType_GlobalNetworkList{}
					globalNetworkChoiceInt.GlobalNetworkList = &ves_io_schema_views.GlobalNetworkConnectionListType{}
					siteTypeInt.IngressEgressGw.GlobalNetworkChoice = globalNetworkChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["global_network_connections"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								globalNetworkConnections := make([]*ves_io_schema_views.GlobalNetworkConnectionType, len(sl))
								globalNetworkChoiceInt.GlobalNetworkList.GlobalNetworkConnections = globalNetworkConnections
								for i, set := range sl {
									if set != nil {
										globalNetworkConnections[i] = &ves_io_schema_views.GlobalNetworkConnectionType{}
										globalNetworkConnectionsMapStrToI := set.(map[string]interface{})

										connectionChoiceTypeFound := false

										if v, ok := globalNetworkConnectionsMapStrToI["sli_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

											connectionChoiceTypeFound = true
											connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SliToGlobalDr{}
											connectionChoiceInt.SliToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
											globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														globalVn := &ves_io_schema_views.ObjectRefType{}
														connectionChoiceInt.SliToGlobalDr.GlobalVn = globalVn
														for _, set := range sl {
															if set != nil {
																globalVnMapStrToI := set.(map[string]interface{})

																if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
																	globalVn.Name = w.(string)
																}

																if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
																	globalVn.Namespace = w.(string)
																}

																if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
																	globalVn.Tenant = w.(string)
																}

															}
														}

													}

												}
											}

										}

										if v, ok := globalNetworkConnectionsMapStrToI["slo_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

											connectionChoiceTypeFound = true
											connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SloToGlobalDr{}
											connectionChoiceInt.SloToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
											globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														globalVn := &ves_io_schema_views.ObjectRefType{}
														connectionChoiceInt.SloToGlobalDr.GlobalVn = globalVn
														for _, set := range sl {
															if set != nil {
																globalVnMapStrToI := set.(map[string]interface{})

																if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
																	globalVn.Name = w.(string)
																}

																if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
																	globalVn.Namespace = w.(string)
																}

																if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
																	globalVn.Tenant = w.(string)
																}

															}
														}

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["no_global_network"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

					globalNetworkChoiceTypeFound = true

					if v.(bool) {
						globalNetworkChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwType_NoGlobalNetwork{}
						globalNetworkChoiceInt.NoGlobalNetwork = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGw.GlobalNetworkChoice = globalNetworkChoiceInt
					}

				}

				hubChoiceTypeFound := false

				if v, ok := cs["hub"]; ok && !isIntfNil(v) && !hubChoiceTypeFound {

					hubChoiceTypeFound = true
					hubChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwType_Hub{}
					hubChoiceInt.Hub = &ves_io_schema_views_azure_vnet_site.AzureHubVnetType{}
					siteTypeInt.IngressEgressGw.HubChoice = hubChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							expressRouteChoiceTypeFound := false

							if v, ok := cs["express_route_disabled"]; ok && !isIntfNil(v) && !expressRouteChoiceTypeFound {

								expressRouteChoiceTypeFound = true

								if v.(bool) {
									expressRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureHubVnetType_ExpressRouteDisabled{}
									expressRouteChoiceInt.ExpressRouteDisabled = &ves_io_schema.Empty{}
									hubChoiceInt.Hub.ExpressRouteChoice = expressRouteChoiceInt
								}

							}

							if v, ok := cs["express_route_enabled"]; ok && !isIntfNil(v) && !expressRouteChoiceTypeFound {

								expressRouteChoiceTypeFound = true
								expressRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureHubVnetType_ExpressRouteEnabled{}
								expressRouteChoiceInt.ExpressRouteEnabled = &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType{}
								hubChoiceInt.Hub.ExpressRouteChoice = expressRouteChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										asnChoiceTypeFound := false

										if v, ok := cs["auto_asn"]; ok && !isIntfNil(v) && !asnChoiceTypeFound {

											asnChoiceTypeFound = true

											if v.(bool) {
												asnChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_AutoAsn{}
												asnChoiceInt.AutoAsn = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.AsnChoice = asnChoiceInt
											}

										}

										if v, ok := cs["custom_asn"]; ok && !isIntfNil(v) && !asnChoiceTypeFound {

											asnChoiceTypeFound = true
											asnChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_CustomAsn{}

											expressRouteChoiceInt.ExpressRouteEnabled.AsnChoice = asnChoiceInt

											asnChoiceInt.CustomAsn = uint32(v.(int))

										}

										if v, ok := cs["connections"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											connections := make([]*ves_io_schema_views_azure_vnet_site.ExpressRouteConnectionType, len(sl))
											expressRouteChoiceInt.ExpressRouteEnabled.Connections = connections
											for i, set := range sl {
												if set != nil {
													connections[i] = &ves_io_schema_views_azure_vnet_site.ExpressRouteConnectionType{}
													connectionsMapStrToI := set.(map[string]interface{})

													if v, ok := connectionsMapStrToI["metadata"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														metadata := &ves_io_schema.MessageMetaType{}
														connections[i].Metadata = metadata
														for _, set := range sl {
															if set != nil {
																metadataMapStrToI := set.(map[string]interface{})

																if w, ok := metadataMapStrToI["description"]; ok && !isIntfNil(w) {
																	metadata.Description = w.(string)
																}

																if w, ok := metadataMapStrToI["name"]; ok && !isIntfNil(w) {
																	metadata.Name = w.(string)
																}

															}
														}

													}

													subscriptionChoiceTypeFound := false

													if v, ok := connectionsMapStrToI["circuit_id"]; ok && !isIntfNil(v) && !subscriptionChoiceTypeFound {

														subscriptionChoiceTypeFound = true
														subscriptionChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConnectionType_CircuitId{}

														connections[i].SubscriptionChoice = subscriptionChoiceInt

														subscriptionChoiceInt.CircuitId = v.(string)

													}

													if v, ok := connectionsMapStrToI["other_subscription"]; ok && !isIntfNil(v) && !subscriptionChoiceTypeFound {

														subscriptionChoiceTypeFound = true
														subscriptionChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConnectionType_OtherSubscription{}
														subscriptionChoiceInt.OtherSubscription = &ves_io_schema_views_azure_vnet_site.ExpressRouteOtherSubscriptionConnection{}
														connections[i].SubscriptionChoice = subscriptionChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["authorized_key"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	authorizedKey := &ves_io_schema.SecretType{}
																	subscriptionChoiceInt.OtherSubscription.AuthorizedKey = authorizedKey
																	for _, set := range sl {
																		if set != nil {
																			authorizedKeyMapStrToI := set.(map[string]interface{})

																			secretInfoOneofTypeFound := false

																			if v, ok := authorizedKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																				secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																				authorizedKey.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																						}

																						if v, ok := cs["location"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																						}

																						if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := authorizedKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																				secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																				authorizedKey.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																						}

																						if v, ok := cs["url"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["circuit_id"]; ok && !isIntfNil(v) {

																	subscriptionChoiceInt.OtherSubscription.CircuitId = v.(string)

																}

															}
														}

													}

													if w, ok := connectionsMapStrToI["weight"]; ok && !isIntfNil(w) {
														connections[i].Weight = uint32(w.(int))
													}

												}
											}

										}

										connectivityOptionsTypeFound := false

										if v, ok := cs["site_registration_over_express_route"]; ok && !isIntfNil(v) && !connectivityOptionsTypeFound {

											connectivityOptionsTypeFound = true
											connectivityOptionsInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_SiteRegistrationOverExpressRoute{}
											connectivityOptionsInt.SiteRegistrationOverExpressRoute = &ves_io_schema_views.CloudLinkADNType{}
											expressRouteChoiceInt.ExpressRouteEnabled.ConnectivityOptions = connectivityOptionsInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["cloudlink_network_name"]; ok && !isIntfNil(v) {

														connectivityOptionsInt.SiteRegistrationOverExpressRoute.CloudlinkNetworkName = v.(string)

													}

												}
											}

										}

										if v, ok := cs["site_registration_over_internet"]; ok && !isIntfNil(v) && !connectivityOptionsTypeFound {

											connectivityOptionsTypeFound = true

											if v.(bool) {
												connectivityOptionsInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_SiteRegistrationOverInternet{}
												connectivityOptionsInt.SiteRegistrationOverInternet = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.ConnectivityOptions = connectivityOptionsInt
											}

										}

										if v, ok := cs["gateway_subnet"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											gatewaySubnet := &ves_io_schema_views.AzureSubnetChoiceWithAutoType{}
											expressRouteChoiceInt.ExpressRouteEnabled.GatewaySubnet = gatewaySubnet
											for _, set := range sl {
												if set != nil {
													gatewaySubnetMapStrToI := set.(map[string]interface{})

													choiceTypeFound := false

													if v, ok := gatewaySubnetMapStrToI["auto"]; ok && !isIntfNil(v) && !choiceTypeFound {

														choiceTypeFound = true

														if v.(bool) {
															choiceInt := &ves_io_schema_views.AzureSubnetChoiceWithAutoType_Auto{}
															choiceInt.Auto = &ves_io_schema.Empty{}
															gatewaySubnet.Choice = choiceInt
														}

													}

													if v, ok := gatewaySubnetMapStrToI["subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

														choiceTypeFound = true
														choiceInt := &ves_io_schema_views.AzureSubnetChoiceWithAutoType_Subnet{}
														choiceInt.Subnet = &ves_io_schema_views.AzureSpecialSubnetType{}
														gatewaySubnet.Choice = choiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																resourceGroupChoiceTypeFound := false

																if v, ok := cs["subnet_resource_grp"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

																	resourceGroupChoiceTypeFound = true
																	resourceGroupChoiceInt := &ves_io_schema_views.AzureSpecialSubnetType_SubnetResourceGrp{}

																	choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt

																	resourceGroupChoiceInt.SubnetResourceGrp = v.(string)

																}

																if v, ok := cs["vnet_resource_group"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

																	resourceGroupChoiceTypeFound = true

																	if v.(bool) {
																		resourceGroupChoiceInt := &ves_io_schema_views.AzureSpecialSubnetType_VnetResourceGroup{}
																		resourceGroupChoiceInt.VnetResourceGroup = &ves_io_schema.Empty{}
																		choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt
																	}

																}

															}
														}

													}

													if v, ok := gatewaySubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

														choiceTypeFound = true
														choiceInt := &ves_io_schema_views.AzureSubnetChoiceWithAutoType_SubnetParam{}
														choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
														gatewaySubnet.Choice = choiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

																	choiceInt.SubnetParam.Ipv4 = v.(string)

																}

																if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

																	choiceInt.SubnetParam.Ipv6 = v.(string)

																}

															}
														}

													}

												}
											}

										}

										if v, ok := cs["route_server_subnet"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											routeServerSubnet := &ves_io_schema_views.AzureSubnetChoiceWithAutoType{}
											expressRouteChoiceInt.ExpressRouteEnabled.RouteServerSubnet = routeServerSubnet
											for _, set := range sl {
												if set != nil {
													routeServerSubnetMapStrToI := set.(map[string]interface{})

													choiceTypeFound := false

													if v, ok := routeServerSubnetMapStrToI["auto"]; ok && !isIntfNil(v) && !choiceTypeFound {

														choiceTypeFound = true

														if v.(bool) {
															choiceInt := &ves_io_schema_views.AzureSubnetChoiceWithAutoType_Auto{}
															choiceInt.Auto = &ves_io_schema.Empty{}
															routeServerSubnet.Choice = choiceInt
														}

													}

													if v, ok := routeServerSubnetMapStrToI["subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

														choiceTypeFound = true
														choiceInt := &ves_io_schema_views.AzureSubnetChoiceWithAutoType_Subnet{}
														choiceInt.Subnet = &ves_io_schema_views.AzureSpecialSubnetType{}
														routeServerSubnet.Choice = choiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																resourceGroupChoiceTypeFound := false

																if v, ok := cs["subnet_resource_grp"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

																	resourceGroupChoiceTypeFound = true
																	resourceGroupChoiceInt := &ves_io_schema_views.AzureSpecialSubnetType_SubnetResourceGrp{}

																	choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt

																	resourceGroupChoiceInt.SubnetResourceGrp = v.(string)

																}

																if v, ok := cs["vnet_resource_group"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

																	resourceGroupChoiceTypeFound = true

																	if v.(bool) {
																		resourceGroupChoiceInt := &ves_io_schema_views.AzureSpecialSubnetType_VnetResourceGroup{}
																		resourceGroupChoiceInt.VnetResourceGroup = &ves_io_schema.Empty{}
																		choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt
																	}

																}

															}
														}

													}

													if v, ok := routeServerSubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

														choiceTypeFound = true
														choiceInt := &ves_io_schema_views.AzureSubnetChoiceWithAutoType_SubnetParam{}
														choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
														routeServerSubnet.Choice = choiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

																	choiceInt.SubnetParam.Ipv4 = v.(string)

																}

																if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

																	choiceInt.SubnetParam.Ipv6 = v.(string)

																}

															}
														}

													}

												}
											}

										}

										skuChoiceTypeFound := false

										if v, ok := cs["sku_ergw1az"]; ok && !isIntfNil(v) && !skuChoiceTypeFound {

											skuChoiceTypeFound = true

											if v.(bool) {
												skuChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_SkuErgw1Az{}
												skuChoiceInt.SkuErgw1Az = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.SkuChoice = skuChoiceInt
											}

										}

										if v, ok := cs["sku_ergw2az"]; ok && !isIntfNil(v) && !skuChoiceTypeFound {

											skuChoiceTypeFound = true

											if v.(bool) {
												skuChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_SkuErgw2Az{}
												skuChoiceInt.SkuErgw2Az = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.SkuChoice = skuChoiceInt
											}

										}

										if v, ok := cs["sku_high_perf"]; ok && !isIntfNil(v) && !skuChoiceTypeFound {

											skuChoiceTypeFound = true

											if v.(bool) {
												skuChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_SkuHighPerf{}
												skuChoiceInt.SkuHighPerf = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.SkuChoice = skuChoiceInt
											}

										}

										if v, ok := cs["sku_standard"]; ok && !isIntfNil(v) && !skuChoiceTypeFound {

											skuChoiceTypeFound = true

											if v.(bool) {
												skuChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_SkuStandard{}
												skuChoiceInt.SkuStandard = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.SkuChoice = skuChoiceInt
											}

										}

										spokeVnetRoutesTypeFound := false

										if v, ok := cs["advertise_to_route_server"]; ok && !isIntfNil(v) && !spokeVnetRoutesTypeFound {

											spokeVnetRoutesTypeFound = true

											if v.(bool) {
												spokeVnetRoutesInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_AdvertiseToRouteServer{}
												spokeVnetRoutesInt.AdvertiseToRouteServer = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.SpokeVnetRoutes = spokeVnetRoutesInt
											}

										}

										if v, ok := cs["do_not_advertise_to_route_server"]; ok && !isIntfNil(v) && !spokeVnetRoutesTypeFound {

											spokeVnetRoutesTypeFound = true

											if v.(bool) {
												spokeVnetRoutesInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_DoNotAdvertiseToRouteServer{}
												spokeVnetRoutesInt.DoNotAdvertiseToRouteServer = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.SpokeVnetRoutes = spokeVnetRoutesInt
											}

										}

									}
								}

							}

							if v, ok := cs["spoke_vnets"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								spokeVnets := make([]*ves_io_schema_views_azure_vnet_site.VnetPeeringType, len(sl))
								hubChoiceInt.Hub.SpokeVnets = spokeVnets
								for i, set := range sl {
									if set != nil {
										spokeVnets[i] = &ves_io_schema_views_azure_vnet_site.VnetPeeringType{}
										spokeVnetsMapStrToI := set.(map[string]interface{})

										if w, ok := spokeVnetsMapStrToI["labels"]; ok && !isIntfNil(w) {
											ms := map[string]string{}
											for k, v := range w.(map[string]interface{}) {
												ms[k] = v.(string)
											}
											spokeVnets[i].Labels = ms
										}

										routingChoiceTypeFound := false

										if v, ok := spokeVnetsMapStrToI["auto"]; ok && !isIntfNil(v) && !routingChoiceTypeFound {

											routingChoiceTypeFound = true

											if v.(bool) {
												routingChoiceInt := &ves_io_schema_views_azure_vnet_site.VnetPeeringType_Auto{}
												routingChoiceInt.Auto = &ves_io_schema.Empty{}
												spokeVnets[i].RoutingChoice = routingChoiceInt
											}

										}

										if v, ok := spokeVnetsMapStrToI["manual"]; ok && !isIntfNil(v) && !routingChoiceTypeFound {

											routingChoiceTypeFound = true

											if v.(bool) {
												routingChoiceInt := &ves_io_schema_views_azure_vnet_site.VnetPeeringType_Manual{}
												routingChoiceInt.Manual = &ves_io_schema.Empty{}
												spokeVnets[i].RoutingChoice = routingChoiceInt
											}

										}

										if v, ok := spokeVnetsMapStrToI["vnet"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											vnet := &ves_io_schema_views.AzureVnetType{}
											spokeVnets[i].Vnet = vnet
											for _, set := range sl {
												if set != nil {
													vnetMapStrToI := set.(map[string]interface{})

													if w, ok := vnetMapStrToI["resource_group"]; ok && !isIntfNil(w) {
														vnet.ResourceGroup = w.(string)
													}

													routingTypeTypeFound := false

													if v, ok := vnetMapStrToI["f5_orchestrated_routing"]; ok && !isIntfNil(v) && !routingTypeTypeFound {

														routingTypeTypeFound = true

														if v.(bool) {
															routingTypeInt := &ves_io_schema_views.AzureVnetType_F5OrchestratedRouting{}
															routingTypeInt.F5OrchestratedRouting = &ves_io_schema.Empty{}
															vnet.RoutingType = routingTypeInt
														}

													}

													if v, ok := vnetMapStrToI["manual_routing"]; ok && !isIntfNil(v) && !routingTypeTypeFound {

														routingTypeTypeFound = true

														if v.(bool) {
															routingTypeInt := &ves_io_schema_views.AzureVnetType_ManualRouting{}
															routingTypeInt.ManualRouting = &ves_io_schema.Empty{}
															vnet.RoutingType = routingTypeInt
														}

													}

													if w, ok := vnetMapStrToI["vnet_name"]; ok && !isIntfNil(w) {
														vnet.VnetName = w.(string)
													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["not_hub"]; ok && !isIntfNil(v) && !hubChoiceTypeFound {

					hubChoiceTypeFound = true

					if v.(bool) {
						hubChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwType_NotHub{}
						hubChoiceInt.NotHub = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGw.HubChoice = hubChoiceInt
					}

				}

				insideStaticRouteChoiceTypeFound := false

				if v, ok := cs["inside_static_routes"]; ok && !isIntfNil(v) && !insideStaticRouteChoiceTypeFound {

					insideStaticRouteChoiceTypeFound = true
					insideStaticRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwType_InsideStaticRoutes{}
					insideStaticRouteChoiceInt.InsideStaticRoutes = &ves_io_schema_views.SiteStaticRoutesListType{}
					siteTypeInt.IngressEgressGw.InsideStaticRouteChoice = insideStaticRouteChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_route_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRouteList := make([]*ves_io_schema_views.SiteStaticRoutesType, len(sl))
								insideStaticRouteChoiceInt.InsideStaticRoutes.StaticRouteList = staticRouteList
								for i, set := range sl {
									if set != nil {
										staticRouteList[i] = &ves_io_schema_views.SiteStaticRoutesType{}
										staticRouteListMapStrToI := set.(map[string]interface{})

										configModeChoiceTypeFound := false

										if v, ok := staticRouteListMapStrToI["custom_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_CustomStaticRoute{}
											configModeChoiceInt.CustomStaticRoute = &ves_io_schema.StaticRouteType{}
											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["attrs"]; ok && !isIntfNil(v) {

														attrsList := []ves_io_schema.RouteAttrType{}
														for _, j := range v.([]interface{}) {
															if j == nil {
																return fmt.Errorf("please provide valid non-empty enum value of field attrs")
															}
															attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
														}
														configModeChoiceInt.CustomStaticRoute.Attrs = attrsList

													}

													if v, ok := cs["labels"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														configModeChoiceInt.CustomStaticRoute.Labels = ms
													}

													if v, ok := cs["nexthop"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														nexthop := &ves_io_schema.NextHopType{}
														configModeChoiceInt.CustomStaticRoute.Nexthop = nexthop
														for _, set := range sl {
															if set != nil {
																nexthopMapStrToI := set.(map[string]interface{})

																if v, ok := nexthopMapStrToI["interface"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	intfInt := make([]*ves_io_schema.ObjectRefType, len(sl))
																	nexthop.Interface = intfInt
																	for i, ps := range sl {

																		iMapToStrVal := ps.(map[string]interface{})
																		intfInt[i] = &ves_io_schema.ObjectRefType{}

																		intfInt[i].Kind = "network_interface"

																		if v, ok := iMapToStrVal["name"]; ok && !isIntfNil(v) {
																			intfInt[i].Name = v.(string)
																		}

																		if v, ok := iMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																			intfInt[i].Namespace = v.(string)
																		}

																		if v, ok := iMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																			intfInt[i].Tenant = v.(string)
																		}

																		if v, ok := iMapToStrVal["uid"]; ok && !isIntfNil(v) {
																			intfInt[i].Uid = v.(string)
																		}

																	}

																}

																if v, ok := nexthopMapStrToI["nexthop_address"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	nexthopAddress := &ves_io_schema.IpAddressType{}
																	nexthop.NexthopAddress = nexthopAddress
																	for _, set := range sl {
																		if set != nil {
																			nexthopAddressMapStrToI := set.(map[string]interface{})

																			verTypeFound := false

																			if v, ok := nexthopAddressMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv4{}
																				verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv4.Addr = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := nexthopAddressMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv6{}
																				verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv6.Addr = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := nexthopMapStrToI["type"]; ok && !isIntfNil(v) {

																	nexthop.Type = ves_io_schema.NextHopTypes(ves_io_schema.NextHopTypes_value[v.(string)])

																}

															}
														}

													}

													if v, ok := cs["subnets"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														subnets := make([]*ves_io_schema.IpSubnetType, len(sl))
														configModeChoiceInt.CustomStaticRoute.Subnets = subnets
														for i, set := range sl {
															if set != nil {
																subnets[i] = &ves_io_schema.IpSubnetType{}
																subnetsMapStrToI := set.(map[string]interface{})

																verTypeFound := false

																if v, ok := subnetsMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv4{}
																	verInt.Ipv4 = &ves_io_schema.Ipv4SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Prefix = v.(string)

																			}

																		}
																	}

																}

																if v, ok := subnetsMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv6{}
																	verInt.Ipv6 = &ves_io_schema.Ipv6SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Prefix = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

												}
											}

										}

										if v, ok := staticRouteListMapStrToI["simple_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_SimpleStaticRoute{}

											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											configModeChoiceInt.SimpleStaticRoute = v.(string)

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["no_inside_static_routes"]; ok && !isIntfNil(v) && !insideStaticRouteChoiceTypeFound {

					insideStaticRouteChoiceTypeFound = true

					if v.(bool) {
						insideStaticRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwType_NoInsideStaticRoutes{}
						insideStaticRouteChoiceInt.NoInsideStaticRoutes = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGw.InsideStaticRouteChoice = insideStaticRouteChoiceInt
					}

				}

				networkPolicyChoiceTypeFound := false

				if v, ok := cs["active_enhanced_firewall_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true
					networkPolicyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwType_ActiveEnhancedFirewallPolicies{}
					networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies = &ves_io_schema_network_firewall.ActiveEnhancedFirewallPoliciesType{}
					siteTypeInt.IngressEgressGw.NetworkPolicyChoice = networkPolicyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["enhanced_firewall_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								enhancedFirewallPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies.EnhancedFirewallPolicies = enhancedFirewallPoliciesInt
								for i, ps := range sl {

									efpMapToStrVal := ps.(map[string]interface{})
									enhancedFirewallPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := efpMapToStrVal["name"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Name = v.(string)
									}

									if v, ok := efpMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := efpMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["active_network_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true
					networkPolicyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwType_ActiveNetworkPolicies{}
					networkPolicyChoiceInt.ActiveNetworkPolicies = &ves_io_schema_network_firewall.ActiveNetworkPoliciesType{}
					siteTypeInt.IngressEgressGw.NetworkPolicyChoice = networkPolicyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["network_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								networkPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								networkPolicyChoiceInt.ActiveNetworkPolicies.NetworkPolicies = networkPoliciesInt
								for i, ps := range sl {

									npMapToStrVal := ps.(map[string]interface{})
									networkPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := npMapToStrVal["name"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Name = v.(string)
									}

									if v, ok := npMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := npMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["no_network_policy"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true

					if v.(bool) {
						networkPolicyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwType_NoNetworkPolicy{}
						networkPolicyChoiceInt.NoNetworkPolicy = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGw.NetworkPolicyChoice = networkPolicyChoiceInt
					}

				}

				outsideStaticRouteChoiceTypeFound := false

				if v, ok := cs["no_outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

					outsideStaticRouteChoiceTypeFound = true

					if v.(bool) {
						outsideStaticRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwType_NoOutsideStaticRoutes{}
						outsideStaticRouteChoiceInt.NoOutsideStaticRoutes = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGw.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt
					}

				}

				if v, ok := cs["outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

					outsideStaticRouteChoiceTypeFound = true
					outsideStaticRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwType_OutsideStaticRoutes{}
					outsideStaticRouteChoiceInt.OutsideStaticRoutes = &ves_io_schema_views.SiteStaticRoutesListType{}
					siteTypeInt.IngressEgressGw.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_route_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRouteList := make([]*ves_io_schema_views.SiteStaticRoutesType, len(sl))
								outsideStaticRouteChoiceInt.OutsideStaticRoutes.StaticRouteList = staticRouteList
								for i, set := range sl {
									if set != nil {
										staticRouteList[i] = &ves_io_schema_views.SiteStaticRoutesType{}
										staticRouteListMapStrToI := set.(map[string]interface{})

										configModeChoiceTypeFound := false

										if v, ok := staticRouteListMapStrToI["custom_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_CustomStaticRoute{}
											configModeChoiceInt.CustomStaticRoute = &ves_io_schema.StaticRouteType{}
											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["attrs"]; ok && !isIntfNil(v) {

														attrsList := []ves_io_schema.RouteAttrType{}
														for _, j := range v.([]interface{}) {
															if j == nil {
																return fmt.Errorf("please provide valid non-empty enum value of field attrs")
															}
															attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
														}
														configModeChoiceInt.CustomStaticRoute.Attrs = attrsList

													}

													if v, ok := cs["labels"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														configModeChoiceInt.CustomStaticRoute.Labels = ms
													}

													if v, ok := cs["nexthop"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														nexthop := &ves_io_schema.NextHopType{}
														configModeChoiceInt.CustomStaticRoute.Nexthop = nexthop
														for _, set := range sl {
															if set != nil {
																nexthopMapStrToI := set.(map[string]interface{})

																if v, ok := nexthopMapStrToI["interface"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	intfInt := make([]*ves_io_schema.ObjectRefType, len(sl))
																	nexthop.Interface = intfInt
																	for i, ps := range sl {

																		iMapToStrVal := ps.(map[string]interface{})
																		intfInt[i] = &ves_io_schema.ObjectRefType{}

																		intfInt[i].Kind = "network_interface"

																		if v, ok := iMapToStrVal["name"]; ok && !isIntfNil(v) {
																			intfInt[i].Name = v.(string)
																		}

																		if v, ok := iMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																			intfInt[i].Namespace = v.(string)
																		}

																		if v, ok := iMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																			intfInt[i].Tenant = v.(string)
																		}

																		if v, ok := iMapToStrVal["uid"]; ok && !isIntfNil(v) {
																			intfInt[i].Uid = v.(string)
																		}

																	}

																}

																if v, ok := nexthopMapStrToI["nexthop_address"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	nexthopAddress := &ves_io_schema.IpAddressType{}
																	nexthop.NexthopAddress = nexthopAddress
																	for _, set := range sl {
																		if set != nil {
																			nexthopAddressMapStrToI := set.(map[string]interface{})

																			verTypeFound := false

																			if v, ok := nexthopAddressMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv4{}
																				verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv4.Addr = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := nexthopAddressMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv6{}
																				verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv6.Addr = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := nexthopMapStrToI["type"]; ok && !isIntfNil(v) {

																	nexthop.Type = ves_io_schema.NextHopTypes(ves_io_schema.NextHopTypes_value[v.(string)])

																}

															}
														}

													}

													if v, ok := cs["subnets"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														subnets := make([]*ves_io_schema.IpSubnetType, len(sl))
														configModeChoiceInt.CustomStaticRoute.Subnets = subnets
														for i, set := range sl {
															if set != nil {
																subnets[i] = &ves_io_schema.IpSubnetType{}
																subnetsMapStrToI := set.(map[string]interface{})

																verTypeFound := false

																if v, ok := subnetsMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv4{}
																	verInt.Ipv4 = &ves_io_schema.Ipv4SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Prefix = v.(string)

																			}

																		}
																	}

																}

																if v, ok := subnetsMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv6{}
																	verInt.Ipv6 = &ves_io_schema.Ipv6SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Prefix = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

												}
											}

										}

										if v, ok := staticRouteListMapStrToI["simple_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_SimpleStaticRoute{}

											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											configModeChoiceInt.SimpleStaticRoute = v.(string)

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["performance_enhancement_mode"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					performanceEnhancementMode := &ves_io_schema_views.PerformanceEnhancementModeType{}
					siteTypeInt.IngressEgressGw.PerformanceEnhancementMode = performanceEnhancementMode
					for _, set := range sl {
						if set != nil {
							performanceEnhancementModeMapStrToI := set.(map[string]interface{})

							perfModeChoiceTypeFound := false

							if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l3_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

								perfModeChoiceTypeFound = true
								perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL3Enhanced{}
								perfModeChoiceInt.PerfModeL3Enhanced = &ves_io_schema_views.L3PerformanceEnhancementType{}
								performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										perfModeChoiceTypeFound := false

										if v, ok := cs["jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

											perfModeChoiceTypeFound = true

											if v.(bool) {
												perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_Jumbo{}
												perfModeChoiceIntNew.Jumbo = &ves_io_schema.Empty{}
												perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
											}

										}

										if v, ok := cs["no_jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

											perfModeChoiceTypeFound = true

											if v.(bool) {
												perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_NoJumbo{}
												perfModeChoiceIntNew.NoJumbo = &ves_io_schema.Empty{}
												perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
											}

										}

									}
								}

							}

							if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l7_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

								perfModeChoiceTypeFound = true

								if v.(bool) {
									perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL7Enhanced{}
									perfModeChoiceInt.PerfModeL7Enhanced = &ves_io_schema.Empty{}
									performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt
								}

							}

						}
					}

				}

				siteMeshGroupChoiceTypeFound := false

				if v, ok := cs["sm_connection_public_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

					siteMeshGroupChoiceTypeFound = true

					if v.(bool) {
						siteMeshGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwType_SmConnectionPublicIp{}
						siteMeshGroupChoiceInt.SmConnectionPublicIp = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGw.SiteMeshGroupChoice = siteMeshGroupChoiceInt
					}

				}

				if v, ok := cs["sm_connection_pvt_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

					siteMeshGroupChoiceTypeFound = true

					if v.(bool) {
						siteMeshGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwType_SmConnectionPvtIp{}
						siteMeshGroupChoiceInt.SmConnectionPvtIp = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGw.SiteMeshGroupChoice = siteMeshGroupChoiceInt
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("ingress_egress_gw_ar"); ok && !isIntfNil(v) && !siteTypeTypeFound {

		siteTypeTypeFound = true
		siteTypeInt := &ves_io_schema_views_azure_vnet_site.CreateSpecType_IngressEgressGwAr{}
		siteTypeInt.IngressEgressGwAr = &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARType{}
		createSpec.SiteType = siteTypeInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["accelerated_networking"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					acceleratedNetworking := &ves_io_schema_views.AcceleratedNetworkingType{}
					siteTypeInt.IngressEgressGwAr.AcceleratedNetworking = acceleratedNetworking
					for _, set := range sl {
						if set != nil {
							acceleratedNetworkingMapStrToI := set.(map[string]interface{})

							acceleratedNetworkingTypeFound := false

							if v, ok := acceleratedNetworkingMapStrToI["disable"]; ok && !isIntfNil(v) && !acceleratedNetworkingTypeFound {

								acceleratedNetworkingTypeFound = true

								if v.(bool) {
									acceleratedNetworkingInt := &ves_io_schema_views.AcceleratedNetworkingType_Disable{}
									acceleratedNetworkingInt.Disable = &ves_io_schema.Empty{}
									acceleratedNetworking.AcceleratedNetworking = acceleratedNetworkingInt
								}

							}

							if v, ok := acceleratedNetworkingMapStrToI["enable"]; ok && !isIntfNil(v) && !acceleratedNetworkingTypeFound {

								acceleratedNetworkingTypeFound = true

								if v.(bool) {
									acceleratedNetworkingInt := &ves_io_schema_views.AcceleratedNetworkingType_Enable{}
									acceleratedNetworkingInt.Enable = &ves_io_schema.Empty{}
									acceleratedNetworking.AcceleratedNetworking = acceleratedNetworkingInt
								}

							}

						}
					}

				}

				if v, ok := cs["azure_certified_hw"]; ok && !isIntfNil(v) {

					siteTypeInt.IngressEgressGwAr.AzureCertifiedHw = v.(string)

				}

				dcClusterGroupChoiceTypeFound := false

				if v, ok := cs["dc_cluster_group_inside_vn"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

					dcClusterGroupChoiceTypeFound = true
					dcClusterGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARType_DcClusterGroupInsideVn{}
					dcClusterGroupChoiceInt.DcClusterGroupInsideVn = &ves_io_schema_views.ObjectRefType{}
					siteTypeInt.IngressEgressGwAr.DcClusterGroupChoice = dcClusterGroupChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupInsideVn.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupInsideVn.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupInsideVn.Tenant = v.(string)

							}

						}
					}

				}

				if v, ok := cs["dc_cluster_group_outside_vn"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

					dcClusterGroupChoiceTypeFound = true
					dcClusterGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARType_DcClusterGroupOutsideVn{}
					dcClusterGroupChoiceInt.DcClusterGroupOutsideVn = &ves_io_schema_views.ObjectRefType{}
					siteTypeInt.IngressEgressGwAr.DcClusterGroupChoice = dcClusterGroupChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupOutsideVn.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupOutsideVn.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupOutsideVn.Tenant = v.(string)

							}

						}
					}

				}

				if v, ok := cs["no_dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

					dcClusterGroupChoiceTypeFound = true

					if v.(bool) {
						dcClusterGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARType_NoDcClusterGroup{}
						dcClusterGroupChoiceInt.NoDcClusterGroup = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGwAr.DcClusterGroupChoice = dcClusterGroupChoiceInt
					}

				}

				forwardProxyChoiceTypeFound := false

				if v, ok := cs["active_forward_proxy_policies"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true
					forwardProxyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARType_ActiveForwardProxyPolicies{}
					forwardProxyChoiceInt.ActiveForwardProxyPolicies = &ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType{}
					siteTypeInt.IngressEgressGwAr.ForwardProxyChoice = forwardProxyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["forward_proxy_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								forwardProxyPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								forwardProxyChoiceInt.ActiveForwardProxyPolicies.ForwardProxyPolicies = forwardProxyPoliciesInt
								for i, ps := range sl {

									fppMapToStrVal := ps.(map[string]interface{})
									forwardProxyPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := fppMapToStrVal["name"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Name = v.(string)
									}

									if v, ok := fppMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := fppMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["forward_proxy_allow_all"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true

					if v.(bool) {
						forwardProxyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARType_ForwardProxyAllowAll{}
						forwardProxyChoiceInt.ForwardProxyAllowAll = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGwAr.ForwardProxyChoice = forwardProxyChoiceInt
					}

				}

				if v, ok := cs["no_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true

					if v.(bool) {
						forwardProxyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARType_NoForwardProxy{}
						forwardProxyChoiceInt.NoForwardProxy = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGwAr.ForwardProxyChoice = forwardProxyChoiceInt
					}

				}

				globalNetworkChoiceTypeFound := false

				if v, ok := cs["global_network_list"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

					globalNetworkChoiceTypeFound = true
					globalNetworkChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARType_GlobalNetworkList{}
					globalNetworkChoiceInt.GlobalNetworkList = &ves_io_schema_views.GlobalNetworkConnectionListType{}
					siteTypeInt.IngressEgressGwAr.GlobalNetworkChoice = globalNetworkChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["global_network_connections"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								globalNetworkConnections := make([]*ves_io_schema_views.GlobalNetworkConnectionType, len(sl))
								globalNetworkChoiceInt.GlobalNetworkList.GlobalNetworkConnections = globalNetworkConnections
								for i, set := range sl {
									if set != nil {
										globalNetworkConnections[i] = &ves_io_schema_views.GlobalNetworkConnectionType{}
										globalNetworkConnectionsMapStrToI := set.(map[string]interface{})

										connectionChoiceTypeFound := false

										if v, ok := globalNetworkConnectionsMapStrToI["sli_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

											connectionChoiceTypeFound = true
											connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SliToGlobalDr{}
											connectionChoiceInt.SliToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
											globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														globalVn := &ves_io_schema_views.ObjectRefType{}
														connectionChoiceInt.SliToGlobalDr.GlobalVn = globalVn
														for _, set := range sl {
															if set != nil {
																globalVnMapStrToI := set.(map[string]interface{})

																if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
																	globalVn.Name = w.(string)
																}

																if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
																	globalVn.Namespace = w.(string)
																}

																if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
																	globalVn.Tenant = w.(string)
																}

															}
														}

													}

												}
											}

										}

										if v, ok := globalNetworkConnectionsMapStrToI["slo_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

											connectionChoiceTypeFound = true
											connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SloToGlobalDr{}
											connectionChoiceInt.SloToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
											globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														globalVn := &ves_io_schema_views.ObjectRefType{}
														connectionChoiceInt.SloToGlobalDr.GlobalVn = globalVn
														for _, set := range sl {
															if set != nil {
																globalVnMapStrToI := set.(map[string]interface{})

																if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
																	globalVn.Name = w.(string)
																}

																if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
																	globalVn.Namespace = w.(string)
																}

																if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
																	globalVn.Tenant = w.(string)
																}

															}
														}

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["no_global_network"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

					globalNetworkChoiceTypeFound = true

					if v.(bool) {
						globalNetworkChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARType_NoGlobalNetwork{}
						globalNetworkChoiceInt.NoGlobalNetwork = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGwAr.GlobalNetworkChoice = globalNetworkChoiceInt
					}

				}

				hubChoiceTypeFound := false

				if v, ok := cs["hub"]; ok && !isIntfNil(v) && !hubChoiceTypeFound {

					hubChoiceTypeFound = true
					hubChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARType_Hub{}
					hubChoiceInt.Hub = &ves_io_schema_views_azure_vnet_site.AzureHubVnetType{}
					siteTypeInt.IngressEgressGwAr.HubChoice = hubChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							expressRouteChoiceTypeFound := false

							if v, ok := cs["express_route_disabled"]; ok && !isIntfNil(v) && !expressRouteChoiceTypeFound {

								expressRouteChoiceTypeFound = true

								if v.(bool) {
									expressRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureHubVnetType_ExpressRouteDisabled{}
									expressRouteChoiceInt.ExpressRouteDisabled = &ves_io_schema.Empty{}
									hubChoiceInt.Hub.ExpressRouteChoice = expressRouteChoiceInt
								}

							}

							if v, ok := cs["express_route_enabled"]; ok && !isIntfNil(v) && !expressRouteChoiceTypeFound {

								expressRouteChoiceTypeFound = true
								expressRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureHubVnetType_ExpressRouteEnabled{}
								expressRouteChoiceInt.ExpressRouteEnabled = &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType{}
								hubChoiceInt.Hub.ExpressRouteChoice = expressRouteChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										asnChoiceTypeFound := false

										if v, ok := cs["auto_asn"]; ok && !isIntfNil(v) && !asnChoiceTypeFound {

											asnChoiceTypeFound = true

											if v.(bool) {
												asnChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_AutoAsn{}
												asnChoiceInt.AutoAsn = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.AsnChoice = asnChoiceInt
											}

										}

										if v, ok := cs["custom_asn"]; ok && !isIntfNil(v) && !asnChoiceTypeFound {

											asnChoiceTypeFound = true
											asnChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_CustomAsn{}

											expressRouteChoiceInt.ExpressRouteEnabled.AsnChoice = asnChoiceInt

											asnChoiceInt.CustomAsn = uint32(v.(int))

										}

										if v, ok := cs["connections"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											connections := make([]*ves_io_schema_views_azure_vnet_site.ExpressRouteConnectionType, len(sl))
											expressRouteChoiceInt.ExpressRouteEnabled.Connections = connections
											for i, set := range sl {
												if set != nil {
													connections[i] = &ves_io_schema_views_azure_vnet_site.ExpressRouteConnectionType{}
													connectionsMapStrToI := set.(map[string]interface{})

													if v, ok := connectionsMapStrToI["metadata"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														metadata := &ves_io_schema.MessageMetaType{}
														connections[i].Metadata = metadata
														for _, set := range sl {
															if set != nil {
																metadataMapStrToI := set.(map[string]interface{})

																if w, ok := metadataMapStrToI["description"]; ok && !isIntfNil(w) {
																	metadata.Description = w.(string)
																}

																if w, ok := metadataMapStrToI["name"]; ok && !isIntfNil(w) {
																	metadata.Name = w.(string)
																}

															}
														}

													}

													subscriptionChoiceTypeFound := false

													if v, ok := connectionsMapStrToI["circuit_id"]; ok && !isIntfNil(v) && !subscriptionChoiceTypeFound {

														subscriptionChoiceTypeFound = true
														subscriptionChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConnectionType_CircuitId{}

														connections[i].SubscriptionChoice = subscriptionChoiceInt

														subscriptionChoiceInt.CircuitId = v.(string)

													}

													if v, ok := connectionsMapStrToI["other_subscription"]; ok && !isIntfNil(v) && !subscriptionChoiceTypeFound {

														subscriptionChoiceTypeFound = true
														subscriptionChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConnectionType_OtherSubscription{}
														subscriptionChoiceInt.OtherSubscription = &ves_io_schema_views_azure_vnet_site.ExpressRouteOtherSubscriptionConnection{}
														connections[i].SubscriptionChoice = subscriptionChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["authorized_key"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	authorizedKey := &ves_io_schema.SecretType{}
																	subscriptionChoiceInt.OtherSubscription.AuthorizedKey = authorizedKey
																	for _, set := range sl {
																		if set != nil {
																			authorizedKeyMapStrToI := set.(map[string]interface{})

																			secretInfoOneofTypeFound := false

																			if v, ok := authorizedKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																				secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																				authorizedKey.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																						}

																						if v, ok := cs["location"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																						}

																						if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := authorizedKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																				secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																				authorizedKey.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																						}

																						if v, ok := cs["url"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["circuit_id"]; ok && !isIntfNil(v) {

																	subscriptionChoiceInt.OtherSubscription.CircuitId = v.(string)

																}

															}
														}

													}

													if w, ok := connectionsMapStrToI["weight"]; ok && !isIntfNil(w) {
														connections[i].Weight = uint32(w.(int))
													}

												}
											}

										}

										connectivityOptionsTypeFound := false

										if v, ok := cs["site_registration_over_express_route"]; ok && !isIntfNil(v) && !connectivityOptionsTypeFound {

											connectivityOptionsTypeFound = true
											connectivityOptionsInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_SiteRegistrationOverExpressRoute{}
											connectivityOptionsInt.SiteRegistrationOverExpressRoute = &ves_io_schema_views.CloudLinkADNType{}
											expressRouteChoiceInt.ExpressRouteEnabled.ConnectivityOptions = connectivityOptionsInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["cloudlink_network_name"]; ok && !isIntfNil(v) {

														connectivityOptionsInt.SiteRegistrationOverExpressRoute.CloudlinkNetworkName = v.(string)

													}

												}
											}

										}

										if v, ok := cs["site_registration_over_internet"]; ok && !isIntfNil(v) && !connectivityOptionsTypeFound {

											connectivityOptionsTypeFound = true

											if v.(bool) {
												connectivityOptionsInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_SiteRegistrationOverInternet{}
												connectivityOptionsInt.SiteRegistrationOverInternet = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.ConnectivityOptions = connectivityOptionsInt
											}

										}

										if v, ok := cs["gateway_subnet"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											gatewaySubnet := &ves_io_schema_views.AzureSubnetChoiceWithAutoType{}
											expressRouteChoiceInt.ExpressRouteEnabled.GatewaySubnet = gatewaySubnet
											for _, set := range sl {
												if set != nil {
													gatewaySubnetMapStrToI := set.(map[string]interface{})

													choiceTypeFound := false

													if v, ok := gatewaySubnetMapStrToI["auto"]; ok && !isIntfNil(v) && !choiceTypeFound {

														choiceTypeFound = true

														if v.(bool) {
															choiceInt := &ves_io_schema_views.AzureSubnetChoiceWithAutoType_Auto{}
															choiceInt.Auto = &ves_io_schema.Empty{}
															gatewaySubnet.Choice = choiceInt
														}

													}

													if v, ok := gatewaySubnetMapStrToI["subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

														choiceTypeFound = true
														choiceInt := &ves_io_schema_views.AzureSubnetChoiceWithAutoType_Subnet{}
														choiceInt.Subnet = &ves_io_schema_views.AzureSpecialSubnetType{}
														gatewaySubnet.Choice = choiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																resourceGroupChoiceTypeFound := false

																if v, ok := cs["subnet_resource_grp"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

																	resourceGroupChoiceTypeFound = true
																	resourceGroupChoiceInt := &ves_io_schema_views.AzureSpecialSubnetType_SubnetResourceGrp{}

																	choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt

																	resourceGroupChoiceInt.SubnetResourceGrp = v.(string)

																}

																if v, ok := cs["vnet_resource_group"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

																	resourceGroupChoiceTypeFound = true

																	if v.(bool) {
																		resourceGroupChoiceInt := &ves_io_schema_views.AzureSpecialSubnetType_VnetResourceGroup{}
																		resourceGroupChoiceInt.VnetResourceGroup = &ves_io_schema.Empty{}
																		choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt
																	}

																}

															}
														}

													}

													if v, ok := gatewaySubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

														choiceTypeFound = true
														choiceInt := &ves_io_schema_views.AzureSubnetChoiceWithAutoType_SubnetParam{}
														choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
														gatewaySubnet.Choice = choiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

																	choiceInt.SubnetParam.Ipv4 = v.(string)

																}

																if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

																	choiceInt.SubnetParam.Ipv6 = v.(string)

																}

															}
														}

													}

												}
											}

										}

										if v, ok := cs["route_server_subnet"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											routeServerSubnet := &ves_io_schema_views.AzureSubnetChoiceWithAutoType{}
											expressRouteChoiceInt.ExpressRouteEnabled.RouteServerSubnet = routeServerSubnet
											for _, set := range sl {
												if set != nil {
													routeServerSubnetMapStrToI := set.(map[string]interface{})

													choiceTypeFound := false

													if v, ok := routeServerSubnetMapStrToI["auto"]; ok && !isIntfNil(v) && !choiceTypeFound {

														choiceTypeFound = true

														if v.(bool) {
															choiceInt := &ves_io_schema_views.AzureSubnetChoiceWithAutoType_Auto{}
															choiceInt.Auto = &ves_io_schema.Empty{}
															routeServerSubnet.Choice = choiceInt
														}

													}

													if v, ok := routeServerSubnetMapStrToI["subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

														choiceTypeFound = true
														choiceInt := &ves_io_schema_views.AzureSubnetChoiceWithAutoType_Subnet{}
														choiceInt.Subnet = &ves_io_schema_views.AzureSpecialSubnetType{}
														routeServerSubnet.Choice = choiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																resourceGroupChoiceTypeFound := false

																if v, ok := cs["subnet_resource_grp"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

																	resourceGroupChoiceTypeFound = true
																	resourceGroupChoiceInt := &ves_io_schema_views.AzureSpecialSubnetType_SubnetResourceGrp{}

																	choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt

																	resourceGroupChoiceInt.SubnetResourceGrp = v.(string)

																}

																if v, ok := cs["vnet_resource_group"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

																	resourceGroupChoiceTypeFound = true

																	if v.(bool) {
																		resourceGroupChoiceInt := &ves_io_schema_views.AzureSpecialSubnetType_VnetResourceGroup{}
																		resourceGroupChoiceInt.VnetResourceGroup = &ves_io_schema.Empty{}
																		choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt
																	}

																}

															}
														}

													}

													if v, ok := routeServerSubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

														choiceTypeFound = true
														choiceInt := &ves_io_schema_views.AzureSubnetChoiceWithAutoType_SubnetParam{}
														choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
														routeServerSubnet.Choice = choiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

																	choiceInt.SubnetParam.Ipv4 = v.(string)

																}

																if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

																	choiceInt.SubnetParam.Ipv6 = v.(string)

																}

															}
														}

													}

												}
											}

										}

										skuChoiceTypeFound := false

										if v, ok := cs["sku_ergw1az"]; ok && !isIntfNil(v) && !skuChoiceTypeFound {

											skuChoiceTypeFound = true

											if v.(bool) {
												skuChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_SkuErgw1Az{}
												skuChoiceInt.SkuErgw1Az = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.SkuChoice = skuChoiceInt
											}

										}

										if v, ok := cs["sku_ergw2az"]; ok && !isIntfNil(v) && !skuChoiceTypeFound {

											skuChoiceTypeFound = true

											if v.(bool) {
												skuChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_SkuErgw2Az{}
												skuChoiceInt.SkuErgw2Az = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.SkuChoice = skuChoiceInt
											}

										}

										if v, ok := cs["sku_high_perf"]; ok && !isIntfNil(v) && !skuChoiceTypeFound {

											skuChoiceTypeFound = true

											if v.(bool) {
												skuChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_SkuHighPerf{}
												skuChoiceInt.SkuHighPerf = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.SkuChoice = skuChoiceInt
											}

										}

										if v, ok := cs["sku_standard"]; ok && !isIntfNil(v) && !skuChoiceTypeFound {

											skuChoiceTypeFound = true

											if v.(bool) {
												skuChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_SkuStandard{}
												skuChoiceInt.SkuStandard = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.SkuChoice = skuChoiceInt
											}

										}

										spokeVnetRoutesTypeFound := false

										if v, ok := cs["advertise_to_route_server"]; ok && !isIntfNil(v) && !spokeVnetRoutesTypeFound {

											spokeVnetRoutesTypeFound = true

											if v.(bool) {
												spokeVnetRoutesInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_AdvertiseToRouteServer{}
												spokeVnetRoutesInt.AdvertiseToRouteServer = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.SpokeVnetRoutes = spokeVnetRoutesInt
											}

										}

										if v, ok := cs["do_not_advertise_to_route_server"]; ok && !isIntfNil(v) && !spokeVnetRoutesTypeFound {

											spokeVnetRoutesTypeFound = true

											if v.(bool) {
												spokeVnetRoutesInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_DoNotAdvertiseToRouteServer{}
												spokeVnetRoutesInt.DoNotAdvertiseToRouteServer = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.SpokeVnetRoutes = spokeVnetRoutesInt
											}

										}

									}
								}

							}

							if v, ok := cs["spoke_vnets"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								spokeVnets := make([]*ves_io_schema_views_azure_vnet_site.VnetPeeringType, len(sl))
								hubChoiceInt.Hub.SpokeVnets = spokeVnets
								for i, set := range sl {
									if set != nil {
										spokeVnets[i] = &ves_io_schema_views_azure_vnet_site.VnetPeeringType{}
										spokeVnetsMapStrToI := set.(map[string]interface{})

										if w, ok := spokeVnetsMapStrToI["labels"]; ok && !isIntfNil(w) {
											ms := map[string]string{}
											for k, v := range w.(map[string]interface{}) {
												ms[k] = v.(string)
											}
											spokeVnets[i].Labels = ms
										}

										routingChoiceTypeFound := false

										if v, ok := spokeVnetsMapStrToI["auto"]; ok && !isIntfNil(v) && !routingChoiceTypeFound {

											routingChoiceTypeFound = true

											if v.(bool) {
												routingChoiceInt := &ves_io_schema_views_azure_vnet_site.VnetPeeringType_Auto{}
												routingChoiceInt.Auto = &ves_io_schema.Empty{}
												spokeVnets[i].RoutingChoice = routingChoiceInt
											}

										}

										if v, ok := spokeVnetsMapStrToI["manual"]; ok && !isIntfNil(v) && !routingChoiceTypeFound {

											routingChoiceTypeFound = true

											if v.(bool) {
												routingChoiceInt := &ves_io_schema_views_azure_vnet_site.VnetPeeringType_Manual{}
												routingChoiceInt.Manual = &ves_io_schema.Empty{}
												spokeVnets[i].RoutingChoice = routingChoiceInt
											}

										}

										if v, ok := spokeVnetsMapStrToI["vnet"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											vnet := &ves_io_schema_views.AzureVnetType{}
											spokeVnets[i].Vnet = vnet
											for _, set := range sl {
												if set != nil {
													vnetMapStrToI := set.(map[string]interface{})

													if w, ok := vnetMapStrToI["resource_group"]; ok && !isIntfNil(w) {
														vnet.ResourceGroup = w.(string)
													}

													routingTypeTypeFound := false

													if v, ok := vnetMapStrToI["f5_orchestrated_routing"]; ok && !isIntfNil(v) && !routingTypeTypeFound {

														routingTypeTypeFound = true

														if v.(bool) {
															routingTypeInt := &ves_io_schema_views.AzureVnetType_F5OrchestratedRouting{}
															routingTypeInt.F5OrchestratedRouting = &ves_io_schema.Empty{}
															vnet.RoutingType = routingTypeInt
														}

													}

													if v, ok := vnetMapStrToI["manual_routing"]; ok && !isIntfNil(v) && !routingTypeTypeFound {

														routingTypeTypeFound = true

														if v.(bool) {
															routingTypeInt := &ves_io_schema_views.AzureVnetType_ManualRouting{}
															routingTypeInt.ManualRouting = &ves_io_schema.Empty{}
															vnet.RoutingType = routingTypeInt
														}

													}

													if w, ok := vnetMapStrToI["vnet_name"]; ok && !isIntfNil(w) {
														vnet.VnetName = w.(string)
													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["not_hub"]; ok && !isIntfNil(v) && !hubChoiceTypeFound {

					hubChoiceTypeFound = true

					if v.(bool) {
						hubChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARType_NotHub{}
						hubChoiceInt.NotHub = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGwAr.HubChoice = hubChoiceInt
					}

				}

				insideStaticRouteChoiceTypeFound := false

				if v, ok := cs["inside_static_routes"]; ok && !isIntfNil(v) && !insideStaticRouteChoiceTypeFound {

					insideStaticRouteChoiceTypeFound = true
					insideStaticRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARType_InsideStaticRoutes{}
					insideStaticRouteChoiceInt.InsideStaticRoutes = &ves_io_schema_views.SiteStaticRoutesListType{}
					siteTypeInt.IngressEgressGwAr.InsideStaticRouteChoice = insideStaticRouteChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_route_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRouteList := make([]*ves_io_schema_views.SiteStaticRoutesType, len(sl))
								insideStaticRouteChoiceInt.InsideStaticRoutes.StaticRouteList = staticRouteList
								for i, set := range sl {
									if set != nil {
										staticRouteList[i] = &ves_io_schema_views.SiteStaticRoutesType{}
										staticRouteListMapStrToI := set.(map[string]interface{})

										configModeChoiceTypeFound := false

										if v, ok := staticRouteListMapStrToI["custom_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_CustomStaticRoute{}
											configModeChoiceInt.CustomStaticRoute = &ves_io_schema.StaticRouteType{}
											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["attrs"]; ok && !isIntfNil(v) {

														attrsList := []ves_io_schema.RouteAttrType{}
														for _, j := range v.([]interface{}) {
															if j == nil {
																return fmt.Errorf("please provide valid non-empty enum value of field attrs")
															}
															attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
														}
														configModeChoiceInt.CustomStaticRoute.Attrs = attrsList

													}

													if v, ok := cs["labels"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														configModeChoiceInt.CustomStaticRoute.Labels = ms
													}

													if v, ok := cs["nexthop"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														nexthop := &ves_io_schema.NextHopType{}
														configModeChoiceInt.CustomStaticRoute.Nexthop = nexthop
														for _, set := range sl {
															if set != nil {
																nexthopMapStrToI := set.(map[string]interface{})

																if v, ok := nexthopMapStrToI["interface"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	intfInt := make([]*ves_io_schema.ObjectRefType, len(sl))
																	nexthop.Interface = intfInt
																	for i, ps := range sl {

																		iMapToStrVal := ps.(map[string]interface{})
																		intfInt[i] = &ves_io_schema.ObjectRefType{}

																		intfInt[i].Kind = "network_interface"

																		if v, ok := iMapToStrVal["name"]; ok && !isIntfNil(v) {
																			intfInt[i].Name = v.(string)
																		}

																		if v, ok := iMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																			intfInt[i].Namespace = v.(string)
																		}

																		if v, ok := iMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																			intfInt[i].Tenant = v.(string)
																		}

																		if v, ok := iMapToStrVal["uid"]; ok && !isIntfNil(v) {
																			intfInt[i].Uid = v.(string)
																		}

																	}

																}

																if v, ok := nexthopMapStrToI["nexthop_address"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	nexthopAddress := &ves_io_schema.IpAddressType{}
																	nexthop.NexthopAddress = nexthopAddress
																	for _, set := range sl {
																		if set != nil {
																			nexthopAddressMapStrToI := set.(map[string]interface{})

																			verTypeFound := false

																			if v, ok := nexthopAddressMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv4{}
																				verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv4.Addr = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := nexthopAddressMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv6{}
																				verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv6.Addr = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := nexthopMapStrToI["type"]; ok && !isIntfNil(v) {

																	nexthop.Type = ves_io_schema.NextHopTypes(ves_io_schema.NextHopTypes_value[v.(string)])

																}

															}
														}

													}

													if v, ok := cs["subnets"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														subnets := make([]*ves_io_schema.IpSubnetType, len(sl))
														configModeChoiceInt.CustomStaticRoute.Subnets = subnets
														for i, set := range sl {
															if set != nil {
																subnets[i] = &ves_io_schema.IpSubnetType{}
																subnetsMapStrToI := set.(map[string]interface{})

																verTypeFound := false

																if v, ok := subnetsMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv4{}
																	verInt.Ipv4 = &ves_io_schema.Ipv4SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Prefix = v.(string)

																			}

																		}
																	}

																}

																if v, ok := subnetsMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv6{}
																	verInt.Ipv6 = &ves_io_schema.Ipv6SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Prefix = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

												}
											}

										}

										if v, ok := staticRouteListMapStrToI["simple_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_SimpleStaticRoute{}

											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											configModeChoiceInt.SimpleStaticRoute = v.(string)

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["no_inside_static_routes"]; ok && !isIntfNil(v) && !insideStaticRouteChoiceTypeFound {

					insideStaticRouteChoiceTypeFound = true

					if v.(bool) {
						insideStaticRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARType_NoInsideStaticRoutes{}
						insideStaticRouteChoiceInt.NoInsideStaticRoutes = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGwAr.InsideStaticRouteChoice = insideStaticRouteChoiceInt
					}

				}

				networkPolicyChoiceTypeFound := false

				if v, ok := cs["active_enhanced_firewall_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true
					networkPolicyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARType_ActiveEnhancedFirewallPolicies{}
					networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies = &ves_io_schema_network_firewall.ActiveEnhancedFirewallPoliciesType{}
					siteTypeInt.IngressEgressGwAr.NetworkPolicyChoice = networkPolicyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["enhanced_firewall_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								enhancedFirewallPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies.EnhancedFirewallPolicies = enhancedFirewallPoliciesInt
								for i, ps := range sl {

									efpMapToStrVal := ps.(map[string]interface{})
									enhancedFirewallPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := efpMapToStrVal["name"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Name = v.(string)
									}

									if v, ok := efpMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := efpMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["active_network_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true
					networkPolicyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARType_ActiveNetworkPolicies{}
					networkPolicyChoiceInt.ActiveNetworkPolicies = &ves_io_schema_network_firewall.ActiveNetworkPoliciesType{}
					siteTypeInt.IngressEgressGwAr.NetworkPolicyChoice = networkPolicyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["network_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								networkPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								networkPolicyChoiceInt.ActiveNetworkPolicies.NetworkPolicies = networkPoliciesInt
								for i, ps := range sl {

									npMapToStrVal := ps.(map[string]interface{})
									networkPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := npMapToStrVal["name"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Name = v.(string)
									}

									if v, ok := npMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := npMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["no_network_policy"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true

					if v.(bool) {
						networkPolicyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARType_NoNetworkPolicy{}
						networkPolicyChoiceInt.NoNetworkPolicy = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGwAr.NetworkPolicyChoice = networkPolicyChoiceInt
					}

				}

				if v, ok := cs["node"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					node := &ves_io_schema_views.AzureVnetTwoInterfaceNodeARType{}
					siteTypeInt.IngressEgressGwAr.Node = node
					for _, set := range sl {
						if set != nil {
							nodeMapStrToI := set.(map[string]interface{})

							if w, ok := nodeMapStrToI["fault_domain"]; ok && !isIntfNil(w) {
								node.FaultDomain = uint32(w.(int))
							}

							if v, ok := nodeMapStrToI["inside_subnet"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								insideSubnet := &ves_io_schema_views.AzureSubnetChoiceType{}
								node.InsideSubnet = insideSubnet
								for _, set := range sl {
									if set != nil {
										insideSubnetMapStrToI := set.(map[string]interface{})

										choiceTypeFound := false

										if v, ok := insideSubnetMapStrToI["subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_Subnet{}
											choiceInt.Subnet = &ves_io_schema_views.AzureSubnetType{}
											insideSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													resourceGroupChoiceTypeFound := false

													if v, ok := cs["subnet_resource_grp"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true
														resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_SubnetResourceGrp{}

														choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt

														resourceGroupChoiceInt.SubnetResourceGrp = v.(string)

													}

													if v, ok := cs["vnet_resource_group"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true

														if v.(bool) {
															resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_VnetResourceGroup{}
															resourceGroupChoiceInt.VnetResourceGroup = &ves_io_schema.Empty{}
															choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt
														}

													}

													if v, ok := cs["subnet_name"]; ok && !isIntfNil(v) {

														choiceInt.Subnet.SubnetName = v.(string)

													}

												}
											}

										}

										if v, ok := insideSubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_SubnetParam{}
											choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
											insideSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv4 = v.(string)

													}

													if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv6 = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if w, ok := nodeMapStrToI["node_number"]; ok && !isIntfNil(w) {
								node.NodeNumber = uint32(w.(int))
							}

							if v, ok := nodeMapStrToI["outside_subnet"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								outsideSubnet := &ves_io_schema_views.AzureSubnetChoiceType{}
								node.OutsideSubnet = outsideSubnet
								for _, set := range sl {
									if set != nil {
										outsideSubnetMapStrToI := set.(map[string]interface{})

										choiceTypeFound := false

										if v, ok := outsideSubnetMapStrToI["subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_Subnet{}
											choiceInt.Subnet = &ves_io_schema_views.AzureSubnetType{}
											outsideSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													resourceGroupChoiceTypeFound := false

													if v, ok := cs["subnet_resource_grp"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true
														resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_SubnetResourceGrp{}

														choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt

														resourceGroupChoiceInt.SubnetResourceGrp = v.(string)

													}

													if v, ok := cs["vnet_resource_group"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true

														if v.(bool) {
															resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_VnetResourceGroup{}
															resourceGroupChoiceInt.VnetResourceGroup = &ves_io_schema.Empty{}
															choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt
														}

													}

													if v, ok := cs["subnet_name"]; ok && !isIntfNil(v) {

														choiceInt.Subnet.SubnetName = v.(string)

													}

												}
											}

										}

										if v, ok := outsideSubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_SubnetParam{}
											choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
											outsideSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv4 = v.(string)

													}

													if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv6 = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if w, ok := nodeMapStrToI["update_domain"]; ok && !isIntfNil(w) {
								node.UpdateDomain = uint32(w.(int))
							}

						}
					}

				}

				outsideStaticRouteChoiceTypeFound := false

				if v, ok := cs["no_outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

					outsideStaticRouteChoiceTypeFound = true

					if v.(bool) {
						outsideStaticRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARType_NoOutsideStaticRoutes{}
						outsideStaticRouteChoiceInt.NoOutsideStaticRoutes = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGwAr.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt
					}

				}

				if v, ok := cs["outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

					outsideStaticRouteChoiceTypeFound = true
					outsideStaticRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARType_OutsideStaticRoutes{}
					outsideStaticRouteChoiceInt.OutsideStaticRoutes = &ves_io_schema_views.SiteStaticRoutesListType{}
					siteTypeInt.IngressEgressGwAr.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_route_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRouteList := make([]*ves_io_schema_views.SiteStaticRoutesType, len(sl))
								outsideStaticRouteChoiceInt.OutsideStaticRoutes.StaticRouteList = staticRouteList
								for i, set := range sl {
									if set != nil {
										staticRouteList[i] = &ves_io_schema_views.SiteStaticRoutesType{}
										staticRouteListMapStrToI := set.(map[string]interface{})

										configModeChoiceTypeFound := false

										if v, ok := staticRouteListMapStrToI["custom_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_CustomStaticRoute{}
											configModeChoiceInt.CustomStaticRoute = &ves_io_schema.StaticRouteType{}
											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["attrs"]; ok && !isIntfNil(v) {

														attrsList := []ves_io_schema.RouteAttrType{}
														for _, j := range v.([]interface{}) {
															if j == nil {
																return fmt.Errorf("please provide valid non-empty enum value of field attrs")
															}
															attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
														}
														configModeChoiceInt.CustomStaticRoute.Attrs = attrsList

													}

													if v, ok := cs["labels"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														configModeChoiceInt.CustomStaticRoute.Labels = ms
													}

													if v, ok := cs["nexthop"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														nexthop := &ves_io_schema.NextHopType{}
														configModeChoiceInt.CustomStaticRoute.Nexthop = nexthop
														for _, set := range sl {
															if set != nil {
																nexthopMapStrToI := set.(map[string]interface{})

																if v, ok := nexthopMapStrToI["interface"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	intfInt := make([]*ves_io_schema.ObjectRefType, len(sl))
																	nexthop.Interface = intfInt
																	for i, ps := range sl {

																		iMapToStrVal := ps.(map[string]interface{})
																		intfInt[i] = &ves_io_schema.ObjectRefType{}

																		intfInt[i].Kind = "network_interface"

																		if v, ok := iMapToStrVal["name"]; ok && !isIntfNil(v) {
																			intfInt[i].Name = v.(string)
																		}

																		if v, ok := iMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																			intfInt[i].Namespace = v.(string)
																		}

																		if v, ok := iMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																			intfInt[i].Tenant = v.(string)
																		}

																		if v, ok := iMapToStrVal["uid"]; ok && !isIntfNil(v) {
																			intfInt[i].Uid = v.(string)
																		}

																	}

																}

																if v, ok := nexthopMapStrToI["nexthop_address"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	nexthopAddress := &ves_io_schema.IpAddressType{}
																	nexthop.NexthopAddress = nexthopAddress
																	for _, set := range sl {
																		if set != nil {
																			nexthopAddressMapStrToI := set.(map[string]interface{})

																			verTypeFound := false

																			if v, ok := nexthopAddressMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv4{}
																				verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv4.Addr = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := nexthopAddressMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv6{}
																				verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv6.Addr = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := nexthopMapStrToI["type"]; ok && !isIntfNil(v) {

																	nexthop.Type = ves_io_schema.NextHopTypes(ves_io_schema.NextHopTypes_value[v.(string)])

																}

															}
														}

													}

													if v, ok := cs["subnets"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														subnets := make([]*ves_io_schema.IpSubnetType, len(sl))
														configModeChoiceInt.CustomStaticRoute.Subnets = subnets
														for i, set := range sl {
															if set != nil {
																subnets[i] = &ves_io_schema.IpSubnetType{}
																subnetsMapStrToI := set.(map[string]interface{})

																verTypeFound := false

																if v, ok := subnetsMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv4{}
																	verInt.Ipv4 = &ves_io_schema.Ipv4SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Prefix = v.(string)

																			}

																		}
																	}

																}

																if v, ok := subnetsMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv6{}
																	verInt.Ipv6 = &ves_io_schema.Ipv6SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Prefix = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

												}
											}

										}

										if v, ok := staticRouteListMapStrToI["simple_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_SimpleStaticRoute{}

											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											configModeChoiceInt.SimpleStaticRoute = v.(string)

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["performance_enhancement_mode"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					performanceEnhancementMode := &ves_io_schema_views.PerformanceEnhancementModeType{}
					siteTypeInt.IngressEgressGwAr.PerformanceEnhancementMode = performanceEnhancementMode
					for _, set := range sl {
						if set != nil {
							performanceEnhancementModeMapStrToI := set.(map[string]interface{})

							perfModeChoiceTypeFound := false

							if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l3_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

								perfModeChoiceTypeFound = true
								perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL3Enhanced{}
								perfModeChoiceInt.PerfModeL3Enhanced = &ves_io_schema_views.L3PerformanceEnhancementType{}
								performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										perfModeChoiceTypeFound := false

										if v, ok := cs["jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

											perfModeChoiceTypeFound = true

											if v.(bool) {
												perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_Jumbo{}
												perfModeChoiceIntNew.Jumbo = &ves_io_schema.Empty{}
												perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
											}

										}

										if v, ok := cs["no_jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

											perfModeChoiceTypeFound = true

											if v.(bool) {
												perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_NoJumbo{}
												perfModeChoiceIntNew.NoJumbo = &ves_io_schema.Empty{}
												perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
											}

										}

									}
								}

							}

							if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l7_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

								perfModeChoiceTypeFound = true

								if v.(bool) {
									perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL7Enhanced{}
									perfModeChoiceInt.PerfModeL7Enhanced = &ves_io_schema.Empty{}
									performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt
								}

							}

						}
					}

				}

				siteMeshGroupChoiceTypeFound := false

				if v, ok := cs["sm_connection_public_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

					siteMeshGroupChoiceTypeFound = true

					if v.(bool) {
						siteMeshGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARType_SmConnectionPublicIp{}
						siteMeshGroupChoiceInt.SmConnectionPublicIp = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGwAr.SiteMeshGroupChoice = siteMeshGroupChoiceInt
					}

				}

				if v, ok := cs["sm_connection_pvt_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

					siteMeshGroupChoiceTypeFound = true

					if v.(bool) {
						siteMeshGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARType_SmConnectionPvtIp{}
						siteMeshGroupChoiceInt.SmConnectionPvtIp = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGwAr.SiteMeshGroupChoice = siteMeshGroupChoiceInt
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("ingress_gw"); ok && !isIntfNil(v) && !siteTypeTypeFound {

		siteTypeTypeFound = true
		siteTypeInt := &ves_io_schema_views_azure_vnet_site.CreateSpecType_IngressGw{}
		siteTypeInt.IngressGw = &ves_io_schema_views_azure_vnet_site.AzureVnetIngressGwType{}
		createSpec.SiteType = siteTypeInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["accelerated_networking"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					acceleratedNetworking := &ves_io_schema_views.AcceleratedNetworkingType{}
					siteTypeInt.IngressGw.AcceleratedNetworking = acceleratedNetworking
					for _, set := range sl {
						if set != nil {
							acceleratedNetworkingMapStrToI := set.(map[string]interface{})

							acceleratedNetworkingTypeFound := false

							if v, ok := acceleratedNetworkingMapStrToI["disable"]; ok && !isIntfNil(v) && !acceleratedNetworkingTypeFound {

								acceleratedNetworkingTypeFound = true

								if v.(bool) {
									acceleratedNetworkingInt := &ves_io_schema_views.AcceleratedNetworkingType_Disable{}
									acceleratedNetworkingInt.Disable = &ves_io_schema.Empty{}
									acceleratedNetworking.AcceleratedNetworking = acceleratedNetworkingInt
								}

							}

							if v, ok := acceleratedNetworkingMapStrToI["enable"]; ok && !isIntfNil(v) && !acceleratedNetworkingTypeFound {

								acceleratedNetworkingTypeFound = true

								if v.(bool) {
									acceleratedNetworkingInt := &ves_io_schema_views.AcceleratedNetworkingType_Enable{}
									acceleratedNetworkingInt.Enable = &ves_io_schema.Empty{}
									acceleratedNetworking.AcceleratedNetworking = acceleratedNetworkingInt
								}

							}

						}
					}

				}

				if v, ok := cs["az_nodes"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					azNodes := make([]*ves_io_schema_views.AzureVnetOneInterfaceNodeType, len(sl))
					siteTypeInt.IngressGw.AzNodes = azNodes
					for i, set := range sl {
						if set != nil {
							azNodes[i] = &ves_io_schema_views.AzureVnetOneInterfaceNodeType{}
							azNodesMapStrToI := set.(map[string]interface{})

							if w, ok := azNodesMapStrToI["azure_az"]; ok && !isIntfNil(w) {
								azNodes[i].AzureAz = w.(string)
							}

							if v, ok := azNodesMapStrToI["local_subnet"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								localSubnet := &ves_io_schema_views.AzureSubnetChoiceType{}
								azNodes[i].LocalSubnet = localSubnet
								for _, set := range sl {
									if set != nil {
										localSubnetMapStrToI := set.(map[string]interface{})

										choiceTypeFound := false

										if v, ok := localSubnetMapStrToI["subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_Subnet{}
											choiceInt.Subnet = &ves_io_schema_views.AzureSubnetType{}
											localSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													resourceGroupChoiceTypeFound := false

													if v, ok := cs["subnet_resource_grp"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true
														resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_SubnetResourceGrp{}

														choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt

														resourceGroupChoiceInt.SubnetResourceGrp = v.(string)

													}

													if v, ok := cs["vnet_resource_group"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true

														if v.(bool) {
															resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_VnetResourceGroup{}
															resourceGroupChoiceInt.VnetResourceGroup = &ves_io_schema.Empty{}
															choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt
														}

													}

													if v, ok := cs["subnet_name"]; ok && !isIntfNil(v) {

														choiceInt.Subnet.SubnetName = v.(string)

													}

												}
											}

										}

										if v, ok := localSubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_SubnetParam{}
											choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
											localSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv4 = v.(string)

													}

													if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv6 = v.(string)

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["azure_certified_hw"]; ok && !isIntfNil(v) {

					siteTypeInt.IngressGw.AzureCertifiedHw = v.(string)

				}

				if v, ok := cs["performance_enhancement_mode"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					performanceEnhancementMode := &ves_io_schema_views.PerformanceEnhancementModeType{}
					siteTypeInt.IngressGw.PerformanceEnhancementMode = performanceEnhancementMode
					for _, set := range sl {
						if set != nil {
							performanceEnhancementModeMapStrToI := set.(map[string]interface{})

							perfModeChoiceTypeFound := false

							if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l3_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

								perfModeChoiceTypeFound = true
								perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL3Enhanced{}
								perfModeChoiceInt.PerfModeL3Enhanced = &ves_io_schema_views.L3PerformanceEnhancementType{}
								performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										perfModeChoiceTypeFound := false

										if v, ok := cs["jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

											perfModeChoiceTypeFound = true

											if v.(bool) {
												perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_Jumbo{}
												perfModeChoiceIntNew.Jumbo = &ves_io_schema.Empty{}
												perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
											}

										}

										if v, ok := cs["no_jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

											perfModeChoiceTypeFound = true

											if v.(bool) {
												perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_NoJumbo{}
												perfModeChoiceIntNew.NoJumbo = &ves_io_schema.Empty{}
												perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
											}

										}

									}
								}

							}

							if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l7_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

								perfModeChoiceTypeFound = true

								if v.(bool) {
									perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL7Enhanced{}
									perfModeChoiceInt.PerfModeL7Enhanced = &ves_io_schema.Empty{}
									performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt
								}

							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("ingress_gw_ar"); ok && !isIntfNil(v) && !siteTypeTypeFound {

		siteTypeTypeFound = true
		siteTypeInt := &ves_io_schema_views_azure_vnet_site.CreateSpecType_IngressGwAr{}
		siteTypeInt.IngressGwAr = &ves_io_schema_views_azure_vnet_site.AzureVnetIngressGwARType{}
		createSpec.SiteType = siteTypeInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["accelerated_networking"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					acceleratedNetworking := &ves_io_schema_views.AcceleratedNetworkingType{}
					siteTypeInt.IngressGwAr.AcceleratedNetworking = acceleratedNetworking
					for _, set := range sl {
						if set != nil {
							acceleratedNetworkingMapStrToI := set.(map[string]interface{})

							acceleratedNetworkingTypeFound := false

							if v, ok := acceleratedNetworkingMapStrToI["disable"]; ok && !isIntfNil(v) && !acceleratedNetworkingTypeFound {

								acceleratedNetworkingTypeFound = true

								if v.(bool) {
									acceleratedNetworkingInt := &ves_io_schema_views.AcceleratedNetworkingType_Disable{}
									acceleratedNetworkingInt.Disable = &ves_io_schema.Empty{}
									acceleratedNetworking.AcceleratedNetworking = acceleratedNetworkingInt
								}

							}

							if v, ok := acceleratedNetworkingMapStrToI["enable"]; ok && !isIntfNil(v) && !acceleratedNetworkingTypeFound {

								acceleratedNetworkingTypeFound = true

								if v.(bool) {
									acceleratedNetworkingInt := &ves_io_schema_views.AcceleratedNetworkingType_Enable{}
									acceleratedNetworkingInt.Enable = &ves_io_schema.Empty{}
									acceleratedNetworking.AcceleratedNetworking = acceleratedNetworkingInt
								}

							}

						}
					}

				}

				if v, ok := cs["azure_certified_hw"]; ok && !isIntfNil(v) {

					siteTypeInt.IngressGwAr.AzureCertifiedHw = v.(string)

				}

				if v, ok := cs["node"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					node := &ves_io_schema_views.AzureVnetOneInterfaceNodeARType{}
					siteTypeInt.IngressGwAr.Node = node
					for _, set := range sl {
						if set != nil {
							nodeMapStrToI := set.(map[string]interface{})

							if w, ok := nodeMapStrToI["fault_domain"]; ok && !isIntfNil(w) {
								node.FaultDomain = uint32(w.(int))
							}

							if v, ok := nodeMapStrToI["local_subnet"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								localSubnet := &ves_io_schema_views.AzureSubnetChoiceType{}
								node.LocalSubnet = localSubnet
								for _, set := range sl {
									if set != nil {
										localSubnetMapStrToI := set.(map[string]interface{})

										choiceTypeFound := false

										if v, ok := localSubnetMapStrToI["subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_Subnet{}
											choiceInt.Subnet = &ves_io_schema_views.AzureSubnetType{}
											localSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													resourceGroupChoiceTypeFound := false

													if v, ok := cs["subnet_resource_grp"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true
														resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_SubnetResourceGrp{}

														choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt

														resourceGroupChoiceInt.SubnetResourceGrp = v.(string)

													}

													if v, ok := cs["vnet_resource_group"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true

														if v.(bool) {
															resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_VnetResourceGroup{}
															resourceGroupChoiceInt.VnetResourceGroup = &ves_io_schema.Empty{}
															choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt
														}

													}

													if v, ok := cs["subnet_name"]; ok && !isIntfNil(v) {

														choiceInt.Subnet.SubnetName = v.(string)

													}

												}
											}

										}

										if v, ok := localSubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_SubnetParam{}
											choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
											localSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv4 = v.(string)

													}

													if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv6 = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if w, ok := nodeMapStrToI["node_number"]; ok && !isIntfNil(w) {
								node.NodeNumber = uint32(w.(int))
							}

							if w, ok := nodeMapStrToI["update_domain"]; ok && !isIntfNil(w) {
								node.UpdateDomain = uint32(w.(int))
							}

						}
					}

				}

				if v, ok := cs["performance_enhancement_mode"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					performanceEnhancementMode := &ves_io_schema_views.PerformanceEnhancementModeType{}
					siteTypeInt.IngressGwAr.PerformanceEnhancementMode = performanceEnhancementMode
					for _, set := range sl {
						if set != nil {
							performanceEnhancementModeMapStrToI := set.(map[string]interface{})

							perfModeChoiceTypeFound := false

							if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l3_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

								perfModeChoiceTypeFound = true
								perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL3Enhanced{}
								perfModeChoiceInt.PerfModeL3Enhanced = &ves_io_schema_views.L3PerformanceEnhancementType{}
								performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										perfModeChoiceTypeFound := false

										if v, ok := cs["jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

											perfModeChoiceTypeFound = true

											if v.(bool) {
												perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_Jumbo{}
												perfModeChoiceIntNew.Jumbo = &ves_io_schema.Empty{}
												perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
											}

										}

										if v, ok := cs["no_jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

											perfModeChoiceTypeFound = true

											if v.(bool) {
												perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_NoJumbo{}
												perfModeChoiceIntNew.NoJumbo = &ves_io_schema.Empty{}
												perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
											}

										}

									}
								}

							}

							if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l7_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

								perfModeChoiceTypeFound = true

								if v.(bool) {
									perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL7Enhanced{}
									perfModeChoiceInt.PerfModeL7Enhanced = &ves_io_schema.Empty{}
									performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt
								}

							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("voltstack_cluster"); ok && !isIntfNil(v) && !siteTypeTypeFound {

		siteTypeTypeFound = true
		siteTypeInt := &ves_io_schema_views_azure_vnet_site.CreateSpecType_VoltstackCluster{}
		siteTypeInt.VoltstackCluster = &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterType{}
		createSpec.SiteType = siteTypeInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["accelerated_networking"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					acceleratedNetworking := &ves_io_schema_views.AcceleratedNetworkingType{}
					siteTypeInt.VoltstackCluster.AcceleratedNetworking = acceleratedNetworking
					for _, set := range sl {
						if set != nil {
							acceleratedNetworkingMapStrToI := set.(map[string]interface{})

							acceleratedNetworkingTypeFound := false

							if v, ok := acceleratedNetworkingMapStrToI["disable"]; ok && !isIntfNil(v) && !acceleratedNetworkingTypeFound {

								acceleratedNetworkingTypeFound = true

								if v.(bool) {
									acceleratedNetworkingInt := &ves_io_schema_views.AcceleratedNetworkingType_Disable{}
									acceleratedNetworkingInt.Disable = &ves_io_schema.Empty{}
									acceleratedNetworking.AcceleratedNetworking = acceleratedNetworkingInt
								}

							}

							if v, ok := acceleratedNetworkingMapStrToI["enable"]; ok && !isIntfNil(v) && !acceleratedNetworkingTypeFound {

								acceleratedNetworkingTypeFound = true

								if v.(bool) {
									acceleratedNetworkingInt := &ves_io_schema_views.AcceleratedNetworkingType_Enable{}
									acceleratedNetworkingInt.Enable = &ves_io_schema.Empty{}
									acceleratedNetworking.AcceleratedNetworking = acceleratedNetworkingInt
								}

							}

						}
					}

				}

				if v, ok := cs["az_nodes"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					azNodes := make([]*ves_io_schema_views.AzureVnetOneInterfaceNodeType, len(sl))
					siteTypeInt.VoltstackCluster.AzNodes = azNodes
					for i, set := range sl {
						if set != nil {
							azNodes[i] = &ves_io_schema_views.AzureVnetOneInterfaceNodeType{}
							azNodesMapStrToI := set.(map[string]interface{})

							if w, ok := azNodesMapStrToI["azure_az"]; ok && !isIntfNil(w) {
								azNodes[i].AzureAz = w.(string)
							}

							if v, ok := azNodesMapStrToI["local_subnet"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								localSubnet := &ves_io_schema_views.AzureSubnetChoiceType{}
								azNodes[i].LocalSubnet = localSubnet
								for _, set := range sl {
									if set != nil {
										localSubnetMapStrToI := set.(map[string]interface{})

										choiceTypeFound := false

										if v, ok := localSubnetMapStrToI["subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_Subnet{}
											choiceInt.Subnet = &ves_io_schema_views.AzureSubnetType{}
											localSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													resourceGroupChoiceTypeFound := false

													if v, ok := cs["subnet_resource_grp"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true
														resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_SubnetResourceGrp{}

														choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt

														resourceGroupChoiceInt.SubnetResourceGrp = v.(string)

													}

													if v, ok := cs["vnet_resource_group"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true

														if v.(bool) {
															resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_VnetResourceGroup{}
															resourceGroupChoiceInt.VnetResourceGroup = &ves_io_schema.Empty{}
															choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt
														}

													}

													if v, ok := cs["subnet_name"]; ok && !isIntfNil(v) {

														choiceInt.Subnet.SubnetName = v.(string)

													}

												}
											}

										}

										if v, ok := localSubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_SubnetParam{}
											choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
											localSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv4 = v.(string)

													}

													if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv6 = v.(string)

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["azure_certified_hw"]; ok && !isIntfNil(v) {

					siteTypeInt.VoltstackCluster.AzureCertifiedHw = v.(string)

				}

				dcClusterGroupChoiceTypeFound := false

				if v, ok := cs["dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

					dcClusterGroupChoiceTypeFound = true
					dcClusterGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterType_DcClusterGroup{}
					dcClusterGroupChoiceInt.DcClusterGroup = &ves_io_schema_views.ObjectRefType{}
					siteTypeInt.VoltstackCluster.DcClusterGroupChoice = dcClusterGroupChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Tenant = v.(string)

							}

						}
					}

				}

				if v, ok := cs["no_dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

					dcClusterGroupChoiceTypeFound = true

					if v.(bool) {
						dcClusterGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterType_NoDcClusterGroup{}
						dcClusterGroupChoiceInt.NoDcClusterGroup = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackCluster.DcClusterGroupChoice = dcClusterGroupChoiceInt
					}

				}

				forwardProxyChoiceTypeFound := false

				if v, ok := cs["active_forward_proxy_policies"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true
					forwardProxyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterType_ActiveForwardProxyPolicies{}
					forwardProxyChoiceInt.ActiveForwardProxyPolicies = &ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType{}
					siteTypeInt.VoltstackCluster.ForwardProxyChoice = forwardProxyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["forward_proxy_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								forwardProxyPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								forwardProxyChoiceInt.ActiveForwardProxyPolicies.ForwardProxyPolicies = forwardProxyPoliciesInt
								for i, ps := range sl {

									fppMapToStrVal := ps.(map[string]interface{})
									forwardProxyPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := fppMapToStrVal["name"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Name = v.(string)
									}

									if v, ok := fppMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := fppMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["forward_proxy_allow_all"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true

					if v.(bool) {
						forwardProxyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterType_ForwardProxyAllowAll{}
						forwardProxyChoiceInt.ForwardProxyAllowAll = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackCluster.ForwardProxyChoice = forwardProxyChoiceInt
					}

				}

				if v, ok := cs["no_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true

					if v.(bool) {
						forwardProxyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterType_NoForwardProxy{}
						forwardProxyChoiceInt.NoForwardProxy = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackCluster.ForwardProxyChoice = forwardProxyChoiceInt
					}

				}

				globalNetworkChoiceTypeFound := false

				if v, ok := cs["global_network_list"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

					globalNetworkChoiceTypeFound = true
					globalNetworkChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterType_GlobalNetworkList{}
					globalNetworkChoiceInt.GlobalNetworkList = &ves_io_schema_views.GlobalNetworkConnectionListType{}
					siteTypeInt.VoltstackCluster.GlobalNetworkChoice = globalNetworkChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["global_network_connections"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								globalNetworkConnections := make([]*ves_io_schema_views.GlobalNetworkConnectionType, len(sl))
								globalNetworkChoiceInt.GlobalNetworkList.GlobalNetworkConnections = globalNetworkConnections
								for i, set := range sl {
									if set != nil {
										globalNetworkConnections[i] = &ves_io_schema_views.GlobalNetworkConnectionType{}
										globalNetworkConnectionsMapStrToI := set.(map[string]interface{})

										connectionChoiceTypeFound := false

										if v, ok := globalNetworkConnectionsMapStrToI["sli_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

											connectionChoiceTypeFound = true
											connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SliToGlobalDr{}
											connectionChoiceInt.SliToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
											globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														globalVn := &ves_io_schema_views.ObjectRefType{}
														connectionChoiceInt.SliToGlobalDr.GlobalVn = globalVn
														for _, set := range sl {
															if set != nil {
																globalVnMapStrToI := set.(map[string]interface{})

																if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
																	globalVn.Name = w.(string)
																}

																if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
																	globalVn.Namespace = w.(string)
																}

																if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
																	globalVn.Tenant = w.(string)
																}

															}
														}

													}

												}
											}

										}

										if v, ok := globalNetworkConnectionsMapStrToI["slo_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

											connectionChoiceTypeFound = true
											connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SloToGlobalDr{}
											connectionChoiceInt.SloToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
											globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														globalVn := &ves_io_schema_views.ObjectRefType{}
														connectionChoiceInt.SloToGlobalDr.GlobalVn = globalVn
														for _, set := range sl {
															if set != nil {
																globalVnMapStrToI := set.(map[string]interface{})

																if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
																	globalVn.Name = w.(string)
																}

																if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
																	globalVn.Namespace = w.(string)
																}

																if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
																	globalVn.Tenant = w.(string)
																}

															}
														}

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["no_global_network"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

					globalNetworkChoiceTypeFound = true

					if v.(bool) {
						globalNetworkChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterType_NoGlobalNetwork{}
						globalNetworkChoiceInt.NoGlobalNetwork = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackCluster.GlobalNetworkChoice = globalNetworkChoiceInt
					}

				}

				k8SClusterChoiceTypeFound := false

				if v, ok := cs["k8s_cluster"]; ok && !isIntfNil(v) && !k8SClusterChoiceTypeFound {

					k8SClusterChoiceTypeFound = true
					k8SClusterChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterType_K8SCluster{}
					k8SClusterChoiceInt.K8SCluster = &ves_io_schema_views.ObjectRefType{}
					siteTypeInt.VoltstackCluster.K8SClusterChoice = k8SClusterChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								k8SClusterChoiceInt.K8SCluster.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								k8SClusterChoiceInt.K8SCluster.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								k8SClusterChoiceInt.K8SCluster.Tenant = v.(string)

							}

						}
					}

				}

				if v, ok := cs["no_k8s_cluster"]; ok && !isIntfNil(v) && !k8SClusterChoiceTypeFound {

					k8SClusterChoiceTypeFound = true

					if v.(bool) {
						k8SClusterChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterType_NoK8SCluster{}
						k8SClusterChoiceInt.NoK8SCluster = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackCluster.K8SClusterChoice = k8SClusterChoiceInt
					}

				}

				networkPolicyChoiceTypeFound := false

				if v, ok := cs["active_enhanced_firewall_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true
					networkPolicyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterType_ActiveEnhancedFirewallPolicies{}
					networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies = &ves_io_schema_network_firewall.ActiveEnhancedFirewallPoliciesType{}
					siteTypeInt.VoltstackCluster.NetworkPolicyChoice = networkPolicyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["enhanced_firewall_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								enhancedFirewallPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies.EnhancedFirewallPolicies = enhancedFirewallPoliciesInt
								for i, ps := range sl {

									efpMapToStrVal := ps.(map[string]interface{})
									enhancedFirewallPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := efpMapToStrVal["name"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Name = v.(string)
									}

									if v, ok := efpMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := efpMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["active_network_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true
					networkPolicyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterType_ActiveNetworkPolicies{}
					networkPolicyChoiceInt.ActiveNetworkPolicies = &ves_io_schema_network_firewall.ActiveNetworkPoliciesType{}
					siteTypeInt.VoltstackCluster.NetworkPolicyChoice = networkPolicyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["network_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								networkPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								networkPolicyChoiceInt.ActiveNetworkPolicies.NetworkPolicies = networkPoliciesInt
								for i, ps := range sl {

									npMapToStrVal := ps.(map[string]interface{})
									networkPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := npMapToStrVal["name"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Name = v.(string)
									}

									if v, ok := npMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := npMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["no_network_policy"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true

					if v.(bool) {
						networkPolicyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterType_NoNetworkPolicy{}
						networkPolicyChoiceInt.NoNetworkPolicy = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackCluster.NetworkPolicyChoice = networkPolicyChoiceInt
					}

				}

				outsideStaticRouteChoiceTypeFound := false

				if v, ok := cs["no_outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

					outsideStaticRouteChoiceTypeFound = true

					if v.(bool) {
						outsideStaticRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterType_NoOutsideStaticRoutes{}
						outsideStaticRouteChoiceInt.NoOutsideStaticRoutes = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackCluster.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt
					}

				}

				if v, ok := cs["outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

					outsideStaticRouteChoiceTypeFound = true
					outsideStaticRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterType_OutsideStaticRoutes{}
					outsideStaticRouteChoiceInt.OutsideStaticRoutes = &ves_io_schema_views.SiteStaticRoutesListType{}
					siteTypeInt.VoltstackCluster.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_route_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRouteList := make([]*ves_io_schema_views.SiteStaticRoutesType, len(sl))
								outsideStaticRouteChoiceInt.OutsideStaticRoutes.StaticRouteList = staticRouteList
								for i, set := range sl {
									if set != nil {
										staticRouteList[i] = &ves_io_schema_views.SiteStaticRoutesType{}
										staticRouteListMapStrToI := set.(map[string]interface{})

										configModeChoiceTypeFound := false

										if v, ok := staticRouteListMapStrToI["custom_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_CustomStaticRoute{}
											configModeChoiceInt.CustomStaticRoute = &ves_io_schema.StaticRouteType{}
											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["attrs"]; ok && !isIntfNil(v) {

														attrsList := []ves_io_schema.RouteAttrType{}
														for _, j := range v.([]interface{}) {
															if j == nil {
																return fmt.Errorf("please provide valid non-empty enum value of field attrs")
															}
															attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
														}
														configModeChoiceInt.CustomStaticRoute.Attrs = attrsList

													}

													if v, ok := cs["labels"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														configModeChoiceInt.CustomStaticRoute.Labels = ms
													}

													if v, ok := cs["nexthop"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														nexthop := &ves_io_schema.NextHopType{}
														configModeChoiceInt.CustomStaticRoute.Nexthop = nexthop
														for _, set := range sl {
															if set != nil {
																nexthopMapStrToI := set.(map[string]interface{})

																if v, ok := nexthopMapStrToI["interface"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	intfInt := make([]*ves_io_schema.ObjectRefType, len(sl))
																	nexthop.Interface = intfInt
																	for i, ps := range sl {

																		iMapToStrVal := ps.(map[string]interface{})
																		intfInt[i] = &ves_io_schema.ObjectRefType{}

																		intfInt[i].Kind = "network_interface"

																		if v, ok := iMapToStrVal["name"]; ok && !isIntfNil(v) {
																			intfInt[i].Name = v.(string)
																		}

																		if v, ok := iMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																			intfInt[i].Namespace = v.(string)
																		}

																		if v, ok := iMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																			intfInt[i].Tenant = v.(string)
																		}

																		if v, ok := iMapToStrVal["uid"]; ok && !isIntfNil(v) {
																			intfInt[i].Uid = v.(string)
																		}

																	}

																}

																if v, ok := nexthopMapStrToI["nexthop_address"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	nexthopAddress := &ves_io_schema.IpAddressType{}
																	nexthop.NexthopAddress = nexthopAddress
																	for _, set := range sl {
																		if set != nil {
																			nexthopAddressMapStrToI := set.(map[string]interface{})

																			verTypeFound := false

																			if v, ok := nexthopAddressMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv4{}
																				verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv4.Addr = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := nexthopAddressMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv6{}
																				verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv6.Addr = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := nexthopMapStrToI["type"]; ok && !isIntfNil(v) {

																	nexthop.Type = ves_io_schema.NextHopTypes(ves_io_schema.NextHopTypes_value[v.(string)])

																}

															}
														}

													}

													if v, ok := cs["subnets"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														subnets := make([]*ves_io_schema.IpSubnetType, len(sl))
														configModeChoiceInt.CustomStaticRoute.Subnets = subnets
														for i, set := range sl {
															if set != nil {
																subnets[i] = &ves_io_schema.IpSubnetType{}
																subnetsMapStrToI := set.(map[string]interface{})

																verTypeFound := false

																if v, ok := subnetsMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv4{}
																	verInt.Ipv4 = &ves_io_schema.Ipv4SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Prefix = v.(string)

																			}

																		}
																	}

																}

																if v, ok := subnetsMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv6{}
																	verInt.Ipv6 = &ves_io_schema.Ipv6SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Prefix = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

												}
											}

										}

										if v, ok := staticRouteListMapStrToI["simple_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_SimpleStaticRoute{}

											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											configModeChoiceInt.SimpleStaticRoute = v.(string)

										}

									}
								}

							}

						}
					}

				}

				siteMeshGroupChoiceTypeFound := false

				if v, ok := cs["sm_connection_public_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

					siteMeshGroupChoiceTypeFound = true

					if v.(bool) {
						siteMeshGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterType_SmConnectionPublicIp{}
						siteMeshGroupChoiceInt.SmConnectionPublicIp = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackCluster.SiteMeshGroupChoice = siteMeshGroupChoiceInt
					}

				}

				if v, ok := cs["sm_connection_pvt_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

					siteMeshGroupChoiceTypeFound = true

					if v.(bool) {
						siteMeshGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterType_SmConnectionPvtIp{}
						siteMeshGroupChoiceInt.SmConnectionPvtIp = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackCluster.SiteMeshGroupChoice = siteMeshGroupChoiceInt
					}

				}

				storageClassChoiceTypeFound := false

				if v, ok := cs["default_storage"]; ok && !isIntfNil(v) && !storageClassChoiceTypeFound {

					storageClassChoiceTypeFound = true

					if v.(bool) {
						storageClassChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterType_DefaultStorage{}
						storageClassChoiceInt.DefaultStorage = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackCluster.StorageClassChoice = storageClassChoiceInt
					}

				}

				if v, ok := cs["storage_class_list"]; ok && !isIntfNil(v) && !storageClassChoiceTypeFound {

					storageClassChoiceTypeFound = true
					storageClassChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterType_StorageClassList{}
					storageClassChoiceInt.StorageClassList = &ves_io_schema_views.StorageClassListType{}
					siteTypeInt.VoltstackCluster.StorageClassChoice = storageClassChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["storage_classes"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								storageClasses := make([]*ves_io_schema_views.StorageClassType, len(sl))
								storageClassChoiceInt.StorageClassList.StorageClasses = storageClasses
								for i, set := range sl {
									if set != nil {
										storageClasses[i] = &ves_io_schema_views.StorageClassType{}
										storageClassesMapStrToI := set.(map[string]interface{})

										if w, ok := storageClassesMapStrToI["default_storage_class"]; ok && !isIntfNil(w) {
											storageClasses[i].DefaultStorageClass = w.(bool)
										}

										if w, ok := storageClassesMapStrToI["storage_class_name"]; ok && !isIntfNil(w) {
											storageClasses[i].StorageClassName = w.(string)
										}

									}
								}

							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("voltstack_cluster_ar"); ok && !isIntfNil(v) && !siteTypeTypeFound {

		siteTypeTypeFound = true
		siteTypeInt := &ves_io_schema_views_azure_vnet_site.CreateSpecType_VoltstackClusterAr{}
		siteTypeInt.VoltstackClusterAr = &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARType{}
		createSpec.SiteType = siteTypeInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["accelerated_networking"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					acceleratedNetworking := &ves_io_schema_views.AcceleratedNetworkingType{}
					siteTypeInt.VoltstackClusterAr.AcceleratedNetworking = acceleratedNetworking
					for _, set := range sl {
						if set != nil {
							acceleratedNetworkingMapStrToI := set.(map[string]interface{})

							acceleratedNetworkingTypeFound := false

							if v, ok := acceleratedNetworkingMapStrToI["disable"]; ok && !isIntfNil(v) && !acceleratedNetworkingTypeFound {

								acceleratedNetworkingTypeFound = true

								if v.(bool) {
									acceleratedNetworkingInt := &ves_io_schema_views.AcceleratedNetworkingType_Disable{}
									acceleratedNetworkingInt.Disable = &ves_io_schema.Empty{}
									acceleratedNetworking.AcceleratedNetworking = acceleratedNetworkingInt
								}

							}

							if v, ok := acceleratedNetworkingMapStrToI["enable"]; ok && !isIntfNil(v) && !acceleratedNetworkingTypeFound {

								acceleratedNetworkingTypeFound = true

								if v.(bool) {
									acceleratedNetworkingInt := &ves_io_schema_views.AcceleratedNetworkingType_Enable{}
									acceleratedNetworkingInt.Enable = &ves_io_schema.Empty{}
									acceleratedNetworking.AcceleratedNetworking = acceleratedNetworkingInt
								}

							}

						}
					}

				}

				if v, ok := cs["azure_certified_hw"]; ok && !isIntfNil(v) {

					siteTypeInt.VoltstackClusterAr.AzureCertifiedHw = v.(string)

				}

				dcClusterGroupChoiceTypeFound := false

				if v, ok := cs["dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

					dcClusterGroupChoiceTypeFound = true
					dcClusterGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARType_DcClusterGroup{}
					dcClusterGroupChoiceInt.DcClusterGroup = &ves_io_schema_views.ObjectRefType{}
					siteTypeInt.VoltstackClusterAr.DcClusterGroupChoice = dcClusterGroupChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Tenant = v.(string)

							}

						}
					}

				}

				if v, ok := cs["no_dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

					dcClusterGroupChoiceTypeFound = true

					if v.(bool) {
						dcClusterGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARType_NoDcClusterGroup{}
						dcClusterGroupChoiceInt.NoDcClusterGroup = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackClusterAr.DcClusterGroupChoice = dcClusterGroupChoiceInt
					}

				}

				forwardProxyChoiceTypeFound := false

				if v, ok := cs["active_forward_proxy_policies"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true
					forwardProxyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARType_ActiveForwardProxyPolicies{}
					forwardProxyChoiceInt.ActiveForwardProxyPolicies = &ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType{}
					siteTypeInt.VoltstackClusterAr.ForwardProxyChoice = forwardProxyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["forward_proxy_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								forwardProxyPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								forwardProxyChoiceInt.ActiveForwardProxyPolicies.ForwardProxyPolicies = forwardProxyPoliciesInt
								for i, ps := range sl {

									fppMapToStrVal := ps.(map[string]interface{})
									forwardProxyPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := fppMapToStrVal["name"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Name = v.(string)
									}

									if v, ok := fppMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := fppMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["forward_proxy_allow_all"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true

					if v.(bool) {
						forwardProxyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARType_ForwardProxyAllowAll{}
						forwardProxyChoiceInt.ForwardProxyAllowAll = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackClusterAr.ForwardProxyChoice = forwardProxyChoiceInt
					}

				}

				if v, ok := cs["no_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true

					if v.(bool) {
						forwardProxyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARType_NoForwardProxy{}
						forwardProxyChoiceInt.NoForwardProxy = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackClusterAr.ForwardProxyChoice = forwardProxyChoiceInt
					}

				}

				globalNetworkChoiceTypeFound := false

				if v, ok := cs["global_network_list"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

					globalNetworkChoiceTypeFound = true
					globalNetworkChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARType_GlobalNetworkList{}
					globalNetworkChoiceInt.GlobalNetworkList = &ves_io_schema_views.GlobalNetworkConnectionListType{}
					siteTypeInt.VoltstackClusterAr.GlobalNetworkChoice = globalNetworkChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["global_network_connections"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								globalNetworkConnections := make([]*ves_io_schema_views.GlobalNetworkConnectionType, len(sl))
								globalNetworkChoiceInt.GlobalNetworkList.GlobalNetworkConnections = globalNetworkConnections
								for i, set := range sl {
									if set != nil {
										globalNetworkConnections[i] = &ves_io_schema_views.GlobalNetworkConnectionType{}
										globalNetworkConnectionsMapStrToI := set.(map[string]interface{})

										connectionChoiceTypeFound := false

										if v, ok := globalNetworkConnectionsMapStrToI["sli_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

											connectionChoiceTypeFound = true
											connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SliToGlobalDr{}
											connectionChoiceInt.SliToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
											globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														globalVn := &ves_io_schema_views.ObjectRefType{}
														connectionChoiceInt.SliToGlobalDr.GlobalVn = globalVn
														for _, set := range sl {
															if set != nil {
																globalVnMapStrToI := set.(map[string]interface{})

																if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
																	globalVn.Name = w.(string)
																}

																if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
																	globalVn.Namespace = w.(string)
																}

																if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
																	globalVn.Tenant = w.(string)
																}

															}
														}

													}

												}
											}

										}

										if v, ok := globalNetworkConnectionsMapStrToI["slo_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

											connectionChoiceTypeFound = true
											connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SloToGlobalDr{}
											connectionChoiceInt.SloToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
											globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														globalVn := &ves_io_schema_views.ObjectRefType{}
														connectionChoiceInt.SloToGlobalDr.GlobalVn = globalVn
														for _, set := range sl {
															if set != nil {
																globalVnMapStrToI := set.(map[string]interface{})

																if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
																	globalVn.Name = w.(string)
																}

																if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
																	globalVn.Namespace = w.(string)
																}

																if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
																	globalVn.Tenant = w.(string)
																}

															}
														}

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["no_global_network"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

					globalNetworkChoiceTypeFound = true

					if v.(bool) {
						globalNetworkChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARType_NoGlobalNetwork{}
						globalNetworkChoiceInt.NoGlobalNetwork = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackClusterAr.GlobalNetworkChoice = globalNetworkChoiceInt
					}

				}

				k8SClusterChoiceTypeFound := false

				if v, ok := cs["k8s_cluster"]; ok && !isIntfNil(v) && !k8SClusterChoiceTypeFound {

					k8SClusterChoiceTypeFound = true
					k8SClusterChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARType_K8SCluster{}
					k8SClusterChoiceInt.K8SCluster = &ves_io_schema_views.ObjectRefType{}
					siteTypeInt.VoltstackClusterAr.K8SClusterChoice = k8SClusterChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								k8SClusterChoiceInt.K8SCluster.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								k8SClusterChoiceInt.K8SCluster.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								k8SClusterChoiceInt.K8SCluster.Tenant = v.(string)

							}

						}
					}

				}

				if v, ok := cs["no_k8s_cluster"]; ok && !isIntfNil(v) && !k8SClusterChoiceTypeFound {

					k8SClusterChoiceTypeFound = true

					if v.(bool) {
						k8SClusterChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARType_NoK8SCluster{}
						k8SClusterChoiceInt.NoK8SCluster = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackClusterAr.K8SClusterChoice = k8SClusterChoiceInt
					}

				}

				networkPolicyChoiceTypeFound := false

				if v, ok := cs["active_enhanced_firewall_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true
					networkPolicyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARType_ActiveEnhancedFirewallPolicies{}
					networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies = &ves_io_schema_network_firewall.ActiveEnhancedFirewallPoliciesType{}
					siteTypeInt.VoltstackClusterAr.NetworkPolicyChoice = networkPolicyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["enhanced_firewall_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								enhancedFirewallPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies.EnhancedFirewallPolicies = enhancedFirewallPoliciesInt
								for i, ps := range sl {

									efpMapToStrVal := ps.(map[string]interface{})
									enhancedFirewallPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := efpMapToStrVal["name"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Name = v.(string)
									}

									if v, ok := efpMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := efpMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["active_network_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true
					networkPolicyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARType_ActiveNetworkPolicies{}
					networkPolicyChoiceInt.ActiveNetworkPolicies = &ves_io_schema_network_firewall.ActiveNetworkPoliciesType{}
					siteTypeInt.VoltstackClusterAr.NetworkPolicyChoice = networkPolicyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["network_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								networkPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								networkPolicyChoiceInt.ActiveNetworkPolicies.NetworkPolicies = networkPoliciesInt
								for i, ps := range sl {

									npMapToStrVal := ps.(map[string]interface{})
									networkPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := npMapToStrVal["name"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Name = v.(string)
									}

									if v, ok := npMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := npMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["no_network_policy"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true

					if v.(bool) {
						networkPolicyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARType_NoNetworkPolicy{}
						networkPolicyChoiceInt.NoNetworkPolicy = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackClusterAr.NetworkPolicyChoice = networkPolicyChoiceInt
					}

				}

				if v, ok := cs["node"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					node := &ves_io_schema_views.AzureVnetOneInterfaceNodeARType{}
					siteTypeInt.VoltstackClusterAr.Node = node
					for _, set := range sl {
						if set != nil {
							nodeMapStrToI := set.(map[string]interface{})

							if w, ok := nodeMapStrToI["fault_domain"]; ok && !isIntfNil(w) {
								node.FaultDomain = uint32(w.(int))
							}

							if v, ok := nodeMapStrToI["local_subnet"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								localSubnet := &ves_io_schema_views.AzureSubnetChoiceType{}
								node.LocalSubnet = localSubnet
								for _, set := range sl {
									if set != nil {
										localSubnetMapStrToI := set.(map[string]interface{})

										choiceTypeFound := false

										if v, ok := localSubnetMapStrToI["subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_Subnet{}
											choiceInt.Subnet = &ves_io_schema_views.AzureSubnetType{}
											localSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													resourceGroupChoiceTypeFound := false

													if v, ok := cs["subnet_resource_grp"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true
														resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_SubnetResourceGrp{}

														choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt

														resourceGroupChoiceInt.SubnetResourceGrp = v.(string)

													}

													if v, ok := cs["vnet_resource_group"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true

														if v.(bool) {
															resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_VnetResourceGroup{}
															resourceGroupChoiceInt.VnetResourceGroup = &ves_io_schema.Empty{}
															choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt
														}

													}

													if v, ok := cs["subnet_name"]; ok && !isIntfNil(v) {

														choiceInt.Subnet.SubnetName = v.(string)

													}

												}
											}

										}

										if v, ok := localSubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_SubnetParam{}
											choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
											localSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv4 = v.(string)

													}

													if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv6 = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if w, ok := nodeMapStrToI["node_number"]; ok && !isIntfNil(w) {
								node.NodeNumber = uint32(w.(int))
							}

							if w, ok := nodeMapStrToI["update_domain"]; ok && !isIntfNil(w) {
								node.UpdateDomain = uint32(w.(int))
							}

						}
					}

				}

				outsideStaticRouteChoiceTypeFound := false

				if v, ok := cs["no_outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

					outsideStaticRouteChoiceTypeFound = true

					if v.(bool) {
						outsideStaticRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARType_NoOutsideStaticRoutes{}
						outsideStaticRouteChoiceInt.NoOutsideStaticRoutes = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackClusterAr.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt
					}

				}

				if v, ok := cs["outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

					outsideStaticRouteChoiceTypeFound = true
					outsideStaticRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARType_OutsideStaticRoutes{}
					outsideStaticRouteChoiceInt.OutsideStaticRoutes = &ves_io_schema_views.SiteStaticRoutesListType{}
					siteTypeInt.VoltstackClusterAr.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_route_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRouteList := make([]*ves_io_schema_views.SiteStaticRoutesType, len(sl))
								outsideStaticRouteChoiceInt.OutsideStaticRoutes.StaticRouteList = staticRouteList
								for i, set := range sl {
									if set != nil {
										staticRouteList[i] = &ves_io_schema_views.SiteStaticRoutesType{}
										staticRouteListMapStrToI := set.(map[string]interface{})

										configModeChoiceTypeFound := false

										if v, ok := staticRouteListMapStrToI["custom_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_CustomStaticRoute{}
											configModeChoiceInt.CustomStaticRoute = &ves_io_schema.StaticRouteType{}
											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["attrs"]; ok && !isIntfNil(v) {

														attrsList := []ves_io_schema.RouteAttrType{}
														for _, j := range v.([]interface{}) {
															if j == nil {
																return fmt.Errorf("please provide valid non-empty enum value of field attrs")
															}
															attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
														}
														configModeChoiceInt.CustomStaticRoute.Attrs = attrsList

													}

													if v, ok := cs["labels"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														configModeChoiceInt.CustomStaticRoute.Labels = ms
													}

													if v, ok := cs["nexthop"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														nexthop := &ves_io_schema.NextHopType{}
														configModeChoiceInt.CustomStaticRoute.Nexthop = nexthop
														for _, set := range sl {
															if set != nil {
																nexthopMapStrToI := set.(map[string]interface{})

																if v, ok := nexthopMapStrToI["interface"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	intfInt := make([]*ves_io_schema.ObjectRefType, len(sl))
																	nexthop.Interface = intfInt
																	for i, ps := range sl {

																		iMapToStrVal := ps.(map[string]interface{})
																		intfInt[i] = &ves_io_schema.ObjectRefType{}

																		intfInt[i].Kind = "network_interface"

																		if v, ok := iMapToStrVal["name"]; ok && !isIntfNil(v) {
																			intfInt[i].Name = v.(string)
																		}

																		if v, ok := iMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																			intfInt[i].Namespace = v.(string)
																		}

																		if v, ok := iMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																			intfInt[i].Tenant = v.(string)
																		}

																		if v, ok := iMapToStrVal["uid"]; ok && !isIntfNil(v) {
																			intfInt[i].Uid = v.(string)
																		}

																	}

																}

																if v, ok := nexthopMapStrToI["nexthop_address"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	nexthopAddress := &ves_io_schema.IpAddressType{}
																	nexthop.NexthopAddress = nexthopAddress
																	for _, set := range sl {
																		if set != nil {
																			nexthopAddressMapStrToI := set.(map[string]interface{})

																			verTypeFound := false

																			if v, ok := nexthopAddressMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv4{}
																				verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv4.Addr = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := nexthopAddressMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv6{}
																				verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv6.Addr = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := nexthopMapStrToI["type"]; ok && !isIntfNil(v) {

																	nexthop.Type = ves_io_schema.NextHopTypes(ves_io_schema.NextHopTypes_value[v.(string)])

																}

															}
														}

													}

													if v, ok := cs["subnets"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														subnets := make([]*ves_io_schema.IpSubnetType, len(sl))
														configModeChoiceInt.CustomStaticRoute.Subnets = subnets
														for i, set := range sl {
															if set != nil {
																subnets[i] = &ves_io_schema.IpSubnetType{}
																subnetsMapStrToI := set.(map[string]interface{})

																verTypeFound := false

																if v, ok := subnetsMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv4{}
																	verInt.Ipv4 = &ves_io_schema.Ipv4SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Prefix = v.(string)

																			}

																		}
																	}

																}

																if v, ok := subnetsMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv6{}
																	verInt.Ipv6 = &ves_io_schema.Ipv6SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Prefix = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

												}
											}

										}

										if v, ok := staticRouteListMapStrToI["simple_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_SimpleStaticRoute{}

											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											configModeChoiceInt.SimpleStaticRoute = v.(string)

										}

									}
								}

							}

						}
					}

				}

				siteMeshGroupChoiceTypeFound := false

				if v, ok := cs["sm_connection_public_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

					siteMeshGroupChoiceTypeFound = true

					if v.(bool) {
						siteMeshGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARType_SmConnectionPublicIp{}
						siteMeshGroupChoiceInt.SmConnectionPublicIp = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackClusterAr.SiteMeshGroupChoice = siteMeshGroupChoiceInt
					}

				}

				if v, ok := cs["sm_connection_pvt_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

					siteMeshGroupChoiceTypeFound = true

					if v.(bool) {
						siteMeshGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARType_SmConnectionPvtIp{}
						siteMeshGroupChoiceInt.SmConnectionPvtIp = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackClusterAr.SiteMeshGroupChoice = siteMeshGroupChoiceInt
					}

				}

				storageClassChoiceTypeFound := false

				if v, ok := cs["default_storage"]; ok && !isIntfNil(v) && !storageClassChoiceTypeFound {

					storageClassChoiceTypeFound = true

					if v.(bool) {
						storageClassChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARType_DefaultStorage{}
						storageClassChoiceInt.DefaultStorage = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackClusterAr.StorageClassChoice = storageClassChoiceInt
					}

				}

				if v, ok := cs["storage_class_list"]; ok && !isIntfNil(v) && !storageClassChoiceTypeFound {

					storageClassChoiceTypeFound = true
					storageClassChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARType_StorageClassList{}
					storageClassChoiceInt.StorageClassList = &ves_io_schema_views.StorageClassListType{}
					siteTypeInt.VoltstackClusterAr.StorageClassChoice = storageClassChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["storage_classes"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								storageClasses := make([]*ves_io_schema_views.StorageClassType, len(sl))
								storageClassChoiceInt.StorageClassList.StorageClasses = storageClasses
								for i, set := range sl {
									if set != nil {
										storageClasses[i] = &ves_io_schema_views.StorageClassType{}
										storageClassesMapStrToI := set.(map[string]interface{})

										if w, ok := storageClassesMapStrToI["default_storage_class"]; ok && !isIntfNil(w) {
											storageClasses[i].DefaultStorageClass = w.(bool)
										}

										if w, ok := storageClassesMapStrToI["storage_class_name"]; ok && !isIntfNil(w) {
											storageClasses[i].StorageClassName = w.(string)
										}

									}
								}

							}

						}
					}

				}

			}
		}

	}

	//ssh_key
	if v, ok := d.GetOk("ssh_key"); ok && !isIntfNil(v) {

		createSpec.SshKey =
			v.(string)

	}

	//sw
	if v, ok := d.GetOk("sw"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		sw := &ves_io_schema_views.VolterraSoftwareType{}
		createSpec.Sw = sw
		for _, set := range sl {
			if set != nil {
				swMapStrToI := set.(map[string]interface{})

				volterraSwVersionChoiceTypeFound := false

				if v, ok := swMapStrToI["default_sw_version"]; ok && !isIntfNil(v) && !volterraSwVersionChoiceTypeFound {

					volterraSwVersionChoiceTypeFound = true

					if v.(bool) {
						volterraSwVersionChoiceInt := &ves_io_schema_views.VolterraSoftwareType_DefaultSwVersion{}
						volterraSwVersionChoiceInt.DefaultSwVersion = &ves_io_schema.Empty{}
						sw.VolterraSwVersionChoice = volterraSwVersionChoiceInt
					}

				}

				if v, ok := swMapStrToI["volterra_software_version"]; ok && !isIntfNil(v) && !volterraSwVersionChoiceTypeFound {

					volterraSwVersionChoiceTypeFound = true
					volterraSwVersionChoiceInt := &ves_io_schema_views.VolterraSoftwareType_VolterraSoftwareVersion{}

					sw.VolterraSwVersionChoice = volterraSwVersionChoiceInt

					volterraSwVersionChoiceInt.VolterraSoftwareVersion = v.(string)

				}

			}
		}

	}

	//tags
	if v, ok := d.GetOk("tags"); ok && !isIntfNil(v) {

		ms := map[string]string{}
		for k, v := range v.(map[string]interface{}) {
			ms[k] = v.(string)
		}
		createSpec.Tags = ms
	}

	//vnet
	if v, ok := d.GetOk("vnet"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		vnet := &ves_io_schema_views.AzureVnetChoiceType{}
		createSpec.Vnet = vnet
		for _, set := range sl {
			if set != nil {
				vnetMapStrToI := set.(map[string]interface{})

				choiceTypeFound := false

				if v, ok := vnetMapStrToI["existing_vnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

					choiceTypeFound = true
					choiceInt := &ves_io_schema_views.AzureVnetChoiceType_ExistingVnet{}
					choiceInt.ExistingVnet = &ves_io_schema_views.AzureVnetType{}
					vnet.Choice = choiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["resource_group"]; ok && !isIntfNil(v) {

								choiceInt.ExistingVnet.ResourceGroup = v.(string)

							}

							routingTypeTypeFound := false

							if v, ok := cs["f5_orchestrated_routing"]; ok && !isIntfNil(v) && !routingTypeTypeFound {

								routingTypeTypeFound = true

								if v.(bool) {
									routingTypeInt := &ves_io_schema_views.AzureVnetType_F5OrchestratedRouting{}
									routingTypeInt.F5OrchestratedRouting = &ves_io_schema.Empty{}
									choiceInt.ExistingVnet.RoutingType = routingTypeInt
								}

							}

							if v, ok := cs["manual_routing"]; ok && !isIntfNil(v) && !routingTypeTypeFound {

								routingTypeTypeFound = true

								if v.(bool) {
									routingTypeInt := &ves_io_schema_views.AzureVnetType_ManualRouting{}
									routingTypeInt.ManualRouting = &ves_io_schema.Empty{}
									choiceInt.ExistingVnet.RoutingType = routingTypeInt
								}

							}

							if v, ok := cs["vnet_name"]; ok && !isIntfNil(v) {

								choiceInt.ExistingVnet.VnetName = v.(string)

							}

						}
					}

				}

				if v, ok := vnetMapStrToI["new_vnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

					choiceTypeFound = true
					choiceInt := &ves_io_schema_views.AzureVnetChoiceType_NewVnet{}
					choiceInt.NewVnet = &ves_io_schema_views.AzureVnetParamsType{}
					vnet.Choice = choiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							nameChoiceTypeFound := false

							if v, ok := cs["autogenerate"]; ok && !isIntfNil(v) && !nameChoiceTypeFound {

								nameChoiceTypeFound = true

								if v.(bool) {
									nameChoiceInt := &ves_io_schema_views.AzureVnetParamsType_Autogenerate{}
									nameChoiceInt.Autogenerate = &ves_io_schema.Empty{}
									choiceInt.NewVnet.NameChoice = nameChoiceInt
								}

							}

							if v, ok := cs["name"]; ok && !isIntfNil(v) && !nameChoiceTypeFound {

								nameChoiceTypeFound = true
								nameChoiceInt := &ves_io_schema_views.AzureVnetParamsType_Name{}

								choiceInt.NewVnet.NameChoice = nameChoiceInt

								nameChoiceInt.Name = v.(string)

							}

							if v, ok := cs["primary_ipv4"]; ok && !isIntfNil(v) {

								choiceInt.NewVnet.PrimaryIpv4 = v.(string)

							}

						}
					}

				}

			}
		}

	}

	//worker_nodes

	workerNodesTypeFound := false

	if v, ok := d.GetOk("no_worker_nodes"); ok && !workerNodesTypeFound {

		workerNodesTypeFound = true

		if v.(bool) {
			workerNodesInt := &ves_io_schema_views_azure_vnet_site.CreateSpecType_NoWorkerNodes{}
			workerNodesInt.NoWorkerNodes = &ves_io_schema.Empty{}
			createSpec.WorkerNodes = workerNodesInt
		}

	}

	if v, ok := d.GetOk("nodes_per_az"); ok && !isIntfNil(v) && !workerNodesTypeFound {

		workerNodesTypeFound = true
		workerNodesInt := &ves_io_schema_views_azure_vnet_site.CreateSpecType_NodesPerAz{}

		createSpec.WorkerNodes = workerNodesInt

		workerNodesInt.NodesPerAz = uint32(v.(int))

	}

	if v, ok := d.GetOk("total_nodes"); ok && !isIntfNil(v) && !workerNodesTypeFound {

		workerNodesTypeFound = true
		workerNodesInt := &ves_io_schema_views_azure_vnet_site.CreateSpecType_TotalNodes{}

		createSpec.WorkerNodes = workerNodesInt

		workerNodesInt.TotalNodes = uint32(v.(int))

	}

	log.Printf("[DEBUG] Creating Volterra AzureVnetSite object with struct: %+v", createReq)

	createAzureVnetSiteResp, err := client.CreateObject(context.Background(), ves_io_schema_views_azure_vnet_site.ObjectType, createReq)
	if err != nil {
		return fmt.Errorf("error creating AzureVnetSite: %s", err)
	}
	d.SetId(createAzureVnetSiteResp.GetObjSystemMetadata().GetUid())

	return resourceVolterraAzureVnetSiteRead(d, meta)
}

func resourceVolterraAzureVnetSiteRead(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	resp, err := client.GetObject(context.Background(), ves_io_schema_views_azure_vnet_site.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] AzureVnetSite %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra AzureVnetSite %q: %s", d.Id(), err)
	}
	return setAzureVnetSiteFields(client, d, resp)
}

func setAzureVnetSiteFields(client *APIClient, d *schema.ResourceData, resp vesapi.GetObjectResponse) error {
	metadata := resp.GetObjMetadata()

	d.Set("annotations", metadata.GetAnnotations())

	d.Set("description", metadata.GetDescription())

	d.Set("disable", metadata.GetDisable())

	d.Set("labels", metadata.GetLabels())

	d.Set("name", metadata.GetName())

	d.Set("namespace", metadata.GetNamespace())

	return nil
}

// resourceVolterraAzureVnetSiteUpdate updates AzureVnetSite resource
func resourceVolterraAzureVnetSiteUpdate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	updateMeta := &ves_io_schema.ObjectReplaceMetaType{}
	updateSpec := &ves_io_schema_views_azure_vnet_site.ReplaceSpecType{}
	updateReq := &ves_io_schema_views_azure_vnet_site.ReplaceRequest{
		Metadata: updateMeta,
		Spec:     updateSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		updateMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		updateMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		updateMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		updateMeta.Namespace =
			v.(string)
	}

	if v, ok := d.GetOk("address"); ok && !isIntfNil(v) {

		updateSpec.Address =
			v.(string)

	}

	blockedServicesChoiceTypeFound := false

	if v, ok := d.GetOk("block_all_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true

		if v.(bool) {
			blockedServicesChoiceInt := &ves_io_schema_views_azure_vnet_site.ReplaceSpecType_BlockAllServices{}
			blockedServicesChoiceInt.BlockAllServices = &ves_io_schema.Empty{}
			updateSpec.BlockedServicesChoice = blockedServicesChoiceInt
		}

	}

	if v, ok := d.GetOk("blocked_services"); ok && !isIntfNil(v) && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true
		blockedServicesChoiceInt := &ves_io_schema_views_azure_vnet_site.ReplaceSpecType_BlockedServices{}
		blockedServicesChoiceInt.BlockedServices = &ves_io_schema_fleet.BlockedServicesListType{}
		updateSpec.BlockedServicesChoice = blockedServicesChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["blocked_sevice"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					blockedSevice := make([]*ves_io_schema_fleet.BlockedServices, len(sl))
					blockedServicesChoiceInt.BlockedServices.BlockedSevice = blockedSevice
					for i, set := range sl {
						if set != nil {
							blockedSevice[i] = &ves_io_schema_fleet.BlockedServices{}
							blockedSeviceMapStrToI := set.(map[string]interface{})

							blockedServicesValueTypeChoiceTypeFound := false

							if v, ok := blockedSeviceMapStrToI["dns"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

								blockedServicesValueTypeChoiceTypeFound = true

								if v.(bool) {
									blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Dns{}
									blockedServicesValueTypeChoiceInt.Dns = &ves_io_schema.Empty{}
									blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
								}

							}

							if v, ok := blockedSeviceMapStrToI["ssh"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

								blockedServicesValueTypeChoiceTypeFound = true

								if v.(bool) {
									blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Ssh{}
									blockedServicesValueTypeChoiceInt.Ssh = &ves_io_schema.Empty{}
									blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
								}

							}

							if v, ok := blockedSeviceMapStrToI["web_user_interface"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

								blockedServicesValueTypeChoiceTypeFound = true

								if v.(bool) {
									blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_WebUserInterface{}
									blockedServicesValueTypeChoiceInt.WebUserInterface = &ves_io_schema.Empty{}
									blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
								}

							}

							if v, ok := blockedSeviceMapStrToI["network_type"]; ok && !isIntfNil(v) {

								blockedSevice[i].NetworkType = ves_io_schema.VirtualNetworkType(ves_io_schema.VirtualNetworkType_value[v.(string)])

							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("default_blocked_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true

		if v.(bool) {
			blockedServicesChoiceInt := &ves_io_schema_views_azure_vnet_site.ReplaceSpecType_DefaultBlockedServices{}
			blockedServicesChoiceInt.DefaultBlockedServices = &ves_io_schema.Empty{}
			updateSpec.BlockedServicesChoice = blockedServicesChoiceInt
		}

	}

	if v, ok := d.GetOk("coordinates"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		coordinates := &ves_io_schema_site.Coordinates{}
		updateSpec.Coordinates = coordinates
		for _, set := range sl {
			if set != nil {
				coordinatesMapStrToI := set.(map[string]interface{})

				if w, ok := coordinatesMapStrToI["latitude"]; ok && !isIntfNil(w) {
					coordinates.Latitude = float32(w.(float64))
				}

				if w, ok := coordinatesMapStrToI["longitude"]; ok && !isIntfNil(w) {
					coordinates.Longitude = float32(w.(float64))
				}

			}
		}

	}

	if v, ok := d.GetOk("custom_dns"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		customDns := &ves_io_schema_views.CustomDNS{}
		updateSpec.CustomDns = customDns
		for _, set := range sl {
			if set != nil {
				customDnsMapStrToI := set.(map[string]interface{})

				if w, ok := customDnsMapStrToI["inside_nameserver"]; ok && !isIntfNil(w) {
					customDns.InsideNameserver = w.(string)
				}

				if w, ok := customDnsMapStrToI["inside_nameserver_v6"]; ok && !isIntfNil(w) {
					customDns.InsideNameserverV6 = w.(string)
				}

				if w, ok := customDnsMapStrToI["outside_nameserver"]; ok && !isIntfNil(w) {
					customDns.OutsideNameserver = w.(string)
				}

				if w, ok := customDnsMapStrToI["outside_nameserver_v6"]; ok && !isIntfNil(w) {
					customDns.OutsideNameserverV6 = w.(string)
				}

			}
		}

	}

	deploymentTypeFound := false

	if v, ok := d.GetOk("azure_cred"); ok && !isIntfNil(v) && !deploymentTypeFound {

		deploymentTypeFound = true
		deploymentInt := &ves_io_schema_views_azure_vnet_site.ReplaceSpecType_AzureCred{}
		deploymentInt.AzureCred = &ves_io_schema_views.ObjectRefType{}
		updateSpec.Deployment = deploymentInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["name"]; ok && !isIntfNil(v) {

					deploymentInt.AzureCred.Name = v.(string)

				}

				if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

					deploymentInt.AzureCred.Namespace = v.(string)

				}

				if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

					deploymentInt.AzureCred.Tenant = v.(string)

				}

			}
		}

	}

	if v, ok := d.GetOk("disk_size"); ok && !isIntfNil(v) {

		updateSpec.DiskSize =
			uint32(v.(int))

	}

	if v, ok := d.GetOk("kubernetes_upgrade_drain"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		kubernetesUpgradeDrain := &ves_io_schema_views.KubernetesUpgradeDrain{}
		updateSpec.KubernetesUpgradeDrain = kubernetesUpgradeDrain
		for _, set := range sl {
			if set != nil {
				kubernetesUpgradeDrainMapStrToI := set.(map[string]interface{})

				kubernetesUpgradeDrainEnableChoiceTypeFound := false

				if v, ok := kubernetesUpgradeDrainMapStrToI["disable_upgrade_drain"]; ok && !isIntfNil(v) && !kubernetesUpgradeDrainEnableChoiceTypeFound {

					kubernetesUpgradeDrainEnableChoiceTypeFound = true

					if v.(bool) {
						kubernetesUpgradeDrainEnableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrain_DisableUpgradeDrain{}
						kubernetesUpgradeDrainEnableChoiceInt.DisableUpgradeDrain = &ves_io_schema.Empty{}
						kubernetesUpgradeDrain.KubernetesUpgradeDrainEnableChoice = kubernetesUpgradeDrainEnableChoiceInt
					}

				}

				if v, ok := kubernetesUpgradeDrainMapStrToI["enable_upgrade_drain"]; ok && !isIntfNil(v) && !kubernetesUpgradeDrainEnableChoiceTypeFound {

					kubernetesUpgradeDrainEnableChoiceTypeFound = true
					kubernetesUpgradeDrainEnableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrain_EnableUpgradeDrain{}
					kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain = &ves_io_schema_views.KubernetesUpgradeDrainConfig{}
					kubernetesUpgradeDrain.KubernetesUpgradeDrainEnableChoice = kubernetesUpgradeDrainEnableChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							drainMaxUnavailableChoiceTypeFound := false

							if v, ok := cs["drain_max_unavailable_node_count"]; ok && !isIntfNil(v) && !drainMaxUnavailableChoiceTypeFound {

								drainMaxUnavailableChoiceTypeFound = true
								drainMaxUnavailableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrainConfig_DrainMaxUnavailableNodeCount{}

								kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.DrainMaxUnavailableChoice = drainMaxUnavailableChoiceInt

								drainMaxUnavailableChoiceInt.DrainMaxUnavailableNodeCount = uint32(v.(int))

							}

							if v, ok := cs["drain_node_timeout"]; ok && !isIntfNil(v) {

								kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.DrainNodeTimeout = uint32(v.(int))

							}

						}
					}

				}

			}
		}

	}

	logsReceiverChoiceTypeFound := false

	if v, ok := d.GetOk("log_receiver"); ok && !isIntfNil(v) && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true
		logsReceiverChoiceInt := &ves_io_schema_views_azure_vnet_site.ReplaceSpecType_LogReceiver{}
		logsReceiverChoiceInt.LogReceiver = &ves_io_schema_views.ObjectRefType{}
		updateSpec.LogsReceiverChoice = logsReceiverChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["name"]; ok && !isIntfNil(v) {

					logsReceiverChoiceInt.LogReceiver.Name = v.(string)

				}

				if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

					logsReceiverChoiceInt.LogReceiver.Namespace = v.(string)

				}

				if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

					logsReceiverChoiceInt.LogReceiver.Tenant = v.(string)

				}

			}
		}

	}

	if v, ok := d.GetOk("logs_streaming_disabled"); ok && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true

		if v.(bool) {
			logsReceiverChoiceInt := &ves_io_schema_views_azure_vnet_site.ReplaceSpecType_LogsStreamingDisabled{}
			logsReceiverChoiceInt.LogsStreamingDisabled = &ves_io_schema.Empty{}
			updateSpec.LogsReceiverChoice = logsReceiverChoiceInt
		}

	}

	if v, ok := d.GetOk("machine_type"); ok && !isIntfNil(v) {

		updateSpec.MachineType =
			v.(string)

	}

	if v, ok := d.GetOk("offline_survivability_mode"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		offlineSurvivabilityMode := &ves_io_schema_views.OfflineSurvivabilityModeType{}
		updateSpec.OfflineSurvivabilityMode = offlineSurvivabilityMode
		for _, set := range sl {
			if set != nil {
				offlineSurvivabilityModeMapStrToI := set.(map[string]interface{})

				offlineSurvivabilityModeChoiceTypeFound := false

				if v, ok := offlineSurvivabilityModeMapStrToI["enable_offline_survivability_mode"]; ok && !isIntfNil(v) && !offlineSurvivabilityModeChoiceTypeFound {

					offlineSurvivabilityModeChoiceTypeFound = true

					if v.(bool) {
						offlineSurvivabilityModeChoiceInt := &ves_io_schema_views.OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode{}
						offlineSurvivabilityModeChoiceInt.EnableOfflineSurvivabilityMode = &ves_io_schema.Empty{}
						offlineSurvivabilityMode.OfflineSurvivabilityModeChoice = offlineSurvivabilityModeChoiceInt
					}

				}

				if v, ok := offlineSurvivabilityModeMapStrToI["no_offline_survivability_mode"]; ok && !isIntfNil(v) && !offlineSurvivabilityModeChoiceTypeFound {

					offlineSurvivabilityModeChoiceTypeFound = true

					if v.(bool) {
						offlineSurvivabilityModeChoiceInt := &ves_io_schema_views.OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode{}
						offlineSurvivabilityModeChoiceInt.NoOfflineSurvivabilityMode = &ves_io_schema.Empty{}
						offlineSurvivabilityMode.OfflineSurvivabilityModeChoice = offlineSurvivabilityModeChoiceInt
					}

				}

			}
		}

	}

	regionChoiceTypeFound := false

	if v, ok := d.GetOk("alternate_region"); ok && !isIntfNil(v) && !regionChoiceTypeFound {

		regionChoiceTypeFound = true
		regionChoiceInt := &ves_io_schema_views_azure_vnet_site.ReplaceSpecType_AlternateRegion{}

		updateSpec.RegionChoice = regionChoiceInt

		regionChoiceInt.AlternateRegion = v.(string)

	}

	if v, ok := d.GetOk("azure_region"); ok && !isIntfNil(v) && !regionChoiceTypeFound {

		regionChoiceTypeFound = true
		regionChoiceInt := &ves_io_schema_views_azure_vnet_site.ReplaceSpecType_AzureRegion{}

		updateSpec.RegionChoice = regionChoiceInt

		regionChoiceInt.AzureRegion = v.(string)

	}

	if v, ok := d.GetOk("resource_group"); ok && !isIntfNil(v) {

		updateSpec.ResourceGroup =
			v.(string)

	}

	siteTypeTypeFound := false

	if v, ok := d.GetOk("ingress_egress_gw"); ok && !isIntfNil(v) && !siteTypeTypeFound {

		siteTypeTypeFound = true
		siteTypeInt := &ves_io_schema_views_azure_vnet_site.ReplaceSpecType_IngressEgressGw{}
		siteTypeInt.IngressEgressGw = &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwReplaceType{}
		updateSpec.SiteType = siteTypeInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["az_nodes"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					azNodes := make([]*ves_io_schema_views.AzureVnetTwoInterfaceNodeType, len(sl))
					siteTypeInt.IngressEgressGw.AzNodes = azNodes
					for i, set := range sl {
						if set != nil {
							azNodes[i] = &ves_io_schema_views.AzureVnetTwoInterfaceNodeType{}
							azNodesMapStrToI := set.(map[string]interface{})

							if w, ok := azNodesMapStrToI["azure_az"]; ok && !isIntfNil(w) {
								azNodes[i].AzureAz = w.(string)
							}

							if v, ok := azNodesMapStrToI["inside_subnet"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								insideSubnet := &ves_io_schema_views.AzureSubnetChoiceType{}
								azNodes[i].InsideSubnet = insideSubnet
								for _, set := range sl {
									if set != nil {
										insideSubnetMapStrToI := set.(map[string]interface{})

										choiceTypeFound := false

										if v, ok := insideSubnetMapStrToI["subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_Subnet{}
											choiceInt.Subnet = &ves_io_schema_views.AzureSubnetType{}
											insideSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													resourceGroupChoiceTypeFound := false

													if v, ok := cs["subnet_resource_grp"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true
														resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_SubnetResourceGrp{}

														choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt

														resourceGroupChoiceInt.SubnetResourceGrp = v.(string)

													}

													if v, ok := cs["vnet_resource_group"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true

														if v.(bool) {
															resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_VnetResourceGroup{}
															resourceGroupChoiceInt.VnetResourceGroup = &ves_io_schema.Empty{}
															choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt
														}

													}

													if v, ok := cs["subnet_name"]; ok && !isIntfNil(v) {

														choiceInt.Subnet.SubnetName = v.(string)

													}

												}
											}

										}

										if v, ok := insideSubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_SubnetParam{}
											choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
											insideSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv4 = v.(string)

													}

													if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv6 = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if v, ok := azNodesMapStrToI["outside_subnet"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								outsideSubnet := &ves_io_schema_views.AzureSubnetChoiceType{}
								azNodes[i].OutsideSubnet = outsideSubnet
								for _, set := range sl {
									if set != nil {
										outsideSubnetMapStrToI := set.(map[string]interface{})

										choiceTypeFound := false

										if v, ok := outsideSubnetMapStrToI["subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_Subnet{}
											choiceInt.Subnet = &ves_io_schema_views.AzureSubnetType{}
											outsideSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													resourceGroupChoiceTypeFound := false

													if v, ok := cs["subnet_resource_grp"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true
														resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_SubnetResourceGrp{}

														choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt

														resourceGroupChoiceInt.SubnetResourceGrp = v.(string)

													}

													if v, ok := cs["vnet_resource_group"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true

														if v.(bool) {
															resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_VnetResourceGroup{}
															resourceGroupChoiceInt.VnetResourceGroup = &ves_io_schema.Empty{}
															choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt
														}

													}

													if v, ok := cs["subnet_name"]; ok && !isIntfNil(v) {

														choiceInt.Subnet.SubnetName = v.(string)

													}

												}
											}

										}

										if v, ok := outsideSubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_SubnetParam{}
											choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
											outsideSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv4 = v.(string)

													}

													if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv6 = v.(string)

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				dcClusterGroupChoiceTypeFound := false

				if v, ok := cs["dc_cluster_group_inside_vn"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

					dcClusterGroupChoiceTypeFound = true
					dcClusterGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwReplaceType_DcClusterGroupInsideVn{}
					dcClusterGroupChoiceInt.DcClusterGroupInsideVn = &ves_io_schema_views.ObjectRefType{}
					siteTypeInt.IngressEgressGw.DcClusterGroupChoice = dcClusterGroupChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupInsideVn.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupInsideVn.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupInsideVn.Tenant = v.(string)

							}

						}
					}

				}

				if v, ok := cs["dc_cluster_group_outside_vn"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

					dcClusterGroupChoiceTypeFound = true
					dcClusterGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwReplaceType_DcClusterGroupOutsideVn{}
					dcClusterGroupChoiceInt.DcClusterGroupOutsideVn = &ves_io_schema_views.ObjectRefType{}
					siteTypeInt.IngressEgressGw.DcClusterGroupChoice = dcClusterGroupChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupOutsideVn.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupOutsideVn.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupOutsideVn.Tenant = v.(string)

							}

						}
					}

				}

				if v, ok := cs["no_dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

					dcClusterGroupChoiceTypeFound = true

					if v.(bool) {
						dcClusterGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwReplaceType_NoDcClusterGroup{}
						dcClusterGroupChoiceInt.NoDcClusterGroup = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGw.DcClusterGroupChoice = dcClusterGroupChoiceInt
					}

				}

				forwardProxyChoiceTypeFound := false

				if v, ok := cs["active_forward_proxy_policies"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true
					forwardProxyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwReplaceType_ActiveForwardProxyPolicies{}
					forwardProxyChoiceInt.ActiveForwardProxyPolicies = &ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType{}
					siteTypeInt.IngressEgressGw.ForwardProxyChoice = forwardProxyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["forward_proxy_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								forwardProxyPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								forwardProxyChoiceInt.ActiveForwardProxyPolicies.ForwardProxyPolicies = forwardProxyPoliciesInt
								for i, ps := range sl {

									fppMapToStrVal := ps.(map[string]interface{})
									forwardProxyPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := fppMapToStrVal["name"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Name = v.(string)
									}

									if v, ok := fppMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := fppMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["forward_proxy_allow_all"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true

					if v.(bool) {
						forwardProxyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwReplaceType_ForwardProxyAllowAll{}
						forwardProxyChoiceInt.ForwardProxyAllowAll = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGw.ForwardProxyChoice = forwardProxyChoiceInt
					}

				}

				if v, ok := cs["no_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true

					if v.(bool) {
						forwardProxyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwReplaceType_NoForwardProxy{}
						forwardProxyChoiceInt.NoForwardProxy = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGw.ForwardProxyChoice = forwardProxyChoiceInt
					}

				}

				globalNetworkChoiceTypeFound := false

				if v, ok := cs["global_network_list"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

					globalNetworkChoiceTypeFound = true
					globalNetworkChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwReplaceType_GlobalNetworkList{}
					globalNetworkChoiceInt.GlobalNetworkList = &ves_io_schema_views.GlobalNetworkConnectionListType{}
					siteTypeInt.IngressEgressGw.GlobalNetworkChoice = globalNetworkChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["global_network_connections"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								globalNetworkConnections := make([]*ves_io_schema_views.GlobalNetworkConnectionType, len(sl))
								globalNetworkChoiceInt.GlobalNetworkList.GlobalNetworkConnections = globalNetworkConnections
								for i, set := range sl {
									if set != nil {
										globalNetworkConnections[i] = &ves_io_schema_views.GlobalNetworkConnectionType{}
										globalNetworkConnectionsMapStrToI := set.(map[string]interface{})

										connectionChoiceTypeFound := false

										if v, ok := globalNetworkConnectionsMapStrToI["sli_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

											connectionChoiceTypeFound = true
											connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SliToGlobalDr{}
											connectionChoiceInt.SliToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
											globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														globalVn := &ves_io_schema_views.ObjectRefType{}
														connectionChoiceInt.SliToGlobalDr.GlobalVn = globalVn
														for _, set := range sl {
															if set != nil {
																globalVnMapStrToI := set.(map[string]interface{})

																if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
																	globalVn.Name = w.(string)
																}

																if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
																	globalVn.Namespace = w.(string)
																}

																if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
																	globalVn.Tenant = w.(string)
																}

															}
														}

													}

												}
											}

										}

										if v, ok := globalNetworkConnectionsMapStrToI["slo_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

											connectionChoiceTypeFound = true
											connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SloToGlobalDr{}
											connectionChoiceInt.SloToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
											globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														globalVn := &ves_io_schema_views.ObjectRefType{}
														connectionChoiceInt.SloToGlobalDr.GlobalVn = globalVn
														for _, set := range sl {
															if set != nil {
																globalVnMapStrToI := set.(map[string]interface{})

																if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
																	globalVn.Name = w.(string)
																}

																if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
																	globalVn.Namespace = w.(string)
																}

																if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
																	globalVn.Tenant = w.(string)
																}

															}
														}

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["no_global_network"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

					globalNetworkChoiceTypeFound = true

					if v.(bool) {
						globalNetworkChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwReplaceType_NoGlobalNetwork{}
						globalNetworkChoiceInt.NoGlobalNetwork = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGw.GlobalNetworkChoice = globalNetworkChoiceInt
					}

				}

				hubChoiceTypeFound := false

				if v, ok := cs["hub"]; ok && !isIntfNil(v) && !hubChoiceTypeFound {

					hubChoiceTypeFound = true
					hubChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwReplaceType_Hub{}
					hubChoiceInt.Hub = &ves_io_schema_views_azure_vnet_site.AzureHubVnetType{}
					siteTypeInt.IngressEgressGw.HubChoice = hubChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							expressRouteChoiceTypeFound := false

							if v, ok := cs["express_route_disabled"]; ok && !isIntfNil(v) && !expressRouteChoiceTypeFound {

								expressRouteChoiceTypeFound = true

								if v.(bool) {
									expressRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureHubVnetType_ExpressRouteDisabled{}
									expressRouteChoiceInt.ExpressRouteDisabled = &ves_io_schema.Empty{}
									hubChoiceInt.Hub.ExpressRouteChoice = expressRouteChoiceInt
								}

							}

							if v, ok := cs["express_route_enabled"]; ok && !isIntfNil(v) && !expressRouteChoiceTypeFound {

								expressRouteChoiceTypeFound = true
								expressRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureHubVnetType_ExpressRouteEnabled{}
								expressRouteChoiceInt.ExpressRouteEnabled = &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType{}
								hubChoiceInt.Hub.ExpressRouteChoice = expressRouteChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										asnChoiceTypeFound := false

										if v, ok := cs["auto_asn"]; ok && !isIntfNil(v) && !asnChoiceTypeFound {

											asnChoiceTypeFound = true

											if v.(bool) {
												asnChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_AutoAsn{}
												asnChoiceInt.AutoAsn = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.AsnChoice = asnChoiceInt
											}

										}

										if v, ok := cs["custom_asn"]; ok && !isIntfNil(v) && !asnChoiceTypeFound {

											asnChoiceTypeFound = true
											asnChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_CustomAsn{}

											expressRouteChoiceInt.ExpressRouteEnabled.AsnChoice = asnChoiceInt

											asnChoiceInt.CustomAsn = uint32(v.(int))

										}

										if v, ok := cs["connections"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											connections := make([]*ves_io_schema_views_azure_vnet_site.ExpressRouteConnectionType, len(sl))
											expressRouteChoiceInt.ExpressRouteEnabled.Connections = connections
											for i, set := range sl {
												if set != nil {
													connections[i] = &ves_io_schema_views_azure_vnet_site.ExpressRouteConnectionType{}
													connectionsMapStrToI := set.(map[string]interface{})

													if v, ok := connectionsMapStrToI["metadata"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														metadata := &ves_io_schema.MessageMetaType{}
														connections[i].Metadata = metadata
														for _, set := range sl {
															if set != nil {
																metadataMapStrToI := set.(map[string]interface{})

																if w, ok := metadataMapStrToI["description"]; ok && !isIntfNil(w) {
																	metadata.Description = w.(string)
																}

																if w, ok := metadataMapStrToI["name"]; ok && !isIntfNil(w) {
																	metadata.Name = w.(string)
																}

															}
														}

													}

													subscriptionChoiceTypeFound := false

													if v, ok := connectionsMapStrToI["circuit_id"]; ok && !isIntfNil(v) && !subscriptionChoiceTypeFound {

														subscriptionChoiceTypeFound = true
														subscriptionChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConnectionType_CircuitId{}

														connections[i].SubscriptionChoice = subscriptionChoiceInt

														subscriptionChoiceInt.CircuitId = v.(string)

													}

													if v, ok := connectionsMapStrToI["other_subscription"]; ok && !isIntfNil(v) && !subscriptionChoiceTypeFound {

														subscriptionChoiceTypeFound = true
														subscriptionChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConnectionType_OtherSubscription{}
														subscriptionChoiceInt.OtherSubscription = &ves_io_schema_views_azure_vnet_site.ExpressRouteOtherSubscriptionConnection{}
														connections[i].SubscriptionChoice = subscriptionChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["authorized_key"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	authorizedKey := &ves_io_schema.SecretType{}
																	subscriptionChoiceInt.OtherSubscription.AuthorizedKey = authorizedKey
																	for _, set := range sl {
																		if set != nil {
																			authorizedKeyMapStrToI := set.(map[string]interface{})

																			secretInfoOneofTypeFound := false

																			if v, ok := authorizedKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																				secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																				authorizedKey.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																						}

																						if v, ok := cs["location"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																						}

																						if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := authorizedKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																				secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																				authorizedKey.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																						}

																						if v, ok := cs["url"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["circuit_id"]; ok && !isIntfNil(v) {

																	subscriptionChoiceInt.OtherSubscription.CircuitId = v.(string)

																}

															}
														}

													}

													if w, ok := connectionsMapStrToI["weight"]; ok && !isIntfNil(w) {
														connections[i].Weight = uint32(w.(int))
													}

												}
											}

										}

										connectivityOptionsTypeFound := false

										if v, ok := cs["site_registration_over_express_route"]; ok && !isIntfNil(v) && !connectivityOptionsTypeFound {

											connectivityOptionsTypeFound = true
											connectivityOptionsInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_SiteRegistrationOverExpressRoute{}
											connectivityOptionsInt.SiteRegistrationOverExpressRoute = &ves_io_schema_views.CloudLinkADNType{}
											expressRouteChoiceInt.ExpressRouteEnabled.ConnectivityOptions = connectivityOptionsInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["cloudlink_network_name"]; ok && !isIntfNil(v) {

														connectivityOptionsInt.SiteRegistrationOverExpressRoute.CloudlinkNetworkName = v.(string)

													}

												}
											}

										}

										if v, ok := cs["site_registration_over_internet"]; ok && !isIntfNil(v) && !connectivityOptionsTypeFound {

											connectivityOptionsTypeFound = true

											if v.(bool) {
												connectivityOptionsInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_SiteRegistrationOverInternet{}
												connectivityOptionsInt.SiteRegistrationOverInternet = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.ConnectivityOptions = connectivityOptionsInt
											}

										}

										if v, ok := cs["gateway_subnet"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											gatewaySubnet := &ves_io_schema_views.AzureSubnetChoiceWithAutoType{}
											expressRouteChoiceInt.ExpressRouteEnabled.GatewaySubnet = gatewaySubnet
											for _, set := range sl {
												if set != nil {
													gatewaySubnetMapStrToI := set.(map[string]interface{})

													choiceTypeFound := false

													if v, ok := gatewaySubnetMapStrToI["auto"]; ok && !isIntfNil(v) && !choiceTypeFound {

														choiceTypeFound = true

														if v.(bool) {
															choiceInt := &ves_io_schema_views.AzureSubnetChoiceWithAutoType_Auto{}
															choiceInt.Auto = &ves_io_schema.Empty{}
															gatewaySubnet.Choice = choiceInt
														}

													}

													if v, ok := gatewaySubnetMapStrToI["subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

														choiceTypeFound = true
														choiceInt := &ves_io_schema_views.AzureSubnetChoiceWithAutoType_Subnet{}
														choiceInt.Subnet = &ves_io_schema_views.AzureSpecialSubnetType{}
														gatewaySubnet.Choice = choiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																resourceGroupChoiceTypeFound := false

																if v, ok := cs["subnet_resource_grp"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

																	resourceGroupChoiceTypeFound = true
																	resourceGroupChoiceInt := &ves_io_schema_views.AzureSpecialSubnetType_SubnetResourceGrp{}

																	choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt

																	resourceGroupChoiceInt.SubnetResourceGrp = v.(string)

																}

																if v, ok := cs["vnet_resource_group"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

																	resourceGroupChoiceTypeFound = true

																	if v.(bool) {
																		resourceGroupChoiceInt := &ves_io_schema_views.AzureSpecialSubnetType_VnetResourceGroup{}
																		resourceGroupChoiceInt.VnetResourceGroup = &ves_io_schema.Empty{}
																		choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt
																	}

																}

															}
														}

													}

													if v, ok := gatewaySubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

														choiceTypeFound = true
														choiceInt := &ves_io_schema_views.AzureSubnetChoiceWithAutoType_SubnetParam{}
														choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
														gatewaySubnet.Choice = choiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

																	choiceInt.SubnetParam.Ipv4 = v.(string)

																}

																if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

																	choiceInt.SubnetParam.Ipv6 = v.(string)

																}

															}
														}

													}

												}
											}

										}

										if v, ok := cs["route_server_subnet"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											routeServerSubnet := &ves_io_schema_views.AzureSubnetChoiceWithAutoType{}
											expressRouteChoiceInt.ExpressRouteEnabled.RouteServerSubnet = routeServerSubnet
											for _, set := range sl {
												if set != nil {
													routeServerSubnetMapStrToI := set.(map[string]interface{})

													choiceTypeFound := false

													if v, ok := routeServerSubnetMapStrToI["auto"]; ok && !isIntfNil(v) && !choiceTypeFound {

														choiceTypeFound = true

														if v.(bool) {
															choiceInt := &ves_io_schema_views.AzureSubnetChoiceWithAutoType_Auto{}
															choiceInt.Auto = &ves_io_schema.Empty{}
															routeServerSubnet.Choice = choiceInt
														}

													}

													if v, ok := routeServerSubnetMapStrToI["subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

														choiceTypeFound = true
														choiceInt := &ves_io_schema_views.AzureSubnetChoiceWithAutoType_Subnet{}
														choiceInt.Subnet = &ves_io_schema_views.AzureSpecialSubnetType{}
														routeServerSubnet.Choice = choiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																resourceGroupChoiceTypeFound := false

																if v, ok := cs["subnet_resource_grp"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

																	resourceGroupChoiceTypeFound = true
																	resourceGroupChoiceInt := &ves_io_schema_views.AzureSpecialSubnetType_SubnetResourceGrp{}

																	choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt

																	resourceGroupChoiceInt.SubnetResourceGrp = v.(string)

																}

																if v, ok := cs["vnet_resource_group"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

																	resourceGroupChoiceTypeFound = true

																	if v.(bool) {
																		resourceGroupChoiceInt := &ves_io_schema_views.AzureSpecialSubnetType_VnetResourceGroup{}
																		resourceGroupChoiceInt.VnetResourceGroup = &ves_io_schema.Empty{}
																		choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt
																	}

																}

															}
														}

													}

													if v, ok := routeServerSubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

														choiceTypeFound = true
														choiceInt := &ves_io_schema_views.AzureSubnetChoiceWithAutoType_SubnetParam{}
														choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
														routeServerSubnet.Choice = choiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

																	choiceInt.SubnetParam.Ipv4 = v.(string)

																}

																if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

																	choiceInt.SubnetParam.Ipv6 = v.(string)

																}

															}
														}

													}

												}
											}

										}

										skuChoiceTypeFound := false

										if v, ok := cs["sku_ergw1az"]; ok && !isIntfNil(v) && !skuChoiceTypeFound {

											skuChoiceTypeFound = true

											if v.(bool) {
												skuChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_SkuErgw1Az{}
												skuChoiceInt.SkuErgw1Az = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.SkuChoice = skuChoiceInt
											}

										}

										if v, ok := cs["sku_ergw2az"]; ok && !isIntfNil(v) && !skuChoiceTypeFound {

											skuChoiceTypeFound = true

											if v.(bool) {
												skuChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_SkuErgw2Az{}
												skuChoiceInt.SkuErgw2Az = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.SkuChoice = skuChoiceInt
											}

										}

										if v, ok := cs["sku_high_perf"]; ok && !isIntfNil(v) && !skuChoiceTypeFound {

											skuChoiceTypeFound = true

											if v.(bool) {
												skuChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_SkuHighPerf{}
												skuChoiceInt.SkuHighPerf = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.SkuChoice = skuChoiceInt
											}

										}

										if v, ok := cs["sku_standard"]; ok && !isIntfNil(v) && !skuChoiceTypeFound {

											skuChoiceTypeFound = true

											if v.(bool) {
												skuChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_SkuStandard{}
												skuChoiceInt.SkuStandard = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.SkuChoice = skuChoiceInt
											}

										}

										spokeVnetRoutesTypeFound := false

										if v, ok := cs["advertise_to_route_server"]; ok && !isIntfNil(v) && !spokeVnetRoutesTypeFound {

											spokeVnetRoutesTypeFound = true

											if v.(bool) {
												spokeVnetRoutesInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_AdvertiseToRouteServer{}
												spokeVnetRoutesInt.AdvertiseToRouteServer = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.SpokeVnetRoutes = spokeVnetRoutesInt
											}

										}

										if v, ok := cs["do_not_advertise_to_route_server"]; ok && !isIntfNil(v) && !spokeVnetRoutesTypeFound {

											spokeVnetRoutesTypeFound = true

											if v.(bool) {
												spokeVnetRoutesInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_DoNotAdvertiseToRouteServer{}
												spokeVnetRoutesInt.DoNotAdvertiseToRouteServer = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.SpokeVnetRoutes = spokeVnetRoutesInt
											}

										}

									}
								}

							}

							if v, ok := cs["spoke_vnets"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								spokeVnets := make([]*ves_io_schema_views_azure_vnet_site.VnetPeeringType, len(sl))
								hubChoiceInt.Hub.SpokeVnets = spokeVnets
								for i, set := range sl {
									if set != nil {
										spokeVnets[i] = &ves_io_schema_views_azure_vnet_site.VnetPeeringType{}
										spokeVnetsMapStrToI := set.(map[string]interface{})

										if w, ok := spokeVnetsMapStrToI["labels"]; ok && !isIntfNil(w) {
											ms := map[string]string{}
											for k, v := range w.(map[string]interface{}) {
												ms[k] = v.(string)
											}
											spokeVnets[i].Labels = ms
										}

										routingChoiceTypeFound := false

										if v, ok := spokeVnetsMapStrToI["auto"]; ok && !isIntfNil(v) && !routingChoiceTypeFound {

											routingChoiceTypeFound = true

											if v.(bool) {
												routingChoiceInt := &ves_io_schema_views_azure_vnet_site.VnetPeeringType_Auto{}
												routingChoiceInt.Auto = &ves_io_schema.Empty{}
												spokeVnets[i].RoutingChoice = routingChoiceInt
											}

										}

										if v, ok := spokeVnetsMapStrToI["manual"]; ok && !isIntfNil(v) && !routingChoiceTypeFound {

											routingChoiceTypeFound = true

											if v.(bool) {
												routingChoiceInt := &ves_io_schema_views_azure_vnet_site.VnetPeeringType_Manual{}
												routingChoiceInt.Manual = &ves_io_schema.Empty{}
												spokeVnets[i].RoutingChoice = routingChoiceInt
											}

										}

										if v, ok := spokeVnetsMapStrToI["vnet"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											vnet := &ves_io_schema_views.AzureVnetType{}
											spokeVnets[i].Vnet = vnet
											for _, set := range sl {
												if set != nil {
													vnetMapStrToI := set.(map[string]interface{})

													if w, ok := vnetMapStrToI["resource_group"]; ok && !isIntfNil(w) {
														vnet.ResourceGroup = w.(string)
													}

													routingTypeTypeFound := false

													if v, ok := vnetMapStrToI["f5_orchestrated_routing"]; ok && !isIntfNil(v) && !routingTypeTypeFound {

														routingTypeTypeFound = true

														if v.(bool) {
															routingTypeInt := &ves_io_schema_views.AzureVnetType_F5OrchestratedRouting{}
															routingTypeInt.F5OrchestratedRouting = &ves_io_schema.Empty{}
															vnet.RoutingType = routingTypeInt
														}

													}

													if v, ok := vnetMapStrToI["manual_routing"]; ok && !isIntfNil(v) && !routingTypeTypeFound {

														routingTypeTypeFound = true

														if v.(bool) {
															routingTypeInt := &ves_io_schema_views.AzureVnetType_ManualRouting{}
															routingTypeInt.ManualRouting = &ves_io_schema.Empty{}
															vnet.RoutingType = routingTypeInt
														}

													}

													if w, ok := vnetMapStrToI["vnet_name"]; ok && !isIntfNil(w) {
														vnet.VnetName = w.(string)
													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["not_hub"]; ok && !isIntfNil(v) && !hubChoiceTypeFound {

					hubChoiceTypeFound = true

					if v.(bool) {
						hubChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwReplaceType_NotHub{}
						hubChoiceInt.NotHub = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGw.HubChoice = hubChoiceInt
					}

				}

				insideStaticRouteChoiceTypeFound := false

				if v, ok := cs["inside_static_routes"]; ok && !isIntfNil(v) && !insideStaticRouteChoiceTypeFound {

					insideStaticRouteChoiceTypeFound = true
					insideStaticRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwReplaceType_InsideStaticRoutes{}
					insideStaticRouteChoiceInt.InsideStaticRoutes = &ves_io_schema_views.SiteStaticRoutesListType{}
					siteTypeInt.IngressEgressGw.InsideStaticRouteChoice = insideStaticRouteChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_route_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRouteList := make([]*ves_io_schema_views.SiteStaticRoutesType, len(sl))
								insideStaticRouteChoiceInt.InsideStaticRoutes.StaticRouteList = staticRouteList
								for i, set := range sl {
									if set != nil {
										staticRouteList[i] = &ves_io_schema_views.SiteStaticRoutesType{}
										staticRouteListMapStrToI := set.(map[string]interface{})

										configModeChoiceTypeFound := false

										if v, ok := staticRouteListMapStrToI["custom_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_CustomStaticRoute{}
											configModeChoiceInt.CustomStaticRoute = &ves_io_schema.StaticRouteType{}
											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["attrs"]; ok && !isIntfNil(v) {

														attrsList := []ves_io_schema.RouteAttrType{}
														for _, j := range v.([]interface{}) {
															if j == nil {
																return fmt.Errorf("please provide valid non-empty enum value of field attrs")
															}
															attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
														}
														configModeChoiceInt.CustomStaticRoute.Attrs = attrsList

													}

													if v, ok := cs["labels"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														configModeChoiceInt.CustomStaticRoute.Labels = ms
													}

													if v, ok := cs["nexthop"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														nexthop := &ves_io_schema.NextHopType{}
														configModeChoiceInt.CustomStaticRoute.Nexthop = nexthop
														for _, set := range sl {
															if set != nil {
																nexthopMapStrToI := set.(map[string]interface{})

																if v, ok := nexthopMapStrToI["interface"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	intfInt := make([]*ves_io_schema.ObjectRefType, len(sl))
																	nexthop.Interface = intfInt
																	for i, ps := range sl {

																		iMapToStrVal := ps.(map[string]interface{})
																		intfInt[i] = &ves_io_schema.ObjectRefType{}

																		intfInt[i].Kind = "network_interface"

																		if v, ok := iMapToStrVal["name"]; ok && !isIntfNil(v) {
																			intfInt[i].Name = v.(string)
																		}

																		if v, ok := iMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																			intfInt[i].Namespace = v.(string)
																		}

																		if v, ok := iMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																			intfInt[i].Tenant = v.(string)
																		}

																		if v, ok := iMapToStrVal["uid"]; ok && !isIntfNil(v) {
																			intfInt[i].Uid = v.(string)
																		}

																	}

																}

																if v, ok := nexthopMapStrToI["nexthop_address"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	nexthopAddress := &ves_io_schema.IpAddressType{}
																	nexthop.NexthopAddress = nexthopAddress
																	for _, set := range sl {
																		if set != nil {
																			nexthopAddressMapStrToI := set.(map[string]interface{})

																			verTypeFound := false

																			if v, ok := nexthopAddressMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv4{}
																				verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv4.Addr = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := nexthopAddressMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv6{}
																				verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv6.Addr = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := nexthopMapStrToI["type"]; ok && !isIntfNil(v) {

																	nexthop.Type = ves_io_schema.NextHopTypes(ves_io_schema.NextHopTypes_value[v.(string)])

																}

															}
														}

													}

													if v, ok := cs["subnets"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														subnets := make([]*ves_io_schema.IpSubnetType, len(sl))
														configModeChoiceInt.CustomStaticRoute.Subnets = subnets
														for i, set := range sl {
															if set != nil {
																subnets[i] = &ves_io_schema.IpSubnetType{}
																subnetsMapStrToI := set.(map[string]interface{})

																verTypeFound := false

																if v, ok := subnetsMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv4{}
																	verInt.Ipv4 = &ves_io_schema.Ipv4SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Prefix = v.(string)

																			}

																		}
																	}

																}

																if v, ok := subnetsMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv6{}
																	verInt.Ipv6 = &ves_io_schema.Ipv6SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Prefix = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

												}
											}

										}

										if v, ok := staticRouteListMapStrToI["simple_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_SimpleStaticRoute{}

											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											configModeChoiceInt.SimpleStaticRoute = v.(string)

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["no_inside_static_routes"]; ok && !isIntfNil(v) && !insideStaticRouteChoiceTypeFound {

					insideStaticRouteChoiceTypeFound = true

					if v.(bool) {
						insideStaticRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwReplaceType_NoInsideStaticRoutes{}
						insideStaticRouteChoiceInt.NoInsideStaticRoutes = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGw.InsideStaticRouteChoice = insideStaticRouteChoiceInt
					}

				}

				networkPolicyChoiceTypeFound := false

				if v, ok := cs["active_enhanced_firewall_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true
					networkPolicyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwReplaceType_ActiveEnhancedFirewallPolicies{}
					networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies = &ves_io_schema_network_firewall.ActiveEnhancedFirewallPoliciesType{}
					siteTypeInt.IngressEgressGw.NetworkPolicyChoice = networkPolicyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["enhanced_firewall_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								enhancedFirewallPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies.EnhancedFirewallPolicies = enhancedFirewallPoliciesInt
								for i, ps := range sl {

									efpMapToStrVal := ps.(map[string]interface{})
									enhancedFirewallPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := efpMapToStrVal["name"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Name = v.(string)
									}

									if v, ok := efpMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := efpMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["active_network_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true
					networkPolicyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwReplaceType_ActiveNetworkPolicies{}
					networkPolicyChoiceInt.ActiveNetworkPolicies = &ves_io_schema_network_firewall.ActiveNetworkPoliciesType{}
					siteTypeInt.IngressEgressGw.NetworkPolicyChoice = networkPolicyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["network_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								networkPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								networkPolicyChoiceInt.ActiveNetworkPolicies.NetworkPolicies = networkPoliciesInt
								for i, ps := range sl {

									npMapToStrVal := ps.(map[string]interface{})
									networkPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := npMapToStrVal["name"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Name = v.(string)
									}

									if v, ok := npMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := npMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["no_network_policy"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true

					if v.(bool) {
						networkPolicyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwReplaceType_NoNetworkPolicy{}
						networkPolicyChoiceInt.NoNetworkPolicy = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGw.NetworkPolicyChoice = networkPolicyChoiceInt
					}

				}

				outsideStaticRouteChoiceTypeFound := false

				if v, ok := cs["no_outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

					outsideStaticRouteChoiceTypeFound = true

					if v.(bool) {
						outsideStaticRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwReplaceType_NoOutsideStaticRoutes{}
						outsideStaticRouteChoiceInt.NoOutsideStaticRoutes = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGw.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt
					}

				}

				if v, ok := cs["outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

					outsideStaticRouteChoiceTypeFound = true
					outsideStaticRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwReplaceType_OutsideStaticRoutes{}
					outsideStaticRouteChoiceInt.OutsideStaticRoutes = &ves_io_schema_views.SiteStaticRoutesListType{}
					siteTypeInt.IngressEgressGw.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_route_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRouteList := make([]*ves_io_schema_views.SiteStaticRoutesType, len(sl))
								outsideStaticRouteChoiceInt.OutsideStaticRoutes.StaticRouteList = staticRouteList
								for i, set := range sl {
									if set != nil {
										staticRouteList[i] = &ves_io_schema_views.SiteStaticRoutesType{}
										staticRouteListMapStrToI := set.(map[string]interface{})

										configModeChoiceTypeFound := false

										if v, ok := staticRouteListMapStrToI["custom_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_CustomStaticRoute{}
											configModeChoiceInt.CustomStaticRoute = &ves_io_schema.StaticRouteType{}
											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["attrs"]; ok && !isIntfNil(v) {

														attrsList := []ves_io_schema.RouteAttrType{}
														for _, j := range v.([]interface{}) {
															if j == nil {
																return fmt.Errorf("please provide valid non-empty enum value of field attrs")
															}
															attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
														}
														configModeChoiceInt.CustomStaticRoute.Attrs = attrsList

													}

													if v, ok := cs["labels"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														configModeChoiceInt.CustomStaticRoute.Labels = ms
													}

													if v, ok := cs["nexthop"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														nexthop := &ves_io_schema.NextHopType{}
														configModeChoiceInt.CustomStaticRoute.Nexthop = nexthop
														for _, set := range sl {
															if set != nil {
																nexthopMapStrToI := set.(map[string]interface{})

																if v, ok := nexthopMapStrToI["interface"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	intfInt := make([]*ves_io_schema.ObjectRefType, len(sl))
																	nexthop.Interface = intfInt
																	for i, ps := range sl {

																		iMapToStrVal := ps.(map[string]interface{})
																		intfInt[i] = &ves_io_schema.ObjectRefType{}

																		intfInt[i].Kind = "network_interface"

																		if v, ok := iMapToStrVal["name"]; ok && !isIntfNil(v) {
																			intfInt[i].Name = v.(string)
																		}

																		if v, ok := iMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																			intfInt[i].Namespace = v.(string)
																		}

																		if v, ok := iMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																			intfInt[i].Tenant = v.(string)
																		}

																		if v, ok := iMapToStrVal["uid"]; ok && !isIntfNil(v) {
																			intfInt[i].Uid = v.(string)
																		}

																	}

																}

																if v, ok := nexthopMapStrToI["nexthop_address"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	nexthopAddress := &ves_io_schema.IpAddressType{}
																	nexthop.NexthopAddress = nexthopAddress
																	for _, set := range sl {
																		if set != nil {
																			nexthopAddressMapStrToI := set.(map[string]interface{})

																			verTypeFound := false

																			if v, ok := nexthopAddressMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv4{}
																				verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv4.Addr = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := nexthopAddressMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv6{}
																				verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv6.Addr = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := nexthopMapStrToI["type"]; ok && !isIntfNil(v) {

																	nexthop.Type = ves_io_schema.NextHopTypes(ves_io_schema.NextHopTypes_value[v.(string)])

																}

															}
														}

													}

													if v, ok := cs["subnets"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														subnets := make([]*ves_io_schema.IpSubnetType, len(sl))
														configModeChoiceInt.CustomStaticRoute.Subnets = subnets
														for i, set := range sl {
															if set != nil {
																subnets[i] = &ves_io_schema.IpSubnetType{}
																subnetsMapStrToI := set.(map[string]interface{})

																verTypeFound := false

																if v, ok := subnetsMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv4{}
																	verInt.Ipv4 = &ves_io_schema.Ipv4SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Prefix = v.(string)

																			}

																		}
																	}

																}

																if v, ok := subnetsMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv6{}
																	verInt.Ipv6 = &ves_io_schema.Ipv6SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Prefix = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

												}
											}

										}

										if v, ok := staticRouteListMapStrToI["simple_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_SimpleStaticRoute{}

											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											configModeChoiceInt.SimpleStaticRoute = v.(string)

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["performance_enhancement_mode"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					performanceEnhancementMode := &ves_io_schema_views.PerformanceEnhancementModeType{}
					siteTypeInt.IngressEgressGw.PerformanceEnhancementMode = performanceEnhancementMode
					for _, set := range sl {
						if set != nil {
							performanceEnhancementModeMapStrToI := set.(map[string]interface{})

							perfModeChoiceTypeFound := false

							if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l3_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

								perfModeChoiceTypeFound = true
								perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL3Enhanced{}
								perfModeChoiceInt.PerfModeL3Enhanced = &ves_io_schema_views.L3PerformanceEnhancementType{}
								performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										perfModeChoiceTypeFound := false

										if v, ok := cs["jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

											perfModeChoiceTypeFound = true

											if v.(bool) {
												perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_Jumbo{}
												perfModeChoiceIntNew.Jumbo = &ves_io_schema.Empty{}
												perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
											}

										}

										if v, ok := cs["no_jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

											perfModeChoiceTypeFound = true

											if v.(bool) {
												perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_NoJumbo{}
												perfModeChoiceIntNew.NoJumbo = &ves_io_schema.Empty{}
												perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
											}

										}

									}
								}

							}

							if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l7_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

								perfModeChoiceTypeFound = true

								if v.(bool) {
									perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL7Enhanced{}
									perfModeChoiceInt.PerfModeL7Enhanced = &ves_io_schema.Empty{}
									performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt
								}

							}

						}
					}

				}

				siteMeshGroupChoiceTypeFound := false

				if v, ok := cs["sm_connection_public_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

					siteMeshGroupChoiceTypeFound = true

					if v.(bool) {
						siteMeshGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwReplaceType_SmConnectionPublicIp{}
						siteMeshGroupChoiceInt.SmConnectionPublicIp = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGw.SiteMeshGroupChoice = siteMeshGroupChoiceInt
					}

				}

				if v, ok := cs["sm_connection_pvt_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

					siteMeshGroupChoiceTypeFound = true

					if v.(bool) {
						siteMeshGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwReplaceType_SmConnectionPvtIp{}
						siteMeshGroupChoiceInt.SmConnectionPvtIp = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGw.SiteMeshGroupChoice = siteMeshGroupChoiceInt
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("ingress_egress_gw_ar"); ok && !isIntfNil(v) && !siteTypeTypeFound {

		siteTypeTypeFound = true
		siteTypeInt := &ves_io_schema_views_azure_vnet_site.ReplaceSpecType_IngressEgressGwAr{}
		siteTypeInt.IngressEgressGwAr = &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARReplaceType{}
		updateSpec.SiteType = siteTypeInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				dcClusterGroupChoiceTypeFound := false

				if v, ok := cs["dc_cluster_group_inside_vn"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

					dcClusterGroupChoiceTypeFound = true
					dcClusterGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARReplaceType_DcClusterGroupInsideVn{}
					dcClusterGroupChoiceInt.DcClusterGroupInsideVn = &ves_io_schema_views.ObjectRefType{}
					siteTypeInt.IngressEgressGwAr.DcClusterGroupChoice = dcClusterGroupChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupInsideVn.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupInsideVn.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupInsideVn.Tenant = v.(string)

							}

						}
					}

				}

				if v, ok := cs["dc_cluster_group_outside_vn"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

					dcClusterGroupChoiceTypeFound = true
					dcClusterGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARReplaceType_DcClusterGroupOutsideVn{}
					dcClusterGroupChoiceInt.DcClusterGroupOutsideVn = &ves_io_schema_views.ObjectRefType{}
					siteTypeInt.IngressEgressGwAr.DcClusterGroupChoice = dcClusterGroupChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupOutsideVn.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupOutsideVn.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupOutsideVn.Tenant = v.(string)

							}

						}
					}

				}

				if v, ok := cs["no_dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

					dcClusterGroupChoiceTypeFound = true

					if v.(bool) {
						dcClusterGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARReplaceType_NoDcClusterGroup{}
						dcClusterGroupChoiceInt.NoDcClusterGroup = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGwAr.DcClusterGroupChoice = dcClusterGroupChoiceInt
					}

				}

				forwardProxyChoiceTypeFound := false

				if v, ok := cs["active_forward_proxy_policies"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true
					forwardProxyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARReplaceType_ActiveForwardProxyPolicies{}
					forwardProxyChoiceInt.ActiveForwardProxyPolicies = &ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType{}
					siteTypeInt.IngressEgressGwAr.ForwardProxyChoice = forwardProxyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["forward_proxy_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								forwardProxyPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								forwardProxyChoiceInt.ActiveForwardProxyPolicies.ForwardProxyPolicies = forwardProxyPoliciesInt
								for i, ps := range sl {

									fppMapToStrVal := ps.(map[string]interface{})
									forwardProxyPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := fppMapToStrVal["name"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Name = v.(string)
									}

									if v, ok := fppMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := fppMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["forward_proxy_allow_all"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true

					if v.(bool) {
						forwardProxyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARReplaceType_ForwardProxyAllowAll{}
						forwardProxyChoiceInt.ForwardProxyAllowAll = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGwAr.ForwardProxyChoice = forwardProxyChoiceInt
					}

				}

				if v, ok := cs["no_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true

					if v.(bool) {
						forwardProxyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARReplaceType_NoForwardProxy{}
						forwardProxyChoiceInt.NoForwardProxy = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGwAr.ForwardProxyChoice = forwardProxyChoiceInt
					}

				}

				globalNetworkChoiceTypeFound := false

				if v, ok := cs["global_network_list"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

					globalNetworkChoiceTypeFound = true
					globalNetworkChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARReplaceType_GlobalNetworkList{}
					globalNetworkChoiceInt.GlobalNetworkList = &ves_io_schema_views.GlobalNetworkConnectionListType{}
					siteTypeInt.IngressEgressGwAr.GlobalNetworkChoice = globalNetworkChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["global_network_connections"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								globalNetworkConnections := make([]*ves_io_schema_views.GlobalNetworkConnectionType, len(sl))
								globalNetworkChoiceInt.GlobalNetworkList.GlobalNetworkConnections = globalNetworkConnections
								for i, set := range sl {
									if set != nil {
										globalNetworkConnections[i] = &ves_io_schema_views.GlobalNetworkConnectionType{}
										globalNetworkConnectionsMapStrToI := set.(map[string]interface{})

										connectionChoiceTypeFound := false

										if v, ok := globalNetworkConnectionsMapStrToI["sli_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

											connectionChoiceTypeFound = true
											connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SliToGlobalDr{}
											connectionChoiceInt.SliToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
											globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														globalVn := &ves_io_schema_views.ObjectRefType{}
														connectionChoiceInt.SliToGlobalDr.GlobalVn = globalVn
														for _, set := range sl {
															if set != nil {
																globalVnMapStrToI := set.(map[string]interface{})

																if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
																	globalVn.Name = w.(string)
																}

																if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
																	globalVn.Namespace = w.(string)
																}

																if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
																	globalVn.Tenant = w.(string)
																}

															}
														}

													}

												}
											}

										}

										if v, ok := globalNetworkConnectionsMapStrToI["slo_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

											connectionChoiceTypeFound = true
											connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SloToGlobalDr{}
											connectionChoiceInt.SloToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
											globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														globalVn := &ves_io_schema_views.ObjectRefType{}
														connectionChoiceInt.SloToGlobalDr.GlobalVn = globalVn
														for _, set := range sl {
															if set != nil {
																globalVnMapStrToI := set.(map[string]interface{})

																if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
																	globalVn.Name = w.(string)
																}

																if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
																	globalVn.Namespace = w.(string)
																}

																if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
																	globalVn.Tenant = w.(string)
																}

															}
														}

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["no_global_network"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

					globalNetworkChoiceTypeFound = true

					if v.(bool) {
						globalNetworkChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARReplaceType_NoGlobalNetwork{}
						globalNetworkChoiceInt.NoGlobalNetwork = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGwAr.GlobalNetworkChoice = globalNetworkChoiceInt
					}

				}

				hubChoiceTypeFound := false

				if v, ok := cs["hub"]; ok && !isIntfNil(v) && !hubChoiceTypeFound {

					hubChoiceTypeFound = true
					hubChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARReplaceType_Hub{}
					hubChoiceInt.Hub = &ves_io_schema_views_azure_vnet_site.AzureHubVnetType{}
					siteTypeInt.IngressEgressGwAr.HubChoice = hubChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							expressRouteChoiceTypeFound := false

							if v, ok := cs["express_route_disabled"]; ok && !isIntfNil(v) && !expressRouteChoiceTypeFound {

								expressRouteChoiceTypeFound = true

								if v.(bool) {
									expressRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureHubVnetType_ExpressRouteDisabled{}
									expressRouteChoiceInt.ExpressRouteDisabled = &ves_io_schema.Empty{}
									hubChoiceInt.Hub.ExpressRouteChoice = expressRouteChoiceInt
								}

							}

							if v, ok := cs["express_route_enabled"]; ok && !isIntfNil(v) && !expressRouteChoiceTypeFound {

								expressRouteChoiceTypeFound = true
								expressRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureHubVnetType_ExpressRouteEnabled{}
								expressRouteChoiceInt.ExpressRouteEnabled = &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType{}
								hubChoiceInt.Hub.ExpressRouteChoice = expressRouteChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										asnChoiceTypeFound := false

										if v, ok := cs["auto_asn"]; ok && !isIntfNil(v) && !asnChoiceTypeFound {

											asnChoiceTypeFound = true

											if v.(bool) {
												asnChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_AutoAsn{}
												asnChoiceInt.AutoAsn = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.AsnChoice = asnChoiceInt
											}

										}

										if v, ok := cs["custom_asn"]; ok && !isIntfNil(v) && !asnChoiceTypeFound {

											asnChoiceTypeFound = true
											asnChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_CustomAsn{}

											expressRouteChoiceInt.ExpressRouteEnabled.AsnChoice = asnChoiceInt

											asnChoiceInt.CustomAsn = uint32(v.(int))

										}

										if v, ok := cs["connections"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											connections := make([]*ves_io_schema_views_azure_vnet_site.ExpressRouteConnectionType, len(sl))
											expressRouteChoiceInt.ExpressRouteEnabled.Connections = connections
											for i, set := range sl {
												if set != nil {
													connections[i] = &ves_io_schema_views_azure_vnet_site.ExpressRouteConnectionType{}
													connectionsMapStrToI := set.(map[string]interface{})

													if v, ok := connectionsMapStrToI["metadata"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														metadata := &ves_io_schema.MessageMetaType{}
														connections[i].Metadata = metadata
														for _, set := range sl {
															if set != nil {
																metadataMapStrToI := set.(map[string]interface{})

																if w, ok := metadataMapStrToI["description"]; ok && !isIntfNil(w) {
																	metadata.Description = w.(string)
																}

																if w, ok := metadataMapStrToI["name"]; ok && !isIntfNil(w) {
																	metadata.Name = w.(string)
																}

															}
														}

													}

													subscriptionChoiceTypeFound := false

													if v, ok := connectionsMapStrToI["circuit_id"]; ok && !isIntfNil(v) && !subscriptionChoiceTypeFound {

														subscriptionChoiceTypeFound = true
														subscriptionChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConnectionType_CircuitId{}

														connections[i].SubscriptionChoice = subscriptionChoiceInt

														subscriptionChoiceInt.CircuitId = v.(string)

													}

													if v, ok := connectionsMapStrToI["other_subscription"]; ok && !isIntfNil(v) && !subscriptionChoiceTypeFound {

														subscriptionChoiceTypeFound = true
														subscriptionChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConnectionType_OtherSubscription{}
														subscriptionChoiceInt.OtherSubscription = &ves_io_schema_views_azure_vnet_site.ExpressRouteOtherSubscriptionConnection{}
														connections[i].SubscriptionChoice = subscriptionChoiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["authorized_key"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	authorizedKey := &ves_io_schema.SecretType{}
																	subscriptionChoiceInt.OtherSubscription.AuthorizedKey = authorizedKey
																	for _, set := range sl {
																		if set != nil {
																			authorizedKeyMapStrToI := set.(map[string]interface{})

																			secretInfoOneofTypeFound := false

																			if v, ok := authorizedKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																				secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																				authorizedKey.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																						}

																						if v, ok := cs["location"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																						}

																						if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := authorizedKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																				secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																				authorizedKey.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																						}

																						if v, ok := cs["url"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := cs["circuit_id"]; ok && !isIntfNil(v) {

																	subscriptionChoiceInt.OtherSubscription.CircuitId = v.(string)

																}

															}
														}

													}

													if w, ok := connectionsMapStrToI["weight"]; ok && !isIntfNil(w) {
														connections[i].Weight = uint32(w.(int))
													}

												}
											}

										}

										connectivityOptionsTypeFound := false

										if v, ok := cs["site_registration_over_express_route"]; ok && !isIntfNil(v) && !connectivityOptionsTypeFound {

											connectivityOptionsTypeFound = true
											connectivityOptionsInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_SiteRegistrationOverExpressRoute{}
											connectivityOptionsInt.SiteRegistrationOverExpressRoute = &ves_io_schema_views.CloudLinkADNType{}
											expressRouteChoiceInt.ExpressRouteEnabled.ConnectivityOptions = connectivityOptionsInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["cloudlink_network_name"]; ok && !isIntfNil(v) {

														connectivityOptionsInt.SiteRegistrationOverExpressRoute.CloudlinkNetworkName = v.(string)

													}

												}
											}

										}

										if v, ok := cs["site_registration_over_internet"]; ok && !isIntfNil(v) && !connectivityOptionsTypeFound {

											connectivityOptionsTypeFound = true

											if v.(bool) {
												connectivityOptionsInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_SiteRegistrationOverInternet{}
												connectivityOptionsInt.SiteRegistrationOverInternet = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.ConnectivityOptions = connectivityOptionsInt
											}

										}

										if v, ok := cs["gateway_subnet"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											gatewaySubnet := &ves_io_schema_views.AzureSubnetChoiceWithAutoType{}
											expressRouteChoiceInt.ExpressRouteEnabled.GatewaySubnet = gatewaySubnet
											for _, set := range sl {
												if set != nil {
													gatewaySubnetMapStrToI := set.(map[string]interface{})

													choiceTypeFound := false

													if v, ok := gatewaySubnetMapStrToI["auto"]; ok && !isIntfNil(v) && !choiceTypeFound {

														choiceTypeFound = true

														if v.(bool) {
															choiceInt := &ves_io_schema_views.AzureSubnetChoiceWithAutoType_Auto{}
															choiceInt.Auto = &ves_io_schema.Empty{}
															gatewaySubnet.Choice = choiceInt
														}

													}

													if v, ok := gatewaySubnetMapStrToI["subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

														choiceTypeFound = true
														choiceInt := &ves_io_schema_views.AzureSubnetChoiceWithAutoType_Subnet{}
														choiceInt.Subnet = &ves_io_schema_views.AzureSpecialSubnetType{}
														gatewaySubnet.Choice = choiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																resourceGroupChoiceTypeFound := false

																if v, ok := cs["subnet_resource_grp"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

																	resourceGroupChoiceTypeFound = true
																	resourceGroupChoiceInt := &ves_io_schema_views.AzureSpecialSubnetType_SubnetResourceGrp{}

																	choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt

																	resourceGroupChoiceInt.SubnetResourceGrp = v.(string)

																}

																if v, ok := cs["vnet_resource_group"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

																	resourceGroupChoiceTypeFound = true

																	if v.(bool) {
																		resourceGroupChoiceInt := &ves_io_schema_views.AzureSpecialSubnetType_VnetResourceGroup{}
																		resourceGroupChoiceInt.VnetResourceGroup = &ves_io_schema.Empty{}
																		choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt
																	}

																}

															}
														}

													}

													if v, ok := gatewaySubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

														choiceTypeFound = true
														choiceInt := &ves_io_schema_views.AzureSubnetChoiceWithAutoType_SubnetParam{}
														choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
														gatewaySubnet.Choice = choiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

																	choiceInt.SubnetParam.Ipv4 = v.(string)

																}

																if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

																	choiceInt.SubnetParam.Ipv6 = v.(string)

																}

															}
														}

													}

												}
											}

										}

										if v, ok := cs["route_server_subnet"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											routeServerSubnet := &ves_io_schema_views.AzureSubnetChoiceWithAutoType{}
											expressRouteChoiceInt.ExpressRouteEnabled.RouteServerSubnet = routeServerSubnet
											for _, set := range sl {
												if set != nil {
													routeServerSubnetMapStrToI := set.(map[string]interface{})

													choiceTypeFound := false

													if v, ok := routeServerSubnetMapStrToI["auto"]; ok && !isIntfNil(v) && !choiceTypeFound {

														choiceTypeFound = true

														if v.(bool) {
															choiceInt := &ves_io_schema_views.AzureSubnetChoiceWithAutoType_Auto{}
															choiceInt.Auto = &ves_io_schema.Empty{}
															routeServerSubnet.Choice = choiceInt
														}

													}

													if v, ok := routeServerSubnetMapStrToI["subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

														choiceTypeFound = true
														choiceInt := &ves_io_schema_views.AzureSubnetChoiceWithAutoType_Subnet{}
														choiceInt.Subnet = &ves_io_schema_views.AzureSpecialSubnetType{}
														routeServerSubnet.Choice = choiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																resourceGroupChoiceTypeFound := false

																if v, ok := cs["subnet_resource_grp"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

																	resourceGroupChoiceTypeFound = true
																	resourceGroupChoiceInt := &ves_io_schema_views.AzureSpecialSubnetType_SubnetResourceGrp{}

																	choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt

																	resourceGroupChoiceInt.SubnetResourceGrp = v.(string)

																}

																if v, ok := cs["vnet_resource_group"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

																	resourceGroupChoiceTypeFound = true

																	if v.(bool) {
																		resourceGroupChoiceInt := &ves_io_schema_views.AzureSpecialSubnetType_VnetResourceGroup{}
																		resourceGroupChoiceInt.VnetResourceGroup = &ves_io_schema.Empty{}
																		choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt
																	}

																}

															}
														}

													}

													if v, ok := routeServerSubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

														choiceTypeFound = true
														choiceInt := &ves_io_schema_views.AzureSubnetChoiceWithAutoType_SubnetParam{}
														choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
														routeServerSubnet.Choice = choiceInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

																	choiceInt.SubnetParam.Ipv4 = v.(string)

																}

																if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

																	choiceInt.SubnetParam.Ipv6 = v.(string)

																}

															}
														}

													}

												}
											}

										}

										skuChoiceTypeFound := false

										if v, ok := cs["sku_ergw1az"]; ok && !isIntfNil(v) && !skuChoiceTypeFound {

											skuChoiceTypeFound = true

											if v.(bool) {
												skuChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_SkuErgw1Az{}
												skuChoiceInt.SkuErgw1Az = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.SkuChoice = skuChoiceInt
											}

										}

										if v, ok := cs["sku_ergw2az"]; ok && !isIntfNil(v) && !skuChoiceTypeFound {

											skuChoiceTypeFound = true

											if v.(bool) {
												skuChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_SkuErgw2Az{}
												skuChoiceInt.SkuErgw2Az = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.SkuChoice = skuChoiceInt
											}

										}

										if v, ok := cs["sku_high_perf"]; ok && !isIntfNil(v) && !skuChoiceTypeFound {

											skuChoiceTypeFound = true

											if v.(bool) {
												skuChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_SkuHighPerf{}
												skuChoiceInt.SkuHighPerf = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.SkuChoice = skuChoiceInt
											}

										}

										if v, ok := cs["sku_standard"]; ok && !isIntfNil(v) && !skuChoiceTypeFound {

											skuChoiceTypeFound = true

											if v.(bool) {
												skuChoiceInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_SkuStandard{}
												skuChoiceInt.SkuStandard = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.SkuChoice = skuChoiceInt
											}

										}

										spokeVnetRoutesTypeFound := false

										if v, ok := cs["advertise_to_route_server"]; ok && !isIntfNil(v) && !spokeVnetRoutesTypeFound {

											spokeVnetRoutesTypeFound = true

											if v.(bool) {
												spokeVnetRoutesInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_AdvertiseToRouteServer{}
												spokeVnetRoutesInt.AdvertiseToRouteServer = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.SpokeVnetRoutes = spokeVnetRoutesInt
											}

										}

										if v, ok := cs["do_not_advertise_to_route_server"]; ok && !isIntfNil(v) && !spokeVnetRoutesTypeFound {

											spokeVnetRoutesTypeFound = true

											if v.(bool) {
												spokeVnetRoutesInt := &ves_io_schema_views_azure_vnet_site.ExpressRouteConfigType_DoNotAdvertiseToRouteServer{}
												spokeVnetRoutesInt.DoNotAdvertiseToRouteServer = &ves_io_schema.Empty{}
												expressRouteChoiceInt.ExpressRouteEnabled.SpokeVnetRoutes = spokeVnetRoutesInt
											}

										}

									}
								}

							}

							if v, ok := cs["spoke_vnets"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								spokeVnets := make([]*ves_io_schema_views_azure_vnet_site.VnetPeeringType, len(sl))
								hubChoiceInt.Hub.SpokeVnets = spokeVnets
								for i, set := range sl {
									if set != nil {
										spokeVnets[i] = &ves_io_schema_views_azure_vnet_site.VnetPeeringType{}
										spokeVnetsMapStrToI := set.(map[string]interface{})

										if w, ok := spokeVnetsMapStrToI["labels"]; ok && !isIntfNil(w) {
											ms := map[string]string{}
											for k, v := range w.(map[string]interface{}) {
												ms[k] = v.(string)
											}
											spokeVnets[i].Labels = ms
										}

										routingChoiceTypeFound := false

										if v, ok := spokeVnetsMapStrToI["auto"]; ok && !isIntfNil(v) && !routingChoiceTypeFound {

											routingChoiceTypeFound = true

											if v.(bool) {
												routingChoiceInt := &ves_io_schema_views_azure_vnet_site.VnetPeeringType_Auto{}
												routingChoiceInt.Auto = &ves_io_schema.Empty{}
												spokeVnets[i].RoutingChoice = routingChoiceInt
											}

										}

										if v, ok := spokeVnetsMapStrToI["manual"]; ok && !isIntfNil(v) && !routingChoiceTypeFound {

											routingChoiceTypeFound = true

											if v.(bool) {
												routingChoiceInt := &ves_io_schema_views_azure_vnet_site.VnetPeeringType_Manual{}
												routingChoiceInt.Manual = &ves_io_schema.Empty{}
												spokeVnets[i].RoutingChoice = routingChoiceInt
											}

										}

										if v, ok := spokeVnetsMapStrToI["vnet"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											vnet := &ves_io_schema_views.AzureVnetType{}
											spokeVnets[i].Vnet = vnet
											for _, set := range sl {
												if set != nil {
													vnetMapStrToI := set.(map[string]interface{})

													if w, ok := vnetMapStrToI["resource_group"]; ok && !isIntfNil(w) {
														vnet.ResourceGroup = w.(string)
													}

													routingTypeTypeFound := false

													if v, ok := vnetMapStrToI["f5_orchestrated_routing"]; ok && !isIntfNil(v) && !routingTypeTypeFound {

														routingTypeTypeFound = true

														if v.(bool) {
															routingTypeInt := &ves_io_schema_views.AzureVnetType_F5OrchestratedRouting{}
															routingTypeInt.F5OrchestratedRouting = &ves_io_schema.Empty{}
															vnet.RoutingType = routingTypeInt
														}

													}

													if v, ok := vnetMapStrToI["manual_routing"]; ok && !isIntfNil(v) && !routingTypeTypeFound {

														routingTypeTypeFound = true

														if v.(bool) {
															routingTypeInt := &ves_io_schema_views.AzureVnetType_ManualRouting{}
															routingTypeInt.ManualRouting = &ves_io_schema.Empty{}
															vnet.RoutingType = routingTypeInt
														}

													}

													if w, ok := vnetMapStrToI["vnet_name"]; ok && !isIntfNil(w) {
														vnet.VnetName = w.(string)
													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["not_hub"]; ok && !isIntfNil(v) && !hubChoiceTypeFound {

					hubChoiceTypeFound = true

					if v.(bool) {
						hubChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARReplaceType_NotHub{}
						hubChoiceInt.NotHub = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGwAr.HubChoice = hubChoiceInt
					}

				}

				insideStaticRouteChoiceTypeFound := false

				if v, ok := cs["inside_static_routes"]; ok && !isIntfNil(v) && !insideStaticRouteChoiceTypeFound {

					insideStaticRouteChoiceTypeFound = true
					insideStaticRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARReplaceType_InsideStaticRoutes{}
					insideStaticRouteChoiceInt.InsideStaticRoutes = &ves_io_schema_views.SiteStaticRoutesListType{}
					siteTypeInt.IngressEgressGwAr.InsideStaticRouteChoice = insideStaticRouteChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_route_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRouteList := make([]*ves_io_schema_views.SiteStaticRoutesType, len(sl))
								insideStaticRouteChoiceInt.InsideStaticRoutes.StaticRouteList = staticRouteList
								for i, set := range sl {
									if set != nil {
										staticRouteList[i] = &ves_io_schema_views.SiteStaticRoutesType{}
										staticRouteListMapStrToI := set.(map[string]interface{})

										configModeChoiceTypeFound := false

										if v, ok := staticRouteListMapStrToI["custom_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_CustomStaticRoute{}
											configModeChoiceInt.CustomStaticRoute = &ves_io_schema.StaticRouteType{}
											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["attrs"]; ok && !isIntfNil(v) {

														attrsList := []ves_io_schema.RouteAttrType{}
														for _, j := range v.([]interface{}) {
															if j == nil {
																return fmt.Errorf("please provide valid non-empty enum value of field attrs")
															}
															attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
														}
														configModeChoiceInt.CustomStaticRoute.Attrs = attrsList

													}

													if v, ok := cs["labels"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														configModeChoiceInt.CustomStaticRoute.Labels = ms
													}

													if v, ok := cs["nexthop"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														nexthop := &ves_io_schema.NextHopType{}
														configModeChoiceInt.CustomStaticRoute.Nexthop = nexthop
														for _, set := range sl {
															if set != nil {
																nexthopMapStrToI := set.(map[string]interface{})

																if v, ok := nexthopMapStrToI["interface"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	intfInt := make([]*ves_io_schema.ObjectRefType, len(sl))
																	nexthop.Interface = intfInt
																	for i, ps := range sl {

																		iMapToStrVal := ps.(map[string]interface{})
																		intfInt[i] = &ves_io_schema.ObjectRefType{}

																		intfInt[i].Kind = "network_interface"

																		if v, ok := iMapToStrVal["name"]; ok && !isIntfNil(v) {
																			intfInt[i].Name = v.(string)
																		}

																		if v, ok := iMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																			intfInt[i].Namespace = v.(string)
																		}

																		if v, ok := iMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																			intfInt[i].Tenant = v.(string)
																		}

																		if v, ok := iMapToStrVal["uid"]; ok && !isIntfNil(v) {
																			intfInt[i].Uid = v.(string)
																		}

																	}

																}

																if v, ok := nexthopMapStrToI["nexthop_address"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	nexthopAddress := &ves_io_schema.IpAddressType{}
																	nexthop.NexthopAddress = nexthopAddress
																	for _, set := range sl {
																		if set != nil {
																			nexthopAddressMapStrToI := set.(map[string]interface{})

																			verTypeFound := false

																			if v, ok := nexthopAddressMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv4{}
																				verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv4.Addr = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := nexthopAddressMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv6{}
																				verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv6.Addr = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := nexthopMapStrToI["type"]; ok && !isIntfNil(v) {

																	nexthop.Type = ves_io_schema.NextHopTypes(ves_io_schema.NextHopTypes_value[v.(string)])

																}

															}
														}

													}

													if v, ok := cs["subnets"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														subnets := make([]*ves_io_schema.IpSubnetType, len(sl))
														configModeChoiceInt.CustomStaticRoute.Subnets = subnets
														for i, set := range sl {
															if set != nil {
																subnets[i] = &ves_io_schema.IpSubnetType{}
																subnetsMapStrToI := set.(map[string]interface{})

																verTypeFound := false

																if v, ok := subnetsMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv4{}
																	verInt.Ipv4 = &ves_io_schema.Ipv4SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Prefix = v.(string)

																			}

																		}
																	}

																}

																if v, ok := subnetsMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv6{}
																	verInt.Ipv6 = &ves_io_schema.Ipv6SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Prefix = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

												}
											}

										}

										if v, ok := staticRouteListMapStrToI["simple_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_SimpleStaticRoute{}

											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											configModeChoiceInt.SimpleStaticRoute = v.(string)

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["no_inside_static_routes"]; ok && !isIntfNil(v) && !insideStaticRouteChoiceTypeFound {

					insideStaticRouteChoiceTypeFound = true

					if v.(bool) {
						insideStaticRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARReplaceType_NoInsideStaticRoutes{}
						insideStaticRouteChoiceInt.NoInsideStaticRoutes = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGwAr.InsideStaticRouteChoice = insideStaticRouteChoiceInt
					}

				}

				networkPolicyChoiceTypeFound := false

				if v, ok := cs["active_enhanced_firewall_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true
					networkPolicyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARReplaceType_ActiveEnhancedFirewallPolicies{}
					networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies = &ves_io_schema_network_firewall.ActiveEnhancedFirewallPoliciesType{}
					siteTypeInt.IngressEgressGwAr.NetworkPolicyChoice = networkPolicyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["enhanced_firewall_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								enhancedFirewallPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies.EnhancedFirewallPolicies = enhancedFirewallPoliciesInt
								for i, ps := range sl {

									efpMapToStrVal := ps.(map[string]interface{})
									enhancedFirewallPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := efpMapToStrVal["name"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Name = v.(string)
									}

									if v, ok := efpMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := efpMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["active_network_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true
					networkPolicyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARReplaceType_ActiveNetworkPolicies{}
					networkPolicyChoiceInt.ActiveNetworkPolicies = &ves_io_schema_network_firewall.ActiveNetworkPoliciesType{}
					siteTypeInt.IngressEgressGwAr.NetworkPolicyChoice = networkPolicyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["network_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								networkPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								networkPolicyChoiceInt.ActiveNetworkPolicies.NetworkPolicies = networkPoliciesInt
								for i, ps := range sl {

									npMapToStrVal := ps.(map[string]interface{})
									networkPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := npMapToStrVal["name"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Name = v.(string)
									}

									if v, ok := npMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := npMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["no_network_policy"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true

					if v.(bool) {
						networkPolicyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARReplaceType_NoNetworkPolicy{}
						networkPolicyChoiceInt.NoNetworkPolicy = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGwAr.NetworkPolicyChoice = networkPolicyChoiceInt
					}

				}

				if v, ok := cs["node"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					node := &ves_io_schema_views.AzureVnetTwoInterfaceNodeARType{}
					siteTypeInt.IngressEgressGwAr.Node = node
					for _, set := range sl {
						if set != nil {
							nodeMapStrToI := set.(map[string]interface{})

							if w, ok := nodeMapStrToI["fault_domain"]; ok && !isIntfNil(w) {
								node.FaultDomain = uint32(w.(int))
							}

							if v, ok := nodeMapStrToI["inside_subnet"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								insideSubnet := &ves_io_schema_views.AzureSubnetChoiceType{}
								node.InsideSubnet = insideSubnet
								for _, set := range sl {
									if set != nil {
										insideSubnetMapStrToI := set.(map[string]interface{})

										choiceTypeFound := false

										if v, ok := insideSubnetMapStrToI["subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_Subnet{}
											choiceInt.Subnet = &ves_io_schema_views.AzureSubnetType{}
											insideSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													resourceGroupChoiceTypeFound := false

													if v, ok := cs["subnet_resource_grp"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true
														resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_SubnetResourceGrp{}

														choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt

														resourceGroupChoiceInt.SubnetResourceGrp = v.(string)

													}

													if v, ok := cs["vnet_resource_group"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true

														if v.(bool) {
															resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_VnetResourceGroup{}
															resourceGroupChoiceInt.VnetResourceGroup = &ves_io_schema.Empty{}
															choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt
														}

													}

													if v, ok := cs["subnet_name"]; ok && !isIntfNil(v) {

														choiceInt.Subnet.SubnetName = v.(string)

													}

												}
											}

										}

										if v, ok := insideSubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_SubnetParam{}
											choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
											insideSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv4 = v.(string)

													}

													if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv6 = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if w, ok := nodeMapStrToI["node_number"]; ok && !isIntfNil(w) {
								node.NodeNumber = uint32(w.(int))
							}

							if v, ok := nodeMapStrToI["outside_subnet"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								outsideSubnet := &ves_io_schema_views.AzureSubnetChoiceType{}
								node.OutsideSubnet = outsideSubnet
								for _, set := range sl {
									if set != nil {
										outsideSubnetMapStrToI := set.(map[string]interface{})

										choiceTypeFound := false

										if v, ok := outsideSubnetMapStrToI["subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_Subnet{}
											choiceInt.Subnet = &ves_io_schema_views.AzureSubnetType{}
											outsideSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													resourceGroupChoiceTypeFound := false

													if v, ok := cs["subnet_resource_grp"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true
														resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_SubnetResourceGrp{}

														choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt

														resourceGroupChoiceInt.SubnetResourceGrp = v.(string)

													}

													if v, ok := cs["vnet_resource_group"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true

														if v.(bool) {
															resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_VnetResourceGroup{}
															resourceGroupChoiceInt.VnetResourceGroup = &ves_io_schema.Empty{}
															choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt
														}

													}

													if v, ok := cs["subnet_name"]; ok && !isIntfNil(v) {

														choiceInt.Subnet.SubnetName = v.(string)

													}

												}
											}

										}

										if v, ok := outsideSubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_SubnetParam{}
											choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
											outsideSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv4 = v.(string)

													}

													if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv6 = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if w, ok := nodeMapStrToI["update_domain"]; ok && !isIntfNil(w) {
								node.UpdateDomain = uint32(w.(int))
							}

						}
					}

				}

				outsideStaticRouteChoiceTypeFound := false

				if v, ok := cs["no_outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

					outsideStaticRouteChoiceTypeFound = true

					if v.(bool) {
						outsideStaticRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARReplaceType_NoOutsideStaticRoutes{}
						outsideStaticRouteChoiceInt.NoOutsideStaticRoutes = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGwAr.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt
					}

				}

				if v, ok := cs["outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

					outsideStaticRouteChoiceTypeFound = true
					outsideStaticRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARReplaceType_OutsideStaticRoutes{}
					outsideStaticRouteChoiceInt.OutsideStaticRoutes = &ves_io_schema_views.SiteStaticRoutesListType{}
					siteTypeInt.IngressEgressGwAr.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_route_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRouteList := make([]*ves_io_schema_views.SiteStaticRoutesType, len(sl))
								outsideStaticRouteChoiceInt.OutsideStaticRoutes.StaticRouteList = staticRouteList
								for i, set := range sl {
									if set != nil {
										staticRouteList[i] = &ves_io_schema_views.SiteStaticRoutesType{}
										staticRouteListMapStrToI := set.(map[string]interface{})

										configModeChoiceTypeFound := false

										if v, ok := staticRouteListMapStrToI["custom_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_CustomStaticRoute{}
											configModeChoiceInt.CustomStaticRoute = &ves_io_schema.StaticRouteType{}
											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["attrs"]; ok && !isIntfNil(v) {

														attrsList := []ves_io_schema.RouteAttrType{}
														for _, j := range v.([]interface{}) {
															if j == nil {
																return fmt.Errorf("please provide valid non-empty enum value of field attrs")
															}
															attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
														}
														configModeChoiceInt.CustomStaticRoute.Attrs = attrsList

													}

													if v, ok := cs["labels"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														configModeChoiceInt.CustomStaticRoute.Labels = ms
													}

													if v, ok := cs["nexthop"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														nexthop := &ves_io_schema.NextHopType{}
														configModeChoiceInt.CustomStaticRoute.Nexthop = nexthop
														for _, set := range sl {
															if set != nil {
																nexthopMapStrToI := set.(map[string]interface{})

																if v, ok := nexthopMapStrToI["interface"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	intfInt := make([]*ves_io_schema.ObjectRefType, len(sl))
																	nexthop.Interface = intfInt
																	for i, ps := range sl {

																		iMapToStrVal := ps.(map[string]interface{})
																		intfInt[i] = &ves_io_schema.ObjectRefType{}

																		intfInt[i].Kind = "network_interface"

																		if v, ok := iMapToStrVal["name"]; ok && !isIntfNil(v) {
																			intfInt[i].Name = v.(string)
																		}

																		if v, ok := iMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																			intfInt[i].Namespace = v.(string)
																		}

																		if v, ok := iMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																			intfInt[i].Tenant = v.(string)
																		}

																		if v, ok := iMapToStrVal["uid"]; ok && !isIntfNil(v) {
																			intfInt[i].Uid = v.(string)
																		}

																	}

																}

																if v, ok := nexthopMapStrToI["nexthop_address"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	nexthopAddress := &ves_io_schema.IpAddressType{}
																	nexthop.NexthopAddress = nexthopAddress
																	for _, set := range sl {
																		if set != nil {
																			nexthopAddressMapStrToI := set.(map[string]interface{})

																			verTypeFound := false

																			if v, ok := nexthopAddressMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv4{}
																				verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv4.Addr = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := nexthopAddressMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv6{}
																				verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv6.Addr = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := nexthopMapStrToI["type"]; ok && !isIntfNil(v) {

																	nexthop.Type = ves_io_schema.NextHopTypes(ves_io_schema.NextHopTypes_value[v.(string)])

																}

															}
														}

													}

													if v, ok := cs["subnets"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														subnets := make([]*ves_io_schema.IpSubnetType, len(sl))
														configModeChoiceInt.CustomStaticRoute.Subnets = subnets
														for i, set := range sl {
															if set != nil {
																subnets[i] = &ves_io_schema.IpSubnetType{}
																subnetsMapStrToI := set.(map[string]interface{})

																verTypeFound := false

																if v, ok := subnetsMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv4{}
																	verInt.Ipv4 = &ves_io_schema.Ipv4SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Prefix = v.(string)

																			}

																		}
																	}

																}

																if v, ok := subnetsMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv6{}
																	verInt.Ipv6 = &ves_io_schema.Ipv6SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Prefix = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

												}
											}

										}

										if v, ok := staticRouteListMapStrToI["simple_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_SimpleStaticRoute{}

											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											configModeChoiceInt.SimpleStaticRoute = v.(string)

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["performance_enhancement_mode"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					performanceEnhancementMode := &ves_io_schema_views.PerformanceEnhancementModeType{}
					siteTypeInt.IngressEgressGwAr.PerformanceEnhancementMode = performanceEnhancementMode
					for _, set := range sl {
						if set != nil {
							performanceEnhancementModeMapStrToI := set.(map[string]interface{})

							perfModeChoiceTypeFound := false

							if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l3_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

								perfModeChoiceTypeFound = true
								perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL3Enhanced{}
								perfModeChoiceInt.PerfModeL3Enhanced = &ves_io_schema_views.L3PerformanceEnhancementType{}
								performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										perfModeChoiceTypeFound := false

										if v, ok := cs["jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

											perfModeChoiceTypeFound = true

											if v.(bool) {
												perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_Jumbo{}
												perfModeChoiceIntNew.Jumbo = &ves_io_schema.Empty{}
												perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
											}

										}

										if v, ok := cs["no_jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

											perfModeChoiceTypeFound = true

											if v.(bool) {
												perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_NoJumbo{}
												perfModeChoiceIntNew.NoJumbo = &ves_io_schema.Empty{}
												perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
											}

										}

									}
								}

							}

							if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l7_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

								perfModeChoiceTypeFound = true

								if v.(bool) {
									perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL7Enhanced{}
									perfModeChoiceInt.PerfModeL7Enhanced = &ves_io_schema.Empty{}
									performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt
								}

							}

						}
					}

				}

				siteMeshGroupChoiceTypeFound := false

				if v, ok := cs["sm_connection_public_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

					siteMeshGroupChoiceTypeFound = true

					if v.(bool) {
						siteMeshGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARReplaceType_SmConnectionPublicIp{}
						siteMeshGroupChoiceInt.SmConnectionPublicIp = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGwAr.SiteMeshGroupChoice = siteMeshGroupChoiceInt
					}

				}

				if v, ok := cs["sm_connection_pvt_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

					siteMeshGroupChoiceTypeFound = true

					if v.(bool) {
						siteMeshGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetIngressEgressGwARReplaceType_SmConnectionPvtIp{}
						siteMeshGroupChoiceInt.SmConnectionPvtIp = &ves_io_schema.Empty{}
						siteTypeInt.IngressEgressGwAr.SiteMeshGroupChoice = siteMeshGroupChoiceInt
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("ingress_gw"); ok && !isIntfNil(v) && !siteTypeTypeFound {

		siteTypeTypeFound = true
		siteTypeInt := &ves_io_schema_views_azure_vnet_site.ReplaceSpecType_IngressGw{}
		siteTypeInt.IngressGw = &ves_io_schema_views_azure_vnet_site.AzureVnetIngressGwReplaceType{}
		updateSpec.SiteType = siteTypeInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["az_nodes"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					azNodes := make([]*ves_io_schema_views.AzureVnetOneInterfaceNodeType, len(sl))
					siteTypeInt.IngressGw.AzNodes = azNodes
					for i, set := range sl {
						if set != nil {
							azNodes[i] = &ves_io_schema_views.AzureVnetOneInterfaceNodeType{}
							azNodesMapStrToI := set.(map[string]interface{})

							if w, ok := azNodesMapStrToI["azure_az"]; ok && !isIntfNil(w) {
								azNodes[i].AzureAz = w.(string)
							}

							if v, ok := azNodesMapStrToI["local_subnet"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								localSubnet := &ves_io_schema_views.AzureSubnetChoiceType{}
								azNodes[i].LocalSubnet = localSubnet
								for _, set := range sl {
									if set != nil {
										localSubnetMapStrToI := set.(map[string]interface{})

										choiceTypeFound := false

										if v, ok := localSubnetMapStrToI["subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_Subnet{}
											choiceInt.Subnet = &ves_io_schema_views.AzureSubnetType{}
											localSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													resourceGroupChoiceTypeFound := false

													if v, ok := cs["subnet_resource_grp"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true
														resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_SubnetResourceGrp{}

														choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt

														resourceGroupChoiceInt.SubnetResourceGrp = v.(string)

													}

													if v, ok := cs["vnet_resource_group"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true

														if v.(bool) {
															resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_VnetResourceGroup{}
															resourceGroupChoiceInt.VnetResourceGroup = &ves_io_schema.Empty{}
															choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt
														}

													}

													if v, ok := cs["subnet_name"]; ok && !isIntfNil(v) {

														choiceInt.Subnet.SubnetName = v.(string)

													}

												}
											}

										}

										if v, ok := localSubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_SubnetParam{}
											choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
											localSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv4 = v.(string)

													}

													if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv6 = v.(string)

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("ingress_gw_ar"); ok && !isIntfNil(v) && !siteTypeTypeFound {

		siteTypeTypeFound = true
		siteTypeInt := &ves_io_schema_views_azure_vnet_site.ReplaceSpecType_IngressGwAr{}
		siteTypeInt.IngressGwAr = &ves_io_schema_views_azure_vnet_site.AzureVnetIngressGwARReplaceType{}
		updateSpec.SiteType = siteTypeInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["node"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					node := &ves_io_schema_views.AzureVnetOneInterfaceNodeARType{}
					siteTypeInt.IngressGwAr.Node = node
					for _, set := range sl {
						if set != nil {
							nodeMapStrToI := set.(map[string]interface{})

							if w, ok := nodeMapStrToI["fault_domain"]; ok && !isIntfNil(w) {
								node.FaultDomain = uint32(w.(int))
							}

							if v, ok := nodeMapStrToI["local_subnet"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								localSubnet := &ves_io_schema_views.AzureSubnetChoiceType{}
								node.LocalSubnet = localSubnet
								for _, set := range sl {
									if set != nil {
										localSubnetMapStrToI := set.(map[string]interface{})

										choiceTypeFound := false

										if v, ok := localSubnetMapStrToI["subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_Subnet{}
											choiceInt.Subnet = &ves_io_schema_views.AzureSubnetType{}
											localSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													resourceGroupChoiceTypeFound := false

													if v, ok := cs["subnet_resource_grp"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true
														resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_SubnetResourceGrp{}

														choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt

														resourceGroupChoiceInt.SubnetResourceGrp = v.(string)

													}

													if v, ok := cs["vnet_resource_group"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true

														if v.(bool) {
															resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_VnetResourceGroup{}
															resourceGroupChoiceInt.VnetResourceGroup = &ves_io_schema.Empty{}
															choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt
														}

													}

													if v, ok := cs["subnet_name"]; ok && !isIntfNil(v) {

														choiceInt.Subnet.SubnetName = v.(string)

													}

												}
											}

										}

										if v, ok := localSubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_SubnetParam{}
											choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
											localSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv4 = v.(string)

													}

													if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv6 = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if w, ok := nodeMapStrToI["node_number"]; ok && !isIntfNil(w) {
								node.NodeNumber = uint32(w.(int))
							}

							if w, ok := nodeMapStrToI["update_domain"]; ok && !isIntfNil(w) {
								node.UpdateDomain = uint32(w.(int))
							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("voltstack_cluster"); ok && !isIntfNil(v) && !siteTypeTypeFound {

		siteTypeTypeFound = true
		siteTypeInt := &ves_io_schema_views_azure_vnet_site.ReplaceSpecType_VoltstackCluster{}
		siteTypeInt.VoltstackCluster = &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterReplaceType{}
		updateSpec.SiteType = siteTypeInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["az_nodes"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					azNodes := make([]*ves_io_schema_views.AzureVnetOneInterfaceNodeType, len(sl))
					siteTypeInt.VoltstackCluster.AzNodes = azNodes
					for i, set := range sl {
						if set != nil {
							azNodes[i] = &ves_io_schema_views.AzureVnetOneInterfaceNodeType{}
							azNodesMapStrToI := set.(map[string]interface{})

							if w, ok := azNodesMapStrToI["azure_az"]; ok && !isIntfNil(w) {
								azNodes[i].AzureAz = w.(string)
							}

							if v, ok := azNodesMapStrToI["local_subnet"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								localSubnet := &ves_io_schema_views.AzureSubnetChoiceType{}
								azNodes[i].LocalSubnet = localSubnet
								for _, set := range sl {
									if set != nil {
										localSubnetMapStrToI := set.(map[string]interface{})

										choiceTypeFound := false

										if v, ok := localSubnetMapStrToI["subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_Subnet{}
											choiceInt.Subnet = &ves_io_schema_views.AzureSubnetType{}
											localSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													resourceGroupChoiceTypeFound := false

													if v, ok := cs["subnet_resource_grp"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true
														resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_SubnetResourceGrp{}

														choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt

														resourceGroupChoiceInt.SubnetResourceGrp = v.(string)

													}

													if v, ok := cs["vnet_resource_group"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true

														if v.(bool) {
															resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_VnetResourceGroup{}
															resourceGroupChoiceInt.VnetResourceGroup = &ves_io_schema.Empty{}
															choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt
														}

													}

													if v, ok := cs["subnet_name"]; ok && !isIntfNil(v) {

														choiceInt.Subnet.SubnetName = v.(string)

													}

												}
											}

										}

										if v, ok := localSubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_SubnetParam{}
											choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
											localSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv4 = v.(string)

													}

													if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv6 = v.(string)

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				dcClusterGroupChoiceTypeFound := false

				if v, ok := cs["dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

					dcClusterGroupChoiceTypeFound = true
					dcClusterGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterReplaceType_DcClusterGroup{}
					dcClusterGroupChoiceInt.DcClusterGroup = &ves_io_schema_views.ObjectRefType{}
					siteTypeInt.VoltstackCluster.DcClusterGroupChoice = dcClusterGroupChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Tenant = v.(string)

							}

						}
					}

				}

				if v, ok := cs["no_dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

					dcClusterGroupChoiceTypeFound = true

					if v.(bool) {
						dcClusterGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterReplaceType_NoDcClusterGroup{}
						dcClusterGroupChoiceInt.NoDcClusterGroup = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackCluster.DcClusterGroupChoice = dcClusterGroupChoiceInt
					}

				}

				forwardProxyChoiceTypeFound := false

				if v, ok := cs["active_forward_proxy_policies"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true
					forwardProxyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterReplaceType_ActiveForwardProxyPolicies{}
					forwardProxyChoiceInt.ActiveForwardProxyPolicies = &ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType{}
					siteTypeInt.VoltstackCluster.ForwardProxyChoice = forwardProxyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["forward_proxy_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								forwardProxyPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								forwardProxyChoiceInt.ActiveForwardProxyPolicies.ForwardProxyPolicies = forwardProxyPoliciesInt
								for i, ps := range sl {

									fppMapToStrVal := ps.(map[string]interface{})
									forwardProxyPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := fppMapToStrVal["name"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Name = v.(string)
									}

									if v, ok := fppMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := fppMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["forward_proxy_allow_all"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true

					if v.(bool) {
						forwardProxyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterReplaceType_ForwardProxyAllowAll{}
						forwardProxyChoiceInt.ForwardProxyAllowAll = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackCluster.ForwardProxyChoice = forwardProxyChoiceInt
					}

				}

				if v, ok := cs["no_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true

					if v.(bool) {
						forwardProxyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterReplaceType_NoForwardProxy{}
						forwardProxyChoiceInt.NoForwardProxy = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackCluster.ForwardProxyChoice = forwardProxyChoiceInt
					}

				}

				globalNetworkChoiceTypeFound := false

				if v, ok := cs["global_network_list"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

					globalNetworkChoiceTypeFound = true
					globalNetworkChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterReplaceType_GlobalNetworkList{}
					globalNetworkChoiceInt.GlobalNetworkList = &ves_io_schema_views.GlobalNetworkConnectionListType{}
					siteTypeInt.VoltstackCluster.GlobalNetworkChoice = globalNetworkChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["global_network_connections"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								globalNetworkConnections := make([]*ves_io_schema_views.GlobalNetworkConnectionType, len(sl))
								globalNetworkChoiceInt.GlobalNetworkList.GlobalNetworkConnections = globalNetworkConnections
								for i, set := range sl {
									if set != nil {
										globalNetworkConnections[i] = &ves_io_schema_views.GlobalNetworkConnectionType{}
										globalNetworkConnectionsMapStrToI := set.(map[string]interface{})

										connectionChoiceTypeFound := false

										if v, ok := globalNetworkConnectionsMapStrToI["sli_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

											connectionChoiceTypeFound = true
											connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SliToGlobalDr{}
											connectionChoiceInt.SliToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
											globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														globalVn := &ves_io_schema_views.ObjectRefType{}
														connectionChoiceInt.SliToGlobalDr.GlobalVn = globalVn
														for _, set := range sl {
															if set != nil {
																globalVnMapStrToI := set.(map[string]interface{})

																if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
																	globalVn.Name = w.(string)
																}

																if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
																	globalVn.Namespace = w.(string)
																}

																if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
																	globalVn.Tenant = w.(string)
																}

															}
														}

													}

												}
											}

										}

										if v, ok := globalNetworkConnectionsMapStrToI["slo_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

											connectionChoiceTypeFound = true
											connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SloToGlobalDr{}
											connectionChoiceInt.SloToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
											globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														globalVn := &ves_io_schema_views.ObjectRefType{}
														connectionChoiceInt.SloToGlobalDr.GlobalVn = globalVn
														for _, set := range sl {
															if set != nil {
																globalVnMapStrToI := set.(map[string]interface{})

																if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
																	globalVn.Name = w.(string)
																}

																if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
																	globalVn.Namespace = w.(string)
																}

																if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
																	globalVn.Tenant = w.(string)
																}

															}
														}

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["no_global_network"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

					globalNetworkChoiceTypeFound = true

					if v.(bool) {
						globalNetworkChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterReplaceType_NoGlobalNetwork{}
						globalNetworkChoiceInt.NoGlobalNetwork = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackCluster.GlobalNetworkChoice = globalNetworkChoiceInt
					}

				}

				networkPolicyChoiceTypeFound := false

				if v, ok := cs["active_enhanced_firewall_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true
					networkPolicyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterReplaceType_ActiveEnhancedFirewallPolicies{}
					networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies = &ves_io_schema_network_firewall.ActiveEnhancedFirewallPoliciesType{}
					siteTypeInt.VoltstackCluster.NetworkPolicyChoice = networkPolicyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["enhanced_firewall_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								enhancedFirewallPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies.EnhancedFirewallPolicies = enhancedFirewallPoliciesInt
								for i, ps := range sl {

									efpMapToStrVal := ps.(map[string]interface{})
									enhancedFirewallPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := efpMapToStrVal["name"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Name = v.(string)
									}

									if v, ok := efpMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := efpMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["active_network_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true
					networkPolicyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterReplaceType_ActiveNetworkPolicies{}
					networkPolicyChoiceInt.ActiveNetworkPolicies = &ves_io_schema_network_firewall.ActiveNetworkPoliciesType{}
					siteTypeInt.VoltstackCluster.NetworkPolicyChoice = networkPolicyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["network_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								networkPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								networkPolicyChoiceInt.ActiveNetworkPolicies.NetworkPolicies = networkPoliciesInt
								for i, ps := range sl {

									npMapToStrVal := ps.(map[string]interface{})
									networkPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := npMapToStrVal["name"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Name = v.(string)
									}

									if v, ok := npMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := npMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["no_network_policy"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true

					if v.(bool) {
						networkPolicyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterReplaceType_NoNetworkPolicy{}
						networkPolicyChoiceInt.NoNetworkPolicy = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackCluster.NetworkPolicyChoice = networkPolicyChoiceInt
					}

				}

				outsideStaticRouteChoiceTypeFound := false

				if v, ok := cs["no_outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

					outsideStaticRouteChoiceTypeFound = true

					if v.(bool) {
						outsideStaticRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterReplaceType_NoOutsideStaticRoutes{}
						outsideStaticRouteChoiceInt.NoOutsideStaticRoutes = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackCluster.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt
					}

				}

				if v, ok := cs["outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

					outsideStaticRouteChoiceTypeFound = true
					outsideStaticRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterReplaceType_OutsideStaticRoutes{}
					outsideStaticRouteChoiceInt.OutsideStaticRoutes = &ves_io_schema_views.SiteStaticRoutesListType{}
					siteTypeInt.VoltstackCluster.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_route_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRouteList := make([]*ves_io_schema_views.SiteStaticRoutesType, len(sl))
								outsideStaticRouteChoiceInt.OutsideStaticRoutes.StaticRouteList = staticRouteList
								for i, set := range sl {
									if set != nil {
										staticRouteList[i] = &ves_io_schema_views.SiteStaticRoutesType{}
										staticRouteListMapStrToI := set.(map[string]interface{})

										configModeChoiceTypeFound := false

										if v, ok := staticRouteListMapStrToI["custom_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_CustomStaticRoute{}
											configModeChoiceInt.CustomStaticRoute = &ves_io_schema.StaticRouteType{}
											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["attrs"]; ok && !isIntfNil(v) {

														attrsList := []ves_io_schema.RouteAttrType{}
														for _, j := range v.([]interface{}) {
															if j == nil {
																return fmt.Errorf("please provide valid non-empty enum value of field attrs")
															}
															attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
														}
														configModeChoiceInt.CustomStaticRoute.Attrs = attrsList

													}

													if v, ok := cs["labels"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														configModeChoiceInt.CustomStaticRoute.Labels = ms
													}

													if v, ok := cs["nexthop"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														nexthop := &ves_io_schema.NextHopType{}
														configModeChoiceInt.CustomStaticRoute.Nexthop = nexthop
														for _, set := range sl {
															if set != nil {
																nexthopMapStrToI := set.(map[string]interface{})

																if v, ok := nexthopMapStrToI["interface"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	intfInt := make([]*ves_io_schema.ObjectRefType, len(sl))
																	nexthop.Interface = intfInt
																	for i, ps := range sl {

																		iMapToStrVal := ps.(map[string]interface{})
																		intfInt[i] = &ves_io_schema.ObjectRefType{}

																		intfInt[i].Kind = "network_interface"

																		if v, ok := iMapToStrVal["name"]; ok && !isIntfNil(v) {
																			intfInt[i].Name = v.(string)
																		}

																		if v, ok := iMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																			intfInt[i].Namespace = v.(string)
																		}

																		if v, ok := iMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																			intfInt[i].Tenant = v.(string)
																		}

																		if v, ok := iMapToStrVal["uid"]; ok && !isIntfNil(v) {
																			intfInt[i].Uid = v.(string)
																		}

																	}

																}

																if v, ok := nexthopMapStrToI["nexthop_address"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	nexthopAddress := &ves_io_schema.IpAddressType{}
																	nexthop.NexthopAddress = nexthopAddress
																	for _, set := range sl {
																		if set != nil {
																			nexthopAddressMapStrToI := set.(map[string]interface{})

																			verTypeFound := false

																			if v, ok := nexthopAddressMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv4{}
																				verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv4.Addr = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := nexthopAddressMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv6{}
																				verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv6.Addr = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := nexthopMapStrToI["type"]; ok && !isIntfNil(v) {

																	nexthop.Type = ves_io_schema.NextHopTypes(ves_io_schema.NextHopTypes_value[v.(string)])

																}

															}
														}

													}

													if v, ok := cs["subnets"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														subnets := make([]*ves_io_schema.IpSubnetType, len(sl))
														configModeChoiceInt.CustomStaticRoute.Subnets = subnets
														for i, set := range sl {
															if set != nil {
																subnets[i] = &ves_io_schema.IpSubnetType{}
																subnetsMapStrToI := set.(map[string]interface{})

																verTypeFound := false

																if v, ok := subnetsMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv4{}
																	verInt.Ipv4 = &ves_io_schema.Ipv4SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Prefix = v.(string)

																			}

																		}
																	}

																}

																if v, ok := subnetsMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv6{}
																	verInt.Ipv6 = &ves_io_schema.Ipv6SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Prefix = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

												}
											}

										}

										if v, ok := staticRouteListMapStrToI["simple_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_SimpleStaticRoute{}

											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											configModeChoiceInt.SimpleStaticRoute = v.(string)

										}

									}
								}

							}

						}
					}

				}

				siteMeshGroupChoiceTypeFound := false

				if v, ok := cs["sm_connection_public_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

					siteMeshGroupChoiceTypeFound = true

					if v.(bool) {
						siteMeshGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterReplaceType_SmConnectionPublicIp{}
						siteMeshGroupChoiceInt.SmConnectionPublicIp = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackCluster.SiteMeshGroupChoice = siteMeshGroupChoiceInt
					}

				}

				if v, ok := cs["sm_connection_pvt_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

					siteMeshGroupChoiceTypeFound = true

					if v.(bool) {
						siteMeshGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterReplaceType_SmConnectionPvtIp{}
						siteMeshGroupChoiceInt.SmConnectionPvtIp = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackCluster.SiteMeshGroupChoice = siteMeshGroupChoiceInt
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("voltstack_cluster_ar"); ok && !isIntfNil(v) && !siteTypeTypeFound {

		siteTypeTypeFound = true
		siteTypeInt := &ves_io_schema_views_azure_vnet_site.ReplaceSpecType_VoltstackClusterAr{}
		siteTypeInt.VoltstackClusterAr = &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARReplaceType{}
		updateSpec.SiteType = siteTypeInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				dcClusterGroupChoiceTypeFound := false

				if v, ok := cs["dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

					dcClusterGroupChoiceTypeFound = true
					dcClusterGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARReplaceType_DcClusterGroup{}
					dcClusterGroupChoiceInt.DcClusterGroup = &ves_io_schema_views.ObjectRefType{}
					siteTypeInt.VoltstackClusterAr.DcClusterGroupChoice = dcClusterGroupChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Tenant = v.(string)

							}

						}
					}

				}

				if v, ok := cs["no_dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

					dcClusterGroupChoiceTypeFound = true

					if v.(bool) {
						dcClusterGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARReplaceType_NoDcClusterGroup{}
						dcClusterGroupChoiceInt.NoDcClusterGroup = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackClusterAr.DcClusterGroupChoice = dcClusterGroupChoiceInt
					}

				}

				forwardProxyChoiceTypeFound := false

				if v, ok := cs["active_forward_proxy_policies"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true
					forwardProxyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARReplaceType_ActiveForwardProxyPolicies{}
					forwardProxyChoiceInt.ActiveForwardProxyPolicies = &ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType{}
					siteTypeInt.VoltstackClusterAr.ForwardProxyChoice = forwardProxyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["forward_proxy_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								forwardProxyPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								forwardProxyChoiceInt.ActiveForwardProxyPolicies.ForwardProxyPolicies = forwardProxyPoliciesInt
								for i, ps := range sl {

									fppMapToStrVal := ps.(map[string]interface{})
									forwardProxyPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := fppMapToStrVal["name"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Name = v.(string)
									}

									if v, ok := fppMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := fppMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["forward_proxy_allow_all"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true

					if v.(bool) {
						forwardProxyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARReplaceType_ForwardProxyAllowAll{}
						forwardProxyChoiceInt.ForwardProxyAllowAll = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackClusterAr.ForwardProxyChoice = forwardProxyChoiceInt
					}

				}

				if v, ok := cs["no_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true

					if v.(bool) {
						forwardProxyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARReplaceType_NoForwardProxy{}
						forwardProxyChoiceInt.NoForwardProxy = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackClusterAr.ForwardProxyChoice = forwardProxyChoiceInt
					}

				}

				globalNetworkChoiceTypeFound := false

				if v, ok := cs["global_network_list"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

					globalNetworkChoiceTypeFound = true
					globalNetworkChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARReplaceType_GlobalNetworkList{}
					globalNetworkChoiceInt.GlobalNetworkList = &ves_io_schema_views.GlobalNetworkConnectionListType{}
					siteTypeInt.VoltstackClusterAr.GlobalNetworkChoice = globalNetworkChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["global_network_connections"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								globalNetworkConnections := make([]*ves_io_schema_views.GlobalNetworkConnectionType, len(sl))
								globalNetworkChoiceInt.GlobalNetworkList.GlobalNetworkConnections = globalNetworkConnections
								for i, set := range sl {
									if set != nil {
										globalNetworkConnections[i] = &ves_io_schema_views.GlobalNetworkConnectionType{}
										globalNetworkConnectionsMapStrToI := set.(map[string]interface{})

										connectionChoiceTypeFound := false

										if v, ok := globalNetworkConnectionsMapStrToI["sli_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

											connectionChoiceTypeFound = true
											connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SliToGlobalDr{}
											connectionChoiceInt.SliToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
											globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														globalVn := &ves_io_schema_views.ObjectRefType{}
														connectionChoiceInt.SliToGlobalDr.GlobalVn = globalVn
														for _, set := range sl {
															if set != nil {
																globalVnMapStrToI := set.(map[string]interface{})

																if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
																	globalVn.Name = w.(string)
																}

																if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
																	globalVn.Namespace = w.(string)
																}

																if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
																	globalVn.Tenant = w.(string)
																}

															}
														}

													}

												}
											}

										}

										if v, ok := globalNetworkConnectionsMapStrToI["slo_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

											connectionChoiceTypeFound = true
											connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SloToGlobalDr{}
											connectionChoiceInt.SloToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
											globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														globalVn := &ves_io_schema_views.ObjectRefType{}
														connectionChoiceInt.SloToGlobalDr.GlobalVn = globalVn
														for _, set := range sl {
															if set != nil {
																globalVnMapStrToI := set.(map[string]interface{})

																if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
																	globalVn.Name = w.(string)
																}

																if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
																	globalVn.Namespace = w.(string)
																}

																if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
																	globalVn.Tenant = w.(string)
																}

															}
														}

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["no_global_network"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

					globalNetworkChoiceTypeFound = true

					if v.(bool) {
						globalNetworkChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARReplaceType_NoGlobalNetwork{}
						globalNetworkChoiceInt.NoGlobalNetwork = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackClusterAr.GlobalNetworkChoice = globalNetworkChoiceInt
					}

				}

				networkPolicyChoiceTypeFound := false

				if v, ok := cs["active_enhanced_firewall_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true
					networkPolicyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARReplaceType_ActiveEnhancedFirewallPolicies{}
					networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies = &ves_io_schema_network_firewall.ActiveEnhancedFirewallPoliciesType{}
					siteTypeInt.VoltstackClusterAr.NetworkPolicyChoice = networkPolicyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["enhanced_firewall_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								enhancedFirewallPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies.EnhancedFirewallPolicies = enhancedFirewallPoliciesInt
								for i, ps := range sl {

									efpMapToStrVal := ps.(map[string]interface{})
									enhancedFirewallPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := efpMapToStrVal["name"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Name = v.(string)
									}

									if v, ok := efpMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := efpMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["active_network_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true
					networkPolicyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARReplaceType_ActiveNetworkPolicies{}
					networkPolicyChoiceInt.ActiveNetworkPolicies = &ves_io_schema_network_firewall.ActiveNetworkPoliciesType{}
					siteTypeInt.VoltstackClusterAr.NetworkPolicyChoice = networkPolicyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["network_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								networkPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								networkPolicyChoiceInt.ActiveNetworkPolicies.NetworkPolicies = networkPoliciesInt
								for i, ps := range sl {

									npMapToStrVal := ps.(map[string]interface{})
									networkPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := npMapToStrVal["name"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Name = v.(string)
									}

									if v, ok := npMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := npMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := cs["no_network_policy"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true

					if v.(bool) {
						networkPolicyChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARReplaceType_NoNetworkPolicy{}
						networkPolicyChoiceInt.NoNetworkPolicy = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackClusterAr.NetworkPolicyChoice = networkPolicyChoiceInt
					}

				}

				if v, ok := cs["node"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					node := &ves_io_schema_views.AzureVnetOneInterfaceNodeARType{}
					siteTypeInt.VoltstackClusterAr.Node = node
					for _, set := range sl {
						if set != nil {
							nodeMapStrToI := set.(map[string]interface{})

							if w, ok := nodeMapStrToI["fault_domain"]; ok && !isIntfNil(w) {
								node.FaultDomain = uint32(w.(int))
							}

							if v, ok := nodeMapStrToI["local_subnet"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								localSubnet := &ves_io_schema_views.AzureSubnetChoiceType{}
								node.LocalSubnet = localSubnet
								for _, set := range sl {
									if set != nil {
										localSubnetMapStrToI := set.(map[string]interface{})

										choiceTypeFound := false

										if v, ok := localSubnetMapStrToI["subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_Subnet{}
											choiceInt.Subnet = &ves_io_schema_views.AzureSubnetType{}
											localSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													resourceGroupChoiceTypeFound := false

													if v, ok := cs["subnet_resource_grp"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true
														resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_SubnetResourceGrp{}

														choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt

														resourceGroupChoiceInt.SubnetResourceGrp = v.(string)

													}

													if v, ok := cs["vnet_resource_group"]; ok && !isIntfNil(v) && !resourceGroupChoiceTypeFound {

														resourceGroupChoiceTypeFound = true

														if v.(bool) {
															resourceGroupChoiceInt := &ves_io_schema_views.AzureSubnetType_VnetResourceGroup{}
															resourceGroupChoiceInt.VnetResourceGroup = &ves_io_schema.Empty{}
															choiceInt.Subnet.ResourceGroupChoice = resourceGroupChoiceInt
														}

													}

													if v, ok := cs["subnet_name"]; ok && !isIntfNil(v) {

														choiceInt.Subnet.SubnetName = v.(string)

													}

												}
											}

										}

										if v, ok := localSubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.AzureSubnetChoiceType_SubnetParam{}
											choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
											localSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv4 = v.(string)

													}

													if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv6 = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if w, ok := nodeMapStrToI["node_number"]; ok && !isIntfNil(w) {
								node.NodeNumber = uint32(w.(int))
							}

							if w, ok := nodeMapStrToI["update_domain"]; ok && !isIntfNil(w) {
								node.UpdateDomain = uint32(w.(int))
							}

						}
					}

				}

				outsideStaticRouteChoiceTypeFound := false

				if v, ok := cs["no_outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

					outsideStaticRouteChoiceTypeFound = true

					if v.(bool) {
						outsideStaticRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARReplaceType_NoOutsideStaticRoutes{}
						outsideStaticRouteChoiceInt.NoOutsideStaticRoutes = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackClusterAr.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt
					}

				}

				if v, ok := cs["outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

					outsideStaticRouteChoiceTypeFound = true
					outsideStaticRouteChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARReplaceType_OutsideStaticRoutes{}
					outsideStaticRouteChoiceInt.OutsideStaticRoutes = &ves_io_schema_views.SiteStaticRoutesListType{}
					siteTypeInt.VoltstackClusterAr.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_route_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRouteList := make([]*ves_io_schema_views.SiteStaticRoutesType, len(sl))
								outsideStaticRouteChoiceInt.OutsideStaticRoutes.StaticRouteList = staticRouteList
								for i, set := range sl {
									if set != nil {
										staticRouteList[i] = &ves_io_schema_views.SiteStaticRoutesType{}
										staticRouteListMapStrToI := set.(map[string]interface{})

										configModeChoiceTypeFound := false

										if v, ok := staticRouteListMapStrToI["custom_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_CustomStaticRoute{}
											configModeChoiceInt.CustomStaticRoute = &ves_io_schema.StaticRouteType{}
											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["attrs"]; ok && !isIntfNil(v) {

														attrsList := []ves_io_schema.RouteAttrType{}
														for _, j := range v.([]interface{}) {
															if j == nil {
																return fmt.Errorf("please provide valid non-empty enum value of field attrs")
															}
															attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
														}
														configModeChoiceInt.CustomStaticRoute.Attrs = attrsList

													}

													if v, ok := cs["labels"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														configModeChoiceInt.CustomStaticRoute.Labels = ms
													}

													if v, ok := cs["nexthop"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														nexthop := &ves_io_schema.NextHopType{}
														configModeChoiceInt.CustomStaticRoute.Nexthop = nexthop
														for _, set := range sl {
															if set != nil {
																nexthopMapStrToI := set.(map[string]interface{})

																if v, ok := nexthopMapStrToI["interface"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	intfInt := make([]*ves_io_schema.ObjectRefType, len(sl))
																	nexthop.Interface = intfInt
																	for i, ps := range sl {

																		iMapToStrVal := ps.(map[string]interface{})
																		intfInt[i] = &ves_io_schema.ObjectRefType{}

																		intfInt[i].Kind = "network_interface"

																		if v, ok := iMapToStrVal["name"]; ok && !isIntfNil(v) {
																			intfInt[i].Name = v.(string)
																		}

																		if v, ok := iMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																			intfInt[i].Namespace = v.(string)
																		}

																		if v, ok := iMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																			intfInt[i].Tenant = v.(string)
																		}

																		if v, ok := iMapToStrVal["uid"]; ok && !isIntfNil(v) {
																			intfInt[i].Uid = v.(string)
																		}

																	}

																}

																if v, ok := nexthopMapStrToI["nexthop_address"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	nexthopAddress := &ves_io_schema.IpAddressType{}
																	nexthop.NexthopAddress = nexthopAddress
																	for _, set := range sl {
																		if set != nil {
																			nexthopAddressMapStrToI := set.(map[string]interface{})

																			verTypeFound := false

																			if v, ok := nexthopAddressMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv4{}
																				verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv4.Addr = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := nexthopAddressMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv6{}
																				verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv6.Addr = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := nexthopMapStrToI["type"]; ok && !isIntfNil(v) {

																	nexthop.Type = ves_io_schema.NextHopTypes(ves_io_schema.NextHopTypes_value[v.(string)])

																}

															}
														}

													}

													if v, ok := cs["subnets"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														subnets := make([]*ves_io_schema.IpSubnetType, len(sl))
														configModeChoiceInt.CustomStaticRoute.Subnets = subnets
														for i, set := range sl {
															if set != nil {
																subnets[i] = &ves_io_schema.IpSubnetType{}
																subnetsMapStrToI := set.(map[string]interface{})

																verTypeFound := false

																if v, ok := subnetsMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv4{}
																	verInt.Ipv4 = &ves_io_schema.Ipv4SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Prefix = v.(string)

																			}

																		}
																	}

																}

																if v, ok := subnetsMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv6{}
																	verInt.Ipv6 = &ves_io_schema.Ipv6SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Prefix = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

												}
											}

										}

										if v, ok := staticRouteListMapStrToI["simple_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_SimpleStaticRoute{}

											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											configModeChoiceInt.SimpleStaticRoute = v.(string)

										}

									}
								}

							}

						}
					}

				}

				siteMeshGroupChoiceTypeFound := false

				if v, ok := cs["sm_connection_public_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

					siteMeshGroupChoiceTypeFound = true

					if v.(bool) {
						siteMeshGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARReplaceType_SmConnectionPublicIp{}
						siteMeshGroupChoiceInt.SmConnectionPublicIp = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackClusterAr.SiteMeshGroupChoice = siteMeshGroupChoiceInt
					}

				}

				if v, ok := cs["sm_connection_pvt_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

					siteMeshGroupChoiceTypeFound = true

					if v.(bool) {
						siteMeshGroupChoiceInt := &ves_io_schema_views_azure_vnet_site.AzureVnetVoltstackClusterARReplaceType_SmConnectionPvtIp{}
						siteMeshGroupChoiceInt.SmConnectionPvtIp = &ves_io_schema.Empty{}
						siteTypeInt.VoltstackClusterAr.SiteMeshGroupChoice = siteMeshGroupChoiceInt
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("ssh_key"); ok && !isIntfNil(v) {

		updateSpec.SshKey =
			v.(string)

	}

	if v, ok := d.GetOk("vnet"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		vnet := &ves_io_schema_views.AzureVnetChoiceType{}
		updateSpec.Vnet = vnet
		for _, set := range sl {
			if set != nil {
				vnetMapStrToI := set.(map[string]interface{})

				choiceTypeFound := false

				if v, ok := vnetMapStrToI["existing_vnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

					choiceTypeFound = true
					choiceInt := &ves_io_schema_views.AzureVnetChoiceType_ExistingVnet{}
					choiceInt.ExistingVnet = &ves_io_schema_views.AzureVnetType{}
					vnet.Choice = choiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["resource_group"]; ok && !isIntfNil(v) {

								choiceInt.ExistingVnet.ResourceGroup = v.(string)

							}

							routingTypeTypeFound := false

							if v, ok := cs["f5_orchestrated_routing"]; ok && !isIntfNil(v) && !routingTypeTypeFound {

								routingTypeTypeFound = true

								if v.(bool) {
									routingTypeInt := &ves_io_schema_views.AzureVnetType_F5OrchestratedRouting{}
									routingTypeInt.F5OrchestratedRouting = &ves_io_schema.Empty{}
									choiceInt.ExistingVnet.RoutingType = routingTypeInt
								}

							}

							if v, ok := cs["manual_routing"]; ok && !isIntfNil(v) && !routingTypeTypeFound {

								routingTypeTypeFound = true

								if v.(bool) {
									routingTypeInt := &ves_io_schema_views.AzureVnetType_ManualRouting{}
									routingTypeInt.ManualRouting = &ves_io_schema.Empty{}
									choiceInt.ExistingVnet.RoutingType = routingTypeInt
								}

							}

							if v, ok := cs["vnet_name"]; ok && !isIntfNil(v) {

								choiceInt.ExistingVnet.VnetName = v.(string)

							}

						}
					}

				}

				if v, ok := vnetMapStrToI["new_vnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

					choiceTypeFound = true
					choiceInt := &ves_io_schema_views.AzureVnetChoiceType_NewVnet{}
					choiceInt.NewVnet = &ves_io_schema_views.AzureVnetParamsType{}
					vnet.Choice = choiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							nameChoiceTypeFound := false

							if v, ok := cs["autogenerate"]; ok && !isIntfNil(v) && !nameChoiceTypeFound {

								nameChoiceTypeFound = true

								if v.(bool) {
									nameChoiceInt := &ves_io_schema_views.AzureVnetParamsType_Autogenerate{}
									nameChoiceInt.Autogenerate = &ves_io_schema.Empty{}
									choiceInt.NewVnet.NameChoice = nameChoiceInt
								}

							}

							if v, ok := cs["name"]; ok && !isIntfNil(v) && !nameChoiceTypeFound {

								nameChoiceTypeFound = true
								nameChoiceInt := &ves_io_schema_views.AzureVnetParamsType_Name{}

								choiceInt.NewVnet.NameChoice = nameChoiceInt

								nameChoiceInt.Name = v.(string)

							}

							if v, ok := cs["primary_ipv4"]; ok && !isIntfNil(v) {

								choiceInt.NewVnet.PrimaryIpv4 = v.(string)

							}

						}
					}

				}

			}
		}

	}

	workerNodesTypeFound := false

	if v, ok := d.GetOk("no_worker_nodes"); ok && !workerNodesTypeFound {

		workerNodesTypeFound = true

		if v.(bool) {
			workerNodesInt := &ves_io_schema_views_azure_vnet_site.ReplaceSpecType_NoWorkerNodes{}
			workerNodesInt.NoWorkerNodes = &ves_io_schema.Empty{}
			updateSpec.WorkerNodes = workerNodesInt
		}

	}

	if v, ok := d.GetOk("nodes_per_az"); ok && !isIntfNil(v) && !workerNodesTypeFound {

		workerNodesTypeFound = true
		workerNodesInt := &ves_io_schema_views_azure_vnet_site.ReplaceSpecType_NodesPerAz{}

		updateSpec.WorkerNodes = workerNodesInt

		workerNodesInt.NodesPerAz = uint32(v.(int))

	}

	if v, ok := d.GetOk("total_nodes"); ok && !isIntfNil(v) && !workerNodesTypeFound {

		workerNodesTypeFound = true
		workerNodesInt := &ves_io_schema_views_azure_vnet_site.ReplaceSpecType_TotalNodes{}

		updateSpec.WorkerNodes = workerNodesInt

		workerNodesInt.TotalNodes = uint32(v.(int))

	}

	log.Printf("[DEBUG] Updating Volterra AzureVnetSite obj with struct: %+v", updateReq)

	err := client.ReplaceObject(context.Background(), ves_io_schema_views_azure_vnet_site.ObjectType, updateReq)
	if err != nil {
		return fmt.Errorf("error updating AzureVnetSite: %s", err)
	}

	return resourceVolterraAzureVnetSiteRead(d, meta)
}

func resourceVolterraAzureVnetSiteDelete(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	_, err := client.GetObject(context.Background(), ves_io_schema_views_azure_vnet_site.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] AzureVnetSite %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra AzureVnetSite before deleting %q: %s", d.Id(), err)
	}

	log.Printf("[DEBUG] Deleting Volterra AzureVnetSite obj with name %+v in namespace %+v", name, namespace)
	opts := []vesapi.CallOpt{
		vesapi.WithFailIfReferred(),
	}
	return client.DeleteObject(context.Background(), ves_io_schema_views_azure_vnet_site.ObjectType, namespace, name, opts...)
}
