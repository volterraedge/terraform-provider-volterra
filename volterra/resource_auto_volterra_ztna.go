//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-tf-provider. DO NOT EDIT.
//

package volterra

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"gopkg.volterra.us/stdlib/client/vesapi"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_ztna "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/ztna"
)

// resourceVolterraZtna is implementation of Volterra's Ztna resources
func resourceVolterraZtna() *schema.Resource {
	return &schema.Resource{
		Create: resourceVolterraZtnaCreate,
		Read:   resourceVolterraZtnaRead,
		Update: resourceVolterraZtnaUpdate,
		Delete: resourceVolterraZtnaDelete,

		Schema: map[string]*schema.Schema{

			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"description": {
				Type:     schema.TypeString,
				Optional: true,
			},

			"disable": {
				Type:     schema.TypeBool,
				Optional: true,
			},

			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"namespace": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"connectivity": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"connectivities": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"connectivity_policy_name": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"per_session": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"external_server": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Required: true,
									},
									"value": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"admin_password": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"blindfold_secret_info": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"decryption_provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"location": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"store_provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"clear_secret_info": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"url": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																	},
																},
															},
														},
													},
												},

												"admin_username": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"domain": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"server_type": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"lease_pool_member": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Required: true,
									},
									"value": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"end_address": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"ipv4": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"addr": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"ipv6": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"addr": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},

												"start_address": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"ipv4": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"addr": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"ipv6": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"addr": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"per_session_policy_name": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"resources": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Required: true,
									},
									"value": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"acl": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"entries": {

																Type:     schema.TypeList,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"action": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"destination_end_port": {
																			Type:     schema.TypeInt,
																			Optional: true,
																		},

																		"destination_ip": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"ipv4": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"addr": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"ipv6": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"addr": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"destination_start_port": {
																			Type:     schema.TypeInt,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},

												"connectivity": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"web": {

													Type:     schema.TypeBool,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"sequence_action": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"connectivity_access_policy_name": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"next_action": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"active_directory_auth": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"active_directory_query": {

																Type:     schema.TypeList,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"deny_name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"filter": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"resource_assign": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"allow": {

																						Type:     schema.TypeList,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"allow_name": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"deny_name": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"rules_resource_assign": {

																									Type:     schema.TypeList,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"acls": {

																												Type: schema.TypeList,

																												Optional: true,
																												Elem: &schema.Schema{
																													Type: schema.TypeString,
																												},
																											},

																											"network_access_rule": {

																												Type: schema.TypeList,

																												Optional: true,
																												Elem: &schema.Schema{
																													Type: schema.TypeString,
																												},
																											},

																											"web_top_name": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},
																										},
																									},
																								},

																								"server": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"server": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"deny_name": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"expression": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"server": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"active_directory_query": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"deny_name": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"filter": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"resource_assign": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"allow": {

																			Type:     schema.TypeList,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"allow_name": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"deny_name": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"rules_resource_assign": {

																						Type:     schema.TypeList,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"acls": {

																									Type: schema.TypeList,

																									Optional: true,
																									Elem: &schema.Schema{
																										Type: schema.TypeString,
																									},
																								},

																								"network_access_rule": {

																									Type: schema.TypeList,

																									Optional: true,
																									Elem: &schema.Schema{
																										Type: schema.TypeString,
																									},
																								},

																								"web_top_name": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"server": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"server": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"log_on": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"active_directory_auth": {

																Type:     schema.TypeList,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"active_directory_query": {

																			Type:     schema.TypeList,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"deny_name": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"filter": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"resource_assign": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"allow": {

																									Type:     schema.TypeList,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"allow_name": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"deny_name": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"rules_resource_assign": {

																												Type:     schema.TypeList,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"acls": {

																															Type: schema.TypeList,

																															Optional: true,
																															Elem: &schema.Schema{
																																Type: schema.TypeString,
																															},
																														},

																														"network_access_rule": {

																															Type: schema.TypeList,

																															Optional: true,
																															Elem: &schema.Schema{
																																Type: schema.TypeString,
																															},
																														},

																														"web_top_name": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},
																													},
																												},
																											},

																											"server": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},

																					"server": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"deny_name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"expression": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"server": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"customization": {

																Type:     schema.TypeList,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"password": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"blindfold_secret_info": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"decryption_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"location": {
																									Type:     schema.TypeString,
																									Required: true,
																								},

																								"store_provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"clear_secret_info": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"provider": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"url": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"user_name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},

												"resource_assign": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"allow": {

																Type:     schema.TypeList,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"allow_name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"deny_name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"rules_resource_assign": {

																			Type:     schema.TypeList,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"acls": {

																						Type: schema.TypeList,

																						Optional: true,
																						Elem: &schema.Schema{
																							Type: schema.TypeString,
																						},
																					},

																					"network_access_rule": {

																						Type: schema.TypeList,

																						Optional: true,
																						Elem: &schema.Schema{
																							Type: schema.TypeString,
																						},
																					},

																					"web_top_name": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"server": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

// resourceVolterraZtnaCreate creates Ztna resource
func resourceVolterraZtnaCreate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	createMeta := &ves_io_schema.ObjectCreateMetaType{}
	createSpec := &ves_io_schema_ztna.CreateSpecType{}
	createReq := &ves_io_schema_ztna.CreateRequest{
		Metadata: createMeta,
		Spec:     createSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		createMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		createMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		createMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		createMeta.Namespace =
			v.(string)
	}

	//connectivity
	if v, ok := d.GetOk("connectivity"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		connectivity := &ves_io_schema_ztna.ConnectivityPolicyType{}
		createSpec.Connectivity = connectivity
		for _, set := range sl {
			if set != nil {
				connectivityMapStrToI := set.(map[string]interface{})

				if v, ok := connectivityMapStrToI["connectivities"]; ok && !isIntfNil(v) {

					connectivity.Connectivities = ves_io_schema_ztna.Connectivity(ves_io_schema_ztna.Connectivity_value[v.(string)])

				}

				if w, ok := connectivityMapStrToI["connectivity_policy_name"]; ok && !isIntfNil(w) {
					connectivity.ConnectivityPolicyName = w.(string)
				}

			}
		}

	}

	//per_session
	if v, ok := d.GetOk("per_session"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		perSession := &ves_io_schema_ztna.PerSessionPolicyType{}
		createSpec.PerSession = perSession
		for _, set := range sl {
			if set != nil {
				perSessionMapStrToI := set.(map[string]interface{})

				if v, ok := perSessionMapStrToI["external_server"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					externalServer := make(map[string]*ves_io_schema_ztna.ExternalServers)
					perSession.ExternalServer = externalServer
					for _, set := range sl {
						if set != nil {
							externalServerMapStrToI := set.(map[string]interface{})
							key, ok := externalServerMapStrToI["name"]
							if ok && !isIntfNil(key) {
								externalServer[key.(string)] = &ves_io_schema_ztna.ExternalServers{}
								val, _ := externalServerMapStrToI["value"]

								externalServerVals := val.([]interface{})
								for _, intVal := range externalServerVals {
									if intVal != nil {

										externalServerStaticMap := intVal.(map[string]interface{})

										if w, ok := externalServerStaticMap["admin_password"]; ok && !isIntfNil(w) {
											externalServer[key.(string)].AdminPassword = w.(*ves_io_schema.SecretType)
										}

										if w, ok := externalServerStaticMap["admin_username"]; ok && !isIntfNil(w) {
											externalServer[key.(string)].AdminUsername = w.(string)
										}

										if w, ok := externalServerStaticMap["domain"]; ok && !isIntfNil(w) {
											externalServer[key.(string)].Domain = w.(string)
										}

										if w, ok := externalServerStaticMap["server_type"]; ok && !isIntfNil(w) {
											externalServer[key.(string)].ServerType =  w.(ves_io_schema_ztna.ServerType)
										}

										// break after one loop
										break
									}
								}
							}
						}
					}

				}

				if v, ok := perSessionMapStrToI["lease_pool_member"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					leasePoolMember := make(map[string]*ves_io_schema_ztna.LeasePoolMember)
					perSession.LeasePoolMember = leasePoolMember
					for _, set := range sl {
						if set != nil {
							leasePoolMemberMapStrToI := set.(map[string]interface{})
							key, ok := leasePoolMemberMapStrToI["name"]
							if ok && !isIntfNil(key) {
								leasePoolMember[key.(string)] = &ves_io_schema_ztna.LeasePoolMember{}
								val, _ := leasePoolMemberMapStrToI["value"]

								leasePoolMemberVals := val.([]interface{})
								for _, intVal := range leasePoolMemberVals {
									if intVal != nil {

										leasePoolMemberStaticMap := intVal.(map[string]interface{})

										if w, ok := leasePoolMemberStaticMap["end_address"]; ok && !isIntfNil(w) {
											leasePoolMember[key.(string)].EndAddress = w.(*ves_io_schema.IpAddressType)
										}

										if w, ok := leasePoolMemberStaticMap["start_address"]; ok && !isIntfNil(w) {
											leasePoolMember[key.(string)].StartAddress = w.(*ves_io_schema.IpAddressType)
										}

										// break after one loop
										break
									}
								}
							}
						}
					}

				}

				if w, ok := perSessionMapStrToI["per_session_policy_name"]; ok && !isIntfNil(w) {
					perSession.PerSessionPolicyName = w.(string)
				}

				if v, ok := perSessionMapStrToI["resources"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					resources := make(map[string]*ves_io_schema_ztna.Resource)
					perSession.Resources = resources
					for _, set := range sl {
						if set != nil {
							resourcesMapStrToI := set.(map[string]interface{})
							key, ok := resourcesMapStrToI["name"]
							if ok && !isIntfNil(key) {
								resources[key.(string)] = &ves_io_schema_ztna.Resource{}
								val, _ := resourcesMapStrToI["value"]

								resourcesVals := val.([]interface{})
								for _, intVal := range resourcesVals {
									if intVal != nil {

										resourcesStaticMap := intVal.(map[string]interface{})

										resourceTypeTypeFound := false

										if v, ok := resourcesStaticMap["acl"]; ok && !isIntfNil(v) && !resourceTypeTypeFound {

											resourceTypeTypeFound = true
											resourceTypeInt := &ves_io_schema_ztna.Resource_Acl{}
											resourceTypeInt.Acl = &ves_io_schema_ztna.AclResourceEntry{}
											resources[key.(string)].ResourceType = resourceTypeInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["entries"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														entries := make([]*ves_io_schema_ztna.Entry, len(sl))
														resourceTypeInt.Acl.Entries = entries
														for i, set := range sl {
															if set != nil {
																entries[i] = &ves_io_schema_ztna.Entry{}
																entriesMapStrToI := set.(map[string]interface{})

																if v, ok := entriesMapStrToI["action"]; ok && !isIntfNil(v) {

																	entries[i].Action = ves_io_schema_ztna.Action(ves_io_schema_ztna.Action_value[v.(string)])

																}

																if w, ok := entriesMapStrToI["destination_end_port"]; ok && !isIntfNil(w) {
																	entries[i].DestinationEndPort = uint32(w.(int))
																}

																if v, ok := entriesMapStrToI["destination_ip"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	destinationIp := &ves_io_schema.IpAddressType{}
																	entries[i].DestinationIp = destinationIp
																	for _, set := range sl {
																		if set != nil {
																			destinationIpMapStrToI := set.(map[string]interface{})

																			verTypeFound := false

																			if v, ok := destinationIpMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv4{}
																				verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
																				destinationIp.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv4.Addr = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := destinationIpMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv6{}
																				verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
																				destinationIp.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv6.Addr = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if w, ok := entriesMapStrToI["destination_start_port"]; ok && !isIntfNil(w) {
																	entries[i].DestinationStartPort = uint32(w.(int))
																}

															}
														}

													}

												}
											}

										}

										if v, ok := resourcesStaticMap["connectivity"]; ok && !isIntfNil(v) && !resourceTypeTypeFound {

											resourceTypeTypeFound = true

											if v.(bool) {
												resourceTypeInt := &ves_io_schema_ztna.Resource_Connectivity{}
												resourceTypeInt.Connectivity = &ves_io_schema.Empty{}
												resources[key.(string)].ResourceType = resourceTypeInt
											}

										}

										if v, ok := resourcesStaticMap["web"]; ok && !isIntfNil(v) && !resourceTypeTypeFound {

											resourceTypeTypeFound = true

											if v.(bool) {
												resourceTypeInt := &ves_io_schema_ztna.Resource_Web{}
												resourceTypeInt.Web = &ves_io_schema.Empty{}
												resources[key.(string)].ResourceType = resourceTypeInt
											}

										}

										// break after one loop
										break
									}
								}
							}
						}
					}

				}

				if v, ok := perSessionMapStrToI["sequence_action"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					sequenceAction := &ves_io_schema_ztna.SequenceAction{}
					perSession.SequenceAction = sequenceAction
					for _, set := range sl {
						if set != nil {
							sequenceActionMapStrToI := set.(map[string]interface{})

							if w, ok := sequenceActionMapStrToI["connectivity_access_policy_name"]; ok && !isIntfNil(w) {
								sequenceAction.ConnectivityAccessPolicyName = w.(string)
							}

							if v, ok := sequenceActionMapStrToI["next_action"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								nextAction := &ves_io_schema_ztna.ActionType{}
								sequenceAction.NextAction = nextAction
								for _, set := range sl {
									if set != nil {
										nextActionMapStrToI := set.(map[string]interface{})

										itemTypeTypeFound := false

										if v, ok := nextActionMapStrToI["active_directory_auth"]; ok && !isIntfNil(v) && !itemTypeTypeFound {

											itemTypeTypeFound = true
											itemTypeInt := &ves_io_schema_ztna.ActionType_ActiveDirectoryAuth{}
											itemTypeInt.ActiveDirectoryAuth = &ves_io_schema_ztna.ActiveDirectoryAuth{}
											nextAction.ItemType = itemTypeInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["active_directory_query"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														activeDirectoryQuery := make([]*ves_io_schema_ztna.ActiveDirectoryQuery, len(sl))
														itemTypeInt.ActiveDirectoryAuth.ActiveDirectoryQuery = activeDirectoryQuery
														for i, set := range sl {
															if set != nil {
																activeDirectoryQuery[i] = &ves_io_schema_ztna.ActiveDirectoryQuery{}
																activeDirectoryQueryMapStrToI := set.(map[string]interface{})

																if w, ok := activeDirectoryQueryMapStrToI["deny_name"]; ok && !isIntfNil(w) {
																	activeDirectoryQuery[i].DenyName = w.(string)
																}

																if w, ok := activeDirectoryQueryMapStrToI["filter"]; ok && !isIntfNil(w) {
																	activeDirectoryQuery[i].Filter = w.(string)
																}

																if v, ok := activeDirectoryQueryMapStrToI["resource_assign"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	resourceAssign := &ves_io_schema_ztna.ResourceAssign{}
																	activeDirectoryQuery[i].ResourceAssign = resourceAssign
																	for _, set := range sl {
																		if set != nil {
																			resourceAssignMapStrToI := set.(map[string]interface{})

																			if v, ok := resourceAssignMapStrToI["allow"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				allow := make([]*ves_io_schema_ztna.AllowResourceAssign, len(sl))
																				resourceAssign.Allow = allow
																				for i, set := range sl {
																					if set != nil {
																						allow[i] = &ves_io_schema_ztna.AllowResourceAssign{}
																						allowMapStrToI := set.(map[string]interface{})

																						if w, ok := allowMapStrToI["allow_name"]; ok && !isIntfNil(w) {
																							allow[i].AllowName = w.(string)
																						}

																						if w, ok := allowMapStrToI["deny_name"]; ok && !isIntfNil(w) {
																							allow[i].DenyName = w.(string)
																						}

																						if v, ok := allowMapStrToI["rules_resource_assign"]; ok && !isIntfNil(v) {

																							sl := v.([]interface{})
																							rulesResourceAssign := make([]*ves_io_schema_ztna.Rules, len(sl))
																							allow[i].RulesResourceAssign = rulesResourceAssign
																							for i, set := range sl {
																								if set != nil {
																									rulesResourceAssign[i] = &ves_io_schema_ztna.Rules{}
																									rulesResourceAssignMapStrToI := set.(map[string]interface{})

																									if w, ok := rulesResourceAssignMapStrToI["acls"]; ok && !isIntfNil(w) {
																										ls := make([]string, len(w.([]interface{})))
																										for i, v := range w.([]interface{}) {
																											if v == nil {
																												return fmt.Errorf("please provide valid non-empty string value of field acls")
																											}
																											if str, ok := v.(string); ok {
																												ls[i] = str
																											}
																										}
																										rulesResourceAssign[i].Acls = ls
																									}

																									if w, ok := rulesResourceAssignMapStrToI["network_access_rule"]; ok && !isIntfNil(w) {
																										ls := make([]string, len(w.([]interface{})))
																										for i, v := range w.([]interface{}) {
																											if v == nil {
																												return fmt.Errorf("please provide valid non-empty string value of field network_access_rule")
																											}
																											if str, ok := v.(string); ok {
																												ls[i] = str
																											}
																										}
																										rulesResourceAssign[i].NetworkAccessRule = ls
																									}

																									if w, ok := rulesResourceAssignMapStrToI["web_top_name"]; ok && !isIntfNil(w) {
																										rulesResourceAssign[i].WebTopName = w.(string)
																									}

																								}
																							}

																						}

																						if w, ok := allowMapStrToI["server"]; ok && !isIntfNil(w) {
																							allow[i].Server = w.(string)
																						}

																					}
																				}

																			}

																		}
																	}

																}

																if w, ok := activeDirectoryQueryMapStrToI["server"]; ok && !isIntfNil(w) {
																	activeDirectoryQuery[i].Server = w.(string)
																}

															}
														}

													}

													if v, ok := cs["deny_name"]; ok && !isIntfNil(v) {

														itemTypeInt.ActiveDirectoryAuth.DenyName = v.(string)

													}

													if v, ok := cs["expression"]; ok && !isIntfNil(v) {

														itemTypeInt.ActiveDirectoryAuth.Expression = v.(string)

													}

													if v, ok := cs["server"]; ok && !isIntfNil(v) {

														itemTypeInt.ActiveDirectoryAuth.Server = v.(string)

													}

												}
											}

										}

										if v, ok := nextActionMapStrToI["active_directory_query"]; ok && !isIntfNil(v) && !itemTypeTypeFound {

											itemTypeTypeFound = true
											itemTypeInt := &ves_io_schema_ztna.ActionType_ActiveDirectoryQuery{}
											itemTypeInt.ActiveDirectoryQuery = &ves_io_schema_ztna.ActiveDirectoryQuery{}
											nextAction.ItemType = itemTypeInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["deny_name"]; ok && !isIntfNil(v) {

														itemTypeInt.ActiveDirectoryQuery.DenyName = v.(string)

													}

													if v, ok := cs["filter"]; ok && !isIntfNil(v) {

														itemTypeInt.ActiveDirectoryQuery.Filter = v.(string)

													}

													if v, ok := cs["resource_assign"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														resourceAssign := &ves_io_schema_ztna.ResourceAssign{}
														itemTypeInt.ActiveDirectoryQuery.ResourceAssign = resourceAssign
														for _, set := range sl {
															if set != nil {
																resourceAssignMapStrToI := set.(map[string]interface{})

																if v, ok := resourceAssignMapStrToI["allow"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	allow := make([]*ves_io_schema_ztna.AllowResourceAssign, len(sl))
																	resourceAssign.Allow = allow
																	for i, set := range sl {
																		if set != nil {
																			allow[i] = &ves_io_schema_ztna.AllowResourceAssign{}
																			allowMapStrToI := set.(map[string]interface{})

																			if w, ok := allowMapStrToI["allow_name"]; ok && !isIntfNil(w) {
																				allow[i].AllowName = w.(string)
																			}

																			if w, ok := allowMapStrToI["deny_name"]; ok && !isIntfNil(w) {
																				allow[i].DenyName = w.(string)
																			}

																			if v, ok := allowMapStrToI["rules_resource_assign"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				rulesResourceAssign := make([]*ves_io_schema_ztna.Rules, len(sl))
																				allow[i].RulesResourceAssign = rulesResourceAssign
																				for i, set := range sl {
																					if set != nil {
																						rulesResourceAssign[i] = &ves_io_schema_ztna.Rules{}
																						rulesResourceAssignMapStrToI := set.(map[string]interface{})

																						if w, ok := rulesResourceAssignMapStrToI["acls"]; ok && !isIntfNil(w) {
																							ls := make([]string, len(w.([]interface{})))
																							for i, v := range w.([]interface{}) {
																								if v == nil {
																									return fmt.Errorf("please provide valid non-empty string value of field acls")
																								}
																								if str, ok := v.(string); ok {
																									ls[i] = str
																								}
																							}
																							rulesResourceAssign[i].Acls = ls
																						}

																						if w, ok := rulesResourceAssignMapStrToI["network_access_rule"]; ok && !isIntfNil(w) {
																							ls := make([]string, len(w.([]interface{})))
																							for i, v := range w.([]interface{}) {
																								if v == nil {
																									return fmt.Errorf("please provide valid non-empty string value of field network_access_rule")
																								}
																								if str, ok := v.(string); ok {
																									ls[i] = str
																								}
																							}
																							rulesResourceAssign[i].NetworkAccessRule = ls
																						}

																						if w, ok := rulesResourceAssignMapStrToI["web_top_name"]; ok && !isIntfNil(w) {
																							rulesResourceAssign[i].WebTopName = w.(string)
																						}

																					}
																				}

																			}

																			if w, ok := allowMapStrToI["server"]; ok && !isIntfNil(w) {
																				allow[i].Server = w.(string)
																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := cs["server"]; ok && !isIntfNil(v) {

														itemTypeInt.ActiveDirectoryQuery.Server = v.(string)

													}

												}
											}

										}

										if v, ok := nextActionMapStrToI["log_on"]; ok && !isIntfNil(v) && !itemTypeTypeFound {

											itemTypeTypeFound = true
											itemTypeInt := &ves_io_schema_ztna.ActionType_LogOn{}
											itemTypeInt.LogOn = &ves_io_schema_ztna.LogonItemType{}
											nextAction.ItemType = itemTypeInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["active_directory_auth"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														activeDirectoryAuth := make([]*ves_io_schema_ztna.ActiveDirectoryAuth, len(sl))
														itemTypeInt.LogOn.ActiveDirectoryAuth = activeDirectoryAuth
														for i, set := range sl {
															if set != nil {
																activeDirectoryAuth[i] = &ves_io_schema_ztna.ActiveDirectoryAuth{}
																activeDirectoryAuthMapStrToI := set.(map[string]interface{})

																if v, ok := activeDirectoryAuthMapStrToI["active_directory_query"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	activeDirectoryQuery := make([]*ves_io_schema_ztna.ActiveDirectoryQuery, len(sl))
																	activeDirectoryAuth[i].ActiveDirectoryQuery = activeDirectoryQuery
																	for i, set := range sl {
																		if set != nil {
																			activeDirectoryQuery[i] = &ves_io_schema_ztna.ActiveDirectoryQuery{}
																			activeDirectoryQueryMapStrToI := set.(map[string]interface{})

																			if w, ok := activeDirectoryQueryMapStrToI["deny_name"]; ok && !isIntfNil(w) {
																				activeDirectoryQuery[i].DenyName = w.(string)
																			}

																			if w, ok := activeDirectoryQueryMapStrToI["filter"]; ok && !isIntfNil(w) {
																				activeDirectoryQuery[i].Filter = w.(string)
																			}

																			if v, ok := activeDirectoryQueryMapStrToI["resource_assign"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				resourceAssign := &ves_io_schema_ztna.ResourceAssign{}
																				activeDirectoryQuery[i].ResourceAssign = resourceAssign
																				for _, set := range sl {
																					if set != nil {
																						resourceAssignMapStrToI := set.(map[string]interface{})

																						if v, ok := resourceAssignMapStrToI["allow"]; ok && !isIntfNil(v) {

																							sl := v.([]interface{})
																							allow := make([]*ves_io_schema_ztna.AllowResourceAssign, len(sl))
																							resourceAssign.Allow = allow
																							for i, set := range sl {
																								if set != nil {
																									allow[i] = &ves_io_schema_ztna.AllowResourceAssign{}
																									allowMapStrToI := set.(map[string]interface{})

																									if w, ok := allowMapStrToI["allow_name"]; ok && !isIntfNil(w) {
																										allow[i].AllowName = w.(string)
																									}

																									if w, ok := allowMapStrToI["deny_name"]; ok && !isIntfNil(w) {
																										allow[i].DenyName = w.(string)
																									}

																									if v, ok := allowMapStrToI["rules_resource_assign"]; ok && !isIntfNil(v) {

																										sl := v.([]interface{})
																										rulesResourceAssign := make([]*ves_io_schema_ztna.Rules, len(sl))
																										allow[i].RulesResourceAssign = rulesResourceAssign
																										for i, set := range sl {
																											if set != nil {
																												rulesResourceAssign[i] = &ves_io_schema_ztna.Rules{}
																												rulesResourceAssignMapStrToI := set.(map[string]interface{})

																												if w, ok := rulesResourceAssignMapStrToI["acls"]; ok && !isIntfNil(w) {
																													ls := make([]string, len(w.([]interface{})))
																													for i, v := range w.([]interface{}) {
																														if v == nil {
																															return fmt.Errorf("please provide valid non-empty string value of field acls")
																														}
																														if str, ok := v.(string); ok {
																															ls[i] = str
																														}
																													}
																													rulesResourceAssign[i].Acls = ls
																												}

																												if w, ok := rulesResourceAssignMapStrToI["network_access_rule"]; ok && !isIntfNil(w) {
																													ls := make([]string, len(w.([]interface{})))
																													for i, v := range w.([]interface{}) {
																														if v == nil {
																															return fmt.Errorf("please provide valid non-empty string value of field network_access_rule")
																														}
																														if str, ok := v.(string); ok {
																															ls[i] = str
																														}
																													}
																													rulesResourceAssign[i].NetworkAccessRule = ls
																												}

																												if w, ok := rulesResourceAssignMapStrToI["web_top_name"]; ok && !isIntfNil(w) {
																													rulesResourceAssign[i].WebTopName = w.(string)
																												}

																											}
																										}

																									}

																									if w, ok := allowMapStrToI["server"]; ok && !isIntfNil(w) {
																										allow[i].Server = w.(string)
																									}

																								}
																							}

																						}

																					}
																				}

																			}

																			if w, ok := activeDirectoryQueryMapStrToI["server"]; ok && !isIntfNil(w) {
																				activeDirectoryQuery[i].Server = w.(string)
																			}

																		}
																	}

																}

																if w, ok := activeDirectoryAuthMapStrToI["deny_name"]; ok && !isIntfNil(w) {
																	activeDirectoryAuth[i].DenyName = w.(string)
																}

																if w, ok := activeDirectoryAuthMapStrToI["expression"]; ok && !isIntfNil(w) {
																	activeDirectoryAuth[i].Expression = w.(string)
																}

																if w, ok := activeDirectoryAuthMapStrToI["server"]; ok && !isIntfNil(w) {
																	activeDirectoryAuth[i].Server = w.(string)
																}

															}
														}

													}

													if v, ok := cs["customization"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														customization := make([]*ves_io_schema_ztna.Custmization, len(sl))
														itemTypeInt.LogOn.Customization = customization
														for i, set := range sl {
															if set != nil {
																customization[i] = &ves_io_schema_ztna.Custmization{}
																customizationMapStrToI := set.(map[string]interface{})

																if v, ok := customizationMapStrToI["password"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	password := &ves_io_schema.SecretType{}
																	customization[i].Password = password
																	for _, set := range sl {
																		if set != nil {
																			passwordMapStrToI := set.(map[string]interface{})

																			secretInfoOneofTypeFound := false

																			if v, ok := passwordMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																				secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																				password.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																						}

																						if v, ok := cs["location"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																						}

																						if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := passwordMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																				secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																				password.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																						}

																						if v, ok := cs["url"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if w, ok := customizationMapStrToI["user_name"]; ok && !isIntfNil(w) {
																	customization[i].UserName = w.(string)
																}

															}
														}

													}

												}
											}

										}

										if v, ok := nextActionMapStrToI["resource_assign"]; ok && !isIntfNil(v) && !itemTypeTypeFound {

											itemTypeTypeFound = true
											itemTypeInt := &ves_io_schema_ztna.ActionType_ResourceAssign{}
											itemTypeInt.ResourceAssign = &ves_io_schema_ztna.ResourceAssign{}
											nextAction.ItemType = itemTypeInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["allow"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														allow := make([]*ves_io_schema_ztna.AllowResourceAssign, len(sl))
														itemTypeInt.ResourceAssign.Allow = allow
														for i, set := range sl {
															if set != nil {
																allow[i] = &ves_io_schema_ztna.AllowResourceAssign{}
																allowMapStrToI := set.(map[string]interface{})

																if w, ok := allowMapStrToI["allow_name"]; ok && !isIntfNil(w) {
																	allow[i].AllowName = w.(string)
																}

																if w, ok := allowMapStrToI["deny_name"]; ok && !isIntfNil(w) {
																	allow[i].DenyName = w.(string)
																}

																if v, ok := allowMapStrToI["rules_resource_assign"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	rulesResourceAssign := make([]*ves_io_schema_ztna.Rules, len(sl))
																	allow[i].RulesResourceAssign = rulesResourceAssign
																	for i, set := range sl {
																		if set != nil {
																			rulesResourceAssign[i] = &ves_io_schema_ztna.Rules{}
																			rulesResourceAssignMapStrToI := set.(map[string]interface{})

																			if w, ok := rulesResourceAssignMapStrToI["acls"]; ok && !isIntfNil(w) {
																				ls := make([]string, len(w.([]interface{})))
																				for i, v := range w.([]interface{}) {
																					if v == nil {
																						return fmt.Errorf("please provide valid non-empty string value of field acls")
																					}
																					if str, ok := v.(string); ok {
																						ls[i] = str
																					}
																				}
																				rulesResourceAssign[i].Acls = ls
																			}

																			if w, ok := rulesResourceAssignMapStrToI["network_access_rule"]; ok && !isIntfNil(w) {
																				ls := make([]string, len(w.([]interface{})))
																				for i, v := range w.([]interface{}) {
																					if v == nil {
																						return fmt.Errorf("please provide valid non-empty string value of field network_access_rule")
																					}
																					if str, ok := v.(string); ok {
																						ls[i] = str
																					}
																				}
																				rulesResourceAssign[i].NetworkAccessRule = ls
																			}

																			if w, ok := rulesResourceAssignMapStrToI["web_top_name"]; ok && !isIntfNil(w) {
																				rulesResourceAssign[i].WebTopName = w.(string)
																			}

																		}
																	}

																}

																if w, ok := allowMapStrToI["server"]; ok && !isIntfNil(w) {
																	allow[i].Server = w.(string)
																}

															}
														}

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

			}
		}

	}

	log.Printf("[DEBUG] Creating Volterra Ztna object with struct: %+v", createReq)

	createZtnaResp, err := client.CreateObject(context.Background(), ves_io_schema_ztna.ObjectType, createReq)
	if err != nil {
		return fmt.Errorf("error creating Ztna: %s", err)
	}
	d.SetId(createZtnaResp.GetObjSystemMetadata().GetUid())

	return resourceVolterraZtnaRead(d, meta)
}

func resourceVolterraZtnaRead(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	resp, err := client.GetObject(context.Background(), ves_io_schema_ztna.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] Ztna %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra Ztna %q: %s", d.Id(), err)
	}
	return setZtnaFields(client, d, resp)
}

func setZtnaFields(client *APIClient, d *schema.ResourceData, resp vesapi.GetObjectResponse) error {
	metadata := resp.GetObjMetadata()

	d.Set("annotations", metadata.GetAnnotations())

	d.Set("description", metadata.GetDescription())

	d.Set("disable", metadata.GetDisable())

	d.Set("labels", metadata.GetLabels())

	d.Set("name", metadata.GetName())

	d.Set("namespace", metadata.GetNamespace())

	return nil
}

// resourceVolterraZtnaUpdate updates Ztna resource
func resourceVolterraZtnaUpdate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	updateMeta := &ves_io_schema.ObjectReplaceMetaType{}
	updateSpec := &ves_io_schema_ztna.ReplaceSpecType{}
	updateReq := &ves_io_schema_ztna.ReplaceRequest{
		Metadata: updateMeta,
		Spec:     updateSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		updateMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		updateMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		updateMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		updateMeta.Namespace =
			v.(string)
	}

	if v, ok := d.GetOk("connectivity"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		connectivity := &ves_io_schema_ztna.ConnectivityPolicyType{}
		updateSpec.Connectivity = connectivity
		for _, set := range sl {
			if set != nil {
				connectivityMapStrToI := set.(map[string]interface{})

				if v, ok := connectivityMapStrToI["connectivities"]; ok && !isIntfNil(v) {

					connectivity.Connectivities = ves_io_schema_ztna.Connectivity(ves_io_schema_ztna.Connectivity_value[v.(string)])

				}

				if w, ok := connectivityMapStrToI["connectivity_policy_name"]; ok && !isIntfNil(w) {
					connectivity.ConnectivityPolicyName = w.(string)
				}

			}
		}

	}

	if v, ok := d.GetOk("per_session"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		perSession := &ves_io_schema_ztna.PerSessionPolicyType{}
		updateSpec.PerSession = perSession
		for _, set := range sl {
			if set != nil {
				perSessionMapStrToI := set.(map[string]interface{})

				if v, ok := perSessionMapStrToI["external_server"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					externalServer := make(map[string]*ves_io_schema_ztna.ExternalServers)
					perSession.ExternalServer = externalServer
					for _, set := range sl {
						if set != nil {
							externalServerMapStrToI := set.(map[string]interface{})
							key, ok := externalServerMapStrToI["name"]
							if ok && !isIntfNil(key) {
								externalServer[key.(string)] = &ves_io_schema_ztna.ExternalServers{}
								val, _ := externalServerMapStrToI["value"]

								externalServerVals := val.([]interface{})
								for _, intVal := range externalServerVals {
									if intVal != nil {

										externalServerStaticMap := intVal.(map[string]interface{})

										if w, ok := externalServerStaticMap["admin_password"]; ok && !isIntfNil(w) {
											externalServer[key.(string)].AdminPassword = w.(*ves_io_schema.SecretType)
										}

										if w, ok := externalServerStaticMap["admin_username"]; ok && !isIntfNil(w) {
											externalServer[key.(string)].AdminUsername = w.(string)
										}

										if w, ok := externalServerStaticMap["domain"]; ok && !isIntfNil(w) {
											externalServer[key.(string)].Domain = w.(string)
										}

										if w, ok := externalServerStaticMap["server_type"]; ok && !isIntfNil(w) {
											externalServer[key.(string)].ServerType =  w.(ves_io_schema_ztna.ServerType)
										}

										// break after one loop
										break
									}
								}
							}
						}
					}

				}

				if v, ok := perSessionMapStrToI["lease_pool_member"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					leasePoolMember := make(map[string]*ves_io_schema_ztna.LeasePoolMember)
					perSession.LeasePoolMember = leasePoolMember
					for _, set := range sl {
						if set != nil {
							leasePoolMemberMapStrToI := set.(map[string]interface{})
							key, ok := leasePoolMemberMapStrToI["name"]
							if ok && !isIntfNil(key) {
								leasePoolMember[key.(string)] = &ves_io_schema_ztna.LeasePoolMember{}
								val, _ := leasePoolMemberMapStrToI["value"]

								leasePoolMemberVals := val.([]interface{})
								for _, intVal := range leasePoolMemberVals {
									if intVal != nil {

										leasePoolMemberStaticMap := intVal.(map[string]interface{})

										if w, ok := leasePoolMemberStaticMap["end_address"]; ok && !isIntfNil(w) {
											leasePoolMember[key.(string)].EndAddress = w.(*ves_io_schema.IpAddressType)
										}

										if w, ok := leasePoolMemberStaticMap["start_address"]; ok && !isIntfNil(w) {
											leasePoolMember[key.(string)].StartAddress = w.(*ves_io_schema.IpAddressType)
										}

										// break after one loop
										break
									}
								}
							}
						}
					}

				}

				if w, ok := perSessionMapStrToI["per_session_policy_name"]; ok && !isIntfNil(w) {
					perSession.PerSessionPolicyName = w.(string)
				}

				if v, ok := perSessionMapStrToI["resources"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					resources := make(map[string]*ves_io_schema_ztna.Resource)
					perSession.Resources = resources
					for _, set := range sl {
						if set != nil {
							resourcesMapStrToI := set.(map[string]interface{})
							key, ok := resourcesMapStrToI["name"]
							if ok && !isIntfNil(key) {
								resources[key.(string)] = &ves_io_schema_ztna.Resource{}
								val, _ := resourcesMapStrToI["value"]

								resourcesVals := val.([]interface{})
								for _, intVal := range resourcesVals {
									if intVal != nil {

										resourcesStaticMap := intVal.(map[string]interface{})

										resourceTypeTypeFound := false

										if v, ok := resourcesStaticMap["acl"]; ok && !isIntfNil(v) && !resourceTypeTypeFound {

											resourceTypeTypeFound = true
											resourceTypeInt := &ves_io_schema_ztna.Resource_Acl{}
											resourceTypeInt.Acl = &ves_io_schema_ztna.AclResourceEntry{}
											resources[key.(string)].ResourceType = resourceTypeInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["entries"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														entries := make([]*ves_io_schema_ztna.Entry, len(sl))
														resourceTypeInt.Acl.Entries = entries
														for i, set := range sl {
															if set != nil {
																entries[i] = &ves_io_schema_ztna.Entry{}
																entriesMapStrToI := set.(map[string]interface{})

																if v, ok := entriesMapStrToI["action"]; ok && !isIntfNil(v) {

																	entries[i].Action = ves_io_schema_ztna.Action(ves_io_schema_ztna.Action_value[v.(string)])

																}

																if w, ok := entriesMapStrToI["destination_end_port"]; ok && !isIntfNil(w) {
																	entries[i].DestinationEndPort = uint32(w.(int))
																}

																if v, ok := entriesMapStrToI["destination_ip"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	destinationIp := &ves_io_schema.IpAddressType{}
																	entries[i].DestinationIp = destinationIp
																	for _, set := range sl {
																		if set != nil {
																			destinationIpMapStrToI := set.(map[string]interface{})

																			verTypeFound := false

																			if v, ok := destinationIpMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv4{}
																				verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
																				destinationIp.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv4.Addr = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := destinationIpMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv6{}
																				verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
																				destinationIp.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv6.Addr = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if w, ok := entriesMapStrToI["destination_start_port"]; ok && !isIntfNil(w) {
																	entries[i].DestinationStartPort = uint32(w.(int))
																}

															}
														}

													}

												}
											}

										}

										if v, ok := resourcesStaticMap["connectivity"]; ok && !isIntfNil(v) && !resourceTypeTypeFound {

											resourceTypeTypeFound = true

											if v.(bool) {
												resourceTypeInt := &ves_io_schema_ztna.Resource_Connectivity{}
												resourceTypeInt.Connectivity = &ves_io_schema.Empty{}
												resources[key.(string)].ResourceType = resourceTypeInt
											}

										}

										if v, ok := resourcesStaticMap["web"]; ok && !isIntfNil(v) && !resourceTypeTypeFound {

											resourceTypeTypeFound = true

											if v.(bool) {
												resourceTypeInt := &ves_io_schema_ztna.Resource_Web{}
												resourceTypeInt.Web = &ves_io_schema.Empty{}
												resources[key.(string)].ResourceType = resourceTypeInt
											}

										}

										// break after one loop
										break
									}
								}
							}
						}
					}

				}

				if v, ok := perSessionMapStrToI["sequence_action"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					sequenceAction := &ves_io_schema_ztna.SequenceAction{}
					perSession.SequenceAction = sequenceAction
					for _, set := range sl {
						if set != nil {
							sequenceActionMapStrToI := set.(map[string]interface{})

							if w, ok := sequenceActionMapStrToI["connectivity_access_policy_name"]; ok && !isIntfNil(w) {
								sequenceAction.ConnectivityAccessPolicyName = w.(string)
							}

							if v, ok := sequenceActionMapStrToI["next_action"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								nextAction := &ves_io_schema_ztna.ActionType{}
								sequenceAction.NextAction = nextAction
								for _, set := range sl {
									if set != nil {
										nextActionMapStrToI := set.(map[string]interface{})

										itemTypeTypeFound := false

										if v, ok := nextActionMapStrToI["active_directory_auth"]; ok && !isIntfNil(v) && !itemTypeTypeFound {

											itemTypeTypeFound = true
											itemTypeInt := &ves_io_schema_ztna.ActionType_ActiveDirectoryAuth{}
											itemTypeInt.ActiveDirectoryAuth = &ves_io_schema_ztna.ActiveDirectoryAuth{}
											nextAction.ItemType = itemTypeInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["active_directory_query"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														activeDirectoryQuery := make([]*ves_io_schema_ztna.ActiveDirectoryQuery, len(sl))
														itemTypeInt.ActiveDirectoryAuth.ActiveDirectoryQuery = activeDirectoryQuery
														for i, set := range sl {
															if set != nil {
																activeDirectoryQuery[i] = &ves_io_schema_ztna.ActiveDirectoryQuery{}
																activeDirectoryQueryMapStrToI := set.(map[string]interface{})

																if w, ok := activeDirectoryQueryMapStrToI["deny_name"]; ok && !isIntfNil(w) {
																	activeDirectoryQuery[i].DenyName = w.(string)
																}

																if w, ok := activeDirectoryQueryMapStrToI["filter"]; ok && !isIntfNil(w) {
																	activeDirectoryQuery[i].Filter = w.(string)
																}

																if v, ok := activeDirectoryQueryMapStrToI["resource_assign"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	resourceAssign := &ves_io_schema_ztna.ResourceAssign{}
																	activeDirectoryQuery[i].ResourceAssign = resourceAssign
																	for _, set := range sl {
																		if set != nil {
																			resourceAssignMapStrToI := set.(map[string]interface{})

																			if v, ok := resourceAssignMapStrToI["allow"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				allow := make([]*ves_io_schema_ztna.AllowResourceAssign, len(sl))
																				resourceAssign.Allow = allow
																				for i, set := range sl {
																					if set != nil {
																						allow[i] = &ves_io_schema_ztna.AllowResourceAssign{}
																						allowMapStrToI := set.(map[string]interface{})

																						if w, ok := allowMapStrToI["allow_name"]; ok && !isIntfNil(w) {
																							allow[i].AllowName = w.(string)
																						}

																						if w, ok := allowMapStrToI["deny_name"]; ok && !isIntfNil(w) {
																							allow[i].DenyName = w.(string)
																						}

																						if v, ok := allowMapStrToI["rules_resource_assign"]; ok && !isIntfNil(v) {

																							sl := v.([]interface{})
																							rulesResourceAssign := make([]*ves_io_schema_ztna.Rules, len(sl))
																							allow[i].RulesResourceAssign = rulesResourceAssign
																							for i, set := range sl {
																								if set != nil {
																									rulesResourceAssign[i] = &ves_io_schema_ztna.Rules{}
																									rulesResourceAssignMapStrToI := set.(map[string]interface{})

																									if w, ok := rulesResourceAssignMapStrToI["acls"]; ok && !isIntfNil(w) {
																										ls := make([]string, len(w.([]interface{})))
																										for i, v := range w.([]interface{}) {
																											if v == nil {
																												return fmt.Errorf("please provide valid non-empty string value of field acls")
																											}
																											if str, ok := v.(string); ok {
																												ls[i] = str
																											}
																										}
																										rulesResourceAssign[i].Acls = ls
																									}

																									if w, ok := rulesResourceAssignMapStrToI["network_access_rule"]; ok && !isIntfNil(w) {
																										ls := make([]string, len(w.([]interface{})))
																										for i, v := range w.([]interface{}) {
																											if v == nil {
																												return fmt.Errorf("please provide valid non-empty string value of field network_access_rule")
																											}
																											if str, ok := v.(string); ok {
																												ls[i] = str
																											}
																										}
																										rulesResourceAssign[i].NetworkAccessRule = ls
																									}

																									if w, ok := rulesResourceAssignMapStrToI["web_top_name"]; ok && !isIntfNil(w) {
																										rulesResourceAssign[i].WebTopName = w.(string)
																									}

																								}
																							}

																						}

																						if w, ok := allowMapStrToI["server"]; ok && !isIntfNil(w) {
																							allow[i].Server = w.(string)
																						}

																					}
																				}

																			}

																		}
																	}

																}

																if w, ok := activeDirectoryQueryMapStrToI["server"]; ok && !isIntfNil(w) {
																	activeDirectoryQuery[i].Server = w.(string)
																}

															}
														}

													}

													if v, ok := cs["deny_name"]; ok && !isIntfNil(v) {

														itemTypeInt.ActiveDirectoryAuth.DenyName = v.(string)

													}

													if v, ok := cs["expression"]; ok && !isIntfNil(v) {

														itemTypeInt.ActiveDirectoryAuth.Expression = v.(string)

													}

													if v, ok := cs["server"]; ok && !isIntfNil(v) {

														itemTypeInt.ActiveDirectoryAuth.Server = v.(string)

													}

												}
											}

										}

										if v, ok := nextActionMapStrToI["active_directory_query"]; ok && !isIntfNil(v) && !itemTypeTypeFound {

											itemTypeTypeFound = true
											itemTypeInt := &ves_io_schema_ztna.ActionType_ActiveDirectoryQuery{}
											itemTypeInt.ActiveDirectoryQuery = &ves_io_schema_ztna.ActiveDirectoryQuery{}
											nextAction.ItemType = itemTypeInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["deny_name"]; ok && !isIntfNil(v) {

														itemTypeInt.ActiveDirectoryQuery.DenyName = v.(string)

													}

													if v, ok := cs["filter"]; ok && !isIntfNil(v) {

														itemTypeInt.ActiveDirectoryQuery.Filter = v.(string)

													}

													if v, ok := cs["resource_assign"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														resourceAssign := &ves_io_schema_ztna.ResourceAssign{}
														itemTypeInt.ActiveDirectoryQuery.ResourceAssign = resourceAssign
														for _, set := range sl {
															if set != nil {
																resourceAssignMapStrToI := set.(map[string]interface{})

																if v, ok := resourceAssignMapStrToI["allow"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	allow := make([]*ves_io_schema_ztna.AllowResourceAssign, len(sl))
																	resourceAssign.Allow = allow
																	for i, set := range sl {
																		if set != nil {
																			allow[i] = &ves_io_schema_ztna.AllowResourceAssign{}
																			allowMapStrToI := set.(map[string]interface{})

																			if w, ok := allowMapStrToI["allow_name"]; ok && !isIntfNil(w) {
																				allow[i].AllowName = w.(string)
																			}

																			if w, ok := allowMapStrToI["deny_name"]; ok && !isIntfNil(w) {
																				allow[i].DenyName = w.(string)
																			}

																			if v, ok := allowMapStrToI["rules_resource_assign"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				rulesResourceAssign := make([]*ves_io_schema_ztna.Rules, len(sl))
																				allow[i].RulesResourceAssign = rulesResourceAssign
																				for i, set := range sl {
																					if set != nil {
																						rulesResourceAssign[i] = &ves_io_schema_ztna.Rules{}
																						rulesResourceAssignMapStrToI := set.(map[string]interface{})

																						if w, ok := rulesResourceAssignMapStrToI["acls"]; ok && !isIntfNil(w) {
																							ls := make([]string, len(w.([]interface{})))
																							for i, v := range w.([]interface{}) {
																								if v == nil {
																									return fmt.Errorf("please provide valid non-empty string value of field acls")
																								}
																								if str, ok := v.(string); ok {
																									ls[i] = str
																								}
																							}
																							rulesResourceAssign[i].Acls = ls
																						}

																						if w, ok := rulesResourceAssignMapStrToI["network_access_rule"]; ok && !isIntfNil(w) {
																							ls := make([]string, len(w.([]interface{})))
																							for i, v := range w.([]interface{}) {
																								if v == nil {
																									return fmt.Errorf("please provide valid non-empty string value of field network_access_rule")
																								}
																								if str, ok := v.(string); ok {
																									ls[i] = str
																								}
																							}
																							rulesResourceAssign[i].NetworkAccessRule = ls
																						}

																						if w, ok := rulesResourceAssignMapStrToI["web_top_name"]; ok && !isIntfNil(w) {
																							rulesResourceAssign[i].WebTopName = w.(string)
																						}

																					}
																				}

																			}

																			if w, ok := allowMapStrToI["server"]; ok && !isIntfNil(w) {
																				allow[i].Server = w.(string)
																			}

																		}
																	}

																}

															}
														}

													}

													if v, ok := cs["server"]; ok && !isIntfNil(v) {

														itemTypeInt.ActiveDirectoryQuery.Server = v.(string)

													}

												}
											}

										}

										if v, ok := nextActionMapStrToI["log_on"]; ok && !isIntfNil(v) && !itemTypeTypeFound {

											itemTypeTypeFound = true
											itemTypeInt := &ves_io_schema_ztna.ActionType_LogOn{}
											itemTypeInt.LogOn = &ves_io_schema_ztna.LogonItemType{}
											nextAction.ItemType = itemTypeInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["active_directory_auth"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														activeDirectoryAuth := make([]*ves_io_schema_ztna.ActiveDirectoryAuth, len(sl))
														itemTypeInt.LogOn.ActiveDirectoryAuth = activeDirectoryAuth
														for i, set := range sl {
															if set != nil {
																activeDirectoryAuth[i] = &ves_io_schema_ztna.ActiveDirectoryAuth{}
																activeDirectoryAuthMapStrToI := set.(map[string]interface{})

																if v, ok := activeDirectoryAuthMapStrToI["active_directory_query"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	activeDirectoryQuery := make([]*ves_io_schema_ztna.ActiveDirectoryQuery, len(sl))
																	activeDirectoryAuth[i].ActiveDirectoryQuery = activeDirectoryQuery
																	for i, set := range sl {
																		if set != nil {
																			activeDirectoryQuery[i] = &ves_io_schema_ztna.ActiveDirectoryQuery{}
																			activeDirectoryQueryMapStrToI := set.(map[string]interface{})

																			if w, ok := activeDirectoryQueryMapStrToI["deny_name"]; ok && !isIntfNil(w) {
																				activeDirectoryQuery[i].DenyName = w.(string)
																			}

																			if w, ok := activeDirectoryQueryMapStrToI["filter"]; ok && !isIntfNil(w) {
																				activeDirectoryQuery[i].Filter = w.(string)
																			}

																			if v, ok := activeDirectoryQueryMapStrToI["resource_assign"]; ok && !isIntfNil(v) {

																				sl := v.([]interface{})
																				resourceAssign := &ves_io_schema_ztna.ResourceAssign{}
																				activeDirectoryQuery[i].ResourceAssign = resourceAssign
																				for _, set := range sl {
																					if set != nil {
																						resourceAssignMapStrToI := set.(map[string]interface{})

																						if v, ok := resourceAssignMapStrToI["allow"]; ok && !isIntfNil(v) {

																							sl := v.([]interface{})
																							allow := make([]*ves_io_schema_ztna.AllowResourceAssign, len(sl))
																							resourceAssign.Allow = allow
																							for i, set := range sl {
																								if set != nil {
																									allow[i] = &ves_io_schema_ztna.AllowResourceAssign{}
																									allowMapStrToI := set.(map[string]interface{})

																									if w, ok := allowMapStrToI["allow_name"]; ok && !isIntfNil(w) {
																										allow[i].AllowName = w.(string)
																									}

																									if w, ok := allowMapStrToI["deny_name"]; ok && !isIntfNil(w) {
																										allow[i].DenyName = w.(string)
																									}

																									if v, ok := allowMapStrToI["rules_resource_assign"]; ok && !isIntfNil(v) {

																										sl := v.([]interface{})
																										rulesResourceAssign := make([]*ves_io_schema_ztna.Rules, len(sl))
																										allow[i].RulesResourceAssign = rulesResourceAssign
																										for i, set := range sl {
																											if set != nil {
																												rulesResourceAssign[i] = &ves_io_schema_ztna.Rules{}
																												rulesResourceAssignMapStrToI := set.(map[string]interface{})

																												if w, ok := rulesResourceAssignMapStrToI["acls"]; ok && !isIntfNil(w) {
																													ls := make([]string, len(w.([]interface{})))
																													for i, v := range w.([]interface{}) {
																														if v == nil {
																															return fmt.Errorf("please provide valid non-empty string value of field acls")
																														}
																														if str, ok := v.(string); ok {
																															ls[i] = str
																														}
																													}
																													rulesResourceAssign[i].Acls = ls
																												}

																												if w, ok := rulesResourceAssignMapStrToI["network_access_rule"]; ok && !isIntfNil(w) {
																													ls := make([]string, len(w.([]interface{})))
																													for i, v := range w.([]interface{}) {
																														if v == nil {
																															return fmt.Errorf("please provide valid non-empty string value of field network_access_rule")
																														}
																														if str, ok := v.(string); ok {
																															ls[i] = str
																														}
																													}
																													rulesResourceAssign[i].NetworkAccessRule = ls
																												}

																												if w, ok := rulesResourceAssignMapStrToI["web_top_name"]; ok && !isIntfNil(w) {
																													rulesResourceAssign[i].WebTopName = w.(string)
																												}

																											}
																										}

																									}

																									if w, ok := allowMapStrToI["server"]; ok && !isIntfNil(w) {
																										allow[i].Server = w.(string)
																									}

																								}
																							}

																						}

																					}
																				}

																			}

																			if w, ok := activeDirectoryQueryMapStrToI["server"]; ok && !isIntfNil(w) {
																				activeDirectoryQuery[i].Server = w.(string)
																			}

																		}
																	}

																}

																if w, ok := activeDirectoryAuthMapStrToI["deny_name"]; ok && !isIntfNil(w) {
																	activeDirectoryAuth[i].DenyName = w.(string)
																}

																if w, ok := activeDirectoryAuthMapStrToI["expression"]; ok && !isIntfNil(w) {
																	activeDirectoryAuth[i].Expression = w.(string)
																}

																if w, ok := activeDirectoryAuthMapStrToI["server"]; ok && !isIntfNil(w) {
																	activeDirectoryAuth[i].Server = w.(string)
																}

															}
														}

													}

													if v, ok := cs["customization"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														customization := make([]*ves_io_schema_ztna.Custmization, len(sl))
														itemTypeInt.LogOn.Customization = customization
														for i, set := range sl {
															if set != nil {
																customization[i] = &ves_io_schema_ztna.Custmization{}
																customizationMapStrToI := set.(map[string]interface{})

																if v, ok := customizationMapStrToI["password"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	password := &ves_io_schema.SecretType{}
																	customization[i].Password = password
																	for _, set := range sl {
																		if set != nil {
																			passwordMapStrToI := set.(map[string]interface{})

																			secretInfoOneofTypeFound := false

																			if v, ok := passwordMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																				secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																				password.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																						}

																						if v, ok := cs["location"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																						}

																						if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := passwordMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																				secretInfoOneofTypeFound = true
																				secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																				secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																				password.SecretInfoOneof = secretInfoOneofInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																						}

																						if v, ok := cs["url"]; ok && !isIntfNil(v) {

																							secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if w, ok := customizationMapStrToI["user_name"]; ok && !isIntfNil(w) {
																	customization[i].UserName = w.(string)
																}

															}
														}

													}

												}
											}

										}

										if v, ok := nextActionMapStrToI["resource_assign"]; ok && !isIntfNil(v) && !itemTypeTypeFound {

											itemTypeTypeFound = true
											itemTypeInt := &ves_io_schema_ztna.ActionType_ResourceAssign{}
											itemTypeInt.ResourceAssign = &ves_io_schema_ztna.ResourceAssign{}
											nextAction.ItemType = itemTypeInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["allow"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														allow := make([]*ves_io_schema_ztna.AllowResourceAssign, len(sl))
														itemTypeInt.ResourceAssign.Allow = allow
														for i, set := range sl {
															if set != nil {
																allow[i] = &ves_io_schema_ztna.AllowResourceAssign{}
																allowMapStrToI := set.(map[string]interface{})

																if w, ok := allowMapStrToI["allow_name"]; ok && !isIntfNil(w) {
																	allow[i].AllowName = w.(string)
																}

																if w, ok := allowMapStrToI["deny_name"]; ok && !isIntfNil(w) {
																	allow[i].DenyName = w.(string)
																}

																if v, ok := allowMapStrToI["rules_resource_assign"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	rulesResourceAssign := make([]*ves_io_schema_ztna.Rules, len(sl))
																	allow[i].RulesResourceAssign = rulesResourceAssign
																	for i, set := range sl {
																		if set != nil {
																			rulesResourceAssign[i] = &ves_io_schema_ztna.Rules{}
																			rulesResourceAssignMapStrToI := set.(map[string]interface{})

																			if w, ok := rulesResourceAssignMapStrToI["acls"]; ok && !isIntfNil(w) {
																				ls := make([]string, len(w.([]interface{})))
																				for i, v := range w.([]interface{}) {
																					if v == nil {
																						return fmt.Errorf("please provide valid non-empty string value of field acls")
																					}
																					if str, ok := v.(string); ok {
																						ls[i] = str
																					}
																				}
																				rulesResourceAssign[i].Acls = ls
																			}

																			if w, ok := rulesResourceAssignMapStrToI["network_access_rule"]; ok && !isIntfNil(w) {
																				ls := make([]string, len(w.([]interface{})))
																				for i, v := range w.([]interface{}) {
																					if v == nil {
																						return fmt.Errorf("please provide valid non-empty string value of field network_access_rule")
																					}
																					if str, ok := v.(string); ok {
																						ls[i] = str
																					}
																				}
																				rulesResourceAssign[i].NetworkAccessRule = ls
																			}

																			if w, ok := rulesResourceAssignMapStrToI["web_top_name"]; ok && !isIntfNil(w) {
																				rulesResourceAssign[i].WebTopName = w.(string)
																			}

																		}
																	}

																}

																if w, ok := allowMapStrToI["server"]; ok && !isIntfNil(w) {
																	allow[i].Server = w.(string)
																}

															}
														}

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

			}
		}

	}

	log.Printf("[DEBUG] Updating Volterra Ztna obj with struct: %+v", updateReq)

	err := client.ReplaceObject(context.Background(), ves_io_schema_ztna.ObjectType, updateReq)
	if err != nil {
		return fmt.Errorf("error updating Ztna: %s", err)
	}

	return resourceVolterraZtnaRead(d, meta)
}

func resourceVolterraZtnaDelete(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	_, err := client.GetObject(context.Background(), ves_io_schema_ztna.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] Ztna %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra Ztna before deleting %q: %s", d.Id(), err)
	}

	log.Printf("[DEBUG] Deleting Volterra Ztna obj with name %+v in namespace %+v", name, namespace)
	opts := []vesapi.CallOpt{
		vesapi.WithFailIfReferred(),
	}
	return client.DeleteObject(context.Background(), ves_io_schema_ztna.ObjectType, namespace, name, opts...)
}
