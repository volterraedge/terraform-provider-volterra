//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-tf-provider. DO NOT EDIT.
//

package volterra

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"gopkg.volterra.us/stdlib/client/vesapi"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_policy "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/policy"
	ves_io_schema_route "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/route"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
)

// resourceVolterraRoute is implementation of Volterra's Route resources
func resourceVolterraRoute() *schema.Resource {
	return &schema.Resource{
		Create: resourceVolterraRouteCreate,
		Read:   resourceVolterraRouteRead,
		Update: resourceVolterraRouteUpdate,
		Delete: resourceVolterraRouteDelete,

		Schema: map[string]*schema.Schema{

			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"description": {
				Type:     schema.TypeString,
				Optional: true,
			},

			"disable": {
				Type:     schema.TypeBool,
				Optional: true,
			},

			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"namespace": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"routes": {

				Type:     schema.TypeList,
				Required: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"bot_defense_javascript_injection": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"javascript_location": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"javascript_tags": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"javascript_url": {
													Type:     schema.TypeString,
													Required: true,
												},

												"tag_attributes": {

													Type:     schema.TypeList,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"javascript_tag": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"tag_value": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"inherited_bot_defense_javascript_injection": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"bot_defense_javascript_injection_inline_mode": {

							Type:       schema.TypeList,
							MaxItems:   1,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"element_selector": {
										Type:       schema.TypeString,
										Required:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"insert_content": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"position": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
								},
							},
						},

						"disable_custom_script": {
							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"disable_location_add": {
							Type:     schema.TypeBool,
							Optional: true,
						},

						"match": {

							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"headers": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"invert_match": {
													Type:     schema.TypeBool,
													Optional: true,
												},

												"name": {
													Type:     schema.TypeString,
													Required: true,
												},

												"exact": {

													Type:     schema.TypeString,
													Optional: true,
												},

												"presence": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"regex": {

													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},

									"http_method": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"incoming_port": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"no_port_match": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"port": {

													Type:     schema.TypeInt,
													Optional: true,
												},

												"port_ranges": {

													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},

									"path": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"path": {

													Type:     schema.TypeString,
													Optional: true,
												},

												"prefix": {

													Type:     schema.TypeString,
													Optional: true,
												},

												"regex": {

													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},

									"query_params": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"key": {
													Type:     schema.TypeString,
													Required: true,
												},

												"exact": {

													Type:     schema.TypeString,
													Optional: true,
												},

												"regex": {

													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"request_cookies_to_add": {

							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Required: true,
									},

									"overwrite": {
										Type:     schema.TypeBool,
										Optional: true,
									},

									"secret_value": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"blindfold_secret_info_internal": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"decryption_provider": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"location": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"store_provider": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},

												"secret_encoding_type": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"blindfold_secret_info": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"decryption_provider": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"location": {
																Type:     schema.TypeString,
																Required: true,
															},

															"store_provider": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"clear_secret_info": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"provider": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"url": {
																Type:     schema.TypeString,
																Required: true,
															},
														},
													},
												},

												"vault_secret_info": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"key": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"location": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"provider": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"secret_encoding": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"version": {
																Type:       schema.TypeInt,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},

												"wingman_secret_info": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"name": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},
											},
										},
									},

									"value": {

										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"request_cookies_to_remove": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},

						"request_headers_to_add": {

							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"append": {
										Type:     schema.TypeBool,
										Optional: true,
									},

									"name": {
										Type:     schema.TypeString,
										Required: true,
									},

									"secret_value": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"blindfold_secret_info_internal": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"decryption_provider": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"location": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"store_provider": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},

												"secret_encoding_type": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"blindfold_secret_info": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"decryption_provider": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"location": {
																Type:     schema.TypeString,
																Required: true,
															},

															"store_provider": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"clear_secret_info": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"provider": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"url": {
																Type:     schema.TypeString,
																Required: true,
															},
														},
													},
												},

												"vault_secret_info": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"key": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"location": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"provider": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"secret_encoding": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"version": {
																Type:       schema.TypeInt,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},

												"wingman_secret_info": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"name": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},
											},
										},
									},

									"value": {

										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"request_headers_to_remove": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},

						"response_cookies_to_add": {

							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"add_domain": {

										Type:     schema.TypeString,
										Optional: true,
									},

									"ignore_domain": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"add_expiry": {

										Type:     schema.TypeString,
										Optional: true,
									},

									"ignore_expiry": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"add_httponly": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"ignore_httponly": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"ignore_max_age": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"max_age_value": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"name": {
										Type:     schema.TypeString,
										Required: true,
									},

									"overwrite": {
										Type:     schema.TypeBool,
										Optional: true,
									},

									"add_partitioned": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"ignore_partitioned": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"add_path": {

										Type:     schema.TypeString,
										Optional: true,
									},

									"ignore_path": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"ignore_samesite": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"samesite_lax": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"samesite_none": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"samesite_strict": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"add_secure": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"ignore_secure": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"ignore_value": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"secret_value": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"blindfold_secret_info_internal": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"decryption_provider": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"location": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"store_provider": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},

												"secret_encoding_type": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"blindfold_secret_info": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"decryption_provider": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"location": {
																Type:     schema.TypeString,
																Required: true,
															},

															"store_provider": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"clear_secret_info": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"provider": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"url": {
																Type:     schema.TypeString,
																Required: true,
															},
														},
													},
												},

												"vault_secret_info": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"key": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"location": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"provider": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"secret_encoding": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"version": {
																Type:       schema.TypeInt,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},

												"wingman_secret_info": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"name": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},
											},
										},
									},

									"value": {

										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"response_cookies_to_remove": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},

						"response_headers_to_add": {

							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"append": {
										Type:     schema.TypeBool,
										Optional: true,
									},

									"name": {
										Type:     schema.TypeString,
										Required: true,
									},

									"secret_value": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"blindfold_secret_info_internal": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"decryption_provider": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"location": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"store_provider": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},

												"secret_encoding_type": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"blindfold_secret_info": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"decryption_provider": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"location": {
																Type:     schema.TypeString,
																Required: true,
															},

															"store_provider": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"clear_secret_info": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"provider": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"url": {
																Type:     schema.TypeString,
																Required: true,
															},
														},
													},
												},

												"vault_secret_info": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"key": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"location": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"provider": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"secret_encoding": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"version": {
																Type:       schema.TypeInt,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},

												"wingman_secret_info": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"name": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},
											},
										},
									},

									"value": {

										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"response_headers_to_remove": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},

						"route_destination": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"buffer_policy": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"disabled": {
													Type:     schema.TypeBool,
													Optional: true,
												},

												"max_request_bytes": {
													Type:     schema.TypeInt,
													Optional: true,
												},

												"max_request_time": {
													Type:       schema.TypeInt,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},

									"do_not_retract_cluster": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"retract_cluster": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"cors_policy": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"allow_credentials": {
													Type:     schema.TypeBool,
													Optional: true,
												},

												"allow_headers": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"allow_methods": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"allow_origin": {

													Type: schema.TypeList,

													Optional: true,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},

												"allow_origin_regex": {

													Type: schema.TypeList,

													Optional: true,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},

												"disabled": {
													Type:     schema.TypeBool,
													Optional: true,
												},

												"expose_headers": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"max_age": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"maximum_age": {
													Type:     schema.TypeInt,
													Optional: true,
												},
											},
										},
									},

									"csrf_policy": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"all_load_balancer_domains": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"custom_domain_list": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"domains": {

																Type: schema.TypeList,

																Required: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
														},
													},
												},

												"disabled": {

													Type:     schema.TypeBool,
													Optional: true,
												},
											},
										},
									},

									"destinations": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"cluster": {

													Type:     schema.TypeList,
													Required: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"kind": {
																Type:     schema.TypeString,
																Computed: true,
															},

															"name": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"namespace": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"tenant": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"endpoint_subsets": {
													Type:     schema.TypeMap,
													Optional: true,
												},

												"priority": {
													Type:     schema.TypeInt,
													Optional: true,
												},

												"weight": {
													Type:     schema.TypeInt,
													Optional: true,
												},
											},
										},
									},

									"endpoint_subsets": {
										Type:     schema.TypeMap,
										Optional: true,
									},

									"hash_policy": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"cookie": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"add_httponly": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"ignore_httponly": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"name": {
																Type:     schema.TypeString,
																Required: true,
															},

															"path": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"ignore_samesite": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"samesite_lax": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"samesite_none": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"samesite_strict": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"add_secure": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"ignore_secure": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"ttl": {
																Type:     schema.TypeInt,
																Optional: true,
															},
														},
													},
												},

												"header_name": {

													Type:     schema.TypeString,
													Optional: true,
												},

												"source_ip": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"terminal": {
													Type:     schema.TypeBool,
													Optional: true,
												},
											},
										},
									},

									"auto_host_rewrite": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"host_rewrite": {

										Type:     schema.TypeString,
										Optional: true,
									},

									"mirror_policy": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"cluster": {

													Type:     schema.TypeList,
													Required: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"kind": {
																Type:     schema.TypeString,
																Computed: true,
															},

															"name": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"namespace": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"tenant": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"percent": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"denominator": {
																Type:     schema.TypeString,
																Required: true,
															},

															"numerator": {
																Type:     schema.TypeInt,
																Required: true,
															},
														},
													},
												},
											},
										},
									},

									"priority": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"query_params": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"remove_all_params": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"replace_params": {

													Type:     schema.TypeString,
													Optional: true,
												},

												"retain_all_params": {

													Type:     schema.TypeBool,
													Optional: true,
												},
											},
										},
									},

									"retry_policy": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"back_off": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"base_interval": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"max_interval": {
																Type:     schema.TypeInt,
																Optional: true,
															},
														},
													},
												},

												"num_retries": {
													Type:     schema.TypeInt,
													Optional: true,
												},

												"per_try_timeout": {
													Type:     schema.TypeInt,
													Optional: true,
												},

												"retriable_status_codes": {

													Type: schema.TypeList,

													Optional: true,
													Elem: &schema.Schema{
														Type: schema.TypeInt,
													},
												},

												"retry_condition": {

													Type: schema.TypeList,

													Required: true,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},

												"retry_on": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},

									"prefix_rewrite": {

										Type:     schema.TypeString,
										Optional: true,
									},

									"regex_rewrite": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"pattern": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"substitution": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},

									"spdy_config": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"use_spdy": {
													Type:     schema.TypeBool,
													Optional: true,
												},
											},
										},
									},

									"timeout": {
										Type:     schema.TypeInt,
										Optional: true,
									},

									"web_socket_config": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"use_websocket": {
													Type:     schema.TypeBool,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"route_direct_response": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"response_body": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"response_body_encoded": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"response_code": {
										Type:     schema.TypeInt,
										Optional: true,
									},
								},
							},
						},

						"route_redirect": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"host_redirect": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"port_redirect": {
										Type:       schema.TypeInt,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"proto_redirect": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"all_params": {

										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"remove_all_params": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"replace_params": {

										Type:     schema.TypeString,
										Optional: true,
									},

									"retain_all_params": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"strip_query_params": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"query_params": {

													Type: schema.TypeList,

													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
											},
										},
									},

									"path_redirect": {

										Type:     schema.TypeString,
										Optional: true,
									},

									"prefix_rewrite": {

										Type:     schema.TypeString,
										Optional: true,
									},

									"response_code": {
										Type:     schema.TypeInt,
										Optional: true,
									},
								},
							},
						},

						"service_policy": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"context_extensions": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"context_extensions": {
													Type:       schema.TypeMap,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},

									"disable": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"skip_lb_override": {
							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"uuid": {
							Type:       schema.TypeString,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"inherited_waf_exclusion": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"waf_exclusion_policy": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Required: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"waf_exclusion_service_policy": {

							Type:       schema.TypeList,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"kind": {
										Type:       schema.TypeString,
										Computed:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"name": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
									"namespace": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
									"tenant": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
								},
							},
						},

						"waf_type": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"app_firewall": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"app_firewall": {

													Type:     schema.TypeList,
													Required: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"kind": {
																Type:     schema.TypeString,
																Computed: true,
															},

															"name": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"namespace": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"tenant": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},

									"disable_waf": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"inherit_waf": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

// resourceVolterraRouteCreate creates Route resource
func resourceVolterraRouteCreate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	createMeta := &ves_io_schema.ObjectCreateMetaType{}
	createSpec := &ves_io_schema_route.CreateSpecType{}
	createReq := &ves_io_schema_route.CreateRequest{
		Metadata: createMeta,
		Spec:     createSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		createMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		createMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		createMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		createMeta.Namespace =
			v.(string)
	}

	//routes
	if v, ok := d.GetOk("routes"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		routes := make([]*ves_io_schema_route.RouteType, len(sl))
		createSpec.Routes = routes
		for i, set := range sl {
			if set != nil {
				routes[i] = &ves_io_schema_route.RouteType{}
				routesMapStrToI := set.(map[string]interface{})

				botDefenseJavascriptInjectionChoiceTypeFound := false

				if v, ok := routesMapStrToI["bot_defense_javascript_injection"]; ok && !isIntfNil(v) && !botDefenseJavascriptInjectionChoiceTypeFound {

					botDefenseJavascriptInjectionChoiceTypeFound = true
					botDefenseJavascriptInjectionChoiceInt := &ves_io_schema_route.RouteType_BotDefenseJavascriptInjection{}
					botDefenseJavascriptInjectionChoiceInt.BotDefenseJavascriptInjection = &ves_io_schema_route.BotDefenseJavascriptInjectionType{}
					routes[i].BotDefenseJavascriptInjectionChoice = botDefenseJavascriptInjectionChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["javascript_location"]; ok && !isIntfNil(v) {

								botDefenseJavascriptInjectionChoiceInt.BotDefenseJavascriptInjection.JavascriptLocation = ves_io_schema_route.JavaScriptLocation(ves_io_schema_route.JavaScriptLocation_value[v.(string)])

							}

							if v, ok := cs["javascript_tags"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								javascriptTags := make([]*ves_io_schema_route.JavaScriptTag, len(sl))
								botDefenseJavascriptInjectionChoiceInt.BotDefenseJavascriptInjection.JavascriptTags = javascriptTags
								for i, set := range sl {
									if set != nil {
										javascriptTags[i] = &ves_io_schema_route.JavaScriptTag{}
										javascriptTagsMapStrToI := set.(map[string]interface{})

										if w, ok := javascriptTagsMapStrToI["javascript_url"]; ok && !isIntfNil(w) {
											javascriptTags[i].JavascriptUrl = w.(string)
										}

										if v, ok := javascriptTagsMapStrToI["tag_attributes"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											tagAttributes := make([]*ves_io_schema_route.TagAttribute, len(sl))
											javascriptTags[i].TagAttributes = tagAttributes
											for i, set := range sl {
												if set != nil {
													tagAttributes[i] = &ves_io_schema_route.TagAttribute{}
													tagAttributesMapStrToI := set.(map[string]interface{})

													if v, ok := tagAttributesMapStrToI["javascript_tag"]; ok && !isIntfNil(v) {

														tagAttributes[i].JavascriptTag = ves_io_schema_route.TagAttributeName(ves_io_schema_route.TagAttributeName_value[v.(string)])

													}

													if w, ok := tagAttributesMapStrToI["tag_value"]; ok && !isIntfNil(w) {
														tagAttributes[i].TagValue = w.(string)
													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := routesMapStrToI["inherited_bot_defense_javascript_injection"]; ok && !isIntfNil(v) && !botDefenseJavascriptInjectionChoiceTypeFound {

					botDefenseJavascriptInjectionChoiceTypeFound = true

					if v.(bool) {
						botDefenseJavascriptInjectionChoiceInt := &ves_io_schema_route.RouteType_InheritedBotDefenseJavascriptInjection{}
						botDefenseJavascriptInjectionChoiceInt.InheritedBotDefenseJavascriptInjection = &ves_io_schema.Empty{}
						routes[i].BotDefenseJavascriptInjectionChoice = botDefenseJavascriptInjectionChoiceInt
					}

				}

				if v, ok := routesMapStrToI["bot_defense_javascript_injection_inline_mode"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					botDefenseJavascriptInjectionInlineMode := &ves_io_schema_route.ContentRewriteType{}
					routes[i].BotDefenseJavascriptInjectionInlineMode = botDefenseJavascriptInjectionInlineMode
					for _, set := range sl {
						if set != nil {
							botDefenseJavascriptInjectionInlineModeMapStrToI := set.(map[string]interface{})

							if w, ok := botDefenseJavascriptInjectionInlineModeMapStrToI["element_selector"]; ok && !isIntfNil(w) {
								botDefenseJavascriptInjectionInlineMode.ElementSelector = w.(string)
							}

							if w, ok := botDefenseJavascriptInjectionInlineModeMapStrToI["insert_content"]; ok && !isIntfNil(w) {
								botDefenseJavascriptInjectionInlineMode.InsertContent = w.(string)
							}

							if v, ok := botDefenseJavascriptInjectionInlineModeMapStrToI["position"]; ok && !isIntfNil(v) {

								botDefenseJavascriptInjectionInlineMode.Position = ves_io_schema_policy.HTMLPosition(ves_io_schema_policy.HTMLPosition_value[v.(string)])

							}

						}
					}

				}

				if w, ok := routesMapStrToI["disable_custom_script"]; ok && !isIntfNil(w) {
					routes[i].DisableCustomScript = w.(bool)
				}

				if w, ok := routesMapStrToI["disable_location_add"]; ok && !isIntfNil(w) {
					routes[i].DisableLocationAdd = w.(bool)
				}

				if v, ok := routesMapStrToI["match"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					match := make([]*ves_io_schema.RouteMatch, len(sl))
					routes[i].Match = match
					for i, set := range sl {
						if set != nil {
							match[i] = &ves_io_schema.RouteMatch{}
							matchMapStrToI := set.(map[string]interface{})

							if v, ok := matchMapStrToI["headers"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								headers := make([]*ves_io_schema.HeaderMatcherType, len(sl))
								match[i].Headers = headers
								for i, set := range sl {
									if set != nil {
										headers[i] = &ves_io_schema.HeaderMatcherType{}
										headersMapStrToI := set.(map[string]interface{})

										if w, ok := headersMapStrToI["invert_match"]; ok && !isIntfNil(w) {
											headers[i].InvertMatch = w.(bool)
										}

										if w, ok := headersMapStrToI["name"]; ok && !isIntfNil(w) {
											headers[i].Name = w.(string)
										}

										valueMatchTypeFound := false

										if v, ok := headersMapStrToI["exact"]; ok && !isIntfNil(v) && !valueMatchTypeFound {

											valueMatchTypeFound = true
											valueMatchInt := &ves_io_schema.HeaderMatcherType_Exact{}

											headers[i].ValueMatch = valueMatchInt

											valueMatchInt.Exact = v.(string)

										}

										if v, ok := headersMapStrToI["presence"]; ok && !isIntfNil(v) && !valueMatchTypeFound {

											valueMatchTypeFound = true
											valueMatchInt := &ves_io_schema.HeaderMatcherType_Presence{}

											headers[i].ValueMatch = valueMatchInt

											valueMatchInt.Presence = v.(bool)

										}

										if v, ok := headersMapStrToI["regex"]; ok && !isIntfNil(v) && !valueMatchTypeFound {

											valueMatchTypeFound = true
											valueMatchInt := &ves_io_schema.HeaderMatcherType_Regex{}

											headers[i].ValueMatch = valueMatchInt

											valueMatchInt.Regex = v.(string)

										}

									}
								}

							}

							if v, ok := matchMapStrToI["http_method"]; ok && !isIntfNil(v) {

								match[i].HttpMethod = ves_io_schema.HttpMethod(ves_io_schema.HttpMethod_value[v.(string)])

							}

							if v, ok := matchMapStrToI["incoming_port"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								incomingPort := &ves_io_schema.PortMatcherType{}
								match[i].IncomingPort = incomingPort
								for _, set := range sl {
									if set != nil {
										incomingPortMapStrToI := set.(map[string]interface{})

										portMatchTypeFound := false

										if v, ok := incomingPortMapStrToI["no_port_match"]; ok && !isIntfNil(v) && !portMatchTypeFound {

											portMatchTypeFound = true

											if v.(bool) {
												portMatchInt := &ves_io_schema.PortMatcherType_NoPortMatch{}
												portMatchInt.NoPortMatch = &ves_io_schema.Empty{}
												incomingPort.PortMatch = portMatchInt
											}

										}

										if v, ok := incomingPortMapStrToI["port"]; ok && !isIntfNil(v) && !portMatchTypeFound {

											portMatchTypeFound = true
											portMatchInt := &ves_io_schema.PortMatcherType_Port{}

											incomingPort.PortMatch = portMatchInt

											portMatchInt.Port = uint32(v.(int))

										}

										if v, ok := incomingPortMapStrToI["port_ranges"]; ok && !isIntfNil(v) && !portMatchTypeFound {

											portMatchTypeFound = true
											portMatchInt := &ves_io_schema.PortMatcherType_PortRanges{}

											incomingPort.PortMatch = portMatchInt

											portMatchInt.PortRanges = v.(string)

										}

									}
								}

							}

							if v, ok := matchMapStrToI["path"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								path := &ves_io_schema.PathMatcherType{}
								match[i].Path = path
								for _, set := range sl {
									if set != nil {
										pathMapStrToI := set.(map[string]interface{})

										pathMatchTypeFound := false

										if v, ok := pathMapStrToI["path"]; ok && !isIntfNil(v) && !pathMatchTypeFound {

											pathMatchTypeFound = true
											pathMatchInt := &ves_io_schema.PathMatcherType_Path{}

											path.PathMatch = pathMatchInt

											pathMatchInt.Path = v.(string)

										}

										if v, ok := pathMapStrToI["prefix"]; ok && !isIntfNil(v) && !pathMatchTypeFound {

											pathMatchTypeFound = true
											pathMatchInt := &ves_io_schema.PathMatcherType_Prefix{}

											path.PathMatch = pathMatchInt

											pathMatchInt.Prefix = v.(string)

										}

										if v, ok := pathMapStrToI["regex"]; ok && !isIntfNil(v) && !pathMatchTypeFound {

											pathMatchTypeFound = true
											pathMatchInt := &ves_io_schema.PathMatcherType_Regex{}

											path.PathMatch = pathMatchInt

											pathMatchInt.Regex = v.(string)

										}

									}
								}

							}

							if v, ok := matchMapStrToI["query_params"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								queryParams := make([]*ves_io_schema.QueryParameterMatcherType, len(sl))
								match[i].QueryParams = queryParams
								for i, set := range sl {
									if set != nil {
										queryParams[i] = &ves_io_schema.QueryParameterMatcherType{}
										queryParamsMapStrToI := set.(map[string]interface{})

										if w, ok := queryParamsMapStrToI["key"]; ok && !isIntfNil(w) {
											queryParams[i].Key = w.(string)
										}

										valueMatchTypeFound := false

										if v, ok := queryParamsMapStrToI["exact"]; ok && !isIntfNil(v) && !valueMatchTypeFound {

											valueMatchTypeFound = true
											valueMatchInt := &ves_io_schema.QueryParameterMatcherType_Exact{}

											queryParams[i].ValueMatch = valueMatchInt

											valueMatchInt.Exact = v.(string)

										}

										if v, ok := queryParamsMapStrToI["regex"]; ok && !isIntfNil(v) && !valueMatchTypeFound {

											valueMatchTypeFound = true
											valueMatchInt := &ves_io_schema.QueryParameterMatcherType_Regex{}

											queryParams[i].ValueMatch = valueMatchInt

											valueMatchInt.Regex = v.(string)

										}

									}
								}

							}

						}
					}

				}

				if v, ok := routesMapStrToI["request_cookies_to_add"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					requestCookiesToAdd := make([]*ves_io_schema.CookieValueOption, len(sl))
					routes[i].RequestCookiesToAdd = requestCookiesToAdd
					for i, set := range sl {
						if set != nil {
							requestCookiesToAdd[i] = &ves_io_schema.CookieValueOption{}
							requestCookiesToAddMapStrToI := set.(map[string]interface{})

							if w, ok := requestCookiesToAddMapStrToI["name"]; ok && !isIntfNil(w) {
								requestCookiesToAdd[i].Name = w.(string)
							}

							if w, ok := requestCookiesToAddMapStrToI["overwrite"]; ok && !isIntfNil(w) {
								requestCookiesToAdd[i].Overwrite = w.(bool)
							}

							valueChoiceTypeFound := false

							if v, ok := requestCookiesToAddMapStrToI["secret_value"]; ok && !isIntfNil(v) && !valueChoiceTypeFound {

								valueChoiceTypeFound = true
								valueChoiceInt := &ves_io_schema.CookieValueOption_SecretValue{}
								valueChoiceInt.SecretValue = &ves_io_schema.SecretType{}
								requestCookiesToAdd[i].ValueChoice = valueChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
											valueChoiceInt.SecretValue.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
											for _, set := range sl {
												if set != nil {
													blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

													if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.Location = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.StoreProvider = w.(string)
													}

												}
											}

										}

										if v, ok := cs["secret_encoding_type"]; ok && !isIntfNil(v) {

											valueChoiceInt.SecretValue.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										secretInfoOneofTypeFound := false

										if v, ok := cs["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
											secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

													}

													if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

													}

												}
											}

										}

										if v, ok := cs["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
											secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["url"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

													}

												}
											}

										}

										if v, ok := cs["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
											secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["key"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

													}

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													if v, ok := cs["version"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

													}

												}
											}

										}

										if v, ok := cs["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
											secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if v, ok := requestCookiesToAddMapStrToI["value"]; ok && !isIntfNil(v) && !valueChoiceTypeFound {

								valueChoiceTypeFound = true
								valueChoiceInt := &ves_io_schema.CookieValueOption_Value{}

								requestCookiesToAdd[i].ValueChoice = valueChoiceInt

								valueChoiceInt.Value = v.(string)

							}

						}
					}

				}

				if w, ok := routesMapStrToI["request_cookies_to_remove"]; ok && !isIntfNil(w) {
					ls := make([]string, len(w.([]interface{})))
					for i, v := range w.([]interface{}) {
						if v == nil {
							return fmt.Errorf("please provide valid non-empty string value of field request_cookies_to_remove")
						}
						if str, ok := v.(string); ok {
							ls[i] = str
						}
					}
					routes[i].RequestCookiesToRemove = ls
				}

				if v, ok := routesMapStrToI["request_headers_to_add"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					requestHeadersToAdd := make([]*ves_io_schema.HeaderManipulationOptionType, len(sl))
					routes[i].RequestHeadersToAdd = requestHeadersToAdd
					for i, set := range sl {
						if set != nil {
							requestHeadersToAdd[i] = &ves_io_schema.HeaderManipulationOptionType{}
							requestHeadersToAddMapStrToI := set.(map[string]interface{})

							if w, ok := requestHeadersToAddMapStrToI["append"]; ok && !isIntfNil(w) {
								requestHeadersToAdd[i].Append = w.(bool)
							}

							if w, ok := requestHeadersToAddMapStrToI["name"]; ok && !isIntfNil(w) {
								requestHeadersToAdd[i].Name = w.(string)
							}

							valueChoiceTypeFound := false

							if v, ok := requestHeadersToAddMapStrToI["secret_value"]; ok && !isIntfNil(v) && !valueChoiceTypeFound {

								valueChoiceTypeFound = true
								valueChoiceInt := &ves_io_schema.HeaderManipulationOptionType_SecretValue{}
								valueChoiceInt.SecretValue = &ves_io_schema.SecretType{}
								requestHeadersToAdd[i].ValueChoice = valueChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
											valueChoiceInt.SecretValue.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
											for _, set := range sl {
												if set != nil {
													blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

													if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.Location = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.StoreProvider = w.(string)
													}

												}
											}

										}

										if v, ok := cs["secret_encoding_type"]; ok && !isIntfNil(v) {

											valueChoiceInt.SecretValue.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										secretInfoOneofTypeFound := false

										if v, ok := cs["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
											secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

													}

													if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

													}

												}
											}

										}

										if v, ok := cs["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
											secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["url"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

													}

												}
											}

										}

										if v, ok := cs["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
											secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["key"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

													}

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													if v, ok := cs["version"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

													}

												}
											}

										}

										if v, ok := cs["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
											secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if v, ok := requestHeadersToAddMapStrToI["value"]; ok && !isIntfNil(v) && !valueChoiceTypeFound {

								valueChoiceTypeFound = true
								valueChoiceInt := &ves_io_schema.HeaderManipulationOptionType_Value{}

								requestHeadersToAdd[i].ValueChoice = valueChoiceInt

								valueChoiceInt.Value = v.(string)

							}

						}
					}

				}

				if w, ok := routesMapStrToI["request_headers_to_remove"]; ok && !isIntfNil(w) {
					ls := make([]string, len(w.([]interface{})))
					for i, v := range w.([]interface{}) {
						if v == nil {
							return fmt.Errorf("please provide valid non-empty string value of field request_headers_to_remove")
						}
						if str, ok := v.(string); ok {
							ls[i] = str
						}
					}
					routes[i].RequestHeadersToRemove = ls
				}

				if v, ok := routesMapStrToI["response_cookies_to_add"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					responseCookiesToAdd := make([]*ves_io_schema.SetCookieValueOption, len(sl))
					routes[i].ResponseCookiesToAdd = responseCookiesToAdd
					for i, set := range sl {
						if set != nil {
							responseCookiesToAdd[i] = &ves_io_schema.SetCookieValueOption{}
							responseCookiesToAddMapStrToI := set.(map[string]interface{})

							domainChoiceTypeFound := false

							if v, ok := responseCookiesToAddMapStrToI["add_domain"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

								domainChoiceTypeFound = true
								domainChoiceInt := &ves_io_schema.SetCookieValueOption_AddDomain{}

								responseCookiesToAdd[i].DomainChoice = domainChoiceInt

								domainChoiceInt.AddDomain = v.(string)

							}

							if v, ok := responseCookiesToAddMapStrToI["ignore_domain"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

								domainChoiceTypeFound = true

								if v.(bool) {
									domainChoiceInt := &ves_io_schema.SetCookieValueOption_IgnoreDomain{}
									domainChoiceInt.IgnoreDomain = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].DomainChoice = domainChoiceInt
								}

							}

							expiryChoiceTypeFound := false

							if v, ok := responseCookiesToAddMapStrToI["add_expiry"]; ok && !isIntfNil(v) && !expiryChoiceTypeFound {

								expiryChoiceTypeFound = true
								expiryChoiceInt := &ves_io_schema.SetCookieValueOption_AddExpiry{}

								responseCookiesToAdd[i].ExpiryChoice = expiryChoiceInt

								expiryChoiceInt.AddExpiry = v.(string)

							}

							if v, ok := responseCookiesToAddMapStrToI["ignore_expiry"]; ok && !isIntfNil(v) && !expiryChoiceTypeFound {

								expiryChoiceTypeFound = true

								if v.(bool) {
									expiryChoiceInt := &ves_io_schema.SetCookieValueOption_IgnoreExpiry{}
									expiryChoiceInt.IgnoreExpiry = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].ExpiryChoice = expiryChoiceInt
								}

							}

							httponlyChoiceTypeFound := false

							if v, ok := responseCookiesToAddMapStrToI["add_httponly"]; ok && !isIntfNil(v) && !httponlyChoiceTypeFound {

								httponlyChoiceTypeFound = true

								if v.(bool) {
									httponlyChoiceInt := &ves_io_schema.SetCookieValueOption_AddHttponly{}
									httponlyChoiceInt.AddHttponly = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].HttponlyChoice = httponlyChoiceInt
								}

							}

							if v, ok := responseCookiesToAddMapStrToI["ignore_httponly"]; ok && !isIntfNil(v) && !httponlyChoiceTypeFound {

								httponlyChoiceTypeFound = true

								if v.(bool) {
									httponlyChoiceInt := &ves_io_schema.SetCookieValueOption_IgnoreHttponly{}
									httponlyChoiceInt.IgnoreHttponly = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].HttponlyChoice = httponlyChoiceInt
								}

							}

							maxAgeChoiceTypeFound := false

							if v, ok := responseCookiesToAddMapStrToI["ignore_max_age"]; ok && !isIntfNil(v) && !maxAgeChoiceTypeFound {

								maxAgeChoiceTypeFound = true

								if v.(bool) {
									maxAgeChoiceInt := &ves_io_schema.SetCookieValueOption_IgnoreMaxAge{}
									maxAgeChoiceInt.IgnoreMaxAge = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].MaxAgeChoice = maxAgeChoiceInt
								}

							}

							if v, ok := responseCookiesToAddMapStrToI["max_age_value"]; ok && !isIntfNil(v) && !maxAgeChoiceTypeFound {

								maxAgeChoiceTypeFound = true
								maxAgeChoiceInt := &ves_io_schema.SetCookieValueOption_MaxAgeValue{}

								responseCookiesToAdd[i].MaxAgeChoice = maxAgeChoiceInt

								maxAgeChoiceInt.MaxAgeValue = int32(v.(int))

							}

							if w, ok := responseCookiesToAddMapStrToI["name"]; ok && !isIntfNil(w) {
								responseCookiesToAdd[i].Name = w.(string)
							}

							if w, ok := responseCookiesToAddMapStrToI["overwrite"]; ok && !isIntfNil(w) {
								responseCookiesToAdd[i].Overwrite = w.(bool)
							}

							partitionedChoiceTypeFound := false

							if v, ok := responseCookiesToAddMapStrToI["add_partitioned"]; ok && !isIntfNil(v) && !partitionedChoiceTypeFound {

								partitionedChoiceTypeFound = true

								if v.(bool) {
									partitionedChoiceInt := &ves_io_schema.SetCookieValueOption_AddPartitioned{}
									partitionedChoiceInt.AddPartitioned = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].PartitionedChoice = partitionedChoiceInt
								}

							}

							if v, ok := responseCookiesToAddMapStrToI["ignore_partitioned"]; ok && !isIntfNil(v) && !partitionedChoiceTypeFound {

								partitionedChoiceTypeFound = true

								if v.(bool) {
									partitionedChoiceInt := &ves_io_schema.SetCookieValueOption_IgnorePartitioned{}
									partitionedChoiceInt.IgnorePartitioned = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].PartitionedChoice = partitionedChoiceInt
								}

							}

							pathChoiceTypeFound := false

							if v, ok := responseCookiesToAddMapStrToI["add_path"]; ok && !isIntfNil(v) && !pathChoiceTypeFound {

								pathChoiceTypeFound = true
								pathChoiceInt := &ves_io_schema.SetCookieValueOption_AddPath{}

								responseCookiesToAdd[i].PathChoice = pathChoiceInt

								pathChoiceInt.AddPath = v.(string)

							}

							if v, ok := responseCookiesToAddMapStrToI["ignore_path"]; ok && !isIntfNil(v) && !pathChoiceTypeFound {

								pathChoiceTypeFound = true

								if v.(bool) {
									pathChoiceInt := &ves_io_schema.SetCookieValueOption_IgnorePath{}
									pathChoiceInt.IgnorePath = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].PathChoice = pathChoiceInt
								}

							}

							samesiteChoiceTypeFound := false

							if v, ok := responseCookiesToAddMapStrToI["ignore_samesite"]; ok && !isIntfNil(v) && !samesiteChoiceTypeFound {

								samesiteChoiceTypeFound = true

								if v.(bool) {
									samesiteChoiceInt := &ves_io_schema.SetCookieValueOption_IgnoreSamesite{}
									samesiteChoiceInt.IgnoreSamesite = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].SamesiteChoice = samesiteChoiceInt
								}

							}

							if v, ok := responseCookiesToAddMapStrToI["samesite_lax"]; ok && !isIntfNil(v) && !samesiteChoiceTypeFound {

								samesiteChoiceTypeFound = true

								if v.(bool) {
									samesiteChoiceInt := &ves_io_schema.SetCookieValueOption_SamesiteLax{}
									samesiteChoiceInt.SamesiteLax = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].SamesiteChoice = samesiteChoiceInt
								}

							}

							if v, ok := responseCookiesToAddMapStrToI["samesite_none"]; ok && !isIntfNil(v) && !samesiteChoiceTypeFound {

								samesiteChoiceTypeFound = true

								if v.(bool) {
									samesiteChoiceInt := &ves_io_schema.SetCookieValueOption_SamesiteNone{}
									samesiteChoiceInt.SamesiteNone = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].SamesiteChoice = samesiteChoiceInt
								}

							}

							if v, ok := responseCookiesToAddMapStrToI["samesite_strict"]; ok && !isIntfNil(v) && !samesiteChoiceTypeFound {

								samesiteChoiceTypeFound = true

								if v.(bool) {
									samesiteChoiceInt := &ves_io_schema.SetCookieValueOption_SamesiteStrict{}
									samesiteChoiceInt.SamesiteStrict = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].SamesiteChoice = samesiteChoiceInt
								}

							}

							secureChoiceTypeFound := false

							if v, ok := responseCookiesToAddMapStrToI["add_secure"]; ok && !isIntfNil(v) && !secureChoiceTypeFound {

								secureChoiceTypeFound = true

								if v.(bool) {
									secureChoiceInt := &ves_io_schema.SetCookieValueOption_AddSecure{}
									secureChoiceInt.AddSecure = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].SecureChoice = secureChoiceInt
								}

							}

							if v, ok := responseCookiesToAddMapStrToI["ignore_secure"]; ok && !isIntfNil(v) && !secureChoiceTypeFound {

								secureChoiceTypeFound = true

								if v.(bool) {
									secureChoiceInt := &ves_io_schema.SetCookieValueOption_IgnoreSecure{}
									secureChoiceInt.IgnoreSecure = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].SecureChoice = secureChoiceInt
								}

							}

							valueChoiceTypeFound := false

							if v, ok := responseCookiesToAddMapStrToI["ignore_value"]; ok && !isIntfNil(v) && !valueChoiceTypeFound {

								valueChoiceTypeFound = true

								if v.(bool) {
									valueChoiceInt := &ves_io_schema.SetCookieValueOption_IgnoreValue{}
									valueChoiceInt.IgnoreValue = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].ValueChoice = valueChoiceInt
								}

							}

							if v, ok := responseCookiesToAddMapStrToI["secret_value"]; ok && !isIntfNil(v) && !valueChoiceTypeFound {

								valueChoiceTypeFound = true
								valueChoiceInt := &ves_io_schema.SetCookieValueOption_SecretValue{}
								valueChoiceInt.SecretValue = &ves_io_schema.SecretType{}
								responseCookiesToAdd[i].ValueChoice = valueChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
											valueChoiceInt.SecretValue.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
											for _, set := range sl {
												if set != nil {
													blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

													if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.Location = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.StoreProvider = w.(string)
													}

												}
											}

										}

										if v, ok := cs["secret_encoding_type"]; ok && !isIntfNil(v) {

											valueChoiceInt.SecretValue.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										secretInfoOneofTypeFound := false

										if v, ok := cs["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
											secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

													}

													if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

													}

												}
											}

										}

										if v, ok := cs["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
											secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["url"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

													}

												}
											}

										}

										if v, ok := cs["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
											secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["key"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

													}

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													if v, ok := cs["version"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

													}

												}
											}

										}

										if v, ok := cs["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
											secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if v, ok := responseCookiesToAddMapStrToI["value"]; ok && !isIntfNil(v) && !valueChoiceTypeFound {

								valueChoiceTypeFound = true
								valueChoiceInt := &ves_io_schema.SetCookieValueOption_Value{}

								responseCookiesToAdd[i].ValueChoice = valueChoiceInt

								valueChoiceInt.Value = v.(string)

							}

						}
					}

				}

				if w, ok := routesMapStrToI["response_cookies_to_remove"]; ok && !isIntfNil(w) {
					ls := make([]string, len(w.([]interface{})))
					for i, v := range w.([]interface{}) {
						if v == nil {
							return fmt.Errorf("please provide valid non-empty string value of field response_cookies_to_remove")
						}
						if str, ok := v.(string); ok {
							ls[i] = str
						}
					}
					routes[i].ResponseCookiesToRemove = ls
				}

				if v, ok := routesMapStrToI["response_headers_to_add"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					responseHeadersToAdd := make([]*ves_io_schema.HeaderManipulationOptionType, len(sl))
					routes[i].ResponseHeadersToAdd = responseHeadersToAdd
					for i, set := range sl {
						if set != nil {
							responseHeadersToAdd[i] = &ves_io_schema.HeaderManipulationOptionType{}
							responseHeadersToAddMapStrToI := set.(map[string]interface{})

							if w, ok := responseHeadersToAddMapStrToI["append"]; ok && !isIntfNil(w) {
								responseHeadersToAdd[i].Append = w.(bool)
							}

							if w, ok := responseHeadersToAddMapStrToI["name"]; ok && !isIntfNil(w) {
								responseHeadersToAdd[i].Name = w.(string)
							}

							valueChoiceTypeFound := false

							if v, ok := responseHeadersToAddMapStrToI["secret_value"]; ok && !isIntfNil(v) && !valueChoiceTypeFound {

								valueChoiceTypeFound = true
								valueChoiceInt := &ves_io_schema.HeaderManipulationOptionType_SecretValue{}
								valueChoiceInt.SecretValue = &ves_io_schema.SecretType{}
								responseHeadersToAdd[i].ValueChoice = valueChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
											valueChoiceInt.SecretValue.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
											for _, set := range sl {
												if set != nil {
													blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

													if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.Location = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.StoreProvider = w.(string)
													}

												}
											}

										}

										if v, ok := cs["secret_encoding_type"]; ok && !isIntfNil(v) {

											valueChoiceInt.SecretValue.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										secretInfoOneofTypeFound := false

										if v, ok := cs["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
											secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

													}

													if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

													}

												}
											}

										}

										if v, ok := cs["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
											secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["url"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

													}

												}
											}

										}

										if v, ok := cs["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
											secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["key"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

													}

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													if v, ok := cs["version"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

													}

												}
											}

										}

										if v, ok := cs["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
											secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if v, ok := responseHeadersToAddMapStrToI["value"]; ok && !isIntfNil(v) && !valueChoiceTypeFound {

								valueChoiceTypeFound = true
								valueChoiceInt := &ves_io_schema.HeaderManipulationOptionType_Value{}

								responseHeadersToAdd[i].ValueChoice = valueChoiceInt

								valueChoiceInt.Value = v.(string)

							}

						}
					}

				}

				if w, ok := routesMapStrToI["response_headers_to_remove"]; ok && !isIntfNil(w) {
					ls := make([]string, len(w.([]interface{})))
					for i, v := range w.([]interface{}) {
						if v == nil {
							return fmt.Errorf("please provide valid non-empty string value of field response_headers_to_remove")
						}
						if str, ok := v.(string); ok {
							ls[i] = str
						}
					}
					routes[i].ResponseHeadersToRemove = ls
				}

				routeActionTypeFound := false

				if v, ok := routesMapStrToI["route_destination"]; ok && !isIntfNil(v) && !routeActionTypeFound {

					routeActionTypeFound = true
					routeActionInt := &ves_io_schema_route.RouteType_RouteDestination{}
					routeActionInt.RouteDestination = &ves_io_schema_route.RouteDestinationList{}
					routes[i].RouteAction = routeActionInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["buffer_policy"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								bufferPolicy := &ves_io_schema.BufferConfigType{}
								routeActionInt.RouteDestination.BufferPolicy = bufferPolicy
								for _, set := range sl {
									if set != nil {
										bufferPolicyMapStrToI := set.(map[string]interface{})

										if w, ok := bufferPolicyMapStrToI["disabled"]; ok && !isIntfNil(w) {
											bufferPolicy.Disabled = w.(bool)
										}

										if w, ok := bufferPolicyMapStrToI["max_request_bytes"]; ok && !isIntfNil(w) {
											bufferPolicy.MaxRequestBytes = uint32(w.(int))
										}

										if w, ok := bufferPolicyMapStrToI["max_request_time"]; ok && !isIntfNil(w) {
											bufferPolicy.MaxRequestTime = uint32(w.(int))
										}

									}
								}

							}

							clusterRetractChoiceTypeFound := false

							if v, ok := cs["do_not_retract_cluster"]; ok && !isIntfNil(v) && !clusterRetractChoiceTypeFound {

								clusterRetractChoiceTypeFound = true

								if v.(bool) {
									clusterRetractChoiceInt := &ves_io_schema_route.RouteDestinationList_DoNotRetractCluster{}
									clusterRetractChoiceInt.DoNotRetractCluster = &ves_io_schema.Empty{}
									routeActionInt.RouteDestination.ClusterRetractChoice = clusterRetractChoiceInt
								}

							}

							if v, ok := cs["retract_cluster"]; ok && !isIntfNil(v) && !clusterRetractChoiceTypeFound {

								clusterRetractChoiceTypeFound = true

								if v.(bool) {
									clusterRetractChoiceInt := &ves_io_schema_route.RouteDestinationList_RetractCluster{}
									clusterRetractChoiceInt.RetractCluster = &ves_io_schema.Empty{}
									routeActionInt.RouteDestination.ClusterRetractChoice = clusterRetractChoiceInt
								}

							}

							if v, ok := cs["cors_policy"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								corsPolicy := &ves_io_schema.CorsPolicy{}
								routeActionInt.RouteDestination.CorsPolicy = corsPolicy
								for _, set := range sl {
									if set != nil {
										corsPolicyMapStrToI := set.(map[string]interface{})

										if w, ok := corsPolicyMapStrToI["allow_credentials"]; ok && !isIntfNil(w) {
											corsPolicy.AllowCredentials = w.(bool)
										}

										if w, ok := corsPolicyMapStrToI["allow_headers"]; ok && !isIntfNil(w) {
											corsPolicy.AllowHeaders = w.(string)
										}

										if w, ok := corsPolicyMapStrToI["allow_methods"]; ok && !isIntfNil(w) {
											corsPolicy.AllowMethods = w.(string)
										}

										if w, ok := corsPolicyMapStrToI["allow_origin"]; ok && !isIntfNil(w) {
											ls := make([]string, len(w.([]interface{})))
											for i, v := range w.([]interface{}) {
												if v == nil {
													return fmt.Errorf("please provide valid non-empty string value of field allow_origin")
												}
												if str, ok := v.(string); ok {
													ls[i] = str
												}
											}
											corsPolicy.AllowOrigin = ls
										}

										if w, ok := corsPolicyMapStrToI["allow_origin_regex"]; ok && !isIntfNil(w) {
											ls := make([]string, len(w.([]interface{})))
											for i, v := range w.([]interface{}) {
												if v == nil {
													return fmt.Errorf("please provide valid non-empty string value of field allow_origin_regex")
												}
												if str, ok := v.(string); ok {
													ls[i] = str
												}
											}
											corsPolicy.AllowOriginRegex = ls
										}

										if w, ok := corsPolicyMapStrToI["disabled"]; ok && !isIntfNil(w) {
											corsPolicy.Disabled = w.(bool)
										}

										if w, ok := corsPolicyMapStrToI["expose_headers"]; ok && !isIntfNil(w) {
											corsPolicy.ExposeHeaders = w.(string)
										}

										if w, ok := corsPolicyMapStrToI["max_age"]; ok && !isIntfNil(w) {
											corsPolicy.MaxAge = w.(string)
										}

										if w, ok := corsPolicyMapStrToI["maximum_age"]; ok && !isIntfNil(w) {
											corsPolicy.MaximumAge = int32(w.(int))
										}

									}
								}

							}

							if v, ok := cs["csrf_policy"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								csrfPolicy := &ves_io_schema.CsrfPolicy{}
								routeActionInt.RouteDestination.CsrfPolicy = csrfPolicy
								for _, set := range sl {
									if set != nil {
										csrfPolicyMapStrToI := set.(map[string]interface{})

										allowedDomainsTypeFound := false

										if v, ok := csrfPolicyMapStrToI["all_load_balancer_domains"]; ok && !isIntfNil(v) && !allowedDomainsTypeFound {

											allowedDomainsTypeFound = true

											if v.(bool) {
												allowedDomainsInt := &ves_io_schema.CsrfPolicy_AllLoadBalancerDomains{}
												allowedDomainsInt.AllLoadBalancerDomains = &ves_io_schema.Empty{}
												csrfPolicy.AllowedDomains = allowedDomainsInt
											}

										}

										if v, ok := csrfPolicyMapStrToI["custom_domain_list"]; ok && !isIntfNil(v) && !allowedDomainsTypeFound {

											allowedDomainsTypeFound = true
											allowedDomainsInt := &ves_io_schema.CsrfPolicy_CustomDomainList{}
											allowedDomainsInt.CustomDomainList = &ves_io_schema.DomainNameList{}
											csrfPolicy.AllowedDomains = allowedDomainsInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["domains"]; ok && !isIntfNil(v) {

														ls := make([]string, len(v.([]interface{})))
														for i, v := range v.([]interface{}) {
															if v == nil {
																return fmt.Errorf("please provide valid non-empty string value of field domains")
															}
															if str, ok := v.(string); ok {
																ls[i] = str
															}
														}
														allowedDomainsInt.CustomDomainList.Domains = ls

													}

												}
											}

										}

										if v, ok := csrfPolicyMapStrToI["disabled"]; ok && !isIntfNil(v) && !allowedDomainsTypeFound {

											allowedDomainsTypeFound = true

											if v.(bool) {
												allowedDomainsInt := &ves_io_schema.CsrfPolicy_Disabled{}
												allowedDomainsInt.Disabled = &ves_io_schema.Empty{}
												csrfPolicy.AllowedDomains = allowedDomainsInt
											}

										}

									}
								}

							}

							if v, ok := cs["destinations"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								destinations := make([]*ves_io_schema_route.RouteDestination, len(sl))
								routeActionInt.RouteDestination.Destinations = destinations
								for i, set := range sl {
									if set != nil {
										destinations[i] = &ves_io_schema_route.RouteDestination{}
										destinationsMapStrToI := set.(map[string]interface{})

										if v, ok := destinationsMapStrToI["cluster"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											clusterInt := make([]*ves_io_schema.ObjectRefType, len(sl))
											destinations[i].Cluster = clusterInt
											for i, ps := range sl {
												if ps != nil {

													cMapToStrVal := ps.(map[string]interface{})
													clusterInt[i] = &ves_io_schema.ObjectRefType{}

													clusterInt[i].Kind = "cluster"

													if v, ok := cMapToStrVal["name"]; ok && !isIntfNil(v) {
														clusterInt[i].Name = v.(string)
													}

													if v, ok := cMapToStrVal["namespace"]; ok && !isIntfNil(v) {
														clusterInt[i].Namespace = v.(string)
													}

													if v, ok := cMapToStrVal["tenant"]; ok && !isIntfNil(v) {
														clusterInt[i].Tenant = v.(string)
													}

													if v, ok := cMapToStrVal["uid"]; ok && !isIntfNil(v) {
														clusterInt[i].Uid = v.(string)
													}

												}
											}

										}

										if w, ok := destinationsMapStrToI["endpoint_subsets"]; ok && !isIntfNil(w) {
											ms := map[string]string{}
											for k, v := range w.(map[string]interface{}) {
												ms[k] = v.(string)
											}
											destinations[i].EndpointSubsets = ms
										}

										if w, ok := destinationsMapStrToI["priority"]; ok && !isIntfNil(w) {
											destinations[i].Priority = uint32(w.(int))
										}

										if w, ok := destinationsMapStrToI["weight"]; ok && !isIntfNil(w) {
											destinations[i].Weight = uint32(w.(int))
										}

									}
								}

							}

							if v, ok := cs["endpoint_subsets"]; ok && !isIntfNil(v) {

								ms := map[string]string{}
								for k, v := range v.(map[string]interface{}) {
									ms[k] = v.(string)
								}
								routeActionInt.RouteDestination.EndpointSubsets = ms
							}

							if v, ok := cs["hash_policy"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								hashPolicy := make([]*ves_io_schema_route.HashPolicyType, len(sl))
								routeActionInt.RouteDestination.HashPolicy = hashPolicy
								for i, set := range sl {
									if set != nil {
										hashPolicy[i] = &ves_io_schema_route.HashPolicyType{}
										hashPolicyMapStrToI := set.(map[string]interface{})

										policySpecifierTypeFound := false

										if v, ok := hashPolicyMapStrToI["cookie"]; ok && !isIntfNil(v) && !policySpecifierTypeFound {

											policySpecifierTypeFound = true
											policySpecifierInt := &ves_io_schema_route.HashPolicyType_Cookie{}
											policySpecifierInt.Cookie = &ves_io_schema_route.CookieForHashing{}
											hashPolicy[i].PolicySpecifier = policySpecifierInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													httponlyTypeFound := false

													if v, ok := cs["add_httponly"]; ok && !isIntfNil(v) && !httponlyTypeFound {

														httponlyTypeFound = true

														if v.(bool) {
															httponlyInt := &ves_io_schema_route.CookieForHashing_AddHttponly{}
															httponlyInt.AddHttponly = &ves_io_schema.Empty{}
															policySpecifierInt.Cookie.Httponly = httponlyInt
														}

													}

													if v, ok := cs["ignore_httponly"]; ok && !isIntfNil(v) && !httponlyTypeFound {

														httponlyTypeFound = true

														if v.(bool) {
															httponlyInt := &ves_io_schema_route.CookieForHashing_IgnoreHttponly{}
															httponlyInt.IgnoreHttponly = &ves_io_schema.Empty{}
															policySpecifierInt.Cookie.Httponly = httponlyInt
														}

													}

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														policySpecifierInt.Cookie.Name = v.(string)

													}

													if v, ok := cs["path"]; ok && !isIntfNil(v) {

														policySpecifierInt.Cookie.Path = v.(string)

													}

													samesiteTypeFound := false

													if v, ok := cs["ignore_samesite"]; ok && !isIntfNil(v) && !samesiteTypeFound {

														samesiteTypeFound = true

														if v.(bool) {
															samesiteInt := &ves_io_schema_route.CookieForHashing_IgnoreSamesite{}
															samesiteInt.IgnoreSamesite = &ves_io_schema.Empty{}
															policySpecifierInt.Cookie.Samesite = samesiteInt
														}

													}

													if v, ok := cs["samesite_lax"]; ok && !isIntfNil(v) && !samesiteTypeFound {

														samesiteTypeFound = true

														if v.(bool) {
															samesiteInt := &ves_io_schema_route.CookieForHashing_SamesiteLax{}
															samesiteInt.SamesiteLax = &ves_io_schema.Empty{}
															policySpecifierInt.Cookie.Samesite = samesiteInt
														}

													}

													if v, ok := cs["samesite_none"]; ok && !isIntfNil(v) && !samesiteTypeFound {

														samesiteTypeFound = true

														if v.(bool) {
															samesiteInt := &ves_io_schema_route.CookieForHashing_SamesiteNone{}
															samesiteInt.SamesiteNone = &ves_io_schema.Empty{}
															policySpecifierInt.Cookie.Samesite = samesiteInt
														}

													}

													if v, ok := cs["samesite_strict"]; ok && !isIntfNil(v) && !samesiteTypeFound {

														samesiteTypeFound = true

														if v.(bool) {
															samesiteInt := &ves_io_schema_route.CookieForHashing_SamesiteStrict{}
															samesiteInt.SamesiteStrict = &ves_io_schema.Empty{}
															policySpecifierInt.Cookie.Samesite = samesiteInt
														}

													}

													secureTypeFound := false

													if v, ok := cs["add_secure"]; ok && !isIntfNil(v) && !secureTypeFound {

														secureTypeFound = true

														if v.(bool) {
															secureInt := &ves_io_schema_route.CookieForHashing_AddSecure{}
															secureInt.AddSecure = &ves_io_schema.Empty{}
															policySpecifierInt.Cookie.Secure = secureInt
														}

													}

													if v, ok := cs["ignore_secure"]; ok && !isIntfNil(v) && !secureTypeFound {

														secureTypeFound = true

														if v.(bool) {
															secureInt := &ves_io_schema_route.CookieForHashing_IgnoreSecure{}
															secureInt.IgnoreSecure = &ves_io_schema.Empty{}
															policySpecifierInt.Cookie.Secure = secureInt
														}

													}

													if v, ok := cs["ttl"]; ok && !isIntfNil(v) {

														policySpecifierInt.Cookie.Ttl = uint32(v.(int))

													}

												}
											}

										}

										if v, ok := hashPolicyMapStrToI["header_name"]; ok && !isIntfNil(v) && !policySpecifierTypeFound {

											policySpecifierTypeFound = true
											policySpecifierInt := &ves_io_schema_route.HashPolicyType_HeaderName{}

											hashPolicy[i].PolicySpecifier = policySpecifierInt

											policySpecifierInt.HeaderName = v.(string)

										}

										if v, ok := hashPolicyMapStrToI["source_ip"]; ok && !isIntfNil(v) && !policySpecifierTypeFound {

											policySpecifierTypeFound = true
											policySpecifierInt := &ves_io_schema_route.HashPolicyType_SourceIp{}

											hashPolicy[i].PolicySpecifier = policySpecifierInt

											policySpecifierInt.SourceIp = v.(bool)

										}

										if w, ok := hashPolicyMapStrToI["terminal"]; ok && !isIntfNil(w) {
											hashPolicy[i].Terminal = w.(bool)
										}

									}
								}

							}

							hostRewriteParamsTypeFound := false

							if v, ok := cs["auto_host_rewrite"]; ok && !isIntfNil(v) && !hostRewriteParamsTypeFound {

								hostRewriteParamsTypeFound = true
								hostRewriteParamsInt := &ves_io_schema_route.RouteDestinationList_AutoHostRewrite{}

								routeActionInt.RouteDestination.HostRewriteParams = hostRewriteParamsInt

								hostRewriteParamsInt.AutoHostRewrite = v.(bool)

							}

							if v, ok := cs["host_rewrite"]; ok && !isIntfNil(v) && !hostRewriteParamsTypeFound {

								hostRewriteParamsTypeFound = true
								hostRewriteParamsInt := &ves_io_schema_route.RouteDestinationList_HostRewrite{}

								routeActionInt.RouteDestination.HostRewriteParams = hostRewriteParamsInt

								hostRewriteParamsInt.HostRewrite = v.(string)

							}

							if v, ok := cs["mirror_policy"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								mirrorPolicy := &ves_io_schema_route.MirrorPolicyType{}
								routeActionInt.RouteDestination.MirrorPolicy = mirrorPolicy
								for _, set := range sl {
									if set != nil {
										mirrorPolicyMapStrToI := set.(map[string]interface{})

										if v, ok := mirrorPolicyMapStrToI["cluster"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											clusterInt := make([]*ves_io_schema.ObjectRefType, len(sl))
											mirrorPolicy.Cluster = clusterInt
											for i, ps := range sl {
												if ps != nil {

													cMapToStrVal := ps.(map[string]interface{})
													clusterInt[i] = &ves_io_schema.ObjectRefType{}

													clusterInt[i].Kind = "cluster"

													if v, ok := cMapToStrVal["name"]; ok && !isIntfNil(v) {
														clusterInt[i].Name = v.(string)
													}

													if v, ok := cMapToStrVal["namespace"]; ok && !isIntfNil(v) {
														clusterInt[i].Namespace = v.(string)
													}

													if v, ok := cMapToStrVal["tenant"]; ok && !isIntfNil(v) {
														clusterInt[i].Tenant = v.(string)
													}

													if v, ok := cMapToStrVal["uid"]; ok && !isIntfNil(v) {
														clusterInt[i].Uid = v.(string)
													}

												}
											}

										}

										if v, ok := mirrorPolicyMapStrToI["percent"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											percent := &ves_io_schema.FractionalPercent{}
											mirrorPolicy.Percent = percent
											for _, set := range sl {
												if set != nil {
													percentMapStrToI := set.(map[string]interface{})

													if v, ok := percentMapStrToI["denominator"]; ok && !isIntfNil(v) {

														percent.Denominator = ves_io_schema.DenominatorType(ves_io_schema.DenominatorType_value[v.(string)])

													}

													if w, ok := percentMapStrToI["numerator"]; ok && !isIntfNil(w) {
														percent.Numerator = uint32(w.(int))
													}

												}
											}

										}

									}
								}

							}

							if v, ok := cs["priority"]; ok && !isIntfNil(v) {

								routeActionInt.RouteDestination.Priority = ves_io_schema.RoutingPriority(ves_io_schema.RoutingPriority_value[v.(string)])

							}

							if v, ok := cs["query_params"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								queryParams := &ves_io_schema_route.QueryParamsSimpleRoute{}
								routeActionInt.RouteDestination.QueryParams = queryParams
								for _, set := range sl {
									if set != nil {
										queryParamsMapStrToI := set.(map[string]interface{})

										queryParamsTypeFound := false

										if v, ok := queryParamsMapStrToI["remove_all_params"]; ok && !isIntfNil(v) && !queryParamsTypeFound {

											queryParamsTypeFound = true

											if v.(bool) {
												queryParamsInt := &ves_io_schema_route.QueryParamsSimpleRoute_RemoveAllParams{}
												queryParamsInt.RemoveAllParams = &ves_io_schema.Empty{}
												queryParams.QueryParams = queryParamsInt
											}

										}

										if v, ok := queryParamsMapStrToI["replace_params"]; ok && !isIntfNil(v) && !queryParamsTypeFound {

											queryParamsTypeFound = true
											queryParamsInt := &ves_io_schema_route.QueryParamsSimpleRoute_ReplaceParams{}

											queryParams.QueryParams = queryParamsInt

											queryParamsInt.ReplaceParams = v.(string)

										}

										if v, ok := queryParamsMapStrToI["retain_all_params"]; ok && !isIntfNil(v) && !queryParamsTypeFound {

											queryParamsTypeFound = true

											if v.(bool) {
												queryParamsInt := &ves_io_schema_route.QueryParamsSimpleRoute_RetainAllParams{}
												queryParamsInt.RetainAllParams = &ves_io_schema.Empty{}
												queryParams.QueryParams = queryParamsInt
											}

										}

									}
								}

							}

							if v, ok := cs["retry_policy"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								retryPolicy := &ves_io_schema.RetryPolicyType{}
								routeActionInt.RouteDestination.RetryPolicy = retryPolicy
								for _, set := range sl {
									if set != nil {
										retryPolicyMapStrToI := set.(map[string]interface{})

										if v, ok := retryPolicyMapStrToI["back_off"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											backOff := &ves_io_schema.RetryBackOff{}
											retryPolicy.BackOff = backOff
											for _, set := range sl {
												if set != nil {
													backOffMapStrToI := set.(map[string]interface{})

													if w, ok := backOffMapStrToI["base_interval"]; ok && !isIntfNil(w) {
														backOff.BaseInterval = uint32(w.(int))
													}

													if w, ok := backOffMapStrToI["max_interval"]; ok && !isIntfNil(w) {
														backOff.MaxInterval = uint32(w.(int))
													}

												}
											}

										}

										if w, ok := retryPolicyMapStrToI["num_retries"]; ok && !isIntfNil(w) {
											retryPolicy.NumRetries = uint32(w.(int))
										}

										if w, ok := retryPolicyMapStrToI["per_try_timeout"]; ok && !isIntfNil(w) {
											retryPolicy.PerTryTimeout = uint32(w.(int))
										}

										if w, ok := retryPolicyMapStrToI["retriable_status_codes"]; ok && !isIntfNil(w) {
											ls := make([]uint32, len(w.([]interface{})))
											for i, v := range w.([]interface{}) {
												ls[i] = uint32(v.(int))
											}
											retryPolicy.RetriableStatusCodes = ls
										}

										if w, ok := retryPolicyMapStrToI["retry_condition"]; ok && !isIntfNil(w) {
											ls := make([]string, len(w.([]interface{})))
											for i, v := range w.([]interface{}) {
												if v == nil {
													return fmt.Errorf("please provide valid non-empty string value of field retry_condition")
												}
												if str, ok := v.(string); ok {
													ls[i] = str
												}
											}
											retryPolicy.RetryCondition = ls
										}

										if w, ok := retryPolicyMapStrToI["retry_on"]; ok && !isIntfNil(w) {
											retryPolicy.RetryOn = w.(string)
										}

									}
								}

							}

							routeDestinationRewriteTypeFound := false

							if v, ok := cs["prefix_rewrite"]; ok && !isIntfNil(v) && !routeDestinationRewriteTypeFound {

								routeDestinationRewriteTypeFound = true
								routeDestinationRewriteInt := &ves_io_schema_route.RouteDestinationList_PrefixRewrite{}

								routeActionInt.RouteDestination.RouteDestinationRewrite = routeDestinationRewriteInt

								routeDestinationRewriteInt.PrefixRewrite = v.(string)

							}

							if v, ok := cs["regex_rewrite"]; ok && !isIntfNil(v) && !routeDestinationRewriteTypeFound {

								routeDestinationRewriteTypeFound = true
								routeDestinationRewriteInt := &ves_io_schema_route.RouteDestinationList_RegexRewrite{}
								routeDestinationRewriteInt.RegexRewrite = &ves_io_schema.RegexMatchRewrite{}
								routeActionInt.RouteDestination.RouteDestinationRewrite = routeDestinationRewriteInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["pattern"]; ok && !isIntfNil(v) {

											routeDestinationRewriteInt.RegexRewrite.Pattern = v.(string)

										}

										if v, ok := cs["substitution"]; ok && !isIntfNil(v) {

											routeDestinationRewriteInt.RegexRewrite.Substitution = v.(string)

										}

									}
								}

							}

							if v, ok := cs["spdy_config"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								spdyConfig := &ves_io_schema_route.SpdyConfigType{}
								routeActionInt.RouteDestination.SpdyConfig = spdyConfig
								for _, set := range sl {
									if set != nil {
										spdyConfigMapStrToI := set.(map[string]interface{})

										if w, ok := spdyConfigMapStrToI["use_spdy"]; ok && !isIntfNil(w) {
											spdyConfig.UseSpdy = w.(bool)
										}

									}
								}

							}

							if v, ok := cs["timeout"]; ok && !isIntfNil(v) {

								routeActionInt.RouteDestination.Timeout = uint32(v.(int))

							}

							if v, ok := cs["web_socket_config"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								webSocketConfig := &ves_io_schema_route.WebsocketConfigType{}
								routeActionInt.RouteDestination.WebSocketConfig = webSocketConfig
								for _, set := range sl {
									if set != nil {
										webSocketConfigMapStrToI := set.(map[string]interface{})

										if w, ok := webSocketConfigMapStrToI["use_websocket"]; ok && !isIntfNil(w) {
											webSocketConfig.UseWebsocket = w.(bool)
										}

									}
								}

							}

						}
					}

				}

				if v, ok := routesMapStrToI["route_direct_response"]; ok && !isIntfNil(v) && !routeActionTypeFound {

					routeActionTypeFound = true
					routeActionInt := &ves_io_schema_route.RouteType_RouteDirectResponse{}
					routeActionInt.RouteDirectResponse = &ves_io_schema_route.RouteDirectResponse{}
					routes[i].RouteAction = routeActionInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["response_body"]; ok && !isIntfNil(v) {

								routeActionInt.RouteDirectResponse.ResponseBody = v.(string)

							}

							if v, ok := cs["response_body_encoded"]; ok && !isIntfNil(v) {

								routeActionInt.RouteDirectResponse.ResponseBodyEncoded = v.(string)

							}

							if v, ok := cs["response_code"]; ok && !isIntfNil(v) {

								routeActionInt.RouteDirectResponse.ResponseCode = uint32(v.(int))

							}

						}
					}

				}

				if v, ok := routesMapStrToI["route_redirect"]; ok && !isIntfNil(v) && !routeActionTypeFound {

					routeActionTypeFound = true
					routeActionInt := &ves_io_schema_route.RouteType_RouteRedirect{}
					routeActionInt.RouteRedirect = &ves_io_schema_route.RouteRedirect{}
					routes[i].RouteAction = routeActionInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["host_redirect"]; ok && !isIntfNil(v) {

								routeActionInt.RouteRedirect.HostRedirect = v.(string)

							}

							if v, ok := cs["port_redirect"]; ok && !isIntfNil(v) {

								routeActionInt.RouteRedirect.PortRedirect = uint32(v.(int))

							}

							if v, ok := cs["proto_redirect"]; ok && !isIntfNil(v) {

								routeActionInt.RouteRedirect.ProtoRedirect = v.(string)

							}

							queryParamsTypeFound := false

							if v, ok := cs["all_params"]; ok && !isIntfNil(v) && !queryParamsTypeFound {

								queryParamsTypeFound = true
								queryParamsInt := &ves_io_schema_route.RouteRedirect_AllParams{}

								routeActionInt.RouteRedirect.QueryParams = queryParamsInt

								queryParamsInt.AllParams = v.(bool)

							}

							if v, ok := cs["remove_all_params"]; ok && !isIntfNil(v) && !queryParamsTypeFound {

								queryParamsTypeFound = true

								if v.(bool) {
									queryParamsInt := &ves_io_schema_route.RouteRedirect_RemoveAllParams{}
									queryParamsInt.RemoveAllParams = &ves_io_schema.Empty{}
									routeActionInt.RouteRedirect.QueryParams = queryParamsInt
								}

							}

							if v, ok := cs["replace_params"]; ok && !isIntfNil(v) && !queryParamsTypeFound {

								queryParamsTypeFound = true
								queryParamsInt := &ves_io_schema_route.RouteRedirect_ReplaceParams{}

								routeActionInt.RouteRedirect.QueryParams = queryParamsInt

								queryParamsInt.ReplaceParams = v.(string)

							}

							if v, ok := cs["retain_all_params"]; ok && !isIntfNil(v) && !queryParamsTypeFound {

								queryParamsTypeFound = true

								if v.(bool) {
									queryParamsInt := &ves_io_schema_route.RouteRedirect_RetainAllParams{}
									queryParamsInt.RetainAllParams = &ves_io_schema.Empty{}
									routeActionInt.RouteRedirect.QueryParams = queryParamsInt
								}

							}

							if v, ok := cs["strip_query_params"]; ok && !isIntfNil(v) && !queryParamsTypeFound {

								queryParamsTypeFound = true
								queryParamsInt := &ves_io_schema_route.RouteRedirect_StripQueryParams{}
								queryParamsInt.StripQueryParams = &ves_io_schema_route.RouteQueryParams{}
								routeActionInt.RouteRedirect.QueryParams = queryParamsInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["query_params"]; ok && !isIntfNil(v) {

											ls := make([]string, len(v.([]interface{})))
											for i, v := range v.([]interface{}) {
												if v == nil {
													return fmt.Errorf("please provide valid non-empty string value of field query_params")
												}
												if str, ok := v.(string); ok {
													ls[i] = str
												}
											}
											queryParamsInt.StripQueryParams.QueryParams = ls

										}

									}
								}

							}

							redirectPathChoiceTypeFound := false

							if v, ok := cs["path_redirect"]; ok && !isIntfNil(v) && !redirectPathChoiceTypeFound {

								redirectPathChoiceTypeFound = true
								redirectPathChoiceInt := &ves_io_schema_route.RouteRedirect_PathRedirect{}

								routeActionInt.RouteRedirect.RedirectPathChoice = redirectPathChoiceInt

								redirectPathChoiceInt.PathRedirect = v.(string)

							}

							if v, ok := cs["prefix_rewrite"]; ok && !isIntfNil(v) && !redirectPathChoiceTypeFound {

								redirectPathChoiceTypeFound = true
								redirectPathChoiceInt := &ves_io_schema_route.RouteRedirect_PrefixRewrite{}

								routeActionInt.RouteRedirect.RedirectPathChoice = redirectPathChoiceInt

								redirectPathChoiceInt.PrefixRewrite = v.(string)

							}

							if v, ok := cs["response_code"]; ok && !isIntfNil(v) {

								routeActionInt.RouteRedirect.ResponseCode = uint32(v.(int))

							}

						}
					}

				}

				if v, ok := routesMapStrToI["service_policy"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					servicePolicy := &ves_io_schema_route.ServicePolicyInfo{}
					routes[i].ServicePolicy = servicePolicy
					for _, set := range sl {
						if set != nil {
							servicePolicyMapStrToI := set.(map[string]interface{})

							servicePolicyChoiceTypeFound := false

							if v, ok := servicePolicyMapStrToI["context_extensions"]; ok && !isIntfNil(v) && !servicePolicyChoiceTypeFound {

								servicePolicyChoiceTypeFound = true
								servicePolicyChoiceInt := &ves_io_schema_route.ServicePolicyInfo_ContextExtensions{}
								servicePolicyChoiceInt.ContextExtensions = &ves_io_schema_route.ContextExtensionInfo{}
								servicePolicy.ServicePolicyChoice = servicePolicyChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["context_extensions"]; ok && !isIntfNil(v) {

											ms := map[string]string{}
											for k, v := range v.(map[string]interface{}) {
												ms[k] = v.(string)
											}
											servicePolicyChoiceInt.ContextExtensions.ContextExtensions = ms
										}

									}
								}

							}

							if v, ok := servicePolicyMapStrToI["disable"]; ok && !isIntfNil(v) && !servicePolicyChoiceTypeFound {

								servicePolicyChoiceTypeFound = true
								servicePolicyChoiceInt := &ves_io_schema_route.ServicePolicyInfo_Disable{}

								servicePolicy.ServicePolicyChoice = servicePolicyChoiceInt

								servicePolicyChoiceInt.Disable = v.(bool)

							}

						}
					}

				}

				if w, ok := routesMapStrToI["skip_lb_override"]; ok && !isIntfNil(w) {
					routes[i].SkipLbOverride = w.(bool)
				}

				if w, ok := routesMapStrToI["uuid"]; ok && !isIntfNil(w) {
					routes[i].Uuid = w.(string)
				}

				wafExclusionChoiceTypeFound := false

				if v, ok := routesMapStrToI["inherited_waf_exclusion"]; ok && !isIntfNil(v) && !wafExclusionChoiceTypeFound {

					wafExclusionChoiceTypeFound = true

					if v.(bool) {
						wafExclusionChoiceInt := &ves_io_schema_route.RouteType_InheritedWafExclusion{}
						wafExclusionChoiceInt.InheritedWafExclusion = &ves_io_schema.Empty{}
						routes[i].WafExclusionChoice = wafExclusionChoiceInt
					}

				}

				if v, ok := routesMapStrToI["waf_exclusion_policy"]; ok && !isIntfNil(v) && !wafExclusionChoiceTypeFound {

					wafExclusionChoiceTypeFound = true
					wafExclusionChoiceInt := &ves_io_schema_route.RouteType_WafExclusionPolicy{}
					wafExclusionChoiceInt.WafExclusionPolicy = &ves_io_schema_views.ObjectRefType{}
					routes[i].WafExclusionChoice = wafExclusionChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								wafExclusionChoiceInt.WafExclusionPolicy.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								wafExclusionChoiceInt.WafExclusionPolicy.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								wafExclusionChoiceInt.WafExclusionPolicy.Tenant = v.(string)

							}

						}
					}

				}

				if v, ok := routesMapStrToI["waf_exclusion_service_policy"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					wafExclusionServicePolicyInt := make([]*ves_io_schema.ObjectRefType, len(sl))
					routes[i].WafExclusionServicePolicy = wafExclusionServicePolicyInt
					for i, ps := range sl {
						if ps != nil {

							wespMapToStrVal := ps.(map[string]interface{})
							wafExclusionServicePolicyInt[i] = &ves_io_schema.ObjectRefType{}

							wafExclusionServicePolicyInt[i].Kind = "service_policy"

							if v, ok := wespMapToStrVal["name"]; ok && !isIntfNil(v) {
								wafExclusionServicePolicyInt[i].Name = v.(string)
							}

							if v, ok := wespMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								wafExclusionServicePolicyInt[i].Namespace = v.(string)
							}

							if v, ok := wespMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								wafExclusionServicePolicyInt[i].Tenant = v.(string)
							}

							if v, ok := wespMapToStrVal["uid"]; ok && !isIntfNil(v) {
								wafExclusionServicePolicyInt[i].Uid = v.(string)
							}

						}
					}

				}

				if v, ok := routesMapStrToI["waf_type"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					wafType := &ves_io_schema.WafType{}
					routes[i].WafType = wafType
					for _, set := range sl {
						if set != nil {
							wafTypeMapStrToI := set.(map[string]interface{})

							refTypeTypeFound := false

							if v, ok := wafTypeMapStrToI["app_firewall"]; ok && !isIntfNil(v) && !refTypeTypeFound {

								refTypeTypeFound = true
								refTypeInt := &ves_io_schema.WafType_AppFirewall{}
								refTypeInt.AppFirewall = &ves_io_schema.AppFirewallRefType{}
								wafType.RefType = refTypeInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["app_firewall"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											appFirewallInt := make([]*ves_io_schema.ObjectRefType, len(sl))
											refTypeInt.AppFirewall.AppFirewall = appFirewallInt
											for i, ps := range sl {
												if ps != nil {

													afMapToStrVal := ps.(map[string]interface{})
													appFirewallInt[i] = &ves_io_schema.ObjectRefType{}

													appFirewallInt[i].Kind = "app_firewall"

													if v, ok := afMapToStrVal["name"]; ok && !isIntfNil(v) {
														appFirewallInt[i].Name = v.(string)
													}

													if v, ok := afMapToStrVal["namespace"]; ok && !isIntfNil(v) {
														appFirewallInt[i].Namespace = v.(string)
													}

													if v, ok := afMapToStrVal["tenant"]; ok && !isIntfNil(v) {
														appFirewallInt[i].Tenant = v.(string)
													}

													if v, ok := afMapToStrVal["uid"]; ok && !isIntfNil(v) {
														appFirewallInt[i].Uid = v.(string)
													}

												}
											}

										}

									}
								}

							}

							if v, ok := wafTypeMapStrToI["disable_waf"]; ok && !isIntfNil(v) && !refTypeTypeFound {

								refTypeTypeFound = true

								if v.(bool) {
									refTypeInt := &ves_io_schema.WafType_DisableWaf{}
									refTypeInt.DisableWaf = &ves_io_schema.Empty{}
									wafType.RefType = refTypeInt
								}

							}

							if v, ok := wafTypeMapStrToI["inherit_waf"]; ok && !isIntfNil(v) && !refTypeTypeFound {

								refTypeTypeFound = true

								if v.(bool) {
									refTypeInt := &ves_io_schema.WafType_InheritWaf{}
									refTypeInt.InheritWaf = &ves_io_schema.Empty{}
									wafType.RefType = refTypeInt
								}

							}

						}
					}

				}

			}
		}

	}

	log.Printf("[DEBUG] Creating Volterra Route object with struct: %+v", createReq)

	createRouteResp, err := client.CreateObject(context.Background(), ves_io_schema_route.ObjectType, createReq)
	if err != nil {
		return fmt.Errorf("error creating Route: %s", err)
	}
	d.SetId(createRouteResp.GetObjSystemMetadata().GetUid())

	return resourceVolterraRouteRead(d, meta)
}

func resourceVolterraRouteRead(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	resp, err := client.GetObject(context.Background(), ves_io_schema_route.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] Route %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra Route %q: %s", d.Id(), err)
	}
	return setRouteFields(client, d, resp)
}

func setRouteFields(client *APIClient, d *schema.ResourceData, resp vesapi.GetObjectResponse) error {
	metadata := resp.GetObjMetadata()

	d.Set("annotations", metadata.GetAnnotations())

	d.Set("description", metadata.GetDescription())

	d.Set("disable", metadata.GetDisable())

	d.Set("labels", metadata.GetLabels())

	d.Set("name", metadata.GetName())

	d.Set("namespace", metadata.GetNamespace())

	return nil
}

// resourceVolterraRouteUpdate updates Route resource
func resourceVolterraRouteUpdate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	updateMeta := &ves_io_schema.ObjectReplaceMetaType{}
	updateSpec := &ves_io_schema_route.ReplaceSpecType{}
	updateReq := &ves_io_schema_route.ReplaceRequest{
		Metadata: updateMeta,
		Spec:     updateSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		updateMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		updateMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		updateMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		updateMeta.Namespace =
			v.(string)
	}

	if v, ok := d.GetOk("routes"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		routes := make([]*ves_io_schema_route.RouteType, len(sl))
		updateSpec.Routes = routes
		for i, set := range sl {
			if set != nil {
				routes[i] = &ves_io_schema_route.RouteType{}
				routesMapStrToI := set.(map[string]interface{})

				botDefenseJavascriptInjectionChoiceTypeFound := false

				if v, ok := routesMapStrToI["bot_defense_javascript_injection"]; ok && !isIntfNil(v) && !botDefenseJavascriptInjectionChoiceTypeFound {

					botDefenseJavascriptInjectionChoiceTypeFound = true
					botDefenseJavascriptInjectionChoiceInt := &ves_io_schema_route.RouteType_BotDefenseJavascriptInjection{}
					botDefenseJavascriptInjectionChoiceInt.BotDefenseJavascriptInjection = &ves_io_schema_route.BotDefenseJavascriptInjectionType{}
					routes[i].BotDefenseJavascriptInjectionChoice = botDefenseJavascriptInjectionChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["javascript_location"]; ok && !isIntfNil(v) {

								botDefenseJavascriptInjectionChoiceInt.BotDefenseJavascriptInjection.JavascriptLocation = ves_io_schema_route.JavaScriptLocation(ves_io_schema_route.JavaScriptLocation_value[v.(string)])

							}

							if v, ok := cs["javascript_tags"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								javascriptTags := make([]*ves_io_schema_route.JavaScriptTag, len(sl))
								botDefenseJavascriptInjectionChoiceInt.BotDefenseJavascriptInjection.JavascriptTags = javascriptTags
								for i, set := range sl {
									if set != nil {
										javascriptTags[i] = &ves_io_schema_route.JavaScriptTag{}
										javascriptTagsMapStrToI := set.(map[string]interface{})

										if w, ok := javascriptTagsMapStrToI["javascript_url"]; ok && !isIntfNil(w) {
											javascriptTags[i].JavascriptUrl = w.(string)
										}

										if v, ok := javascriptTagsMapStrToI["tag_attributes"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											tagAttributes := make([]*ves_io_schema_route.TagAttribute, len(sl))
											javascriptTags[i].TagAttributes = tagAttributes
											for i, set := range sl {
												if set != nil {
													tagAttributes[i] = &ves_io_schema_route.TagAttribute{}
													tagAttributesMapStrToI := set.(map[string]interface{})

													if v, ok := tagAttributesMapStrToI["javascript_tag"]; ok && !isIntfNil(v) {

														tagAttributes[i].JavascriptTag = ves_io_schema_route.TagAttributeName(ves_io_schema_route.TagAttributeName_value[v.(string)])

													}

													if w, ok := tagAttributesMapStrToI["tag_value"]; ok && !isIntfNil(w) {
														tagAttributes[i].TagValue = w.(string)
													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := routesMapStrToI["inherited_bot_defense_javascript_injection"]; ok && !isIntfNil(v) && !botDefenseJavascriptInjectionChoiceTypeFound {

					botDefenseJavascriptInjectionChoiceTypeFound = true

					if v.(bool) {
						botDefenseJavascriptInjectionChoiceInt := &ves_io_schema_route.RouteType_InheritedBotDefenseJavascriptInjection{}
						botDefenseJavascriptInjectionChoiceInt.InheritedBotDefenseJavascriptInjection = &ves_io_schema.Empty{}
						routes[i].BotDefenseJavascriptInjectionChoice = botDefenseJavascriptInjectionChoiceInt
					}

				}

				if v, ok := routesMapStrToI["bot_defense_javascript_injection_inline_mode"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					botDefenseJavascriptInjectionInlineMode := &ves_io_schema_route.ContentRewriteType{}
					routes[i].BotDefenseJavascriptInjectionInlineMode = botDefenseJavascriptInjectionInlineMode
					for _, set := range sl {
						if set != nil {
							botDefenseJavascriptInjectionInlineModeMapStrToI := set.(map[string]interface{})

							if w, ok := botDefenseJavascriptInjectionInlineModeMapStrToI["element_selector"]; ok && !isIntfNil(w) {
								botDefenseJavascriptInjectionInlineMode.ElementSelector = w.(string)
							}

							if w, ok := botDefenseJavascriptInjectionInlineModeMapStrToI["insert_content"]; ok && !isIntfNil(w) {
								botDefenseJavascriptInjectionInlineMode.InsertContent = w.(string)
							}

							if v, ok := botDefenseJavascriptInjectionInlineModeMapStrToI["position"]; ok && !isIntfNil(v) {

								botDefenseJavascriptInjectionInlineMode.Position = ves_io_schema_policy.HTMLPosition(ves_io_schema_policy.HTMLPosition_value[v.(string)])

							}

						}
					}

				}

				if w, ok := routesMapStrToI["disable_custom_script"]; ok && !isIntfNil(w) {
					routes[i].DisableCustomScript = w.(bool)
				}

				if w, ok := routesMapStrToI["disable_location_add"]; ok && !isIntfNil(w) {
					routes[i].DisableLocationAdd = w.(bool)
				}

				if v, ok := routesMapStrToI["match"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					match := make([]*ves_io_schema.RouteMatch, len(sl))
					routes[i].Match = match
					for i, set := range sl {
						if set != nil {
							match[i] = &ves_io_schema.RouteMatch{}
							matchMapStrToI := set.(map[string]interface{})

							if v, ok := matchMapStrToI["headers"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								headers := make([]*ves_io_schema.HeaderMatcherType, len(sl))
								match[i].Headers = headers
								for i, set := range sl {
									if set != nil {
										headers[i] = &ves_io_schema.HeaderMatcherType{}
										headersMapStrToI := set.(map[string]interface{})

										if w, ok := headersMapStrToI["invert_match"]; ok && !isIntfNil(w) {
											headers[i].InvertMatch = w.(bool)
										}

										if w, ok := headersMapStrToI["name"]; ok && !isIntfNil(w) {
											headers[i].Name = w.(string)
										}

										valueMatchTypeFound := false

										if v, ok := headersMapStrToI["exact"]; ok && !isIntfNil(v) && !valueMatchTypeFound {

											valueMatchTypeFound = true
											valueMatchInt := &ves_io_schema.HeaderMatcherType_Exact{}

											headers[i].ValueMatch = valueMatchInt

											valueMatchInt.Exact = v.(string)

										}

										if v, ok := headersMapStrToI["presence"]; ok && !isIntfNil(v) && !valueMatchTypeFound {

											valueMatchTypeFound = true
											valueMatchInt := &ves_io_schema.HeaderMatcherType_Presence{}

											headers[i].ValueMatch = valueMatchInt

											valueMatchInt.Presence = v.(bool)

										}

										if v, ok := headersMapStrToI["regex"]; ok && !isIntfNil(v) && !valueMatchTypeFound {

											valueMatchTypeFound = true
											valueMatchInt := &ves_io_schema.HeaderMatcherType_Regex{}

											headers[i].ValueMatch = valueMatchInt

											valueMatchInt.Regex = v.(string)

										}

									}
								}

							}

							if v, ok := matchMapStrToI["http_method"]; ok && !isIntfNil(v) {

								match[i].HttpMethod = ves_io_schema.HttpMethod(ves_io_schema.HttpMethod_value[v.(string)])

							}

							if v, ok := matchMapStrToI["incoming_port"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								incomingPort := &ves_io_schema.PortMatcherType{}
								match[i].IncomingPort = incomingPort
								for _, set := range sl {
									if set != nil {
										incomingPortMapStrToI := set.(map[string]interface{})

										portMatchTypeFound := false

										if v, ok := incomingPortMapStrToI["no_port_match"]; ok && !isIntfNil(v) && !portMatchTypeFound {

											portMatchTypeFound = true

											if v.(bool) {
												portMatchInt := &ves_io_schema.PortMatcherType_NoPortMatch{}
												portMatchInt.NoPortMatch = &ves_io_schema.Empty{}
												incomingPort.PortMatch = portMatchInt
											}

										}

										if v, ok := incomingPortMapStrToI["port"]; ok && !isIntfNil(v) && !portMatchTypeFound {

											portMatchTypeFound = true
											portMatchInt := &ves_io_schema.PortMatcherType_Port{}

											incomingPort.PortMatch = portMatchInt

											portMatchInt.Port = uint32(v.(int))

										}

										if v, ok := incomingPortMapStrToI["port_ranges"]; ok && !isIntfNil(v) && !portMatchTypeFound {

											portMatchTypeFound = true
											portMatchInt := &ves_io_schema.PortMatcherType_PortRanges{}

											incomingPort.PortMatch = portMatchInt

											portMatchInt.PortRanges = v.(string)

										}

									}
								}

							}

							if v, ok := matchMapStrToI["path"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								path := &ves_io_schema.PathMatcherType{}
								match[i].Path = path
								for _, set := range sl {
									if set != nil {
										pathMapStrToI := set.(map[string]interface{})

										pathMatchTypeFound := false

										if v, ok := pathMapStrToI["path"]; ok && !isIntfNil(v) && !pathMatchTypeFound {

											pathMatchTypeFound = true
											pathMatchInt := &ves_io_schema.PathMatcherType_Path{}

											path.PathMatch = pathMatchInt

											pathMatchInt.Path = v.(string)

										}

										if v, ok := pathMapStrToI["prefix"]; ok && !isIntfNil(v) && !pathMatchTypeFound {

											pathMatchTypeFound = true
											pathMatchInt := &ves_io_schema.PathMatcherType_Prefix{}

											path.PathMatch = pathMatchInt

											pathMatchInt.Prefix = v.(string)

										}

										if v, ok := pathMapStrToI["regex"]; ok && !isIntfNil(v) && !pathMatchTypeFound {

											pathMatchTypeFound = true
											pathMatchInt := &ves_io_schema.PathMatcherType_Regex{}

											path.PathMatch = pathMatchInt

											pathMatchInt.Regex = v.(string)

										}

									}
								}

							}

							if v, ok := matchMapStrToI["query_params"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								queryParams := make([]*ves_io_schema.QueryParameterMatcherType, len(sl))
								match[i].QueryParams = queryParams
								for i, set := range sl {
									if set != nil {
										queryParams[i] = &ves_io_schema.QueryParameterMatcherType{}
										queryParamsMapStrToI := set.(map[string]interface{})

										if w, ok := queryParamsMapStrToI["key"]; ok && !isIntfNil(w) {
											queryParams[i].Key = w.(string)
										}

										valueMatchTypeFound := false

										if v, ok := queryParamsMapStrToI["exact"]; ok && !isIntfNil(v) && !valueMatchTypeFound {

											valueMatchTypeFound = true
											valueMatchInt := &ves_io_schema.QueryParameterMatcherType_Exact{}

											queryParams[i].ValueMatch = valueMatchInt

											valueMatchInt.Exact = v.(string)

										}

										if v, ok := queryParamsMapStrToI["regex"]; ok && !isIntfNil(v) && !valueMatchTypeFound {

											valueMatchTypeFound = true
											valueMatchInt := &ves_io_schema.QueryParameterMatcherType_Regex{}

											queryParams[i].ValueMatch = valueMatchInt

											valueMatchInt.Regex = v.(string)

										}

									}
								}

							}

						}
					}

				}

				if v, ok := routesMapStrToI["request_cookies_to_add"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					requestCookiesToAdd := make([]*ves_io_schema.CookieValueOption, len(sl))
					routes[i].RequestCookiesToAdd = requestCookiesToAdd
					for i, set := range sl {
						if set != nil {
							requestCookiesToAdd[i] = &ves_io_schema.CookieValueOption{}
							requestCookiesToAddMapStrToI := set.(map[string]interface{})

							if w, ok := requestCookiesToAddMapStrToI["name"]; ok && !isIntfNil(w) {
								requestCookiesToAdd[i].Name = w.(string)
							}

							if w, ok := requestCookiesToAddMapStrToI["overwrite"]; ok && !isIntfNil(w) {
								requestCookiesToAdd[i].Overwrite = w.(bool)
							}

							valueChoiceTypeFound := false

							if v, ok := requestCookiesToAddMapStrToI["secret_value"]; ok && !isIntfNil(v) && !valueChoiceTypeFound {

								valueChoiceTypeFound = true
								valueChoiceInt := &ves_io_schema.CookieValueOption_SecretValue{}
								valueChoiceInt.SecretValue = &ves_io_schema.SecretType{}
								requestCookiesToAdd[i].ValueChoice = valueChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
											valueChoiceInt.SecretValue.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
											for _, set := range sl {
												if set != nil {
													blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

													if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.Location = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.StoreProvider = w.(string)
													}

												}
											}

										}

										if v, ok := cs["secret_encoding_type"]; ok && !isIntfNil(v) {

											valueChoiceInt.SecretValue.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										secretInfoOneofTypeFound := false

										if v, ok := cs["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
											secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

													}

													if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

													}

												}
											}

										}

										if v, ok := cs["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
											secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["url"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

													}

												}
											}

										}

										if v, ok := cs["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
											secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["key"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

													}

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													if v, ok := cs["version"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

													}

												}
											}

										}

										if v, ok := cs["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
											secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if v, ok := requestCookiesToAddMapStrToI["value"]; ok && !isIntfNil(v) && !valueChoiceTypeFound {

								valueChoiceTypeFound = true
								valueChoiceInt := &ves_io_schema.CookieValueOption_Value{}

								requestCookiesToAdd[i].ValueChoice = valueChoiceInt

								valueChoiceInt.Value = v.(string)

							}

						}
					}

				}

				if w, ok := routesMapStrToI["request_cookies_to_remove"]; ok && !isIntfNil(w) {
					ls := make([]string, len(w.([]interface{})))
					for i, v := range w.([]interface{}) {
						if v == nil {
							return fmt.Errorf("please provide valid non-empty string value of field request_cookies_to_remove")
						}
						if str, ok := v.(string); ok {
							ls[i] = str
						}
					}
					routes[i].RequestCookiesToRemove = ls
				}

				if v, ok := routesMapStrToI["request_headers_to_add"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					requestHeadersToAdd := make([]*ves_io_schema.HeaderManipulationOptionType, len(sl))
					routes[i].RequestHeadersToAdd = requestHeadersToAdd
					for i, set := range sl {
						if set != nil {
							requestHeadersToAdd[i] = &ves_io_schema.HeaderManipulationOptionType{}
							requestHeadersToAddMapStrToI := set.(map[string]interface{})

							if w, ok := requestHeadersToAddMapStrToI["append"]; ok && !isIntfNil(w) {
								requestHeadersToAdd[i].Append = w.(bool)
							}

							if w, ok := requestHeadersToAddMapStrToI["name"]; ok && !isIntfNil(w) {
								requestHeadersToAdd[i].Name = w.(string)
							}

							valueChoiceTypeFound := false

							if v, ok := requestHeadersToAddMapStrToI["secret_value"]; ok && !isIntfNil(v) && !valueChoiceTypeFound {

								valueChoiceTypeFound = true
								valueChoiceInt := &ves_io_schema.HeaderManipulationOptionType_SecretValue{}
								valueChoiceInt.SecretValue = &ves_io_schema.SecretType{}
								requestHeadersToAdd[i].ValueChoice = valueChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
											valueChoiceInt.SecretValue.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
											for _, set := range sl {
												if set != nil {
													blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

													if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.Location = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.StoreProvider = w.(string)
													}

												}
											}

										}

										if v, ok := cs["secret_encoding_type"]; ok && !isIntfNil(v) {

											valueChoiceInt.SecretValue.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										secretInfoOneofTypeFound := false

										if v, ok := cs["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
											secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

													}

													if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

													}

												}
											}

										}

										if v, ok := cs["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
											secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["url"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

													}

												}
											}

										}

										if v, ok := cs["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
											secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["key"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

													}

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													if v, ok := cs["version"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

													}

												}
											}

										}

										if v, ok := cs["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
											secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if v, ok := requestHeadersToAddMapStrToI["value"]; ok && !isIntfNil(v) && !valueChoiceTypeFound {

								valueChoiceTypeFound = true
								valueChoiceInt := &ves_io_schema.HeaderManipulationOptionType_Value{}

								requestHeadersToAdd[i].ValueChoice = valueChoiceInt

								valueChoiceInt.Value = v.(string)

							}

						}
					}

				}

				if w, ok := routesMapStrToI["request_headers_to_remove"]; ok && !isIntfNil(w) {
					ls := make([]string, len(w.([]interface{})))
					for i, v := range w.([]interface{}) {
						if v == nil {
							return fmt.Errorf("please provide valid non-empty string value of field request_headers_to_remove")
						}
						if str, ok := v.(string); ok {
							ls[i] = str
						}
					}
					routes[i].RequestHeadersToRemove = ls
				}

				if v, ok := routesMapStrToI["response_cookies_to_add"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					responseCookiesToAdd := make([]*ves_io_schema.SetCookieValueOption, len(sl))
					routes[i].ResponseCookiesToAdd = responseCookiesToAdd
					for i, set := range sl {
						if set != nil {
							responseCookiesToAdd[i] = &ves_io_schema.SetCookieValueOption{}
							responseCookiesToAddMapStrToI := set.(map[string]interface{})

							domainChoiceTypeFound := false

							if v, ok := responseCookiesToAddMapStrToI["add_domain"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

								domainChoiceTypeFound = true
								domainChoiceInt := &ves_io_schema.SetCookieValueOption_AddDomain{}

								responseCookiesToAdd[i].DomainChoice = domainChoiceInt

								domainChoiceInt.AddDomain = v.(string)

							}

							if v, ok := responseCookiesToAddMapStrToI["ignore_domain"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

								domainChoiceTypeFound = true

								if v.(bool) {
									domainChoiceInt := &ves_io_schema.SetCookieValueOption_IgnoreDomain{}
									domainChoiceInt.IgnoreDomain = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].DomainChoice = domainChoiceInt
								}

							}

							expiryChoiceTypeFound := false

							if v, ok := responseCookiesToAddMapStrToI["add_expiry"]; ok && !isIntfNil(v) && !expiryChoiceTypeFound {

								expiryChoiceTypeFound = true
								expiryChoiceInt := &ves_io_schema.SetCookieValueOption_AddExpiry{}

								responseCookiesToAdd[i].ExpiryChoice = expiryChoiceInt

								expiryChoiceInt.AddExpiry = v.(string)

							}

							if v, ok := responseCookiesToAddMapStrToI["ignore_expiry"]; ok && !isIntfNil(v) && !expiryChoiceTypeFound {

								expiryChoiceTypeFound = true

								if v.(bool) {
									expiryChoiceInt := &ves_io_schema.SetCookieValueOption_IgnoreExpiry{}
									expiryChoiceInt.IgnoreExpiry = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].ExpiryChoice = expiryChoiceInt
								}

							}

							httponlyChoiceTypeFound := false

							if v, ok := responseCookiesToAddMapStrToI["add_httponly"]; ok && !isIntfNil(v) && !httponlyChoiceTypeFound {

								httponlyChoiceTypeFound = true

								if v.(bool) {
									httponlyChoiceInt := &ves_io_schema.SetCookieValueOption_AddHttponly{}
									httponlyChoiceInt.AddHttponly = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].HttponlyChoice = httponlyChoiceInt
								}

							}

							if v, ok := responseCookiesToAddMapStrToI["ignore_httponly"]; ok && !isIntfNil(v) && !httponlyChoiceTypeFound {

								httponlyChoiceTypeFound = true

								if v.(bool) {
									httponlyChoiceInt := &ves_io_schema.SetCookieValueOption_IgnoreHttponly{}
									httponlyChoiceInt.IgnoreHttponly = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].HttponlyChoice = httponlyChoiceInt
								}

							}

							maxAgeChoiceTypeFound := false

							if v, ok := responseCookiesToAddMapStrToI["ignore_max_age"]; ok && !isIntfNil(v) && !maxAgeChoiceTypeFound {

								maxAgeChoiceTypeFound = true

								if v.(bool) {
									maxAgeChoiceInt := &ves_io_schema.SetCookieValueOption_IgnoreMaxAge{}
									maxAgeChoiceInt.IgnoreMaxAge = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].MaxAgeChoice = maxAgeChoiceInt
								}

							}

							if v, ok := responseCookiesToAddMapStrToI["max_age_value"]; ok && !isIntfNil(v) && !maxAgeChoiceTypeFound {

								maxAgeChoiceTypeFound = true
								maxAgeChoiceInt := &ves_io_schema.SetCookieValueOption_MaxAgeValue{}

								responseCookiesToAdd[i].MaxAgeChoice = maxAgeChoiceInt

								maxAgeChoiceInt.MaxAgeValue = int32(v.(int))

							}

							if w, ok := responseCookiesToAddMapStrToI["name"]; ok && !isIntfNil(w) {
								responseCookiesToAdd[i].Name = w.(string)
							}

							if w, ok := responseCookiesToAddMapStrToI["overwrite"]; ok && !isIntfNil(w) {
								responseCookiesToAdd[i].Overwrite = w.(bool)
							}

							partitionedChoiceTypeFound := false

							if v, ok := responseCookiesToAddMapStrToI["add_partitioned"]; ok && !isIntfNil(v) && !partitionedChoiceTypeFound {

								partitionedChoiceTypeFound = true

								if v.(bool) {
									partitionedChoiceInt := &ves_io_schema.SetCookieValueOption_AddPartitioned{}
									partitionedChoiceInt.AddPartitioned = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].PartitionedChoice = partitionedChoiceInt
								}

							}

							if v, ok := responseCookiesToAddMapStrToI["ignore_partitioned"]; ok && !isIntfNil(v) && !partitionedChoiceTypeFound {

								partitionedChoiceTypeFound = true

								if v.(bool) {
									partitionedChoiceInt := &ves_io_schema.SetCookieValueOption_IgnorePartitioned{}
									partitionedChoiceInt.IgnorePartitioned = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].PartitionedChoice = partitionedChoiceInt
								}

							}

							pathChoiceTypeFound := false

							if v, ok := responseCookiesToAddMapStrToI["add_path"]; ok && !isIntfNil(v) && !pathChoiceTypeFound {

								pathChoiceTypeFound = true
								pathChoiceInt := &ves_io_schema.SetCookieValueOption_AddPath{}

								responseCookiesToAdd[i].PathChoice = pathChoiceInt

								pathChoiceInt.AddPath = v.(string)

							}

							if v, ok := responseCookiesToAddMapStrToI["ignore_path"]; ok && !isIntfNil(v) && !pathChoiceTypeFound {

								pathChoiceTypeFound = true

								if v.(bool) {
									pathChoiceInt := &ves_io_schema.SetCookieValueOption_IgnorePath{}
									pathChoiceInt.IgnorePath = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].PathChoice = pathChoiceInt
								}

							}

							samesiteChoiceTypeFound := false

							if v, ok := responseCookiesToAddMapStrToI["ignore_samesite"]; ok && !isIntfNil(v) && !samesiteChoiceTypeFound {

								samesiteChoiceTypeFound = true

								if v.(bool) {
									samesiteChoiceInt := &ves_io_schema.SetCookieValueOption_IgnoreSamesite{}
									samesiteChoiceInt.IgnoreSamesite = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].SamesiteChoice = samesiteChoiceInt
								}

							}

							if v, ok := responseCookiesToAddMapStrToI["samesite_lax"]; ok && !isIntfNil(v) && !samesiteChoiceTypeFound {

								samesiteChoiceTypeFound = true

								if v.(bool) {
									samesiteChoiceInt := &ves_io_schema.SetCookieValueOption_SamesiteLax{}
									samesiteChoiceInt.SamesiteLax = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].SamesiteChoice = samesiteChoiceInt
								}

							}

							if v, ok := responseCookiesToAddMapStrToI["samesite_none"]; ok && !isIntfNil(v) && !samesiteChoiceTypeFound {

								samesiteChoiceTypeFound = true

								if v.(bool) {
									samesiteChoiceInt := &ves_io_schema.SetCookieValueOption_SamesiteNone{}
									samesiteChoiceInt.SamesiteNone = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].SamesiteChoice = samesiteChoiceInt
								}

							}

							if v, ok := responseCookiesToAddMapStrToI["samesite_strict"]; ok && !isIntfNil(v) && !samesiteChoiceTypeFound {

								samesiteChoiceTypeFound = true

								if v.(bool) {
									samesiteChoiceInt := &ves_io_schema.SetCookieValueOption_SamesiteStrict{}
									samesiteChoiceInt.SamesiteStrict = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].SamesiteChoice = samesiteChoiceInt
								}

							}

							secureChoiceTypeFound := false

							if v, ok := responseCookiesToAddMapStrToI["add_secure"]; ok && !isIntfNil(v) && !secureChoiceTypeFound {

								secureChoiceTypeFound = true

								if v.(bool) {
									secureChoiceInt := &ves_io_schema.SetCookieValueOption_AddSecure{}
									secureChoiceInt.AddSecure = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].SecureChoice = secureChoiceInt
								}

							}

							if v, ok := responseCookiesToAddMapStrToI["ignore_secure"]; ok && !isIntfNil(v) && !secureChoiceTypeFound {

								secureChoiceTypeFound = true

								if v.(bool) {
									secureChoiceInt := &ves_io_schema.SetCookieValueOption_IgnoreSecure{}
									secureChoiceInt.IgnoreSecure = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].SecureChoice = secureChoiceInt
								}

							}

							valueChoiceTypeFound := false

							if v, ok := responseCookiesToAddMapStrToI["ignore_value"]; ok && !isIntfNil(v) && !valueChoiceTypeFound {

								valueChoiceTypeFound = true

								if v.(bool) {
									valueChoiceInt := &ves_io_schema.SetCookieValueOption_IgnoreValue{}
									valueChoiceInt.IgnoreValue = &ves_io_schema.Empty{}
									responseCookiesToAdd[i].ValueChoice = valueChoiceInt
								}

							}

							if v, ok := responseCookiesToAddMapStrToI["secret_value"]; ok && !isIntfNil(v) && !valueChoiceTypeFound {

								valueChoiceTypeFound = true
								valueChoiceInt := &ves_io_schema.SetCookieValueOption_SecretValue{}
								valueChoiceInt.SecretValue = &ves_io_schema.SecretType{}
								responseCookiesToAdd[i].ValueChoice = valueChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
											valueChoiceInt.SecretValue.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
											for _, set := range sl {
												if set != nil {
													blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

													if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.Location = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.StoreProvider = w.(string)
													}

												}
											}

										}

										if v, ok := cs["secret_encoding_type"]; ok && !isIntfNil(v) {

											valueChoiceInt.SecretValue.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										secretInfoOneofTypeFound := false

										if v, ok := cs["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
											secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

													}

													if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

													}

												}
											}

										}

										if v, ok := cs["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
											secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["url"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

													}

												}
											}

										}

										if v, ok := cs["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
											secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["key"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

													}

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													if v, ok := cs["version"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

													}

												}
											}

										}

										if v, ok := cs["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
											secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if v, ok := responseCookiesToAddMapStrToI["value"]; ok && !isIntfNil(v) && !valueChoiceTypeFound {

								valueChoiceTypeFound = true
								valueChoiceInt := &ves_io_schema.SetCookieValueOption_Value{}

								responseCookiesToAdd[i].ValueChoice = valueChoiceInt

								valueChoiceInt.Value = v.(string)

							}

						}
					}

				}

				if w, ok := routesMapStrToI["response_cookies_to_remove"]; ok && !isIntfNil(w) {
					ls := make([]string, len(w.([]interface{})))
					for i, v := range w.([]interface{}) {
						if v == nil {
							return fmt.Errorf("please provide valid non-empty string value of field response_cookies_to_remove")
						}
						if str, ok := v.(string); ok {
							ls[i] = str
						}
					}
					routes[i].ResponseCookiesToRemove = ls
				}

				if v, ok := routesMapStrToI["response_headers_to_add"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					responseHeadersToAdd := make([]*ves_io_schema.HeaderManipulationOptionType, len(sl))
					routes[i].ResponseHeadersToAdd = responseHeadersToAdd
					for i, set := range sl {
						if set != nil {
							responseHeadersToAdd[i] = &ves_io_schema.HeaderManipulationOptionType{}
							responseHeadersToAddMapStrToI := set.(map[string]interface{})

							if w, ok := responseHeadersToAddMapStrToI["append"]; ok && !isIntfNil(w) {
								responseHeadersToAdd[i].Append = w.(bool)
							}

							if w, ok := responseHeadersToAddMapStrToI["name"]; ok && !isIntfNil(w) {
								responseHeadersToAdd[i].Name = w.(string)
							}

							valueChoiceTypeFound := false

							if v, ok := responseHeadersToAddMapStrToI["secret_value"]; ok && !isIntfNil(v) && !valueChoiceTypeFound {

								valueChoiceTypeFound = true
								valueChoiceInt := &ves_io_schema.HeaderManipulationOptionType_SecretValue{}
								valueChoiceInt.SecretValue = &ves_io_schema.SecretType{}
								responseHeadersToAdd[i].ValueChoice = valueChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
											valueChoiceInt.SecretValue.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
											for _, set := range sl {
												if set != nil {
													blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

													if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.Location = w.(string)
													}

													if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
														blindfoldSecretInfoInternal.StoreProvider = w.(string)
													}

												}
											}

										}

										if v, ok := cs["secret_encoding_type"]; ok && !isIntfNil(v) {

											valueChoiceInt.SecretValue.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										secretInfoOneofTypeFound := false

										if v, ok := cs["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
											secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

													}

													if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

													}

												}
											}

										}

										if v, ok := cs["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
											secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["url"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

													}

												}
											}

										}

										if v, ok := cs["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
											secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["key"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

													}

													if v, ok := cs["location"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

													}

													if v, ok := cs["provider"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

													}

													if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													if v, ok := cs["version"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

													}

												}
											}

										}

										if v, ok := cs["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

											secretInfoOneofTypeFound = true
											secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
											secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
											valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if v, ok := responseHeadersToAddMapStrToI["value"]; ok && !isIntfNil(v) && !valueChoiceTypeFound {

								valueChoiceTypeFound = true
								valueChoiceInt := &ves_io_schema.HeaderManipulationOptionType_Value{}

								responseHeadersToAdd[i].ValueChoice = valueChoiceInt

								valueChoiceInt.Value = v.(string)

							}

						}
					}

				}

				if w, ok := routesMapStrToI["response_headers_to_remove"]; ok && !isIntfNil(w) {
					ls := make([]string, len(w.([]interface{})))
					for i, v := range w.([]interface{}) {
						if v == nil {
							return fmt.Errorf("please provide valid non-empty string value of field response_headers_to_remove")
						}
						if str, ok := v.(string); ok {
							ls[i] = str
						}
					}
					routes[i].ResponseHeadersToRemove = ls
				}

				routeActionTypeFound := false

				if v, ok := routesMapStrToI["route_destination"]; ok && !isIntfNil(v) && !routeActionTypeFound {

					routeActionTypeFound = true
					routeActionInt := &ves_io_schema_route.RouteType_RouteDestination{}
					routeActionInt.RouteDestination = &ves_io_schema_route.RouteDestinationList{}
					routes[i].RouteAction = routeActionInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["buffer_policy"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								bufferPolicy := &ves_io_schema.BufferConfigType{}
								routeActionInt.RouteDestination.BufferPolicy = bufferPolicy
								for _, set := range sl {
									if set != nil {
										bufferPolicyMapStrToI := set.(map[string]interface{})

										if w, ok := bufferPolicyMapStrToI["disabled"]; ok && !isIntfNil(w) {
											bufferPolicy.Disabled = w.(bool)
										}

										if w, ok := bufferPolicyMapStrToI["max_request_bytes"]; ok && !isIntfNil(w) {
											bufferPolicy.MaxRequestBytes = uint32(w.(int))
										}

										if w, ok := bufferPolicyMapStrToI["max_request_time"]; ok && !isIntfNil(w) {
											bufferPolicy.MaxRequestTime = uint32(w.(int))
										}

									}
								}

							}

							clusterRetractChoiceTypeFound := false

							if v, ok := cs["do_not_retract_cluster"]; ok && !isIntfNil(v) && !clusterRetractChoiceTypeFound {

								clusterRetractChoiceTypeFound = true

								if v.(bool) {
									clusterRetractChoiceInt := &ves_io_schema_route.RouteDestinationList_DoNotRetractCluster{}
									clusterRetractChoiceInt.DoNotRetractCluster = &ves_io_schema.Empty{}
									routeActionInt.RouteDestination.ClusterRetractChoice = clusterRetractChoiceInt
								}

							}

							if v, ok := cs["retract_cluster"]; ok && !isIntfNil(v) && !clusterRetractChoiceTypeFound {

								clusterRetractChoiceTypeFound = true

								if v.(bool) {
									clusterRetractChoiceInt := &ves_io_schema_route.RouteDestinationList_RetractCluster{}
									clusterRetractChoiceInt.RetractCluster = &ves_io_schema.Empty{}
									routeActionInt.RouteDestination.ClusterRetractChoice = clusterRetractChoiceInt
								}

							}

							if v, ok := cs["cors_policy"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								corsPolicy := &ves_io_schema.CorsPolicy{}
								routeActionInt.RouteDestination.CorsPolicy = corsPolicy
								for _, set := range sl {
									if set != nil {
										corsPolicyMapStrToI := set.(map[string]interface{})

										if w, ok := corsPolicyMapStrToI["allow_credentials"]; ok && !isIntfNil(w) {
											corsPolicy.AllowCredentials = w.(bool)
										}

										if w, ok := corsPolicyMapStrToI["allow_headers"]; ok && !isIntfNil(w) {
											corsPolicy.AllowHeaders = w.(string)
										}

										if w, ok := corsPolicyMapStrToI["allow_methods"]; ok && !isIntfNil(w) {
											corsPolicy.AllowMethods = w.(string)
										}

										if w, ok := corsPolicyMapStrToI["allow_origin"]; ok && !isIntfNil(w) {
											ls := make([]string, len(w.([]interface{})))
											for i, v := range w.([]interface{}) {
												if v == nil {
													return fmt.Errorf("please provide valid non-empty string value of field allow_origin")
												}
												if str, ok := v.(string); ok {
													ls[i] = str
												}
											}
											corsPolicy.AllowOrigin = ls
										}

										if w, ok := corsPolicyMapStrToI["allow_origin_regex"]; ok && !isIntfNil(w) {
											ls := make([]string, len(w.([]interface{})))
											for i, v := range w.([]interface{}) {
												if v == nil {
													return fmt.Errorf("please provide valid non-empty string value of field allow_origin_regex")
												}
												if str, ok := v.(string); ok {
													ls[i] = str
												}
											}
											corsPolicy.AllowOriginRegex = ls
										}

										if w, ok := corsPolicyMapStrToI["disabled"]; ok && !isIntfNil(w) {
											corsPolicy.Disabled = w.(bool)
										}

										if w, ok := corsPolicyMapStrToI["expose_headers"]; ok && !isIntfNil(w) {
											corsPolicy.ExposeHeaders = w.(string)
										}

										if w, ok := corsPolicyMapStrToI["max_age"]; ok && !isIntfNil(w) {
											corsPolicy.MaxAge = w.(string)
										}

										if w, ok := corsPolicyMapStrToI["maximum_age"]; ok && !isIntfNil(w) {
											corsPolicy.MaximumAge = int32(w.(int))
										}

									}
								}

							}

							if v, ok := cs["csrf_policy"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								csrfPolicy := &ves_io_schema.CsrfPolicy{}
								routeActionInt.RouteDestination.CsrfPolicy = csrfPolicy
								for _, set := range sl {
									if set != nil {
										csrfPolicyMapStrToI := set.(map[string]interface{})

										allowedDomainsTypeFound := false

										if v, ok := csrfPolicyMapStrToI["all_load_balancer_domains"]; ok && !isIntfNil(v) && !allowedDomainsTypeFound {

											allowedDomainsTypeFound = true

											if v.(bool) {
												allowedDomainsInt := &ves_io_schema.CsrfPolicy_AllLoadBalancerDomains{}
												allowedDomainsInt.AllLoadBalancerDomains = &ves_io_schema.Empty{}
												csrfPolicy.AllowedDomains = allowedDomainsInt
											}

										}

										if v, ok := csrfPolicyMapStrToI["custom_domain_list"]; ok && !isIntfNil(v) && !allowedDomainsTypeFound {

											allowedDomainsTypeFound = true
											allowedDomainsInt := &ves_io_schema.CsrfPolicy_CustomDomainList{}
											allowedDomainsInt.CustomDomainList = &ves_io_schema.DomainNameList{}
											csrfPolicy.AllowedDomains = allowedDomainsInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["domains"]; ok && !isIntfNil(v) {

														ls := make([]string, len(v.([]interface{})))
														for i, v := range v.([]interface{}) {
															if v == nil {
																return fmt.Errorf("please provide valid non-empty string value of field domains")
															}
															if str, ok := v.(string); ok {
																ls[i] = str
															}
														}
														allowedDomainsInt.CustomDomainList.Domains = ls

													}

												}
											}

										}

										if v, ok := csrfPolicyMapStrToI["disabled"]; ok && !isIntfNil(v) && !allowedDomainsTypeFound {

											allowedDomainsTypeFound = true

											if v.(bool) {
												allowedDomainsInt := &ves_io_schema.CsrfPolicy_Disabled{}
												allowedDomainsInt.Disabled = &ves_io_schema.Empty{}
												csrfPolicy.AllowedDomains = allowedDomainsInt
											}

										}

									}
								}

							}

							if v, ok := cs["destinations"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								destinations := make([]*ves_io_schema_route.RouteDestination, len(sl))
								routeActionInt.RouteDestination.Destinations = destinations
								for i, set := range sl {
									if set != nil {
										destinations[i] = &ves_io_schema_route.RouteDestination{}
										destinationsMapStrToI := set.(map[string]interface{})

										if v, ok := destinationsMapStrToI["cluster"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											clusterInt := make([]*ves_io_schema.ObjectRefType, len(sl))
											destinations[i].Cluster = clusterInt
											for i, ps := range sl {
												if ps != nil {

													cMapToStrVal := ps.(map[string]interface{})
													clusterInt[i] = &ves_io_schema.ObjectRefType{}

													clusterInt[i].Kind = "cluster"

													if v, ok := cMapToStrVal["name"]; ok && !isIntfNil(v) {
														clusterInt[i].Name = v.(string)
													}

													if v, ok := cMapToStrVal["namespace"]; ok && !isIntfNil(v) {
														clusterInt[i].Namespace = v.(string)
													}

													if v, ok := cMapToStrVal["tenant"]; ok && !isIntfNil(v) {
														clusterInt[i].Tenant = v.(string)
													}

													if v, ok := cMapToStrVal["uid"]; ok && !isIntfNil(v) {
														clusterInt[i].Uid = v.(string)
													}

												}
											}

										}

										if w, ok := destinationsMapStrToI["endpoint_subsets"]; ok && !isIntfNil(w) {
											ms := map[string]string{}
											for k, v := range w.(map[string]interface{}) {
												ms[k] = v.(string)
											}
											destinations[i].EndpointSubsets = ms
										}

										if w, ok := destinationsMapStrToI["priority"]; ok && !isIntfNil(w) {
											destinations[i].Priority = uint32(w.(int))
										}

										if w, ok := destinationsMapStrToI["weight"]; ok && !isIntfNil(w) {
											destinations[i].Weight = uint32(w.(int))
										}

									}
								}

							}

							if v, ok := cs["endpoint_subsets"]; ok && !isIntfNil(v) {

								ms := map[string]string{}
								for k, v := range v.(map[string]interface{}) {
									ms[k] = v.(string)
								}
								routeActionInt.RouteDestination.EndpointSubsets = ms
							}

							if v, ok := cs["hash_policy"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								hashPolicy := make([]*ves_io_schema_route.HashPolicyType, len(sl))
								routeActionInt.RouteDestination.HashPolicy = hashPolicy
								for i, set := range sl {
									if set != nil {
										hashPolicy[i] = &ves_io_schema_route.HashPolicyType{}
										hashPolicyMapStrToI := set.(map[string]interface{})

										policySpecifierTypeFound := false

										if v, ok := hashPolicyMapStrToI["cookie"]; ok && !isIntfNil(v) && !policySpecifierTypeFound {

											policySpecifierTypeFound = true
											policySpecifierInt := &ves_io_schema_route.HashPolicyType_Cookie{}
											policySpecifierInt.Cookie = &ves_io_schema_route.CookieForHashing{}
											hashPolicy[i].PolicySpecifier = policySpecifierInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													httponlyTypeFound := false

													if v, ok := cs["add_httponly"]; ok && !isIntfNil(v) && !httponlyTypeFound {

														httponlyTypeFound = true

														if v.(bool) {
															httponlyInt := &ves_io_schema_route.CookieForHashing_AddHttponly{}
															httponlyInt.AddHttponly = &ves_io_schema.Empty{}
															policySpecifierInt.Cookie.Httponly = httponlyInt
														}

													}

													if v, ok := cs["ignore_httponly"]; ok && !isIntfNil(v) && !httponlyTypeFound {

														httponlyTypeFound = true

														if v.(bool) {
															httponlyInt := &ves_io_schema_route.CookieForHashing_IgnoreHttponly{}
															httponlyInt.IgnoreHttponly = &ves_io_schema.Empty{}
															policySpecifierInt.Cookie.Httponly = httponlyInt
														}

													}

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														policySpecifierInt.Cookie.Name = v.(string)

													}

													if v, ok := cs["path"]; ok && !isIntfNil(v) {

														policySpecifierInt.Cookie.Path = v.(string)

													}

													samesiteTypeFound := false

													if v, ok := cs["ignore_samesite"]; ok && !isIntfNil(v) && !samesiteTypeFound {

														samesiteTypeFound = true

														if v.(bool) {
															samesiteInt := &ves_io_schema_route.CookieForHashing_IgnoreSamesite{}
															samesiteInt.IgnoreSamesite = &ves_io_schema.Empty{}
															policySpecifierInt.Cookie.Samesite = samesiteInt
														}

													}

													if v, ok := cs["samesite_lax"]; ok && !isIntfNil(v) && !samesiteTypeFound {

														samesiteTypeFound = true

														if v.(bool) {
															samesiteInt := &ves_io_schema_route.CookieForHashing_SamesiteLax{}
															samesiteInt.SamesiteLax = &ves_io_schema.Empty{}
															policySpecifierInt.Cookie.Samesite = samesiteInt
														}

													}

													if v, ok := cs["samesite_none"]; ok && !isIntfNil(v) && !samesiteTypeFound {

														samesiteTypeFound = true

														if v.(bool) {
															samesiteInt := &ves_io_schema_route.CookieForHashing_SamesiteNone{}
															samesiteInt.SamesiteNone = &ves_io_schema.Empty{}
															policySpecifierInt.Cookie.Samesite = samesiteInt
														}

													}

													if v, ok := cs["samesite_strict"]; ok && !isIntfNil(v) && !samesiteTypeFound {

														samesiteTypeFound = true

														if v.(bool) {
															samesiteInt := &ves_io_schema_route.CookieForHashing_SamesiteStrict{}
															samesiteInt.SamesiteStrict = &ves_io_schema.Empty{}
															policySpecifierInt.Cookie.Samesite = samesiteInt
														}

													}

													secureTypeFound := false

													if v, ok := cs["add_secure"]; ok && !isIntfNil(v) && !secureTypeFound {

														secureTypeFound = true

														if v.(bool) {
															secureInt := &ves_io_schema_route.CookieForHashing_AddSecure{}
															secureInt.AddSecure = &ves_io_schema.Empty{}
															policySpecifierInt.Cookie.Secure = secureInt
														}

													}

													if v, ok := cs["ignore_secure"]; ok && !isIntfNil(v) && !secureTypeFound {

														secureTypeFound = true

														if v.(bool) {
															secureInt := &ves_io_schema_route.CookieForHashing_IgnoreSecure{}
															secureInt.IgnoreSecure = &ves_io_schema.Empty{}
															policySpecifierInt.Cookie.Secure = secureInt
														}

													}

													if v, ok := cs["ttl"]; ok && !isIntfNil(v) {

														policySpecifierInt.Cookie.Ttl = uint32(v.(int))

													}

												}
											}

										}

										if v, ok := hashPolicyMapStrToI["header_name"]; ok && !isIntfNil(v) && !policySpecifierTypeFound {

											policySpecifierTypeFound = true
											policySpecifierInt := &ves_io_schema_route.HashPolicyType_HeaderName{}

											hashPolicy[i].PolicySpecifier = policySpecifierInt

											policySpecifierInt.HeaderName = v.(string)

										}

										if v, ok := hashPolicyMapStrToI["source_ip"]; ok && !isIntfNil(v) && !policySpecifierTypeFound {

											policySpecifierTypeFound = true
											policySpecifierInt := &ves_io_schema_route.HashPolicyType_SourceIp{}

											hashPolicy[i].PolicySpecifier = policySpecifierInt

											policySpecifierInt.SourceIp = v.(bool)

										}

										if w, ok := hashPolicyMapStrToI["terminal"]; ok && !isIntfNil(w) {
											hashPolicy[i].Terminal = w.(bool)
										}

									}
								}

							}

							hostRewriteParamsTypeFound := false

							if v, ok := cs["auto_host_rewrite"]; ok && !isIntfNil(v) && !hostRewriteParamsTypeFound {

								hostRewriteParamsTypeFound = true
								hostRewriteParamsInt := &ves_io_schema_route.RouteDestinationList_AutoHostRewrite{}

								routeActionInt.RouteDestination.HostRewriteParams = hostRewriteParamsInt

								hostRewriteParamsInt.AutoHostRewrite = v.(bool)

							}

							if v, ok := cs["host_rewrite"]; ok && !isIntfNil(v) && !hostRewriteParamsTypeFound {

								hostRewriteParamsTypeFound = true
								hostRewriteParamsInt := &ves_io_schema_route.RouteDestinationList_HostRewrite{}

								routeActionInt.RouteDestination.HostRewriteParams = hostRewriteParamsInt

								hostRewriteParamsInt.HostRewrite = v.(string)

							}

							if v, ok := cs["mirror_policy"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								mirrorPolicy := &ves_io_schema_route.MirrorPolicyType{}
								routeActionInt.RouteDestination.MirrorPolicy = mirrorPolicy
								for _, set := range sl {
									if set != nil {
										mirrorPolicyMapStrToI := set.(map[string]interface{})

										if v, ok := mirrorPolicyMapStrToI["cluster"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											clusterInt := make([]*ves_io_schema.ObjectRefType, len(sl))
											mirrorPolicy.Cluster = clusterInt
											for i, ps := range sl {
												if ps != nil {

													cMapToStrVal := ps.(map[string]interface{})
													clusterInt[i] = &ves_io_schema.ObjectRefType{}

													clusterInt[i].Kind = "cluster"

													if v, ok := cMapToStrVal["name"]; ok && !isIntfNil(v) {
														clusterInt[i].Name = v.(string)
													}

													if v, ok := cMapToStrVal["namespace"]; ok && !isIntfNil(v) {
														clusterInt[i].Namespace = v.(string)
													}

													if v, ok := cMapToStrVal["tenant"]; ok && !isIntfNil(v) {
														clusterInt[i].Tenant = v.(string)
													}

													if v, ok := cMapToStrVal["uid"]; ok && !isIntfNil(v) {
														clusterInt[i].Uid = v.(string)
													}

												}
											}

										}

										if v, ok := mirrorPolicyMapStrToI["percent"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											percent := &ves_io_schema.FractionalPercent{}
											mirrorPolicy.Percent = percent
											for _, set := range sl {
												if set != nil {
													percentMapStrToI := set.(map[string]interface{})

													if v, ok := percentMapStrToI["denominator"]; ok && !isIntfNil(v) {

														percent.Denominator = ves_io_schema.DenominatorType(ves_io_schema.DenominatorType_value[v.(string)])

													}

													if w, ok := percentMapStrToI["numerator"]; ok && !isIntfNil(w) {
														percent.Numerator = uint32(w.(int))
													}

												}
											}

										}

									}
								}

							}

							if v, ok := cs["priority"]; ok && !isIntfNil(v) {

								routeActionInt.RouteDestination.Priority = ves_io_schema.RoutingPriority(ves_io_schema.RoutingPriority_value[v.(string)])

							}

							if v, ok := cs["query_params"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								queryParams := &ves_io_schema_route.QueryParamsSimpleRoute{}
								routeActionInt.RouteDestination.QueryParams = queryParams
								for _, set := range sl {
									if set != nil {
										queryParamsMapStrToI := set.(map[string]interface{})

										queryParamsTypeFound := false

										if v, ok := queryParamsMapStrToI["remove_all_params"]; ok && !isIntfNil(v) && !queryParamsTypeFound {

											queryParamsTypeFound = true

											if v.(bool) {
												queryParamsInt := &ves_io_schema_route.QueryParamsSimpleRoute_RemoveAllParams{}
												queryParamsInt.RemoveAllParams = &ves_io_schema.Empty{}
												queryParams.QueryParams = queryParamsInt
											}

										}

										if v, ok := queryParamsMapStrToI["replace_params"]; ok && !isIntfNil(v) && !queryParamsTypeFound {

											queryParamsTypeFound = true
											queryParamsInt := &ves_io_schema_route.QueryParamsSimpleRoute_ReplaceParams{}

											queryParams.QueryParams = queryParamsInt

											queryParamsInt.ReplaceParams = v.(string)

										}

										if v, ok := queryParamsMapStrToI["retain_all_params"]; ok && !isIntfNil(v) && !queryParamsTypeFound {

											queryParamsTypeFound = true

											if v.(bool) {
												queryParamsInt := &ves_io_schema_route.QueryParamsSimpleRoute_RetainAllParams{}
												queryParamsInt.RetainAllParams = &ves_io_schema.Empty{}
												queryParams.QueryParams = queryParamsInt
											}

										}

									}
								}

							}

							if v, ok := cs["retry_policy"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								retryPolicy := &ves_io_schema.RetryPolicyType{}
								routeActionInt.RouteDestination.RetryPolicy = retryPolicy
								for _, set := range sl {
									if set != nil {
										retryPolicyMapStrToI := set.(map[string]interface{})

										if v, ok := retryPolicyMapStrToI["back_off"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											backOff := &ves_io_schema.RetryBackOff{}
											retryPolicy.BackOff = backOff
											for _, set := range sl {
												if set != nil {
													backOffMapStrToI := set.(map[string]interface{})

													if w, ok := backOffMapStrToI["base_interval"]; ok && !isIntfNil(w) {
														backOff.BaseInterval = uint32(w.(int))
													}

													if w, ok := backOffMapStrToI["max_interval"]; ok && !isIntfNil(w) {
														backOff.MaxInterval = uint32(w.(int))
													}

												}
											}

										}

										if w, ok := retryPolicyMapStrToI["num_retries"]; ok && !isIntfNil(w) {
											retryPolicy.NumRetries = uint32(w.(int))
										}

										if w, ok := retryPolicyMapStrToI["per_try_timeout"]; ok && !isIntfNil(w) {
											retryPolicy.PerTryTimeout = uint32(w.(int))
										}

										if w, ok := retryPolicyMapStrToI["retriable_status_codes"]; ok && !isIntfNil(w) {
											ls := make([]uint32, len(w.([]interface{})))
											for i, v := range w.([]interface{}) {
												ls[i] = uint32(v.(int))
											}
											retryPolicy.RetriableStatusCodes = ls
										}

										if w, ok := retryPolicyMapStrToI["retry_condition"]; ok && !isIntfNil(w) {
											ls := make([]string, len(w.([]interface{})))
											for i, v := range w.([]interface{}) {
												if v == nil {
													return fmt.Errorf("please provide valid non-empty string value of field retry_condition")
												}
												if str, ok := v.(string); ok {
													ls[i] = str
												}
											}
											retryPolicy.RetryCondition = ls
										}

										if w, ok := retryPolicyMapStrToI["retry_on"]; ok && !isIntfNil(w) {
											retryPolicy.RetryOn = w.(string)
										}

									}
								}

							}

							routeDestinationRewriteTypeFound := false

							if v, ok := cs["prefix_rewrite"]; ok && !isIntfNil(v) && !routeDestinationRewriteTypeFound {

								routeDestinationRewriteTypeFound = true
								routeDestinationRewriteInt := &ves_io_schema_route.RouteDestinationList_PrefixRewrite{}

								routeActionInt.RouteDestination.RouteDestinationRewrite = routeDestinationRewriteInt

								routeDestinationRewriteInt.PrefixRewrite = v.(string)

							}

							if v, ok := cs["regex_rewrite"]; ok && !isIntfNil(v) && !routeDestinationRewriteTypeFound {

								routeDestinationRewriteTypeFound = true
								routeDestinationRewriteInt := &ves_io_schema_route.RouteDestinationList_RegexRewrite{}
								routeDestinationRewriteInt.RegexRewrite = &ves_io_schema.RegexMatchRewrite{}
								routeActionInt.RouteDestination.RouteDestinationRewrite = routeDestinationRewriteInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["pattern"]; ok && !isIntfNil(v) {

											routeDestinationRewriteInt.RegexRewrite.Pattern = v.(string)

										}

										if v, ok := cs["substitution"]; ok && !isIntfNil(v) {

											routeDestinationRewriteInt.RegexRewrite.Substitution = v.(string)

										}

									}
								}

							}

							if v, ok := cs["spdy_config"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								spdyConfig := &ves_io_schema_route.SpdyConfigType{}
								routeActionInt.RouteDestination.SpdyConfig = spdyConfig
								for _, set := range sl {
									if set != nil {
										spdyConfigMapStrToI := set.(map[string]interface{})

										if w, ok := spdyConfigMapStrToI["use_spdy"]; ok && !isIntfNil(w) {
											spdyConfig.UseSpdy = w.(bool)
										}

									}
								}

							}

							if v, ok := cs["timeout"]; ok && !isIntfNil(v) {

								routeActionInt.RouteDestination.Timeout = uint32(v.(int))

							}

							if v, ok := cs["web_socket_config"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								webSocketConfig := &ves_io_schema_route.WebsocketConfigType{}
								routeActionInt.RouteDestination.WebSocketConfig = webSocketConfig
								for _, set := range sl {
									if set != nil {
										webSocketConfigMapStrToI := set.(map[string]interface{})

										if w, ok := webSocketConfigMapStrToI["use_websocket"]; ok && !isIntfNil(w) {
											webSocketConfig.UseWebsocket = w.(bool)
										}

									}
								}

							}

						}
					}

				}

				if v, ok := routesMapStrToI["route_direct_response"]; ok && !isIntfNil(v) && !routeActionTypeFound {

					routeActionTypeFound = true
					routeActionInt := &ves_io_schema_route.RouteType_RouteDirectResponse{}
					routeActionInt.RouteDirectResponse = &ves_io_schema_route.RouteDirectResponse{}
					routes[i].RouteAction = routeActionInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["response_body"]; ok && !isIntfNil(v) {

								routeActionInt.RouteDirectResponse.ResponseBody = v.(string)

							}

							if v, ok := cs["response_body_encoded"]; ok && !isIntfNil(v) {

								routeActionInt.RouteDirectResponse.ResponseBodyEncoded = v.(string)

							}

							if v, ok := cs["response_code"]; ok && !isIntfNil(v) {

								routeActionInt.RouteDirectResponse.ResponseCode = uint32(v.(int))

							}

						}
					}

				}

				if v, ok := routesMapStrToI["route_redirect"]; ok && !isIntfNil(v) && !routeActionTypeFound {

					routeActionTypeFound = true
					routeActionInt := &ves_io_schema_route.RouteType_RouteRedirect{}
					routeActionInt.RouteRedirect = &ves_io_schema_route.RouteRedirect{}
					routes[i].RouteAction = routeActionInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["host_redirect"]; ok && !isIntfNil(v) {

								routeActionInt.RouteRedirect.HostRedirect = v.(string)

							}

							if v, ok := cs["port_redirect"]; ok && !isIntfNil(v) {

								routeActionInt.RouteRedirect.PortRedirect = uint32(v.(int))

							}

							if v, ok := cs["proto_redirect"]; ok && !isIntfNil(v) {

								routeActionInt.RouteRedirect.ProtoRedirect = v.(string)

							}

							queryParamsTypeFound := false

							if v, ok := cs["all_params"]; ok && !isIntfNil(v) && !queryParamsTypeFound {

								queryParamsTypeFound = true
								queryParamsInt := &ves_io_schema_route.RouteRedirect_AllParams{}

								routeActionInt.RouteRedirect.QueryParams = queryParamsInt

								queryParamsInt.AllParams = v.(bool)

							}

							if v, ok := cs["remove_all_params"]; ok && !isIntfNil(v) && !queryParamsTypeFound {

								queryParamsTypeFound = true

								if v.(bool) {
									queryParamsInt := &ves_io_schema_route.RouteRedirect_RemoveAllParams{}
									queryParamsInt.RemoveAllParams = &ves_io_schema.Empty{}
									routeActionInt.RouteRedirect.QueryParams = queryParamsInt
								}

							}

							if v, ok := cs["replace_params"]; ok && !isIntfNil(v) && !queryParamsTypeFound {

								queryParamsTypeFound = true
								queryParamsInt := &ves_io_schema_route.RouteRedirect_ReplaceParams{}

								routeActionInt.RouteRedirect.QueryParams = queryParamsInt

								queryParamsInt.ReplaceParams = v.(string)

							}

							if v, ok := cs["retain_all_params"]; ok && !isIntfNil(v) && !queryParamsTypeFound {

								queryParamsTypeFound = true

								if v.(bool) {
									queryParamsInt := &ves_io_schema_route.RouteRedirect_RetainAllParams{}
									queryParamsInt.RetainAllParams = &ves_io_schema.Empty{}
									routeActionInt.RouteRedirect.QueryParams = queryParamsInt
								}

							}

							if v, ok := cs["strip_query_params"]; ok && !isIntfNil(v) && !queryParamsTypeFound {

								queryParamsTypeFound = true
								queryParamsInt := &ves_io_schema_route.RouteRedirect_StripQueryParams{}
								queryParamsInt.StripQueryParams = &ves_io_schema_route.RouteQueryParams{}
								routeActionInt.RouteRedirect.QueryParams = queryParamsInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["query_params"]; ok && !isIntfNil(v) {

											ls := make([]string, len(v.([]interface{})))
											for i, v := range v.([]interface{}) {
												if v == nil {
													return fmt.Errorf("please provide valid non-empty string value of field query_params")
												}
												if str, ok := v.(string); ok {
													ls[i] = str
												}
											}
											queryParamsInt.StripQueryParams.QueryParams = ls

										}

									}
								}

							}

							redirectPathChoiceTypeFound := false

							if v, ok := cs["path_redirect"]; ok && !isIntfNil(v) && !redirectPathChoiceTypeFound {

								redirectPathChoiceTypeFound = true
								redirectPathChoiceInt := &ves_io_schema_route.RouteRedirect_PathRedirect{}

								routeActionInt.RouteRedirect.RedirectPathChoice = redirectPathChoiceInt

								redirectPathChoiceInt.PathRedirect = v.(string)

							}

							if v, ok := cs["prefix_rewrite"]; ok && !isIntfNil(v) && !redirectPathChoiceTypeFound {

								redirectPathChoiceTypeFound = true
								redirectPathChoiceInt := &ves_io_schema_route.RouteRedirect_PrefixRewrite{}

								routeActionInt.RouteRedirect.RedirectPathChoice = redirectPathChoiceInt

								redirectPathChoiceInt.PrefixRewrite = v.(string)

							}

							if v, ok := cs["response_code"]; ok && !isIntfNil(v) {

								routeActionInt.RouteRedirect.ResponseCode = uint32(v.(int))

							}

						}
					}

				}

				if v, ok := routesMapStrToI["service_policy"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					servicePolicy := &ves_io_schema_route.ServicePolicyInfo{}
					routes[i].ServicePolicy = servicePolicy
					for _, set := range sl {
						if set != nil {
							servicePolicyMapStrToI := set.(map[string]interface{})

							servicePolicyChoiceTypeFound := false

							if v, ok := servicePolicyMapStrToI["context_extensions"]; ok && !isIntfNil(v) && !servicePolicyChoiceTypeFound {

								servicePolicyChoiceTypeFound = true
								servicePolicyChoiceInt := &ves_io_schema_route.ServicePolicyInfo_ContextExtensions{}
								servicePolicyChoiceInt.ContextExtensions = &ves_io_schema_route.ContextExtensionInfo{}
								servicePolicy.ServicePolicyChoice = servicePolicyChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["context_extensions"]; ok && !isIntfNil(v) {

											ms := map[string]string{}
											for k, v := range v.(map[string]interface{}) {
												ms[k] = v.(string)
											}
											servicePolicyChoiceInt.ContextExtensions.ContextExtensions = ms
										}

									}
								}

							}

							if v, ok := servicePolicyMapStrToI["disable"]; ok && !isIntfNil(v) && !servicePolicyChoiceTypeFound {

								servicePolicyChoiceTypeFound = true
								servicePolicyChoiceInt := &ves_io_schema_route.ServicePolicyInfo_Disable{}

								servicePolicy.ServicePolicyChoice = servicePolicyChoiceInt

								servicePolicyChoiceInt.Disable = v.(bool)

							}

						}
					}

				}

				if w, ok := routesMapStrToI["skip_lb_override"]; ok && !isIntfNil(w) {
					routes[i].SkipLbOverride = w.(bool)
				}

				if w, ok := routesMapStrToI["uuid"]; ok && !isIntfNil(w) {
					routes[i].Uuid = w.(string)
				}

				wafExclusionChoiceTypeFound := false

				if v, ok := routesMapStrToI["inherited_waf_exclusion"]; ok && !isIntfNil(v) && !wafExclusionChoiceTypeFound {

					wafExclusionChoiceTypeFound = true

					if v.(bool) {
						wafExclusionChoiceInt := &ves_io_schema_route.RouteType_InheritedWafExclusion{}
						wafExclusionChoiceInt.InheritedWafExclusion = &ves_io_schema.Empty{}
						routes[i].WafExclusionChoice = wafExclusionChoiceInt
					}

				}

				if v, ok := routesMapStrToI["waf_exclusion_policy"]; ok && !isIntfNil(v) && !wafExclusionChoiceTypeFound {

					wafExclusionChoiceTypeFound = true
					wafExclusionChoiceInt := &ves_io_schema_route.RouteType_WafExclusionPolicy{}
					wafExclusionChoiceInt.WafExclusionPolicy = &ves_io_schema_views.ObjectRefType{}
					routes[i].WafExclusionChoice = wafExclusionChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								wafExclusionChoiceInt.WafExclusionPolicy.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								wafExclusionChoiceInt.WafExclusionPolicy.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								wafExclusionChoiceInt.WafExclusionPolicy.Tenant = v.(string)

							}

						}
					}

				}

				if v, ok := routesMapStrToI["waf_exclusion_service_policy"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					wafExclusionServicePolicyInt := make([]*ves_io_schema.ObjectRefType, len(sl))
					routes[i].WafExclusionServicePolicy = wafExclusionServicePolicyInt
					for i, ps := range sl {
						if ps != nil {

							wespMapToStrVal := ps.(map[string]interface{})
							wafExclusionServicePolicyInt[i] = &ves_io_schema.ObjectRefType{}

							wafExclusionServicePolicyInt[i].Kind = "service_policy"

							if v, ok := wespMapToStrVal["name"]; ok && !isIntfNil(v) {
								wafExclusionServicePolicyInt[i].Name = v.(string)
							}

							if v, ok := wespMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								wafExclusionServicePolicyInt[i].Namespace = v.(string)
							}

							if v, ok := wespMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								wafExclusionServicePolicyInt[i].Tenant = v.(string)
							}

							if v, ok := wespMapToStrVal["uid"]; ok && !isIntfNil(v) {
								wafExclusionServicePolicyInt[i].Uid = v.(string)
							}

						}
					}

				}

				if v, ok := routesMapStrToI["waf_type"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					wafType := &ves_io_schema.WafType{}
					routes[i].WafType = wafType
					for _, set := range sl {
						if set != nil {
							wafTypeMapStrToI := set.(map[string]interface{})

							refTypeTypeFound := false

							if v, ok := wafTypeMapStrToI["app_firewall"]; ok && !isIntfNil(v) && !refTypeTypeFound {

								refTypeTypeFound = true
								refTypeInt := &ves_io_schema.WafType_AppFirewall{}
								refTypeInt.AppFirewall = &ves_io_schema.AppFirewallRefType{}
								wafType.RefType = refTypeInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["app_firewall"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											appFirewallInt := make([]*ves_io_schema.ObjectRefType, len(sl))
											refTypeInt.AppFirewall.AppFirewall = appFirewallInt
											for i, ps := range sl {
												if ps != nil {

													afMapToStrVal := ps.(map[string]interface{})
													appFirewallInt[i] = &ves_io_schema.ObjectRefType{}

													appFirewallInt[i].Kind = "app_firewall"

													if v, ok := afMapToStrVal["name"]; ok && !isIntfNil(v) {
														appFirewallInt[i].Name = v.(string)
													}

													if v, ok := afMapToStrVal["namespace"]; ok && !isIntfNil(v) {
														appFirewallInt[i].Namespace = v.(string)
													}

													if v, ok := afMapToStrVal["tenant"]; ok && !isIntfNil(v) {
														appFirewallInt[i].Tenant = v.(string)
													}

													if v, ok := afMapToStrVal["uid"]; ok && !isIntfNil(v) {
														appFirewallInt[i].Uid = v.(string)
													}

												}
											}

										}

									}
								}

							}

							if v, ok := wafTypeMapStrToI["disable_waf"]; ok && !isIntfNil(v) && !refTypeTypeFound {

								refTypeTypeFound = true

								if v.(bool) {
									refTypeInt := &ves_io_schema.WafType_DisableWaf{}
									refTypeInt.DisableWaf = &ves_io_schema.Empty{}
									wafType.RefType = refTypeInt
								}

							}

							if v, ok := wafTypeMapStrToI["inherit_waf"]; ok && !isIntfNil(v) && !refTypeTypeFound {

								refTypeTypeFound = true

								if v.(bool) {
									refTypeInt := &ves_io_schema.WafType_InheritWaf{}
									refTypeInt.InheritWaf = &ves_io_schema.Empty{}
									wafType.RefType = refTypeInt
								}

							}

						}
					}

				}

			}
		}

	}

	log.Printf("[DEBUG] Updating Volterra Route obj with struct: %+v", updateReq)

	err := client.ReplaceObject(context.Background(), ves_io_schema_route.ObjectType, updateReq)
	if err != nil {
		return fmt.Errorf("error updating Route: %s", err)
	}

	return resourceVolterraRouteRead(d, meta)
}

func resourceVolterraRouteDelete(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	_, err := client.GetObject(context.Background(), ves_io_schema_route.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] Route %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra Route before deleting %q: %s", d.Id(), err)
	}

	log.Printf("[DEBUG] Deleting Volterra Route obj with name %+v in namespace %+v", name, namespace)
	opts := []vesapi.CallOpt{
		vesapi.WithFailIfReferred(),
	}
	return client.DeleteObject(context.Background(), ves_io_schema_route.ObjectType, namespace, name, opts...)
}
