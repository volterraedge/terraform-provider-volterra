//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-tf-provider. DO NOT EDIT.
//

package volterra

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"gopkg.volterra.us/stdlib/client/vesapi"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_app_firewall "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/app_firewall"
	ves_io_schema_policy "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/policy"
	ves_io_schema_service_policy_rule "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/service_policy_rule"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
)

// resourceVolterraServicePolicyRule is implementation of Volterra's ServicePolicyRule resources
func resourceVolterraServicePolicyRule() *schema.Resource {
	return &schema.Resource{
		Create: resourceVolterraServicePolicyRuleCreate,
		Read:   resourceVolterraServicePolicyRuleRead,
		Update: resourceVolterraServicePolicyRuleUpdate,
		Delete: resourceVolterraServicePolicyRuleDelete,

		Schema: map[string]*schema.Schema{

			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"description": {
				Type:     schema.TypeString,
				Optional: true,
			},

			"disable": {
				Type:     schema.TypeBool,
				Optional: true,
			},

			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"namespace": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"action": {
				Type:     schema.TypeString,
				Required: true,
			},

			"api_group_matcher": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"invert_matcher": {
							Type:     schema.TypeBool,
							Optional: true,
						},

						"match": {

							Type: schema.TypeList,

							Required: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},

			"arg_matchers": {

				Type:     schema.TypeList,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"invert_matcher": {
							Type:     schema.TypeBool,
							Optional: true,
						},

						"check_not_present": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"check_present": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"item": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"exact_values": {

										Type: schema.TypeList,

										Optional: true,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},

									"regex_values": {

										Type: schema.TypeList,

										Optional: true,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},

									"transformers": {

										Type: schema.TypeList,

										Optional: true,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},

						"presence": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"name": {
							Type:     schema.TypeString,
							Required: true,
						},
					},
				},
			},

			"any_asn": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"asn_list": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"as_numbers": {

							Type: schema.TypeList,

							Required: true,
							Elem: &schema.Schema{
								Type: schema.TypeInt,
							},
						},
					},
				},
			},

			"asn_matcher": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"asn_sets": {

							Type:     schema.TypeList,
							Required: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"kind": {
										Type:     schema.TypeString,
										Computed: true,
									},

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"body_matcher": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"exact_values": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},

						"regex_values": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},

						"transformers": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},

			"bot_action": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"bot_skip_processing": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"none": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"challenge_action": {
				Type:       schema.TypeString,
				Required:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
			},

			"any_client": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"client_name": {

				Type:     schema.TypeString,
				Optional: true,
			},

			"client_name_matcher": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"exact_values": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},

						"regex_values": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},

			"client_selector": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"expressions": {

							Type: schema.TypeList,

							Required: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},

			"ip_threat_category_list": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"ip_threat_categories": {

							Type: schema.TypeList,

							Required: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},

			"client_role": {

				Type:       schema.TypeSet,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"match": {
							Type:       schema.TypeString,
							Required:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},
					},
				},
			},

			"content_rewrite_action": {

				Type:       schema.TypeSet,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"element_selector": {
							Type:       schema.TypeString,
							Required:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"insert_content": {
							Type:       schema.TypeString,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"inserted_types": {
							Type:       schema.TypeMap,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"position": {
							Type:       schema.TypeString,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},
					},
				},
			},

			"cookie_matchers": {

				Type:     schema.TypeList,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"invert_matcher": {
							Type:     schema.TypeBool,
							Optional: true,
						},

						"check_not_present": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"check_present": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"item": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"exact_values": {

										Type: schema.TypeList,

										Optional: true,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},

									"regex_values": {

										Type: schema.TypeList,

										Optional: true,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},

									"transformers": {

										Type: schema.TypeList,

										Optional: true,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},

						"presence": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"name": {
							Type:     schema.TypeString,
							Required: true,
						},
					},
				},
			},

			"domain_matcher": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"exact_values": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},

						"regex_values": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},

			"any_dst_asn": {

				Type:       schema.TypeBool,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
			},

			"dst_asn_list": {

				Type:       schema.TypeSet,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"as_numbers": {

							Type: schema.TypeList,

							Required:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Schema{
								Type: schema.TypeInt,
							},
						},
					},
				},
			},

			"dst_asn_matcher": {

				Type:       schema.TypeSet,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"asn_sets": {

							Type:       schema.TypeList,
							Required:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"kind": {
										Type:       schema.TypeString,
										Computed:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"name": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
									"namespace": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
									"tenant": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
								},
							},
						},
					},
				},
			},

			"any_dst_ip": {

				Type:       schema.TypeBool,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
			},

			"dst_ip_matcher": {

				Type:       schema.TypeSet,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"invert_matcher": {
							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"prefix_sets": {

							Type:       schema.TypeList,
							Required:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"kind": {
										Type:       schema.TypeString,
										Computed:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"name": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
									"namespace": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
									"tenant": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
								},
							},
						},
					},
				},
			},

			"dst_ip_prefix_list": {

				Type:       schema.TypeSet,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"invert_match": {
							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"ip_prefixes": {

							Type: schema.TypeList,

							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},

						"ipv6_prefixes": {

							Type: schema.TypeList,

							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},

			"expiration_timestamp": {
				Type:     schema.TypeString,
				Optional: true,
			},

			"goto_policy": {

				Type:       schema.TypeList,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"kind": {
							Type:       schema.TypeString,
							Computed:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"name": {
							Type:       schema.TypeString,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},
						"namespace": {
							Type:       schema.TypeString,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},
						"tenant": {
							Type:       schema.TypeString,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},
					},
				},
			},

			"headers": {

				Type:     schema.TypeList,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"invert_matcher": {
							Type:     schema.TypeBool,
							Optional: true,
						},

						"check_not_present": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"check_present": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"item": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"exact_values": {

										Type: schema.TypeList,

										Optional: true,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},

									"regex_values": {

										Type: schema.TypeList,

										Optional: true,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},

									"transformers": {

										Type: schema.TypeList,

										Optional: true,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},

						"presence": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"name": {
							Type:     schema.TypeString,
							Required: true,
						},
					},
				},
			},

			"http_method": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"invert_matcher": {
							Type:     schema.TypeBool,
							Optional: true,
						},

						"methods": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},

			"any_ip": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"ip_matcher": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"invert_matcher": {
							Type:     schema.TypeBool,
							Optional: true,
						},

						"prefix_sets": {

							Type:     schema.TypeList,
							Required: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"kind": {
										Type:     schema.TypeString,
										Computed: true,
									},

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"ip_prefix_list": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"invert_match": {
							Type:     schema.TypeBool,
							Optional: true,
						},

						"ip_prefixes": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},

						"ipv6_prefixes": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},

			"ip_reputation_action": {

				Type:       schema.TypeSet,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"default": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"skip_processing": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},
					},
				},
			},

			"jwt_claims": {

				Type:     schema.TypeList,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"invert_matcher": {
							Type:     schema.TypeBool,
							Optional: true,
						},

						"check_not_present": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"check_present": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"item": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"exact_values": {

										Type: schema.TypeList,

										Optional: true,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},

									"regex_values": {

										Type: schema.TypeList,

										Optional: true,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},

									"transformers": {

										Type: schema.TypeList,

										Optional: true,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},

						"name": {
							Type:     schema.TypeString,
							Required: true,
						},
					},
				},
			},

			"l4_dest_matcher": {

				Type:       schema.TypeSet,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"invert_matcher": {
							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"l4_dests": {

							Type:       schema.TypeList,
							Required:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"port_ranges": {
										Type:       schema.TypeString,
										Required:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"prefixes": {

										Type: schema.TypeList,

										Required:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
					},
				},
			},

			"label_matcher": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"keys": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},

			"mum_action": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"default": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"skip_processing": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"origin_server_subsets_action": {
				Type:       schema.TypeMap,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
			},

			"path": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"exact_values": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},

						"invert_matcher": {
							Type:     schema.TypeBool,
							Optional: true,
						},

						"prefix_values": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},

						"regex_values": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},

						"suffix_values": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},

						"transformers": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},

			"port_matcher": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"invert_matcher": {
							Type:     schema.TypeBool,
							Optional: true,
						},

						"ports": {

							Type: schema.TypeList,

							Required: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},

			"query_params": {

				Type:     schema.TypeList,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"invert_matcher": {
							Type:     schema.TypeBool,
							Optional: true,
						},

						"key": {
							Type:     schema.TypeString,
							Required: true,
						},

						"check_not_present": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"check_present": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"item": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"exact_values": {

										Type: schema.TypeList,

										Optional: true,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},

									"regex_values": {

										Type: schema.TypeList,

										Optional: true,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},

									"transformers": {

										Type: schema.TypeList,

										Optional: true,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},

						"presence": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},
					},
				},
			},

			"rate_limiter": {

				Type:       schema.TypeList,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"kind": {
							Type:       schema.TypeString,
							Computed:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"name": {
							Type:       schema.TypeString,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},
						"namespace": {
							Type:       schema.TypeString,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},
						"tenant": {
							Type:       schema.TypeString,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},
					},
				},
			},

			"request_constraints": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"max_cookie_count_exceeds": {

							Type:     schema.TypeInt,
							Optional: true,
						},

						"max_cookie_count_none": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"max_cookie_key_size_exceeds": {

							Type:     schema.TypeInt,
							Optional: true,
						},

						"max_cookie_key_size_none": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"max_cookie_value_size_exceeds": {

							Type:     schema.TypeInt,
							Optional: true,
						},

						"max_cookie_value_size_none": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"max_header_count_exceeds": {

							Type:     schema.TypeInt,
							Optional: true,
						},

						"max_header_count_none": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"max_header_key_size_exceeds": {

							Type:     schema.TypeInt,
							Optional: true,
						},

						"max_header_key_size_none": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"max_header_value_size_exceeds": {

							Type:     schema.TypeInt,
							Optional: true,
						},

						"max_header_value_size_none": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"max_parameter_count_exceeds": {

							Type:     schema.TypeInt,
							Optional: true,
						},

						"max_parameter_count_none": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"max_parameter_name_size_exceeds": {

							Type:     schema.TypeInt,
							Optional: true,
						},

						"max_parameter_name_size_none": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"max_parameter_value_size_exceeds": {

							Type:     schema.TypeInt,
							Optional: true,
						},

						"max_parameter_value_size_none": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"max_query_size_exceeds": {

							Type:     schema.TypeInt,
							Optional: true,
						},

						"max_query_size_none": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"max_request_line_size_exceeds": {

							Type:     schema.TypeInt,
							Optional: true,
						},

						"max_request_line_size_none": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"max_request_size_exceeds": {

							Type:     schema.TypeInt,
							Optional: true,
						},

						"max_request_size_none": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"max_url_size_exceeds": {

							Type:     schema.TypeInt,
							Optional: true,
						},

						"max_url_size_none": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"scheme": {

				Type: schema.TypeList,

				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},

			"segment_policy": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"dst_any": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"dst_segments": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"segments": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"kind": {
													Type:     schema.TypeString,
													Computed: true,
												},

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"intra_segment": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"src_any": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"src_segments": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"segments": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"kind": {
													Type:     schema.TypeString,
													Computed: true,
												},

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},

			"server_selector": {

				Type:       schema.TypeSet,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"expressions": {

							Type: schema.TypeList,

							Required:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},

			"shape_protected_endpoint_action": {

				Type:       schema.TypeSet,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"allow_goodbot": {
							Type:       schema.TypeBool,
							Required:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"app_traffic_type": {
							Type:       schema.TypeString,
							Required:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"flow_label": {
							Type:       schema.TypeString,
							Required:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"mitigation": {

							Type:       schema.TypeSet,
							Required:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"block": {

										Type:       schema.TypeSet,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"body": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"body_hash": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"status": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},

									"flag": {

										Type:       schema.TypeSet,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"append_headers": {

													Type:       schema.TypeSet,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"auto_type_header_name": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"inference_header_name": {
																Type:       schema.TypeString,
																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},

												"no_headers": {

													Type:       schema.TypeBool,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},

									"none": {

										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"redirect": {

										Type:       schema.TypeSet,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"uri": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},
								},
							},
						},

						"transaction_result": {

							Type:       schema.TypeSet,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"failure_conditions": {

										Type:       schema.TypeList,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"regex_values": {

													Type: schema.TypeList,

													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},

												"status": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},

									"success_conditions": {

										Type:       schema.TypeList,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"regex_values": {

													Type: schema.TypeList,

													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},

												"status": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},
								},
							},
						},

						"web_scraping": {
							Type:       schema.TypeBool,
							Required:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},
					},
				},
			},

			"tls_fingerprint_matcher": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"classes": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},

						"exact_values": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},

						"excluded_values": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},

			"url_matcher": {

				Type:       schema.TypeSet,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"invert_matcher": {
							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"url_items": {

							Type:       schema.TypeList,
							Required:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"domain_regex": {

										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"domain_value": {

										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"path_prefix": {

										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"path_regex": {

										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"path_value": {

										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
								},
							},
						},
					},
				},
			},

			"virtual_host_matcher": {

				Type:       schema.TypeSet,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"exact_values": {

							Type: schema.TypeList,

							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},

						"regex_values": {

							Type: schema.TypeList,

							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},

			"waf_action": {

				Type:     schema.TypeSet,
				Required: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"app_firewall_detection_control": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"exclude_attack_type_contexts": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"context": {
													Type:     schema.TypeString,
													Required: true,
												},

												"context_name": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"exclude_attack_type": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"exclude_bot_name_contexts": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"bot_name": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"exclude_signature_contexts": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"context": {
													Type:     schema.TypeString,
													Required: true,
												},

												"context_name": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"signature_id": {
													Type:     schema.TypeInt,
													Required: true,
												},
											},
										},
									},

									"exclude_violation_contexts": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"context": {
													Type:     schema.TypeString,
													Required: true,
												},

												"context_name": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"exclude_violation": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},
								},
							},
						},

						"data_guard_control": {

							Type:       schema.TypeSet,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"policy_name": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
								},
							},
						},

						"jwt_claims_validation": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"jwt_validation": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"none": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"waf_in_monitoring_mode": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"waf_skip_processing": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},
		},
	}
}

// resourceVolterraServicePolicyRuleCreate creates ServicePolicyRule resource
func resourceVolterraServicePolicyRuleCreate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	createMeta := &ves_io_schema.ObjectCreateMetaType{}
	createSpec := &ves_io_schema_service_policy_rule.CreateSpecType{}
	createReq := &ves_io_schema_service_policy_rule.CreateRequest{
		Metadata: createMeta,
		Spec:     createSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		createMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		createMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		createMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		createMeta.Namespace =
			v.(string)
	}

	//action
	if v, ok := d.GetOk("action"); ok && !isIntfNil(v) {

		createSpec.Action = ves_io_schema_policy.RuleAction(ves_io_schema_policy.RuleAction_value[v.(string)])

	}

	//api_group_matcher
	if v, ok := d.GetOk("api_group_matcher"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		apiGroupMatcher := &ves_io_schema_policy.StringMatcherType{}
		createSpec.ApiGroupMatcher = apiGroupMatcher
		for _, set := range sl {
			apiGroupMatcherMapStrToI := set.(map[string]interface{})

			if w, ok := apiGroupMatcherMapStrToI["invert_matcher"]; ok && !isIntfNil(w) {
				apiGroupMatcher.InvertMatcher = w.(bool)
			}

			if w, ok := apiGroupMatcherMapStrToI["match"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				apiGroupMatcher.Match = ls
			}

		}

	}

	//arg_matchers
	if v, ok := d.GetOk("arg_matchers"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		argMatchers := make([]*ves_io_schema_policy.ArgMatcherType, len(sl))
		createSpec.ArgMatchers = argMatchers
		for i, set := range sl {
			argMatchers[i] = &ves_io_schema_policy.ArgMatcherType{}
			argMatchersMapStrToI := set.(map[string]interface{})

			if w, ok := argMatchersMapStrToI["invert_matcher"]; ok && !isIntfNil(w) {
				argMatchers[i].InvertMatcher = w.(bool)
			}

			matchTypeFound := false

			if v, ok := argMatchersMapStrToI["check_not_present"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true

				if v.(bool) {
					matchInt := &ves_io_schema_policy.ArgMatcherType_CheckNotPresent{}
					matchInt.CheckNotPresent = &ves_io_schema.Empty{}
					argMatchers[i].Match = matchInt
				}

			}

			if v, ok := argMatchersMapStrToI["check_present"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true

				if v.(bool) {
					matchInt := &ves_io_schema_policy.ArgMatcherType_CheckPresent{}
					matchInt.CheckPresent = &ves_io_schema.Empty{}
					argMatchers[i].Match = matchInt
				}

			}

			if v, ok := argMatchersMapStrToI["item"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true
				matchInt := &ves_io_schema_policy.ArgMatcherType_Item{}
				matchInt.Item = &ves_io_schema_policy.MatcherType{}
				argMatchers[i].Match = matchInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["exact_values"]; ok && !isIntfNil(v) {

						ls := make([]string, len(v.([]interface{})))
						for i, v := range v.([]interface{}) {
							ls[i] = v.(string)
						}
						matchInt.Item.ExactValues = ls

					}

					if v, ok := cs["regex_values"]; ok && !isIntfNil(v) {

						ls := make([]string, len(v.([]interface{})))
						for i, v := range v.([]interface{}) {
							ls[i] = v.(string)
						}
						matchInt.Item.RegexValues = ls

					}

					if v, ok := cs["transformers"]; ok && !isIntfNil(v) {

						transformersList := []ves_io_schema_policy.Transformer{}
						for _, j := range v.([]interface{}) {
							transformersList = append(transformersList, ves_io_schema_policy.Transformer(ves_io_schema_policy.Transformer_value[j.(string)]))
						}
						matchInt.Item.Transformers = transformersList

					}

				}

			}

			if v, ok := argMatchersMapStrToI["presence"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true
				matchInt := &ves_io_schema_policy.ArgMatcherType_Presence{}

				argMatchers[i].Match = matchInt

				matchInt.Presence = v.(bool)

			}

			if w, ok := argMatchersMapStrToI["name"]; ok && !isIntfNil(w) {
				argMatchers[i].Name = w.(string)
			}

		}

	}

	//asn_choice

	asnChoiceTypeFound := false

	if v, ok := d.GetOk("any_asn"); ok && !asnChoiceTypeFound {

		asnChoiceTypeFound = true

		if v.(bool) {
			asnChoiceInt := &ves_io_schema_service_policy_rule.CreateSpecType_AnyAsn{}
			asnChoiceInt.AnyAsn = &ves_io_schema.Empty{}
			createSpec.AsnChoice = asnChoiceInt
		}

	}

	if v, ok := d.GetOk("asn_list"); ok && !asnChoiceTypeFound {

		asnChoiceTypeFound = true
		asnChoiceInt := &ves_io_schema_service_policy_rule.CreateSpecType_AsnList{}
		asnChoiceInt.AsnList = &ves_io_schema_policy.AsnMatchList{}
		createSpec.AsnChoice = asnChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["as_numbers"]; ok && !isIntfNil(v) {

				ls := make([]uint32, len(v.([]interface{})))
				for i, v := range v.([]interface{}) {
					ls[i] = uint32(v.(int))
				}
				asnChoiceInt.AsnList.AsNumbers = ls

			}

		}

	}

	if v, ok := d.GetOk("asn_matcher"); ok && !asnChoiceTypeFound {

		asnChoiceTypeFound = true
		asnChoiceInt := &ves_io_schema_service_policy_rule.CreateSpecType_AsnMatcher{}
		asnChoiceInt.AsnMatcher = &ves_io_schema_policy.AsnMatcherType{}
		createSpec.AsnChoice = asnChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["asn_sets"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				asnSetsInt := make([]*ves_io_schema.ObjectRefType, len(sl))
				asnChoiceInt.AsnMatcher.AsnSets = asnSetsInt
				for i, ps := range sl {

					asMapToStrVal := ps.(map[string]interface{})
					asnSetsInt[i] = &ves_io_schema.ObjectRefType{}

					asnSetsInt[i].Kind = "bgp_asn_set"

					if v, ok := asMapToStrVal["name"]; ok && !isIntfNil(v) {
						asnSetsInt[i].Name = v.(string)
					}

					if v, ok := asMapToStrVal["namespace"]; ok && !isIntfNil(v) {
						asnSetsInt[i].Namespace = v.(string)
					}

					if v, ok := asMapToStrVal["tenant"]; ok && !isIntfNil(v) {
						asnSetsInt[i].Tenant = v.(string)
					}

					if v, ok := asMapToStrVal["uid"]; ok && !isIntfNil(v) {
						asnSetsInt[i].Uid = v.(string)
					}

				}

			}

		}

	}

	//body_matcher
	if v, ok := d.GetOk("body_matcher"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		bodyMatcher := &ves_io_schema_policy.MatcherType{}
		createSpec.BodyMatcher = bodyMatcher
		for _, set := range sl {
			bodyMatcherMapStrToI := set.(map[string]interface{})

			if w, ok := bodyMatcherMapStrToI["exact_values"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				bodyMatcher.ExactValues = ls
			}

			if w, ok := bodyMatcherMapStrToI["regex_values"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				bodyMatcher.RegexValues = ls
			}

			if v, ok := bodyMatcherMapStrToI["transformers"]; ok && !isIntfNil(v) {

				transformersList := []ves_io_schema_policy.Transformer{}
				for _, j := range v.([]interface{}) {
					transformersList = append(transformersList, ves_io_schema_policy.Transformer(ves_io_schema_policy.Transformer_value[j.(string)]))
				}
				bodyMatcher.Transformers = transformersList

			}

		}

	}

	//bot_action
	if v, ok := d.GetOk("bot_action"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		botAction := &ves_io_schema_policy.BotAction{}
		createSpec.BotAction = botAction
		for _, set := range sl {
			botActionMapStrToI := set.(map[string]interface{})

			actionTypeTypeFound := false

			if v, ok := botActionMapStrToI["bot_skip_processing"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

				actionTypeTypeFound = true

				if v.(bool) {
					actionTypeInt := &ves_io_schema_policy.BotAction_BotSkipProcessing{}
					actionTypeInt.BotSkipProcessing = &ves_io_schema.Empty{}
					botAction.ActionType = actionTypeInt
				}

			}

			if v, ok := botActionMapStrToI["none"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

				actionTypeTypeFound = true

				if v.(bool) {
					actionTypeInt := &ves_io_schema_policy.BotAction_None{}
					actionTypeInt.None = &ves_io_schema.Empty{}
					botAction.ActionType = actionTypeInt
				}

			}

		}

	}

	//challenge_action
	if v, ok := d.GetOk("challenge_action"); ok && !isIntfNil(v) {

		createSpec.ChallengeAction = ves_io_schema_policy.ChallengeAction(ves_io_schema_policy.ChallengeAction_value[v.(string)])

	}

	//client_choice

	clientChoiceTypeFound := false

	if v, ok := d.GetOk("any_client"); ok && !clientChoiceTypeFound {

		clientChoiceTypeFound = true

		if v.(bool) {
			clientChoiceInt := &ves_io_schema_service_policy_rule.CreateSpecType_AnyClient{}
			clientChoiceInt.AnyClient = &ves_io_schema.Empty{}
			createSpec.ClientChoice = clientChoiceInt
		}

	}

	if v, ok := d.GetOk("client_name"); ok && !clientChoiceTypeFound {

		clientChoiceTypeFound = true
		clientChoiceInt := &ves_io_schema_service_policy_rule.CreateSpecType_ClientName{}

		createSpec.ClientChoice = clientChoiceInt

		clientChoiceInt.ClientName = v.(string)

	}

	if v, ok := d.GetOk("client_name_matcher"); ok && !clientChoiceTypeFound {

		clientChoiceTypeFound = true
		clientChoiceInt := &ves_io_schema_service_policy_rule.CreateSpecType_ClientNameMatcher{}
		clientChoiceInt.ClientNameMatcher = &ves_io_schema_policy.MatcherTypeBasic{}
		createSpec.ClientChoice = clientChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["exact_values"]; ok && !isIntfNil(v) {

				ls := make([]string, len(v.([]interface{})))
				for i, v := range v.([]interface{}) {
					ls[i] = v.(string)
				}
				clientChoiceInt.ClientNameMatcher.ExactValues = ls

			}

			if v, ok := cs["regex_values"]; ok && !isIntfNil(v) {

				ls := make([]string, len(v.([]interface{})))
				for i, v := range v.([]interface{}) {
					ls[i] = v.(string)
				}
				clientChoiceInt.ClientNameMatcher.RegexValues = ls

			}

		}

	}

	if v, ok := d.GetOk("client_selector"); ok && !clientChoiceTypeFound {

		clientChoiceTypeFound = true
		clientChoiceInt := &ves_io_schema_service_policy_rule.CreateSpecType_ClientSelector{}
		clientChoiceInt.ClientSelector = &ves_io_schema.LabelSelectorType{}
		createSpec.ClientChoice = clientChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["expressions"]; ok && !isIntfNil(v) {

				ls := make([]string, len(v.([]interface{})))
				for i, v := range v.([]interface{}) {
					ls[i] = v.(string)
				}
				clientChoiceInt.ClientSelector.Expressions = ls

			}

		}

	}

	if v, ok := d.GetOk("ip_threat_category_list"); ok && !clientChoiceTypeFound {

		clientChoiceTypeFound = true
		clientChoiceInt := &ves_io_schema_service_policy_rule.CreateSpecType_IpThreatCategoryList{}
		clientChoiceInt.IpThreatCategoryList = &ves_io_schema_service_policy_rule.IPThreatCategoryListType{}
		createSpec.ClientChoice = clientChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["ip_threat_categories"]; ok && !isIntfNil(v) {

				ip_threat_categoriesList := []ves_io_schema_policy.IPThreatCategory{}
				for _, j := range v.([]interface{}) {
					ip_threat_categoriesList = append(ip_threat_categoriesList, ves_io_schema_policy.IPThreatCategory(ves_io_schema_policy.IPThreatCategory_value[j.(string)]))
				}
				clientChoiceInt.IpThreatCategoryList.IpThreatCategories = ip_threat_categoriesList

			}

		}

	}

	//client_role
	if v, ok := d.GetOk("client_role"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		clientRole := &ves_io_schema_policy.RoleMatcherType{}
		createSpec.ClientRole = clientRole
		for _, set := range sl {
			clientRoleMapStrToI := set.(map[string]interface{})

			if w, ok := clientRoleMapStrToI["match"]; ok && !isIntfNil(w) {
				clientRole.Match = w.(string)
			}

		}

	}

	//content_rewrite_action
	if v, ok := d.GetOk("content_rewrite_action"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		contentRewriteAction := &ves_io_schema_policy.ContentRewriteAction{}
		createSpec.ContentRewriteAction = contentRewriteAction
		for _, set := range sl {
			contentRewriteActionMapStrToI := set.(map[string]interface{})

			if w, ok := contentRewriteActionMapStrToI["element_selector"]; ok && !isIntfNil(w) {
				contentRewriteAction.ElementSelector = w.(string)
			}

			if w, ok := contentRewriteActionMapStrToI["insert_content"]; ok && !isIntfNil(w) {
				contentRewriteAction.InsertContent = w.(string)
			}

			if w, ok := contentRewriteActionMapStrToI["inserted_types"]; ok && !isIntfNil(w) {
				ms := map[string]bool{}
				for k, v := range w.(map[string]interface{}) {
					ms[k] = v.(bool)
				}
				contentRewriteAction.InsertedTypes = ms
			}

			if v, ok := contentRewriteActionMapStrToI["position"]; ok && !isIntfNil(v) {

				contentRewriteAction.Position = ves_io_schema_policy.HTMLPosition(ves_io_schema_policy.HTMLPosition_value[v.(string)])

			}

		}

	}

	//cookie_matchers
	if v, ok := d.GetOk("cookie_matchers"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		cookieMatchers := make([]*ves_io_schema_policy.CookieMatcherType, len(sl))
		createSpec.CookieMatchers = cookieMatchers
		for i, set := range sl {
			cookieMatchers[i] = &ves_io_schema_policy.CookieMatcherType{}
			cookieMatchersMapStrToI := set.(map[string]interface{})

			if w, ok := cookieMatchersMapStrToI["invert_matcher"]; ok && !isIntfNil(w) {
				cookieMatchers[i].InvertMatcher = w.(bool)
			}

			matchTypeFound := false

			if v, ok := cookieMatchersMapStrToI["check_not_present"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true

				if v.(bool) {
					matchInt := &ves_io_schema_policy.CookieMatcherType_CheckNotPresent{}
					matchInt.CheckNotPresent = &ves_io_schema.Empty{}
					cookieMatchers[i].Match = matchInt
				}

			}

			if v, ok := cookieMatchersMapStrToI["check_present"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true

				if v.(bool) {
					matchInt := &ves_io_schema_policy.CookieMatcherType_CheckPresent{}
					matchInt.CheckPresent = &ves_io_schema.Empty{}
					cookieMatchers[i].Match = matchInt
				}

			}

			if v, ok := cookieMatchersMapStrToI["item"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true
				matchInt := &ves_io_schema_policy.CookieMatcherType_Item{}
				matchInt.Item = &ves_io_schema_policy.MatcherType{}
				cookieMatchers[i].Match = matchInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["exact_values"]; ok && !isIntfNil(v) {

						ls := make([]string, len(v.([]interface{})))
						for i, v := range v.([]interface{}) {
							ls[i] = v.(string)
						}
						matchInt.Item.ExactValues = ls

					}

					if v, ok := cs["regex_values"]; ok && !isIntfNil(v) {

						ls := make([]string, len(v.([]interface{})))
						for i, v := range v.([]interface{}) {
							ls[i] = v.(string)
						}
						matchInt.Item.RegexValues = ls

					}

					if v, ok := cs["transformers"]; ok && !isIntfNil(v) {

						transformersList := []ves_io_schema_policy.Transformer{}
						for _, j := range v.([]interface{}) {
							transformersList = append(transformersList, ves_io_schema_policy.Transformer(ves_io_schema_policy.Transformer_value[j.(string)]))
						}
						matchInt.Item.Transformers = transformersList

					}

				}

			}

			if v, ok := cookieMatchersMapStrToI["presence"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true
				matchInt := &ves_io_schema_policy.CookieMatcherType_Presence{}

				cookieMatchers[i].Match = matchInt

				matchInt.Presence = v.(bool)

			}

			if w, ok := cookieMatchersMapStrToI["name"]; ok && !isIntfNil(w) {
				cookieMatchers[i].Name = w.(string)
			}

		}

	}

	//domain_matcher
	if v, ok := d.GetOk("domain_matcher"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		domainMatcher := &ves_io_schema_policy.MatcherTypeBasic{}
		createSpec.DomainMatcher = domainMatcher
		for _, set := range sl {
			domainMatcherMapStrToI := set.(map[string]interface{})

			if w, ok := domainMatcherMapStrToI["exact_values"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				domainMatcher.ExactValues = ls
			}

			if w, ok := domainMatcherMapStrToI["regex_values"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				domainMatcher.RegexValues = ls
			}

		}

	}

	//dst_asn_choice

	dstAsnChoiceTypeFound := false

	if v, ok := d.GetOk("any_dst_asn"); ok && !dstAsnChoiceTypeFound {

		dstAsnChoiceTypeFound = true

		if v.(bool) {
			dstAsnChoiceInt := &ves_io_schema_service_policy_rule.CreateSpecType_AnyDstAsn{}
			dstAsnChoiceInt.AnyDstAsn = &ves_io_schema.Empty{}
			createSpec.DstAsnChoice = dstAsnChoiceInt
		}

	}

	if v, ok := d.GetOk("dst_asn_list"); ok && !dstAsnChoiceTypeFound {

		dstAsnChoiceTypeFound = true
		dstAsnChoiceInt := &ves_io_schema_service_policy_rule.CreateSpecType_DstAsnList{}
		dstAsnChoiceInt.DstAsnList = &ves_io_schema_policy.AsnMatchList{}
		createSpec.DstAsnChoice = dstAsnChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["as_numbers"]; ok && !isIntfNil(v) {

				ls := make([]uint32, len(v.([]interface{})))
				for i, v := range v.([]interface{}) {
					ls[i] = uint32(v.(int))
				}
				dstAsnChoiceInt.DstAsnList.AsNumbers = ls

			}

		}

	}

	if v, ok := d.GetOk("dst_asn_matcher"); ok && !dstAsnChoiceTypeFound {

		dstAsnChoiceTypeFound = true
		dstAsnChoiceInt := &ves_io_schema_service_policy_rule.CreateSpecType_DstAsnMatcher{}
		dstAsnChoiceInt.DstAsnMatcher = &ves_io_schema_policy.AsnMatcherType{}
		createSpec.DstAsnChoice = dstAsnChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["asn_sets"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				asnSetsInt := make([]*ves_io_schema.ObjectRefType, len(sl))
				dstAsnChoiceInt.DstAsnMatcher.AsnSets = asnSetsInt
				for i, ps := range sl {

					asMapToStrVal := ps.(map[string]interface{})
					asnSetsInt[i] = &ves_io_schema.ObjectRefType{}

					asnSetsInt[i].Kind = "bgp_asn_set"

					if v, ok := asMapToStrVal["name"]; ok && !isIntfNil(v) {
						asnSetsInt[i].Name = v.(string)
					}

					if v, ok := asMapToStrVal["namespace"]; ok && !isIntfNil(v) {
						asnSetsInt[i].Namespace = v.(string)
					}

					if v, ok := asMapToStrVal["tenant"]; ok && !isIntfNil(v) {
						asnSetsInt[i].Tenant = v.(string)
					}

					if v, ok := asMapToStrVal["uid"]; ok && !isIntfNil(v) {
						asnSetsInt[i].Uid = v.(string)
					}

				}

			}

		}

	}

	//dst_ip_choice

	dstIpChoiceTypeFound := false

	if v, ok := d.GetOk("any_dst_ip"); ok && !dstIpChoiceTypeFound {

		dstIpChoiceTypeFound = true

		if v.(bool) {
			dstIpChoiceInt := &ves_io_schema_service_policy_rule.CreateSpecType_AnyDstIp{}
			dstIpChoiceInt.AnyDstIp = &ves_io_schema.Empty{}
			createSpec.DstIpChoice = dstIpChoiceInt
		}

	}

	if v, ok := d.GetOk("dst_ip_matcher"); ok && !dstIpChoiceTypeFound {

		dstIpChoiceTypeFound = true
		dstIpChoiceInt := &ves_io_schema_service_policy_rule.CreateSpecType_DstIpMatcher{}
		dstIpChoiceInt.DstIpMatcher = &ves_io_schema_policy.IpMatcherType{}
		createSpec.DstIpChoice = dstIpChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["invert_matcher"]; ok && !isIntfNil(v) {

				dstIpChoiceInt.DstIpMatcher.InvertMatcher = v.(bool)

			}

			if v, ok := cs["prefix_sets"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				prefixSetsInt := make([]*ves_io_schema.ObjectRefType, len(sl))
				dstIpChoiceInt.DstIpMatcher.PrefixSets = prefixSetsInt
				for i, ps := range sl {

					psMapToStrVal := ps.(map[string]interface{})
					prefixSetsInt[i] = &ves_io_schema.ObjectRefType{}

					prefixSetsInt[i].Kind = "ip_prefix_set"

					if v, ok := psMapToStrVal["name"]; ok && !isIntfNil(v) {
						prefixSetsInt[i].Name = v.(string)
					}

					if v, ok := psMapToStrVal["namespace"]; ok && !isIntfNil(v) {
						prefixSetsInt[i].Namespace = v.(string)
					}

					if v, ok := psMapToStrVal["tenant"]; ok && !isIntfNil(v) {
						prefixSetsInt[i].Tenant = v.(string)
					}

					if v, ok := psMapToStrVal["uid"]; ok && !isIntfNil(v) {
						prefixSetsInt[i].Uid = v.(string)
					}

				}

			}

		}

	}

	if v, ok := d.GetOk("dst_ip_prefix_list"); ok && !dstIpChoiceTypeFound {

		dstIpChoiceTypeFound = true
		dstIpChoiceInt := &ves_io_schema_service_policy_rule.CreateSpecType_DstIpPrefixList{}
		dstIpChoiceInt.DstIpPrefixList = &ves_io_schema_policy.PrefixMatchList{}
		createSpec.DstIpChoice = dstIpChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["invert_match"]; ok && !isIntfNil(v) {

				dstIpChoiceInt.DstIpPrefixList.InvertMatch = v.(bool)

			}

			if v, ok := cs["ip_prefixes"]; ok && !isIntfNil(v) {

				ls := make([]string, len(v.([]interface{})))
				for i, v := range v.([]interface{}) {
					ls[i] = v.(string)
				}
				dstIpChoiceInt.DstIpPrefixList.IpPrefixes = ls

			}

		}

	}

	//expiration_timestamp
	if v, ok := d.GetOk("expiration_timestamp"); ok && !isIntfNil(v) {

		ts, err := parseTime(v.(string))
		if err != nil {
			return fmt.Errorf("error creating ServicePolicyRule, timestamp format is wrong: %s", err)
		}
		createSpec.ExpirationTimestamp = ts

	}

	//goto_policy
	if v, ok := d.GetOk("goto_policy"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		gotoPolicyInt := make([]*ves_io_schema.ObjectRefType, len(sl))
		createSpec.GotoPolicy = gotoPolicyInt
		for i, ps := range sl {

			gpMapToStrVal := ps.(map[string]interface{})
			gotoPolicyInt[i] = &ves_io_schema.ObjectRefType{}

			gotoPolicyInt[i].Kind = "service_policy"

			if v, ok := gpMapToStrVal["name"]; ok && !isIntfNil(v) {
				gotoPolicyInt[i].Name = v.(string)
			}

			if v, ok := gpMapToStrVal["namespace"]; ok && !isIntfNil(v) {
				gotoPolicyInt[i].Namespace = v.(string)
			}

			if v, ok := gpMapToStrVal["tenant"]; ok && !isIntfNil(v) {
				gotoPolicyInt[i].Tenant = v.(string)
			}

			if v, ok := gpMapToStrVal["uid"]; ok && !isIntfNil(v) {
				gotoPolicyInt[i].Uid = v.(string)
			}

		}

	}

	//headers
	if v, ok := d.GetOk("headers"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		headers := make([]*ves_io_schema_policy.HeaderMatcherType, len(sl))
		createSpec.Headers = headers
		for i, set := range sl {
			headers[i] = &ves_io_schema_policy.HeaderMatcherType{}
			headersMapStrToI := set.(map[string]interface{})

			if w, ok := headersMapStrToI["invert_matcher"]; ok && !isIntfNil(w) {
				headers[i].InvertMatcher = w.(bool)
			}

			matchTypeFound := false

			if v, ok := headersMapStrToI["check_not_present"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true

				if v.(bool) {
					matchInt := &ves_io_schema_policy.HeaderMatcherType_CheckNotPresent{}
					matchInt.CheckNotPresent = &ves_io_schema.Empty{}
					headers[i].Match = matchInt
				}

			}

			if v, ok := headersMapStrToI["check_present"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true

				if v.(bool) {
					matchInt := &ves_io_schema_policy.HeaderMatcherType_CheckPresent{}
					matchInt.CheckPresent = &ves_io_schema.Empty{}
					headers[i].Match = matchInt
				}

			}

			if v, ok := headersMapStrToI["item"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true
				matchInt := &ves_io_schema_policy.HeaderMatcherType_Item{}
				matchInt.Item = &ves_io_schema_policy.MatcherType{}
				headers[i].Match = matchInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["exact_values"]; ok && !isIntfNil(v) {

						ls := make([]string, len(v.([]interface{})))
						for i, v := range v.([]interface{}) {
							ls[i] = v.(string)
						}
						matchInt.Item.ExactValues = ls

					}

					if v, ok := cs["regex_values"]; ok && !isIntfNil(v) {

						ls := make([]string, len(v.([]interface{})))
						for i, v := range v.([]interface{}) {
							ls[i] = v.(string)
						}
						matchInt.Item.RegexValues = ls

					}

					if v, ok := cs["transformers"]; ok && !isIntfNil(v) {

						transformersList := []ves_io_schema_policy.Transformer{}
						for _, j := range v.([]interface{}) {
							transformersList = append(transformersList, ves_io_schema_policy.Transformer(ves_io_schema_policy.Transformer_value[j.(string)]))
						}
						matchInt.Item.Transformers = transformersList

					}

				}

			}

			if v, ok := headersMapStrToI["presence"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true
				matchInt := &ves_io_schema_policy.HeaderMatcherType_Presence{}

				headers[i].Match = matchInt

				matchInt.Presence = v.(bool)

			}

			if w, ok := headersMapStrToI["name"]; ok && !isIntfNil(w) {
				headers[i].Name = w.(string)
			}

		}

	}

	//http_method
	if v, ok := d.GetOk("http_method"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		httpMethod := &ves_io_schema_policy.HttpMethodMatcherType{}
		createSpec.HttpMethod = httpMethod
		for _, set := range sl {
			httpMethodMapStrToI := set.(map[string]interface{})

			if w, ok := httpMethodMapStrToI["invert_matcher"]; ok && !isIntfNil(w) {
				httpMethod.InvertMatcher = w.(bool)
			}

			if v, ok := httpMethodMapStrToI["methods"]; ok && !isIntfNil(v) {

				methodsList := []ves_io_schema.HttpMethod{}
				for _, j := range v.([]interface{}) {
					methodsList = append(methodsList, ves_io_schema.HttpMethod(ves_io_schema.HttpMethod_value[j.(string)]))
				}
				httpMethod.Methods = methodsList

			}

		}

	}

	//ip_choice

	ipChoiceTypeFound := false

	if v, ok := d.GetOk("any_ip"); ok && !ipChoiceTypeFound {

		ipChoiceTypeFound = true

		if v.(bool) {
			ipChoiceInt := &ves_io_schema_service_policy_rule.CreateSpecType_AnyIp{}
			ipChoiceInt.AnyIp = &ves_io_schema.Empty{}
			createSpec.IpChoice = ipChoiceInt
		}

	}

	if v, ok := d.GetOk("ip_matcher"); ok && !ipChoiceTypeFound {

		ipChoiceTypeFound = true
		ipChoiceInt := &ves_io_schema_service_policy_rule.CreateSpecType_IpMatcher{}
		ipChoiceInt.IpMatcher = &ves_io_schema_policy.IpMatcherType{}
		createSpec.IpChoice = ipChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["invert_matcher"]; ok && !isIntfNil(v) {

				ipChoiceInt.IpMatcher.InvertMatcher = v.(bool)

			}

			if v, ok := cs["prefix_sets"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				prefixSetsInt := make([]*ves_io_schema.ObjectRefType, len(sl))
				ipChoiceInt.IpMatcher.PrefixSets = prefixSetsInt
				for i, ps := range sl {

					psMapToStrVal := ps.(map[string]interface{})
					prefixSetsInt[i] = &ves_io_schema.ObjectRefType{}

					prefixSetsInt[i].Kind = "ip_prefix_set"

					if v, ok := psMapToStrVal["name"]; ok && !isIntfNil(v) {
						prefixSetsInt[i].Name = v.(string)
					}

					if v, ok := psMapToStrVal["namespace"]; ok && !isIntfNil(v) {
						prefixSetsInt[i].Namespace = v.(string)
					}

					if v, ok := psMapToStrVal["tenant"]; ok && !isIntfNil(v) {
						prefixSetsInt[i].Tenant = v.(string)
					}

					if v, ok := psMapToStrVal["uid"]; ok && !isIntfNil(v) {
						prefixSetsInt[i].Uid = v.(string)
					}

				}

			}

		}

	}

	if v, ok := d.GetOk("ip_prefix_list"); ok && !ipChoiceTypeFound {

		ipChoiceTypeFound = true
		ipChoiceInt := &ves_io_schema_service_policy_rule.CreateSpecType_IpPrefixList{}
		ipChoiceInt.IpPrefixList = &ves_io_schema_policy.PrefixMatchList{}
		createSpec.IpChoice = ipChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["invert_match"]; ok && !isIntfNil(v) {

				ipChoiceInt.IpPrefixList.InvertMatch = v.(bool)

			}

			if v, ok := cs["ip_prefixes"]; ok && !isIntfNil(v) {

				ls := make([]string, len(v.([]interface{})))
				for i, v := range v.([]interface{}) {
					ls[i] = v.(string)
				}
				ipChoiceInt.IpPrefixList.IpPrefixes = ls

			}

		}

	}

	//ip_reputation_action
	if v, ok := d.GetOk("ip_reputation_action"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		ipReputationAction := &ves_io_schema_policy.ModifyAction{}
		createSpec.IpReputationAction = ipReputationAction
		for _, set := range sl {
			ipReputationActionMapStrToI := set.(map[string]interface{})

			actionTypeTypeFound := false

			if v, ok := ipReputationActionMapStrToI["default"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

				actionTypeTypeFound = true

				if v.(bool) {
					actionTypeInt := &ves_io_schema_policy.ModifyAction_Default{}
					actionTypeInt.Default = &ves_io_schema.Empty{}
					ipReputationAction.ActionType = actionTypeInt
				}

			}

			if v, ok := ipReputationActionMapStrToI["skip_processing"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

				actionTypeTypeFound = true

				if v.(bool) {
					actionTypeInt := &ves_io_schema_policy.ModifyAction_SkipProcessing{}
					actionTypeInt.SkipProcessing = &ves_io_schema.Empty{}
					ipReputationAction.ActionType = actionTypeInt
				}

			}

		}

	}

	//jwt_claims
	if v, ok := d.GetOk("jwt_claims"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		jwtClaims := make([]*ves_io_schema_policy.JWTClaimMatcherType, len(sl))
		createSpec.JwtClaims = jwtClaims
		for i, set := range sl {
			jwtClaims[i] = &ves_io_schema_policy.JWTClaimMatcherType{}
			jwtClaimsMapStrToI := set.(map[string]interface{})

			if w, ok := jwtClaimsMapStrToI["invert_matcher"]; ok && !isIntfNil(w) {
				jwtClaims[i].InvertMatcher = w.(bool)
			}

			matchTypeFound := false

			if v, ok := jwtClaimsMapStrToI["check_not_present"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true

				if v.(bool) {
					matchInt := &ves_io_schema_policy.JWTClaimMatcherType_CheckNotPresent{}
					matchInt.CheckNotPresent = &ves_io_schema.Empty{}
					jwtClaims[i].Match = matchInt
				}

			}

			if v, ok := jwtClaimsMapStrToI["check_present"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true

				if v.(bool) {
					matchInt := &ves_io_schema_policy.JWTClaimMatcherType_CheckPresent{}
					matchInt.CheckPresent = &ves_io_schema.Empty{}
					jwtClaims[i].Match = matchInt
				}

			}

			if v, ok := jwtClaimsMapStrToI["item"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true
				matchInt := &ves_io_schema_policy.JWTClaimMatcherType_Item{}
				matchInt.Item = &ves_io_schema_policy.MatcherType{}
				jwtClaims[i].Match = matchInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["exact_values"]; ok && !isIntfNil(v) {

						ls := make([]string, len(v.([]interface{})))
						for i, v := range v.([]interface{}) {
							ls[i] = v.(string)
						}
						matchInt.Item.ExactValues = ls

					}

					if v, ok := cs["regex_values"]; ok && !isIntfNil(v) {

						ls := make([]string, len(v.([]interface{})))
						for i, v := range v.([]interface{}) {
							ls[i] = v.(string)
						}
						matchInt.Item.RegexValues = ls

					}

					if v, ok := cs["transformers"]; ok && !isIntfNil(v) {

						transformersList := []ves_io_schema_policy.Transformer{}
						for _, j := range v.([]interface{}) {
							transformersList = append(transformersList, ves_io_schema_policy.Transformer(ves_io_schema_policy.Transformer_value[j.(string)]))
						}
						matchInt.Item.Transformers = transformersList

					}

				}

			}

			if w, ok := jwtClaimsMapStrToI["name"]; ok && !isIntfNil(w) {
				jwtClaims[i].Name = w.(string)
			}

		}

	}

	//l4_dest_matcher
	if v, ok := d.GetOk("l4_dest_matcher"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		l4DestMatcher := &ves_io_schema_policy.L4DestMatcherType{}
		createSpec.L4DestMatcher = l4DestMatcher
		for _, set := range sl {
			l4DestMatcherMapStrToI := set.(map[string]interface{})

			if w, ok := l4DestMatcherMapStrToI["invert_matcher"]; ok && !isIntfNil(w) {
				l4DestMatcher.InvertMatcher = w.(bool)
			}

			if v, ok := l4DestMatcherMapStrToI["l4_dests"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				l4Dests := make([]*ves_io_schema.L4DestType, len(sl))
				l4DestMatcher.L4Dests = l4Dests
				for i, set := range sl {
					l4Dests[i] = &ves_io_schema.L4DestType{}
					l4DestsMapStrToI := set.(map[string]interface{})

					if w, ok := l4DestsMapStrToI["port_ranges"]; ok && !isIntfNil(w) {
						l4Dests[i].PortRanges = w.(string)
					}

					if w, ok := l4DestsMapStrToI["prefixes"]; ok && !isIntfNil(w) {
						ls := make([]string, len(w.([]interface{})))
						for i, v := range w.([]interface{}) {
							ls[i] = v.(string)
						}
						l4Dests[i].Prefixes = ls
					}

				}

			}

		}

	}

	//label_matcher
	if v, ok := d.GetOk("label_matcher"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		labelMatcher := &ves_io_schema.LabelMatcherType{}
		createSpec.LabelMatcher = labelMatcher
		for _, set := range sl {
			labelMatcherMapStrToI := set.(map[string]interface{})

			if w, ok := labelMatcherMapStrToI["keys"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				labelMatcher.Keys = ls
			}

		}

	}

	//mum_action
	if v, ok := d.GetOk("mum_action"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		mumAction := &ves_io_schema_policy.ModifyAction{}
		createSpec.MumAction = mumAction
		for _, set := range sl {
			mumActionMapStrToI := set.(map[string]interface{})

			actionTypeTypeFound := false

			if v, ok := mumActionMapStrToI["default"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

				actionTypeTypeFound = true

				if v.(bool) {
					actionTypeInt := &ves_io_schema_policy.ModifyAction_Default{}
					actionTypeInt.Default = &ves_io_schema.Empty{}
					mumAction.ActionType = actionTypeInt
				}

			}

			if v, ok := mumActionMapStrToI["skip_processing"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

				actionTypeTypeFound = true

				if v.(bool) {
					actionTypeInt := &ves_io_schema_policy.ModifyAction_SkipProcessing{}
					actionTypeInt.SkipProcessing = &ves_io_schema.Empty{}
					mumAction.ActionType = actionTypeInt
				}

			}

		}

	}

	//origin_server_subsets_action
	if v, ok := d.GetOk("origin_server_subsets_action"); ok && !isIntfNil(v) {

		ms := map[string]string{}
		for k, v := range v.(map[string]interface{}) {
			ms[k] = v.(string)
		}
		createSpec.OriginServerSubsetsAction = ms
	}

	//path
	if v, ok := d.GetOk("path"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		path := &ves_io_schema_policy.PathMatcherType{}
		createSpec.Path = path
		for _, set := range sl {
			pathMapStrToI := set.(map[string]interface{})

			if w, ok := pathMapStrToI["exact_values"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				path.ExactValues = ls
			}

			if w, ok := pathMapStrToI["invert_matcher"]; ok && !isIntfNil(w) {
				path.InvertMatcher = w.(bool)
			}

			if w, ok := pathMapStrToI["prefix_values"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				path.PrefixValues = ls
			}

			if w, ok := pathMapStrToI["regex_values"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				path.RegexValues = ls
			}

			if w, ok := pathMapStrToI["suffix_values"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				path.SuffixValues = ls
			}

			if v, ok := pathMapStrToI["transformers"]; ok && !isIntfNil(v) {

				transformersList := []ves_io_schema_policy.Transformer{}
				for _, j := range v.([]interface{}) {
					transformersList = append(transformersList, ves_io_schema_policy.Transformer(ves_io_schema_policy.Transformer_value[j.(string)]))
				}
				path.Transformers = transformersList

			}

		}

	}

	//port_matcher
	if v, ok := d.GetOk("port_matcher"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		portMatcher := &ves_io_schema_policy.PortMatcherType{}
		createSpec.PortMatcher = portMatcher
		for _, set := range sl {
			portMatcherMapStrToI := set.(map[string]interface{})

			if w, ok := portMatcherMapStrToI["invert_matcher"]; ok && !isIntfNil(w) {
				portMatcher.InvertMatcher = w.(bool)
			}

			if w, ok := portMatcherMapStrToI["ports"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				portMatcher.Ports = ls
			}

		}

	}

	//query_params
	if v, ok := d.GetOk("query_params"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		queryParams := make([]*ves_io_schema_policy.QueryParameterMatcherType, len(sl))
		createSpec.QueryParams = queryParams
		for i, set := range sl {
			queryParams[i] = &ves_io_schema_policy.QueryParameterMatcherType{}
			queryParamsMapStrToI := set.(map[string]interface{})

			if w, ok := queryParamsMapStrToI["invert_matcher"]; ok && !isIntfNil(w) {
				queryParams[i].InvertMatcher = w.(bool)
			}

			if w, ok := queryParamsMapStrToI["key"]; ok && !isIntfNil(w) {
				queryParams[i].Key = w.(string)
			}

			matchTypeFound := false

			if v, ok := queryParamsMapStrToI["check_not_present"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true

				if v.(bool) {
					matchInt := &ves_io_schema_policy.QueryParameterMatcherType_CheckNotPresent{}
					matchInt.CheckNotPresent = &ves_io_schema.Empty{}
					queryParams[i].Match = matchInt
				}

			}

			if v, ok := queryParamsMapStrToI["check_present"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true

				if v.(bool) {
					matchInt := &ves_io_schema_policy.QueryParameterMatcherType_CheckPresent{}
					matchInt.CheckPresent = &ves_io_schema.Empty{}
					queryParams[i].Match = matchInt
				}

			}

			if v, ok := queryParamsMapStrToI["item"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true
				matchInt := &ves_io_schema_policy.QueryParameterMatcherType_Item{}
				matchInt.Item = &ves_io_schema_policy.MatcherType{}
				queryParams[i].Match = matchInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["exact_values"]; ok && !isIntfNil(v) {

						ls := make([]string, len(v.([]interface{})))
						for i, v := range v.([]interface{}) {
							ls[i] = v.(string)
						}
						matchInt.Item.ExactValues = ls

					}

					if v, ok := cs["regex_values"]; ok && !isIntfNil(v) {

						ls := make([]string, len(v.([]interface{})))
						for i, v := range v.([]interface{}) {
							ls[i] = v.(string)
						}
						matchInt.Item.RegexValues = ls

					}

					if v, ok := cs["transformers"]; ok && !isIntfNil(v) {

						transformersList := []ves_io_schema_policy.Transformer{}
						for _, j := range v.([]interface{}) {
							transformersList = append(transformersList, ves_io_schema_policy.Transformer(ves_io_schema_policy.Transformer_value[j.(string)]))
						}
						matchInt.Item.Transformers = transformersList

					}

				}

			}

			if v, ok := queryParamsMapStrToI["presence"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true
				matchInt := &ves_io_schema_policy.QueryParameterMatcherType_Presence{}

				queryParams[i].Match = matchInt

				matchInt.Presence = v.(bool)

			}

		}

	}

	//rate_limiter
	if v, ok := d.GetOk("rate_limiter"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		rateLimiterInt := make([]*ves_io_schema.ObjectRefType, len(sl))
		createSpec.RateLimiter = rateLimiterInt
		for i, ps := range sl {

			rlMapToStrVal := ps.(map[string]interface{})
			rateLimiterInt[i] = &ves_io_schema.ObjectRefType{}

			rateLimiterInt[i].Kind = "rate_limiter"

			if v, ok := rlMapToStrVal["name"]; ok && !isIntfNil(v) {
				rateLimiterInt[i].Name = v.(string)
			}

			if v, ok := rlMapToStrVal["namespace"]; ok && !isIntfNil(v) {
				rateLimiterInt[i].Namespace = v.(string)
			}

			if v, ok := rlMapToStrVal["tenant"]; ok && !isIntfNil(v) {
				rateLimiterInt[i].Tenant = v.(string)
			}

			if v, ok := rlMapToStrVal["uid"]; ok && !isIntfNil(v) {
				rateLimiterInt[i].Uid = v.(string)
			}

		}

	}

	//request_constraints
	if v, ok := d.GetOk("request_constraints"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		requestConstraints := &ves_io_schema_policy.RequestConstraintType{}
		createSpec.RequestConstraints = requestConstraints
		for _, set := range sl {
			requestConstraintsMapStrToI := set.(map[string]interface{})

			maxCookieCountChoiceTypeFound := false

			if v, ok := requestConstraintsMapStrToI["max_cookie_count_exceeds"]; ok && !isIntfNil(v) && !maxCookieCountChoiceTypeFound {

				maxCookieCountChoiceTypeFound = true
				maxCookieCountChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxCookieCountExceeds{}

				requestConstraints.MaxCookieCountChoice = maxCookieCountChoiceInt

				maxCookieCountChoiceInt.MaxCookieCountExceeds = uint32(v.(int))

			}

			if v, ok := requestConstraintsMapStrToI["max_cookie_count_none"]; ok && !isIntfNil(v) && !maxCookieCountChoiceTypeFound {

				maxCookieCountChoiceTypeFound = true

				if v.(bool) {
					maxCookieCountChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxCookieCountNone{}
					maxCookieCountChoiceInt.MaxCookieCountNone = &ves_io_schema.Empty{}
					requestConstraints.MaxCookieCountChoice = maxCookieCountChoiceInt
				}

			}

			maxCookieKeySizeChoiceTypeFound := false

			if v, ok := requestConstraintsMapStrToI["max_cookie_key_size_exceeds"]; ok && !isIntfNil(v) && !maxCookieKeySizeChoiceTypeFound {

				maxCookieKeySizeChoiceTypeFound = true
				maxCookieKeySizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxCookieKeySizeExceeds{}

				requestConstraints.MaxCookieKeySizeChoice = maxCookieKeySizeChoiceInt

				maxCookieKeySizeChoiceInt.MaxCookieKeySizeExceeds = uint32(v.(int))

			}

			if v, ok := requestConstraintsMapStrToI["max_cookie_key_size_none"]; ok && !isIntfNil(v) && !maxCookieKeySizeChoiceTypeFound {

				maxCookieKeySizeChoiceTypeFound = true

				if v.(bool) {
					maxCookieKeySizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxCookieKeySizeNone{}
					maxCookieKeySizeChoiceInt.MaxCookieKeySizeNone = &ves_io_schema.Empty{}
					requestConstraints.MaxCookieKeySizeChoice = maxCookieKeySizeChoiceInt
				}

			}

			maxCookieValueSizeChoiceTypeFound := false

			if v, ok := requestConstraintsMapStrToI["max_cookie_value_size_exceeds"]; ok && !isIntfNil(v) && !maxCookieValueSizeChoiceTypeFound {

				maxCookieValueSizeChoiceTypeFound = true
				maxCookieValueSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxCookieValueSizeExceeds{}

				requestConstraints.MaxCookieValueSizeChoice = maxCookieValueSizeChoiceInt

				maxCookieValueSizeChoiceInt.MaxCookieValueSizeExceeds = uint32(v.(int))

			}

			if v, ok := requestConstraintsMapStrToI["max_cookie_value_size_none"]; ok && !isIntfNil(v) && !maxCookieValueSizeChoiceTypeFound {

				maxCookieValueSizeChoiceTypeFound = true

				if v.(bool) {
					maxCookieValueSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxCookieValueSizeNone{}
					maxCookieValueSizeChoiceInt.MaxCookieValueSizeNone = &ves_io_schema.Empty{}
					requestConstraints.MaxCookieValueSizeChoice = maxCookieValueSizeChoiceInt
				}

			}

			maxHeaderCountChoiceTypeFound := false

			if v, ok := requestConstraintsMapStrToI["max_header_count_exceeds"]; ok && !isIntfNil(v) && !maxHeaderCountChoiceTypeFound {

				maxHeaderCountChoiceTypeFound = true
				maxHeaderCountChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxHeaderCountExceeds{}

				requestConstraints.MaxHeaderCountChoice = maxHeaderCountChoiceInt

				maxHeaderCountChoiceInt.MaxHeaderCountExceeds = uint32(v.(int))

			}

			if v, ok := requestConstraintsMapStrToI["max_header_count_none"]; ok && !isIntfNil(v) && !maxHeaderCountChoiceTypeFound {

				maxHeaderCountChoiceTypeFound = true

				if v.(bool) {
					maxHeaderCountChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxHeaderCountNone{}
					maxHeaderCountChoiceInt.MaxHeaderCountNone = &ves_io_schema.Empty{}
					requestConstraints.MaxHeaderCountChoice = maxHeaderCountChoiceInt
				}

			}

			maxHeaderKeySizeChoiceTypeFound := false

			if v, ok := requestConstraintsMapStrToI["max_header_key_size_exceeds"]; ok && !isIntfNil(v) && !maxHeaderKeySizeChoiceTypeFound {

				maxHeaderKeySizeChoiceTypeFound = true
				maxHeaderKeySizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxHeaderKeySizeExceeds{}

				requestConstraints.MaxHeaderKeySizeChoice = maxHeaderKeySizeChoiceInt

				maxHeaderKeySizeChoiceInt.MaxHeaderKeySizeExceeds = uint32(v.(int))

			}

			if v, ok := requestConstraintsMapStrToI["max_header_key_size_none"]; ok && !isIntfNil(v) && !maxHeaderKeySizeChoiceTypeFound {

				maxHeaderKeySizeChoiceTypeFound = true

				if v.(bool) {
					maxHeaderKeySizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxHeaderKeySizeNone{}
					maxHeaderKeySizeChoiceInt.MaxHeaderKeySizeNone = &ves_io_schema.Empty{}
					requestConstraints.MaxHeaderKeySizeChoice = maxHeaderKeySizeChoiceInt
				}

			}

			maxHeaderValueSizeChoiceTypeFound := false

			if v, ok := requestConstraintsMapStrToI["max_header_value_size_exceeds"]; ok && !isIntfNil(v) && !maxHeaderValueSizeChoiceTypeFound {

				maxHeaderValueSizeChoiceTypeFound = true
				maxHeaderValueSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxHeaderValueSizeExceeds{}

				requestConstraints.MaxHeaderValueSizeChoice = maxHeaderValueSizeChoiceInt

				maxHeaderValueSizeChoiceInt.MaxHeaderValueSizeExceeds = uint32(v.(int))

			}

			if v, ok := requestConstraintsMapStrToI["max_header_value_size_none"]; ok && !isIntfNil(v) && !maxHeaderValueSizeChoiceTypeFound {

				maxHeaderValueSizeChoiceTypeFound = true

				if v.(bool) {
					maxHeaderValueSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxHeaderValueSizeNone{}
					maxHeaderValueSizeChoiceInt.MaxHeaderValueSizeNone = &ves_io_schema.Empty{}
					requestConstraints.MaxHeaderValueSizeChoice = maxHeaderValueSizeChoiceInt
				}

			}

			maxParameterCountChoiceTypeFound := false

			if v, ok := requestConstraintsMapStrToI["max_parameter_count_exceeds"]; ok && !isIntfNil(v) && !maxParameterCountChoiceTypeFound {

				maxParameterCountChoiceTypeFound = true
				maxParameterCountChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxParameterCountExceeds{}

				requestConstraints.MaxParameterCountChoice = maxParameterCountChoiceInt

				maxParameterCountChoiceInt.MaxParameterCountExceeds = uint32(v.(int))

			}

			if v, ok := requestConstraintsMapStrToI["max_parameter_count_none"]; ok && !isIntfNil(v) && !maxParameterCountChoiceTypeFound {

				maxParameterCountChoiceTypeFound = true

				if v.(bool) {
					maxParameterCountChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxParameterCountNone{}
					maxParameterCountChoiceInt.MaxParameterCountNone = &ves_io_schema.Empty{}
					requestConstraints.MaxParameterCountChoice = maxParameterCountChoiceInt
				}

			}

			maxParameterNameSizeChoiceTypeFound := false

			if v, ok := requestConstraintsMapStrToI["max_parameter_name_size_exceeds"]; ok && !isIntfNil(v) && !maxParameterNameSizeChoiceTypeFound {

				maxParameterNameSizeChoiceTypeFound = true
				maxParameterNameSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxParameterNameSizeExceeds{}

				requestConstraints.MaxParameterNameSizeChoice = maxParameterNameSizeChoiceInt

				maxParameterNameSizeChoiceInt.MaxParameterNameSizeExceeds = uint32(v.(int))

			}

			if v, ok := requestConstraintsMapStrToI["max_parameter_name_size_none"]; ok && !isIntfNil(v) && !maxParameterNameSizeChoiceTypeFound {

				maxParameterNameSizeChoiceTypeFound = true

				if v.(bool) {
					maxParameterNameSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxParameterNameSizeNone{}
					maxParameterNameSizeChoiceInt.MaxParameterNameSizeNone = &ves_io_schema.Empty{}
					requestConstraints.MaxParameterNameSizeChoice = maxParameterNameSizeChoiceInt
				}

			}

			maxParameterValueSizeChoiceTypeFound := false

			if v, ok := requestConstraintsMapStrToI["max_parameter_value_size_exceeds"]; ok && !isIntfNil(v) && !maxParameterValueSizeChoiceTypeFound {

				maxParameterValueSizeChoiceTypeFound = true
				maxParameterValueSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxParameterValueSizeExceeds{}

				requestConstraints.MaxParameterValueSizeChoice = maxParameterValueSizeChoiceInt

				maxParameterValueSizeChoiceInt.MaxParameterValueSizeExceeds = uint32(v.(int))

			}

			if v, ok := requestConstraintsMapStrToI["max_parameter_value_size_none"]; ok && !isIntfNil(v) && !maxParameterValueSizeChoiceTypeFound {

				maxParameterValueSizeChoiceTypeFound = true

				if v.(bool) {
					maxParameterValueSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxParameterValueSizeNone{}
					maxParameterValueSizeChoiceInt.MaxParameterValueSizeNone = &ves_io_schema.Empty{}
					requestConstraints.MaxParameterValueSizeChoice = maxParameterValueSizeChoiceInt
				}

			}

			maxQuerySizeChoiceTypeFound := false

			if v, ok := requestConstraintsMapStrToI["max_query_size_exceeds"]; ok && !isIntfNil(v) && !maxQuerySizeChoiceTypeFound {

				maxQuerySizeChoiceTypeFound = true
				maxQuerySizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxQuerySizeExceeds{}

				requestConstraints.MaxQuerySizeChoice = maxQuerySizeChoiceInt

				maxQuerySizeChoiceInt.MaxQuerySizeExceeds = uint32(v.(int))

			}

			if v, ok := requestConstraintsMapStrToI["max_query_size_none"]; ok && !isIntfNil(v) && !maxQuerySizeChoiceTypeFound {

				maxQuerySizeChoiceTypeFound = true

				if v.(bool) {
					maxQuerySizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxQuerySizeNone{}
					maxQuerySizeChoiceInt.MaxQuerySizeNone = &ves_io_schema.Empty{}
					requestConstraints.MaxQuerySizeChoice = maxQuerySizeChoiceInt
				}

			}

			maxRequestLineSizeChoiceTypeFound := false

			if v, ok := requestConstraintsMapStrToI["max_request_line_size_exceeds"]; ok && !isIntfNil(v) && !maxRequestLineSizeChoiceTypeFound {

				maxRequestLineSizeChoiceTypeFound = true
				maxRequestLineSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxRequestLineSizeExceeds{}

				requestConstraints.MaxRequestLineSizeChoice = maxRequestLineSizeChoiceInt

				maxRequestLineSizeChoiceInt.MaxRequestLineSizeExceeds = uint32(v.(int))

			}

			if v, ok := requestConstraintsMapStrToI["max_request_line_size_none"]; ok && !isIntfNil(v) && !maxRequestLineSizeChoiceTypeFound {

				maxRequestLineSizeChoiceTypeFound = true

				if v.(bool) {
					maxRequestLineSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxRequestLineSizeNone{}
					maxRequestLineSizeChoiceInt.MaxRequestLineSizeNone = &ves_io_schema.Empty{}
					requestConstraints.MaxRequestLineSizeChoice = maxRequestLineSizeChoiceInt
				}

			}

			maxRequestSizeChoiceTypeFound := false

			if v, ok := requestConstraintsMapStrToI["max_request_size_exceeds"]; ok && !isIntfNil(v) && !maxRequestSizeChoiceTypeFound {

				maxRequestSizeChoiceTypeFound = true
				maxRequestSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxRequestSizeExceeds{}

				requestConstraints.MaxRequestSizeChoice = maxRequestSizeChoiceInt

				maxRequestSizeChoiceInt.MaxRequestSizeExceeds = uint32(v.(int))

			}

			if v, ok := requestConstraintsMapStrToI["max_request_size_none"]; ok && !isIntfNil(v) && !maxRequestSizeChoiceTypeFound {

				maxRequestSizeChoiceTypeFound = true

				if v.(bool) {
					maxRequestSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxRequestSizeNone{}
					maxRequestSizeChoiceInt.MaxRequestSizeNone = &ves_io_schema.Empty{}
					requestConstraints.MaxRequestSizeChoice = maxRequestSizeChoiceInt
				}

			}

			maxUrlSizeChoiceTypeFound := false

			if v, ok := requestConstraintsMapStrToI["max_url_size_exceeds"]; ok && !isIntfNil(v) && !maxUrlSizeChoiceTypeFound {

				maxUrlSizeChoiceTypeFound = true
				maxUrlSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxUrlSizeExceeds{}

				requestConstraints.MaxUrlSizeChoice = maxUrlSizeChoiceInt

				maxUrlSizeChoiceInt.MaxUrlSizeExceeds = uint32(v.(int))

			}

			if v, ok := requestConstraintsMapStrToI["max_url_size_none"]; ok && !isIntfNil(v) && !maxUrlSizeChoiceTypeFound {

				maxUrlSizeChoiceTypeFound = true

				if v.(bool) {
					maxUrlSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxUrlSizeNone{}
					maxUrlSizeChoiceInt.MaxUrlSizeNone = &ves_io_schema.Empty{}
					requestConstraints.MaxUrlSizeChoice = maxUrlSizeChoiceInt
				}

			}

		}

	}

	//scheme
	if v, ok := d.GetOk("scheme"); ok && !isIntfNil(v) {

		ls := make([]string, len(v.([]interface{})))
		for i, v := range v.([]interface{}) {
			ls[i] = v.(string)
		}
		createSpec.Scheme = ls

	}

	//segment_policy
	if v, ok := d.GetOk("segment_policy"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		segmentPolicy := &ves_io_schema_policy.SegmentPolicyType{}
		createSpec.SegmentPolicy = segmentPolicy
		for _, set := range sl {
			segmentPolicyMapStrToI := set.(map[string]interface{})

			dstSegmentChoiceTypeFound := false

			if v, ok := segmentPolicyMapStrToI["dst_any"]; ok && !isIntfNil(v) && !dstSegmentChoiceTypeFound {

				dstSegmentChoiceTypeFound = true

				if v.(bool) {
					dstSegmentChoiceInt := &ves_io_schema_policy.SegmentPolicyType_DstAny{}
					dstSegmentChoiceInt.DstAny = &ves_io_schema.Empty{}
					segmentPolicy.DstSegmentChoice = dstSegmentChoiceInt
				}

			}

			if v, ok := segmentPolicyMapStrToI["dst_segments"]; ok && !isIntfNil(v) && !dstSegmentChoiceTypeFound {

				dstSegmentChoiceTypeFound = true
				dstSegmentChoiceInt := &ves_io_schema_policy.SegmentPolicyType_DstSegments{}
				dstSegmentChoiceInt.DstSegments = &ves_io_schema_views.SegmentRefList{}
				segmentPolicy.DstSegmentChoice = dstSegmentChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["segments"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						segmentsInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						dstSegmentChoiceInt.DstSegments.Segments = segmentsInt
						for i, ps := range sl {

							sMapToStrVal := ps.(map[string]interface{})
							segmentsInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := sMapToStrVal["name"]; ok && !isIntfNil(v) {
								segmentsInt[i].Name = v.(string)
							}

							if v, ok := sMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								segmentsInt[i].Namespace = v.(string)
							}

							if v, ok := sMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								segmentsInt[i].Tenant = v.(string)
							}

						}

					}

				}

			}

			if v, ok := segmentPolicyMapStrToI["intra_segment"]; ok && !isIntfNil(v) && !dstSegmentChoiceTypeFound {

				dstSegmentChoiceTypeFound = true

				if v.(bool) {
					dstSegmentChoiceInt := &ves_io_schema_policy.SegmentPolicyType_IntraSegment{}
					dstSegmentChoiceInt.IntraSegment = &ves_io_schema.Empty{}
					segmentPolicy.DstSegmentChoice = dstSegmentChoiceInt
				}

			}

			srcSegmentChoiceTypeFound := false

			if v, ok := segmentPolicyMapStrToI["src_any"]; ok && !isIntfNil(v) && !srcSegmentChoiceTypeFound {

				srcSegmentChoiceTypeFound = true

				if v.(bool) {
					srcSegmentChoiceInt := &ves_io_schema_policy.SegmentPolicyType_SrcAny{}
					srcSegmentChoiceInt.SrcAny = &ves_io_schema.Empty{}
					segmentPolicy.SrcSegmentChoice = srcSegmentChoiceInt
				}

			}

			if v, ok := segmentPolicyMapStrToI["src_segments"]; ok && !isIntfNil(v) && !srcSegmentChoiceTypeFound {

				srcSegmentChoiceTypeFound = true
				srcSegmentChoiceInt := &ves_io_schema_policy.SegmentPolicyType_SrcSegments{}
				srcSegmentChoiceInt.SrcSegments = &ves_io_schema_views.SegmentRefList{}
				segmentPolicy.SrcSegmentChoice = srcSegmentChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["segments"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						segmentsInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						srcSegmentChoiceInt.SrcSegments.Segments = segmentsInt
						for i, ps := range sl {

							sMapToStrVal := ps.(map[string]interface{})
							segmentsInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := sMapToStrVal["name"]; ok && !isIntfNil(v) {
								segmentsInt[i].Name = v.(string)
							}

							if v, ok := sMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								segmentsInt[i].Namespace = v.(string)
							}

							if v, ok := sMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								segmentsInt[i].Tenant = v.(string)
							}

						}

					}

				}

			}

		}

	}

	//server_selector
	if v, ok := d.GetOk("server_selector"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		serverSelector := &ves_io_schema.LabelSelectorType{}
		createSpec.ServerSelector = serverSelector
		for _, set := range sl {
			serverSelectorMapStrToI := set.(map[string]interface{})

			if w, ok := serverSelectorMapStrToI["expressions"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				serverSelector.Expressions = ls
			}

		}

	}

	//shape_protected_endpoint_action
	if v, ok := d.GetOk("shape_protected_endpoint_action"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		shapeProtectedEndpointAction := &ves_io_schema_policy.ShapeProtectedEndpointAction{}
		createSpec.ShapeProtectedEndpointAction = shapeProtectedEndpointAction
		for _, set := range sl {
			shapeProtectedEndpointActionMapStrToI := set.(map[string]interface{})

			if w, ok := shapeProtectedEndpointActionMapStrToI["allow_goodbot"]; ok && !isIntfNil(w) {
				shapeProtectedEndpointAction.AllowGoodbot = w.(bool)
			}

			if v, ok := shapeProtectedEndpointActionMapStrToI["app_traffic_type"]; ok && !isIntfNil(v) {

				shapeProtectedEndpointAction.AppTrafficType = ves_io_schema_policy.AppTrafficType(ves_io_schema_policy.AppTrafficType_value[v.(string)])

			}

			if w, ok := shapeProtectedEndpointActionMapStrToI["flow_label"]; ok && !isIntfNil(w) {
				shapeProtectedEndpointAction.FlowLabel = w.(string)
			}

			if v, ok := shapeProtectedEndpointActionMapStrToI["mitigation"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				mitigation := &ves_io_schema_policy.ShapeBotMitigationAction{}
				shapeProtectedEndpointAction.Mitigation = mitigation
				for _, set := range sl {
					mitigationMapStrToI := set.(map[string]interface{})

					actionTypeTypeFound := false

					if v, ok := mitigationMapStrToI["block"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

						actionTypeTypeFound = true
						actionTypeInt := &ves_io_schema_policy.ShapeBotMitigationAction_Block{}
						actionTypeInt.Block = &ves_io_schema_policy.ShapeBotBlockMitigationActionType{}
						mitigation.ActionType = actionTypeInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["body"]; ok && !isIntfNil(v) {

								actionTypeInt.Block.Body = v.(string)

							}

							if v, ok := cs["body_hash"]; ok && !isIntfNil(v) {

								actionTypeInt.Block.BodyHash = v.(string)

							}

							if v, ok := cs["status"]; ok && !isIntfNil(v) {

								actionTypeInt.Block.Status = ves_io_schema.HttpStatusCode(ves_io_schema.HttpStatusCode_value[v.(string)])

							}

						}

					}

					if v, ok := mitigationMapStrToI["flag"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

						actionTypeTypeFound = true
						actionTypeInt := &ves_io_schema_policy.ShapeBotMitigationAction_Flag{}
						actionTypeInt.Flag = &ves_io_schema_policy.ShapeBotFlagMitigationActionChoiceType{}
						mitigation.ActionType = actionTypeInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							sendHeadersChoiceTypeFound := false

							if v, ok := cs["append_headers"]; ok && !isIntfNil(v) && !sendHeadersChoiceTypeFound {

								sendHeadersChoiceTypeFound = true
								sendHeadersChoiceInt := &ves_io_schema_policy.ShapeBotFlagMitigationActionChoiceType_AppendHeaders{}
								sendHeadersChoiceInt.AppendHeaders = &ves_io_schema_policy.ShapeBotFlagMitigationActionType{}
								actionTypeInt.Flag.SendHeadersChoice = sendHeadersChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["auto_type_header_name"]; ok && !isIntfNil(v) {

										sendHeadersChoiceInt.AppendHeaders.AutoTypeHeaderName = v.(string)

									}

									if v, ok := cs["inference_header_name"]; ok && !isIntfNil(v) {

										sendHeadersChoiceInt.AppendHeaders.InferenceHeaderName = v.(string)

									}

								}

							}

							if v, ok := cs["no_headers"]; ok && !isIntfNil(v) && !sendHeadersChoiceTypeFound {

								sendHeadersChoiceTypeFound = true

								if v.(bool) {
									sendHeadersChoiceInt := &ves_io_schema_policy.ShapeBotFlagMitigationActionChoiceType_NoHeaders{}
									sendHeadersChoiceInt.NoHeaders = &ves_io_schema.Empty{}
									actionTypeInt.Flag.SendHeadersChoice = sendHeadersChoiceInt
								}

							}

						}

					}

					if v, ok := mitigationMapStrToI["none"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

						actionTypeTypeFound = true

						if v.(bool) {
							actionTypeInt := &ves_io_schema_policy.ShapeBotMitigationAction_None{}
							actionTypeInt.None = &ves_io_schema.Empty{}
							mitigation.ActionType = actionTypeInt
						}

					}

					if v, ok := mitigationMapStrToI["redirect"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

						actionTypeTypeFound = true
						actionTypeInt := &ves_io_schema_policy.ShapeBotMitigationAction_Redirect{}
						actionTypeInt.Redirect = &ves_io_schema_policy.ShapeBotRedirectMitigationActionType{}
						mitigation.ActionType = actionTypeInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["uri"]; ok && !isIntfNil(v) {

								actionTypeInt.Redirect.Uri = v.(string)

							}

						}

					}

				}

			}

			if v, ok := shapeProtectedEndpointActionMapStrToI["transaction_result"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				transactionResult := &ves_io_schema.BotDefenseTransactionResultType{}
				shapeProtectedEndpointAction.TransactionResult = transactionResult
				for _, set := range sl {
					transactionResultMapStrToI := set.(map[string]interface{})

					if v, ok := transactionResultMapStrToI["failure_conditions"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						failureConditions := make([]*ves_io_schema.BotDefenseTransactionResultCondition, len(sl))
						transactionResult.FailureConditions = failureConditions
						for i, set := range sl {
							failureConditions[i] = &ves_io_schema.BotDefenseTransactionResultCondition{}
							failureConditionsMapStrToI := set.(map[string]interface{})

							if w, ok := failureConditionsMapStrToI["name"]; ok && !isIntfNil(w) {
								failureConditions[i].Name = w.(string)
							}

							if w, ok := failureConditionsMapStrToI["regex_values"]; ok && !isIntfNil(w) {
								ls := make([]string, len(w.([]interface{})))
								for i, v := range w.([]interface{}) {
									ls[i] = v.(string)
								}
								failureConditions[i].RegexValues = ls
							}

							if v, ok := failureConditionsMapStrToI["status"]; ok && !isIntfNil(v) {

								failureConditions[i].Status = ves_io_schema.HttpStatusCode(ves_io_schema.HttpStatusCode_value[v.(string)])

							}

						}

					}

					if v, ok := transactionResultMapStrToI["success_conditions"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						successConditions := make([]*ves_io_schema.BotDefenseTransactionResultCondition, len(sl))
						transactionResult.SuccessConditions = successConditions
						for i, set := range sl {
							successConditions[i] = &ves_io_schema.BotDefenseTransactionResultCondition{}
							successConditionsMapStrToI := set.(map[string]interface{})

							if w, ok := successConditionsMapStrToI["name"]; ok && !isIntfNil(w) {
								successConditions[i].Name = w.(string)
							}

							if w, ok := successConditionsMapStrToI["regex_values"]; ok && !isIntfNil(w) {
								ls := make([]string, len(w.([]interface{})))
								for i, v := range w.([]interface{}) {
									ls[i] = v.(string)
								}
								successConditions[i].RegexValues = ls
							}

							if v, ok := successConditionsMapStrToI["status"]; ok && !isIntfNil(v) {

								successConditions[i].Status = ves_io_schema.HttpStatusCode(ves_io_schema.HttpStatusCode_value[v.(string)])

							}

						}

					}

				}

			}

			if w, ok := shapeProtectedEndpointActionMapStrToI["web_scraping"]; ok && !isIntfNil(w) {
				shapeProtectedEndpointAction.WebScraping = w.(bool)
			}

		}

	}

	//tls_fingerprint_matcher
	if v, ok := d.GetOk("tls_fingerprint_matcher"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		tlsFingerprintMatcher := &ves_io_schema_policy.TlsFingerprintMatcherType{}
		createSpec.TlsFingerprintMatcher = tlsFingerprintMatcher
		for _, set := range sl {
			tlsFingerprintMatcherMapStrToI := set.(map[string]interface{})

			if v, ok := tlsFingerprintMatcherMapStrToI["classes"]; ok && !isIntfNil(v) {

				classesList := []ves_io_schema_policy.KnownTlsFingerprintClass{}
				for _, j := range v.([]interface{}) {
					classesList = append(classesList, ves_io_schema_policy.KnownTlsFingerprintClass(ves_io_schema_policy.KnownTlsFingerprintClass_value[j.(string)]))
				}
				tlsFingerprintMatcher.Classes = classesList

			}

			if w, ok := tlsFingerprintMatcherMapStrToI["exact_values"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				tlsFingerprintMatcher.ExactValues = ls
			}

			if w, ok := tlsFingerprintMatcherMapStrToI["excluded_values"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				tlsFingerprintMatcher.ExcludedValues = ls
			}

		}

	}

	//url_matcher
	if v, ok := d.GetOk("url_matcher"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		urlMatcher := &ves_io_schema_policy.URLMatcherType{}
		createSpec.UrlMatcher = urlMatcher
		for _, set := range sl {
			urlMatcherMapStrToI := set.(map[string]interface{})

			if w, ok := urlMatcherMapStrToI["invert_matcher"]; ok && !isIntfNil(w) {
				urlMatcher.InvertMatcher = w.(bool)
			}

			if v, ok := urlMatcherMapStrToI["url_items"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				urlItems := make([]*ves_io_schema_policy.URLItem, len(sl))
				urlMatcher.UrlItems = urlItems
				for i, set := range sl {
					urlItems[i] = &ves_io_schema_policy.URLItem{}
					urlItemsMapStrToI := set.(map[string]interface{})

					domainChoiceTypeFound := false

					if v, ok := urlItemsMapStrToI["domain_regex"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

						domainChoiceTypeFound = true
						domainChoiceInt := &ves_io_schema_policy.URLItem_DomainRegex{}

						urlItems[i].DomainChoice = domainChoiceInt

						domainChoiceInt.DomainRegex = v.(string)

					}

					if v, ok := urlItemsMapStrToI["domain_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

						domainChoiceTypeFound = true
						domainChoiceInt := &ves_io_schema_policy.URLItem_DomainValue{}

						urlItems[i].DomainChoice = domainChoiceInt

						domainChoiceInt.DomainValue = v.(string)

					}

					pathChoiceTypeFound := false

					if v, ok := urlItemsMapStrToI["path_prefix"]; ok && !isIntfNil(v) && !pathChoiceTypeFound {

						pathChoiceTypeFound = true
						pathChoiceInt := &ves_io_schema_policy.URLItem_PathPrefix{}

						urlItems[i].PathChoice = pathChoiceInt

						pathChoiceInt.PathPrefix = v.(string)

					}

					if v, ok := urlItemsMapStrToI["path_regex"]; ok && !isIntfNil(v) && !pathChoiceTypeFound {

						pathChoiceTypeFound = true
						pathChoiceInt := &ves_io_schema_policy.URLItem_PathRegex{}

						urlItems[i].PathChoice = pathChoiceInt

						pathChoiceInt.PathRegex = v.(string)

					}

					if v, ok := urlItemsMapStrToI["path_value"]; ok && !isIntfNil(v) && !pathChoiceTypeFound {

						pathChoiceTypeFound = true
						pathChoiceInt := &ves_io_schema_policy.URLItem_PathValue{}

						urlItems[i].PathChoice = pathChoiceInt

						pathChoiceInt.PathValue = v.(string)

					}

				}

			}

		}

	}

	//virtual_host_matcher
	if v, ok := d.GetOk("virtual_host_matcher"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		virtualHostMatcher := &ves_io_schema_policy.MatcherTypeBasic{}
		createSpec.VirtualHostMatcher = virtualHostMatcher
		for _, set := range sl {
			virtualHostMatcherMapStrToI := set.(map[string]interface{})

			if w, ok := virtualHostMatcherMapStrToI["exact_values"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				virtualHostMatcher.ExactValues = ls
			}

			if w, ok := virtualHostMatcherMapStrToI["regex_values"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				virtualHostMatcher.RegexValues = ls
			}

		}

	}

	//waf_action
	if v, ok := d.GetOk("waf_action"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		wafAction := &ves_io_schema_policy.WafAction{}
		createSpec.WafAction = wafAction
		for _, set := range sl {
			wafActionMapStrToI := set.(map[string]interface{})

			actionTypeTypeFound := false

			if v, ok := wafActionMapStrToI["app_firewall_detection_control"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

				actionTypeTypeFound = true
				actionTypeInt := &ves_io_schema_policy.WafAction_AppFirewallDetectionControl{}
				actionTypeInt.AppFirewallDetectionControl = &ves_io_schema_policy.AppFirewallDetectionControl{}
				wafAction.ActionType = actionTypeInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["exclude_attack_type_contexts"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						excludeAttackTypeContexts := make([]*ves_io_schema_policy.AppFirewallAttackTypeContext, len(sl))
						actionTypeInt.AppFirewallDetectionControl.ExcludeAttackTypeContexts = excludeAttackTypeContexts
						for i, set := range sl {
							excludeAttackTypeContexts[i] = &ves_io_schema_policy.AppFirewallAttackTypeContext{}
							excludeAttackTypeContextsMapStrToI := set.(map[string]interface{})

							if v, ok := excludeAttackTypeContextsMapStrToI["context"]; ok && !isIntfNil(v) {

								excludeAttackTypeContexts[i].Context = ves_io_schema_policy.DetectionContext(ves_io_schema_policy.DetectionContext_value[v.(string)])

							}

							if w, ok := excludeAttackTypeContextsMapStrToI["context_name"]; ok && !isIntfNil(w) {
								excludeAttackTypeContexts[i].ContextName = w.(string)
							}

							if v, ok := excludeAttackTypeContextsMapStrToI["exclude_attack_type"]; ok && !isIntfNil(v) {

								excludeAttackTypeContexts[i].ExcludeAttackType = ves_io_schema_app_firewall.AttackType(ves_io_schema_app_firewall.AttackType_value[v.(string)])

							}

						}

					}

					if v, ok := cs["exclude_bot_name_contexts"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						excludeBotNameContexts := make([]*ves_io_schema_policy.BotNameContext, len(sl))
						actionTypeInt.AppFirewallDetectionControl.ExcludeBotNameContexts = excludeBotNameContexts
						for i, set := range sl {
							excludeBotNameContexts[i] = &ves_io_schema_policy.BotNameContext{}
							excludeBotNameContextsMapStrToI := set.(map[string]interface{})

							if w, ok := excludeBotNameContextsMapStrToI["bot_name"]; ok && !isIntfNil(w) {
								excludeBotNameContexts[i].BotName = w.(string)
							}

						}

					}

					if v, ok := cs["exclude_signature_contexts"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						excludeSignatureContexts := make([]*ves_io_schema_policy.AppFirewallSignatureContext, len(sl))
						actionTypeInt.AppFirewallDetectionControl.ExcludeSignatureContexts = excludeSignatureContexts
						for i, set := range sl {
							excludeSignatureContexts[i] = &ves_io_schema_policy.AppFirewallSignatureContext{}
							excludeSignatureContextsMapStrToI := set.(map[string]interface{})

							if v, ok := excludeSignatureContextsMapStrToI["context"]; ok && !isIntfNil(v) {

								excludeSignatureContexts[i].Context = ves_io_schema_policy.DetectionContext(ves_io_schema_policy.DetectionContext_value[v.(string)])

							}

							if w, ok := excludeSignatureContextsMapStrToI["context_name"]; ok && !isIntfNil(w) {
								excludeSignatureContexts[i].ContextName = w.(string)
							}

							if w, ok := excludeSignatureContextsMapStrToI["signature_id"]; ok && !isIntfNil(w) {
								excludeSignatureContexts[i].SignatureId = uint32(w.(int))
							}

						}

					}

					if v, ok := cs["exclude_violation_contexts"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						excludeViolationContexts := make([]*ves_io_schema_policy.AppFirewallViolationContext, len(sl))
						actionTypeInt.AppFirewallDetectionControl.ExcludeViolationContexts = excludeViolationContexts
						for i, set := range sl {
							excludeViolationContexts[i] = &ves_io_schema_policy.AppFirewallViolationContext{}
							excludeViolationContextsMapStrToI := set.(map[string]interface{})

							if v, ok := excludeViolationContextsMapStrToI["context"]; ok && !isIntfNil(v) {

								excludeViolationContexts[i].Context = ves_io_schema_policy.DetectionContext(ves_io_schema_policy.DetectionContext_value[v.(string)])

							}

							if w, ok := excludeViolationContextsMapStrToI["context_name"]; ok && !isIntfNil(w) {
								excludeViolationContexts[i].ContextName = w.(string)
							}

							if v, ok := excludeViolationContextsMapStrToI["exclude_violation"]; ok && !isIntfNil(v) {

								excludeViolationContexts[i].ExcludeViolation = ves_io_schema_app_firewall.AppFirewallViolationType(ves_io_schema_app_firewall.AppFirewallViolationType_value[v.(string)])

							}

						}

					}

				}

			}

			if v, ok := wafActionMapStrToI["data_guard_control"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

				actionTypeTypeFound = true
				actionTypeInt := &ves_io_schema_policy.WafAction_DataGuardControl{}
				actionTypeInt.DataGuardControl = &ves_io_schema_policy.DataGuardControl{}
				wafAction.ActionType = actionTypeInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["policy_name"]; ok && !isIntfNil(v) {

						actionTypeInt.DataGuardControl.PolicyName = v.(string)

					}

				}

			}

			if v, ok := wafActionMapStrToI["jwt_claims_validation"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

				actionTypeTypeFound = true

				if v.(bool) {
					actionTypeInt := &ves_io_schema_policy.WafAction_JwtClaimsValidation{}
					actionTypeInt.JwtClaimsValidation = &ves_io_schema.Empty{}
					wafAction.ActionType = actionTypeInt
				}

			}

			if v, ok := wafActionMapStrToI["jwt_validation"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

				actionTypeTypeFound = true

				if v.(bool) {
					actionTypeInt := &ves_io_schema_policy.WafAction_JwtValidation{}
					actionTypeInt.JwtValidation = &ves_io_schema.Empty{}
					wafAction.ActionType = actionTypeInt
				}

			}

			if v, ok := wafActionMapStrToI["none"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

				actionTypeTypeFound = true

				if v.(bool) {
					actionTypeInt := &ves_io_schema_policy.WafAction_None{}
					actionTypeInt.None = &ves_io_schema.Empty{}
					wafAction.ActionType = actionTypeInt
				}

			}

			if v, ok := wafActionMapStrToI["waf_in_monitoring_mode"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

				actionTypeTypeFound = true

				if v.(bool) {
					actionTypeInt := &ves_io_schema_policy.WafAction_WafInMonitoringMode{}
					actionTypeInt.WafInMonitoringMode = &ves_io_schema.Empty{}
					wafAction.ActionType = actionTypeInt
				}

			}

			if v, ok := wafActionMapStrToI["waf_skip_processing"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

				actionTypeTypeFound = true

				if v.(bool) {
					actionTypeInt := &ves_io_schema_policy.WafAction_WafSkipProcessing{}
					actionTypeInt.WafSkipProcessing = &ves_io_schema.Empty{}
					wafAction.ActionType = actionTypeInt
				}

			}

		}

	}

	log.Printf("[DEBUG] Creating Volterra ServicePolicyRule object with struct: %+v", createReq)

	createServicePolicyRuleResp, err := client.CreateObject(context.Background(), ves_io_schema_service_policy_rule.ObjectType, createReq)
	if err != nil {
		return fmt.Errorf("error creating ServicePolicyRule: %s", err)
	}
	d.SetId(createServicePolicyRuleResp.GetObjSystemMetadata().GetUid())

	return resourceVolterraServicePolicyRuleRead(d, meta)
}

func resourceVolterraServicePolicyRuleRead(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	resp, err := client.GetObject(context.Background(), ves_io_schema_service_policy_rule.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] ServicePolicyRule %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra ServicePolicyRule %q: %s", d.Id(), err)
	}
	return setServicePolicyRuleFields(client, d, resp)
}

func setServicePolicyRuleFields(client *APIClient, d *schema.ResourceData, resp vesapi.GetObjectResponse) error {
	metadata := resp.GetObjMetadata()

	d.Set("annotations", metadata.GetAnnotations())

	d.Set("description", metadata.GetDescription())

	d.Set("disable", metadata.GetDisable())

	d.Set("labels", metadata.GetLabels())

	d.Set("name", metadata.GetName())

	d.Set("namespace", metadata.GetNamespace())

	return nil
}

// resourceVolterraServicePolicyRuleUpdate updates ServicePolicyRule resource
func resourceVolterraServicePolicyRuleUpdate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	updateMeta := &ves_io_schema.ObjectReplaceMetaType{}
	updateSpec := &ves_io_schema_service_policy_rule.ReplaceSpecType{}
	updateReq := &ves_io_schema_service_policy_rule.ReplaceRequest{
		Metadata: updateMeta,
		Spec:     updateSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		updateMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		updateMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		updateMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		updateMeta.Namespace =
			v.(string)
	}

	if v, ok := d.GetOk("action"); ok && !isIntfNil(v) {

		updateSpec.Action = ves_io_schema_policy.RuleAction(ves_io_schema_policy.RuleAction_value[v.(string)])

	}

	if v, ok := d.GetOk("api_group_matcher"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		apiGroupMatcher := &ves_io_schema_policy.StringMatcherType{}
		updateSpec.ApiGroupMatcher = apiGroupMatcher
		for _, set := range sl {
			apiGroupMatcherMapStrToI := set.(map[string]interface{})

			if w, ok := apiGroupMatcherMapStrToI["invert_matcher"]; ok && !isIntfNil(w) {
				apiGroupMatcher.InvertMatcher = w.(bool)
			}

			if w, ok := apiGroupMatcherMapStrToI["match"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				apiGroupMatcher.Match = ls
			}

		}

	}

	if v, ok := d.GetOk("arg_matchers"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		argMatchers := make([]*ves_io_schema_policy.ArgMatcherType, len(sl))
		updateSpec.ArgMatchers = argMatchers
		for i, set := range sl {
			argMatchers[i] = &ves_io_schema_policy.ArgMatcherType{}
			argMatchersMapStrToI := set.(map[string]interface{})

			if w, ok := argMatchersMapStrToI["invert_matcher"]; ok && !isIntfNil(w) {
				argMatchers[i].InvertMatcher = w.(bool)
			}

			matchTypeFound := false

			if v, ok := argMatchersMapStrToI["check_not_present"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true

				if v.(bool) {
					matchInt := &ves_io_schema_policy.ArgMatcherType_CheckNotPresent{}
					matchInt.CheckNotPresent = &ves_io_schema.Empty{}
					argMatchers[i].Match = matchInt
				}

			}

			if v, ok := argMatchersMapStrToI["check_present"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true

				if v.(bool) {
					matchInt := &ves_io_schema_policy.ArgMatcherType_CheckPresent{}
					matchInt.CheckPresent = &ves_io_schema.Empty{}
					argMatchers[i].Match = matchInt
				}

			}

			if v, ok := argMatchersMapStrToI["item"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true
				matchInt := &ves_io_schema_policy.ArgMatcherType_Item{}
				matchInt.Item = &ves_io_schema_policy.MatcherType{}
				argMatchers[i].Match = matchInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["exact_values"]; ok && !isIntfNil(v) {

						ls := make([]string, len(v.([]interface{})))
						for i, v := range v.([]interface{}) {
							ls[i] = v.(string)
						}
						matchInt.Item.ExactValues = ls

					}

					if v, ok := cs["regex_values"]; ok && !isIntfNil(v) {

						ls := make([]string, len(v.([]interface{})))
						for i, v := range v.([]interface{}) {
							ls[i] = v.(string)
						}
						matchInt.Item.RegexValues = ls

					}

					if v, ok := cs["transformers"]; ok && !isIntfNil(v) {

						transformersList := []ves_io_schema_policy.Transformer{}
						for _, j := range v.([]interface{}) {
							transformersList = append(transformersList, ves_io_schema_policy.Transformer(ves_io_schema_policy.Transformer_value[j.(string)]))
						}
						matchInt.Item.Transformers = transformersList

					}

				}

			}

			if v, ok := argMatchersMapStrToI["presence"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true
				matchInt := &ves_io_schema_policy.ArgMatcherType_Presence{}

				argMatchers[i].Match = matchInt

				matchInt.Presence = v.(bool)

			}

			if w, ok := argMatchersMapStrToI["name"]; ok && !isIntfNil(w) {
				argMatchers[i].Name = w.(string)
			}

		}

	}

	asnChoiceTypeFound := false

	if v, ok := d.GetOk("any_asn"); ok && !asnChoiceTypeFound {

		asnChoiceTypeFound = true

		if v.(bool) {
			asnChoiceInt := &ves_io_schema_service_policy_rule.ReplaceSpecType_AnyAsn{}
			asnChoiceInt.AnyAsn = &ves_io_schema.Empty{}
			updateSpec.AsnChoice = asnChoiceInt
		}

	}

	if v, ok := d.GetOk("asn_list"); ok && !asnChoiceTypeFound {

		asnChoiceTypeFound = true
		asnChoiceInt := &ves_io_schema_service_policy_rule.ReplaceSpecType_AsnList{}
		asnChoiceInt.AsnList = &ves_io_schema_policy.AsnMatchList{}
		updateSpec.AsnChoice = asnChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["as_numbers"]; ok && !isIntfNil(v) {

				ls := make([]uint32, len(v.([]interface{})))
				for i, v := range v.([]interface{}) {
					ls[i] = uint32(v.(int))
				}
				asnChoiceInt.AsnList.AsNumbers = ls

			}

		}

	}

	if v, ok := d.GetOk("asn_matcher"); ok && !asnChoiceTypeFound {

		asnChoiceTypeFound = true
		asnChoiceInt := &ves_io_schema_service_policy_rule.ReplaceSpecType_AsnMatcher{}
		asnChoiceInt.AsnMatcher = &ves_io_schema_policy.AsnMatcherType{}
		updateSpec.AsnChoice = asnChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["asn_sets"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				asnSetsInt := make([]*ves_io_schema.ObjectRefType, len(sl))
				asnChoiceInt.AsnMatcher.AsnSets = asnSetsInt
				for i, ps := range sl {

					asMapToStrVal := ps.(map[string]interface{})
					asnSetsInt[i] = &ves_io_schema.ObjectRefType{}

					asnSetsInt[i].Kind = "bgp_asn_set"

					if v, ok := asMapToStrVal["name"]; ok && !isIntfNil(v) {
						asnSetsInt[i].Name = v.(string)
					}

					if v, ok := asMapToStrVal["namespace"]; ok && !isIntfNil(v) {
						asnSetsInt[i].Namespace = v.(string)
					}

					if v, ok := asMapToStrVal["tenant"]; ok && !isIntfNil(v) {
						asnSetsInt[i].Tenant = v.(string)
					}

					if v, ok := asMapToStrVal["uid"]; ok && !isIntfNil(v) {
						asnSetsInt[i].Uid = v.(string)
					}

				}

			}

		}

	}

	if v, ok := d.GetOk("body_matcher"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		bodyMatcher := &ves_io_schema_policy.MatcherType{}
		updateSpec.BodyMatcher = bodyMatcher
		for _, set := range sl {
			bodyMatcherMapStrToI := set.(map[string]interface{})

			if w, ok := bodyMatcherMapStrToI["exact_values"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				bodyMatcher.ExactValues = ls
			}

			if w, ok := bodyMatcherMapStrToI["regex_values"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				bodyMatcher.RegexValues = ls
			}

			if v, ok := bodyMatcherMapStrToI["transformers"]; ok && !isIntfNil(v) {

				transformersList := []ves_io_schema_policy.Transformer{}
				for _, j := range v.([]interface{}) {
					transformersList = append(transformersList, ves_io_schema_policy.Transformer(ves_io_schema_policy.Transformer_value[j.(string)]))
				}
				bodyMatcher.Transformers = transformersList

			}

		}

	}

	if v, ok := d.GetOk("bot_action"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		botAction := &ves_io_schema_policy.BotAction{}
		updateSpec.BotAction = botAction
		for _, set := range sl {
			botActionMapStrToI := set.(map[string]interface{})

			actionTypeTypeFound := false

			if v, ok := botActionMapStrToI["bot_skip_processing"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

				actionTypeTypeFound = true

				if v.(bool) {
					actionTypeInt := &ves_io_schema_policy.BotAction_BotSkipProcessing{}
					actionTypeInt.BotSkipProcessing = &ves_io_schema.Empty{}
					botAction.ActionType = actionTypeInt
				}

			}

			if v, ok := botActionMapStrToI["none"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

				actionTypeTypeFound = true

				if v.(bool) {
					actionTypeInt := &ves_io_schema_policy.BotAction_None{}
					actionTypeInt.None = &ves_io_schema.Empty{}
					botAction.ActionType = actionTypeInt
				}

			}

		}

	}

	if v, ok := d.GetOk("challenge_action"); ok && !isIntfNil(v) {

		updateSpec.ChallengeAction = ves_io_schema_policy.ChallengeAction(ves_io_schema_policy.ChallengeAction_value[v.(string)])

	}

	clientChoiceTypeFound := false

	if v, ok := d.GetOk("any_client"); ok && !clientChoiceTypeFound {

		clientChoiceTypeFound = true

		if v.(bool) {
			clientChoiceInt := &ves_io_schema_service_policy_rule.ReplaceSpecType_AnyClient{}
			clientChoiceInt.AnyClient = &ves_io_schema.Empty{}
			updateSpec.ClientChoice = clientChoiceInt
		}

	}

	if v, ok := d.GetOk("client_name"); ok && !clientChoiceTypeFound {

		clientChoiceTypeFound = true
		clientChoiceInt := &ves_io_schema_service_policy_rule.ReplaceSpecType_ClientName{}

		updateSpec.ClientChoice = clientChoiceInt

		clientChoiceInt.ClientName = v.(string)

	}

	if v, ok := d.GetOk("client_name_matcher"); ok && !clientChoiceTypeFound {

		clientChoiceTypeFound = true
		clientChoiceInt := &ves_io_schema_service_policy_rule.ReplaceSpecType_ClientNameMatcher{}
		clientChoiceInt.ClientNameMatcher = &ves_io_schema_policy.MatcherTypeBasic{}
		updateSpec.ClientChoice = clientChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["exact_values"]; ok && !isIntfNil(v) {

				ls := make([]string, len(v.([]interface{})))
				for i, v := range v.([]interface{}) {
					ls[i] = v.(string)
				}
				clientChoiceInt.ClientNameMatcher.ExactValues = ls

			}

			if v, ok := cs["regex_values"]; ok && !isIntfNil(v) {

				ls := make([]string, len(v.([]interface{})))
				for i, v := range v.([]interface{}) {
					ls[i] = v.(string)
				}
				clientChoiceInt.ClientNameMatcher.RegexValues = ls

			}

		}

	}

	if v, ok := d.GetOk("client_selector"); ok && !clientChoiceTypeFound {

		clientChoiceTypeFound = true
		clientChoiceInt := &ves_io_schema_service_policy_rule.ReplaceSpecType_ClientSelector{}
		clientChoiceInt.ClientSelector = &ves_io_schema.LabelSelectorType{}
		updateSpec.ClientChoice = clientChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["expressions"]; ok && !isIntfNil(v) {

				ls := make([]string, len(v.([]interface{})))
				for i, v := range v.([]interface{}) {
					ls[i] = v.(string)
				}
				clientChoiceInt.ClientSelector.Expressions = ls

			}

		}

	}

	if v, ok := d.GetOk("ip_threat_category_list"); ok && !clientChoiceTypeFound {

		clientChoiceTypeFound = true
		clientChoiceInt := &ves_io_schema_service_policy_rule.ReplaceSpecType_IpThreatCategoryList{}
		clientChoiceInt.IpThreatCategoryList = &ves_io_schema_service_policy_rule.IPThreatCategoryListType{}
		updateSpec.ClientChoice = clientChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["ip_threat_categories"]; ok && !isIntfNil(v) {

				ip_threat_categoriesList := []ves_io_schema_policy.IPThreatCategory{}
				for _, j := range v.([]interface{}) {
					ip_threat_categoriesList = append(ip_threat_categoriesList, ves_io_schema_policy.IPThreatCategory(ves_io_schema_policy.IPThreatCategory_value[j.(string)]))
				}
				clientChoiceInt.IpThreatCategoryList.IpThreatCategories = ip_threat_categoriesList

			}

		}

	}

	if v, ok := d.GetOk("client_role"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		clientRole := &ves_io_schema_policy.RoleMatcherType{}
		updateSpec.ClientRole = clientRole
		for _, set := range sl {
			clientRoleMapStrToI := set.(map[string]interface{})

			if w, ok := clientRoleMapStrToI["match"]; ok && !isIntfNil(w) {
				clientRole.Match = w.(string)
			}

		}

	}

	if v, ok := d.GetOk("content_rewrite_action"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		contentRewriteAction := &ves_io_schema_policy.ContentRewriteAction{}
		updateSpec.ContentRewriteAction = contentRewriteAction
		for _, set := range sl {
			contentRewriteActionMapStrToI := set.(map[string]interface{})

			if w, ok := contentRewriteActionMapStrToI["element_selector"]; ok && !isIntfNil(w) {
				contentRewriteAction.ElementSelector = w.(string)
			}

			if w, ok := contentRewriteActionMapStrToI["insert_content"]; ok && !isIntfNil(w) {
				contentRewriteAction.InsertContent = w.(string)
			}

			if w, ok := contentRewriteActionMapStrToI["inserted_types"]; ok && !isIntfNil(w) {
				ms := map[string]bool{}
				for k, v := range w.(map[string]interface{}) {
					ms[k] = v.(bool)
				}
				contentRewriteAction.InsertedTypes = ms
			}

			if v, ok := contentRewriteActionMapStrToI["position"]; ok && !isIntfNil(v) {

				contentRewriteAction.Position = ves_io_schema_policy.HTMLPosition(ves_io_schema_policy.HTMLPosition_value[v.(string)])

			}

		}

	}

	if v, ok := d.GetOk("cookie_matchers"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		cookieMatchers := make([]*ves_io_schema_policy.CookieMatcherType, len(sl))
		updateSpec.CookieMatchers = cookieMatchers
		for i, set := range sl {
			cookieMatchers[i] = &ves_io_schema_policy.CookieMatcherType{}
			cookieMatchersMapStrToI := set.(map[string]interface{})

			if w, ok := cookieMatchersMapStrToI["invert_matcher"]; ok && !isIntfNil(w) {
				cookieMatchers[i].InvertMatcher = w.(bool)
			}

			matchTypeFound := false

			if v, ok := cookieMatchersMapStrToI["check_not_present"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true

				if v.(bool) {
					matchInt := &ves_io_schema_policy.CookieMatcherType_CheckNotPresent{}
					matchInt.CheckNotPresent = &ves_io_schema.Empty{}
					cookieMatchers[i].Match = matchInt
				}

			}

			if v, ok := cookieMatchersMapStrToI["check_present"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true

				if v.(bool) {
					matchInt := &ves_io_schema_policy.CookieMatcherType_CheckPresent{}
					matchInt.CheckPresent = &ves_io_schema.Empty{}
					cookieMatchers[i].Match = matchInt
				}

			}

			if v, ok := cookieMatchersMapStrToI["item"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true
				matchInt := &ves_io_schema_policy.CookieMatcherType_Item{}
				matchInt.Item = &ves_io_schema_policy.MatcherType{}
				cookieMatchers[i].Match = matchInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["exact_values"]; ok && !isIntfNil(v) {

						ls := make([]string, len(v.([]interface{})))
						for i, v := range v.([]interface{}) {
							ls[i] = v.(string)
						}
						matchInt.Item.ExactValues = ls

					}

					if v, ok := cs["regex_values"]; ok && !isIntfNil(v) {

						ls := make([]string, len(v.([]interface{})))
						for i, v := range v.([]interface{}) {
							ls[i] = v.(string)
						}
						matchInt.Item.RegexValues = ls

					}

					if v, ok := cs["transformers"]; ok && !isIntfNil(v) {

						transformersList := []ves_io_schema_policy.Transformer{}
						for _, j := range v.([]interface{}) {
							transformersList = append(transformersList, ves_io_schema_policy.Transformer(ves_io_schema_policy.Transformer_value[j.(string)]))
						}
						matchInt.Item.Transformers = transformersList

					}

				}

			}

			if v, ok := cookieMatchersMapStrToI["presence"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true
				matchInt := &ves_io_schema_policy.CookieMatcherType_Presence{}

				cookieMatchers[i].Match = matchInt

				matchInt.Presence = v.(bool)

			}

			if w, ok := cookieMatchersMapStrToI["name"]; ok && !isIntfNil(w) {
				cookieMatchers[i].Name = w.(string)
			}

		}

	}

	if v, ok := d.GetOk("domain_matcher"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		domainMatcher := &ves_io_schema_policy.MatcherTypeBasic{}
		updateSpec.DomainMatcher = domainMatcher
		for _, set := range sl {
			domainMatcherMapStrToI := set.(map[string]interface{})

			if w, ok := domainMatcherMapStrToI["exact_values"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				domainMatcher.ExactValues = ls
			}

			if w, ok := domainMatcherMapStrToI["regex_values"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				domainMatcher.RegexValues = ls
			}

		}

	}

	dstAsnChoiceTypeFound := false

	if v, ok := d.GetOk("any_dst_asn"); ok && !dstAsnChoiceTypeFound {

		dstAsnChoiceTypeFound = true

		if v.(bool) {
			dstAsnChoiceInt := &ves_io_schema_service_policy_rule.ReplaceSpecType_AnyDstAsn{}
			dstAsnChoiceInt.AnyDstAsn = &ves_io_schema.Empty{}
			updateSpec.DstAsnChoice = dstAsnChoiceInt
		}

	}

	if v, ok := d.GetOk("dst_asn_list"); ok && !dstAsnChoiceTypeFound {

		dstAsnChoiceTypeFound = true
		dstAsnChoiceInt := &ves_io_schema_service_policy_rule.ReplaceSpecType_DstAsnList{}
		dstAsnChoiceInt.DstAsnList = &ves_io_schema_policy.AsnMatchList{}
		updateSpec.DstAsnChoice = dstAsnChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["as_numbers"]; ok && !isIntfNil(v) {

				ls := make([]uint32, len(v.([]interface{})))
				for i, v := range v.([]interface{}) {
					ls[i] = uint32(v.(int))
				}
				dstAsnChoiceInt.DstAsnList.AsNumbers = ls

			}

		}

	}

	if v, ok := d.GetOk("dst_asn_matcher"); ok && !dstAsnChoiceTypeFound {

		dstAsnChoiceTypeFound = true
		dstAsnChoiceInt := &ves_io_schema_service_policy_rule.ReplaceSpecType_DstAsnMatcher{}
		dstAsnChoiceInt.DstAsnMatcher = &ves_io_schema_policy.AsnMatcherType{}
		updateSpec.DstAsnChoice = dstAsnChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["asn_sets"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				asnSetsInt := make([]*ves_io_schema.ObjectRefType, len(sl))
				dstAsnChoiceInt.DstAsnMatcher.AsnSets = asnSetsInt
				for i, ps := range sl {

					asMapToStrVal := ps.(map[string]interface{})
					asnSetsInt[i] = &ves_io_schema.ObjectRefType{}

					asnSetsInt[i].Kind = "bgp_asn_set"

					if v, ok := asMapToStrVal["name"]; ok && !isIntfNil(v) {
						asnSetsInt[i].Name = v.(string)
					}

					if v, ok := asMapToStrVal["namespace"]; ok && !isIntfNil(v) {
						asnSetsInt[i].Namespace = v.(string)
					}

					if v, ok := asMapToStrVal["tenant"]; ok && !isIntfNil(v) {
						asnSetsInt[i].Tenant = v.(string)
					}

					if v, ok := asMapToStrVal["uid"]; ok && !isIntfNil(v) {
						asnSetsInt[i].Uid = v.(string)
					}

				}

			}

		}

	}

	dstIpChoiceTypeFound := false

	if v, ok := d.GetOk("any_dst_ip"); ok && !dstIpChoiceTypeFound {

		dstIpChoiceTypeFound = true

		if v.(bool) {
			dstIpChoiceInt := &ves_io_schema_service_policy_rule.ReplaceSpecType_AnyDstIp{}
			dstIpChoiceInt.AnyDstIp = &ves_io_schema.Empty{}
			updateSpec.DstIpChoice = dstIpChoiceInt
		}

	}

	if v, ok := d.GetOk("dst_ip_matcher"); ok && !dstIpChoiceTypeFound {

		dstIpChoiceTypeFound = true
		dstIpChoiceInt := &ves_io_schema_service_policy_rule.ReplaceSpecType_DstIpMatcher{}
		dstIpChoiceInt.DstIpMatcher = &ves_io_schema_policy.IpMatcherType{}
		updateSpec.DstIpChoice = dstIpChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["invert_matcher"]; ok && !isIntfNil(v) {

				dstIpChoiceInt.DstIpMatcher.InvertMatcher = v.(bool)

			}

			if v, ok := cs["prefix_sets"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				prefixSetsInt := make([]*ves_io_schema.ObjectRefType, len(sl))
				dstIpChoiceInt.DstIpMatcher.PrefixSets = prefixSetsInt
				for i, ps := range sl {

					psMapToStrVal := ps.(map[string]interface{})
					prefixSetsInt[i] = &ves_io_schema.ObjectRefType{}

					prefixSetsInt[i].Kind = "ip_prefix_set"

					if v, ok := psMapToStrVal["name"]; ok && !isIntfNil(v) {
						prefixSetsInt[i].Name = v.(string)
					}

					if v, ok := psMapToStrVal["namespace"]; ok && !isIntfNil(v) {
						prefixSetsInt[i].Namespace = v.(string)
					}

					if v, ok := psMapToStrVal["tenant"]; ok && !isIntfNil(v) {
						prefixSetsInt[i].Tenant = v.(string)
					}

					if v, ok := psMapToStrVal["uid"]; ok && !isIntfNil(v) {
						prefixSetsInt[i].Uid = v.(string)
					}

				}

			}

		}

	}

	if v, ok := d.GetOk("dst_ip_prefix_list"); ok && !dstIpChoiceTypeFound {

		dstIpChoiceTypeFound = true
		dstIpChoiceInt := &ves_io_schema_service_policy_rule.ReplaceSpecType_DstIpPrefixList{}
		dstIpChoiceInt.DstIpPrefixList = &ves_io_schema_policy.PrefixMatchList{}
		updateSpec.DstIpChoice = dstIpChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["invert_match"]; ok && !isIntfNil(v) {

				dstIpChoiceInt.DstIpPrefixList.InvertMatch = v.(bool)

			}

			if v, ok := cs["ip_prefixes"]; ok && !isIntfNil(v) {

				ls := make([]string, len(v.([]interface{})))
				for i, v := range v.([]interface{}) {
					ls[i] = v.(string)
				}
				dstIpChoiceInt.DstIpPrefixList.IpPrefixes = ls

			}

		}

	}

	if v, ok := d.GetOk("expiration_timestamp"); ok && !isIntfNil(v) {

		ts, err := parseTime(v.(string))
		if err != nil {
			return fmt.Errorf("error creating ServicePolicyRule, timestamp format is wrong: %s", err)
		}
		updateSpec.ExpirationTimestamp = ts

	}

	if v, ok := d.GetOk("goto_policy"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		gotoPolicyInt := make([]*ves_io_schema.ObjectRefType, len(sl))
		updateSpec.GotoPolicy = gotoPolicyInt
		for i, ps := range sl {

			gpMapToStrVal := ps.(map[string]interface{})
			gotoPolicyInt[i] = &ves_io_schema.ObjectRefType{}

			gotoPolicyInt[i].Kind = "service_policy"

			if v, ok := gpMapToStrVal["name"]; ok && !isIntfNil(v) {
				gotoPolicyInt[i].Name = v.(string)
			}

			if v, ok := gpMapToStrVal["namespace"]; ok && !isIntfNil(v) {
				gotoPolicyInt[i].Namespace = v.(string)
			}

			if v, ok := gpMapToStrVal["tenant"]; ok && !isIntfNil(v) {
				gotoPolicyInt[i].Tenant = v.(string)
			}

			if v, ok := gpMapToStrVal["uid"]; ok && !isIntfNil(v) {
				gotoPolicyInt[i].Uid = v.(string)
			}

		}

	}

	if v, ok := d.GetOk("headers"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		headers := make([]*ves_io_schema_policy.HeaderMatcherType, len(sl))
		updateSpec.Headers = headers
		for i, set := range sl {
			headers[i] = &ves_io_schema_policy.HeaderMatcherType{}
			headersMapStrToI := set.(map[string]interface{})

			if w, ok := headersMapStrToI["invert_matcher"]; ok && !isIntfNil(w) {
				headers[i].InvertMatcher = w.(bool)
			}

			matchTypeFound := false

			if v, ok := headersMapStrToI["check_not_present"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true

				if v.(bool) {
					matchInt := &ves_io_schema_policy.HeaderMatcherType_CheckNotPresent{}
					matchInt.CheckNotPresent = &ves_io_schema.Empty{}
					headers[i].Match = matchInt
				}

			}

			if v, ok := headersMapStrToI["check_present"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true

				if v.(bool) {
					matchInt := &ves_io_schema_policy.HeaderMatcherType_CheckPresent{}
					matchInt.CheckPresent = &ves_io_schema.Empty{}
					headers[i].Match = matchInt
				}

			}

			if v, ok := headersMapStrToI["item"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true
				matchInt := &ves_io_schema_policy.HeaderMatcherType_Item{}
				matchInt.Item = &ves_io_schema_policy.MatcherType{}
				headers[i].Match = matchInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["exact_values"]; ok && !isIntfNil(v) {

						ls := make([]string, len(v.([]interface{})))
						for i, v := range v.([]interface{}) {
							ls[i] = v.(string)
						}
						matchInt.Item.ExactValues = ls

					}

					if v, ok := cs["regex_values"]; ok && !isIntfNil(v) {

						ls := make([]string, len(v.([]interface{})))
						for i, v := range v.([]interface{}) {
							ls[i] = v.(string)
						}
						matchInt.Item.RegexValues = ls

					}

					if v, ok := cs["transformers"]; ok && !isIntfNil(v) {

						transformersList := []ves_io_schema_policy.Transformer{}
						for _, j := range v.([]interface{}) {
							transformersList = append(transformersList, ves_io_schema_policy.Transformer(ves_io_schema_policy.Transformer_value[j.(string)]))
						}
						matchInt.Item.Transformers = transformersList

					}

				}

			}

			if v, ok := headersMapStrToI["presence"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true
				matchInt := &ves_io_schema_policy.HeaderMatcherType_Presence{}

				headers[i].Match = matchInt

				matchInt.Presence = v.(bool)

			}

			if w, ok := headersMapStrToI["name"]; ok && !isIntfNil(w) {
				headers[i].Name = w.(string)
			}

		}

	}

	if v, ok := d.GetOk("http_method"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		httpMethod := &ves_io_schema_policy.HttpMethodMatcherType{}
		updateSpec.HttpMethod = httpMethod
		for _, set := range sl {
			httpMethodMapStrToI := set.(map[string]interface{})

			if w, ok := httpMethodMapStrToI["invert_matcher"]; ok && !isIntfNil(w) {
				httpMethod.InvertMatcher = w.(bool)
			}

			if v, ok := httpMethodMapStrToI["methods"]; ok && !isIntfNil(v) {

				methodsList := []ves_io_schema.HttpMethod{}
				for _, j := range v.([]interface{}) {
					methodsList = append(methodsList, ves_io_schema.HttpMethod(ves_io_schema.HttpMethod_value[j.(string)]))
				}
				httpMethod.Methods = methodsList

			}

		}

	}

	ipChoiceTypeFound := false

	if v, ok := d.GetOk("any_ip"); ok && !ipChoiceTypeFound {

		ipChoiceTypeFound = true

		if v.(bool) {
			ipChoiceInt := &ves_io_schema_service_policy_rule.ReplaceSpecType_AnyIp{}
			ipChoiceInt.AnyIp = &ves_io_schema.Empty{}
			updateSpec.IpChoice = ipChoiceInt
		}

	}

	if v, ok := d.GetOk("ip_matcher"); ok && !ipChoiceTypeFound {

		ipChoiceTypeFound = true
		ipChoiceInt := &ves_io_schema_service_policy_rule.ReplaceSpecType_IpMatcher{}
		ipChoiceInt.IpMatcher = &ves_io_schema_policy.IpMatcherType{}
		updateSpec.IpChoice = ipChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["invert_matcher"]; ok && !isIntfNil(v) {

				ipChoiceInt.IpMatcher.InvertMatcher = v.(bool)

			}

			if v, ok := cs["prefix_sets"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				prefixSetsInt := make([]*ves_io_schema.ObjectRefType, len(sl))
				ipChoiceInt.IpMatcher.PrefixSets = prefixSetsInt
				for i, ps := range sl {

					psMapToStrVal := ps.(map[string]interface{})
					prefixSetsInt[i] = &ves_io_schema.ObjectRefType{}

					prefixSetsInt[i].Kind = "ip_prefix_set"

					if v, ok := psMapToStrVal["name"]; ok && !isIntfNil(v) {
						prefixSetsInt[i].Name = v.(string)
					}

					if v, ok := psMapToStrVal["namespace"]; ok && !isIntfNil(v) {
						prefixSetsInt[i].Namespace = v.(string)
					}

					if v, ok := psMapToStrVal["tenant"]; ok && !isIntfNil(v) {
						prefixSetsInt[i].Tenant = v.(string)
					}

					if v, ok := psMapToStrVal["uid"]; ok && !isIntfNil(v) {
						prefixSetsInt[i].Uid = v.(string)
					}

				}

			}

		}

	}

	if v, ok := d.GetOk("ip_prefix_list"); ok && !ipChoiceTypeFound {

		ipChoiceTypeFound = true
		ipChoiceInt := &ves_io_schema_service_policy_rule.ReplaceSpecType_IpPrefixList{}
		ipChoiceInt.IpPrefixList = &ves_io_schema_policy.PrefixMatchList{}
		updateSpec.IpChoice = ipChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["invert_match"]; ok && !isIntfNil(v) {

				ipChoiceInt.IpPrefixList.InvertMatch = v.(bool)

			}

			if v, ok := cs["ip_prefixes"]; ok && !isIntfNil(v) {

				ls := make([]string, len(v.([]interface{})))
				for i, v := range v.([]interface{}) {
					ls[i] = v.(string)
				}
				ipChoiceInt.IpPrefixList.IpPrefixes = ls

			}

		}

	}

	if v, ok := d.GetOk("ip_reputation_action"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		ipReputationAction := &ves_io_schema_policy.ModifyAction{}
		updateSpec.IpReputationAction = ipReputationAction
		for _, set := range sl {
			ipReputationActionMapStrToI := set.(map[string]interface{})

			actionTypeTypeFound := false

			if v, ok := ipReputationActionMapStrToI["default"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

				actionTypeTypeFound = true

				if v.(bool) {
					actionTypeInt := &ves_io_schema_policy.ModifyAction_Default{}
					actionTypeInt.Default = &ves_io_schema.Empty{}
					ipReputationAction.ActionType = actionTypeInt
				}

			}

			if v, ok := ipReputationActionMapStrToI["skip_processing"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

				actionTypeTypeFound = true

				if v.(bool) {
					actionTypeInt := &ves_io_schema_policy.ModifyAction_SkipProcessing{}
					actionTypeInt.SkipProcessing = &ves_io_schema.Empty{}
					ipReputationAction.ActionType = actionTypeInt
				}

			}

		}

	}

	if v, ok := d.GetOk("jwt_claims"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		jwtClaims := make([]*ves_io_schema_policy.JWTClaimMatcherType, len(sl))
		updateSpec.JwtClaims = jwtClaims
		for i, set := range sl {
			jwtClaims[i] = &ves_io_schema_policy.JWTClaimMatcherType{}
			jwtClaimsMapStrToI := set.(map[string]interface{})

			if w, ok := jwtClaimsMapStrToI["invert_matcher"]; ok && !isIntfNil(w) {
				jwtClaims[i].InvertMatcher = w.(bool)
			}

			matchTypeFound := false

			if v, ok := jwtClaimsMapStrToI["check_not_present"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true

				if v.(bool) {
					matchInt := &ves_io_schema_policy.JWTClaimMatcherType_CheckNotPresent{}
					matchInt.CheckNotPresent = &ves_io_schema.Empty{}
					jwtClaims[i].Match = matchInt
				}

			}

			if v, ok := jwtClaimsMapStrToI["check_present"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true

				if v.(bool) {
					matchInt := &ves_io_schema_policy.JWTClaimMatcherType_CheckPresent{}
					matchInt.CheckPresent = &ves_io_schema.Empty{}
					jwtClaims[i].Match = matchInt
				}

			}

			if v, ok := jwtClaimsMapStrToI["item"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true
				matchInt := &ves_io_schema_policy.JWTClaimMatcherType_Item{}
				matchInt.Item = &ves_io_schema_policy.MatcherType{}
				jwtClaims[i].Match = matchInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["exact_values"]; ok && !isIntfNil(v) {

						ls := make([]string, len(v.([]interface{})))
						for i, v := range v.([]interface{}) {
							ls[i] = v.(string)
						}
						matchInt.Item.ExactValues = ls

					}

					if v, ok := cs["regex_values"]; ok && !isIntfNil(v) {

						ls := make([]string, len(v.([]interface{})))
						for i, v := range v.([]interface{}) {
							ls[i] = v.(string)
						}
						matchInt.Item.RegexValues = ls

					}

					if v, ok := cs["transformers"]; ok && !isIntfNil(v) {

						transformersList := []ves_io_schema_policy.Transformer{}
						for _, j := range v.([]interface{}) {
							transformersList = append(transformersList, ves_io_schema_policy.Transformer(ves_io_schema_policy.Transformer_value[j.(string)]))
						}
						matchInt.Item.Transformers = transformersList

					}

				}

			}

			if w, ok := jwtClaimsMapStrToI["name"]; ok && !isIntfNil(w) {
				jwtClaims[i].Name = w.(string)
			}

		}

	}

	if v, ok := d.GetOk("l4_dest_matcher"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		l4DestMatcher := &ves_io_schema_policy.L4DestMatcherType{}
		updateSpec.L4DestMatcher = l4DestMatcher
		for _, set := range sl {
			l4DestMatcherMapStrToI := set.(map[string]interface{})

			if w, ok := l4DestMatcherMapStrToI["invert_matcher"]; ok && !isIntfNil(w) {
				l4DestMatcher.InvertMatcher = w.(bool)
			}

			if v, ok := l4DestMatcherMapStrToI["l4_dests"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				l4Dests := make([]*ves_io_schema.L4DestType, len(sl))
				l4DestMatcher.L4Dests = l4Dests
				for i, set := range sl {
					l4Dests[i] = &ves_io_schema.L4DestType{}
					l4DestsMapStrToI := set.(map[string]interface{})

					if w, ok := l4DestsMapStrToI["port_ranges"]; ok && !isIntfNil(w) {
						l4Dests[i].PortRanges = w.(string)
					}

					if w, ok := l4DestsMapStrToI["prefixes"]; ok && !isIntfNil(w) {
						ls := make([]string, len(w.([]interface{})))
						for i, v := range w.([]interface{}) {
							ls[i] = v.(string)
						}
						l4Dests[i].Prefixes = ls
					}

				}

			}

		}

	}

	if v, ok := d.GetOk("label_matcher"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		labelMatcher := &ves_io_schema.LabelMatcherType{}
		updateSpec.LabelMatcher = labelMatcher
		for _, set := range sl {
			labelMatcherMapStrToI := set.(map[string]interface{})

			if w, ok := labelMatcherMapStrToI["keys"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				labelMatcher.Keys = ls
			}

		}

	}

	if v, ok := d.GetOk("mum_action"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		mumAction := &ves_io_schema_policy.ModifyAction{}
		updateSpec.MumAction = mumAction
		for _, set := range sl {
			mumActionMapStrToI := set.(map[string]interface{})

			actionTypeTypeFound := false

			if v, ok := mumActionMapStrToI["default"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

				actionTypeTypeFound = true

				if v.(bool) {
					actionTypeInt := &ves_io_schema_policy.ModifyAction_Default{}
					actionTypeInt.Default = &ves_io_schema.Empty{}
					mumAction.ActionType = actionTypeInt
				}

			}

			if v, ok := mumActionMapStrToI["skip_processing"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

				actionTypeTypeFound = true

				if v.(bool) {
					actionTypeInt := &ves_io_schema_policy.ModifyAction_SkipProcessing{}
					actionTypeInt.SkipProcessing = &ves_io_schema.Empty{}
					mumAction.ActionType = actionTypeInt
				}

			}

		}

	}

	if v, ok := d.GetOk("origin_server_subsets_action"); ok && !isIntfNil(v) {

		ms := map[string]string{}
		for k, v := range v.(map[string]interface{}) {
			ms[k] = v.(string)
		}
		updateSpec.OriginServerSubsetsAction = ms
	}

	if v, ok := d.GetOk("path"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		path := &ves_io_schema_policy.PathMatcherType{}
		updateSpec.Path = path
		for _, set := range sl {
			pathMapStrToI := set.(map[string]interface{})

			if w, ok := pathMapStrToI["exact_values"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				path.ExactValues = ls
			}

			if w, ok := pathMapStrToI["invert_matcher"]; ok && !isIntfNil(w) {
				path.InvertMatcher = w.(bool)
			}

			if w, ok := pathMapStrToI["prefix_values"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				path.PrefixValues = ls
			}

			if w, ok := pathMapStrToI["regex_values"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				path.RegexValues = ls
			}

			if w, ok := pathMapStrToI["suffix_values"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				path.SuffixValues = ls
			}

			if v, ok := pathMapStrToI["transformers"]; ok && !isIntfNil(v) {

				transformersList := []ves_io_schema_policy.Transformer{}
				for _, j := range v.([]interface{}) {
					transformersList = append(transformersList, ves_io_schema_policy.Transformer(ves_io_schema_policy.Transformer_value[j.(string)]))
				}
				path.Transformers = transformersList

			}

		}

	}

	if v, ok := d.GetOk("port_matcher"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		portMatcher := &ves_io_schema_policy.PortMatcherType{}
		updateSpec.PortMatcher = portMatcher
		for _, set := range sl {
			portMatcherMapStrToI := set.(map[string]interface{})

			if w, ok := portMatcherMapStrToI["invert_matcher"]; ok && !isIntfNil(w) {
				portMatcher.InvertMatcher = w.(bool)
			}

			if w, ok := portMatcherMapStrToI["ports"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				portMatcher.Ports = ls
			}

		}

	}

	if v, ok := d.GetOk("query_params"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		queryParams := make([]*ves_io_schema_policy.QueryParameterMatcherType, len(sl))
		updateSpec.QueryParams = queryParams
		for i, set := range sl {
			queryParams[i] = &ves_io_schema_policy.QueryParameterMatcherType{}
			queryParamsMapStrToI := set.(map[string]interface{})

			if w, ok := queryParamsMapStrToI["invert_matcher"]; ok && !isIntfNil(w) {
				queryParams[i].InvertMatcher = w.(bool)
			}

			if w, ok := queryParamsMapStrToI["key"]; ok && !isIntfNil(w) {
				queryParams[i].Key = w.(string)
			}

			matchTypeFound := false

			if v, ok := queryParamsMapStrToI["check_not_present"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true

				if v.(bool) {
					matchInt := &ves_io_schema_policy.QueryParameterMatcherType_CheckNotPresent{}
					matchInt.CheckNotPresent = &ves_io_schema.Empty{}
					queryParams[i].Match = matchInt
				}

			}

			if v, ok := queryParamsMapStrToI["check_present"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true

				if v.(bool) {
					matchInt := &ves_io_schema_policy.QueryParameterMatcherType_CheckPresent{}
					matchInt.CheckPresent = &ves_io_schema.Empty{}
					queryParams[i].Match = matchInt
				}

			}

			if v, ok := queryParamsMapStrToI["item"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true
				matchInt := &ves_io_schema_policy.QueryParameterMatcherType_Item{}
				matchInt.Item = &ves_io_schema_policy.MatcherType{}
				queryParams[i].Match = matchInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["exact_values"]; ok && !isIntfNil(v) {

						ls := make([]string, len(v.([]interface{})))
						for i, v := range v.([]interface{}) {
							ls[i] = v.(string)
						}
						matchInt.Item.ExactValues = ls

					}

					if v, ok := cs["regex_values"]; ok && !isIntfNil(v) {

						ls := make([]string, len(v.([]interface{})))
						for i, v := range v.([]interface{}) {
							ls[i] = v.(string)
						}
						matchInt.Item.RegexValues = ls

					}

					if v, ok := cs["transformers"]; ok && !isIntfNil(v) {

						transformersList := []ves_io_schema_policy.Transformer{}
						for _, j := range v.([]interface{}) {
							transformersList = append(transformersList, ves_io_schema_policy.Transformer(ves_io_schema_policy.Transformer_value[j.(string)]))
						}
						matchInt.Item.Transformers = transformersList

					}

				}

			}

			if v, ok := queryParamsMapStrToI["presence"]; ok && !isIntfNil(v) && !matchTypeFound {

				matchTypeFound = true
				matchInt := &ves_io_schema_policy.QueryParameterMatcherType_Presence{}

				queryParams[i].Match = matchInt

				matchInt.Presence = v.(bool)

			}

		}

	}

	if v, ok := d.GetOk("rate_limiter"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		rateLimiterInt := make([]*ves_io_schema.ObjectRefType, len(sl))
		updateSpec.RateLimiter = rateLimiterInt
		for i, ps := range sl {

			rlMapToStrVal := ps.(map[string]interface{})
			rateLimiterInt[i] = &ves_io_schema.ObjectRefType{}

			rateLimiterInt[i].Kind = "rate_limiter"

			if v, ok := rlMapToStrVal["name"]; ok && !isIntfNil(v) {
				rateLimiterInt[i].Name = v.(string)
			}

			if v, ok := rlMapToStrVal["namespace"]; ok && !isIntfNil(v) {
				rateLimiterInt[i].Namespace = v.(string)
			}

			if v, ok := rlMapToStrVal["tenant"]; ok && !isIntfNil(v) {
				rateLimiterInt[i].Tenant = v.(string)
			}

			if v, ok := rlMapToStrVal["uid"]; ok && !isIntfNil(v) {
				rateLimiterInt[i].Uid = v.(string)
			}

		}

	}

	if v, ok := d.GetOk("request_constraints"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		requestConstraints := &ves_io_schema_policy.RequestConstraintType{}
		updateSpec.RequestConstraints = requestConstraints
		for _, set := range sl {
			requestConstraintsMapStrToI := set.(map[string]interface{})

			maxCookieCountChoiceTypeFound := false

			if v, ok := requestConstraintsMapStrToI["max_cookie_count_exceeds"]; ok && !isIntfNil(v) && !maxCookieCountChoiceTypeFound {

				maxCookieCountChoiceTypeFound = true
				maxCookieCountChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxCookieCountExceeds{}

				requestConstraints.MaxCookieCountChoice = maxCookieCountChoiceInt

				maxCookieCountChoiceInt.MaxCookieCountExceeds = uint32(v.(int))

			}

			if v, ok := requestConstraintsMapStrToI["max_cookie_count_none"]; ok && !isIntfNil(v) && !maxCookieCountChoiceTypeFound {

				maxCookieCountChoiceTypeFound = true

				if v.(bool) {
					maxCookieCountChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxCookieCountNone{}
					maxCookieCountChoiceInt.MaxCookieCountNone = &ves_io_schema.Empty{}
					requestConstraints.MaxCookieCountChoice = maxCookieCountChoiceInt
				}

			}

			maxCookieKeySizeChoiceTypeFound := false

			if v, ok := requestConstraintsMapStrToI["max_cookie_key_size_exceeds"]; ok && !isIntfNil(v) && !maxCookieKeySizeChoiceTypeFound {

				maxCookieKeySizeChoiceTypeFound = true
				maxCookieKeySizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxCookieKeySizeExceeds{}

				requestConstraints.MaxCookieKeySizeChoice = maxCookieKeySizeChoiceInt

				maxCookieKeySizeChoiceInt.MaxCookieKeySizeExceeds = uint32(v.(int))

			}

			if v, ok := requestConstraintsMapStrToI["max_cookie_key_size_none"]; ok && !isIntfNil(v) && !maxCookieKeySizeChoiceTypeFound {

				maxCookieKeySizeChoiceTypeFound = true

				if v.(bool) {
					maxCookieKeySizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxCookieKeySizeNone{}
					maxCookieKeySizeChoiceInt.MaxCookieKeySizeNone = &ves_io_schema.Empty{}
					requestConstraints.MaxCookieKeySizeChoice = maxCookieKeySizeChoiceInt
				}

			}

			maxCookieValueSizeChoiceTypeFound := false

			if v, ok := requestConstraintsMapStrToI["max_cookie_value_size_exceeds"]; ok && !isIntfNil(v) && !maxCookieValueSizeChoiceTypeFound {

				maxCookieValueSizeChoiceTypeFound = true
				maxCookieValueSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxCookieValueSizeExceeds{}

				requestConstraints.MaxCookieValueSizeChoice = maxCookieValueSizeChoiceInt

				maxCookieValueSizeChoiceInt.MaxCookieValueSizeExceeds = uint32(v.(int))

			}

			if v, ok := requestConstraintsMapStrToI["max_cookie_value_size_none"]; ok && !isIntfNil(v) && !maxCookieValueSizeChoiceTypeFound {

				maxCookieValueSizeChoiceTypeFound = true

				if v.(bool) {
					maxCookieValueSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxCookieValueSizeNone{}
					maxCookieValueSizeChoiceInt.MaxCookieValueSizeNone = &ves_io_schema.Empty{}
					requestConstraints.MaxCookieValueSizeChoice = maxCookieValueSizeChoiceInt
				}

			}

			maxHeaderCountChoiceTypeFound := false

			if v, ok := requestConstraintsMapStrToI["max_header_count_exceeds"]; ok && !isIntfNil(v) && !maxHeaderCountChoiceTypeFound {

				maxHeaderCountChoiceTypeFound = true
				maxHeaderCountChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxHeaderCountExceeds{}

				requestConstraints.MaxHeaderCountChoice = maxHeaderCountChoiceInt

				maxHeaderCountChoiceInt.MaxHeaderCountExceeds = uint32(v.(int))

			}

			if v, ok := requestConstraintsMapStrToI["max_header_count_none"]; ok && !isIntfNil(v) && !maxHeaderCountChoiceTypeFound {

				maxHeaderCountChoiceTypeFound = true

				if v.(bool) {
					maxHeaderCountChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxHeaderCountNone{}
					maxHeaderCountChoiceInt.MaxHeaderCountNone = &ves_io_schema.Empty{}
					requestConstraints.MaxHeaderCountChoice = maxHeaderCountChoiceInt
				}

			}

			maxHeaderKeySizeChoiceTypeFound := false

			if v, ok := requestConstraintsMapStrToI["max_header_key_size_exceeds"]; ok && !isIntfNil(v) && !maxHeaderKeySizeChoiceTypeFound {

				maxHeaderKeySizeChoiceTypeFound = true
				maxHeaderKeySizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxHeaderKeySizeExceeds{}

				requestConstraints.MaxHeaderKeySizeChoice = maxHeaderKeySizeChoiceInt

				maxHeaderKeySizeChoiceInt.MaxHeaderKeySizeExceeds = uint32(v.(int))

			}

			if v, ok := requestConstraintsMapStrToI["max_header_key_size_none"]; ok && !isIntfNil(v) && !maxHeaderKeySizeChoiceTypeFound {

				maxHeaderKeySizeChoiceTypeFound = true

				if v.(bool) {
					maxHeaderKeySizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxHeaderKeySizeNone{}
					maxHeaderKeySizeChoiceInt.MaxHeaderKeySizeNone = &ves_io_schema.Empty{}
					requestConstraints.MaxHeaderKeySizeChoice = maxHeaderKeySizeChoiceInt
				}

			}

			maxHeaderValueSizeChoiceTypeFound := false

			if v, ok := requestConstraintsMapStrToI["max_header_value_size_exceeds"]; ok && !isIntfNil(v) && !maxHeaderValueSizeChoiceTypeFound {

				maxHeaderValueSizeChoiceTypeFound = true
				maxHeaderValueSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxHeaderValueSizeExceeds{}

				requestConstraints.MaxHeaderValueSizeChoice = maxHeaderValueSizeChoiceInt

				maxHeaderValueSizeChoiceInt.MaxHeaderValueSizeExceeds = uint32(v.(int))

			}

			if v, ok := requestConstraintsMapStrToI["max_header_value_size_none"]; ok && !isIntfNil(v) && !maxHeaderValueSizeChoiceTypeFound {

				maxHeaderValueSizeChoiceTypeFound = true

				if v.(bool) {
					maxHeaderValueSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxHeaderValueSizeNone{}
					maxHeaderValueSizeChoiceInt.MaxHeaderValueSizeNone = &ves_io_schema.Empty{}
					requestConstraints.MaxHeaderValueSizeChoice = maxHeaderValueSizeChoiceInt
				}

			}

			maxParameterCountChoiceTypeFound := false

			if v, ok := requestConstraintsMapStrToI["max_parameter_count_exceeds"]; ok && !isIntfNil(v) && !maxParameterCountChoiceTypeFound {

				maxParameterCountChoiceTypeFound = true
				maxParameterCountChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxParameterCountExceeds{}

				requestConstraints.MaxParameterCountChoice = maxParameterCountChoiceInt

				maxParameterCountChoiceInt.MaxParameterCountExceeds = uint32(v.(int))

			}

			if v, ok := requestConstraintsMapStrToI["max_parameter_count_none"]; ok && !isIntfNil(v) && !maxParameterCountChoiceTypeFound {

				maxParameterCountChoiceTypeFound = true

				if v.(bool) {
					maxParameterCountChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxParameterCountNone{}
					maxParameterCountChoiceInt.MaxParameterCountNone = &ves_io_schema.Empty{}
					requestConstraints.MaxParameterCountChoice = maxParameterCountChoiceInt
				}

			}

			maxParameterNameSizeChoiceTypeFound := false

			if v, ok := requestConstraintsMapStrToI["max_parameter_name_size_exceeds"]; ok && !isIntfNil(v) && !maxParameterNameSizeChoiceTypeFound {

				maxParameterNameSizeChoiceTypeFound = true
				maxParameterNameSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxParameterNameSizeExceeds{}

				requestConstraints.MaxParameterNameSizeChoice = maxParameterNameSizeChoiceInt

				maxParameterNameSizeChoiceInt.MaxParameterNameSizeExceeds = uint32(v.(int))

			}

			if v, ok := requestConstraintsMapStrToI["max_parameter_name_size_none"]; ok && !isIntfNil(v) && !maxParameterNameSizeChoiceTypeFound {

				maxParameterNameSizeChoiceTypeFound = true

				if v.(bool) {
					maxParameterNameSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxParameterNameSizeNone{}
					maxParameterNameSizeChoiceInt.MaxParameterNameSizeNone = &ves_io_schema.Empty{}
					requestConstraints.MaxParameterNameSizeChoice = maxParameterNameSizeChoiceInt
				}

			}

			maxParameterValueSizeChoiceTypeFound := false

			if v, ok := requestConstraintsMapStrToI["max_parameter_value_size_exceeds"]; ok && !isIntfNil(v) && !maxParameterValueSizeChoiceTypeFound {

				maxParameterValueSizeChoiceTypeFound = true
				maxParameterValueSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxParameterValueSizeExceeds{}

				requestConstraints.MaxParameterValueSizeChoice = maxParameterValueSizeChoiceInt

				maxParameterValueSizeChoiceInt.MaxParameterValueSizeExceeds = uint32(v.(int))

			}

			if v, ok := requestConstraintsMapStrToI["max_parameter_value_size_none"]; ok && !isIntfNil(v) && !maxParameterValueSizeChoiceTypeFound {

				maxParameterValueSizeChoiceTypeFound = true

				if v.(bool) {
					maxParameterValueSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxParameterValueSizeNone{}
					maxParameterValueSizeChoiceInt.MaxParameterValueSizeNone = &ves_io_schema.Empty{}
					requestConstraints.MaxParameterValueSizeChoice = maxParameterValueSizeChoiceInt
				}

			}

			maxQuerySizeChoiceTypeFound := false

			if v, ok := requestConstraintsMapStrToI["max_query_size_exceeds"]; ok && !isIntfNil(v) && !maxQuerySizeChoiceTypeFound {

				maxQuerySizeChoiceTypeFound = true
				maxQuerySizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxQuerySizeExceeds{}

				requestConstraints.MaxQuerySizeChoice = maxQuerySizeChoiceInt

				maxQuerySizeChoiceInt.MaxQuerySizeExceeds = uint32(v.(int))

			}

			if v, ok := requestConstraintsMapStrToI["max_query_size_none"]; ok && !isIntfNil(v) && !maxQuerySizeChoiceTypeFound {

				maxQuerySizeChoiceTypeFound = true

				if v.(bool) {
					maxQuerySizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxQuerySizeNone{}
					maxQuerySizeChoiceInt.MaxQuerySizeNone = &ves_io_schema.Empty{}
					requestConstraints.MaxQuerySizeChoice = maxQuerySizeChoiceInt
				}

			}

			maxRequestLineSizeChoiceTypeFound := false

			if v, ok := requestConstraintsMapStrToI["max_request_line_size_exceeds"]; ok && !isIntfNil(v) && !maxRequestLineSizeChoiceTypeFound {

				maxRequestLineSizeChoiceTypeFound = true
				maxRequestLineSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxRequestLineSizeExceeds{}

				requestConstraints.MaxRequestLineSizeChoice = maxRequestLineSizeChoiceInt

				maxRequestLineSizeChoiceInt.MaxRequestLineSizeExceeds = uint32(v.(int))

			}

			if v, ok := requestConstraintsMapStrToI["max_request_line_size_none"]; ok && !isIntfNil(v) && !maxRequestLineSizeChoiceTypeFound {

				maxRequestLineSizeChoiceTypeFound = true

				if v.(bool) {
					maxRequestLineSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxRequestLineSizeNone{}
					maxRequestLineSizeChoiceInt.MaxRequestLineSizeNone = &ves_io_schema.Empty{}
					requestConstraints.MaxRequestLineSizeChoice = maxRequestLineSizeChoiceInt
				}

			}

			maxRequestSizeChoiceTypeFound := false

			if v, ok := requestConstraintsMapStrToI["max_request_size_exceeds"]; ok && !isIntfNil(v) && !maxRequestSizeChoiceTypeFound {

				maxRequestSizeChoiceTypeFound = true
				maxRequestSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxRequestSizeExceeds{}

				requestConstraints.MaxRequestSizeChoice = maxRequestSizeChoiceInt

				maxRequestSizeChoiceInt.MaxRequestSizeExceeds = uint32(v.(int))

			}

			if v, ok := requestConstraintsMapStrToI["max_request_size_none"]; ok && !isIntfNil(v) && !maxRequestSizeChoiceTypeFound {

				maxRequestSizeChoiceTypeFound = true

				if v.(bool) {
					maxRequestSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxRequestSizeNone{}
					maxRequestSizeChoiceInt.MaxRequestSizeNone = &ves_io_schema.Empty{}
					requestConstraints.MaxRequestSizeChoice = maxRequestSizeChoiceInt
				}

			}

			maxUrlSizeChoiceTypeFound := false

			if v, ok := requestConstraintsMapStrToI["max_url_size_exceeds"]; ok && !isIntfNil(v) && !maxUrlSizeChoiceTypeFound {

				maxUrlSizeChoiceTypeFound = true
				maxUrlSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxUrlSizeExceeds{}

				requestConstraints.MaxUrlSizeChoice = maxUrlSizeChoiceInt

				maxUrlSizeChoiceInt.MaxUrlSizeExceeds = uint32(v.(int))

			}

			if v, ok := requestConstraintsMapStrToI["max_url_size_none"]; ok && !isIntfNil(v) && !maxUrlSizeChoiceTypeFound {

				maxUrlSizeChoiceTypeFound = true

				if v.(bool) {
					maxUrlSizeChoiceInt := &ves_io_schema_policy.RequestConstraintType_MaxUrlSizeNone{}
					maxUrlSizeChoiceInt.MaxUrlSizeNone = &ves_io_schema.Empty{}
					requestConstraints.MaxUrlSizeChoice = maxUrlSizeChoiceInt
				}

			}

		}

	}

	if v, ok := d.GetOk("scheme"); ok && !isIntfNil(v) {

		ls := make([]string, len(v.([]interface{})))
		for i, v := range v.([]interface{}) {
			ls[i] = v.(string)
		}
		updateSpec.Scheme = ls

	}

	if v, ok := d.GetOk("segment_policy"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		segmentPolicy := &ves_io_schema_policy.SegmentPolicyType{}
		updateSpec.SegmentPolicy = segmentPolicy
		for _, set := range sl {
			segmentPolicyMapStrToI := set.(map[string]interface{})

			dstSegmentChoiceTypeFound := false

			if v, ok := segmentPolicyMapStrToI["dst_any"]; ok && !isIntfNil(v) && !dstSegmentChoiceTypeFound {

				dstSegmentChoiceTypeFound = true

				if v.(bool) {
					dstSegmentChoiceInt := &ves_io_schema_policy.SegmentPolicyType_DstAny{}
					dstSegmentChoiceInt.DstAny = &ves_io_schema.Empty{}
					segmentPolicy.DstSegmentChoice = dstSegmentChoiceInt
				}

			}

			if v, ok := segmentPolicyMapStrToI["dst_segments"]; ok && !isIntfNil(v) && !dstSegmentChoiceTypeFound {

				dstSegmentChoiceTypeFound = true
				dstSegmentChoiceInt := &ves_io_schema_policy.SegmentPolicyType_DstSegments{}
				dstSegmentChoiceInt.DstSegments = &ves_io_schema_views.SegmentRefList{}
				segmentPolicy.DstSegmentChoice = dstSegmentChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["segments"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						segmentsInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						dstSegmentChoiceInt.DstSegments.Segments = segmentsInt
						for i, ps := range sl {

							sMapToStrVal := ps.(map[string]interface{})
							segmentsInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := sMapToStrVal["name"]; ok && !isIntfNil(v) {
								segmentsInt[i].Name = v.(string)
							}

							if v, ok := sMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								segmentsInt[i].Namespace = v.(string)
							}

							if v, ok := sMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								segmentsInt[i].Tenant = v.(string)
							}

						}

					}

				}

			}

			if v, ok := segmentPolicyMapStrToI["intra_segment"]; ok && !isIntfNil(v) && !dstSegmentChoiceTypeFound {

				dstSegmentChoiceTypeFound = true

				if v.(bool) {
					dstSegmentChoiceInt := &ves_io_schema_policy.SegmentPolicyType_IntraSegment{}
					dstSegmentChoiceInt.IntraSegment = &ves_io_schema.Empty{}
					segmentPolicy.DstSegmentChoice = dstSegmentChoiceInt
				}

			}

			srcSegmentChoiceTypeFound := false

			if v, ok := segmentPolicyMapStrToI["src_any"]; ok && !isIntfNil(v) && !srcSegmentChoiceTypeFound {

				srcSegmentChoiceTypeFound = true

				if v.(bool) {
					srcSegmentChoiceInt := &ves_io_schema_policy.SegmentPolicyType_SrcAny{}
					srcSegmentChoiceInt.SrcAny = &ves_io_schema.Empty{}
					segmentPolicy.SrcSegmentChoice = srcSegmentChoiceInt
				}

			}

			if v, ok := segmentPolicyMapStrToI["src_segments"]; ok && !isIntfNil(v) && !srcSegmentChoiceTypeFound {

				srcSegmentChoiceTypeFound = true
				srcSegmentChoiceInt := &ves_io_schema_policy.SegmentPolicyType_SrcSegments{}
				srcSegmentChoiceInt.SrcSegments = &ves_io_schema_views.SegmentRefList{}
				segmentPolicy.SrcSegmentChoice = srcSegmentChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["segments"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						segmentsInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						srcSegmentChoiceInt.SrcSegments.Segments = segmentsInt
						for i, ps := range sl {

							sMapToStrVal := ps.(map[string]interface{})
							segmentsInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := sMapToStrVal["name"]; ok && !isIntfNil(v) {
								segmentsInt[i].Name = v.(string)
							}

							if v, ok := sMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								segmentsInt[i].Namespace = v.(string)
							}

							if v, ok := sMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								segmentsInt[i].Tenant = v.(string)
							}

						}

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("server_selector"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		serverSelector := &ves_io_schema.LabelSelectorType{}
		updateSpec.ServerSelector = serverSelector
		for _, set := range sl {
			serverSelectorMapStrToI := set.(map[string]interface{})

			if w, ok := serverSelectorMapStrToI["expressions"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				serverSelector.Expressions = ls
			}

		}

	}

	if v, ok := d.GetOk("shape_protected_endpoint_action"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		shapeProtectedEndpointAction := &ves_io_schema_policy.ShapeProtectedEndpointAction{}
		updateSpec.ShapeProtectedEndpointAction = shapeProtectedEndpointAction
		for _, set := range sl {
			shapeProtectedEndpointActionMapStrToI := set.(map[string]interface{})

			if w, ok := shapeProtectedEndpointActionMapStrToI["allow_goodbot"]; ok && !isIntfNil(w) {
				shapeProtectedEndpointAction.AllowGoodbot = w.(bool)
			}

			if v, ok := shapeProtectedEndpointActionMapStrToI["app_traffic_type"]; ok && !isIntfNil(v) {

				shapeProtectedEndpointAction.AppTrafficType = ves_io_schema_policy.AppTrafficType(ves_io_schema_policy.AppTrafficType_value[v.(string)])

			}

			if w, ok := shapeProtectedEndpointActionMapStrToI["flow_label"]; ok && !isIntfNil(w) {
				shapeProtectedEndpointAction.FlowLabel = w.(string)
			}

			if v, ok := shapeProtectedEndpointActionMapStrToI["mitigation"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				mitigation := &ves_io_schema_policy.ShapeBotMitigationAction{}
				shapeProtectedEndpointAction.Mitigation = mitigation
				for _, set := range sl {
					mitigationMapStrToI := set.(map[string]interface{})

					actionTypeTypeFound := false

					if v, ok := mitigationMapStrToI["block"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

						actionTypeTypeFound = true
						actionTypeInt := &ves_io_schema_policy.ShapeBotMitigationAction_Block{}
						actionTypeInt.Block = &ves_io_schema_policy.ShapeBotBlockMitigationActionType{}
						mitigation.ActionType = actionTypeInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["body"]; ok && !isIntfNil(v) {

								actionTypeInt.Block.Body = v.(string)

							}

							if v, ok := cs["body_hash"]; ok && !isIntfNil(v) {

								actionTypeInt.Block.BodyHash = v.(string)

							}

							if v, ok := cs["status"]; ok && !isIntfNil(v) {

								actionTypeInt.Block.Status = ves_io_schema.HttpStatusCode(ves_io_schema.HttpStatusCode_value[v.(string)])

							}

						}

					}

					if v, ok := mitigationMapStrToI["flag"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

						actionTypeTypeFound = true
						actionTypeInt := &ves_io_schema_policy.ShapeBotMitigationAction_Flag{}
						actionTypeInt.Flag = &ves_io_schema_policy.ShapeBotFlagMitigationActionChoiceType{}
						mitigation.ActionType = actionTypeInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							sendHeadersChoiceTypeFound := false

							if v, ok := cs["append_headers"]; ok && !isIntfNil(v) && !sendHeadersChoiceTypeFound {

								sendHeadersChoiceTypeFound = true
								sendHeadersChoiceInt := &ves_io_schema_policy.ShapeBotFlagMitigationActionChoiceType_AppendHeaders{}
								sendHeadersChoiceInt.AppendHeaders = &ves_io_schema_policy.ShapeBotFlagMitigationActionType{}
								actionTypeInt.Flag.SendHeadersChoice = sendHeadersChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["auto_type_header_name"]; ok && !isIntfNil(v) {

										sendHeadersChoiceInt.AppendHeaders.AutoTypeHeaderName = v.(string)

									}

									if v, ok := cs["inference_header_name"]; ok && !isIntfNil(v) {

										sendHeadersChoiceInt.AppendHeaders.InferenceHeaderName = v.(string)

									}

								}

							}

							if v, ok := cs["no_headers"]; ok && !isIntfNil(v) && !sendHeadersChoiceTypeFound {

								sendHeadersChoiceTypeFound = true

								if v.(bool) {
									sendHeadersChoiceInt := &ves_io_schema_policy.ShapeBotFlagMitigationActionChoiceType_NoHeaders{}
									sendHeadersChoiceInt.NoHeaders = &ves_io_schema.Empty{}
									actionTypeInt.Flag.SendHeadersChoice = sendHeadersChoiceInt
								}

							}

						}

					}

					if v, ok := mitigationMapStrToI["none"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

						actionTypeTypeFound = true

						if v.(bool) {
							actionTypeInt := &ves_io_schema_policy.ShapeBotMitigationAction_None{}
							actionTypeInt.None = &ves_io_schema.Empty{}
							mitigation.ActionType = actionTypeInt
						}

					}

					if v, ok := mitigationMapStrToI["redirect"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

						actionTypeTypeFound = true
						actionTypeInt := &ves_io_schema_policy.ShapeBotMitigationAction_Redirect{}
						actionTypeInt.Redirect = &ves_io_schema_policy.ShapeBotRedirectMitigationActionType{}
						mitigation.ActionType = actionTypeInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["uri"]; ok && !isIntfNil(v) {

								actionTypeInt.Redirect.Uri = v.(string)

							}

						}

					}

				}

			}

			if v, ok := shapeProtectedEndpointActionMapStrToI["transaction_result"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				transactionResult := &ves_io_schema.BotDefenseTransactionResultType{}
				shapeProtectedEndpointAction.TransactionResult = transactionResult
				for _, set := range sl {
					transactionResultMapStrToI := set.(map[string]interface{})

					if v, ok := transactionResultMapStrToI["failure_conditions"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						failureConditions := make([]*ves_io_schema.BotDefenseTransactionResultCondition, len(sl))
						transactionResult.FailureConditions = failureConditions
						for i, set := range sl {
							failureConditions[i] = &ves_io_schema.BotDefenseTransactionResultCondition{}
							failureConditionsMapStrToI := set.(map[string]interface{})

							if w, ok := failureConditionsMapStrToI["name"]; ok && !isIntfNil(w) {
								failureConditions[i].Name = w.(string)
							}

							if w, ok := failureConditionsMapStrToI["regex_values"]; ok && !isIntfNil(w) {
								ls := make([]string, len(w.([]interface{})))
								for i, v := range w.([]interface{}) {
									ls[i] = v.(string)
								}
								failureConditions[i].RegexValues = ls
							}

							if v, ok := failureConditionsMapStrToI["status"]; ok && !isIntfNil(v) {

								failureConditions[i].Status = ves_io_schema.HttpStatusCode(ves_io_schema.HttpStatusCode_value[v.(string)])

							}

						}

					}

					if v, ok := transactionResultMapStrToI["success_conditions"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						successConditions := make([]*ves_io_schema.BotDefenseTransactionResultCondition, len(sl))
						transactionResult.SuccessConditions = successConditions
						for i, set := range sl {
							successConditions[i] = &ves_io_schema.BotDefenseTransactionResultCondition{}
							successConditionsMapStrToI := set.(map[string]interface{})

							if w, ok := successConditionsMapStrToI["name"]; ok && !isIntfNil(w) {
								successConditions[i].Name = w.(string)
							}

							if w, ok := successConditionsMapStrToI["regex_values"]; ok && !isIntfNil(w) {
								ls := make([]string, len(w.([]interface{})))
								for i, v := range w.([]interface{}) {
									ls[i] = v.(string)
								}
								successConditions[i].RegexValues = ls
							}

							if v, ok := successConditionsMapStrToI["status"]; ok && !isIntfNil(v) {

								successConditions[i].Status = ves_io_schema.HttpStatusCode(ves_io_schema.HttpStatusCode_value[v.(string)])

							}

						}

					}

				}

			}

			if w, ok := shapeProtectedEndpointActionMapStrToI["web_scraping"]; ok && !isIntfNil(w) {
				shapeProtectedEndpointAction.WebScraping = w.(bool)
			}

		}

	}

	if v, ok := d.GetOk("tls_fingerprint_matcher"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		tlsFingerprintMatcher := &ves_io_schema_policy.TlsFingerprintMatcherType{}
		updateSpec.TlsFingerprintMatcher = tlsFingerprintMatcher
		for _, set := range sl {
			tlsFingerprintMatcherMapStrToI := set.(map[string]interface{})

			if v, ok := tlsFingerprintMatcherMapStrToI["classes"]; ok && !isIntfNil(v) {

				classesList := []ves_io_schema_policy.KnownTlsFingerprintClass{}
				for _, j := range v.([]interface{}) {
					classesList = append(classesList, ves_io_schema_policy.KnownTlsFingerprintClass(ves_io_schema_policy.KnownTlsFingerprintClass_value[j.(string)]))
				}
				tlsFingerprintMatcher.Classes = classesList

			}

			if w, ok := tlsFingerprintMatcherMapStrToI["exact_values"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				tlsFingerprintMatcher.ExactValues = ls
			}

			if w, ok := tlsFingerprintMatcherMapStrToI["excluded_values"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				tlsFingerprintMatcher.ExcludedValues = ls
			}

		}

	}

	if v, ok := d.GetOk("url_matcher"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		urlMatcher := &ves_io_schema_policy.URLMatcherType{}
		updateSpec.UrlMatcher = urlMatcher
		for _, set := range sl {
			urlMatcherMapStrToI := set.(map[string]interface{})

			if w, ok := urlMatcherMapStrToI["invert_matcher"]; ok && !isIntfNil(w) {
				urlMatcher.InvertMatcher = w.(bool)
			}

			if v, ok := urlMatcherMapStrToI["url_items"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				urlItems := make([]*ves_io_schema_policy.URLItem, len(sl))
				urlMatcher.UrlItems = urlItems
				for i, set := range sl {
					urlItems[i] = &ves_io_schema_policy.URLItem{}
					urlItemsMapStrToI := set.(map[string]interface{})

					domainChoiceTypeFound := false

					if v, ok := urlItemsMapStrToI["domain_regex"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

						domainChoiceTypeFound = true
						domainChoiceInt := &ves_io_schema_policy.URLItem_DomainRegex{}

						urlItems[i].DomainChoice = domainChoiceInt

						domainChoiceInt.DomainRegex = v.(string)

					}

					if v, ok := urlItemsMapStrToI["domain_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

						domainChoiceTypeFound = true
						domainChoiceInt := &ves_io_schema_policy.URLItem_DomainValue{}

						urlItems[i].DomainChoice = domainChoiceInt

						domainChoiceInt.DomainValue = v.(string)

					}

					pathChoiceTypeFound := false

					if v, ok := urlItemsMapStrToI["path_prefix"]; ok && !isIntfNil(v) && !pathChoiceTypeFound {

						pathChoiceTypeFound = true
						pathChoiceInt := &ves_io_schema_policy.URLItem_PathPrefix{}

						urlItems[i].PathChoice = pathChoiceInt

						pathChoiceInt.PathPrefix = v.(string)

					}

					if v, ok := urlItemsMapStrToI["path_regex"]; ok && !isIntfNil(v) && !pathChoiceTypeFound {

						pathChoiceTypeFound = true
						pathChoiceInt := &ves_io_schema_policy.URLItem_PathRegex{}

						urlItems[i].PathChoice = pathChoiceInt

						pathChoiceInt.PathRegex = v.(string)

					}

					if v, ok := urlItemsMapStrToI["path_value"]; ok && !isIntfNil(v) && !pathChoiceTypeFound {

						pathChoiceTypeFound = true
						pathChoiceInt := &ves_io_schema_policy.URLItem_PathValue{}

						urlItems[i].PathChoice = pathChoiceInt

						pathChoiceInt.PathValue = v.(string)

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("virtual_host_matcher"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		virtualHostMatcher := &ves_io_schema_policy.MatcherTypeBasic{}
		updateSpec.VirtualHostMatcher = virtualHostMatcher
		for _, set := range sl {
			virtualHostMatcherMapStrToI := set.(map[string]interface{})

			if w, ok := virtualHostMatcherMapStrToI["exact_values"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				virtualHostMatcher.ExactValues = ls
			}

			if w, ok := virtualHostMatcherMapStrToI["regex_values"]; ok && !isIntfNil(w) {
				ls := make([]string, len(w.([]interface{})))
				for i, v := range w.([]interface{}) {
					ls[i] = v.(string)
				}
				virtualHostMatcher.RegexValues = ls
			}

		}

	}

	if v, ok := d.GetOk("waf_action"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		wafAction := &ves_io_schema_policy.WafAction{}
		updateSpec.WafAction = wafAction
		for _, set := range sl {
			wafActionMapStrToI := set.(map[string]interface{})

			actionTypeTypeFound := false

			if v, ok := wafActionMapStrToI["app_firewall_detection_control"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

				actionTypeTypeFound = true
				actionTypeInt := &ves_io_schema_policy.WafAction_AppFirewallDetectionControl{}
				actionTypeInt.AppFirewallDetectionControl = &ves_io_schema_policy.AppFirewallDetectionControl{}
				wafAction.ActionType = actionTypeInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["exclude_attack_type_contexts"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						excludeAttackTypeContexts := make([]*ves_io_schema_policy.AppFirewallAttackTypeContext, len(sl))
						actionTypeInt.AppFirewallDetectionControl.ExcludeAttackTypeContexts = excludeAttackTypeContexts
						for i, set := range sl {
							excludeAttackTypeContexts[i] = &ves_io_schema_policy.AppFirewallAttackTypeContext{}
							excludeAttackTypeContextsMapStrToI := set.(map[string]interface{})

							if v, ok := excludeAttackTypeContextsMapStrToI["context"]; ok && !isIntfNil(v) {

								excludeAttackTypeContexts[i].Context = ves_io_schema_policy.DetectionContext(ves_io_schema_policy.DetectionContext_value[v.(string)])

							}

							if w, ok := excludeAttackTypeContextsMapStrToI["context_name"]; ok && !isIntfNil(w) {
								excludeAttackTypeContexts[i].ContextName = w.(string)
							}

							if v, ok := excludeAttackTypeContextsMapStrToI["exclude_attack_type"]; ok && !isIntfNil(v) {

								excludeAttackTypeContexts[i].ExcludeAttackType = ves_io_schema_app_firewall.AttackType(ves_io_schema_app_firewall.AttackType_value[v.(string)])

							}

						}

					}

					if v, ok := cs["exclude_bot_name_contexts"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						excludeBotNameContexts := make([]*ves_io_schema_policy.BotNameContext, len(sl))
						actionTypeInt.AppFirewallDetectionControl.ExcludeBotNameContexts = excludeBotNameContexts
						for i, set := range sl {
							excludeBotNameContexts[i] = &ves_io_schema_policy.BotNameContext{}
							excludeBotNameContextsMapStrToI := set.(map[string]interface{})

							if w, ok := excludeBotNameContextsMapStrToI["bot_name"]; ok && !isIntfNil(w) {
								excludeBotNameContexts[i].BotName = w.(string)
							}

						}

					}

					if v, ok := cs["exclude_signature_contexts"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						excludeSignatureContexts := make([]*ves_io_schema_policy.AppFirewallSignatureContext, len(sl))
						actionTypeInt.AppFirewallDetectionControl.ExcludeSignatureContexts = excludeSignatureContexts
						for i, set := range sl {
							excludeSignatureContexts[i] = &ves_io_schema_policy.AppFirewallSignatureContext{}
							excludeSignatureContextsMapStrToI := set.(map[string]interface{})

							if v, ok := excludeSignatureContextsMapStrToI["context"]; ok && !isIntfNil(v) {

								excludeSignatureContexts[i].Context = ves_io_schema_policy.DetectionContext(ves_io_schema_policy.DetectionContext_value[v.(string)])

							}

							if w, ok := excludeSignatureContextsMapStrToI["context_name"]; ok && !isIntfNil(w) {
								excludeSignatureContexts[i].ContextName = w.(string)
							}

							if w, ok := excludeSignatureContextsMapStrToI["signature_id"]; ok && !isIntfNil(w) {
								excludeSignatureContexts[i].SignatureId = uint32(w.(int))
							}

						}

					}

					if v, ok := cs["exclude_violation_contexts"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						excludeViolationContexts := make([]*ves_io_schema_policy.AppFirewallViolationContext, len(sl))
						actionTypeInt.AppFirewallDetectionControl.ExcludeViolationContexts = excludeViolationContexts
						for i, set := range sl {
							excludeViolationContexts[i] = &ves_io_schema_policy.AppFirewallViolationContext{}
							excludeViolationContextsMapStrToI := set.(map[string]interface{})

							if v, ok := excludeViolationContextsMapStrToI["context"]; ok && !isIntfNil(v) {

								excludeViolationContexts[i].Context = ves_io_schema_policy.DetectionContext(ves_io_schema_policy.DetectionContext_value[v.(string)])

							}

							if w, ok := excludeViolationContextsMapStrToI["context_name"]; ok && !isIntfNil(w) {
								excludeViolationContexts[i].ContextName = w.(string)
							}

							if v, ok := excludeViolationContextsMapStrToI["exclude_violation"]; ok && !isIntfNil(v) {

								excludeViolationContexts[i].ExcludeViolation = ves_io_schema_app_firewall.AppFirewallViolationType(ves_io_schema_app_firewall.AppFirewallViolationType_value[v.(string)])

							}

						}

					}

				}

			}

			if v, ok := wafActionMapStrToI["data_guard_control"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

				actionTypeTypeFound = true
				actionTypeInt := &ves_io_schema_policy.WafAction_DataGuardControl{}
				actionTypeInt.DataGuardControl = &ves_io_schema_policy.DataGuardControl{}
				wafAction.ActionType = actionTypeInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["policy_name"]; ok && !isIntfNil(v) {

						actionTypeInt.DataGuardControl.PolicyName = v.(string)

					}

				}

			}

			if v, ok := wafActionMapStrToI["jwt_claims_validation"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

				actionTypeTypeFound = true

				if v.(bool) {
					actionTypeInt := &ves_io_schema_policy.WafAction_JwtClaimsValidation{}
					actionTypeInt.JwtClaimsValidation = &ves_io_schema.Empty{}
					wafAction.ActionType = actionTypeInt
				}

			}

			if v, ok := wafActionMapStrToI["jwt_validation"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

				actionTypeTypeFound = true

				if v.(bool) {
					actionTypeInt := &ves_io_schema_policy.WafAction_JwtValidation{}
					actionTypeInt.JwtValidation = &ves_io_schema.Empty{}
					wafAction.ActionType = actionTypeInt
				}

			}

			if v, ok := wafActionMapStrToI["none"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

				actionTypeTypeFound = true

				if v.(bool) {
					actionTypeInt := &ves_io_schema_policy.WafAction_None{}
					actionTypeInt.None = &ves_io_schema.Empty{}
					wafAction.ActionType = actionTypeInt
				}

			}

			if v, ok := wafActionMapStrToI["waf_in_monitoring_mode"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

				actionTypeTypeFound = true

				if v.(bool) {
					actionTypeInt := &ves_io_schema_policy.WafAction_WafInMonitoringMode{}
					actionTypeInt.WafInMonitoringMode = &ves_io_schema.Empty{}
					wafAction.ActionType = actionTypeInt
				}

			}

			if v, ok := wafActionMapStrToI["waf_skip_processing"]; ok && !isIntfNil(v) && !actionTypeTypeFound {

				actionTypeTypeFound = true

				if v.(bool) {
					actionTypeInt := &ves_io_schema_policy.WafAction_WafSkipProcessing{}
					actionTypeInt.WafSkipProcessing = &ves_io_schema.Empty{}
					wafAction.ActionType = actionTypeInt
				}

			}

		}

	}

	log.Printf("[DEBUG] Updating Volterra ServicePolicyRule obj with struct: %+v", updateReq)

	err := client.ReplaceObject(context.Background(), ves_io_schema_service_policy_rule.ObjectType, updateReq)
	if err != nil {
		return fmt.Errorf("error updating ServicePolicyRule: %s", err)
	}

	return resourceVolterraServicePolicyRuleRead(d, meta)
}

func resourceVolterraServicePolicyRuleDelete(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	_, err := client.GetObject(context.Background(), ves_io_schema_service_policy_rule.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] ServicePolicyRule %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra ServicePolicyRule before deleting %q: %s", d.Id(), err)
	}

	log.Printf("[DEBUG] Deleting Volterra ServicePolicyRule obj with name %+v in namespace %+v", name, namespace)
	return client.DeleteObject(context.Background(), ves_io_schema_service_policy_rule.ObjectType, namespace, name)
}
